// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from LPC408x_7x_v0.7.svd, see https://github.com/posborne/cmsis-svd/tree/master/data/NXP

//go:build nxp && lpc408x_7x

/*
// LPC408x/7x M4
*/

package nxp

import (
	"runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device       = "LPC408x_7x"
	CPU          = "CM4"
	FPUPresent   = false
	NVICPrioBits = 3
)

// Interrupt numbers.
const (
	// Windowed Watchdog Timer (WWDT)
	IRQ_WWDT = 0

	// Timer0/1/2/3
	IRQ_TIMER0 = 1

	IRQ_TIMER1 = 2

	IRQ_TIMER2 = 3

	IRQ_TIMER3 = 4

	// UART0/2/3
	IRQ_UART0 = 5

	// UART1
	IRQ_UART1 = 6

	IRQ_UART2 = 7

	IRQ_UART3 = 8

	IRQ_PWM1 = 9

	// I2C bus interface
	IRQ_I2C0 = 10

	IRQ_I2C1 = 11

	IRQ_I2C2 = 12

	// SSP controller
	IRQ_SSP0 = 14

	// SSP1 controller
	IRQ_SSP1 = 15

	// Real Time Clock (RTC)
	IRQ_RTC = 17

	// System and clock control
	IRQ_EINT0 = 18

	// System and clock control
	IRQ_EINT1 = 19

	// System and clock control
	IRQ_EINT2 = 20

	// System and clock control
	IRQ_EINT3 = 21

	// Analog-to-Digital Converter (ADC)
	IRQ_ADC = 22

	// System and clock control
	IRQ_BOD = 23

	// USB device controller
	IRQ_USB = 24

	// CAN controller
	IRQ_CAN = 25

	// General Purpose DMA controller Modification
	IRQ_GPDMA = 26

	// I2S interface
	IRQ_I2S = 27

	// Ethernet
	IRQ_ETHERNET = 28

	// SD card
	IRQ_SDMMC = 29

	// Motor Control PWM
	IRQ_MCPWM = 30

	// Quadrature Encoder Interface (QEI)
	IRQ_QEI = 31

	// USB device controller
	IRQ_USB_NEED_CLK = 33

	// UART4
	IRQ_UART4 = 35

	IRQ_SSP2 = 36

	// LCD controller Modification
	IRQ_LCD = 37

	// GPIO
	IRQ_GPIOINT = 38

	// Pulse Width Modulators (PWM0/1)
	IRQ_PWM0 = 39

	// EEPROM/flash
	IRQ_EEPROM = 40

	// Comparators
	IRQ_CMP0 = 41

	// Comparators
	IRQ_CMP1 = 42

	// Highest interrupt number on this device.
	IRQ_max = 42
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//
//go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int)

//export WWDT_IRQHandler
func interruptWWDT() {
	callHandlers(IRQ_WWDT)
}

//export TIMER0_IRQHandler
func interruptTIMER0() {
	callHandlers(IRQ_TIMER0)
}

//export TIMER1_IRQHandler
func interruptTIMER1() {
	callHandlers(IRQ_TIMER1)
}

//export TIMER2_IRQHandler
func interruptTIMER2() {
	callHandlers(IRQ_TIMER2)
}

//export TIMER3_IRQHandler
func interruptTIMER3() {
	callHandlers(IRQ_TIMER3)
}

//export UART0_IRQHandler
func interruptUART0() {
	callHandlers(IRQ_UART0)
}

//export UART1_IRQHandler
func interruptUART1() {
	callHandlers(IRQ_UART1)
}

//export UART2_IRQHandler
func interruptUART2() {
	callHandlers(IRQ_UART2)
}

//export UART3_IRQHandler
func interruptUART3() {
	callHandlers(IRQ_UART3)
}

//export PWM1_IRQHandler
func interruptPWM1() {
	callHandlers(IRQ_PWM1)
}

//export I2C0_IRQHandler
func interruptI2C0() {
	callHandlers(IRQ_I2C0)
}

//export I2C1_IRQHandler
func interruptI2C1() {
	callHandlers(IRQ_I2C1)
}

//export I2C2_IRQHandler
func interruptI2C2() {
	callHandlers(IRQ_I2C2)
}

//export SSP0_IRQHandler
func interruptSSP0() {
	callHandlers(IRQ_SSP0)
}

//export SSP1_IRQHandler
func interruptSSP1() {
	callHandlers(IRQ_SSP1)
}

//export RTC_IRQHandler
func interruptRTC() {
	callHandlers(IRQ_RTC)
}

//export EINT0_IRQHandler
func interruptEINT0() {
	callHandlers(IRQ_EINT0)
}

//export EINT1_IRQHandler
func interruptEINT1() {
	callHandlers(IRQ_EINT1)
}

//export EINT2_IRQHandler
func interruptEINT2() {
	callHandlers(IRQ_EINT2)
}

//export EINT3_IRQHandler
func interruptEINT3() {
	callHandlers(IRQ_EINT3)
}

//export ADC_IRQHandler
func interruptADC() {
	callHandlers(IRQ_ADC)
}

//export BOD_IRQHandler
func interruptBOD() {
	callHandlers(IRQ_BOD)
}

//export USB_IRQHandler
func interruptUSB() {
	callHandlers(IRQ_USB)
}

//export CAN_IRQHandler
func interruptCAN() {
	callHandlers(IRQ_CAN)
}

//export GPDMA_IRQHandler
func interruptGPDMA() {
	callHandlers(IRQ_GPDMA)
}

//export I2S_IRQHandler
func interruptI2S() {
	callHandlers(IRQ_I2S)
}

//export ETHERNET_IRQHandler
func interruptETHERNET() {
	callHandlers(IRQ_ETHERNET)
}

//export SDMMC_IRQHandler
func interruptSDMMC() {
	callHandlers(IRQ_SDMMC)
}

//export MCPWM_IRQHandler
func interruptMCPWM() {
	callHandlers(IRQ_MCPWM)
}

//export QEI_IRQHandler
func interruptQEI() {
	callHandlers(IRQ_QEI)
}

//export USB_NEED_CLK_IRQHandler
func interruptUSB_NEED_CLK() {
	callHandlers(IRQ_USB_NEED_CLK)
}

//export UART4_IRQHandler
func interruptUART4() {
	callHandlers(IRQ_UART4)
}

//export SSP2_IRQHandler
func interruptSSP2() {
	callHandlers(IRQ_SSP2)
}

//export LCD_IRQHandler
func interruptLCD() {
	callHandlers(IRQ_LCD)
}

//export GPIOINT_IRQHandler
func interruptGPIOINT() {
	callHandlers(IRQ_GPIOINT)
}

//export PWM0_IRQHandler
func interruptPWM0() {
	callHandlers(IRQ_PWM0)
}

//export EEPROM_IRQHandler
func interruptEEPROM() {
	callHandlers(IRQ_EEPROM)
}

//export CMP0_IRQHandler
func interruptCMP0() {
	callHandlers(IRQ_CMP0)
}

//export CMP1_IRQHandler
func interruptCMP1() {
	callHandlers(IRQ_CMP1)
}

// Peripherals.
var (
	// EEPROM/flash
	FLASHCTRL = (*FLASHCTRL_Type)(unsafe.Pointer(uintptr(0x200000)))

	// General Purpose DMA controller Modification
	GPDMA = (*GPDMA_Type)(unsafe.Pointer(uintptr(0x20080000)))

	// Ethernet
	ETHERNET = (*ETHERNET_Type)(unsafe.Pointer(uintptr(0x20084000)))

	// LCD controller Modification
	LCD = (*LCD_Type)(unsafe.Pointer(uintptr(0x20088000)))

	// USB device controller
	USB = (*USB_Type)(unsafe.Pointer(uintptr(0x2008c000)))

	// CRC engine
	CRC = (*CRC_Type)(unsafe.Pointer(uintptr(0x20090000)))

	// GPIO
	GPIO = (*GPIO_Type)(unsafe.Pointer(uintptr(0x20098000)))

	// External Memory Controller (EMC)
	EMC = (*EMC_Type)(unsafe.Pointer(uintptr(0x2009c000)))

	// Windowed Watchdog Timer (WWDT)
	WWDT = (*WWDT_Type)(unsafe.Pointer(uintptr(0x40000000)))

	// Timer0/1/2/3
	TIMER0 = (*TIMER0_Type)(unsafe.Pointer(uintptr(0x40004000)))

	// Timer0/1/2/3
	TIMER1 = (*TIMER0_Type)(unsafe.Pointer(uintptr(0x40008000)))

	// UART0/2/3
	UART0 = (*UART0_Type)(unsafe.Pointer(uintptr(0x4000c000)))

	// UART1
	UART1 = (*UART1_Type)(unsafe.Pointer(uintptr(0x40010000)))

	// Pulse Width Modulators (PWM0/1)
	PWM0 = (*PWM_Type)(unsafe.Pointer(uintptr(0x40014000)))

	// I2C bus interface
	I2C0 = (*I2C_Type)(unsafe.Pointer(uintptr(0x4001c000)))

	// Comparators
	COMPARATOR = (*COMPARATOR_Type)(unsafe.Pointer(uintptr(0x40020000)))

	// Real Time Clock (RTC)
	RTC = (*RTC_Type)(unsafe.Pointer(uintptr(0x40024000)))

	// GPIO
	GPIOINT = (*GPIOINT_Type)(unsafe.Pointer(uintptr(0x40028080)))

	// IOCON pin configuration
	IOCON = (*IOCON_Type)(unsafe.Pointer(uintptr(0x4002c000)))

	// SSP1 controller
	SSP1 = (*SSP1_Type)(unsafe.Pointer(uintptr(0x40030000)))

	// Analog-to-Digital Converter (ADC)
	ADC = (*ADC_Type)(unsafe.Pointer(uintptr(0x40034000)))

	// CAN acceptance filter RAM
	CANAFRAM = (*CANAFRAM_Type)(unsafe.Pointer(uintptr(0x40038000)))

	// CAN controller
	CANAF = (*CANAF_Type)(unsafe.Pointer(uintptr(0x4003c000)))

	// CAN controller
	CCAN = (*CCAN_Type)(unsafe.Pointer(uintptr(0x40040000)))

	// CAN controller
	CAN1 = (*CAN_Type)(unsafe.Pointer(uintptr(0x40044000)))

	// SSP controller
	SSP0 = (*SSP1_Type)(unsafe.Pointer(uintptr(0x40088000)))

	// Digital-to-Analog Converter (DAC) Modification
	DAC = (*DAC_Type)(unsafe.Pointer(uintptr(0x4008c000)))

	// Timer0/1/2/3
	TIMER2 = (*TIMER0_Type)(unsafe.Pointer(uintptr(0x40090000)))

	// Timer0/1/2/3
	TIMER3 = (*TIMER0_Type)(unsafe.Pointer(uintptr(0x40094000)))

	// UART0/2/3
	UART2 = (*UART0_Type)(unsafe.Pointer(uintptr(0x40098000)))

	// UART0/2/3
	UART3 = (*UART0_Type)(unsafe.Pointer(uintptr(0x4009c000)))

	// UART4
	UART4 = (*UART4_Type)(unsafe.Pointer(uintptr(0x400a4000)))

	// I2S interface
	I2S = (*I2S_Type)(unsafe.Pointer(uintptr(0x400a8000)))

	// Motor Control PWM
	MCPWM = (*MCPWM_Type)(unsafe.Pointer(uintptr(0x400b8000)))

	// Quadrature Encoder Interface (QEI)
	QEI = (*QEI_Type)(unsafe.Pointer(uintptr(0x400bc000)))

	// SD card
	SDMMC = (*SDMMC_Type)(unsafe.Pointer(uintptr(0x400c0000)))

	// System and clock control
	SYSCON = (*SYSCON_Type)(unsafe.Pointer(uintptr(0x400fc000)))

	// Pulse Width Modulators (PWM0/1)
	PWM1 = (*PWM_Type)(unsafe.Pointer(uintptr(0x40018000)))

	// CAN controller
	CAN2 = (*CAN_Type)(unsafe.Pointer(uintptr(0x40048000)))

	// I2C bus interface
	I2C1 = (*I2C_Type)(unsafe.Pointer(uintptr(0x4005c000)))

	// I2C bus interface
	I2C2 = (*I2C_Type)(unsafe.Pointer(uintptr(0x400a0000)))

	// SSP controller
	SSP2 = (*SSP1_Type)(unsafe.Pointer(uintptr(0x400ac000)))
)

// EEPROM/flash
type FLASHCTRL_Type struct {
	_        [32]byte
	FMSSTART volatile.Register32 // 0x20
	FMSSTOP  volatile.Register32 // 0x24
	_        [4]byte
	FMSW0    volatile.Register32 // 0x2C
	FMSW1    volatile.Register32 // 0x30
	FMSW2    volatile.Register32 // 0x34
	FMSW3    volatile.Register32 // 0x38
	_        [68]byte
	EECMD    volatile.Register32 // 0x80
	EEADDR   volatile.Register32 // 0x84
	EEWDATA  volatile.Register32 // 0x88
	EERDATA  volatile.Register32 // 0x8C
	EEWSTATE volatile.Register32 // 0x90
	EECLKDIV volatile.Register32 // 0x94
	EEPWRDWN volatile.Register32 // 0x98
	_        [3900]byte
	ENCLR    volatile.Register32 // 0xFD8
	ENSET    volatile.Register32 // 0xFDC
	STAT     volatile.Register32 // 0xFE0
	INTEN    volatile.Register32 // 0xFE4
	STATCLR  volatile.Register32 // 0xFE8
}

// FLASHCTRL.FMSSTART: Signature start address register
func (o *FLASHCTRL_Type) SetFMSSTART_START(value uint32) {
	volatile.StoreUint32(&o.FMSSTART.Reg, volatile.LoadUint32(&o.FMSSTART.Reg)&^(0x1ffff)|value)
}
func (o *FLASHCTRL_Type) GetFMSSTART_START() uint32 {
	return volatile.LoadUint32(&o.FMSSTART.Reg) & 0x1ffff
}
func (o *FLASHCTRL_Type) SetFMSSTART_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FMSSTART.Reg, volatile.LoadUint32(&o.FMSSTART.Reg)&^(0xfffe0000)|value<<17)
}
func (o *FLASHCTRL_Type) GetFMSSTART_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FMSSTART.Reg) & 0xfffe0000) >> 17
}

// FLASHCTRL.FMSSTOP: Signature stop-address register
func (o *FLASHCTRL_Type) SetFMSSTOP_STOP(value uint32) {
	volatile.StoreUint32(&o.FMSSTOP.Reg, volatile.LoadUint32(&o.FMSSTOP.Reg)&^(0x1ffff)|value)
}
func (o *FLASHCTRL_Type) GetFMSSTOP_STOP() uint32 {
	return volatile.LoadUint32(&o.FMSSTOP.Reg) & 0x1ffff
}
func (o *FLASHCTRL_Type) SetFMSSTOP_SIG_START(value uint32) {
	volatile.StoreUint32(&o.FMSSTOP.Reg, volatile.LoadUint32(&o.FMSSTOP.Reg)&^(0x20000)|value<<17)
}
func (o *FLASHCTRL_Type) GetFMSSTOP_SIG_START() uint32 {
	return (volatile.LoadUint32(&o.FMSSTOP.Reg) & 0x20000) >> 17
}
func (o *FLASHCTRL_Type) SetFMSSTOP_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FMSSTOP.Reg, volatile.LoadUint32(&o.FMSSTOP.Reg)&^(0xfffc0000)|value<<18)
}
func (o *FLASHCTRL_Type) GetFMSSTOP_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FMSSTOP.Reg) & 0xfffc0000) >> 18
}

// FLASHCTRL.FMSW0: 128-bit signature Word 0
func (o *FLASHCTRL_Type) SetFMSW0(value uint32) {
	volatile.StoreUint32(&o.FMSW0.Reg, value)
}
func (o *FLASHCTRL_Type) GetFMSW0() uint32 {
	return volatile.LoadUint32(&o.FMSW0.Reg)
}

// FLASHCTRL.FMSW1: 128-bit signature Word 1
func (o *FLASHCTRL_Type) SetFMSW1(value uint32) {
	volatile.StoreUint32(&o.FMSW1.Reg, value)
}
func (o *FLASHCTRL_Type) GetFMSW1() uint32 {
	return volatile.LoadUint32(&o.FMSW1.Reg)
}

// FLASHCTRL.FMSW2: 128-bit signature Word 2
func (o *FLASHCTRL_Type) SetFMSW2(value uint32) {
	volatile.StoreUint32(&o.FMSW2.Reg, value)
}
func (o *FLASHCTRL_Type) GetFMSW2() uint32 {
	return volatile.LoadUint32(&o.FMSW2.Reg)
}

// FLASHCTRL.FMSW3: 128-bit signature Word 3
func (o *FLASHCTRL_Type) SetFMSW3(value uint32) {
	volatile.StoreUint32(&o.FMSW3.Reg, value)
}
func (o *FLASHCTRL_Type) GetFMSW3() uint32 {
	return volatile.LoadUint32(&o.FMSW3.Reg)
}

// FLASHCTRL.EECMD: EEPROM command register
func (o *FLASHCTRL_Type) SetEECMD_CMD(value uint32) {
	volatile.StoreUint32(&o.EECMD.Reg, volatile.LoadUint32(&o.EECMD.Reg)&^(0x7)|value)
}
func (o *FLASHCTRL_Type) GetEECMD_CMD() uint32 {
	return volatile.LoadUint32(&o.EECMD.Reg) & 0x7
}
func (o *FLASHCTRL_Type) SetEECMD_RDPREFETCH(value uint32) {
	volatile.StoreUint32(&o.EECMD.Reg, volatile.LoadUint32(&o.EECMD.Reg)&^(0x8)|value<<3)
}
func (o *FLASHCTRL_Type) GetEECMD_RDPREFETCH() uint32 {
	return (volatile.LoadUint32(&o.EECMD.Reg) & 0x8) >> 3
}
func (o *FLASHCTRL_Type) SetEECMD_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EECMD.Reg, volatile.LoadUint32(&o.EECMD.Reg)&^(0xfffffff0)|value<<4)
}
func (o *FLASHCTRL_Type) GetEECMD_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EECMD.Reg) & 0xfffffff0) >> 4
}

// FLASHCTRL.EEADDR: EEPROM address register
func (o *FLASHCTRL_Type) SetEEADDR_ADDR(value uint32) {
	volatile.StoreUint32(&o.EEADDR.Reg, volatile.LoadUint32(&o.EEADDR.Reg)&^(0xfff)|value)
}
func (o *FLASHCTRL_Type) GetEEADDR_ADDR() uint32 {
	return volatile.LoadUint32(&o.EEADDR.Reg) & 0xfff
}
func (o *FLASHCTRL_Type) SetEEADDR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EEADDR.Reg, volatile.LoadUint32(&o.EEADDR.Reg)&^(0xfffff000)|value<<12)
}
func (o *FLASHCTRL_Type) GetEEADDR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EEADDR.Reg) & 0xfffff000) >> 12
}

// FLASHCTRL.EEWDATA: EEPROM write data register
func (o *FLASHCTRL_Type) SetEEWDATA(value uint32) {
	volatile.StoreUint32(&o.EEWDATA.Reg, value)
}
func (o *FLASHCTRL_Type) GetEEWDATA() uint32 {
	return volatile.LoadUint32(&o.EEWDATA.Reg)
}

// FLASHCTRL.EERDATA: EEPROM read data register
func (o *FLASHCTRL_Type) SetEERDATA(value uint32) {
	volatile.StoreUint32(&o.EERDATA.Reg, value)
}
func (o *FLASHCTRL_Type) GetEERDATA() uint32 {
	return volatile.LoadUint32(&o.EERDATA.Reg)
}

// FLASHCTRL.EEWSTATE: EEPROM wait state register
func (o *FLASHCTRL_Type) SetEEWSTATE_PHASE3(value uint32) {
	volatile.StoreUint32(&o.EEWSTATE.Reg, volatile.LoadUint32(&o.EEWSTATE.Reg)&^(0xff)|value)
}
func (o *FLASHCTRL_Type) GetEEWSTATE_PHASE3() uint32 {
	return volatile.LoadUint32(&o.EEWSTATE.Reg) & 0xff
}
func (o *FLASHCTRL_Type) SetEEWSTATE_PHASE2(value uint32) {
	volatile.StoreUint32(&o.EEWSTATE.Reg, volatile.LoadUint32(&o.EEWSTATE.Reg)&^(0xff00)|value<<8)
}
func (o *FLASHCTRL_Type) GetEEWSTATE_PHASE2() uint32 {
	return (volatile.LoadUint32(&o.EEWSTATE.Reg) & 0xff00) >> 8
}
func (o *FLASHCTRL_Type) SetEEWSTATE_PHASE1(value uint32) {
	volatile.StoreUint32(&o.EEWSTATE.Reg, volatile.LoadUint32(&o.EEWSTATE.Reg)&^(0xff0000)|value<<16)
}
func (o *FLASHCTRL_Type) GetEEWSTATE_PHASE1() uint32 {
	return (volatile.LoadUint32(&o.EEWSTATE.Reg) & 0xff0000) >> 16
}
func (o *FLASHCTRL_Type) SetEEWSTATE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EEWSTATE.Reg, volatile.LoadUint32(&o.EEWSTATE.Reg)&^(0xff000000)|value<<24)
}
func (o *FLASHCTRL_Type) GetEEWSTATE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EEWSTATE.Reg) & 0xff000000) >> 24
}

// FLASHCTRL.EECLKDIV: EEPROM clock divider register
func (o *FLASHCTRL_Type) SetEECLKDIV_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.EECLKDIV.Reg, volatile.LoadUint32(&o.EECLKDIV.Reg)&^(0xffff)|value)
}
func (o *FLASHCTRL_Type) GetEECLKDIV_CLKDIV() uint32 {
	return volatile.LoadUint32(&o.EECLKDIV.Reg) & 0xffff
}
func (o *FLASHCTRL_Type) SetEECLKDIV_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EECLKDIV.Reg, volatile.LoadUint32(&o.EECLKDIV.Reg)&^(0xffff0000)|value<<16)
}
func (o *FLASHCTRL_Type) GetEECLKDIV_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EECLKDIV.Reg) & 0xffff0000) >> 16
}

// FLASHCTRL.EEPWRDWN: EEPROM power-down register
func (o *FLASHCTRL_Type) SetEEPWRDWN_PWRDWN(value uint32) {
	volatile.StoreUint32(&o.EEPWRDWN.Reg, volatile.LoadUint32(&o.EEPWRDWN.Reg)&^(0x1)|value)
}
func (o *FLASHCTRL_Type) GetEEPWRDWN_PWRDWN() uint32 {
	return volatile.LoadUint32(&o.EEPWRDWN.Reg) & 0x1
}
func (o *FLASHCTRL_Type) SetEEPWRDWN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EEPWRDWN.Reg, volatile.LoadUint32(&o.EEPWRDWN.Reg)&^(0xfffffffe)|value<<1)
}
func (o *FLASHCTRL_Type) GetEEPWRDWN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EEPWRDWN.Reg) & 0xfffffffe) >> 1
}

// FLASHCTRL.ENCLR: EEPROM interrupt enable clear
func (o *FLASHCTRL_Type) SetENCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENCLR.Reg, volatile.LoadUint32(&o.ENCLR.Reg)&^(0x3ffffff)|value)
}
func (o *FLASHCTRL_Type) GetENCLR_RESERVED() uint32 {
	return volatile.LoadUint32(&o.ENCLR.Reg) & 0x3ffffff
}
func (o *FLASHCTRL_Type) SetENCLR_RDWR_CLR_EN(value uint32) {
	volatile.StoreUint32(&o.ENCLR.Reg, volatile.LoadUint32(&o.ENCLR.Reg)&^(0x4000000)|value<<26)
}
func (o *FLASHCTRL_Type) GetENCLR_RDWR_CLR_EN() uint32 {
	return (volatile.LoadUint32(&o.ENCLR.Reg) & 0x4000000) >> 26
}
func (o *FLASHCTRL_Type) SetENCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENCLR.Reg, volatile.LoadUint32(&o.ENCLR.Reg)&^(0x8000000)|value<<27)
}
func (o *FLASHCTRL_Type) GetENCLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENCLR.Reg) & 0x8000000) >> 27
}
func (o *FLASHCTRL_Type) SetENCLR_PROG1_CLR_EN(value uint32) {
	volatile.StoreUint32(&o.ENCLR.Reg, volatile.LoadUint32(&o.ENCLR.Reg)&^(0x10000000)|value<<28)
}
func (o *FLASHCTRL_Type) GetENCLR_PROG1_CLR_EN() uint32 {
	return (volatile.LoadUint32(&o.ENCLR.Reg) & 0x10000000) >> 28
}
func (o *FLASHCTRL_Type) SetENCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENCLR.Reg, volatile.LoadUint32(&o.ENCLR.Reg)&^(0xe0000000)|value<<29)
}
func (o *FLASHCTRL_Type) GetENCLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENCLR.Reg) & 0xe0000000) >> 29
}

// FLASHCTRL.ENSET: EEPROM interrupt enable set
func (o *FLASHCTRL_Type) SetENSET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENSET.Reg, volatile.LoadUint32(&o.ENSET.Reg)&^(0x3ffffff)|value)
}
func (o *FLASHCTRL_Type) GetENSET_RESERVED() uint32 {
	return volatile.LoadUint32(&o.ENSET.Reg) & 0x3ffffff
}
func (o *FLASHCTRL_Type) SetENSET_RDWR_SET_EN(value uint32) {
	volatile.StoreUint32(&o.ENSET.Reg, volatile.LoadUint32(&o.ENSET.Reg)&^(0x4000000)|value<<26)
}
func (o *FLASHCTRL_Type) GetENSET_RDWR_SET_EN() uint32 {
	return (volatile.LoadUint32(&o.ENSET.Reg) & 0x4000000) >> 26
}
func (o *FLASHCTRL_Type) SetENSET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENSET.Reg, volatile.LoadUint32(&o.ENSET.Reg)&^(0x8000000)|value<<27)
}
func (o *FLASHCTRL_Type) GetENSET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENSET.Reg) & 0x8000000) >> 27
}
func (o *FLASHCTRL_Type) SetENSET_PROG1_SET_EN(value uint32) {
	volatile.StoreUint32(&o.ENSET.Reg, volatile.LoadUint32(&o.ENSET.Reg)&^(0x10000000)|value<<28)
}
func (o *FLASHCTRL_Type) GetENSET_PROG1_SET_EN() uint32 {
	return (volatile.LoadUint32(&o.ENSET.Reg) & 0x10000000) >> 28
}
func (o *FLASHCTRL_Type) SetENSET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENSET.Reg, volatile.LoadUint32(&o.ENSET.Reg)&^(0xe0000000)|value<<29)
}
func (o *FLASHCTRL_Type) GetENSET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENSET.Reg) & 0xe0000000) >> 29
}

// FLASHCTRL.STAT: Signature generation status register
func (o *FLASHCTRL_Type) SetSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x3)|value)
}
func (o *FLASHCTRL_Type) GetSTAT_RESERVED() uint32 {
	return volatile.LoadUint32(&o.STAT.Reg) & 0x3
}
func (o *FLASHCTRL_Type) SetSTAT_SIG_DONE(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x4)|value<<2)
}
func (o *FLASHCTRL_Type) GetSTAT_SIG_DONE() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x4) >> 2
}
func (o *FLASHCTRL_Type) SetSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x3fffff8)|value<<3)
}
func (o *FLASHCTRL_Type) GetSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x3fffff8) >> 3
}
func (o *FLASHCTRL_Type) SetSTAT_END_OF_RDWR(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x4000000)|value<<26)
}
func (o *FLASHCTRL_Type) GetSTAT_END_OF_RDWR() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x4000000) >> 26
}
func (o *FLASHCTRL_Type) SetSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x8000000)|value<<27)
}
func (o *FLASHCTRL_Type) GetSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x8000000) >> 27
}
func (o *FLASHCTRL_Type) SetSTAT_END_OF_PROG1(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x10000000)|value<<28)
}
func (o *FLASHCTRL_Type) GetSTAT_END_OF_PROG1() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x10000000) >> 28
}
func (o *FLASHCTRL_Type) SetSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0xe0000000)|value<<29)
}
func (o *FLASHCTRL_Type) GetSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0xe0000000) >> 29
}

// FLASHCTRL.INTEN: EEPROM interrupt enable
func (o *FLASHCTRL_Type) SetINTEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x3ffffff)|value)
}
func (o *FLASHCTRL_Type) GetINTEN_RESERVED() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x3ffffff
}
func (o *FLASHCTRL_Type) SetINTEN_EE_RW_DONE(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4000000)|value<<26)
}
func (o *FLASHCTRL_Type) GetINTEN_EE_RW_DONE() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4000000) >> 26
}
func (o *FLASHCTRL_Type) SetINTEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8000000)|value<<27)
}
func (o *FLASHCTRL_Type) GetINTEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8000000) >> 27
}
func (o *FLASHCTRL_Type) SetINTEN_EE_PROG_DONE(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10000000)|value<<28)
}
func (o *FLASHCTRL_Type) GetINTEN_EE_PROG_DONE() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10000000) >> 28
}
func (o *FLASHCTRL_Type) SetINTEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0xe0000000)|value<<29)
}
func (o *FLASHCTRL_Type) GetINTEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0xe0000000) >> 29
}

// FLASHCTRL.STATCLR: Signature generation status clear register
func (o *FLASHCTRL_Type) SetSTATCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATCLR.Reg, volatile.LoadUint32(&o.STATCLR.Reg)&^(0x3)|value)
}
func (o *FLASHCTRL_Type) GetSTATCLR_RESERVED() uint32 {
	return volatile.LoadUint32(&o.STATCLR.Reg) & 0x3
}
func (o *FLASHCTRL_Type) SetSTATCLR_SIG_DONE_CLR(value uint32) {
	volatile.StoreUint32(&o.STATCLR.Reg, volatile.LoadUint32(&o.STATCLR.Reg)&^(0x4)|value<<2)
}
func (o *FLASHCTRL_Type) GetSTATCLR_SIG_DONE_CLR() uint32 {
	return (volatile.LoadUint32(&o.STATCLR.Reg) & 0x4) >> 2
}
func (o *FLASHCTRL_Type) SetSTATCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATCLR.Reg, volatile.LoadUint32(&o.STATCLR.Reg)&^(0x3fffff8)|value<<3)
}
func (o *FLASHCTRL_Type) GetSTATCLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATCLR.Reg) & 0x3fffff8) >> 3
}
func (o *FLASHCTRL_Type) SetSTATCLR_RDWR_CLR_ST(value uint32) {
	volatile.StoreUint32(&o.STATCLR.Reg, volatile.LoadUint32(&o.STATCLR.Reg)&^(0x4000000)|value<<26)
}
func (o *FLASHCTRL_Type) GetSTATCLR_RDWR_CLR_ST() uint32 {
	return (volatile.LoadUint32(&o.STATCLR.Reg) & 0x4000000) >> 26
}
func (o *FLASHCTRL_Type) SetSTATCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATCLR.Reg, volatile.LoadUint32(&o.STATCLR.Reg)&^(0x8000000)|value<<27)
}
func (o *FLASHCTRL_Type) GetSTATCLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATCLR.Reg) & 0x8000000) >> 27
}
func (o *FLASHCTRL_Type) SetSTATCLR_PROG1_CLR_ST(value uint32) {
	volatile.StoreUint32(&o.STATCLR.Reg, volatile.LoadUint32(&o.STATCLR.Reg)&^(0x10000000)|value<<28)
}
func (o *FLASHCTRL_Type) GetSTATCLR_PROG1_CLR_ST() uint32 {
	return (volatile.LoadUint32(&o.STATCLR.Reg) & 0x10000000) >> 28
}
func (o *FLASHCTRL_Type) SetSTATCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATCLR.Reg, volatile.LoadUint32(&o.STATCLR.Reg)&^(0xe0000000)|value<<29)
}
func (o *FLASHCTRL_Type) GetSTATCLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATCLR.Reg) & 0xe0000000) >> 29
}

// General Purpose DMA controller Modification
type GPDMA_Type struct {
	INTSTAT       volatile.Register32 // 0x0
	INTTCSTAT     volatile.Register32 // 0x4
	INTTCCLEAR    volatile.Register32 // 0x8
	INTERRSTAT    volatile.Register32 // 0xC
	INTERRCLR     volatile.Register32 // 0x10
	RAWINTTCSTAT  volatile.Register32 // 0x14
	RAWINTERRSTAT volatile.Register32 // 0x18
	ENBLDCHNS     volatile.Register32 // 0x1C
	SOFTBREQ      volatile.Register32 // 0x20
	SOFTSREQ      volatile.Register32 // 0x24
	SOFTLBREQ     volatile.Register32 // 0x28
	SOFTLSREQ     volatile.Register32 // 0x2C
	CONFIG        volatile.Register32 // 0x30
	SYNC          volatile.Register32 // 0x34
	_             [200]byte
	SRCADDR0      volatile.Register32 // 0x100
	DESTADDR0     volatile.Register32 // 0x104
	LLI0          volatile.Register32 // 0x108
	CONTROL0      volatile.Register32 // 0x10C
	CONFIG0       volatile.Register32 // 0x110
	_             [12]byte
	SRCADDR1      volatile.Register32 // 0x120
	DESTADDR1     volatile.Register32 // 0x124
	LLI1          volatile.Register32 // 0x128
	CONTROL1      volatile.Register32 // 0x12C
	CONFIG1       volatile.Register32 // 0x130
	_             [12]byte
	SRCADDR2      volatile.Register32 // 0x140
	DESTADDR2     volatile.Register32 // 0x144
	LLI2          volatile.Register32 // 0x148
	CONTROL2      volatile.Register32 // 0x14C
	CONFIG2       volatile.Register32 // 0x150
	_             [12]byte
	SRCADDR3      volatile.Register32 // 0x160
	DESTADDR3     volatile.Register32 // 0x164
	LLI3          volatile.Register32 // 0x168
	CONTROL3      volatile.Register32 // 0x16C
	CONFIG3       volatile.Register32 // 0x170
	_             [12]byte
	SRCADDR4      volatile.Register32 // 0x180
	DESTADDR4     volatile.Register32 // 0x184
	LLI4          volatile.Register32 // 0x188
	CONTROL4      volatile.Register32 // 0x18C
	CONFIG4       volatile.Register32 // 0x190
	_             [12]byte
	SRCADDR5      volatile.Register32 // 0x1A0
	DESTADDR5     volatile.Register32 // 0x1A4
	LLI5          volatile.Register32 // 0x1A8
	CONTROL5      volatile.Register32 // 0x1AC
	CONFIG5       volatile.Register32 // 0x1B0
	_             [12]byte
	SRCADDR6      volatile.Register32 // 0x1C0
	DESTADDR6     volatile.Register32 // 0x1C4
	LLI6          volatile.Register32 // 0x1C8
	CONTROL6      volatile.Register32 // 0x1CC
	CONFIG6       volatile.Register32 // 0x1D0
	_             [12]byte
	SRCADDR7      volatile.Register32 // 0x1E0
	DESTADDR7     volatile.Register32 // 0x1E4
	LLI7          volatile.Register32 // 0x1E8
	CONTROL7      volatile.Register32 // 0x1EC
	CONFIG7       volatile.Register32 // 0x1F0
}

// GPDMA.INTSTAT: DMA Interrupt Status Register
func (o *GPDMA_Type) SetINTSTAT_INTSTAT0(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetINTSTAT_INTSTAT0() uint32 {
	return volatile.LoadUint32(&o.INTSTAT.Reg) & 0x1
}
func (o *GPDMA_Type) SetINTSTAT_INTSTAT1(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetINTSTAT_INTSTAT1() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetINTSTAT_INTSTAT2(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x4)|value<<2)
}
func (o *GPDMA_Type) GetINTSTAT_INTSTAT2() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x4) >> 2
}
func (o *GPDMA_Type) SetINTSTAT_INTSTAT3(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x8)|value<<3)
}
func (o *GPDMA_Type) GetINTSTAT_INTSTAT3() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x8) >> 3
}
func (o *GPDMA_Type) SetINTSTAT_INTSTAT4(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x10)|value<<4)
}
func (o *GPDMA_Type) GetINTSTAT_INTSTAT4() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x10) >> 4
}
func (o *GPDMA_Type) SetINTSTAT_INTSTAT5(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x20)|value<<5)
}
func (o *GPDMA_Type) GetINTSTAT_INTSTAT5() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x20) >> 5
}
func (o *GPDMA_Type) SetINTSTAT_INTSTAT6(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x40)|value<<6)
}
func (o *GPDMA_Type) GetINTSTAT_INTSTAT6() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x40) >> 6
}
func (o *GPDMA_Type) SetINTSTAT_INTSTAT7(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x80)|value<<7)
}
func (o *GPDMA_Type) GetINTSTAT_INTSTAT7() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x80) >> 7
}
func (o *GPDMA_Type) SetINTSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0xffffff00)|value<<8)
}
func (o *GPDMA_Type) GetINTSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0xffffff00) >> 8
}

// GPDMA.INTTCSTAT: DMA Interrupt Terminal Count Request Status Register
func (o *GPDMA_Type) SetINTTCSTAT_INTTCSTAT0(value uint32) {
	volatile.StoreUint32(&o.INTTCSTAT.Reg, volatile.LoadUint32(&o.INTTCSTAT.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetINTTCSTAT_INTTCSTAT0() uint32 {
	return volatile.LoadUint32(&o.INTTCSTAT.Reg) & 0x1
}
func (o *GPDMA_Type) SetINTTCSTAT_INTTCSTAT1(value uint32) {
	volatile.StoreUint32(&o.INTTCSTAT.Reg, volatile.LoadUint32(&o.INTTCSTAT.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetINTTCSTAT_INTTCSTAT1() uint32 {
	return (volatile.LoadUint32(&o.INTTCSTAT.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetINTTCSTAT_INTTCSTAT2(value uint32) {
	volatile.StoreUint32(&o.INTTCSTAT.Reg, volatile.LoadUint32(&o.INTTCSTAT.Reg)&^(0x4)|value<<2)
}
func (o *GPDMA_Type) GetINTTCSTAT_INTTCSTAT2() uint32 {
	return (volatile.LoadUint32(&o.INTTCSTAT.Reg) & 0x4) >> 2
}
func (o *GPDMA_Type) SetINTTCSTAT_INTTCSTAT3(value uint32) {
	volatile.StoreUint32(&o.INTTCSTAT.Reg, volatile.LoadUint32(&o.INTTCSTAT.Reg)&^(0x8)|value<<3)
}
func (o *GPDMA_Type) GetINTTCSTAT_INTTCSTAT3() uint32 {
	return (volatile.LoadUint32(&o.INTTCSTAT.Reg) & 0x8) >> 3
}
func (o *GPDMA_Type) SetINTTCSTAT_INTTCSTAT4(value uint32) {
	volatile.StoreUint32(&o.INTTCSTAT.Reg, volatile.LoadUint32(&o.INTTCSTAT.Reg)&^(0x10)|value<<4)
}
func (o *GPDMA_Type) GetINTTCSTAT_INTTCSTAT4() uint32 {
	return (volatile.LoadUint32(&o.INTTCSTAT.Reg) & 0x10) >> 4
}
func (o *GPDMA_Type) SetINTTCSTAT_INTTCSTAT5(value uint32) {
	volatile.StoreUint32(&o.INTTCSTAT.Reg, volatile.LoadUint32(&o.INTTCSTAT.Reg)&^(0x20)|value<<5)
}
func (o *GPDMA_Type) GetINTTCSTAT_INTTCSTAT5() uint32 {
	return (volatile.LoadUint32(&o.INTTCSTAT.Reg) & 0x20) >> 5
}
func (o *GPDMA_Type) SetINTTCSTAT_INTTCSTAT6(value uint32) {
	volatile.StoreUint32(&o.INTTCSTAT.Reg, volatile.LoadUint32(&o.INTTCSTAT.Reg)&^(0x40)|value<<6)
}
func (o *GPDMA_Type) GetINTTCSTAT_INTTCSTAT6() uint32 {
	return (volatile.LoadUint32(&o.INTTCSTAT.Reg) & 0x40) >> 6
}
func (o *GPDMA_Type) SetINTTCSTAT_INTTCSTAT7(value uint32) {
	volatile.StoreUint32(&o.INTTCSTAT.Reg, volatile.LoadUint32(&o.INTTCSTAT.Reg)&^(0x80)|value<<7)
}
func (o *GPDMA_Type) GetINTTCSTAT_INTTCSTAT7() uint32 {
	return (volatile.LoadUint32(&o.INTTCSTAT.Reg) & 0x80) >> 7
}
func (o *GPDMA_Type) SetINTTCSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTTCSTAT.Reg, volatile.LoadUint32(&o.INTTCSTAT.Reg)&^(0xffffff00)|value<<8)
}
func (o *GPDMA_Type) GetINTTCSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTTCSTAT.Reg) & 0xffffff00) >> 8
}

// GPDMA.INTTCCLEAR: DMA Interrupt Terminal Count Request Clear Register
func (o *GPDMA_Type) SetINTTCCLEAR_INTTCCLEAR0(value uint32) {
	volatile.StoreUint32(&o.INTTCCLEAR.Reg, volatile.LoadUint32(&o.INTTCCLEAR.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetINTTCCLEAR_INTTCCLEAR0() uint32 {
	return volatile.LoadUint32(&o.INTTCCLEAR.Reg) & 0x1
}
func (o *GPDMA_Type) SetINTTCCLEAR_INTTCCLEAR1(value uint32) {
	volatile.StoreUint32(&o.INTTCCLEAR.Reg, volatile.LoadUint32(&o.INTTCCLEAR.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetINTTCCLEAR_INTTCCLEAR1() uint32 {
	return (volatile.LoadUint32(&o.INTTCCLEAR.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetINTTCCLEAR_INTTCCLEAR2(value uint32) {
	volatile.StoreUint32(&o.INTTCCLEAR.Reg, volatile.LoadUint32(&o.INTTCCLEAR.Reg)&^(0x4)|value<<2)
}
func (o *GPDMA_Type) GetINTTCCLEAR_INTTCCLEAR2() uint32 {
	return (volatile.LoadUint32(&o.INTTCCLEAR.Reg) & 0x4) >> 2
}
func (o *GPDMA_Type) SetINTTCCLEAR_INTTCCLEAR3(value uint32) {
	volatile.StoreUint32(&o.INTTCCLEAR.Reg, volatile.LoadUint32(&o.INTTCCLEAR.Reg)&^(0x8)|value<<3)
}
func (o *GPDMA_Type) GetINTTCCLEAR_INTTCCLEAR3() uint32 {
	return (volatile.LoadUint32(&o.INTTCCLEAR.Reg) & 0x8) >> 3
}
func (o *GPDMA_Type) SetINTTCCLEAR_INTTCCLEAR4(value uint32) {
	volatile.StoreUint32(&o.INTTCCLEAR.Reg, volatile.LoadUint32(&o.INTTCCLEAR.Reg)&^(0x10)|value<<4)
}
func (o *GPDMA_Type) GetINTTCCLEAR_INTTCCLEAR4() uint32 {
	return (volatile.LoadUint32(&o.INTTCCLEAR.Reg) & 0x10) >> 4
}
func (o *GPDMA_Type) SetINTTCCLEAR_INTTCCLEAR5(value uint32) {
	volatile.StoreUint32(&o.INTTCCLEAR.Reg, volatile.LoadUint32(&o.INTTCCLEAR.Reg)&^(0x20)|value<<5)
}
func (o *GPDMA_Type) GetINTTCCLEAR_INTTCCLEAR5() uint32 {
	return (volatile.LoadUint32(&o.INTTCCLEAR.Reg) & 0x20) >> 5
}
func (o *GPDMA_Type) SetINTTCCLEAR_INTTCCLEAR6(value uint32) {
	volatile.StoreUint32(&o.INTTCCLEAR.Reg, volatile.LoadUint32(&o.INTTCCLEAR.Reg)&^(0x40)|value<<6)
}
func (o *GPDMA_Type) GetINTTCCLEAR_INTTCCLEAR6() uint32 {
	return (volatile.LoadUint32(&o.INTTCCLEAR.Reg) & 0x40) >> 6
}
func (o *GPDMA_Type) SetINTTCCLEAR_INTTCCLEAR7(value uint32) {
	volatile.StoreUint32(&o.INTTCCLEAR.Reg, volatile.LoadUint32(&o.INTTCCLEAR.Reg)&^(0x80)|value<<7)
}
func (o *GPDMA_Type) GetINTTCCLEAR_INTTCCLEAR7() uint32 {
	return (volatile.LoadUint32(&o.INTTCCLEAR.Reg) & 0x80) >> 7
}
func (o *GPDMA_Type) SetINTTCCLEAR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTTCCLEAR.Reg, volatile.LoadUint32(&o.INTTCCLEAR.Reg)&^(0xffffff00)|value<<8)
}
func (o *GPDMA_Type) GetINTTCCLEAR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTTCCLEAR.Reg) & 0xffffff00) >> 8
}

// GPDMA.INTERRSTAT: DMA Interrupt Error Status Register
func (o *GPDMA_Type) SetINTERRSTAT_INTERRSTAT0(value uint32) {
	volatile.StoreUint32(&o.INTERRSTAT.Reg, volatile.LoadUint32(&o.INTERRSTAT.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetINTERRSTAT_INTERRSTAT0() uint32 {
	return volatile.LoadUint32(&o.INTERRSTAT.Reg) & 0x1
}
func (o *GPDMA_Type) SetINTERRSTAT_INTERRSTAT1(value uint32) {
	volatile.StoreUint32(&o.INTERRSTAT.Reg, volatile.LoadUint32(&o.INTERRSTAT.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetINTERRSTAT_INTERRSTAT1() uint32 {
	return (volatile.LoadUint32(&o.INTERRSTAT.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetINTERRSTAT_INTERRSTAT2(value uint32) {
	volatile.StoreUint32(&o.INTERRSTAT.Reg, volatile.LoadUint32(&o.INTERRSTAT.Reg)&^(0x4)|value<<2)
}
func (o *GPDMA_Type) GetINTERRSTAT_INTERRSTAT2() uint32 {
	return (volatile.LoadUint32(&o.INTERRSTAT.Reg) & 0x4) >> 2
}
func (o *GPDMA_Type) SetINTERRSTAT_INTERRSTAT3(value uint32) {
	volatile.StoreUint32(&o.INTERRSTAT.Reg, volatile.LoadUint32(&o.INTERRSTAT.Reg)&^(0x8)|value<<3)
}
func (o *GPDMA_Type) GetINTERRSTAT_INTERRSTAT3() uint32 {
	return (volatile.LoadUint32(&o.INTERRSTAT.Reg) & 0x8) >> 3
}
func (o *GPDMA_Type) SetINTERRSTAT_INTERRSTAT4(value uint32) {
	volatile.StoreUint32(&o.INTERRSTAT.Reg, volatile.LoadUint32(&o.INTERRSTAT.Reg)&^(0x10)|value<<4)
}
func (o *GPDMA_Type) GetINTERRSTAT_INTERRSTAT4() uint32 {
	return (volatile.LoadUint32(&o.INTERRSTAT.Reg) & 0x10) >> 4
}
func (o *GPDMA_Type) SetINTERRSTAT_INTERRSTAT5(value uint32) {
	volatile.StoreUint32(&o.INTERRSTAT.Reg, volatile.LoadUint32(&o.INTERRSTAT.Reg)&^(0x20)|value<<5)
}
func (o *GPDMA_Type) GetINTERRSTAT_INTERRSTAT5() uint32 {
	return (volatile.LoadUint32(&o.INTERRSTAT.Reg) & 0x20) >> 5
}
func (o *GPDMA_Type) SetINTERRSTAT_INTERRSTAT6(value uint32) {
	volatile.StoreUint32(&o.INTERRSTAT.Reg, volatile.LoadUint32(&o.INTERRSTAT.Reg)&^(0x40)|value<<6)
}
func (o *GPDMA_Type) GetINTERRSTAT_INTERRSTAT6() uint32 {
	return (volatile.LoadUint32(&o.INTERRSTAT.Reg) & 0x40) >> 6
}
func (o *GPDMA_Type) SetINTERRSTAT_INTERRSTAT7(value uint32) {
	volatile.StoreUint32(&o.INTERRSTAT.Reg, volatile.LoadUint32(&o.INTERRSTAT.Reg)&^(0x80)|value<<7)
}
func (o *GPDMA_Type) GetINTERRSTAT_INTERRSTAT7() uint32 {
	return (volatile.LoadUint32(&o.INTERRSTAT.Reg) & 0x80) >> 7
}
func (o *GPDMA_Type) SetINTERRSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTERRSTAT.Reg, volatile.LoadUint32(&o.INTERRSTAT.Reg)&^(0xffffff00)|value<<8)
}
func (o *GPDMA_Type) GetINTERRSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTERRSTAT.Reg) & 0xffffff00) >> 8
}

// GPDMA.INTERRCLR: DMA Interrupt Error Clear Register
func (o *GPDMA_Type) SetINTERRCLR_INTERRCLR0(value uint32) {
	volatile.StoreUint32(&o.INTERRCLR.Reg, volatile.LoadUint32(&o.INTERRCLR.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetINTERRCLR_INTERRCLR0() uint32 {
	return volatile.LoadUint32(&o.INTERRCLR.Reg) & 0x1
}
func (o *GPDMA_Type) SetINTERRCLR_INTERRCLR1(value uint32) {
	volatile.StoreUint32(&o.INTERRCLR.Reg, volatile.LoadUint32(&o.INTERRCLR.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetINTERRCLR_INTERRCLR1() uint32 {
	return (volatile.LoadUint32(&o.INTERRCLR.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetINTERRCLR_INTERRCLR2(value uint32) {
	volatile.StoreUint32(&o.INTERRCLR.Reg, volatile.LoadUint32(&o.INTERRCLR.Reg)&^(0x4)|value<<2)
}
func (o *GPDMA_Type) GetINTERRCLR_INTERRCLR2() uint32 {
	return (volatile.LoadUint32(&o.INTERRCLR.Reg) & 0x4) >> 2
}
func (o *GPDMA_Type) SetINTERRCLR_INTERRCLR3(value uint32) {
	volatile.StoreUint32(&o.INTERRCLR.Reg, volatile.LoadUint32(&o.INTERRCLR.Reg)&^(0x8)|value<<3)
}
func (o *GPDMA_Type) GetINTERRCLR_INTERRCLR3() uint32 {
	return (volatile.LoadUint32(&o.INTERRCLR.Reg) & 0x8) >> 3
}
func (o *GPDMA_Type) SetINTERRCLR_INTERRCLR4(value uint32) {
	volatile.StoreUint32(&o.INTERRCLR.Reg, volatile.LoadUint32(&o.INTERRCLR.Reg)&^(0x10)|value<<4)
}
func (o *GPDMA_Type) GetINTERRCLR_INTERRCLR4() uint32 {
	return (volatile.LoadUint32(&o.INTERRCLR.Reg) & 0x10) >> 4
}
func (o *GPDMA_Type) SetINTERRCLR_INTERRCLR5(value uint32) {
	volatile.StoreUint32(&o.INTERRCLR.Reg, volatile.LoadUint32(&o.INTERRCLR.Reg)&^(0x20)|value<<5)
}
func (o *GPDMA_Type) GetINTERRCLR_INTERRCLR5() uint32 {
	return (volatile.LoadUint32(&o.INTERRCLR.Reg) & 0x20) >> 5
}
func (o *GPDMA_Type) SetINTERRCLR_INTERRCLR6(value uint32) {
	volatile.StoreUint32(&o.INTERRCLR.Reg, volatile.LoadUint32(&o.INTERRCLR.Reg)&^(0x40)|value<<6)
}
func (o *GPDMA_Type) GetINTERRCLR_INTERRCLR6() uint32 {
	return (volatile.LoadUint32(&o.INTERRCLR.Reg) & 0x40) >> 6
}
func (o *GPDMA_Type) SetINTERRCLR_INTERRCLR7(value uint32) {
	volatile.StoreUint32(&o.INTERRCLR.Reg, volatile.LoadUint32(&o.INTERRCLR.Reg)&^(0x80)|value<<7)
}
func (o *GPDMA_Type) GetINTERRCLR_INTERRCLR7() uint32 {
	return (volatile.LoadUint32(&o.INTERRCLR.Reg) & 0x80) >> 7
}
func (o *GPDMA_Type) SetINTERRCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTERRCLR.Reg, volatile.LoadUint32(&o.INTERRCLR.Reg)&^(0xffffff00)|value<<8)
}
func (o *GPDMA_Type) GetINTERRCLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTERRCLR.Reg) & 0xffffff00) >> 8
}

// GPDMA.RAWINTTCSTAT: DMA Raw Interrupt Terminal Count Status Register
func (o *GPDMA_Type) SetRAWINTTCSTAT_RAWINTTCSTAT0(value uint32) {
	volatile.StoreUint32(&o.RAWINTTCSTAT.Reg, volatile.LoadUint32(&o.RAWINTTCSTAT.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetRAWINTTCSTAT_RAWINTTCSTAT0() uint32 {
	return volatile.LoadUint32(&o.RAWINTTCSTAT.Reg) & 0x1
}
func (o *GPDMA_Type) SetRAWINTTCSTAT_RAWINTTCSTAT1(value uint32) {
	volatile.StoreUint32(&o.RAWINTTCSTAT.Reg, volatile.LoadUint32(&o.RAWINTTCSTAT.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetRAWINTTCSTAT_RAWINTTCSTAT1() uint32 {
	return (volatile.LoadUint32(&o.RAWINTTCSTAT.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetRAWINTTCSTAT_RAWINTTCSTAT2(value uint32) {
	volatile.StoreUint32(&o.RAWINTTCSTAT.Reg, volatile.LoadUint32(&o.RAWINTTCSTAT.Reg)&^(0x4)|value<<2)
}
func (o *GPDMA_Type) GetRAWINTTCSTAT_RAWINTTCSTAT2() uint32 {
	return (volatile.LoadUint32(&o.RAWINTTCSTAT.Reg) & 0x4) >> 2
}
func (o *GPDMA_Type) SetRAWINTTCSTAT_RAWINTTCSTAT3(value uint32) {
	volatile.StoreUint32(&o.RAWINTTCSTAT.Reg, volatile.LoadUint32(&o.RAWINTTCSTAT.Reg)&^(0x8)|value<<3)
}
func (o *GPDMA_Type) GetRAWINTTCSTAT_RAWINTTCSTAT3() uint32 {
	return (volatile.LoadUint32(&o.RAWINTTCSTAT.Reg) & 0x8) >> 3
}
func (o *GPDMA_Type) SetRAWINTTCSTAT_RAWINTTCSTAT4(value uint32) {
	volatile.StoreUint32(&o.RAWINTTCSTAT.Reg, volatile.LoadUint32(&o.RAWINTTCSTAT.Reg)&^(0x10)|value<<4)
}
func (o *GPDMA_Type) GetRAWINTTCSTAT_RAWINTTCSTAT4() uint32 {
	return (volatile.LoadUint32(&o.RAWINTTCSTAT.Reg) & 0x10) >> 4
}
func (o *GPDMA_Type) SetRAWINTTCSTAT_RAWINTTCSTAT5(value uint32) {
	volatile.StoreUint32(&o.RAWINTTCSTAT.Reg, volatile.LoadUint32(&o.RAWINTTCSTAT.Reg)&^(0x20)|value<<5)
}
func (o *GPDMA_Type) GetRAWINTTCSTAT_RAWINTTCSTAT5() uint32 {
	return (volatile.LoadUint32(&o.RAWINTTCSTAT.Reg) & 0x20) >> 5
}
func (o *GPDMA_Type) SetRAWINTTCSTAT_RAWINTTCSTAT6(value uint32) {
	volatile.StoreUint32(&o.RAWINTTCSTAT.Reg, volatile.LoadUint32(&o.RAWINTTCSTAT.Reg)&^(0x40)|value<<6)
}
func (o *GPDMA_Type) GetRAWINTTCSTAT_RAWINTTCSTAT6() uint32 {
	return (volatile.LoadUint32(&o.RAWINTTCSTAT.Reg) & 0x40) >> 6
}
func (o *GPDMA_Type) SetRAWINTTCSTAT_RAWINTTCSTAT7(value uint32) {
	volatile.StoreUint32(&o.RAWINTTCSTAT.Reg, volatile.LoadUint32(&o.RAWINTTCSTAT.Reg)&^(0x80)|value<<7)
}
func (o *GPDMA_Type) GetRAWINTTCSTAT_RAWINTTCSTAT7() uint32 {
	return (volatile.LoadUint32(&o.RAWINTTCSTAT.Reg) & 0x80) >> 7
}
func (o *GPDMA_Type) SetRAWINTTCSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RAWINTTCSTAT.Reg, volatile.LoadUint32(&o.RAWINTTCSTAT.Reg)&^(0xffffff00)|value<<8)
}
func (o *GPDMA_Type) GetRAWINTTCSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RAWINTTCSTAT.Reg) & 0xffffff00) >> 8
}

// GPDMA.RAWINTERRSTAT: DMA Raw Error Interrupt Status Register
func (o *GPDMA_Type) SetRAWINTERRSTAT_RAWINTERRSTAT0(value uint32) {
	volatile.StoreUint32(&o.RAWINTERRSTAT.Reg, volatile.LoadUint32(&o.RAWINTERRSTAT.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetRAWINTERRSTAT_RAWINTERRSTAT0() uint32 {
	return volatile.LoadUint32(&o.RAWINTERRSTAT.Reg) & 0x1
}
func (o *GPDMA_Type) SetRAWINTERRSTAT_RAWINTERRSTAT1(value uint32) {
	volatile.StoreUint32(&o.RAWINTERRSTAT.Reg, volatile.LoadUint32(&o.RAWINTERRSTAT.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetRAWINTERRSTAT_RAWINTERRSTAT1() uint32 {
	return (volatile.LoadUint32(&o.RAWINTERRSTAT.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetRAWINTERRSTAT_RAWINTERRSTAT2(value uint32) {
	volatile.StoreUint32(&o.RAWINTERRSTAT.Reg, volatile.LoadUint32(&o.RAWINTERRSTAT.Reg)&^(0x4)|value<<2)
}
func (o *GPDMA_Type) GetRAWINTERRSTAT_RAWINTERRSTAT2() uint32 {
	return (volatile.LoadUint32(&o.RAWINTERRSTAT.Reg) & 0x4) >> 2
}
func (o *GPDMA_Type) SetRAWINTERRSTAT_RAWINTERRSTAT3(value uint32) {
	volatile.StoreUint32(&o.RAWINTERRSTAT.Reg, volatile.LoadUint32(&o.RAWINTERRSTAT.Reg)&^(0x8)|value<<3)
}
func (o *GPDMA_Type) GetRAWINTERRSTAT_RAWINTERRSTAT3() uint32 {
	return (volatile.LoadUint32(&o.RAWINTERRSTAT.Reg) & 0x8) >> 3
}
func (o *GPDMA_Type) SetRAWINTERRSTAT_RAWINTERRSTAT4(value uint32) {
	volatile.StoreUint32(&o.RAWINTERRSTAT.Reg, volatile.LoadUint32(&o.RAWINTERRSTAT.Reg)&^(0x10)|value<<4)
}
func (o *GPDMA_Type) GetRAWINTERRSTAT_RAWINTERRSTAT4() uint32 {
	return (volatile.LoadUint32(&o.RAWINTERRSTAT.Reg) & 0x10) >> 4
}
func (o *GPDMA_Type) SetRAWINTERRSTAT_RAWINTERRSTAT5(value uint32) {
	volatile.StoreUint32(&o.RAWINTERRSTAT.Reg, volatile.LoadUint32(&o.RAWINTERRSTAT.Reg)&^(0x20)|value<<5)
}
func (o *GPDMA_Type) GetRAWINTERRSTAT_RAWINTERRSTAT5() uint32 {
	return (volatile.LoadUint32(&o.RAWINTERRSTAT.Reg) & 0x20) >> 5
}
func (o *GPDMA_Type) SetRAWINTERRSTAT_RAWINTERRSTAT6(value uint32) {
	volatile.StoreUint32(&o.RAWINTERRSTAT.Reg, volatile.LoadUint32(&o.RAWINTERRSTAT.Reg)&^(0x40)|value<<6)
}
func (o *GPDMA_Type) GetRAWINTERRSTAT_RAWINTERRSTAT6() uint32 {
	return (volatile.LoadUint32(&o.RAWINTERRSTAT.Reg) & 0x40) >> 6
}
func (o *GPDMA_Type) SetRAWINTERRSTAT_RAWINTERRSTAT7(value uint32) {
	volatile.StoreUint32(&o.RAWINTERRSTAT.Reg, volatile.LoadUint32(&o.RAWINTERRSTAT.Reg)&^(0x80)|value<<7)
}
func (o *GPDMA_Type) GetRAWINTERRSTAT_RAWINTERRSTAT7() uint32 {
	return (volatile.LoadUint32(&o.RAWINTERRSTAT.Reg) & 0x80) >> 7
}
func (o *GPDMA_Type) SetRAWINTERRSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RAWINTERRSTAT.Reg, volatile.LoadUint32(&o.RAWINTERRSTAT.Reg)&^(0xffffff00)|value<<8)
}
func (o *GPDMA_Type) GetRAWINTERRSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RAWINTERRSTAT.Reg) & 0xffffff00) >> 8
}

// GPDMA.ENBLDCHNS: DMA Enabled Channel Register
func (o *GPDMA_Type) SetENBLDCHNS_ENABLEDCHANNELS0(value uint32) {
	volatile.StoreUint32(&o.ENBLDCHNS.Reg, volatile.LoadUint32(&o.ENBLDCHNS.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetENBLDCHNS_ENABLEDCHANNELS0() uint32 {
	return volatile.LoadUint32(&o.ENBLDCHNS.Reg) & 0x1
}
func (o *GPDMA_Type) SetENBLDCHNS_ENABLEDCHANNELS1(value uint32) {
	volatile.StoreUint32(&o.ENBLDCHNS.Reg, volatile.LoadUint32(&o.ENBLDCHNS.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetENBLDCHNS_ENABLEDCHANNELS1() uint32 {
	return (volatile.LoadUint32(&o.ENBLDCHNS.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetENBLDCHNS_ENABLEDCHANNELS2(value uint32) {
	volatile.StoreUint32(&o.ENBLDCHNS.Reg, volatile.LoadUint32(&o.ENBLDCHNS.Reg)&^(0x4)|value<<2)
}
func (o *GPDMA_Type) GetENBLDCHNS_ENABLEDCHANNELS2() uint32 {
	return (volatile.LoadUint32(&o.ENBLDCHNS.Reg) & 0x4) >> 2
}
func (o *GPDMA_Type) SetENBLDCHNS_ENABLEDCHANNELS3(value uint32) {
	volatile.StoreUint32(&o.ENBLDCHNS.Reg, volatile.LoadUint32(&o.ENBLDCHNS.Reg)&^(0x8)|value<<3)
}
func (o *GPDMA_Type) GetENBLDCHNS_ENABLEDCHANNELS3() uint32 {
	return (volatile.LoadUint32(&o.ENBLDCHNS.Reg) & 0x8) >> 3
}
func (o *GPDMA_Type) SetENBLDCHNS_ENABLEDCHANNELS4(value uint32) {
	volatile.StoreUint32(&o.ENBLDCHNS.Reg, volatile.LoadUint32(&o.ENBLDCHNS.Reg)&^(0x10)|value<<4)
}
func (o *GPDMA_Type) GetENBLDCHNS_ENABLEDCHANNELS4() uint32 {
	return (volatile.LoadUint32(&o.ENBLDCHNS.Reg) & 0x10) >> 4
}
func (o *GPDMA_Type) SetENBLDCHNS_ENABLEDCHANNELS5(value uint32) {
	volatile.StoreUint32(&o.ENBLDCHNS.Reg, volatile.LoadUint32(&o.ENBLDCHNS.Reg)&^(0x20)|value<<5)
}
func (o *GPDMA_Type) GetENBLDCHNS_ENABLEDCHANNELS5() uint32 {
	return (volatile.LoadUint32(&o.ENBLDCHNS.Reg) & 0x20) >> 5
}
func (o *GPDMA_Type) SetENBLDCHNS_ENABLEDCHANNELS6(value uint32) {
	volatile.StoreUint32(&o.ENBLDCHNS.Reg, volatile.LoadUint32(&o.ENBLDCHNS.Reg)&^(0x40)|value<<6)
}
func (o *GPDMA_Type) GetENBLDCHNS_ENABLEDCHANNELS6() uint32 {
	return (volatile.LoadUint32(&o.ENBLDCHNS.Reg) & 0x40) >> 6
}
func (o *GPDMA_Type) SetENBLDCHNS_ENABLEDCHANNELS7(value uint32) {
	volatile.StoreUint32(&o.ENBLDCHNS.Reg, volatile.LoadUint32(&o.ENBLDCHNS.Reg)&^(0x80)|value<<7)
}
func (o *GPDMA_Type) GetENBLDCHNS_ENABLEDCHANNELS7() uint32 {
	return (volatile.LoadUint32(&o.ENBLDCHNS.Reg) & 0x80) >> 7
}
func (o *GPDMA_Type) SetENBLDCHNS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENBLDCHNS.Reg, volatile.LoadUint32(&o.ENBLDCHNS.Reg)&^(0xffffff00)|value<<8)
}
func (o *GPDMA_Type) GetENBLDCHNS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENBLDCHNS.Reg) & 0xffffff00) >> 8
}

// GPDMA.SOFTBREQ: DMA Software Burst Request Register
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ0(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ0() uint32 {
	return volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x1
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ1(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ1() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ2(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x4)|value<<2)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ2() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x4) >> 2
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ3(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x8)|value<<3)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ3() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x8) >> 3
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ4(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x10)|value<<4)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ4() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x10) >> 4
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ5(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x20)|value<<5)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ5() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x20) >> 5
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ6(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x40)|value<<6)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ6() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x40) >> 6
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ7(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x80)|value<<7)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ7() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x80) >> 7
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ8(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x100)|value<<8)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ8() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x100) >> 8
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ9(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x200)|value<<9)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ9() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x200) >> 9
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ10(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x400)|value<<10)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ10() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x400) >> 10
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ11(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x800)|value<<11)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ11() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x800) >> 11
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ12(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x1000)|value<<12)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ12() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x1000) >> 12
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ13(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x2000)|value<<13)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ13() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x2000) >> 13
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ14(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x4000)|value<<14)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ14() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x4000) >> 14
}
func (o *GPDMA_Type) SetSOFTBREQ_SOFTBREQ15(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0x8000)|value<<15)
}
func (o *GPDMA_Type) GetSOFTBREQ_SOFTBREQ15() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0x8000) >> 15
}
func (o *GPDMA_Type) SetSOFTBREQ_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SOFTBREQ.Reg, volatile.LoadUint32(&o.SOFTBREQ.Reg)&^(0xffff0000)|value<<16)
}
func (o *GPDMA_Type) GetSOFTBREQ_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SOFTBREQ.Reg) & 0xffff0000) >> 16
}

// GPDMA.SOFTSREQ: DMA Software Single Request Register
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ0(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ0() uint32 {
	return volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x1
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ1(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ1() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ2(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x4)|value<<2)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ2() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x4) >> 2
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ3(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x8)|value<<3)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ3() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x8) >> 3
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ4(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x10)|value<<4)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ4() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x10) >> 4
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ5(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x20)|value<<5)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ5() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x20) >> 5
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ6(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x40)|value<<6)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ6() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x40) >> 6
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ7(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x80)|value<<7)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ7() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x80) >> 7
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ8(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x100)|value<<8)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ8() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x100) >> 8
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ9(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x200)|value<<9)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ9() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x200) >> 9
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ10(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x400)|value<<10)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ10() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x400) >> 10
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ11(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x800)|value<<11)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ11() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x800) >> 11
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ12(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x1000)|value<<12)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ12() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x1000) >> 12
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ13(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x2000)|value<<13)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ13() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x2000) >> 13
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ14(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x4000)|value<<14)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ14() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x4000) >> 14
}
func (o *GPDMA_Type) SetSOFTSREQ_SOFTSREQ15(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0x8000)|value<<15)
}
func (o *GPDMA_Type) GetSOFTSREQ_SOFTSREQ15() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0x8000) >> 15
}
func (o *GPDMA_Type) SetSOFTSREQ_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SOFTSREQ.Reg, volatile.LoadUint32(&o.SOFTSREQ.Reg)&^(0xffff0000)|value<<16)
}
func (o *GPDMA_Type) GetSOFTSREQ_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SOFTSREQ.Reg) & 0xffff0000) >> 16
}

// GPDMA.SOFTLBREQ: DMA Software Last Burst Request Register
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ0(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ0() uint32 {
	return volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x1
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ1(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ1() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ2(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x4)|value<<2)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ2() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x4) >> 2
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ3(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x8)|value<<3)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ3() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x8) >> 3
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ4(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x10)|value<<4)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ4() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x10) >> 4
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ5(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x20)|value<<5)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ5() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x20) >> 5
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ6(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x40)|value<<6)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ6() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x40) >> 6
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ7(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x80)|value<<7)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ7() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x80) >> 7
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ8(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x100)|value<<8)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ8() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x100) >> 8
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ9(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x200)|value<<9)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ9() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x200) >> 9
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ10(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x400)|value<<10)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ10() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x400) >> 10
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ11(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x800)|value<<11)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ11() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x800) >> 11
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ12(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x1000)|value<<12)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ12() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x1000) >> 12
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ13(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x2000)|value<<13)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ13() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x2000) >> 13
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ14(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x4000)|value<<14)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ14() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x4000) >> 14
}
func (o *GPDMA_Type) SetSOFTLBREQ_SOFTLBREQ15(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0x8000)|value<<15)
}
func (o *GPDMA_Type) GetSOFTLBREQ_SOFTLBREQ15() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0x8000) >> 15
}
func (o *GPDMA_Type) SetSOFTLBREQ_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SOFTLBREQ.Reg, volatile.LoadUint32(&o.SOFTLBREQ.Reg)&^(0xffff0000)|value<<16)
}
func (o *GPDMA_Type) GetSOFTLBREQ_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SOFTLBREQ.Reg) & 0xffff0000) >> 16
}

// GPDMA.SOFTLSREQ: DMA Software Last Single Request Register
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ0(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ0() uint32 {
	return volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x1
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ1(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ1() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ2(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x4)|value<<2)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ2() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x4) >> 2
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ3(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x8)|value<<3)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ3() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x8) >> 3
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ4(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x10)|value<<4)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ4() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x10) >> 4
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ5(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x20)|value<<5)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ5() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x20) >> 5
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ6(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x40)|value<<6)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ6() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x40) >> 6
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ7(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x80)|value<<7)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ7() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x80) >> 7
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ8(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x100)|value<<8)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ8() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x100) >> 8
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ9(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x200)|value<<9)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ9() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x200) >> 9
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ10(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x400)|value<<10)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ10() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x400) >> 10
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ11(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x800)|value<<11)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ11() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x800) >> 11
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ12(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x1000)|value<<12)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ12() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x1000) >> 12
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ13(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x2000)|value<<13)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ13() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x2000) >> 13
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ14(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x4000)|value<<14)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ14() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x4000) >> 14
}
func (o *GPDMA_Type) SetSOFTLSREQ_SOFTLSREQ15(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0x8000)|value<<15)
}
func (o *GPDMA_Type) GetSOFTLSREQ_SOFTLSREQ15() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0x8000) >> 15
}
func (o *GPDMA_Type) SetSOFTLSREQ_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SOFTLSREQ.Reg, volatile.LoadUint32(&o.SOFTLSREQ.Reg)&^(0xffff0000)|value<<16)
}
func (o *GPDMA_Type) GetSOFTLSREQ_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SOFTLSREQ.Reg) & 0xffff0000) >> 16
}

// GPDMA.CONFIG: DMA Configuration Register
func (o *GPDMA_Type) SetCONFIG_E(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetCONFIG_E() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x1
}
func (o *GPDMA_Type) SetCONFIG_M(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetCONFIG_M() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetCONFIG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0xfffffffc)|value<<2)
}
func (o *GPDMA_Type) GetCONFIG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0xfffffffc) >> 2
}

// GPDMA.SYNC: DMA Synchronization Register
func (o *GPDMA_Type) SetSYNC_DMACSYNC0(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC0() uint32 {
	return volatile.LoadUint32(&o.SYNC.Reg) & 0x1
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC1(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x2)|value<<1)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC1() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x2) >> 1
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC2(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x4)|value<<2)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC2() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x4) >> 2
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC3(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x8)|value<<3)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC3() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x8) >> 3
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC4(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x10)|value<<4)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC4() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x10) >> 4
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC5(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x20)|value<<5)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC5() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x20) >> 5
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC6(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x40)|value<<6)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC6() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x40) >> 6
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC7(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x80)|value<<7)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC7() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x80) >> 7
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC8(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x100)|value<<8)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC8() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x100) >> 8
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC9(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x200)|value<<9)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC9() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x200) >> 9
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC10(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x400)|value<<10)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC10() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x400) >> 10
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC11(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x800)|value<<11)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC11() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x800) >> 11
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC12(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x1000)|value<<12)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC12() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x1000) >> 12
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC13(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x2000)|value<<13)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC13() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x2000) >> 13
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC14(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x4000)|value<<14)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC14() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x4000) >> 14
}
func (o *GPDMA_Type) SetSYNC_DMACSYNC15(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0x8000)|value<<15)
}
func (o *GPDMA_Type) GetSYNC_DMACSYNC15() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0x8000) >> 15
}
func (o *GPDMA_Type) SetSYNC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SYNC.Reg, volatile.LoadUint32(&o.SYNC.Reg)&^(0xffff0000)|value<<16)
}
func (o *GPDMA_Type) GetSYNC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SYNC.Reg) & 0xffff0000) >> 16
}

// GPDMA.SRCADDR0: DMA Channel 0 Source Address Register
func (o *GPDMA_Type) SetSRCADDR0(value uint32) {
	volatile.StoreUint32(&o.SRCADDR0.Reg, value)
}
func (o *GPDMA_Type) GetSRCADDR0() uint32 {
	return volatile.LoadUint32(&o.SRCADDR0.Reg)
}

// GPDMA.DESTADDR0: DMA Channel 0 Destination Address Register
func (o *GPDMA_Type) SetDESTADDR0(value uint32) {
	volatile.StoreUint32(&o.DESTADDR0.Reg, value)
}
func (o *GPDMA_Type) GetDESTADDR0() uint32 {
	return volatile.LoadUint32(&o.DESTADDR0.Reg)
}

// GPDMA.LLI0: DMA Channel 0 Linked List Item Register
func (o *GPDMA_Type) SetLLI0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LLI0.Reg, volatile.LoadUint32(&o.LLI0.Reg)&^(0x3)|value)
}
func (o *GPDMA_Type) GetLLI0_RESERVED() uint32 {
	return volatile.LoadUint32(&o.LLI0.Reg) & 0x3
}
func (o *GPDMA_Type) SetLLI0_LLI(value uint32) {
	volatile.StoreUint32(&o.LLI0.Reg, volatile.LoadUint32(&o.LLI0.Reg)&^(0xfffffffc)|value<<2)
}
func (o *GPDMA_Type) GetLLI0_LLI() uint32 {
	return (volatile.LoadUint32(&o.LLI0.Reg) & 0xfffffffc) >> 2
}

// GPDMA.CONTROL0: DMA Channel 0 Control Register
func (o *GPDMA_Type) SetCONTROL0_TRANSFERSIZE(value uint32) {
	volatile.StoreUint32(&o.CONTROL0.Reg, volatile.LoadUint32(&o.CONTROL0.Reg)&^(0xfff)|value)
}
func (o *GPDMA_Type) GetCONTROL0_TRANSFERSIZE() uint32 {
	return volatile.LoadUint32(&o.CONTROL0.Reg) & 0xfff
}
func (o *GPDMA_Type) SetCONTROL0_SBSIZE(value uint32) {
	volatile.StoreUint32(&o.CONTROL0.Reg, volatile.LoadUint32(&o.CONTROL0.Reg)&^(0x7000)|value<<12)
}
func (o *GPDMA_Type) GetCONTROL0_SBSIZE() uint32 {
	return (volatile.LoadUint32(&o.CONTROL0.Reg) & 0x7000) >> 12
}
func (o *GPDMA_Type) SetCONTROL0_DBSIZE(value uint32) {
	volatile.StoreUint32(&o.CONTROL0.Reg, volatile.LoadUint32(&o.CONTROL0.Reg)&^(0x38000)|value<<15)
}
func (o *GPDMA_Type) GetCONTROL0_DBSIZE() uint32 {
	return (volatile.LoadUint32(&o.CONTROL0.Reg) & 0x38000) >> 15
}
func (o *GPDMA_Type) SetCONTROL0_SWIDTH(value uint32) {
	volatile.StoreUint32(&o.CONTROL0.Reg, volatile.LoadUint32(&o.CONTROL0.Reg)&^(0x1c0000)|value<<18)
}
func (o *GPDMA_Type) GetCONTROL0_SWIDTH() uint32 {
	return (volatile.LoadUint32(&o.CONTROL0.Reg) & 0x1c0000) >> 18
}
func (o *GPDMA_Type) SetCONTROL0_DWIDTH(value uint32) {
	volatile.StoreUint32(&o.CONTROL0.Reg, volatile.LoadUint32(&o.CONTROL0.Reg)&^(0xe00000)|value<<21)
}
func (o *GPDMA_Type) GetCONTROL0_DWIDTH() uint32 {
	return (volatile.LoadUint32(&o.CONTROL0.Reg) & 0xe00000) >> 21
}
func (o *GPDMA_Type) SetCONTROL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONTROL0.Reg, volatile.LoadUint32(&o.CONTROL0.Reg)&^(0x3000000)|value<<24)
}
func (o *GPDMA_Type) GetCONTROL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONTROL0.Reg) & 0x3000000) >> 24
}
func (o *GPDMA_Type) SetCONTROL0_SI(value uint32) {
	volatile.StoreUint32(&o.CONTROL0.Reg, volatile.LoadUint32(&o.CONTROL0.Reg)&^(0x4000000)|value<<26)
}
func (o *GPDMA_Type) GetCONTROL0_SI() uint32 {
	return (volatile.LoadUint32(&o.CONTROL0.Reg) & 0x4000000) >> 26
}
func (o *GPDMA_Type) SetCONTROL0_DI(value uint32) {
	volatile.StoreUint32(&o.CONTROL0.Reg, volatile.LoadUint32(&o.CONTROL0.Reg)&^(0x8000000)|value<<27)
}
func (o *GPDMA_Type) GetCONTROL0_DI() uint32 {
	return (volatile.LoadUint32(&o.CONTROL0.Reg) & 0x8000000) >> 27
}
func (o *GPDMA_Type) SetCONTROL0_PROT1(value uint32) {
	volatile.StoreUint32(&o.CONTROL0.Reg, volatile.LoadUint32(&o.CONTROL0.Reg)&^(0x10000000)|value<<28)
}
func (o *GPDMA_Type) GetCONTROL0_PROT1() uint32 {
	return (volatile.LoadUint32(&o.CONTROL0.Reg) & 0x10000000) >> 28
}
func (o *GPDMA_Type) SetCONTROL0_PROT2(value uint32) {
	volatile.StoreUint32(&o.CONTROL0.Reg, volatile.LoadUint32(&o.CONTROL0.Reg)&^(0x20000000)|value<<29)
}
func (o *GPDMA_Type) GetCONTROL0_PROT2() uint32 {
	return (volatile.LoadUint32(&o.CONTROL0.Reg) & 0x20000000) >> 29
}
func (o *GPDMA_Type) SetCONTROL0_PROT3(value uint32) {
	volatile.StoreUint32(&o.CONTROL0.Reg, volatile.LoadUint32(&o.CONTROL0.Reg)&^(0x40000000)|value<<30)
}
func (o *GPDMA_Type) GetCONTROL0_PROT3() uint32 {
	return (volatile.LoadUint32(&o.CONTROL0.Reg) & 0x40000000) >> 30
}
func (o *GPDMA_Type) SetCONTROL0_I(value uint32) {
	volatile.StoreUint32(&o.CONTROL0.Reg, volatile.LoadUint32(&o.CONTROL0.Reg)&^(0x80000000)|value<<31)
}
func (o *GPDMA_Type) GetCONTROL0_I() uint32 {
	return (volatile.LoadUint32(&o.CONTROL0.Reg) & 0x80000000) >> 31
}

// GPDMA.CONFIG0: DMA Channel 0 Configuration Register[1]
func (o *GPDMA_Type) SetCONFIG0_E(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetCONFIG0_E() uint32 {
	return volatile.LoadUint32(&o.CONFIG0.Reg) & 0x1
}
func (o *GPDMA_Type) SetCONFIG0_SRCPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x3e)|value<<1)
}
func (o *GPDMA_Type) GetCONFIG0_SRCPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x3e) >> 1
}
func (o *GPDMA_Type) SetCONFIG0_DESTPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x7c0)|value<<6)
}
func (o *GPDMA_Type) GetCONFIG0_DESTPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x7c0) >> 6
}
func (o *GPDMA_Type) SetCONFIG0_TRANSFERTYPE(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x3800)|value<<11)
}
func (o *GPDMA_Type) GetCONFIG0_TRANSFERTYPE() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x3800) >> 11
}
func (o *GPDMA_Type) SetCONFIG0_IE(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x4000)|value<<14)
}
func (o *GPDMA_Type) GetCONFIG0_IE() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x4000) >> 14
}
func (o *GPDMA_Type) SetCONFIG0_ITC(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x8000)|value<<15)
}
func (o *GPDMA_Type) GetCONFIG0_ITC() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x8000) >> 15
}
func (o *GPDMA_Type) SetCONFIG0_L(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x10000)|value<<16)
}
func (o *GPDMA_Type) GetCONFIG0_L() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x10000) >> 16
}
func (o *GPDMA_Type) SetCONFIG0_A(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x20000)|value<<17)
}
func (o *GPDMA_Type) GetCONFIG0_A() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x20000) >> 17
}
func (o *GPDMA_Type) SetCONFIG0_H(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0x40000)|value<<18)
}
func (o *GPDMA_Type) GetCONFIG0_H() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0x40000) >> 18
}
func (o *GPDMA_Type) SetCONFIG0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONFIG0.Reg, volatile.LoadUint32(&o.CONFIG0.Reg)&^(0xfff80000)|value<<19)
}
func (o *GPDMA_Type) GetCONFIG0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONFIG0.Reg) & 0xfff80000) >> 19
}

// GPDMA.SRCADDR1: DMA Channel 0 Source Address Register
func (o *GPDMA_Type) SetSRCADDR1(value uint32) {
	volatile.StoreUint32(&o.SRCADDR1.Reg, value)
}
func (o *GPDMA_Type) GetSRCADDR1() uint32 {
	return volatile.LoadUint32(&o.SRCADDR1.Reg)
}

// GPDMA.DESTADDR1: DMA Channel 0 Destination Address Register
func (o *GPDMA_Type) SetDESTADDR1(value uint32) {
	volatile.StoreUint32(&o.DESTADDR1.Reg, value)
}
func (o *GPDMA_Type) GetDESTADDR1() uint32 {
	return volatile.LoadUint32(&o.DESTADDR1.Reg)
}

// GPDMA.LLI1: DMA Channel 0 Linked List Item Register
func (o *GPDMA_Type) SetLLI1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LLI1.Reg, volatile.LoadUint32(&o.LLI1.Reg)&^(0x3)|value)
}
func (o *GPDMA_Type) GetLLI1_RESERVED() uint32 {
	return volatile.LoadUint32(&o.LLI1.Reg) & 0x3
}
func (o *GPDMA_Type) SetLLI1_LLI(value uint32) {
	volatile.StoreUint32(&o.LLI1.Reg, volatile.LoadUint32(&o.LLI1.Reg)&^(0xfffffffc)|value<<2)
}
func (o *GPDMA_Type) GetLLI1_LLI() uint32 {
	return (volatile.LoadUint32(&o.LLI1.Reg) & 0xfffffffc) >> 2
}

// GPDMA.CONTROL1: DMA Channel 0 Control Register
func (o *GPDMA_Type) SetCONTROL1_TRANSFERSIZE(value uint32) {
	volatile.StoreUint32(&o.CONTROL1.Reg, volatile.LoadUint32(&o.CONTROL1.Reg)&^(0xfff)|value)
}
func (o *GPDMA_Type) GetCONTROL1_TRANSFERSIZE() uint32 {
	return volatile.LoadUint32(&o.CONTROL1.Reg) & 0xfff
}
func (o *GPDMA_Type) SetCONTROL1_SBSIZE(value uint32) {
	volatile.StoreUint32(&o.CONTROL1.Reg, volatile.LoadUint32(&o.CONTROL1.Reg)&^(0x7000)|value<<12)
}
func (o *GPDMA_Type) GetCONTROL1_SBSIZE() uint32 {
	return (volatile.LoadUint32(&o.CONTROL1.Reg) & 0x7000) >> 12
}
func (o *GPDMA_Type) SetCONTROL1_DBSIZE(value uint32) {
	volatile.StoreUint32(&o.CONTROL1.Reg, volatile.LoadUint32(&o.CONTROL1.Reg)&^(0x38000)|value<<15)
}
func (o *GPDMA_Type) GetCONTROL1_DBSIZE() uint32 {
	return (volatile.LoadUint32(&o.CONTROL1.Reg) & 0x38000) >> 15
}
func (o *GPDMA_Type) SetCONTROL1_SWIDTH(value uint32) {
	volatile.StoreUint32(&o.CONTROL1.Reg, volatile.LoadUint32(&o.CONTROL1.Reg)&^(0x1c0000)|value<<18)
}
func (o *GPDMA_Type) GetCONTROL1_SWIDTH() uint32 {
	return (volatile.LoadUint32(&o.CONTROL1.Reg) & 0x1c0000) >> 18
}
func (o *GPDMA_Type) SetCONTROL1_DWIDTH(value uint32) {
	volatile.StoreUint32(&o.CONTROL1.Reg, volatile.LoadUint32(&o.CONTROL1.Reg)&^(0xe00000)|value<<21)
}
func (o *GPDMA_Type) GetCONTROL1_DWIDTH() uint32 {
	return (volatile.LoadUint32(&o.CONTROL1.Reg) & 0xe00000) >> 21
}
func (o *GPDMA_Type) SetCONTROL1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONTROL1.Reg, volatile.LoadUint32(&o.CONTROL1.Reg)&^(0x3000000)|value<<24)
}
func (o *GPDMA_Type) GetCONTROL1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONTROL1.Reg) & 0x3000000) >> 24
}
func (o *GPDMA_Type) SetCONTROL1_SI(value uint32) {
	volatile.StoreUint32(&o.CONTROL1.Reg, volatile.LoadUint32(&o.CONTROL1.Reg)&^(0x4000000)|value<<26)
}
func (o *GPDMA_Type) GetCONTROL1_SI() uint32 {
	return (volatile.LoadUint32(&o.CONTROL1.Reg) & 0x4000000) >> 26
}
func (o *GPDMA_Type) SetCONTROL1_DI(value uint32) {
	volatile.StoreUint32(&o.CONTROL1.Reg, volatile.LoadUint32(&o.CONTROL1.Reg)&^(0x8000000)|value<<27)
}
func (o *GPDMA_Type) GetCONTROL1_DI() uint32 {
	return (volatile.LoadUint32(&o.CONTROL1.Reg) & 0x8000000) >> 27
}
func (o *GPDMA_Type) SetCONTROL1_PROT1(value uint32) {
	volatile.StoreUint32(&o.CONTROL1.Reg, volatile.LoadUint32(&o.CONTROL1.Reg)&^(0x10000000)|value<<28)
}
func (o *GPDMA_Type) GetCONTROL1_PROT1() uint32 {
	return (volatile.LoadUint32(&o.CONTROL1.Reg) & 0x10000000) >> 28
}
func (o *GPDMA_Type) SetCONTROL1_PROT2(value uint32) {
	volatile.StoreUint32(&o.CONTROL1.Reg, volatile.LoadUint32(&o.CONTROL1.Reg)&^(0x20000000)|value<<29)
}
func (o *GPDMA_Type) GetCONTROL1_PROT2() uint32 {
	return (volatile.LoadUint32(&o.CONTROL1.Reg) & 0x20000000) >> 29
}
func (o *GPDMA_Type) SetCONTROL1_PROT3(value uint32) {
	volatile.StoreUint32(&o.CONTROL1.Reg, volatile.LoadUint32(&o.CONTROL1.Reg)&^(0x40000000)|value<<30)
}
func (o *GPDMA_Type) GetCONTROL1_PROT3() uint32 {
	return (volatile.LoadUint32(&o.CONTROL1.Reg) & 0x40000000) >> 30
}
func (o *GPDMA_Type) SetCONTROL1_I(value uint32) {
	volatile.StoreUint32(&o.CONTROL1.Reg, volatile.LoadUint32(&o.CONTROL1.Reg)&^(0x80000000)|value<<31)
}
func (o *GPDMA_Type) GetCONTROL1_I() uint32 {
	return (volatile.LoadUint32(&o.CONTROL1.Reg) & 0x80000000) >> 31
}

// GPDMA.CONFIG1: DMA Channel 0 Configuration Register[1]
func (o *GPDMA_Type) SetCONFIG1_E(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetCONFIG1_E() uint32 {
	return volatile.LoadUint32(&o.CONFIG1.Reg) & 0x1
}
func (o *GPDMA_Type) SetCONFIG1_SRCPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x3e)|value<<1)
}
func (o *GPDMA_Type) GetCONFIG1_SRCPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x3e) >> 1
}
func (o *GPDMA_Type) SetCONFIG1_DESTPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x7c0)|value<<6)
}
func (o *GPDMA_Type) GetCONFIG1_DESTPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x7c0) >> 6
}
func (o *GPDMA_Type) SetCONFIG1_TRANSFERTYPE(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x3800)|value<<11)
}
func (o *GPDMA_Type) GetCONFIG1_TRANSFERTYPE() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x3800) >> 11
}
func (o *GPDMA_Type) SetCONFIG1_IE(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x4000)|value<<14)
}
func (o *GPDMA_Type) GetCONFIG1_IE() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x4000) >> 14
}
func (o *GPDMA_Type) SetCONFIG1_ITC(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x8000)|value<<15)
}
func (o *GPDMA_Type) GetCONFIG1_ITC() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x8000) >> 15
}
func (o *GPDMA_Type) SetCONFIG1_L(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x10000)|value<<16)
}
func (o *GPDMA_Type) GetCONFIG1_L() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x10000) >> 16
}
func (o *GPDMA_Type) SetCONFIG1_A(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x20000)|value<<17)
}
func (o *GPDMA_Type) GetCONFIG1_A() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x20000) >> 17
}
func (o *GPDMA_Type) SetCONFIG1_H(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0x40000)|value<<18)
}
func (o *GPDMA_Type) GetCONFIG1_H() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0x40000) >> 18
}
func (o *GPDMA_Type) SetCONFIG1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONFIG1.Reg, volatile.LoadUint32(&o.CONFIG1.Reg)&^(0xfff80000)|value<<19)
}
func (o *GPDMA_Type) GetCONFIG1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONFIG1.Reg) & 0xfff80000) >> 19
}

// GPDMA.SRCADDR2: DMA Channel 0 Source Address Register
func (o *GPDMA_Type) SetSRCADDR2(value uint32) {
	volatile.StoreUint32(&o.SRCADDR2.Reg, value)
}
func (o *GPDMA_Type) GetSRCADDR2() uint32 {
	return volatile.LoadUint32(&o.SRCADDR2.Reg)
}

// GPDMA.DESTADDR2: DMA Channel 0 Destination Address Register
func (o *GPDMA_Type) SetDESTADDR2(value uint32) {
	volatile.StoreUint32(&o.DESTADDR2.Reg, value)
}
func (o *GPDMA_Type) GetDESTADDR2() uint32 {
	return volatile.LoadUint32(&o.DESTADDR2.Reg)
}

// GPDMA.LLI2: DMA Channel 0 Linked List Item Register
func (o *GPDMA_Type) SetLLI2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LLI2.Reg, volatile.LoadUint32(&o.LLI2.Reg)&^(0x3)|value)
}
func (o *GPDMA_Type) GetLLI2_RESERVED() uint32 {
	return volatile.LoadUint32(&o.LLI2.Reg) & 0x3
}
func (o *GPDMA_Type) SetLLI2_LLI(value uint32) {
	volatile.StoreUint32(&o.LLI2.Reg, volatile.LoadUint32(&o.LLI2.Reg)&^(0xfffffffc)|value<<2)
}
func (o *GPDMA_Type) GetLLI2_LLI() uint32 {
	return (volatile.LoadUint32(&o.LLI2.Reg) & 0xfffffffc) >> 2
}

// GPDMA.CONTROL2: DMA Channel 0 Control Register
func (o *GPDMA_Type) SetCONTROL2_TRANSFERSIZE(value uint32) {
	volatile.StoreUint32(&o.CONTROL2.Reg, volatile.LoadUint32(&o.CONTROL2.Reg)&^(0xfff)|value)
}
func (o *GPDMA_Type) GetCONTROL2_TRANSFERSIZE() uint32 {
	return volatile.LoadUint32(&o.CONTROL2.Reg) & 0xfff
}
func (o *GPDMA_Type) SetCONTROL2_SBSIZE(value uint32) {
	volatile.StoreUint32(&o.CONTROL2.Reg, volatile.LoadUint32(&o.CONTROL2.Reg)&^(0x7000)|value<<12)
}
func (o *GPDMA_Type) GetCONTROL2_SBSIZE() uint32 {
	return (volatile.LoadUint32(&o.CONTROL2.Reg) & 0x7000) >> 12
}
func (o *GPDMA_Type) SetCONTROL2_DBSIZE(value uint32) {
	volatile.StoreUint32(&o.CONTROL2.Reg, volatile.LoadUint32(&o.CONTROL2.Reg)&^(0x38000)|value<<15)
}
func (o *GPDMA_Type) GetCONTROL2_DBSIZE() uint32 {
	return (volatile.LoadUint32(&o.CONTROL2.Reg) & 0x38000) >> 15
}
func (o *GPDMA_Type) SetCONTROL2_SWIDTH(value uint32) {
	volatile.StoreUint32(&o.CONTROL2.Reg, volatile.LoadUint32(&o.CONTROL2.Reg)&^(0x1c0000)|value<<18)
}
func (o *GPDMA_Type) GetCONTROL2_SWIDTH() uint32 {
	return (volatile.LoadUint32(&o.CONTROL2.Reg) & 0x1c0000) >> 18
}
func (o *GPDMA_Type) SetCONTROL2_DWIDTH(value uint32) {
	volatile.StoreUint32(&o.CONTROL2.Reg, volatile.LoadUint32(&o.CONTROL2.Reg)&^(0xe00000)|value<<21)
}
func (o *GPDMA_Type) GetCONTROL2_DWIDTH() uint32 {
	return (volatile.LoadUint32(&o.CONTROL2.Reg) & 0xe00000) >> 21
}
func (o *GPDMA_Type) SetCONTROL2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONTROL2.Reg, volatile.LoadUint32(&o.CONTROL2.Reg)&^(0x3000000)|value<<24)
}
func (o *GPDMA_Type) GetCONTROL2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONTROL2.Reg) & 0x3000000) >> 24
}
func (o *GPDMA_Type) SetCONTROL2_SI(value uint32) {
	volatile.StoreUint32(&o.CONTROL2.Reg, volatile.LoadUint32(&o.CONTROL2.Reg)&^(0x4000000)|value<<26)
}
func (o *GPDMA_Type) GetCONTROL2_SI() uint32 {
	return (volatile.LoadUint32(&o.CONTROL2.Reg) & 0x4000000) >> 26
}
func (o *GPDMA_Type) SetCONTROL2_DI(value uint32) {
	volatile.StoreUint32(&o.CONTROL2.Reg, volatile.LoadUint32(&o.CONTROL2.Reg)&^(0x8000000)|value<<27)
}
func (o *GPDMA_Type) GetCONTROL2_DI() uint32 {
	return (volatile.LoadUint32(&o.CONTROL2.Reg) & 0x8000000) >> 27
}
func (o *GPDMA_Type) SetCONTROL2_PROT1(value uint32) {
	volatile.StoreUint32(&o.CONTROL2.Reg, volatile.LoadUint32(&o.CONTROL2.Reg)&^(0x10000000)|value<<28)
}
func (o *GPDMA_Type) GetCONTROL2_PROT1() uint32 {
	return (volatile.LoadUint32(&o.CONTROL2.Reg) & 0x10000000) >> 28
}
func (o *GPDMA_Type) SetCONTROL2_PROT2(value uint32) {
	volatile.StoreUint32(&o.CONTROL2.Reg, volatile.LoadUint32(&o.CONTROL2.Reg)&^(0x20000000)|value<<29)
}
func (o *GPDMA_Type) GetCONTROL2_PROT2() uint32 {
	return (volatile.LoadUint32(&o.CONTROL2.Reg) & 0x20000000) >> 29
}
func (o *GPDMA_Type) SetCONTROL2_PROT3(value uint32) {
	volatile.StoreUint32(&o.CONTROL2.Reg, volatile.LoadUint32(&o.CONTROL2.Reg)&^(0x40000000)|value<<30)
}
func (o *GPDMA_Type) GetCONTROL2_PROT3() uint32 {
	return (volatile.LoadUint32(&o.CONTROL2.Reg) & 0x40000000) >> 30
}
func (o *GPDMA_Type) SetCONTROL2_I(value uint32) {
	volatile.StoreUint32(&o.CONTROL2.Reg, volatile.LoadUint32(&o.CONTROL2.Reg)&^(0x80000000)|value<<31)
}
func (o *GPDMA_Type) GetCONTROL2_I() uint32 {
	return (volatile.LoadUint32(&o.CONTROL2.Reg) & 0x80000000) >> 31
}

// GPDMA.CONFIG2: DMA Channel 0 Configuration Register[1]
func (o *GPDMA_Type) SetCONFIG2_E(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetCONFIG2_E() uint32 {
	return volatile.LoadUint32(&o.CONFIG2.Reg) & 0x1
}
func (o *GPDMA_Type) SetCONFIG2_SRCPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x3e)|value<<1)
}
func (o *GPDMA_Type) GetCONFIG2_SRCPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x3e) >> 1
}
func (o *GPDMA_Type) SetCONFIG2_DESTPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x7c0)|value<<6)
}
func (o *GPDMA_Type) GetCONFIG2_DESTPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x7c0) >> 6
}
func (o *GPDMA_Type) SetCONFIG2_TRANSFERTYPE(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x3800)|value<<11)
}
func (o *GPDMA_Type) GetCONFIG2_TRANSFERTYPE() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x3800) >> 11
}
func (o *GPDMA_Type) SetCONFIG2_IE(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x4000)|value<<14)
}
func (o *GPDMA_Type) GetCONFIG2_IE() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x4000) >> 14
}
func (o *GPDMA_Type) SetCONFIG2_ITC(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x8000)|value<<15)
}
func (o *GPDMA_Type) GetCONFIG2_ITC() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x8000) >> 15
}
func (o *GPDMA_Type) SetCONFIG2_L(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x10000)|value<<16)
}
func (o *GPDMA_Type) GetCONFIG2_L() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x10000) >> 16
}
func (o *GPDMA_Type) SetCONFIG2_A(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x20000)|value<<17)
}
func (o *GPDMA_Type) GetCONFIG2_A() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x20000) >> 17
}
func (o *GPDMA_Type) SetCONFIG2_H(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0x40000)|value<<18)
}
func (o *GPDMA_Type) GetCONFIG2_H() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0x40000) >> 18
}
func (o *GPDMA_Type) SetCONFIG2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONFIG2.Reg, volatile.LoadUint32(&o.CONFIG2.Reg)&^(0xfff80000)|value<<19)
}
func (o *GPDMA_Type) GetCONFIG2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONFIG2.Reg) & 0xfff80000) >> 19
}

// GPDMA.SRCADDR3: DMA Channel 0 Source Address Register
func (o *GPDMA_Type) SetSRCADDR3(value uint32) {
	volatile.StoreUint32(&o.SRCADDR3.Reg, value)
}
func (o *GPDMA_Type) GetSRCADDR3() uint32 {
	return volatile.LoadUint32(&o.SRCADDR3.Reg)
}

// GPDMA.DESTADDR3: DMA Channel 0 Destination Address Register
func (o *GPDMA_Type) SetDESTADDR3(value uint32) {
	volatile.StoreUint32(&o.DESTADDR3.Reg, value)
}
func (o *GPDMA_Type) GetDESTADDR3() uint32 {
	return volatile.LoadUint32(&o.DESTADDR3.Reg)
}

// GPDMA.LLI3: DMA Channel 0 Linked List Item Register
func (o *GPDMA_Type) SetLLI3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LLI3.Reg, volatile.LoadUint32(&o.LLI3.Reg)&^(0x3)|value)
}
func (o *GPDMA_Type) GetLLI3_RESERVED() uint32 {
	return volatile.LoadUint32(&o.LLI3.Reg) & 0x3
}
func (o *GPDMA_Type) SetLLI3_LLI(value uint32) {
	volatile.StoreUint32(&o.LLI3.Reg, volatile.LoadUint32(&o.LLI3.Reg)&^(0xfffffffc)|value<<2)
}
func (o *GPDMA_Type) GetLLI3_LLI() uint32 {
	return (volatile.LoadUint32(&o.LLI3.Reg) & 0xfffffffc) >> 2
}

// GPDMA.CONTROL3: DMA Channel 0 Control Register
func (o *GPDMA_Type) SetCONTROL3_TRANSFERSIZE(value uint32) {
	volatile.StoreUint32(&o.CONTROL3.Reg, volatile.LoadUint32(&o.CONTROL3.Reg)&^(0xfff)|value)
}
func (o *GPDMA_Type) GetCONTROL3_TRANSFERSIZE() uint32 {
	return volatile.LoadUint32(&o.CONTROL3.Reg) & 0xfff
}
func (o *GPDMA_Type) SetCONTROL3_SBSIZE(value uint32) {
	volatile.StoreUint32(&o.CONTROL3.Reg, volatile.LoadUint32(&o.CONTROL3.Reg)&^(0x7000)|value<<12)
}
func (o *GPDMA_Type) GetCONTROL3_SBSIZE() uint32 {
	return (volatile.LoadUint32(&o.CONTROL3.Reg) & 0x7000) >> 12
}
func (o *GPDMA_Type) SetCONTROL3_DBSIZE(value uint32) {
	volatile.StoreUint32(&o.CONTROL3.Reg, volatile.LoadUint32(&o.CONTROL3.Reg)&^(0x38000)|value<<15)
}
func (o *GPDMA_Type) GetCONTROL3_DBSIZE() uint32 {
	return (volatile.LoadUint32(&o.CONTROL3.Reg) & 0x38000) >> 15
}
func (o *GPDMA_Type) SetCONTROL3_SWIDTH(value uint32) {
	volatile.StoreUint32(&o.CONTROL3.Reg, volatile.LoadUint32(&o.CONTROL3.Reg)&^(0x1c0000)|value<<18)
}
func (o *GPDMA_Type) GetCONTROL3_SWIDTH() uint32 {
	return (volatile.LoadUint32(&o.CONTROL3.Reg) & 0x1c0000) >> 18
}
func (o *GPDMA_Type) SetCONTROL3_DWIDTH(value uint32) {
	volatile.StoreUint32(&o.CONTROL3.Reg, volatile.LoadUint32(&o.CONTROL3.Reg)&^(0xe00000)|value<<21)
}
func (o *GPDMA_Type) GetCONTROL3_DWIDTH() uint32 {
	return (volatile.LoadUint32(&o.CONTROL3.Reg) & 0xe00000) >> 21
}
func (o *GPDMA_Type) SetCONTROL3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONTROL3.Reg, volatile.LoadUint32(&o.CONTROL3.Reg)&^(0x3000000)|value<<24)
}
func (o *GPDMA_Type) GetCONTROL3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONTROL3.Reg) & 0x3000000) >> 24
}
func (o *GPDMA_Type) SetCONTROL3_SI(value uint32) {
	volatile.StoreUint32(&o.CONTROL3.Reg, volatile.LoadUint32(&o.CONTROL3.Reg)&^(0x4000000)|value<<26)
}
func (o *GPDMA_Type) GetCONTROL3_SI() uint32 {
	return (volatile.LoadUint32(&o.CONTROL3.Reg) & 0x4000000) >> 26
}
func (o *GPDMA_Type) SetCONTROL3_DI(value uint32) {
	volatile.StoreUint32(&o.CONTROL3.Reg, volatile.LoadUint32(&o.CONTROL3.Reg)&^(0x8000000)|value<<27)
}
func (o *GPDMA_Type) GetCONTROL3_DI() uint32 {
	return (volatile.LoadUint32(&o.CONTROL3.Reg) & 0x8000000) >> 27
}
func (o *GPDMA_Type) SetCONTROL3_PROT1(value uint32) {
	volatile.StoreUint32(&o.CONTROL3.Reg, volatile.LoadUint32(&o.CONTROL3.Reg)&^(0x10000000)|value<<28)
}
func (o *GPDMA_Type) GetCONTROL3_PROT1() uint32 {
	return (volatile.LoadUint32(&o.CONTROL3.Reg) & 0x10000000) >> 28
}
func (o *GPDMA_Type) SetCONTROL3_PROT2(value uint32) {
	volatile.StoreUint32(&o.CONTROL3.Reg, volatile.LoadUint32(&o.CONTROL3.Reg)&^(0x20000000)|value<<29)
}
func (o *GPDMA_Type) GetCONTROL3_PROT2() uint32 {
	return (volatile.LoadUint32(&o.CONTROL3.Reg) & 0x20000000) >> 29
}
func (o *GPDMA_Type) SetCONTROL3_PROT3(value uint32) {
	volatile.StoreUint32(&o.CONTROL3.Reg, volatile.LoadUint32(&o.CONTROL3.Reg)&^(0x40000000)|value<<30)
}
func (o *GPDMA_Type) GetCONTROL3_PROT3() uint32 {
	return (volatile.LoadUint32(&o.CONTROL3.Reg) & 0x40000000) >> 30
}
func (o *GPDMA_Type) SetCONTROL3_I(value uint32) {
	volatile.StoreUint32(&o.CONTROL3.Reg, volatile.LoadUint32(&o.CONTROL3.Reg)&^(0x80000000)|value<<31)
}
func (o *GPDMA_Type) GetCONTROL3_I() uint32 {
	return (volatile.LoadUint32(&o.CONTROL3.Reg) & 0x80000000) >> 31
}

// GPDMA.CONFIG3: DMA Channel 0 Configuration Register[1]
func (o *GPDMA_Type) SetCONFIG3_E(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetCONFIG3_E() uint32 {
	return volatile.LoadUint32(&o.CONFIG3.Reg) & 0x1
}
func (o *GPDMA_Type) SetCONFIG3_SRCPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x3e)|value<<1)
}
func (o *GPDMA_Type) GetCONFIG3_SRCPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x3e) >> 1
}
func (o *GPDMA_Type) SetCONFIG3_DESTPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x7c0)|value<<6)
}
func (o *GPDMA_Type) GetCONFIG3_DESTPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x7c0) >> 6
}
func (o *GPDMA_Type) SetCONFIG3_TRANSFERTYPE(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x3800)|value<<11)
}
func (o *GPDMA_Type) GetCONFIG3_TRANSFERTYPE() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x3800) >> 11
}
func (o *GPDMA_Type) SetCONFIG3_IE(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x4000)|value<<14)
}
func (o *GPDMA_Type) GetCONFIG3_IE() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x4000) >> 14
}
func (o *GPDMA_Type) SetCONFIG3_ITC(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x8000)|value<<15)
}
func (o *GPDMA_Type) GetCONFIG3_ITC() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x8000) >> 15
}
func (o *GPDMA_Type) SetCONFIG3_L(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x10000)|value<<16)
}
func (o *GPDMA_Type) GetCONFIG3_L() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x10000) >> 16
}
func (o *GPDMA_Type) SetCONFIG3_A(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x20000)|value<<17)
}
func (o *GPDMA_Type) GetCONFIG3_A() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x20000) >> 17
}
func (o *GPDMA_Type) SetCONFIG3_H(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0x40000)|value<<18)
}
func (o *GPDMA_Type) GetCONFIG3_H() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0x40000) >> 18
}
func (o *GPDMA_Type) SetCONFIG3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONFIG3.Reg, volatile.LoadUint32(&o.CONFIG3.Reg)&^(0xfff80000)|value<<19)
}
func (o *GPDMA_Type) GetCONFIG3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONFIG3.Reg) & 0xfff80000) >> 19
}

// GPDMA.SRCADDR4: DMA Channel 0 Source Address Register
func (o *GPDMA_Type) SetSRCADDR4(value uint32) {
	volatile.StoreUint32(&o.SRCADDR4.Reg, value)
}
func (o *GPDMA_Type) GetSRCADDR4() uint32 {
	return volatile.LoadUint32(&o.SRCADDR4.Reg)
}

// GPDMA.DESTADDR4: DMA Channel 0 Destination Address Register
func (o *GPDMA_Type) SetDESTADDR4(value uint32) {
	volatile.StoreUint32(&o.DESTADDR4.Reg, value)
}
func (o *GPDMA_Type) GetDESTADDR4() uint32 {
	return volatile.LoadUint32(&o.DESTADDR4.Reg)
}

// GPDMA.LLI4: DMA Channel 0 Linked List Item Register
func (o *GPDMA_Type) SetLLI4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LLI4.Reg, volatile.LoadUint32(&o.LLI4.Reg)&^(0x3)|value)
}
func (o *GPDMA_Type) GetLLI4_RESERVED() uint32 {
	return volatile.LoadUint32(&o.LLI4.Reg) & 0x3
}
func (o *GPDMA_Type) SetLLI4_LLI(value uint32) {
	volatile.StoreUint32(&o.LLI4.Reg, volatile.LoadUint32(&o.LLI4.Reg)&^(0xfffffffc)|value<<2)
}
func (o *GPDMA_Type) GetLLI4_LLI() uint32 {
	return (volatile.LoadUint32(&o.LLI4.Reg) & 0xfffffffc) >> 2
}

// GPDMA.CONTROL4: DMA Channel 0 Control Register
func (o *GPDMA_Type) SetCONTROL4_TRANSFERSIZE(value uint32) {
	volatile.StoreUint32(&o.CONTROL4.Reg, volatile.LoadUint32(&o.CONTROL4.Reg)&^(0xfff)|value)
}
func (o *GPDMA_Type) GetCONTROL4_TRANSFERSIZE() uint32 {
	return volatile.LoadUint32(&o.CONTROL4.Reg) & 0xfff
}
func (o *GPDMA_Type) SetCONTROL4_SBSIZE(value uint32) {
	volatile.StoreUint32(&o.CONTROL4.Reg, volatile.LoadUint32(&o.CONTROL4.Reg)&^(0x7000)|value<<12)
}
func (o *GPDMA_Type) GetCONTROL4_SBSIZE() uint32 {
	return (volatile.LoadUint32(&o.CONTROL4.Reg) & 0x7000) >> 12
}
func (o *GPDMA_Type) SetCONTROL4_DBSIZE(value uint32) {
	volatile.StoreUint32(&o.CONTROL4.Reg, volatile.LoadUint32(&o.CONTROL4.Reg)&^(0x38000)|value<<15)
}
func (o *GPDMA_Type) GetCONTROL4_DBSIZE() uint32 {
	return (volatile.LoadUint32(&o.CONTROL4.Reg) & 0x38000) >> 15
}
func (o *GPDMA_Type) SetCONTROL4_SWIDTH(value uint32) {
	volatile.StoreUint32(&o.CONTROL4.Reg, volatile.LoadUint32(&o.CONTROL4.Reg)&^(0x1c0000)|value<<18)
}
func (o *GPDMA_Type) GetCONTROL4_SWIDTH() uint32 {
	return (volatile.LoadUint32(&o.CONTROL4.Reg) & 0x1c0000) >> 18
}
func (o *GPDMA_Type) SetCONTROL4_DWIDTH(value uint32) {
	volatile.StoreUint32(&o.CONTROL4.Reg, volatile.LoadUint32(&o.CONTROL4.Reg)&^(0xe00000)|value<<21)
}
func (o *GPDMA_Type) GetCONTROL4_DWIDTH() uint32 {
	return (volatile.LoadUint32(&o.CONTROL4.Reg) & 0xe00000) >> 21
}
func (o *GPDMA_Type) SetCONTROL4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONTROL4.Reg, volatile.LoadUint32(&o.CONTROL4.Reg)&^(0x3000000)|value<<24)
}
func (o *GPDMA_Type) GetCONTROL4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONTROL4.Reg) & 0x3000000) >> 24
}
func (o *GPDMA_Type) SetCONTROL4_SI(value uint32) {
	volatile.StoreUint32(&o.CONTROL4.Reg, volatile.LoadUint32(&o.CONTROL4.Reg)&^(0x4000000)|value<<26)
}
func (o *GPDMA_Type) GetCONTROL4_SI() uint32 {
	return (volatile.LoadUint32(&o.CONTROL4.Reg) & 0x4000000) >> 26
}
func (o *GPDMA_Type) SetCONTROL4_DI(value uint32) {
	volatile.StoreUint32(&o.CONTROL4.Reg, volatile.LoadUint32(&o.CONTROL4.Reg)&^(0x8000000)|value<<27)
}
func (o *GPDMA_Type) GetCONTROL4_DI() uint32 {
	return (volatile.LoadUint32(&o.CONTROL4.Reg) & 0x8000000) >> 27
}
func (o *GPDMA_Type) SetCONTROL4_PROT1(value uint32) {
	volatile.StoreUint32(&o.CONTROL4.Reg, volatile.LoadUint32(&o.CONTROL4.Reg)&^(0x10000000)|value<<28)
}
func (o *GPDMA_Type) GetCONTROL4_PROT1() uint32 {
	return (volatile.LoadUint32(&o.CONTROL4.Reg) & 0x10000000) >> 28
}
func (o *GPDMA_Type) SetCONTROL4_PROT2(value uint32) {
	volatile.StoreUint32(&o.CONTROL4.Reg, volatile.LoadUint32(&o.CONTROL4.Reg)&^(0x20000000)|value<<29)
}
func (o *GPDMA_Type) GetCONTROL4_PROT2() uint32 {
	return (volatile.LoadUint32(&o.CONTROL4.Reg) & 0x20000000) >> 29
}
func (o *GPDMA_Type) SetCONTROL4_PROT3(value uint32) {
	volatile.StoreUint32(&o.CONTROL4.Reg, volatile.LoadUint32(&o.CONTROL4.Reg)&^(0x40000000)|value<<30)
}
func (o *GPDMA_Type) GetCONTROL4_PROT3() uint32 {
	return (volatile.LoadUint32(&o.CONTROL4.Reg) & 0x40000000) >> 30
}
func (o *GPDMA_Type) SetCONTROL4_I(value uint32) {
	volatile.StoreUint32(&o.CONTROL4.Reg, volatile.LoadUint32(&o.CONTROL4.Reg)&^(0x80000000)|value<<31)
}
func (o *GPDMA_Type) GetCONTROL4_I() uint32 {
	return (volatile.LoadUint32(&o.CONTROL4.Reg) & 0x80000000) >> 31
}

// GPDMA.CONFIG4: DMA Channel 0 Configuration Register[1]
func (o *GPDMA_Type) SetCONFIG4_E(value uint32) {
	volatile.StoreUint32(&o.CONFIG4.Reg, volatile.LoadUint32(&o.CONFIG4.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetCONFIG4_E() uint32 {
	return volatile.LoadUint32(&o.CONFIG4.Reg) & 0x1
}
func (o *GPDMA_Type) SetCONFIG4_SRCPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.CONFIG4.Reg, volatile.LoadUint32(&o.CONFIG4.Reg)&^(0x3e)|value<<1)
}
func (o *GPDMA_Type) GetCONFIG4_SRCPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.CONFIG4.Reg) & 0x3e) >> 1
}
func (o *GPDMA_Type) SetCONFIG4_DESTPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.CONFIG4.Reg, volatile.LoadUint32(&o.CONFIG4.Reg)&^(0x7c0)|value<<6)
}
func (o *GPDMA_Type) GetCONFIG4_DESTPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.CONFIG4.Reg) & 0x7c0) >> 6
}
func (o *GPDMA_Type) SetCONFIG4_TRANSFERTYPE(value uint32) {
	volatile.StoreUint32(&o.CONFIG4.Reg, volatile.LoadUint32(&o.CONFIG4.Reg)&^(0x3800)|value<<11)
}
func (o *GPDMA_Type) GetCONFIG4_TRANSFERTYPE() uint32 {
	return (volatile.LoadUint32(&o.CONFIG4.Reg) & 0x3800) >> 11
}
func (o *GPDMA_Type) SetCONFIG4_IE(value uint32) {
	volatile.StoreUint32(&o.CONFIG4.Reg, volatile.LoadUint32(&o.CONFIG4.Reg)&^(0x4000)|value<<14)
}
func (o *GPDMA_Type) GetCONFIG4_IE() uint32 {
	return (volatile.LoadUint32(&o.CONFIG4.Reg) & 0x4000) >> 14
}
func (o *GPDMA_Type) SetCONFIG4_ITC(value uint32) {
	volatile.StoreUint32(&o.CONFIG4.Reg, volatile.LoadUint32(&o.CONFIG4.Reg)&^(0x8000)|value<<15)
}
func (o *GPDMA_Type) GetCONFIG4_ITC() uint32 {
	return (volatile.LoadUint32(&o.CONFIG4.Reg) & 0x8000) >> 15
}
func (o *GPDMA_Type) SetCONFIG4_L(value uint32) {
	volatile.StoreUint32(&o.CONFIG4.Reg, volatile.LoadUint32(&o.CONFIG4.Reg)&^(0x10000)|value<<16)
}
func (o *GPDMA_Type) GetCONFIG4_L() uint32 {
	return (volatile.LoadUint32(&o.CONFIG4.Reg) & 0x10000) >> 16
}
func (o *GPDMA_Type) SetCONFIG4_A(value uint32) {
	volatile.StoreUint32(&o.CONFIG4.Reg, volatile.LoadUint32(&o.CONFIG4.Reg)&^(0x20000)|value<<17)
}
func (o *GPDMA_Type) GetCONFIG4_A() uint32 {
	return (volatile.LoadUint32(&o.CONFIG4.Reg) & 0x20000) >> 17
}
func (o *GPDMA_Type) SetCONFIG4_H(value uint32) {
	volatile.StoreUint32(&o.CONFIG4.Reg, volatile.LoadUint32(&o.CONFIG4.Reg)&^(0x40000)|value<<18)
}
func (o *GPDMA_Type) GetCONFIG4_H() uint32 {
	return (volatile.LoadUint32(&o.CONFIG4.Reg) & 0x40000) >> 18
}
func (o *GPDMA_Type) SetCONFIG4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONFIG4.Reg, volatile.LoadUint32(&o.CONFIG4.Reg)&^(0xfff80000)|value<<19)
}
func (o *GPDMA_Type) GetCONFIG4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONFIG4.Reg) & 0xfff80000) >> 19
}

// GPDMA.SRCADDR5: DMA Channel 0 Source Address Register
func (o *GPDMA_Type) SetSRCADDR5(value uint32) {
	volatile.StoreUint32(&o.SRCADDR5.Reg, value)
}
func (o *GPDMA_Type) GetSRCADDR5() uint32 {
	return volatile.LoadUint32(&o.SRCADDR5.Reg)
}

// GPDMA.DESTADDR5: DMA Channel 0 Destination Address Register
func (o *GPDMA_Type) SetDESTADDR5(value uint32) {
	volatile.StoreUint32(&o.DESTADDR5.Reg, value)
}
func (o *GPDMA_Type) GetDESTADDR5() uint32 {
	return volatile.LoadUint32(&o.DESTADDR5.Reg)
}

// GPDMA.LLI5: DMA Channel 0 Linked List Item Register
func (o *GPDMA_Type) SetLLI5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LLI5.Reg, volatile.LoadUint32(&o.LLI5.Reg)&^(0x3)|value)
}
func (o *GPDMA_Type) GetLLI5_RESERVED() uint32 {
	return volatile.LoadUint32(&o.LLI5.Reg) & 0x3
}
func (o *GPDMA_Type) SetLLI5_LLI(value uint32) {
	volatile.StoreUint32(&o.LLI5.Reg, volatile.LoadUint32(&o.LLI5.Reg)&^(0xfffffffc)|value<<2)
}
func (o *GPDMA_Type) GetLLI5_LLI() uint32 {
	return (volatile.LoadUint32(&o.LLI5.Reg) & 0xfffffffc) >> 2
}

// GPDMA.CONTROL5: DMA Channel 0 Control Register
func (o *GPDMA_Type) SetCONTROL5_TRANSFERSIZE(value uint32) {
	volatile.StoreUint32(&o.CONTROL5.Reg, volatile.LoadUint32(&o.CONTROL5.Reg)&^(0xfff)|value)
}
func (o *GPDMA_Type) GetCONTROL5_TRANSFERSIZE() uint32 {
	return volatile.LoadUint32(&o.CONTROL5.Reg) & 0xfff
}
func (o *GPDMA_Type) SetCONTROL5_SBSIZE(value uint32) {
	volatile.StoreUint32(&o.CONTROL5.Reg, volatile.LoadUint32(&o.CONTROL5.Reg)&^(0x7000)|value<<12)
}
func (o *GPDMA_Type) GetCONTROL5_SBSIZE() uint32 {
	return (volatile.LoadUint32(&o.CONTROL5.Reg) & 0x7000) >> 12
}
func (o *GPDMA_Type) SetCONTROL5_DBSIZE(value uint32) {
	volatile.StoreUint32(&o.CONTROL5.Reg, volatile.LoadUint32(&o.CONTROL5.Reg)&^(0x38000)|value<<15)
}
func (o *GPDMA_Type) GetCONTROL5_DBSIZE() uint32 {
	return (volatile.LoadUint32(&o.CONTROL5.Reg) & 0x38000) >> 15
}
func (o *GPDMA_Type) SetCONTROL5_SWIDTH(value uint32) {
	volatile.StoreUint32(&o.CONTROL5.Reg, volatile.LoadUint32(&o.CONTROL5.Reg)&^(0x1c0000)|value<<18)
}
func (o *GPDMA_Type) GetCONTROL5_SWIDTH() uint32 {
	return (volatile.LoadUint32(&o.CONTROL5.Reg) & 0x1c0000) >> 18
}
func (o *GPDMA_Type) SetCONTROL5_DWIDTH(value uint32) {
	volatile.StoreUint32(&o.CONTROL5.Reg, volatile.LoadUint32(&o.CONTROL5.Reg)&^(0xe00000)|value<<21)
}
func (o *GPDMA_Type) GetCONTROL5_DWIDTH() uint32 {
	return (volatile.LoadUint32(&o.CONTROL5.Reg) & 0xe00000) >> 21
}
func (o *GPDMA_Type) SetCONTROL5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONTROL5.Reg, volatile.LoadUint32(&o.CONTROL5.Reg)&^(0x3000000)|value<<24)
}
func (o *GPDMA_Type) GetCONTROL5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONTROL5.Reg) & 0x3000000) >> 24
}
func (o *GPDMA_Type) SetCONTROL5_SI(value uint32) {
	volatile.StoreUint32(&o.CONTROL5.Reg, volatile.LoadUint32(&o.CONTROL5.Reg)&^(0x4000000)|value<<26)
}
func (o *GPDMA_Type) GetCONTROL5_SI() uint32 {
	return (volatile.LoadUint32(&o.CONTROL5.Reg) & 0x4000000) >> 26
}
func (o *GPDMA_Type) SetCONTROL5_DI(value uint32) {
	volatile.StoreUint32(&o.CONTROL5.Reg, volatile.LoadUint32(&o.CONTROL5.Reg)&^(0x8000000)|value<<27)
}
func (o *GPDMA_Type) GetCONTROL5_DI() uint32 {
	return (volatile.LoadUint32(&o.CONTROL5.Reg) & 0x8000000) >> 27
}
func (o *GPDMA_Type) SetCONTROL5_PROT1(value uint32) {
	volatile.StoreUint32(&o.CONTROL5.Reg, volatile.LoadUint32(&o.CONTROL5.Reg)&^(0x10000000)|value<<28)
}
func (o *GPDMA_Type) GetCONTROL5_PROT1() uint32 {
	return (volatile.LoadUint32(&o.CONTROL5.Reg) & 0x10000000) >> 28
}
func (o *GPDMA_Type) SetCONTROL5_PROT2(value uint32) {
	volatile.StoreUint32(&o.CONTROL5.Reg, volatile.LoadUint32(&o.CONTROL5.Reg)&^(0x20000000)|value<<29)
}
func (o *GPDMA_Type) GetCONTROL5_PROT2() uint32 {
	return (volatile.LoadUint32(&o.CONTROL5.Reg) & 0x20000000) >> 29
}
func (o *GPDMA_Type) SetCONTROL5_PROT3(value uint32) {
	volatile.StoreUint32(&o.CONTROL5.Reg, volatile.LoadUint32(&o.CONTROL5.Reg)&^(0x40000000)|value<<30)
}
func (o *GPDMA_Type) GetCONTROL5_PROT3() uint32 {
	return (volatile.LoadUint32(&o.CONTROL5.Reg) & 0x40000000) >> 30
}
func (o *GPDMA_Type) SetCONTROL5_I(value uint32) {
	volatile.StoreUint32(&o.CONTROL5.Reg, volatile.LoadUint32(&o.CONTROL5.Reg)&^(0x80000000)|value<<31)
}
func (o *GPDMA_Type) GetCONTROL5_I() uint32 {
	return (volatile.LoadUint32(&o.CONTROL5.Reg) & 0x80000000) >> 31
}

// GPDMA.CONFIG5: DMA Channel 0 Configuration Register[1]
func (o *GPDMA_Type) SetCONFIG5_E(value uint32) {
	volatile.StoreUint32(&o.CONFIG5.Reg, volatile.LoadUint32(&o.CONFIG5.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetCONFIG5_E() uint32 {
	return volatile.LoadUint32(&o.CONFIG5.Reg) & 0x1
}
func (o *GPDMA_Type) SetCONFIG5_SRCPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.CONFIG5.Reg, volatile.LoadUint32(&o.CONFIG5.Reg)&^(0x3e)|value<<1)
}
func (o *GPDMA_Type) GetCONFIG5_SRCPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.CONFIG5.Reg) & 0x3e) >> 1
}
func (o *GPDMA_Type) SetCONFIG5_DESTPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.CONFIG5.Reg, volatile.LoadUint32(&o.CONFIG5.Reg)&^(0x7c0)|value<<6)
}
func (o *GPDMA_Type) GetCONFIG5_DESTPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.CONFIG5.Reg) & 0x7c0) >> 6
}
func (o *GPDMA_Type) SetCONFIG5_TRANSFERTYPE(value uint32) {
	volatile.StoreUint32(&o.CONFIG5.Reg, volatile.LoadUint32(&o.CONFIG5.Reg)&^(0x3800)|value<<11)
}
func (o *GPDMA_Type) GetCONFIG5_TRANSFERTYPE() uint32 {
	return (volatile.LoadUint32(&o.CONFIG5.Reg) & 0x3800) >> 11
}
func (o *GPDMA_Type) SetCONFIG5_IE(value uint32) {
	volatile.StoreUint32(&o.CONFIG5.Reg, volatile.LoadUint32(&o.CONFIG5.Reg)&^(0x4000)|value<<14)
}
func (o *GPDMA_Type) GetCONFIG5_IE() uint32 {
	return (volatile.LoadUint32(&o.CONFIG5.Reg) & 0x4000) >> 14
}
func (o *GPDMA_Type) SetCONFIG5_ITC(value uint32) {
	volatile.StoreUint32(&o.CONFIG5.Reg, volatile.LoadUint32(&o.CONFIG5.Reg)&^(0x8000)|value<<15)
}
func (o *GPDMA_Type) GetCONFIG5_ITC() uint32 {
	return (volatile.LoadUint32(&o.CONFIG5.Reg) & 0x8000) >> 15
}
func (o *GPDMA_Type) SetCONFIG5_L(value uint32) {
	volatile.StoreUint32(&o.CONFIG5.Reg, volatile.LoadUint32(&o.CONFIG5.Reg)&^(0x10000)|value<<16)
}
func (o *GPDMA_Type) GetCONFIG5_L() uint32 {
	return (volatile.LoadUint32(&o.CONFIG5.Reg) & 0x10000) >> 16
}
func (o *GPDMA_Type) SetCONFIG5_A(value uint32) {
	volatile.StoreUint32(&o.CONFIG5.Reg, volatile.LoadUint32(&o.CONFIG5.Reg)&^(0x20000)|value<<17)
}
func (o *GPDMA_Type) GetCONFIG5_A() uint32 {
	return (volatile.LoadUint32(&o.CONFIG5.Reg) & 0x20000) >> 17
}
func (o *GPDMA_Type) SetCONFIG5_H(value uint32) {
	volatile.StoreUint32(&o.CONFIG5.Reg, volatile.LoadUint32(&o.CONFIG5.Reg)&^(0x40000)|value<<18)
}
func (o *GPDMA_Type) GetCONFIG5_H() uint32 {
	return (volatile.LoadUint32(&o.CONFIG5.Reg) & 0x40000) >> 18
}
func (o *GPDMA_Type) SetCONFIG5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONFIG5.Reg, volatile.LoadUint32(&o.CONFIG5.Reg)&^(0xfff80000)|value<<19)
}
func (o *GPDMA_Type) GetCONFIG5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONFIG5.Reg) & 0xfff80000) >> 19
}

// GPDMA.SRCADDR6: DMA Channel 0 Source Address Register
func (o *GPDMA_Type) SetSRCADDR6(value uint32) {
	volatile.StoreUint32(&o.SRCADDR6.Reg, value)
}
func (o *GPDMA_Type) GetSRCADDR6() uint32 {
	return volatile.LoadUint32(&o.SRCADDR6.Reg)
}

// GPDMA.DESTADDR6: DMA Channel 0 Destination Address Register
func (o *GPDMA_Type) SetDESTADDR6(value uint32) {
	volatile.StoreUint32(&o.DESTADDR6.Reg, value)
}
func (o *GPDMA_Type) GetDESTADDR6() uint32 {
	return volatile.LoadUint32(&o.DESTADDR6.Reg)
}

// GPDMA.LLI6: DMA Channel 0 Linked List Item Register
func (o *GPDMA_Type) SetLLI6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LLI6.Reg, volatile.LoadUint32(&o.LLI6.Reg)&^(0x3)|value)
}
func (o *GPDMA_Type) GetLLI6_RESERVED() uint32 {
	return volatile.LoadUint32(&o.LLI6.Reg) & 0x3
}
func (o *GPDMA_Type) SetLLI6_LLI(value uint32) {
	volatile.StoreUint32(&o.LLI6.Reg, volatile.LoadUint32(&o.LLI6.Reg)&^(0xfffffffc)|value<<2)
}
func (o *GPDMA_Type) GetLLI6_LLI() uint32 {
	return (volatile.LoadUint32(&o.LLI6.Reg) & 0xfffffffc) >> 2
}

// GPDMA.CONTROL6: DMA Channel 0 Control Register
func (o *GPDMA_Type) SetCONTROL6_TRANSFERSIZE(value uint32) {
	volatile.StoreUint32(&o.CONTROL6.Reg, volatile.LoadUint32(&o.CONTROL6.Reg)&^(0xfff)|value)
}
func (o *GPDMA_Type) GetCONTROL6_TRANSFERSIZE() uint32 {
	return volatile.LoadUint32(&o.CONTROL6.Reg) & 0xfff
}
func (o *GPDMA_Type) SetCONTROL6_SBSIZE(value uint32) {
	volatile.StoreUint32(&o.CONTROL6.Reg, volatile.LoadUint32(&o.CONTROL6.Reg)&^(0x7000)|value<<12)
}
func (o *GPDMA_Type) GetCONTROL6_SBSIZE() uint32 {
	return (volatile.LoadUint32(&o.CONTROL6.Reg) & 0x7000) >> 12
}
func (o *GPDMA_Type) SetCONTROL6_DBSIZE(value uint32) {
	volatile.StoreUint32(&o.CONTROL6.Reg, volatile.LoadUint32(&o.CONTROL6.Reg)&^(0x38000)|value<<15)
}
func (o *GPDMA_Type) GetCONTROL6_DBSIZE() uint32 {
	return (volatile.LoadUint32(&o.CONTROL6.Reg) & 0x38000) >> 15
}
func (o *GPDMA_Type) SetCONTROL6_SWIDTH(value uint32) {
	volatile.StoreUint32(&o.CONTROL6.Reg, volatile.LoadUint32(&o.CONTROL6.Reg)&^(0x1c0000)|value<<18)
}
func (o *GPDMA_Type) GetCONTROL6_SWIDTH() uint32 {
	return (volatile.LoadUint32(&o.CONTROL6.Reg) & 0x1c0000) >> 18
}
func (o *GPDMA_Type) SetCONTROL6_DWIDTH(value uint32) {
	volatile.StoreUint32(&o.CONTROL6.Reg, volatile.LoadUint32(&o.CONTROL6.Reg)&^(0xe00000)|value<<21)
}
func (o *GPDMA_Type) GetCONTROL6_DWIDTH() uint32 {
	return (volatile.LoadUint32(&o.CONTROL6.Reg) & 0xe00000) >> 21
}
func (o *GPDMA_Type) SetCONTROL6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONTROL6.Reg, volatile.LoadUint32(&o.CONTROL6.Reg)&^(0x3000000)|value<<24)
}
func (o *GPDMA_Type) GetCONTROL6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONTROL6.Reg) & 0x3000000) >> 24
}
func (o *GPDMA_Type) SetCONTROL6_SI(value uint32) {
	volatile.StoreUint32(&o.CONTROL6.Reg, volatile.LoadUint32(&o.CONTROL6.Reg)&^(0x4000000)|value<<26)
}
func (o *GPDMA_Type) GetCONTROL6_SI() uint32 {
	return (volatile.LoadUint32(&o.CONTROL6.Reg) & 0x4000000) >> 26
}
func (o *GPDMA_Type) SetCONTROL6_DI(value uint32) {
	volatile.StoreUint32(&o.CONTROL6.Reg, volatile.LoadUint32(&o.CONTROL6.Reg)&^(0x8000000)|value<<27)
}
func (o *GPDMA_Type) GetCONTROL6_DI() uint32 {
	return (volatile.LoadUint32(&o.CONTROL6.Reg) & 0x8000000) >> 27
}
func (o *GPDMA_Type) SetCONTROL6_PROT1(value uint32) {
	volatile.StoreUint32(&o.CONTROL6.Reg, volatile.LoadUint32(&o.CONTROL6.Reg)&^(0x10000000)|value<<28)
}
func (o *GPDMA_Type) GetCONTROL6_PROT1() uint32 {
	return (volatile.LoadUint32(&o.CONTROL6.Reg) & 0x10000000) >> 28
}
func (o *GPDMA_Type) SetCONTROL6_PROT2(value uint32) {
	volatile.StoreUint32(&o.CONTROL6.Reg, volatile.LoadUint32(&o.CONTROL6.Reg)&^(0x20000000)|value<<29)
}
func (o *GPDMA_Type) GetCONTROL6_PROT2() uint32 {
	return (volatile.LoadUint32(&o.CONTROL6.Reg) & 0x20000000) >> 29
}
func (o *GPDMA_Type) SetCONTROL6_PROT3(value uint32) {
	volatile.StoreUint32(&o.CONTROL6.Reg, volatile.LoadUint32(&o.CONTROL6.Reg)&^(0x40000000)|value<<30)
}
func (o *GPDMA_Type) GetCONTROL6_PROT3() uint32 {
	return (volatile.LoadUint32(&o.CONTROL6.Reg) & 0x40000000) >> 30
}
func (o *GPDMA_Type) SetCONTROL6_I(value uint32) {
	volatile.StoreUint32(&o.CONTROL6.Reg, volatile.LoadUint32(&o.CONTROL6.Reg)&^(0x80000000)|value<<31)
}
func (o *GPDMA_Type) GetCONTROL6_I() uint32 {
	return (volatile.LoadUint32(&o.CONTROL6.Reg) & 0x80000000) >> 31
}

// GPDMA.CONFIG6: DMA Channel 0 Configuration Register[1]
func (o *GPDMA_Type) SetCONFIG6_E(value uint32) {
	volatile.StoreUint32(&o.CONFIG6.Reg, volatile.LoadUint32(&o.CONFIG6.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetCONFIG6_E() uint32 {
	return volatile.LoadUint32(&o.CONFIG6.Reg) & 0x1
}
func (o *GPDMA_Type) SetCONFIG6_SRCPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.CONFIG6.Reg, volatile.LoadUint32(&o.CONFIG6.Reg)&^(0x3e)|value<<1)
}
func (o *GPDMA_Type) GetCONFIG6_SRCPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.CONFIG6.Reg) & 0x3e) >> 1
}
func (o *GPDMA_Type) SetCONFIG6_DESTPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.CONFIG6.Reg, volatile.LoadUint32(&o.CONFIG6.Reg)&^(0x7c0)|value<<6)
}
func (o *GPDMA_Type) GetCONFIG6_DESTPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.CONFIG6.Reg) & 0x7c0) >> 6
}
func (o *GPDMA_Type) SetCONFIG6_TRANSFERTYPE(value uint32) {
	volatile.StoreUint32(&o.CONFIG6.Reg, volatile.LoadUint32(&o.CONFIG6.Reg)&^(0x3800)|value<<11)
}
func (o *GPDMA_Type) GetCONFIG6_TRANSFERTYPE() uint32 {
	return (volatile.LoadUint32(&o.CONFIG6.Reg) & 0x3800) >> 11
}
func (o *GPDMA_Type) SetCONFIG6_IE(value uint32) {
	volatile.StoreUint32(&o.CONFIG6.Reg, volatile.LoadUint32(&o.CONFIG6.Reg)&^(0x4000)|value<<14)
}
func (o *GPDMA_Type) GetCONFIG6_IE() uint32 {
	return (volatile.LoadUint32(&o.CONFIG6.Reg) & 0x4000) >> 14
}
func (o *GPDMA_Type) SetCONFIG6_ITC(value uint32) {
	volatile.StoreUint32(&o.CONFIG6.Reg, volatile.LoadUint32(&o.CONFIG6.Reg)&^(0x8000)|value<<15)
}
func (o *GPDMA_Type) GetCONFIG6_ITC() uint32 {
	return (volatile.LoadUint32(&o.CONFIG6.Reg) & 0x8000) >> 15
}
func (o *GPDMA_Type) SetCONFIG6_L(value uint32) {
	volatile.StoreUint32(&o.CONFIG6.Reg, volatile.LoadUint32(&o.CONFIG6.Reg)&^(0x10000)|value<<16)
}
func (o *GPDMA_Type) GetCONFIG6_L() uint32 {
	return (volatile.LoadUint32(&o.CONFIG6.Reg) & 0x10000) >> 16
}
func (o *GPDMA_Type) SetCONFIG6_A(value uint32) {
	volatile.StoreUint32(&o.CONFIG6.Reg, volatile.LoadUint32(&o.CONFIG6.Reg)&^(0x20000)|value<<17)
}
func (o *GPDMA_Type) GetCONFIG6_A() uint32 {
	return (volatile.LoadUint32(&o.CONFIG6.Reg) & 0x20000) >> 17
}
func (o *GPDMA_Type) SetCONFIG6_H(value uint32) {
	volatile.StoreUint32(&o.CONFIG6.Reg, volatile.LoadUint32(&o.CONFIG6.Reg)&^(0x40000)|value<<18)
}
func (o *GPDMA_Type) GetCONFIG6_H() uint32 {
	return (volatile.LoadUint32(&o.CONFIG6.Reg) & 0x40000) >> 18
}
func (o *GPDMA_Type) SetCONFIG6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONFIG6.Reg, volatile.LoadUint32(&o.CONFIG6.Reg)&^(0xfff80000)|value<<19)
}
func (o *GPDMA_Type) GetCONFIG6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONFIG6.Reg) & 0xfff80000) >> 19
}

// GPDMA.SRCADDR7: DMA Channel 0 Source Address Register
func (o *GPDMA_Type) SetSRCADDR7(value uint32) {
	volatile.StoreUint32(&o.SRCADDR7.Reg, value)
}
func (o *GPDMA_Type) GetSRCADDR7() uint32 {
	return volatile.LoadUint32(&o.SRCADDR7.Reg)
}

// GPDMA.DESTADDR7: DMA Channel 0 Destination Address Register
func (o *GPDMA_Type) SetDESTADDR7(value uint32) {
	volatile.StoreUint32(&o.DESTADDR7.Reg, value)
}
func (o *GPDMA_Type) GetDESTADDR7() uint32 {
	return volatile.LoadUint32(&o.DESTADDR7.Reg)
}

// GPDMA.LLI7: DMA Channel 0 Linked List Item Register
func (o *GPDMA_Type) SetLLI7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LLI7.Reg, volatile.LoadUint32(&o.LLI7.Reg)&^(0x3)|value)
}
func (o *GPDMA_Type) GetLLI7_RESERVED() uint32 {
	return volatile.LoadUint32(&o.LLI7.Reg) & 0x3
}
func (o *GPDMA_Type) SetLLI7_LLI(value uint32) {
	volatile.StoreUint32(&o.LLI7.Reg, volatile.LoadUint32(&o.LLI7.Reg)&^(0xfffffffc)|value<<2)
}
func (o *GPDMA_Type) GetLLI7_LLI() uint32 {
	return (volatile.LoadUint32(&o.LLI7.Reg) & 0xfffffffc) >> 2
}

// GPDMA.CONTROL7: DMA Channel 0 Control Register
func (o *GPDMA_Type) SetCONTROL7_TRANSFERSIZE(value uint32) {
	volatile.StoreUint32(&o.CONTROL7.Reg, volatile.LoadUint32(&o.CONTROL7.Reg)&^(0xfff)|value)
}
func (o *GPDMA_Type) GetCONTROL7_TRANSFERSIZE() uint32 {
	return volatile.LoadUint32(&o.CONTROL7.Reg) & 0xfff
}
func (o *GPDMA_Type) SetCONTROL7_SBSIZE(value uint32) {
	volatile.StoreUint32(&o.CONTROL7.Reg, volatile.LoadUint32(&o.CONTROL7.Reg)&^(0x7000)|value<<12)
}
func (o *GPDMA_Type) GetCONTROL7_SBSIZE() uint32 {
	return (volatile.LoadUint32(&o.CONTROL7.Reg) & 0x7000) >> 12
}
func (o *GPDMA_Type) SetCONTROL7_DBSIZE(value uint32) {
	volatile.StoreUint32(&o.CONTROL7.Reg, volatile.LoadUint32(&o.CONTROL7.Reg)&^(0x38000)|value<<15)
}
func (o *GPDMA_Type) GetCONTROL7_DBSIZE() uint32 {
	return (volatile.LoadUint32(&o.CONTROL7.Reg) & 0x38000) >> 15
}
func (o *GPDMA_Type) SetCONTROL7_SWIDTH(value uint32) {
	volatile.StoreUint32(&o.CONTROL7.Reg, volatile.LoadUint32(&o.CONTROL7.Reg)&^(0x1c0000)|value<<18)
}
func (o *GPDMA_Type) GetCONTROL7_SWIDTH() uint32 {
	return (volatile.LoadUint32(&o.CONTROL7.Reg) & 0x1c0000) >> 18
}
func (o *GPDMA_Type) SetCONTROL7_DWIDTH(value uint32) {
	volatile.StoreUint32(&o.CONTROL7.Reg, volatile.LoadUint32(&o.CONTROL7.Reg)&^(0xe00000)|value<<21)
}
func (o *GPDMA_Type) GetCONTROL7_DWIDTH() uint32 {
	return (volatile.LoadUint32(&o.CONTROL7.Reg) & 0xe00000) >> 21
}
func (o *GPDMA_Type) SetCONTROL7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONTROL7.Reg, volatile.LoadUint32(&o.CONTROL7.Reg)&^(0x3000000)|value<<24)
}
func (o *GPDMA_Type) GetCONTROL7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONTROL7.Reg) & 0x3000000) >> 24
}
func (o *GPDMA_Type) SetCONTROL7_SI(value uint32) {
	volatile.StoreUint32(&o.CONTROL7.Reg, volatile.LoadUint32(&o.CONTROL7.Reg)&^(0x4000000)|value<<26)
}
func (o *GPDMA_Type) GetCONTROL7_SI() uint32 {
	return (volatile.LoadUint32(&o.CONTROL7.Reg) & 0x4000000) >> 26
}
func (o *GPDMA_Type) SetCONTROL7_DI(value uint32) {
	volatile.StoreUint32(&o.CONTROL7.Reg, volatile.LoadUint32(&o.CONTROL7.Reg)&^(0x8000000)|value<<27)
}
func (o *GPDMA_Type) GetCONTROL7_DI() uint32 {
	return (volatile.LoadUint32(&o.CONTROL7.Reg) & 0x8000000) >> 27
}
func (o *GPDMA_Type) SetCONTROL7_PROT1(value uint32) {
	volatile.StoreUint32(&o.CONTROL7.Reg, volatile.LoadUint32(&o.CONTROL7.Reg)&^(0x10000000)|value<<28)
}
func (o *GPDMA_Type) GetCONTROL7_PROT1() uint32 {
	return (volatile.LoadUint32(&o.CONTROL7.Reg) & 0x10000000) >> 28
}
func (o *GPDMA_Type) SetCONTROL7_PROT2(value uint32) {
	volatile.StoreUint32(&o.CONTROL7.Reg, volatile.LoadUint32(&o.CONTROL7.Reg)&^(0x20000000)|value<<29)
}
func (o *GPDMA_Type) GetCONTROL7_PROT2() uint32 {
	return (volatile.LoadUint32(&o.CONTROL7.Reg) & 0x20000000) >> 29
}
func (o *GPDMA_Type) SetCONTROL7_PROT3(value uint32) {
	volatile.StoreUint32(&o.CONTROL7.Reg, volatile.LoadUint32(&o.CONTROL7.Reg)&^(0x40000000)|value<<30)
}
func (o *GPDMA_Type) GetCONTROL7_PROT3() uint32 {
	return (volatile.LoadUint32(&o.CONTROL7.Reg) & 0x40000000) >> 30
}
func (o *GPDMA_Type) SetCONTROL7_I(value uint32) {
	volatile.StoreUint32(&o.CONTROL7.Reg, volatile.LoadUint32(&o.CONTROL7.Reg)&^(0x80000000)|value<<31)
}
func (o *GPDMA_Type) GetCONTROL7_I() uint32 {
	return (volatile.LoadUint32(&o.CONTROL7.Reg) & 0x80000000) >> 31
}

// GPDMA.CONFIG7: DMA Channel 0 Configuration Register[1]
func (o *GPDMA_Type) SetCONFIG7_E(value uint32) {
	volatile.StoreUint32(&o.CONFIG7.Reg, volatile.LoadUint32(&o.CONFIG7.Reg)&^(0x1)|value)
}
func (o *GPDMA_Type) GetCONFIG7_E() uint32 {
	return volatile.LoadUint32(&o.CONFIG7.Reg) & 0x1
}
func (o *GPDMA_Type) SetCONFIG7_SRCPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.CONFIG7.Reg, volatile.LoadUint32(&o.CONFIG7.Reg)&^(0x3e)|value<<1)
}
func (o *GPDMA_Type) GetCONFIG7_SRCPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.CONFIG7.Reg) & 0x3e) >> 1
}
func (o *GPDMA_Type) SetCONFIG7_DESTPERIPHERAL(value uint32) {
	volatile.StoreUint32(&o.CONFIG7.Reg, volatile.LoadUint32(&o.CONFIG7.Reg)&^(0x7c0)|value<<6)
}
func (o *GPDMA_Type) GetCONFIG7_DESTPERIPHERAL() uint32 {
	return (volatile.LoadUint32(&o.CONFIG7.Reg) & 0x7c0) >> 6
}
func (o *GPDMA_Type) SetCONFIG7_TRANSFERTYPE(value uint32) {
	volatile.StoreUint32(&o.CONFIG7.Reg, volatile.LoadUint32(&o.CONFIG7.Reg)&^(0x3800)|value<<11)
}
func (o *GPDMA_Type) GetCONFIG7_TRANSFERTYPE() uint32 {
	return (volatile.LoadUint32(&o.CONFIG7.Reg) & 0x3800) >> 11
}
func (o *GPDMA_Type) SetCONFIG7_IE(value uint32) {
	volatile.StoreUint32(&o.CONFIG7.Reg, volatile.LoadUint32(&o.CONFIG7.Reg)&^(0x4000)|value<<14)
}
func (o *GPDMA_Type) GetCONFIG7_IE() uint32 {
	return (volatile.LoadUint32(&o.CONFIG7.Reg) & 0x4000) >> 14
}
func (o *GPDMA_Type) SetCONFIG7_ITC(value uint32) {
	volatile.StoreUint32(&o.CONFIG7.Reg, volatile.LoadUint32(&o.CONFIG7.Reg)&^(0x8000)|value<<15)
}
func (o *GPDMA_Type) GetCONFIG7_ITC() uint32 {
	return (volatile.LoadUint32(&o.CONFIG7.Reg) & 0x8000) >> 15
}
func (o *GPDMA_Type) SetCONFIG7_L(value uint32) {
	volatile.StoreUint32(&o.CONFIG7.Reg, volatile.LoadUint32(&o.CONFIG7.Reg)&^(0x10000)|value<<16)
}
func (o *GPDMA_Type) GetCONFIG7_L() uint32 {
	return (volatile.LoadUint32(&o.CONFIG7.Reg) & 0x10000) >> 16
}
func (o *GPDMA_Type) SetCONFIG7_A(value uint32) {
	volatile.StoreUint32(&o.CONFIG7.Reg, volatile.LoadUint32(&o.CONFIG7.Reg)&^(0x20000)|value<<17)
}
func (o *GPDMA_Type) GetCONFIG7_A() uint32 {
	return (volatile.LoadUint32(&o.CONFIG7.Reg) & 0x20000) >> 17
}
func (o *GPDMA_Type) SetCONFIG7_H(value uint32) {
	volatile.StoreUint32(&o.CONFIG7.Reg, volatile.LoadUint32(&o.CONFIG7.Reg)&^(0x40000)|value<<18)
}
func (o *GPDMA_Type) GetCONFIG7_H() uint32 {
	return (volatile.LoadUint32(&o.CONFIG7.Reg) & 0x40000) >> 18
}
func (o *GPDMA_Type) SetCONFIG7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONFIG7.Reg, volatile.LoadUint32(&o.CONFIG7.Reg)&^(0xfff80000)|value<<19)
}
func (o *GPDMA_Type) GetCONFIG7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONFIG7.Reg) & 0xfff80000) >> 19
}

// Ethernet
type ETHERNET_Type struct {
	MAC1               volatile.Register32 // 0x0
	MAC2               volatile.Register32 // 0x4
	IPGT               volatile.Register32 // 0x8
	IPGR               volatile.Register32 // 0xC
	CLRT               volatile.Register32 // 0x10
	MAXF               volatile.Register32 // 0x14
	SUPP               volatile.Register32 // 0x18
	TEST               volatile.Register32 // 0x1C
	MCFG               volatile.Register32 // 0x20
	MCMD               volatile.Register32 // 0x24
	MADR               volatile.Register32 // 0x28
	MWTD               volatile.Register32 // 0x2C
	MRDD               volatile.Register32 // 0x30
	MIND               volatile.Register32 // 0x34
	_                  [8]byte
	SA0                volatile.Register32 // 0x40
	SA1                volatile.Register32 // 0x44
	SA2                volatile.Register32 // 0x48
	_                  [180]byte
	COMMAND            volatile.Register32 // 0x100
	STATUS             volatile.Register32 // 0x104
	RXDESCRIPTOR       volatile.Register32 // 0x108
	RXSTATUS           volatile.Register32 // 0x10C
	RXDESCRIPTORNUMBER volatile.Register32 // 0x110
	RXPRODUCEINDEX     volatile.Register32 // 0x114
	RXCONSUMEINDEX     volatile.Register32 // 0x118
	TXDESCRIPTOR       volatile.Register32 // 0x11C
	TXSTATUS           volatile.Register32 // 0x120
	TXDESCRIPTORNUMBER volatile.Register32 // 0x124
	TXPRODUCEINDEX     volatile.Register32 // 0x128
	TXCONSUMEINDEX     volatile.Register32 // 0x12C
	_                  [40]byte
	TSV0               volatile.Register32 // 0x158
	TSV1               volatile.Register32 // 0x15C
	RSV                volatile.Register32 // 0x160
	_                  [12]byte
	FLOWCONTROLCOUNTER volatile.Register32 // 0x170
	FLOWCONTROLSTATUS  volatile.Register32 // 0x174
	_                  [136]byte
	RXFILTERCTRL       volatile.Register32 // 0x200
	RXFILTERWOLSTATUS  volatile.Register32 // 0x204
	RXFILTERWOLCLEAR   volatile.Register32 // 0x208
	_                  [4]byte
	HASHFILTERL        volatile.Register32 // 0x210
	HASHFILTERH        volatile.Register32 // 0x214
	_                  [3528]byte
	INTSTATUS          volatile.Register32 // 0xFE0
	INTENABLE          volatile.Register32 // 0xFE4
	INTCLEAR           volatile.Register32 // 0xFE8
	INTSET             volatile.Register32 // 0xFEC
	_                  [4]byte
	POWERDOWN          volatile.Register32 // 0xFF4
}

// ETHERNET.MAC1: MAC configuration register 1.
func (o *ETHERNET_Type) SetMAC1_RXENABLE(value uint32) {
	volatile.StoreUint32(&o.MAC1.Reg, volatile.LoadUint32(&o.MAC1.Reg)&^(0x1)|value)
}
func (o *ETHERNET_Type) GetMAC1_RXENABLE() uint32 {
	return volatile.LoadUint32(&o.MAC1.Reg) & 0x1
}
func (o *ETHERNET_Type) SetMAC1_PARF(value uint32) {
	volatile.StoreUint32(&o.MAC1.Reg, volatile.LoadUint32(&o.MAC1.Reg)&^(0x2)|value<<1)
}
func (o *ETHERNET_Type) GetMAC1_PARF() uint32 {
	return (volatile.LoadUint32(&o.MAC1.Reg) & 0x2) >> 1
}
func (o *ETHERNET_Type) SetMAC1_RXFLOWCTRL(value uint32) {
	volatile.StoreUint32(&o.MAC1.Reg, volatile.LoadUint32(&o.MAC1.Reg)&^(0x4)|value<<2)
}
func (o *ETHERNET_Type) GetMAC1_RXFLOWCTRL() uint32 {
	return (volatile.LoadUint32(&o.MAC1.Reg) & 0x4) >> 2
}
func (o *ETHERNET_Type) SetMAC1_TXFLOWCTRL(value uint32) {
	volatile.StoreUint32(&o.MAC1.Reg, volatile.LoadUint32(&o.MAC1.Reg)&^(0x8)|value<<3)
}
func (o *ETHERNET_Type) GetMAC1_TXFLOWCTRL() uint32 {
	return (volatile.LoadUint32(&o.MAC1.Reg) & 0x8) >> 3
}
func (o *ETHERNET_Type) SetMAC1_LOOPBACK(value uint32) {
	volatile.StoreUint32(&o.MAC1.Reg, volatile.LoadUint32(&o.MAC1.Reg)&^(0x10)|value<<4)
}
func (o *ETHERNET_Type) GetMAC1_LOOPBACK() uint32 {
	return (volatile.LoadUint32(&o.MAC1.Reg) & 0x10) >> 4
}
func (o *ETHERNET_Type) SetMAC1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC1.Reg, volatile.LoadUint32(&o.MAC1.Reg)&^(0xe0)|value<<5)
}
func (o *ETHERNET_Type) GetMAC1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC1.Reg) & 0xe0) >> 5
}
func (o *ETHERNET_Type) SetMAC1_RESETTX(value uint32) {
	volatile.StoreUint32(&o.MAC1.Reg, volatile.LoadUint32(&o.MAC1.Reg)&^(0x100)|value<<8)
}
func (o *ETHERNET_Type) GetMAC1_RESETTX() uint32 {
	return (volatile.LoadUint32(&o.MAC1.Reg) & 0x100) >> 8
}
func (o *ETHERNET_Type) SetMAC1_RESETMCSTX(value uint32) {
	volatile.StoreUint32(&o.MAC1.Reg, volatile.LoadUint32(&o.MAC1.Reg)&^(0x200)|value<<9)
}
func (o *ETHERNET_Type) GetMAC1_RESETMCSTX() uint32 {
	return (volatile.LoadUint32(&o.MAC1.Reg) & 0x200) >> 9
}
func (o *ETHERNET_Type) SetMAC1_RESETRX(value uint32) {
	volatile.StoreUint32(&o.MAC1.Reg, volatile.LoadUint32(&o.MAC1.Reg)&^(0x400)|value<<10)
}
func (o *ETHERNET_Type) GetMAC1_RESETRX() uint32 {
	return (volatile.LoadUint32(&o.MAC1.Reg) & 0x400) >> 10
}
func (o *ETHERNET_Type) SetMAC1_RESETMCSRX(value uint32) {
	volatile.StoreUint32(&o.MAC1.Reg, volatile.LoadUint32(&o.MAC1.Reg)&^(0x800)|value<<11)
}
func (o *ETHERNET_Type) GetMAC1_RESETMCSRX() uint32 {
	return (volatile.LoadUint32(&o.MAC1.Reg) & 0x800) >> 11
}
func (o *ETHERNET_Type) SetMAC1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC1.Reg, volatile.LoadUint32(&o.MAC1.Reg)&^(0x3000)|value<<12)
}
func (o *ETHERNET_Type) GetMAC1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC1.Reg) & 0x3000) >> 12
}
func (o *ETHERNET_Type) SetMAC1_SIMRESET(value uint32) {
	volatile.StoreUint32(&o.MAC1.Reg, volatile.LoadUint32(&o.MAC1.Reg)&^(0x4000)|value<<14)
}
func (o *ETHERNET_Type) GetMAC1_SIMRESET() uint32 {
	return (volatile.LoadUint32(&o.MAC1.Reg) & 0x4000) >> 14
}
func (o *ETHERNET_Type) SetMAC1_SOFTRESET(value uint32) {
	volatile.StoreUint32(&o.MAC1.Reg, volatile.LoadUint32(&o.MAC1.Reg)&^(0x8000)|value<<15)
}
func (o *ETHERNET_Type) GetMAC1_SOFTRESET() uint32 {
	return (volatile.LoadUint32(&o.MAC1.Reg) & 0x8000) >> 15
}
func (o *ETHERNET_Type) SetMAC1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC1.Reg, volatile.LoadUint32(&o.MAC1.Reg)&^(0xffff0000)|value<<16)
}
func (o *ETHERNET_Type) GetMAC1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC1.Reg) & 0xffff0000) >> 16
}

// ETHERNET.MAC2: MAC configuration register 2.
func (o *ETHERNET_Type) SetMAC2_FULLDUPLEX(value uint32) {
	volatile.StoreUint32(&o.MAC2.Reg, volatile.LoadUint32(&o.MAC2.Reg)&^(0x1)|value)
}
func (o *ETHERNET_Type) GetMAC2_FULLDUPLEX() uint32 {
	return volatile.LoadUint32(&o.MAC2.Reg) & 0x1
}
func (o *ETHERNET_Type) SetMAC2_FLC(value uint32) {
	volatile.StoreUint32(&o.MAC2.Reg, volatile.LoadUint32(&o.MAC2.Reg)&^(0x2)|value<<1)
}
func (o *ETHERNET_Type) GetMAC2_FLC() uint32 {
	return (volatile.LoadUint32(&o.MAC2.Reg) & 0x2) >> 1
}
func (o *ETHERNET_Type) SetMAC2_HFEN(value uint32) {
	volatile.StoreUint32(&o.MAC2.Reg, volatile.LoadUint32(&o.MAC2.Reg)&^(0x4)|value<<2)
}
func (o *ETHERNET_Type) GetMAC2_HFEN() uint32 {
	return (volatile.LoadUint32(&o.MAC2.Reg) & 0x4) >> 2
}
func (o *ETHERNET_Type) SetMAC2_DELAYEDCRC(value uint32) {
	volatile.StoreUint32(&o.MAC2.Reg, volatile.LoadUint32(&o.MAC2.Reg)&^(0x8)|value<<3)
}
func (o *ETHERNET_Type) GetMAC2_DELAYEDCRC() uint32 {
	return (volatile.LoadUint32(&o.MAC2.Reg) & 0x8) >> 3
}
func (o *ETHERNET_Type) SetMAC2_CRCEN(value uint32) {
	volatile.StoreUint32(&o.MAC2.Reg, volatile.LoadUint32(&o.MAC2.Reg)&^(0x10)|value<<4)
}
func (o *ETHERNET_Type) GetMAC2_CRCEN() uint32 {
	return (volatile.LoadUint32(&o.MAC2.Reg) & 0x10) >> 4
}
func (o *ETHERNET_Type) SetMAC2_PADCRCEN(value uint32) {
	volatile.StoreUint32(&o.MAC2.Reg, volatile.LoadUint32(&o.MAC2.Reg)&^(0x20)|value<<5)
}
func (o *ETHERNET_Type) GetMAC2_PADCRCEN() uint32 {
	return (volatile.LoadUint32(&o.MAC2.Reg) & 0x20) >> 5
}
func (o *ETHERNET_Type) SetMAC2_VLANPADEN(value uint32) {
	volatile.StoreUint32(&o.MAC2.Reg, volatile.LoadUint32(&o.MAC2.Reg)&^(0x40)|value<<6)
}
func (o *ETHERNET_Type) GetMAC2_VLANPADEN() uint32 {
	return (volatile.LoadUint32(&o.MAC2.Reg) & 0x40) >> 6
}
func (o *ETHERNET_Type) SetMAC2_AUTODETPADEN(value uint32) {
	volatile.StoreUint32(&o.MAC2.Reg, volatile.LoadUint32(&o.MAC2.Reg)&^(0x80)|value<<7)
}
func (o *ETHERNET_Type) GetMAC2_AUTODETPADEN() uint32 {
	return (volatile.LoadUint32(&o.MAC2.Reg) & 0x80) >> 7
}
func (o *ETHERNET_Type) SetMAC2_PPENF(value uint32) {
	volatile.StoreUint32(&o.MAC2.Reg, volatile.LoadUint32(&o.MAC2.Reg)&^(0x100)|value<<8)
}
func (o *ETHERNET_Type) GetMAC2_PPENF() uint32 {
	return (volatile.LoadUint32(&o.MAC2.Reg) & 0x100) >> 8
}
func (o *ETHERNET_Type) SetMAC2_LPENF(value uint32) {
	volatile.StoreUint32(&o.MAC2.Reg, volatile.LoadUint32(&o.MAC2.Reg)&^(0x200)|value<<9)
}
func (o *ETHERNET_Type) GetMAC2_LPENF() uint32 {
	return (volatile.LoadUint32(&o.MAC2.Reg) & 0x200) >> 9
}
func (o *ETHERNET_Type) SetMAC2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC2.Reg, volatile.LoadUint32(&o.MAC2.Reg)&^(0xc00)|value<<10)
}
func (o *ETHERNET_Type) GetMAC2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC2.Reg) & 0xc00) >> 10
}
func (o *ETHERNET_Type) SetMAC2_NOBACKOFF(value uint32) {
	volatile.StoreUint32(&o.MAC2.Reg, volatile.LoadUint32(&o.MAC2.Reg)&^(0x1000)|value<<12)
}
func (o *ETHERNET_Type) GetMAC2_NOBACKOFF() uint32 {
	return (volatile.LoadUint32(&o.MAC2.Reg) & 0x1000) >> 12
}
func (o *ETHERNET_Type) SetMAC2_BP_NOBACKOFF(value uint32) {
	volatile.StoreUint32(&o.MAC2.Reg, volatile.LoadUint32(&o.MAC2.Reg)&^(0x2000)|value<<13)
}
func (o *ETHERNET_Type) GetMAC2_BP_NOBACKOFF() uint32 {
	return (volatile.LoadUint32(&o.MAC2.Reg) & 0x2000) >> 13
}
func (o *ETHERNET_Type) SetMAC2_EXCESSDEFER(value uint32) {
	volatile.StoreUint32(&o.MAC2.Reg, volatile.LoadUint32(&o.MAC2.Reg)&^(0x4000)|value<<14)
}
func (o *ETHERNET_Type) GetMAC2_EXCESSDEFER() uint32 {
	return (volatile.LoadUint32(&o.MAC2.Reg) & 0x4000) >> 14
}
func (o *ETHERNET_Type) SetMAC2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAC2.Reg, volatile.LoadUint32(&o.MAC2.Reg)&^(0xffff8000)|value<<15)
}
func (o *ETHERNET_Type) GetMAC2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAC2.Reg) & 0xffff8000) >> 15
}

// ETHERNET.IPGT: Back-to-Back Inter-Packet-Gap register.
func (o *ETHERNET_Type) SetIPGT_BTOBINTEGAP(value uint32) {
	volatile.StoreUint32(&o.IPGT.Reg, volatile.LoadUint32(&o.IPGT.Reg)&^(0x7f)|value)
}
func (o *ETHERNET_Type) GetIPGT_BTOBINTEGAP() uint32 {
	return volatile.LoadUint32(&o.IPGT.Reg) & 0x7f
}
func (o *ETHERNET_Type) SetIPGT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IPGT.Reg, volatile.LoadUint32(&o.IPGT.Reg)&^(0xffffff80)|value<<7)
}
func (o *ETHERNET_Type) GetIPGT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IPGT.Reg) & 0xffffff80) >> 7
}

// ETHERNET.IPGR: Non Back-to-Back Inter-Packet-Gap register.
func (o *ETHERNET_Type) SetIPGR_NBTOBINTEGAP2(value uint32) {
	volatile.StoreUint32(&o.IPGR.Reg, volatile.LoadUint32(&o.IPGR.Reg)&^(0x7f)|value)
}
func (o *ETHERNET_Type) GetIPGR_NBTOBINTEGAP2() uint32 {
	return volatile.LoadUint32(&o.IPGR.Reg) & 0x7f
}
func (o *ETHERNET_Type) SetIPGR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IPGR.Reg, volatile.LoadUint32(&o.IPGR.Reg)&^(0x80)|value<<7)
}
func (o *ETHERNET_Type) GetIPGR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IPGR.Reg) & 0x80) >> 7
}
func (o *ETHERNET_Type) SetIPGR_NBTOBINTEGAP1(value uint32) {
	volatile.StoreUint32(&o.IPGR.Reg, volatile.LoadUint32(&o.IPGR.Reg)&^(0x7f00)|value<<8)
}
func (o *ETHERNET_Type) GetIPGR_NBTOBINTEGAP1() uint32 {
	return (volatile.LoadUint32(&o.IPGR.Reg) & 0x7f00) >> 8
}
func (o *ETHERNET_Type) SetIPGR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IPGR.Reg, volatile.LoadUint32(&o.IPGR.Reg)&^(0xffff8000)|value<<15)
}
func (o *ETHERNET_Type) GetIPGR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IPGR.Reg) & 0xffff8000) >> 15
}

// ETHERNET.CLRT: Collision window / Retry register.
func (o *ETHERNET_Type) SetCLRT_RETRANSMAX(value uint32) {
	volatile.StoreUint32(&o.CLRT.Reg, volatile.LoadUint32(&o.CLRT.Reg)&^(0xf)|value)
}
func (o *ETHERNET_Type) GetCLRT_RETRANSMAX() uint32 {
	return volatile.LoadUint32(&o.CLRT.Reg) & 0xf
}
func (o *ETHERNET_Type) SetCLRT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLRT.Reg, volatile.LoadUint32(&o.CLRT.Reg)&^(0xf0)|value<<4)
}
func (o *ETHERNET_Type) GetCLRT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLRT.Reg) & 0xf0) >> 4
}
func (o *ETHERNET_Type) SetCLRT_COLLWIN(value uint32) {
	volatile.StoreUint32(&o.CLRT.Reg, volatile.LoadUint32(&o.CLRT.Reg)&^(0x3f00)|value<<8)
}
func (o *ETHERNET_Type) GetCLRT_COLLWIN() uint32 {
	return (volatile.LoadUint32(&o.CLRT.Reg) & 0x3f00) >> 8
}
func (o *ETHERNET_Type) SetCLRT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLRT.Reg, volatile.LoadUint32(&o.CLRT.Reg)&^(0xffffc000)|value<<14)
}
func (o *ETHERNET_Type) GetCLRT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLRT.Reg) & 0xffffc000) >> 14
}

// ETHERNET.MAXF: Maximum Frame register.
func (o *ETHERNET_Type) SetMAXF_MAXFLEN(value uint32) {
	volatile.StoreUint32(&o.MAXF.Reg, volatile.LoadUint32(&o.MAXF.Reg)&^(0xffff)|value)
}
func (o *ETHERNET_Type) GetMAXF_MAXFLEN() uint32 {
	return volatile.LoadUint32(&o.MAXF.Reg) & 0xffff
}
func (o *ETHERNET_Type) SetMAXF_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAXF.Reg, volatile.LoadUint32(&o.MAXF.Reg)&^(0xffff0000)|value<<16)
}
func (o *ETHERNET_Type) GetMAXF_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAXF.Reg) & 0xffff0000) >> 16
}

// ETHERNET.SUPP: PHY Support register.
func (o *ETHERNET_Type) SetSUPP_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SUPP.Reg, volatile.LoadUint32(&o.SUPP.Reg)&^(0xff)|value)
}
func (o *ETHERNET_Type) GetSUPP_RESERVED() uint32 {
	return volatile.LoadUint32(&o.SUPP.Reg) & 0xff
}
func (o *ETHERNET_Type) SetSUPP_SPEED(value uint32) {
	volatile.StoreUint32(&o.SUPP.Reg, volatile.LoadUint32(&o.SUPP.Reg)&^(0x100)|value<<8)
}
func (o *ETHERNET_Type) GetSUPP_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SUPP.Reg) & 0x100) >> 8
}
func (o *ETHERNET_Type) SetSUPP_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SUPP.Reg, volatile.LoadUint32(&o.SUPP.Reg)&^(0xfffffe00)|value<<9)
}
func (o *ETHERNET_Type) GetSUPP_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SUPP.Reg) & 0xfffffe00) >> 9
}

// ETHERNET.TEST: Test register.
func (o *ETHERNET_Type) SetTEST_SCPQ(value uint32) {
	volatile.StoreUint32(&o.TEST.Reg, volatile.LoadUint32(&o.TEST.Reg)&^(0x1)|value)
}
func (o *ETHERNET_Type) GetTEST_SCPQ() uint32 {
	return volatile.LoadUint32(&o.TEST.Reg) & 0x1
}
func (o *ETHERNET_Type) SetTEST_TESTPAUSE(value uint32) {
	volatile.StoreUint32(&o.TEST.Reg, volatile.LoadUint32(&o.TEST.Reg)&^(0x2)|value<<1)
}
func (o *ETHERNET_Type) GetTEST_TESTPAUSE() uint32 {
	return (volatile.LoadUint32(&o.TEST.Reg) & 0x2) >> 1
}
func (o *ETHERNET_Type) SetTEST_TESTBP(value uint32) {
	volatile.StoreUint32(&o.TEST.Reg, volatile.LoadUint32(&o.TEST.Reg)&^(0x4)|value<<2)
}
func (o *ETHERNET_Type) GetTEST_TESTBP() uint32 {
	return (volatile.LoadUint32(&o.TEST.Reg) & 0x4) >> 2
}
func (o *ETHERNET_Type) SetTEST_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TEST.Reg, volatile.LoadUint32(&o.TEST.Reg)&^(0xfffffff8)|value<<3)
}
func (o *ETHERNET_Type) GetTEST_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TEST.Reg) & 0xfffffff8) >> 3
}

// ETHERNET.MCFG: MII Mgmt Configuration register.
func (o *ETHERNET_Type) SetMCFG_SCANINC(value uint32) {
	volatile.StoreUint32(&o.MCFG.Reg, volatile.LoadUint32(&o.MCFG.Reg)&^(0x1)|value)
}
func (o *ETHERNET_Type) GetMCFG_SCANINC() uint32 {
	return volatile.LoadUint32(&o.MCFG.Reg) & 0x1
}
func (o *ETHERNET_Type) SetMCFG_SUPPPREAMBLE(value uint32) {
	volatile.StoreUint32(&o.MCFG.Reg, volatile.LoadUint32(&o.MCFG.Reg)&^(0x2)|value<<1)
}
func (o *ETHERNET_Type) GetMCFG_SUPPPREAMBLE() uint32 {
	return (volatile.LoadUint32(&o.MCFG.Reg) & 0x2) >> 1
}
func (o *ETHERNET_Type) SetMCFG_CLOCKSEL(value uint32) {
	volatile.StoreUint32(&o.MCFG.Reg, volatile.LoadUint32(&o.MCFG.Reg)&^(0x3c)|value<<2)
}
func (o *ETHERNET_Type) GetMCFG_CLOCKSEL() uint32 {
	return (volatile.LoadUint32(&o.MCFG.Reg) & 0x3c) >> 2
}
func (o *ETHERNET_Type) SetMCFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MCFG.Reg, volatile.LoadUint32(&o.MCFG.Reg)&^(0x7fc0)|value<<6)
}
func (o *ETHERNET_Type) GetMCFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MCFG.Reg) & 0x7fc0) >> 6
}
func (o *ETHERNET_Type) SetMCFG_RESETMIIMGMT(value uint32) {
	volatile.StoreUint32(&o.MCFG.Reg, volatile.LoadUint32(&o.MCFG.Reg)&^(0x8000)|value<<15)
}
func (o *ETHERNET_Type) GetMCFG_RESETMIIMGMT() uint32 {
	return (volatile.LoadUint32(&o.MCFG.Reg) & 0x8000) >> 15
}
func (o *ETHERNET_Type) SetMCFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MCFG.Reg, volatile.LoadUint32(&o.MCFG.Reg)&^(0xffff0000)|value<<16)
}
func (o *ETHERNET_Type) GetMCFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MCFG.Reg) & 0xffff0000) >> 16
}

// ETHERNET.MCMD: MII Mgmt Command register.
func (o *ETHERNET_Type) SetMCMD_READ(value uint32) {
	volatile.StoreUint32(&o.MCMD.Reg, volatile.LoadUint32(&o.MCMD.Reg)&^(0x1)|value)
}
func (o *ETHERNET_Type) GetMCMD_READ() uint32 {
	return volatile.LoadUint32(&o.MCMD.Reg) & 0x1
}
func (o *ETHERNET_Type) SetMCMD_SCAN(value uint32) {
	volatile.StoreUint32(&o.MCMD.Reg, volatile.LoadUint32(&o.MCMD.Reg)&^(0x2)|value<<1)
}
func (o *ETHERNET_Type) GetMCMD_SCAN() uint32 {
	return (volatile.LoadUint32(&o.MCMD.Reg) & 0x2) >> 1
}
func (o *ETHERNET_Type) SetMCMD_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MCMD.Reg, volatile.LoadUint32(&o.MCMD.Reg)&^(0xfffffffc)|value<<2)
}
func (o *ETHERNET_Type) GetMCMD_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MCMD.Reg) & 0xfffffffc) >> 2
}

// ETHERNET.MADR: MII Mgmt Address register.
func (o *ETHERNET_Type) SetMADR_REGADDR(value uint32) {
	volatile.StoreUint32(&o.MADR.Reg, volatile.LoadUint32(&o.MADR.Reg)&^(0x1f)|value)
}
func (o *ETHERNET_Type) GetMADR_REGADDR() uint32 {
	return volatile.LoadUint32(&o.MADR.Reg) & 0x1f
}
func (o *ETHERNET_Type) SetMADR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MADR.Reg, volatile.LoadUint32(&o.MADR.Reg)&^(0xe0)|value<<5)
}
func (o *ETHERNET_Type) GetMADR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MADR.Reg) & 0xe0) >> 5
}
func (o *ETHERNET_Type) SetMADR_PHYADDR(value uint32) {
	volatile.StoreUint32(&o.MADR.Reg, volatile.LoadUint32(&o.MADR.Reg)&^(0x1f00)|value<<8)
}
func (o *ETHERNET_Type) GetMADR_PHYADDR() uint32 {
	return (volatile.LoadUint32(&o.MADR.Reg) & 0x1f00) >> 8
}
func (o *ETHERNET_Type) SetMADR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MADR.Reg, volatile.LoadUint32(&o.MADR.Reg)&^(0xffffe000)|value<<13)
}
func (o *ETHERNET_Type) GetMADR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MADR.Reg) & 0xffffe000) >> 13
}

// ETHERNET.MWTD: MII Mgmt Write Data register.
func (o *ETHERNET_Type) SetMWTD_WRITEDATA(value uint32) {
	volatile.StoreUint32(&o.MWTD.Reg, volatile.LoadUint32(&o.MWTD.Reg)&^(0xffff)|value)
}
func (o *ETHERNET_Type) GetMWTD_WRITEDATA() uint32 {
	return volatile.LoadUint32(&o.MWTD.Reg) & 0xffff
}
func (o *ETHERNET_Type) SetMWTD_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MWTD.Reg, volatile.LoadUint32(&o.MWTD.Reg)&^(0xffff0000)|value<<16)
}
func (o *ETHERNET_Type) GetMWTD_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MWTD.Reg) & 0xffff0000) >> 16
}

// ETHERNET.MRDD: MII Mgmt Read Data register.
func (o *ETHERNET_Type) SetMRDD_READDATA(value uint32) {
	volatile.StoreUint32(&o.MRDD.Reg, volatile.LoadUint32(&o.MRDD.Reg)&^(0xffff)|value)
}
func (o *ETHERNET_Type) GetMRDD_READDATA() uint32 {
	return volatile.LoadUint32(&o.MRDD.Reg) & 0xffff
}
func (o *ETHERNET_Type) SetMRDD_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MRDD.Reg, volatile.LoadUint32(&o.MRDD.Reg)&^(0xffff0000)|value<<16)
}
func (o *ETHERNET_Type) GetMRDD_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MRDD.Reg) & 0xffff0000) >> 16
}

// ETHERNET.MIND: MII Mgmt Indicators register.
func (o *ETHERNET_Type) SetMIND_BUSY(value uint32) {
	volatile.StoreUint32(&o.MIND.Reg, volatile.LoadUint32(&o.MIND.Reg)&^(0x1)|value)
}
func (o *ETHERNET_Type) GetMIND_BUSY() uint32 {
	return volatile.LoadUint32(&o.MIND.Reg) & 0x1
}
func (o *ETHERNET_Type) SetMIND_SCANNING(value uint32) {
	volatile.StoreUint32(&o.MIND.Reg, volatile.LoadUint32(&o.MIND.Reg)&^(0x2)|value<<1)
}
func (o *ETHERNET_Type) GetMIND_SCANNING() uint32 {
	return (volatile.LoadUint32(&o.MIND.Reg) & 0x2) >> 1
}
func (o *ETHERNET_Type) SetMIND_NOTVALID(value uint32) {
	volatile.StoreUint32(&o.MIND.Reg, volatile.LoadUint32(&o.MIND.Reg)&^(0x4)|value<<2)
}
func (o *ETHERNET_Type) GetMIND_NOTVALID() uint32 {
	return (volatile.LoadUint32(&o.MIND.Reg) & 0x4) >> 2
}
func (o *ETHERNET_Type) SetMIND_MIILINKFAIL(value uint32) {
	volatile.StoreUint32(&o.MIND.Reg, volatile.LoadUint32(&o.MIND.Reg)&^(0x8)|value<<3)
}
func (o *ETHERNET_Type) GetMIND_MIILINKFAIL() uint32 {
	return (volatile.LoadUint32(&o.MIND.Reg) & 0x8) >> 3
}
func (o *ETHERNET_Type) SetMIND_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MIND.Reg, volatile.LoadUint32(&o.MIND.Reg)&^(0xfffffff0)|value<<4)
}
func (o *ETHERNET_Type) GetMIND_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MIND.Reg) & 0xfffffff0) >> 4
}

// ETHERNET.SA0: Station Address 0 register.
func (o *ETHERNET_Type) SetSA0_SADDR2(value uint32) {
	volatile.StoreUint32(&o.SA0.Reg, volatile.LoadUint32(&o.SA0.Reg)&^(0xff)|value)
}
func (o *ETHERNET_Type) GetSA0_SADDR2() uint32 {
	return volatile.LoadUint32(&o.SA0.Reg) & 0xff
}
func (o *ETHERNET_Type) SetSA0_SADDR1(value uint32) {
	volatile.StoreUint32(&o.SA0.Reg, volatile.LoadUint32(&o.SA0.Reg)&^(0xff00)|value<<8)
}
func (o *ETHERNET_Type) GetSA0_SADDR1() uint32 {
	return (volatile.LoadUint32(&o.SA0.Reg) & 0xff00) >> 8
}
func (o *ETHERNET_Type) SetSA0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SA0.Reg, volatile.LoadUint32(&o.SA0.Reg)&^(0xffff0000)|value<<16)
}
func (o *ETHERNET_Type) GetSA0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SA0.Reg) & 0xffff0000) >> 16
}

// ETHERNET.SA1: Station Address 1 register.
func (o *ETHERNET_Type) SetSA1_SADDR4(value uint32) {
	volatile.StoreUint32(&o.SA1.Reg, volatile.LoadUint32(&o.SA1.Reg)&^(0xff)|value)
}
func (o *ETHERNET_Type) GetSA1_SADDR4() uint32 {
	return volatile.LoadUint32(&o.SA1.Reg) & 0xff
}
func (o *ETHERNET_Type) SetSA1_SADDR3(value uint32) {
	volatile.StoreUint32(&o.SA1.Reg, volatile.LoadUint32(&o.SA1.Reg)&^(0xff00)|value<<8)
}
func (o *ETHERNET_Type) GetSA1_SADDR3() uint32 {
	return (volatile.LoadUint32(&o.SA1.Reg) & 0xff00) >> 8
}
func (o *ETHERNET_Type) SetSA1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SA1.Reg, volatile.LoadUint32(&o.SA1.Reg)&^(0xffff0000)|value<<16)
}
func (o *ETHERNET_Type) GetSA1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SA1.Reg) & 0xffff0000) >> 16
}

// ETHERNET.SA2: Station Address 2 register.
func (o *ETHERNET_Type) SetSA2_SADDR6(value uint32) {
	volatile.StoreUint32(&o.SA2.Reg, volatile.LoadUint32(&o.SA2.Reg)&^(0xff)|value)
}
func (o *ETHERNET_Type) GetSA2_SADDR6() uint32 {
	return volatile.LoadUint32(&o.SA2.Reg) & 0xff
}
func (o *ETHERNET_Type) SetSA2_SADDR5(value uint32) {
	volatile.StoreUint32(&o.SA2.Reg, volatile.LoadUint32(&o.SA2.Reg)&^(0xff00)|value<<8)
}
func (o *ETHERNET_Type) GetSA2_SADDR5() uint32 {
	return (volatile.LoadUint32(&o.SA2.Reg) & 0xff00) >> 8
}
func (o *ETHERNET_Type) SetSA2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SA2.Reg, volatile.LoadUint32(&o.SA2.Reg)&^(0xffff0000)|value<<16)
}
func (o *ETHERNET_Type) GetSA2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SA2.Reg) & 0xffff0000) >> 16
}

// ETHERNET.COMMAND: Command register.
func (o *ETHERNET_Type) SetCOMMAND_RXENABLE(value uint32) {
	volatile.StoreUint32(&o.COMMAND.Reg, volatile.LoadUint32(&o.COMMAND.Reg)&^(0x1)|value)
}
func (o *ETHERNET_Type) GetCOMMAND_RXENABLE() uint32 {
	return volatile.LoadUint32(&o.COMMAND.Reg) & 0x1
}
func (o *ETHERNET_Type) SetCOMMAND_TXENABLE(value uint32) {
	volatile.StoreUint32(&o.COMMAND.Reg, volatile.LoadUint32(&o.COMMAND.Reg)&^(0x2)|value<<1)
}
func (o *ETHERNET_Type) GetCOMMAND_TXENABLE() uint32 {
	return (volatile.LoadUint32(&o.COMMAND.Reg) & 0x2) >> 1
}
func (o *ETHERNET_Type) SetCOMMAND_RESERVED(value uint32) {
	volatile.StoreUint32(&o.COMMAND.Reg, volatile.LoadUint32(&o.COMMAND.Reg)&^(0x4)|value<<2)
}
func (o *ETHERNET_Type) GetCOMMAND_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.COMMAND.Reg) & 0x4) >> 2
}
func (o *ETHERNET_Type) SetCOMMAND_REGRESET(value uint32) {
	volatile.StoreUint32(&o.COMMAND.Reg, volatile.LoadUint32(&o.COMMAND.Reg)&^(0x8)|value<<3)
}
func (o *ETHERNET_Type) GetCOMMAND_REGRESET() uint32 {
	return (volatile.LoadUint32(&o.COMMAND.Reg) & 0x8) >> 3
}
func (o *ETHERNET_Type) SetCOMMAND_TXRESET(value uint32) {
	volatile.StoreUint32(&o.COMMAND.Reg, volatile.LoadUint32(&o.COMMAND.Reg)&^(0x10)|value<<4)
}
func (o *ETHERNET_Type) GetCOMMAND_TXRESET() uint32 {
	return (volatile.LoadUint32(&o.COMMAND.Reg) & 0x10) >> 4
}
func (o *ETHERNET_Type) SetCOMMAND_RXRESET(value uint32) {
	volatile.StoreUint32(&o.COMMAND.Reg, volatile.LoadUint32(&o.COMMAND.Reg)&^(0x20)|value<<5)
}
func (o *ETHERNET_Type) GetCOMMAND_RXRESET() uint32 {
	return (volatile.LoadUint32(&o.COMMAND.Reg) & 0x20) >> 5
}
func (o *ETHERNET_Type) SetCOMMAND_PASSRUNTFRAME(value uint32) {
	volatile.StoreUint32(&o.COMMAND.Reg, volatile.LoadUint32(&o.COMMAND.Reg)&^(0x40)|value<<6)
}
func (o *ETHERNET_Type) GetCOMMAND_PASSRUNTFRAME() uint32 {
	return (volatile.LoadUint32(&o.COMMAND.Reg) & 0x40) >> 6
}
func (o *ETHERNET_Type) SetCOMMAND_PASSRXFILTER(value uint32) {
	volatile.StoreUint32(&o.COMMAND.Reg, volatile.LoadUint32(&o.COMMAND.Reg)&^(0x80)|value<<7)
}
func (o *ETHERNET_Type) GetCOMMAND_PASSRXFILTER() uint32 {
	return (volatile.LoadUint32(&o.COMMAND.Reg) & 0x80) >> 7
}
func (o *ETHERNET_Type) SetCOMMAND_TXFLOWCONTROL(value uint32) {
	volatile.StoreUint32(&o.COMMAND.Reg, volatile.LoadUint32(&o.COMMAND.Reg)&^(0x100)|value<<8)
}
func (o *ETHERNET_Type) GetCOMMAND_TXFLOWCONTROL() uint32 {
	return (volatile.LoadUint32(&o.COMMAND.Reg) & 0x100) >> 8
}
func (o *ETHERNET_Type) SetCOMMAND_RMII(value uint32) {
	volatile.StoreUint32(&o.COMMAND.Reg, volatile.LoadUint32(&o.COMMAND.Reg)&^(0x200)|value<<9)
}
func (o *ETHERNET_Type) GetCOMMAND_RMII() uint32 {
	return (volatile.LoadUint32(&o.COMMAND.Reg) & 0x200) >> 9
}
func (o *ETHERNET_Type) SetCOMMAND_FULLDUPLEX(value uint32) {
	volatile.StoreUint32(&o.COMMAND.Reg, volatile.LoadUint32(&o.COMMAND.Reg)&^(0x400)|value<<10)
}
func (o *ETHERNET_Type) GetCOMMAND_FULLDUPLEX() uint32 {
	return (volatile.LoadUint32(&o.COMMAND.Reg) & 0x400) >> 10
}
func (o *ETHERNET_Type) SetCOMMAND_RESERVED(value uint32) {
	volatile.StoreUint32(&o.COMMAND.Reg, volatile.LoadUint32(&o.COMMAND.Reg)&^(0xfffff800)|value<<11)
}
func (o *ETHERNET_Type) GetCOMMAND_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.COMMAND.Reg) & 0xfffff800) >> 11
}

// ETHERNET.STATUS: Status register.
func (o *ETHERNET_Type) SetSTATUS_RXSTATUS(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *ETHERNET_Type) GetSTATUS_RXSTATUS() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1
}
func (o *ETHERNET_Type) SetSTATUS_TXSTATUS(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *ETHERNET_Type) GetSTATUS_TXSTATUS() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *ETHERNET_Type) SetSTATUS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0xfffffffc)|value<<2)
}
func (o *ETHERNET_Type) GetSTATUS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0xfffffffc) >> 2
}

// ETHERNET.RXDESCRIPTOR: Receive descriptor base address register.
func (o *ETHERNET_Type) SetRXDESCRIPTOR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RXDESCRIPTOR.Reg, volatile.LoadUint32(&o.RXDESCRIPTOR.Reg)&^(0x3)|value)
}
func (o *ETHERNET_Type) GetRXDESCRIPTOR_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RXDESCRIPTOR.Reg) & 0x3
}
func (o *ETHERNET_Type) SetRXDESCRIPTOR(value uint32) {
	volatile.StoreUint32(&o.RXDESCRIPTOR.Reg, volatile.LoadUint32(&o.RXDESCRIPTOR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *ETHERNET_Type) GetRXDESCRIPTOR() uint32 {
	return (volatile.LoadUint32(&o.RXDESCRIPTOR.Reg) & 0xfffffffc) >> 2
}

// ETHERNET.RXSTATUS: Receive status base address register.
func (o *ETHERNET_Type) SetRXSTATUS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RXSTATUS.Reg, volatile.LoadUint32(&o.RXSTATUS.Reg)&^(0x7)|value)
}
func (o *ETHERNET_Type) GetRXSTATUS_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RXSTATUS.Reg) & 0x7
}
func (o *ETHERNET_Type) SetRXSTATUS(value uint32) {
	volatile.StoreUint32(&o.RXSTATUS.Reg, volatile.LoadUint32(&o.RXSTATUS.Reg)&^(0xfffffff8)|value<<3)
}
func (o *ETHERNET_Type) GetRXSTATUS() uint32 {
	return (volatile.LoadUint32(&o.RXSTATUS.Reg) & 0xfffffff8) >> 3
}

// ETHERNET.RXDESCRIPTORNUMBER: Receive number of descriptors register.
func (o *ETHERNET_Type) SetRXDESCRIPTORNUMBER_RXDESCRIPTORN(value uint32) {
	volatile.StoreUint32(&o.RXDESCRIPTORNUMBER.Reg, volatile.LoadUint32(&o.RXDESCRIPTORNUMBER.Reg)&^(0xffff)|value)
}
func (o *ETHERNET_Type) GetRXDESCRIPTORNUMBER_RXDESCRIPTORN() uint32 {
	return volatile.LoadUint32(&o.RXDESCRIPTORNUMBER.Reg) & 0xffff
}
func (o *ETHERNET_Type) SetRXDESCRIPTORNUMBER_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RXDESCRIPTORNUMBER.Reg, volatile.LoadUint32(&o.RXDESCRIPTORNUMBER.Reg)&^(0xffff0000)|value<<16)
}
func (o *ETHERNET_Type) GetRXDESCRIPTORNUMBER_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RXDESCRIPTORNUMBER.Reg) & 0xffff0000) >> 16
}

// ETHERNET.RXPRODUCEINDEX: Receive produce index register.
func (o *ETHERNET_Type) SetRXPRODUCEINDEX_RXPRODUCEIX(value uint32) {
	volatile.StoreUint32(&o.RXPRODUCEINDEX.Reg, volatile.LoadUint32(&o.RXPRODUCEINDEX.Reg)&^(0xffff)|value)
}
func (o *ETHERNET_Type) GetRXPRODUCEINDEX_RXPRODUCEIX() uint32 {
	return volatile.LoadUint32(&o.RXPRODUCEINDEX.Reg) & 0xffff
}
func (o *ETHERNET_Type) SetRXPRODUCEINDEX_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RXPRODUCEINDEX.Reg, volatile.LoadUint32(&o.RXPRODUCEINDEX.Reg)&^(0xffff0000)|value<<16)
}
func (o *ETHERNET_Type) GetRXPRODUCEINDEX_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RXPRODUCEINDEX.Reg) & 0xffff0000) >> 16
}

// ETHERNET.RXCONSUMEINDEX: Receive consume index register.
func (o *ETHERNET_Type) SetRXCONSUMEINDEX_RXCONSUMEIX(value uint32) {
	volatile.StoreUint32(&o.RXCONSUMEINDEX.Reg, volatile.LoadUint32(&o.RXCONSUMEINDEX.Reg)&^(0xffff)|value)
}
func (o *ETHERNET_Type) GetRXCONSUMEINDEX_RXCONSUMEIX() uint32 {
	return volatile.LoadUint32(&o.RXCONSUMEINDEX.Reg) & 0xffff
}
func (o *ETHERNET_Type) SetRXCONSUMEINDEX_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RXCONSUMEINDEX.Reg, volatile.LoadUint32(&o.RXCONSUMEINDEX.Reg)&^(0xffff0000)|value<<16)
}
func (o *ETHERNET_Type) GetRXCONSUMEINDEX_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RXCONSUMEINDEX.Reg) & 0xffff0000) >> 16
}

// ETHERNET.TXDESCRIPTOR: Transmit descriptor base address register.
func (o *ETHERNET_Type) SetTXDESCRIPTOR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TXDESCRIPTOR.Reg, volatile.LoadUint32(&o.TXDESCRIPTOR.Reg)&^(0x3)|value)
}
func (o *ETHERNET_Type) GetTXDESCRIPTOR_RESERVED() uint32 {
	return volatile.LoadUint32(&o.TXDESCRIPTOR.Reg) & 0x3
}
func (o *ETHERNET_Type) SetTXDESCRIPTOR_TXD(value uint32) {
	volatile.StoreUint32(&o.TXDESCRIPTOR.Reg, volatile.LoadUint32(&o.TXDESCRIPTOR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *ETHERNET_Type) GetTXDESCRIPTOR_TXD() uint32 {
	return (volatile.LoadUint32(&o.TXDESCRIPTOR.Reg) & 0xfffffffc) >> 2
}

// ETHERNET.TXSTATUS: Transmit status base address register.
func (o *ETHERNET_Type) SetTXSTATUS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TXSTATUS.Reg, volatile.LoadUint32(&o.TXSTATUS.Reg)&^(0x3)|value)
}
func (o *ETHERNET_Type) GetTXSTATUS_RESERVED() uint32 {
	return volatile.LoadUint32(&o.TXSTATUS.Reg) & 0x3
}
func (o *ETHERNET_Type) SetTXSTATUS_TXSTAT(value uint32) {
	volatile.StoreUint32(&o.TXSTATUS.Reg, volatile.LoadUint32(&o.TXSTATUS.Reg)&^(0xfffffffc)|value<<2)
}
func (o *ETHERNET_Type) GetTXSTATUS_TXSTAT() uint32 {
	return (volatile.LoadUint32(&o.TXSTATUS.Reg) & 0xfffffffc) >> 2
}

// ETHERNET.TXDESCRIPTORNUMBER: Transmit number of descriptors register.
func (o *ETHERNET_Type) SetTXDESCRIPTORNUMBER_TXDN(value uint32) {
	volatile.StoreUint32(&o.TXDESCRIPTORNUMBER.Reg, volatile.LoadUint32(&o.TXDESCRIPTORNUMBER.Reg)&^(0xffff)|value)
}
func (o *ETHERNET_Type) GetTXDESCRIPTORNUMBER_TXDN() uint32 {
	return volatile.LoadUint32(&o.TXDESCRIPTORNUMBER.Reg) & 0xffff
}
func (o *ETHERNET_Type) SetTXDESCRIPTORNUMBER_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TXDESCRIPTORNUMBER.Reg, volatile.LoadUint32(&o.TXDESCRIPTORNUMBER.Reg)&^(0xffff0000)|value<<16)
}
func (o *ETHERNET_Type) GetTXDESCRIPTORNUMBER_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TXDESCRIPTORNUMBER.Reg) & 0xffff0000) >> 16
}

// ETHERNET.TXPRODUCEINDEX: Transmit produce index register.
func (o *ETHERNET_Type) SetTXPRODUCEINDEX_TXPI(value uint32) {
	volatile.StoreUint32(&o.TXPRODUCEINDEX.Reg, volatile.LoadUint32(&o.TXPRODUCEINDEX.Reg)&^(0xffff)|value)
}
func (o *ETHERNET_Type) GetTXPRODUCEINDEX_TXPI() uint32 {
	return volatile.LoadUint32(&o.TXPRODUCEINDEX.Reg) & 0xffff
}
func (o *ETHERNET_Type) SetTXPRODUCEINDEX_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TXPRODUCEINDEX.Reg, volatile.LoadUint32(&o.TXPRODUCEINDEX.Reg)&^(0xffff0000)|value<<16)
}
func (o *ETHERNET_Type) GetTXPRODUCEINDEX_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TXPRODUCEINDEX.Reg) & 0xffff0000) >> 16
}

// ETHERNET.TXCONSUMEINDEX: Transmit consume index register.
func (o *ETHERNET_Type) SetTXCONSUMEINDEX_TXCI(value uint32) {
	volatile.StoreUint32(&o.TXCONSUMEINDEX.Reg, volatile.LoadUint32(&o.TXCONSUMEINDEX.Reg)&^(0xffff)|value)
}
func (o *ETHERNET_Type) GetTXCONSUMEINDEX_TXCI() uint32 {
	return volatile.LoadUint32(&o.TXCONSUMEINDEX.Reg) & 0xffff
}
func (o *ETHERNET_Type) SetTXCONSUMEINDEX_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TXCONSUMEINDEX.Reg, volatile.LoadUint32(&o.TXCONSUMEINDEX.Reg)&^(0xffff0000)|value<<16)
}
func (o *ETHERNET_Type) GetTXCONSUMEINDEX_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TXCONSUMEINDEX.Reg) & 0xffff0000) >> 16
}

// ETHERNET.TSV0: Transmit status vector 0 register.
func (o *ETHERNET_Type) SetTSV0_CRCERR(value uint32) {
	volatile.StoreUint32(&o.TSV0.Reg, volatile.LoadUint32(&o.TSV0.Reg)&^(0x1)|value)
}
func (o *ETHERNET_Type) GetTSV0_CRCERR() uint32 {
	return volatile.LoadUint32(&o.TSV0.Reg) & 0x1
}
func (o *ETHERNET_Type) SetTSV0_LCE(value uint32) {
	volatile.StoreUint32(&o.TSV0.Reg, volatile.LoadUint32(&o.TSV0.Reg)&^(0x2)|value<<1)
}
func (o *ETHERNET_Type) GetTSV0_LCE() uint32 {
	return (volatile.LoadUint32(&o.TSV0.Reg) & 0x2) >> 1
}
func (o *ETHERNET_Type) SetTSV0_LOR(value uint32) {
	volatile.StoreUint32(&o.TSV0.Reg, volatile.LoadUint32(&o.TSV0.Reg)&^(0x4)|value<<2)
}
func (o *ETHERNET_Type) GetTSV0_LOR() uint32 {
	return (volatile.LoadUint32(&o.TSV0.Reg) & 0x4) >> 2
}
func (o *ETHERNET_Type) SetTSV0_DONE(value uint32) {
	volatile.StoreUint32(&o.TSV0.Reg, volatile.LoadUint32(&o.TSV0.Reg)&^(0x8)|value<<3)
}
func (o *ETHERNET_Type) GetTSV0_DONE() uint32 {
	return (volatile.LoadUint32(&o.TSV0.Reg) & 0x8) >> 3
}
func (o *ETHERNET_Type) SetTSV0_MULTICAST(value uint32) {
	volatile.StoreUint32(&o.TSV0.Reg, volatile.LoadUint32(&o.TSV0.Reg)&^(0x10)|value<<4)
}
func (o *ETHERNET_Type) GetTSV0_MULTICAST() uint32 {
	return (volatile.LoadUint32(&o.TSV0.Reg) & 0x10) >> 4
}
func (o *ETHERNET_Type) SetTSV0_BROADCAST(value uint32) {
	volatile.StoreUint32(&o.TSV0.Reg, volatile.LoadUint32(&o.TSV0.Reg)&^(0x20)|value<<5)
}
func (o *ETHERNET_Type) GetTSV0_BROADCAST() uint32 {
	return (volatile.LoadUint32(&o.TSV0.Reg) & 0x20) >> 5
}
func (o *ETHERNET_Type) SetTSV0_PACKETDEFER(value uint32) {
	volatile.StoreUint32(&o.TSV0.Reg, volatile.LoadUint32(&o.TSV0.Reg)&^(0x40)|value<<6)
}
func (o *ETHERNET_Type) GetTSV0_PACKETDEFER() uint32 {
	return (volatile.LoadUint32(&o.TSV0.Reg) & 0x40) >> 6
}
func (o *ETHERNET_Type) SetTSV0_EXDF(value uint32) {
	volatile.StoreUint32(&o.TSV0.Reg, volatile.LoadUint32(&o.TSV0.Reg)&^(0x80)|value<<7)
}
func (o *ETHERNET_Type) GetTSV0_EXDF() uint32 {
	return (volatile.LoadUint32(&o.TSV0.Reg) & 0x80) >> 7
}
func (o *ETHERNET_Type) SetTSV0_EXCOL(value uint32) {
	volatile.StoreUint32(&o.TSV0.Reg, volatile.LoadUint32(&o.TSV0.Reg)&^(0x100)|value<<8)
}
func (o *ETHERNET_Type) GetTSV0_EXCOL() uint32 {
	return (volatile.LoadUint32(&o.TSV0.Reg) & 0x100) >> 8
}
func (o *ETHERNET_Type) SetTSV0_LCOL(value uint32) {
	volatile.StoreUint32(&o.TSV0.Reg, volatile.LoadUint32(&o.TSV0.Reg)&^(0x200)|value<<9)
}
func (o *ETHERNET_Type) GetTSV0_LCOL() uint32 {
	return (volatile.LoadUint32(&o.TSV0.Reg) & 0x200) >> 9
}
func (o *ETHERNET_Type) SetTSV0_GIANT(value uint32) {
	volatile.StoreUint32(&o.TSV0.Reg, volatile.LoadUint32(&o.TSV0.Reg)&^(0x400)|value<<10)
}
func (o *ETHERNET_Type) GetTSV0_GIANT() uint32 {
	return (volatile.LoadUint32(&o.TSV0.Reg) & 0x400) >> 10
}
func (o *ETHERNET_Type) SetTSV0_UNDERRUN(value uint32) {
	volatile.StoreUint32(&o.TSV0.Reg, volatile.LoadUint32(&o.TSV0.Reg)&^(0x800)|value<<11)
}
func (o *ETHERNET_Type) GetTSV0_UNDERRUN() uint32 {
	return (volatile.LoadUint32(&o.TSV0.Reg) & 0x800) >> 11
}
func (o *ETHERNET_Type) SetTSV0_TOTALBYTES(value uint32) {
	volatile.StoreUint32(&o.TSV0.Reg, volatile.LoadUint32(&o.TSV0.Reg)&^(0xffff000)|value<<12)
}
func (o *ETHERNET_Type) GetTSV0_TOTALBYTES() uint32 {
	return (volatile.LoadUint32(&o.TSV0.Reg) & 0xffff000) >> 12
}
func (o *ETHERNET_Type) SetTSV0_CONTROLFRAME(value uint32) {
	volatile.StoreUint32(&o.TSV0.Reg, volatile.LoadUint32(&o.TSV0.Reg)&^(0x10000000)|value<<28)
}
func (o *ETHERNET_Type) GetTSV0_CONTROLFRAME() uint32 {
	return (volatile.LoadUint32(&o.TSV0.Reg) & 0x10000000) >> 28
}
func (o *ETHERNET_Type) SetTSV0_PAUSE(value uint32) {
	volatile.StoreUint32(&o.TSV0.Reg, volatile.LoadUint32(&o.TSV0.Reg)&^(0x20000000)|value<<29)
}
func (o *ETHERNET_Type) GetTSV0_PAUSE() uint32 {
	return (volatile.LoadUint32(&o.TSV0.Reg) & 0x20000000) >> 29
}
func (o *ETHERNET_Type) SetTSV0_BACKPRESSURE(value uint32) {
	volatile.StoreUint32(&o.TSV0.Reg, volatile.LoadUint32(&o.TSV0.Reg)&^(0x40000000)|value<<30)
}
func (o *ETHERNET_Type) GetTSV0_BACKPRESSURE() uint32 {
	return (volatile.LoadUint32(&o.TSV0.Reg) & 0x40000000) >> 30
}
func (o *ETHERNET_Type) SetTSV0_VLAN(value uint32) {
	volatile.StoreUint32(&o.TSV0.Reg, volatile.LoadUint32(&o.TSV0.Reg)&^(0x80000000)|value<<31)
}
func (o *ETHERNET_Type) GetTSV0_VLAN() uint32 {
	return (volatile.LoadUint32(&o.TSV0.Reg) & 0x80000000) >> 31
}

// ETHERNET.TSV1: Transmit status vector 1 register.
func (o *ETHERNET_Type) SetTSV1_TBC(value uint32) {
	volatile.StoreUint32(&o.TSV1.Reg, volatile.LoadUint32(&o.TSV1.Reg)&^(0xffff)|value)
}
func (o *ETHERNET_Type) GetTSV1_TBC() uint32 {
	return volatile.LoadUint32(&o.TSV1.Reg) & 0xffff
}
func (o *ETHERNET_Type) SetTSV1_TCC(value uint32) {
	volatile.StoreUint32(&o.TSV1.Reg, volatile.LoadUint32(&o.TSV1.Reg)&^(0xf0000)|value<<16)
}
func (o *ETHERNET_Type) GetTSV1_TCC() uint32 {
	return (volatile.LoadUint32(&o.TSV1.Reg) & 0xf0000) >> 16
}
func (o *ETHERNET_Type) SetTSV1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TSV1.Reg, volatile.LoadUint32(&o.TSV1.Reg)&^(0xfff00000)|value<<20)
}
func (o *ETHERNET_Type) GetTSV1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TSV1.Reg) & 0xfff00000) >> 20
}

// ETHERNET.RSV: Receive status vector register.
func (o *ETHERNET_Type) SetRSV_RBC(value uint32) {
	volatile.StoreUint32(&o.RSV.Reg, volatile.LoadUint32(&o.RSV.Reg)&^(0xffff)|value)
}
func (o *ETHERNET_Type) GetRSV_RBC() uint32 {
	return volatile.LoadUint32(&o.RSV.Reg) & 0xffff
}
func (o *ETHERNET_Type) SetRSV_PPI(value uint32) {
	volatile.StoreUint32(&o.RSV.Reg, volatile.LoadUint32(&o.RSV.Reg)&^(0x10000)|value<<16)
}
func (o *ETHERNET_Type) GetRSV_PPI() uint32 {
	return (volatile.LoadUint32(&o.RSV.Reg) & 0x10000) >> 16
}
func (o *ETHERNET_Type) SetRSV_RXDVSEEN(value uint32) {
	volatile.StoreUint32(&o.RSV.Reg, volatile.LoadUint32(&o.RSV.Reg)&^(0x20000)|value<<17)
}
func (o *ETHERNET_Type) GetRSV_RXDVSEEN() uint32 {
	return (volatile.LoadUint32(&o.RSV.Reg) & 0x20000) >> 17
}
func (o *ETHERNET_Type) SetRSV_CESEEN(value uint32) {
	volatile.StoreUint32(&o.RSV.Reg, volatile.LoadUint32(&o.RSV.Reg)&^(0x40000)|value<<18)
}
func (o *ETHERNET_Type) GetRSV_CESEEN() uint32 {
	return (volatile.LoadUint32(&o.RSV.Reg) & 0x40000) >> 18
}
func (o *ETHERNET_Type) SetRSV_RCV(value uint32) {
	volatile.StoreUint32(&o.RSV.Reg, volatile.LoadUint32(&o.RSV.Reg)&^(0x80000)|value<<19)
}
func (o *ETHERNET_Type) GetRSV_RCV() uint32 {
	return (volatile.LoadUint32(&o.RSV.Reg) & 0x80000) >> 19
}
func (o *ETHERNET_Type) SetRSV_CRCERR(value uint32) {
	volatile.StoreUint32(&o.RSV.Reg, volatile.LoadUint32(&o.RSV.Reg)&^(0x100000)|value<<20)
}
func (o *ETHERNET_Type) GetRSV_CRCERR() uint32 {
	return (volatile.LoadUint32(&o.RSV.Reg) & 0x100000) >> 20
}
func (o *ETHERNET_Type) SetRSV_LCERR(value uint32) {
	volatile.StoreUint32(&o.RSV.Reg, volatile.LoadUint32(&o.RSV.Reg)&^(0x200000)|value<<21)
}
func (o *ETHERNET_Type) GetRSV_LCERR() uint32 {
	return (volatile.LoadUint32(&o.RSV.Reg) & 0x200000) >> 21
}
func (o *ETHERNET_Type) SetRSV_LOR(value uint32) {
	volatile.StoreUint32(&o.RSV.Reg, volatile.LoadUint32(&o.RSV.Reg)&^(0x400000)|value<<22)
}
func (o *ETHERNET_Type) GetRSV_LOR() uint32 {
	return (volatile.LoadUint32(&o.RSV.Reg) & 0x400000) >> 22
}
func (o *ETHERNET_Type) SetRSV_ROK(value uint32) {
	volatile.StoreUint32(&o.RSV.Reg, volatile.LoadUint32(&o.RSV.Reg)&^(0x800000)|value<<23)
}
func (o *ETHERNET_Type) GetRSV_ROK() uint32 {
	return (volatile.LoadUint32(&o.RSV.Reg) & 0x800000) >> 23
}
func (o *ETHERNET_Type) SetRSV_MULTICAST(value uint32) {
	volatile.StoreUint32(&o.RSV.Reg, volatile.LoadUint32(&o.RSV.Reg)&^(0x1000000)|value<<24)
}
func (o *ETHERNET_Type) GetRSV_MULTICAST() uint32 {
	return (volatile.LoadUint32(&o.RSV.Reg) & 0x1000000) >> 24
}
func (o *ETHERNET_Type) SetRSV_BROADCAST(value uint32) {
	volatile.StoreUint32(&o.RSV.Reg, volatile.LoadUint32(&o.RSV.Reg)&^(0x2000000)|value<<25)
}
func (o *ETHERNET_Type) GetRSV_BROADCAST() uint32 {
	return (volatile.LoadUint32(&o.RSV.Reg) & 0x2000000) >> 25
}
func (o *ETHERNET_Type) SetRSV_DRIBBLENIBBLE(value uint32) {
	volatile.StoreUint32(&o.RSV.Reg, volatile.LoadUint32(&o.RSV.Reg)&^(0x4000000)|value<<26)
}
func (o *ETHERNET_Type) GetRSV_DRIBBLENIBBLE() uint32 {
	return (volatile.LoadUint32(&o.RSV.Reg) & 0x4000000) >> 26
}
func (o *ETHERNET_Type) SetRSV_CONTROLFRAME(value uint32) {
	volatile.StoreUint32(&o.RSV.Reg, volatile.LoadUint32(&o.RSV.Reg)&^(0x8000000)|value<<27)
}
func (o *ETHERNET_Type) GetRSV_CONTROLFRAME() uint32 {
	return (volatile.LoadUint32(&o.RSV.Reg) & 0x8000000) >> 27
}
func (o *ETHERNET_Type) SetRSV_PAUSE(value uint32) {
	volatile.StoreUint32(&o.RSV.Reg, volatile.LoadUint32(&o.RSV.Reg)&^(0x10000000)|value<<28)
}
func (o *ETHERNET_Type) GetRSV_PAUSE() uint32 {
	return (volatile.LoadUint32(&o.RSV.Reg) & 0x10000000) >> 28
}
func (o *ETHERNET_Type) SetRSV_UO(value uint32) {
	volatile.StoreUint32(&o.RSV.Reg, volatile.LoadUint32(&o.RSV.Reg)&^(0x20000000)|value<<29)
}
func (o *ETHERNET_Type) GetRSV_UO() uint32 {
	return (volatile.LoadUint32(&o.RSV.Reg) & 0x20000000) >> 29
}
func (o *ETHERNET_Type) SetRSV_VLAN(value uint32) {
	volatile.StoreUint32(&o.RSV.Reg, volatile.LoadUint32(&o.RSV.Reg)&^(0x40000000)|value<<30)
}
func (o *ETHERNET_Type) GetRSV_VLAN() uint32 {
	return (volatile.LoadUint32(&o.RSV.Reg) & 0x40000000) >> 30
}
func (o *ETHERNET_Type) SetRSV_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RSV.Reg, volatile.LoadUint32(&o.RSV.Reg)&^(0x80000000)|value<<31)
}
func (o *ETHERNET_Type) GetRSV_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RSV.Reg) & 0x80000000) >> 31
}

// ETHERNET.FLOWCONTROLCOUNTER: Flow control counter register.
func (o *ETHERNET_Type) SetFLOWCONTROLCOUNTER_MC(value uint32) {
	volatile.StoreUint32(&o.FLOWCONTROLCOUNTER.Reg, volatile.LoadUint32(&o.FLOWCONTROLCOUNTER.Reg)&^(0xffff)|value)
}
func (o *ETHERNET_Type) GetFLOWCONTROLCOUNTER_MC() uint32 {
	return volatile.LoadUint32(&o.FLOWCONTROLCOUNTER.Reg) & 0xffff
}
func (o *ETHERNET_Type) SetFLOWCONTROLCOUNTER_PT(value uint32) {
	volatile.StoreUint32(&o.FLOWCONTROLCOUNTER.Reg, volatile.LoadUint32(&o.FLOWCONTROLCOUNTER.Reg)&^(0xffff0000)|value<<16)
}
func (o *ETHERNET_Type) GetFLOWCONTROLCOUNTER_PT() uint32 {
	return (volatile.LoadUint32(&o.FLOWCONTROLCOUNTER.Reg) & 0xffff0000) >> 16
}

// ETHERNET.FLOWCONTROLSTATUS: Flow control status register.
func (o *ETHERNET_Type) SetFLOWCONTROLSTATUS_MCC(value uint32) {
	volatile.StoreUint32(&o.FLOWCONTROLSTATUS.Reg, volatile.LoadUint32(&o.FLOWCONTROLSTATUS.Reg)&^(0xffff)|value)
}
func (o *ETHERNET_Type) GetFLOWCONTROLSTATUS_MCC() uint32 {
	return volatile.LoadUint32(&o.FLOWCONTROLSTATUS.Reg) & 0xffff
}
func (o *ETHERNET_Type) SetFLOWCONTROLSTATUS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FLOWCONTROLSTATUS.Reg, volatile.LoadUint32(&o.FLOWCONTROLSTATUS.Reg)&^(0xffff0000)|value<<16)
}
func (o *ETHERNET_Type) GetFLOWCONTROLSTATUS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FLOWCONTROLSTATUS.Reg) & 0xffff0000) >> 16
}

// ETHERNET.RXFILTERCTRL: Receive filter control register.
func (o *ETHERNET_Type) SetRXFILTERCTRL_AUE(value uint32) {
	volatile.StoreUint32(&o.RXFILTERCTRL.Reg, volatile.LoadUint32(&o.RXFILTERCTRL.Reg)&^(0x1)|value)
}
func (o *ETHERNET_Type) GetRXFILTERCTRL_AUE() uint32 {
	return volatile.LoadUint32(&o.RXFILTERCTRL.Reg) & 0x1
}
func (o *ETHERNET_Type) SetRXFILTERCTRL_ABE(value uint32) {
	volatile.StoreUint32(&o.RXFILTERCTRL.Reg, volatile.LoadUint32(&o.RXFILTERCTRL.Reg)&^(0x2)|value<<1)
}
func (o *ETHERNET_Type) GetRXFILTERCTRL_ABE() uint32 {
	return (volatile.LoadUint32(&o.RXFILTERCTRL.Reg) & 0x2) >> 1
}
func (o *ETHERNET_Type) SetRXFILTERCTRL_AME(value uint32) {
	volatile.StoreUint32(&o.RXFILTERCTRL.Reg, volatile.LoadUint32(&o.RXFILTERCTRL.Reg)&^(0x4)|value<<2)
}
func (o *ETHERNET_Type) GetRXFILTERCTRL_AME() uint32 {
	return (volatile.LoadUint32(&o.RXFILTERCTRL.Reg) & 0x4) >> 2
}
func (o *ETHERNET_Type) SetRXFILTERCTRL_AUHE(value uint32) {
	volatile.StoreUint32(&o.RXFILTERCTRL.Reg, volatile.LoadUint32(&o.RXFILTERCTRL.Reg)&^(0x8)|value<<3)
}
func (o *ETHERNET_Type) GetRXFILTERCTRL_AUHE() uint32 {
	return (volatile.LoadUint32(&o.RXFILTERCTRL.Reg) & 0x8) >> 3
}
func (o *ETHERNET_Type) SetRXFILTERCTRL_AMHE(value uint32) {
	volatile.StoreUint32(&o.RXFILTERCTRL.Reg, volatile.LoadUint32(&o.RXFILTERCTRL.Reg)&^(0x10)|value<<4)
}
func (o *ETHERNET_Type) GetRXFILTERCTRL_AMHE() uint32 {
	return (volatile.LoadUint32(&o.RXFILTERCTRL.Reg) & 0x10) >> 4
}
func (o *ETHERNET_Type) SetRXFILTERCTRL_APE(value uint32) {
	volatile.StoreUint32(&o.RXFILTERCTRL.Reg, volatile.LoadUint32(&o.RXFILTERCTRL.Reg)&^(0x20)|value<<5)
}
func (o *ETHERNET_Type) GetRXFILTERCTRL_APE() uint32 {
	return (volatile.LoadUint32(&o.RXFILTERCTRL.Reg) & 0x20) >> 5
}
func (o *ETHERNET_Type) SetRXFILTERCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RXFILTERCTRL.Reg, volatile.LoadUint32(&o.RXFILTERCTRL.Reg)&^(0xfc0)|value<<6)
}
func (o *ETHERNET_Type) GetRXFILTERCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RXFILTERCTRL.Reg) & 0xfc0) >> 6
}
func (o *ETHERNET_Type) SetRXFILTERCTRL_MPEW(value uint32) {
	volatile.StoreUint32(&o.RXFILTERCTRL.Reg, volatile.LoadUint32(&o.RXFILTERCTRL.Reg)&^(0x1000)|value<<12)
}
func (o *ETHERNET_Type) GetRXFILTERCTRL_MPEW() uint32 {
	return (volatile.LoadUint32(&o.RXFILTERCTRL.Reg) & 0x1000) >> 12
}
func (o *ETHERNET_Type) SetRXFILTERCTRL_RFEW(value uint32) {
	volatile.StoreUint32(&o.RXFILTERCTRL.Reg, volatile.LoadUint32(&o.RXFILTERCTRL.Reg)&^(0x2000)|value<<13)
}
func (o *ETHERNET_Type) GetRXFILTERCTRL_RFEW() uint32 {
	return (volatile.LoadUint32(&o.RXFILTERCTRL.Reg) & 0x2000) >> 13
}
func (o *ETHERNET_Type) SetRXFILTERCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RXFILTERCTRL.Reg, volatile.LoadUint32(&o.RXFILTERCTRL.Reg)&^(0xffffc000)|value<<14)
}
func (o *ETHERNET_Type) GetRXFILTERCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RXFILTERCTRL.Reg) & 0xffffc000) >> 14
}

// ETHERNET.RXFILTERWOLSTATUS: Receive filter WoL status register.
func (o *ETHERNET_Type) SetRXFILTERWOLSTATUS_AUW(value uint32) {
	volatile.StoreUint32(&o.RXFILTERWOLSTATUS.Reg, volatile.LoadUint32(&o.RXFILTERWOLSTATUS.Reg)&^(0x1)|value)
}
func (o *ETHERNET_Type) GetRXFILTERWOLSTATUS_AUW() uint32 {
	return volatile.LoadUint32(&o.RXFILTERWOLSTATUS.Reg) & 0x1
}
func (o *ETHERNET_Type) SetRXFILTERWOLSTATUS_ABW(value uint32) {
	volatile.StoreUint32(&o.RXFILTERWOLSTATUS.Reg, volatile.LoadUint32(&o.RXFILTERWOLSTATUS.Reg)&^(0x2)|value<<1)
}
func (o *ETHERNET_Type) GetRXFILTERWOLSTATUS_ABW() uint32 {
	return (volatile.LoadUint32(&o.RXFILTERWOLSTATUS.Reg) & 0x2) >> 1
}
func (o *ETHERNET_Type) SetRXFILTERWOLSTATUS_AMW(value uint32) {
	volatile.StoreUint32(&o.RXFILTERWOLSTATUS.Reg, volatile.LoadUint32(&o.RXFILTERWOLSTATUS.Reg)&^(0x4)|value<<2)
}
func (o *ETHERNET_Type) GetRXFILTERWOLSTATUS_AMW() uint32 {
	return (volatile.LoadUint32(&o.RXFILTERWOLSTATUS.Reg) & 0x4) >> 2
}
func (o *ETHERNET_Type) SetRXFILTERWOLSTATUS_AUHW(value uint32) {
	volatile.StoreUint32(&o.RXFILTERWOLSTATUS.Reg, volatile.LoadUint32(&o.RXFILTERWOLSTATUS.Reg)&^(0x8)|value<<3)
}
func (o *ETHERNET_Type) GetRXFILTERWOLSTATUS_AUHW() uint32 {
	return (volatile.LoadUint32(&o.RXFILTERWOLSTATUS.Reg) & 0x8) >> 3
}
func (o *ETHERNET_Type) SetRXFILTERWOLSTATUS_AMHW(value uint32) {
	volatile.StoreUint32(&o.RXFILTERWOLSTATUS.Reg, volatile.LoadUint32(&o.RXFILTERWOLSTATUS.Reg)&^(0x10)|value<<4)
}
func (o *ETHERNET_Type) GetRXFILTERWOLSTATUS_AMHW() uint32 {
	return (volatile.LoadUint32(&o.RXFILTERWOLSTATUS.Reg) & 0x10) >> 4
}
func (o *ETHERNET_Type) SetRXFILTERWOLSTATUS_APW(value uint32) {
	volatile.StoreUint32(&o.RXFILTERWOLSTATUS.Reg, volatile.LoadUint32(&o.RXFILTERWOLSTATUS.Reg)&^(0x20)|value<<5)
}
func (o *ETHERNET_Type) GetRXFILTERWOLSTATUS_APW() uint32 {
	return (volatile.LoadUint32(&o.RXFILTERWOLSTATUS.Reg) & 0x20) >> 5
}
func (o *ETHERNET_Type) SetRXFILTERWOLSTATUS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RXFILTERWOLSTATUS.Reg, volatile.LoadUint32(&o.RXFILTERWOLSTATUS.Reg)&^(0x40)|value<<6)
}
func (o *ETHERNET_Type) GetRXFILTERWOLSTATUS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RXFILTERWOLSTATUS.Reg) & 0x40) >> 6
}
func (o *ETHERNET_Type) SetRXFILTERWOLSTATUS_RFW(value uint32) {
	volatile.StoreUint32(&o.RXFILTERWOLSTATUS.Reg, volatile.LoadUint32(&o.RXFILTERWOLSTATUS.Reg)&^(0x80)|value<<7)
}
func (o *ETHERNET_Type) GetRXFILTERWOLSTATUS_RFW() uint32 {
	return (volatile.LoadUint32(&o.RXFILTERWOLSTATUS.Reg) & 0x80) >> 7
}
func (o *ETHERNET_Type) SetRXFILTERWOLSTATUS_MPW(value uint32) {
	volatile.StoreUint32(&o.RXFILTERWOLSTATUS.Reg, volatile.LoadUint32(&o.RXFILTERWOLSTATUS.Reg)&^(0x100)|value<<8)
}
func (o *ETHERNET_Type) GetRXFILTERWOLSTATUS_MPW() uint32 {
	return (volatile.LoadUint32(&o.RXFILTERWOLSTATUS.Reg) & 0x100) >> 8
}
func (o *ETHERNET_Type) SetRXFILTERWOLSTATUS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RXFILTERWOLSTATUS.Reg, volatile.LoadUint32(&o.RXFILTERWOLSTATUS.Reg)&^(0xfffffe00)|value<<9)
}
func (o *ETHERNET_Type) GetRXFILTERWOLSTATUS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RXFILTERWOLSTATUS.Reg) & 0xfffffe00) >> 9
}

// ETHERNET.RXFILTERWOLCLEAR: Receive filter WoL clear register.
func (o *ETHERNET_Type) SetRXFILTERWOLCLEAR_AUWCLR(value uint32) {
	volatile.StoreUint32(&o.RXFILTERWOLCLEAR.Reg, volatile.LoadUint32(&o.RXFILTERWOLCLEAR.Reg)&^(0x1)|value)
}
func (o *ETHERNET_Type) GetRXFILTERWOLCLEAR_AUWCLR() uint32 {
	return volatile.LoadUint32(&o.RXFILTERWOLCLEAR.Reg) & 0x1
}
func (o *ETHERNET_Type) SetRXFILTERWOLCLEAR_ABWCLR(value uint32) {
	volatile.StoreUint32(&o.RXFILTERWOLCLEAR.Reg, volatile.LoadUint32(&o.RXFILTERWOLCLEAR.Reg)&^(0x2)|value<<1)
}
func (o *ETHERNET_Type) GetRXFILTERWOLCLEAR_ABWCLR() uint32 {
	return (volatile.LoadUint32(&o.RXFILTERWOLCLEAR.Reg) & 0x2) >> 1
}
func (o *ETHERNET_Type) SetRXFILTERWOLCLEAR_AMWCLR(value uint32) {
	volatile.StoreUint32(&o.RXFILTERWOLCLEAR.Reg, volatile.LoadUint32(&o.RXFILTERWOLCLEAR.Reg)&^(0x4)|value<<2)
}
func (o *ETHERNET_Type) GetRXFILTERWOLCLEAR_AMWCLR() uint32 {
	return (volatile.LoadUint32(&o.RXFILTERWOLCLEAR.Reg) & 0x4) >> 2
}
func (o *ETHERNET_Type) SetRXFILTERWOLCLEAR_AUHWCLR(value uint32) {
	volatile.StoreUint32(&o.RXFILTERWOLCLEAR.Reg, volatile.LoadUint32(&o.RXFILTERWOLCLEAR.Reg)&^(0x8)|value<<3)
}
func (o *ETHERNET_Type) GetRXFILTERWOLCLEAR_AUHWCLR() uint32 {
	return (volatile.LoadUint32(&o.RXFILTERWOLCLEAR.Reg) & 0x8) >> 3
}
func (o *ETHERNET_Type) SetRXFILTERWOLCLEAR_AMHWCLR(value uint32) {
	volatile.StoreUint32(&o.RXFILTERWOLCLEAR.Reg, volatile.LoadUint32(&o.RXFILTERWOLCLEAR.Reg)&^(0x10)|value<<4)
}
func (o *ETHERNET_Type) GetRXFILTERWOLCLEAR_AMHWCLR() uint32 {
	return (volatile.LoadUint32(&o.RXFILTERWOLCLEAR.Reg) & 0x10) >> 4
}
func (o *ETHERNET_Type) SetRXFILTERWOLCLEAR_APWCLR(value uint32) {
	volatile.StoreUint32(&o.RXFILTERWOLCLEAR.Reg, volatile.LoadUint32(&o.RXFILTERWOLCLEAR.Reg)&^(0x20)|value<<5)
}
func (o *ETHERNET_Type) GetRXFILTERWOLCLEAR_APWCLR() uint32 {
	return (volatile.LoadUint32(&o.RXFILTERWOLCLEAR.Reg) & 0x20) >> 5
}
func (o *ETHERNET_Type) SetRXFILTERWOLCLEAR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RXFILTERWOLCLEAR.Reg, volatile.LoadUint32(&o.RXFILTERWOLCLEAR.Reg)&^(0x40)|value<<6)
}
func (o *ETHERNET_Type) GetRXFILTERWOLCLEAR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RXFILTERWOLCLEAR.Reg) & 0x40) >> 6
}
func (o *ETHERNET_Type) SetRXFILTERWOLCLEAR_RFWCLR(value uint32) {
	volatile.StoreUint32(&o.RXFILTERWOLCLEAR.Reg, volatile.LoadUint32(&o.RXFILTERWOLCLEAR.Reg)&^(0x80)|value<<7)
}
func (o *ETHERNET_Type) GetRXFILTERWOLCLEAR_RFWCLR() uint32 {
	return (volatile.LoadUint32(&o.RXFILTERWOLCLEAR.Reg) & 0x80) >> 7
}
func (o *ETHERNET_Type) SetRXFILTERWOLCLEAR_MPWCLR(value uint32) {
	volatile.StoreUint32(&o.RXFILTERWOLCLEAR.Reg, volatile.LoadUint32(&o.RXFILTERWOLCLEAR.Reg)&^(0x100)|value<<8)
}
func (o *ETHERNET_Type) GetRXFILTERWOLCLEAR_MPWCLR() uint32 {
	return (volatile.LoadUint32(&o.RXFILTERWOLCLEAR.Reg) & 0x100) >> 8
}
func (o *ETHERNET_Type) SetRXFILTERWOLCLEAR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RXFILTERWOLCLEAR.Reg, volatile.LoadUint32(&o.RXFILTERWOLCLEAR.Reg)&^(0xfffffe00)|value<<9)
}
func (o *ETHERNET_Type) GetRXFILTERWOLCLEAR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RXFILTERWOLCLEAR.Reg) & 0xfffffe00) >> 9
}

// ETHERNET.HASHFILTERL: Hash filter table LSBs register.
func (o *ETHERNET_Type) SetHASHFILTERL(value uint32) {
	volatile.StoreUint32(&o.HASHFILTERL.Reg, value)
}
func (o *ETHERNET_Type) GetHASHFILTERL() uint32 {
	return volatile.LoadUint32(&o.HASHFILTERL.Reg)
}

// ETHERNET.HASHFILTERH: Hash filter table MSBs register.
func (o *ETHERNET_Type) SetHASHFILTERH(value uint32) {
	volatile.StoreUint32(&o.HASHFILTERH.Reg, value)
}
func (o *ETHERNET_Type) GetHASHFILTERH() uint32 {
	return volatile.LoadUint32(&o.HASHFILTERH.Reg)
}

// ETHERNET.INTSTATUS: Interrupt status register.
func (o *ETHERNET_Type) SetINTSTATUS_RXOVERRUNINT(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x1)|value)
}
func (o *ETHERNET_Type) GetINTSTATUS_RXOVERRUNINT() uint32 {
	return volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x1
}
func (o *ETHERNET_Type) SetINTSTATUS_RXERRORINT(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x2)|value<<1)
}
func (o *ETHERNET_Type) GetINTSTATUS_RXERRORINT() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x2) >> 1
}
func (o *ETHERNET_Type) SetINTSTATUS_RXFINISHEDINT(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x4)|value<<2)
}
func (o *ETHERNET_Type) GetINTSTATUS_RXFINISHEDINT() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x4) >> 2
}
func (o *ETHERNET_Type) SetINTSTATUS_RXDONEINT(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x8)|value<<3)
}
func (o *ETHERNET_Type) GetINTSTATUS_RXDONEINT() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x8) >> 3
}
func (o *ETHERNET_Type) SetINTSTATUS_TXUNDERRUNINT(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x10)|value<<4)
}
func (o *ETHERNET_Type) GetINTSTATUS_TXUNDERRUNINT() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x10) >> 4
}
func (o *ETHERNET_Type) SetINTSTATUS_TXERRORINT(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x20)|value<<5)
}
func (o *ETHERNET_Type) GetINTSTATUS_TXERRORINT() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x20) >> 5
}
func (o *ETHERNET_Type) SetINTSTATUS_TXFINISHEDINT(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x40)|value<<6)
}
func (o *ETHERNET_Type) GetINTSTATUS_TXFINISHEDINT() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x40) >> 6
}
func (o *ETHERNET_Type) SetINTSTATUS_TXDONEINT(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x80)|value<<7)
}
func (o *ETHERNET_Type) GetINTSTATUS_TXDONEINT() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x80) >> 7
}
func (o *ETHERNET_Type) SetINTSTATUS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0xf00)|value<<8)
}
func (o *ETHERNET_Type) GetINTSTATUS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0xf00) >> 8
}
func (o *ETHERNET_Type) SetINTSTATUS_SOFTINT(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x1000)|value<<12)
}
func (o *ETHERNET_Type) GetINTSTATUS_SOFTINT() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x1000) >> 12
}
func (o *ETHERNET_Type) SetINTSTATUS_WAKEUPINT(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0x2000)|value<<13)
}
func (o *ETHERNET_Type) GetINTSTATUS_WAKEUPINT() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0x2000) >> 13
}
func (o *ETHERNET_Type) SetINTSTATUS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTSTATUS.Reg, volatile.LoadUint32(&o.INTSTATUS.Reg)&^(0xffffc000)|value<<14)
}
func (o *ETHERNET_Type) GetINTSTATUS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTSTATUS.Reg) & 0xffffc000) >> 14
}

// ETHERNET.INTENABLE: Interrupt enable register.
func (o *ETHERNET_Type) SetINTENABLE_RXOVERRUNINTEN(value uint32) {
	volatile.StoreUint32(&o.INTENABLE.Reg, volatile.LoadUint32(&o.INTENABLE.Reg)&^(0x1)|value)
}
func (o *ETHERNET_Type) GetINTENABLE_RXOVERRUNINTEN() uint32 {
	return volatile.LoadUint32(&o.INTENABLE.Reg) & 0x1
}
func (o *ETHERNET_Type) SetINTENABLE_RXERRORINTEN(value uint32) {
	volatile.StoreUint32(&o.INTENABLE.Reg, volatile.LoadUint32(&o.INTENABLE.Reg)&^(0x2)|value<<1)
}
func (o *ETHERNET_Type) GetINTENABLE_RXERRORINTEN() uint32 {
	return (volatile.LoadUint32(&o.INTENABLE.Reg) & 0x2) >> 1
}
func (o *ETHERNET_Type) SetINTENABLE_RXFINISHEDINTEN(value uint32) {
	volatile.StoreUint32(&o.INTENABLE.Reg, volatile.LoadUint32(&o.INTENABLE.Reg)&^(0x4)|value<<2)
}
func (o *ETHERNET_Type) GetINTENABLE_RXFINISHEDINTEN() uint32 {
	return (volatile.LoadUint32(&o.INTENABLE.Reg) & 0x4) >> 2
}
func (o *ETHERNET_Type) SetINTENABLE_RXDONEINTEN(value uint32) {
	volatile.StoreUint32(&o.INTENABLE.Reg, volatile.LoadUint32(&o.INTENABLE.Reg)&^(0x8)|value<<3)
}
func (o *ETHERNET_Type) GetINTENABLE_RXDONEINTEN() uint32 {
	return (volatile.LoadUint32(&o.INTENABLE.Reg) & 0x8) >> 3
}
func (o *ETHERNET_Type) SetINTENABLE_TXUNDERRUNINTEN(value uint32) {
	volatile.StoreUint32(&o.INTENABLE.Reg, volatile.LoadUint32(&o.INTENABLE.Reg)&^(0x10)|value<<4)
}
func (o *ETHERNET_Type) GetINTENABLE_TXUNDERRUNINTEN() uint32 {
	return (volatile.LoadUint32(&o.INTENABLE.Reg) & 0x10) >> 4
}
func (o *ETHERNET_Type) SetINTENABLE_TXERRORINTEN(value uint32) {
	volatile.StoreUint32(&o.INTENABLE.Reg, volatile.LoadUint32(&o.INTENABLE.Reg)&^(0x20)|value<<5)
}
func (o *ETHERNET_Type) GetINTENABLE_TXERRORINTEN() uint32 {
	return (volatile.LoadUint32(&o.INTENABLE.Reg) & 0x20) >> 5
}
func (o *ETHERNET_Type) SetINTENABLE_TXFINISHEDINTEN(value uint32) {
	volatile.StoreUint32(&o.INTENABLE.Reg, volatile.LoadUint32(&o.INTENABLE.Reg)&^(0x40)|value<<6)
}
func (o *ETHERNET_Type) GetINTENABLE_TXFINISHEDINTEN() uint32 {
	return (volatile.LoadUint32(&o.INTENABLE.Reg) & 0x40) >> 6
}
func (o *ETHERNET_Type) SetINTENABLE_TXDONEINTEN(value uint32) {
	volatile.StoreUint32(&o.INTENABLE.Reg, volatile.LoadUint32(&o.INTENABLE.Reg)&^(0x80)|value<<7)
}
func (o *ETHERNET_Type) GetINTENABLE_TXDONEINTEN() uint32 {
	return (volatile.LoadUint32(&o.INTENABLE.Reg) & 0x80) >> 7
}
func (o *ETHERNET_Type) SetINTENABLE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTENABLE.Reg, volatile.LoadUint32(&o.INTENABLE.Reg)&^(0xf00)|value<<8)
}
func (o *ETHERNET_Type) GetINTENABLE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTENABLE.Reg) & 0xf00) >> 8
}
func (o *ETHERNET_Type) SetINTENABLE_SOFTINTEN(value uint32) {
	volatile.StoreUint32(&o.INTENABLE.Reg, volatile.LoadUint32(&o.INTENABLE.Reg)&^(0x1000)|value<<12)
}
func (o *ETHERNET_Type) GetINTENABLE_SOFTINTEN() uint32 {
	return (volatile.LoadUint32(&o.INTENABLE.Reg) & 0x1000) >> 12
}
func (o *ETHERNET_Type) SetINTENABLE_WAKEUPINTEN(value uint32) {
	volatile.StoreUint32(&o.INTENABLE.Reg, volatile.LoadUint32(&o.INTENABLE.Reg)&^(0x2000)|value<<13)
}
func (o *ETHERNET_Type) GetINTENABLE_WAKEUPINTEN() uint32 {
	return (volatile.LoadUint32(&o.INTENABLE.Reg) & 0x2000) >> 13
}
func (o *ETHERNET_Type) SetINTENABLE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTENABLE.Reg, volatile.LoadUint32(&o.INTENABLE.Reg)&^(0xffffc000)|value<<14)
}
func (o *ETHERNET_Type) GetINTENABLE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTENABLE.Reg) & 0xffffc000) >> 14
}

// ETHERNET.INTCLEAR: Interrupt clear register.
func (o *ETHERNET_Type) SetINTCLEAR_RXOVERRUNINTCLR(value uint32) {
	volatile.StoreUint32(&o.INTCLEAR.Reg, volatile.LoadUint32(&o.INTCLEAR.Reg)&^(0x1)|value)
}
func (o *ETHERNET_Type) GetINTCLEAR_RXOVERRUNINTCLR() uint32 {
	return volatile.LoadUint32(&o.INTCLEAR.Reg) & 0x1
}
func (o *ETHERNET_Type) SetINTCLEAR_RXERRORINTCLR(value uint32) {
	volatile.StoreUint32(&o.INTCLEAR.Reg, volatile.LoadUint32(&o.INTCLEAR.Reg)&^(0x2)|value<<1)
}
func (o *ETHERNET_Type) GetINTCLEAR_RXERRORINTCLR() uint32 {
	return (volatile.LoadUint32(&o.INTCLEAR.Reg) & 0x2) >> 1
}
func (o *ETHERNET_Type) SetINTCLEAR_RXFINISHEDINTCLR(value uint32) {
	volatile.StoreUint32(&o.INTCLEAR.Reg, volatile.LoadUint32(&o.INTCLEAR.Reg)&^(0x4)|value<<2)
}
func (o *ETHERNET_Type) GetINTCLEAR_RXFINISHEDINTCLR() uint32 {
	return (volatile.LoadUint32(&o.INTCLEAR.Reg) & 0x4) >> 2
}
func (o *ETHERNET_Type) SetINTCLEAR_RXDONEINTCLR(value uint32) {
	volatile.StoreUint32(&o.INTCLEAR.Reg, volatile.LoadUint32(&o.INTCLEAR.Reg)&^(0x8)|value<<3)
}
func (o *ETHERNET_Type) GetINTCLEAR_RXDONEINTCLR() uint32 {
	return (volatile.LoadUint32(&o.INTCLEAR.Reg) & 0x8) >> 3
}
func (o *ETHERNET_Type) SetINTCLEAR_TXUNDERRUNINTCLR(value uint32) {
	volatile.StoreUint32(&o.INTCLEAR.Reg, volatile.LoadUint32(&o.INTCLEAR.Reg)&^(0x10)|value<<4)
}
func (o *ETHERNET_Type) GetINTCLEAR_TXUNDERRUNINTCLR() uint32 {
	return (volatile.LoadUint32(&o.INTCLEAR.Reg) & 0x10) >> 4
}
func (o *ETHERNET_Type) SetINTCLEAR_TXERRORINTCLR(value uint32) {
	volatile.StoreUint32(&o.INTCLEAR.Reg, volatile.LoadUint32(&o.INTCLEAR.Reg)&^(0x20)|value<<5)
}
func (o *ETHERNET_Type) GetINTCLEAR_TXERRORINTCLR() uint32 {
	return (volatile.LoadUint32(&o.INTCLEAR.Reg) & 0x20) >> 5
}
func (o *ETHERNET_Type) SetINTCLEAR_TXFINISHEDINTCLR(value uint32) {
	volatile.StoreUint32(&o.INTCLEAR.Reg, volatile.LoadUint32(&o.INTCLEAR.Reg)&^(0x40)|value<<6)
}
func (o *ETHERNET_Type) GetINTCLEAR_TXFINISHEDINTCLR() uint32 {
	return (volatile.LoadUint32(&o.INTCLEAR.Reg) & 0x40) >> 6
}
func (o *ETHERNET_Type) SetINTCLEAR_TXDONEINTCLR(value uint32) {
	volatile.StoreUint32(&o.INTCLEAR.Reg, volatile.LoadUint32(&o.INTCLEAR.Reg)&^(0x80)|value<<7)
}
func (o *ETHERNET_Type) GetINTCLEAR_TXDONEINTCLR() uint32 {
	return (volatile.LoadUint32(&o.INTCLEAR.Reg) & 0x80) >> 7
}
func (o *ETHERNET_Type) SetINTCLEAR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTCLEAR.Reg, volatile.LoadUint32(&o.INTCLEAR.Reg)&^(0xf00)|value<<8)
}
func (o *ETHERNET_Type) GetINTCLEAR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTCLEAR.Reg) & 0xf00) >> 8
}
func (o *ETHERNET_Type) SetINTCLEAR_SOFTINTCLR(value uint32) {
	volatile.StoreUint32(&o.INTCLEAR.Reg, volatile.LoadUint32(&o.INTCLEAR.Reg)&^(0x1000)|value<<12)
}
func (o *ETHERNET_Type) GetINTCLEAR_SOFTINTCLR() uint32 {
	return (volatile.LoadUint32(&o.INTCLEAR.Reg) & 0x1000) >> 12
}
func (o *ETHERNET_Type) SetINTCLEAR_WAKEUPINTCLR(value uint32) {
	volatile.StoreUint32(&o.INTCLEAR.Reg, volatile.LoadUint32(&o.INTCLEAR.Reg)&^(0x2000)|value<<13)
}
func (o *ETHERNET_Type) GetINTCLEAR_WAKEUPINTCLR() uint32 {
	return (volatile.LoadUint32(&o.INTCLEAR.Reg) & 0x2000) >> 13
}
func (o *ETHERNET_Type) SetINTCLEAR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTCLEAR.Reg, volatile.LoadUint32(&o.INTCLEAR.Reg)&^(0xffffc000)|value<<14)
}
func (o *ETHERNET_Type) GetINTCLEAR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTCLEAR.Reg) & 0xffffc000) >> 14
}

// ETHERNET.INTSET: Interrupt set register.
func (o *ETHERNET_Type) SetINTSET_RXOVERRUNINTSET(value uint32) {
	volatile.StoreUint32(&o.INTSET.Reg, volatile.LoadUint32(&o.INTSET.Reg)&^(0x1)|value)
}
func (o *ETHERNET_Type) GetINTSET_RXOVERRUNINTSET() uint32 {
	return volatile.LoadUint32(&o.INTSET.Reg) & 0x1
}
func (o *ETHERNET_Type) SetINTSET_RXERRORINTSET(value uint32) {
	volatile.StoreUint32(&o.INTSET.Reg, volatile.LoadUint32(&o.INTSET.Reg)&^(0x2)|value<<1)
}
func (o *ETHERNET_Type) GetINTSET_RXERRORINTSET() uint32 {
	return (volatile.LoadUint32(&o.INTSET.Reg) & 0x2) >> 1
}
func (o *ETHERNET_Type) SetINTSET_RXFINISHEDINTSET(value uint32) {
	volatile.StoreUint32(&o.INTSET.Reg, volatile.LoadUint32(&o.INTSET.Reg)&^(0x4)|value<<2)
}
func (o *ETHERNET_Type) GetINTSET_RXFINISHEDINTSET() uint32 {
	return (volatile.LoadUint32(&o.INTSET.Reg) & 0x4) >> 2
}
func (o *ETHERNET_Type) SetINTSET_RXDONEINTSET(value uint32) {
	volatile.StoreUint32(&o.INTSET.Reg, volatile.LoadUint32(&o.INTSET.Reg)&^(0x8)|value<<3)
}
func (o *ETHERNET_Type) GetINTSET_RXDONEINTSET() uint32 {
	return (volatile.LoadUint32(&o.INTSET.Reg) & 0x8) >> 3
}
func (o *ETHERNET_Type) SetINTSET_TXUNDERRUNINTSET(value uint32) {
	volatile.StoreUint32(&o.INTSET.Reg, volatile.LoadUint32(&o.INTSET.Reg)&^(0x10)|value<<4)
}
func (o *ETHERNET_Type) GetINTSET_TXUNDERRUNINTSET() uint32 {
	return (volatile.LoadUint32(&o.INTSET.Reg) & 0x10) >> 4
}
func (o *ETHERNET_Type) SetINTSET_TXERRORINTSET(value uint32) {
	volatile.StoreUint32(&o.INTSET.Reg, volatile.LoadUint32(&o.INTSET.Reg)&^(0x20)|value<<5)
}
func (o *ETHERNET_Type) GetINTSET_TXERRORINTSET() uint32 {
	return (volatile.LoadUint32(&o.INTSET.Reg) & 0x20) >> 5
}
func (o *ETHERNET_Type) SetINTSET_TXFINISHEDINTSET(value uint32) {
	volatile.StoreUint32(&o.INTSET.Reg, volatile.LoadUint32(&o.INTSET.Reg)&^(0x40)|value<<6)
}
func (o *ETHERNET_Type) GetINTSET_TXFINISHEDINTSET() uint32 {
	return (volatile.LoadUint32(&o.INTSET.Reg) & 0x40) >> 6
}
func (o *ETHERNET_Type) SetINTSET_TXDONEINTSET(value uint32) {
	volatile.StoreUint32(&o.INTSET.Reg, volatile.LoadUint32(&o.INTSET.Reg)&^(0x80)|value<<7)
}
func (o *ETHERNET_Type) GetINTSET_TXDONEINTSET() uint32 {
	return (volatile.LoadUint32(&o.INTSET.Reg) & 0x80) >> 7
}
func (o *ETHERNET_Type) SetINTSET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTSET.Reg, volatile.LoadUint32(&o.INTSET.Reg)&^(0xf00)|value<<8)
}
func (o *ETHERNET_Type) GetINTSET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTSET.Reg) & 0xf00) >> 8
}
func (o *ETHERNET_Type) SetINTSET_SOFTINTSET(value uint32) {
	volatile.StoreUint32(&o.INTSET.Reg, volatile.LoadUint32(&o.INTSET.Reg)&^(0x1000)|value<<12)
}
func (o *ETHERNET_Type) GetINTSET_SOFTINTSET() uint32 {
	return (volatile.LoadUint32(&o.INTSET.Reg) & 0x1000) >> 12
}
func (o *ETHERNET_Type) SetINTSET_WAKEUPINTSET(value uint32) {
	volatile.StoreUint32(&o.INTSET.Reg, volatile.LoadUint32(&o.INTSET.Reg)&^(0x2000)|value<<13)
}
func (o *ETHERNET_Type) GetINTSET_WAKEUPINTSET() uint32 {
	return (volatile.LoadUint32(&o.INTSET.Reg) & 0x2000) >> 13
}
func (o *ETHERNET_Type) SetINTSET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTSET.Reg, volatile.LoadUint32(&o.INTSET.Reg)&^(0xffffc000)|value<<14)
}
func (o *ETHERNET_Type) GetINTSET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTSET.Reg) & 0xffffc000) >> 14
}

// ETHERNET.POWERDOWN: Power-down register.
func (o *ETHERNET_Type) SetPOWERDOWN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.POWERDOWN.Reg, volatile.LoadUint32(&o.POWERDOWN.Reg)&^(0x7fffffff)|value)
}
func (o *ETHERNET_Type) GetPOWERDOWN_RESERVED() uint32 {
	return volatile.LoadUint32(&o.POWERDOWN.Reg) & 0x7fffffff
}
func (o *ETHERNET_Type) SetPOWERDOWN_PD(value uint32) {
	volatile.StoreUint32(&o.POWERDOWN.Reg, volatile.LoadUint32(&o.POWERDOWN.Reg)&^(0x80000000)|value<<31)
}
func (o *ETHERNET_Type) GetPOWERDOWN_PD() uint32 {
	return (volatile.LoadUint32(&o.POWERDOWN.Reg) & 0x80000000) >> 31
}

// LCD controller Modification
type LCD_Type struct {
	TIMH         volatile.Register32 // 0x0
	TIMV         volatile.Register32 // 0x4
	POL          volatile.Register32 // 0x8
	LE           volatile.Register32 // 0xC
	UPBASE       volatile.Register32 // 0x10
	LPBASE       volatile.Register32 // 0x14
	CTRL         volatile.Register32 // 0x18
	INTMSK       volatile.Register32 // 0x1C
	INTRAW       volatile.Register32 // 0x20
	INTSTAT      volatile.Register32 // 0x24
	INTCLR       volatile.Register32 // 0x28
	UPCURR       volatile.Register32 // 0x2C
	LPCURR       volatile.Register32 // 0x30
	_            [460]byte
	PAL          [128]volatile.Register32 // 0x200
	_            [1024]byte
	CRSR_IMG     [256]volatile.Register32 // 0x800
	CRSR_CTRL    volatile.Register32      // 0xC00
	CRSR_CFG     volatile.Register32      // 0xC04
	CRSR_PAL0    volatile.Register32      // 0xC08
	CRSR_PAL1    volatile.Register32      // 0xC0C
	CRSR_XY      volatile.Register32      // 0xC10
	CRSR_CLIP    volatile.Register32      // 0xC14
	_            [8]byte
	CRSR_INTMSK  volatile.Register32 // 0xC20
	CRSR_INTCLR  volatile.Register32 // 0xC24
	CRSR_INTRAW  volatile.Register32 // 0xC28
	CRSR_INTSTAT volatile.Register32 // 0xC2C
}

// LCD.TIMH: Horizontal Timing Control register
func (o *LCD_Type) SetTIMH_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TIMH.Reg, volatile.LoadUint32(&o.TIMH.Reg)&^(0x3)|value)
}
func (o *LCD_Type) GetTIMH_RESERVED() uint32 {
	return volatile.LoadUint32(&o.TIMH.Reg) & 0x3
}
func (o *LCD_Type) SetTIMH_PPL(value uint32) {
	volatile.StoreUint32(&o.TIMH.Reg, volatile.LoadUint32(&o.TIMH.Reg)&^(0xfc)|value<<2)
}
func (o *LCD_Type) GetTIMH_PPL() uint32 {
	return (volatile.LoadUint32(&o.TIMH.Reg) & 0xfc) >> 2
}
func (o *LCD_Type) SetTIMH_HSW(value uint32) {
	volatile.StoreUint32(&o.TIMH.Reg, volatile.LoadUint32(&o.TIMH.Reg)&^(0xff00)|value<<8)
}
func (o *LCD_Type) GetTIMH_HSW() uint32 {
	return (volatile.LoadUint32(&o.TIMH.Reg) & 0xff00) >> 8
}
func (o *LCD_Type) SetTIMH_HFP(value uint32) {
	volatile.StoreUint32(&o.TIMH.Reg, volatile.LoadUint32(&o.TIMH.Reg)&^(0xff0000)|value<<16)
}
func (o *LCD_Type) GetTIMH_HFP() uint32 {
	return (volatile.LoadUint32(&o.TIMH.Reg) & 0xff0000) >> 16
}
func (o *LCD_Type) SetTIMH_HBP(value uint32) {
	volatile.StoreUint32(&o.TIMH.Reg, volatile.LoadUint32(&o.TIMH.Reg)&^(0xff000000)|value<<24)
}
func (o *LCD_Type) GetTIMH_HBP() uint32 {
	return (volatile.LoadUint32(&o.TIMH.Reg) & 0xff000000) >> 24
}

// LCD.TIMV: Vertical Timing Control register
func (o *LCD_Type) SetTIMV_LPP(value uint32) {
	volatile.StoreUint32(&o.TIMV.Reg, volatile.LoadUint32(&o.TIMV.Reg)&^(0x3ff)|value)
}
func (o *LCD_Type) GetTIMV_LPP() uint32 {
	return volatile.LoadUint32(&o.TIMV.Reg) & 0x3ff
}
func (o *LCD_Type) SetTIMV_VSW(value uint32) {
	volatile.StoreUint32(&o.TIMV.Reg, volatile.LoadUint32(&o.TIMV.Reg)&^(0xfc00)|value<<10)
}
func (o *LCD_Type) GetTIMV_VSW() uint32 {
	return (volatile.LoadUint32(&o.TIMV.Reg) & 0xfc00) >> 10
}
func (o *LCD_Type) SetTIMV_VFP(value uint32) {
	volatile.StoreUint32(&o.TIMV.Reg, volatile.LoadUint32(&o.TIMV.Reg)&^(0xff0000)|value<<16)
}
func (o *LCD_Type) GetTIMV_VFP() uint32 {
	return (volatile.LoadUint32(&o.TIMV.Reg) & 0xff0000) >> 16
}
func (o *LCD_Type) SetTIMV_VBP(value uint32) {
	volatile.StoreUint32(&o.TIMV.Reg, volatile.LoadUint32(&o.TIMV.Reg)&^(0xff000000)|value<<24)
}
func (o *LCD_Type) GetTIMV_VBP() uint32 {
	return (volatile.LoadUint32(&o.TIMV.Reg) & 0xff000000) >> 24
}

// LCD.POL: Clock and Signal Polarity Control register
func (o *LCD_Type) SetPOL_PCD_LO(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x1f)|value)
}
func (o *LCD_Type) GetPOL_PCD_LO() uint32 {
	return volatile.LoadUint32(&o.POL.Reg) & 0x1f
}
func (o *LCD_Type) SetPOL_CLKSEL(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x20)|value<<5)
}
func (o *LCD_Type) GetPOL_CLKSEL() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x20) >> 5
}
func (o *LCD_Type) SetPOL_ACB(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x7c0)|value<<6)
}
func (o *LCD_Type) GetPOL_ACB() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x7c0) >> 6
}
func (o *LCD_Type) SetPOL_IVS(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x800)|value<<11)
}
func (o *LCD_Type) GetPOL_IVS() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x800) >> 11
}
func (o *LCD_Type) SetPOL_IHS(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x1000)|value<<12)
}
func (o *LCD_Type) GetPOL_IHS() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x1000) >> 12
}
func (o *LCD_Type) SetPOL_IPC(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x2000)|value<<13)
}
func (o *LCD_Type) GetPOL_IPC() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x2000) >> 13
}
func (o *LCD_Type) SetPOL_IOE(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x4000)|value<<14)
}
func (o *LCD_Type) GetPOL_IOE() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x4000) >> 14
}
func (o *LCD_Type) SetPOL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x8000)|value<<15)
}
func (o *LCD_Type) GetPOL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x8000) >> 15
}
func (o *LCD_Type) SetPOL_CPL(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x3ff0000)|value<<16)
}
func (o *LCD_Type) GetPOL_CPL() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x3ff0000) >> 16
}
func (o *LCD_Type) SetPOL_BCD(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0x4000000)|value<<26)
}
func (o *LCD_Type) GetPOL_BCD() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0x4000000) >> 26
}
func (o *LCD_Type) SetPOL_PCD_HI(value uint32) {
	volatile.StoreUint32(&o.POL.Reg, volatile.LoadUint32(&o.POL.Reg)&^(0xf8000000)|value<<27)
}
func (o *LCD_Type) GetPOL_PCD_HI() uint32 {
	return (volatile.LoadUint32(&o.POL.Reg) & 0xf8000000) >> 27
}

// LCD.LE: Line End Control register
func (o *LCD_Type) SetLE_LED(value uint32) {
	volatile.StoreUint32(&o.LE.Reg, volatile.LoadUint32(&o.LE.Reg)&^(0x7f)|value)
}
func (o *LCD_Type) GetLE_LED() uint32 {
	return volatile.LoadUint32(&o.LE.Reg) & 0x7f
}
func (o *LCD_Type) SetLE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LE.Reg, volatile.LoadUint32(&o.LE.Reg)&^(0xff80)|value<<7)
}
func (o *LCD_Type) GetLE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.LE.Reg) & 0xff80) >> 7
}
func (o *LCD_Type) SetLE_LEE(value uint32) {
	volatile.StoreUint32(&o.LE.Reg, volatile.LoadUint32(&o.LE.Reg)&^(0x10000)|value<<16)
}
func (o *LCD_Type) GetLE_LEE() uint32 {
	return (volatile.LoadUint32(&o.LE.Reg) & 0x10000) >> 16
}
func (o *LCD_Type) SetLE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LE.Reg, volatile.LoadUint32(&o.LE.Reg)&^(0xfffe0000)|value<<17)
}
func (o *LCD_Type) GetLE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.LE.Reg) & 0xfffe0000) >> 17
}

// LCD.UPBASE: Upper Panel Frame Base Address register
func (o *LCD_Type) SetUPBASE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.UPBASE.Reg, volatile.LoadUint32(&o.UPBASE.Reg)&^(0x7)|value)
}
func (o *LCD_Type) GetUPBASE_RESERVED() uint32 {
	return volatile.LoadUint32(&o.UPBASE.Reg) & 0x7
}
func (o *LCD_Type) SetUPBASE_LCDUPBASE(value uint32) {
	volatile.StoreUint32(&o.UPBASE.Reg, volatile.LoadUint32(&o.UPBASE.Reg)&^(0xfffffff8)|value<<3)
}
func (o *LCD_Type) GetUPBASE_LCDUPBASE() uint32 {
	return (volatile.LoadUint32(&o.UPBASE.Reg) & 0xfffffff8) >> 3
}

// LCD.LPBASE: Lower Panel Frame Base Address register
func (o *LCD_Type) SetLPBASE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LPBASE.Reg, volatile.LoadUint32(&o.LPBASE.Reg)&^(0x7)|value)
}
func (o *LCD_Type) GetLPBASE_RESERVED() uint32 {
	return volatile.LoadUint32(&o.LPBASE.Reg) & 0x7
}
func (o *LCD_Type) SetLPBASE_LCDLPBASE(value uint32) {
	volatile.StoreUint32(&o.LPBASE.Reg, volatile.LoadUint32(&o.LPBASE.Reg)&^(0xfffffff8)|value<<3)
}
func (o *LCD_Type) GetLPBASE_LCDLPBASE() uint32 {
	return (volatile.LoadUint32(&o.LPBASE.Reg) & 0xfffffff8) >> 3
}

// LCD.CTRL: LCD Control register
func (o *LCD_Type) SetCTRL_LCDEN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetCTRL_LCDEN() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *LCD_Type) SetCTRL_LCDBPP(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xe)|value<<1)
}
func (o *LCD_Type) GetCTRL_LCDBPP() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xe) >> 1
}
func (o *LCD_Type) SetCTRL_LCDBW(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10)|value<<4)
}
func (o *LCD_Type) GetCTRL_LCDBW() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10) >> 4
}
func (o *LCD_Type) SetCTRL_LCDTFT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20)|value<<5)
}
func (o *LCD_Type) GetCTRL_LCDTFT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20) >> 5
}
func (o *LCD_Type) SetCTRL_LCDMONO8(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40)|value<<6)
}
func (o *LCD_Type) GetCTRL_LCDMONO8() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40) >> 6
}
func (o *LCD_Type) SetCTRL_LCDDUAL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80)|value<<7)
}
func (o *LCD_Type) GetCTRL_LCDDUAL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80) >> 7
}
func (o *LCD_Type) SetCTRL_BGR(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x100)|value<<8)
}
func (o *LCD_Type) GetCTRL_BGR() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x100) >> 8
}
func (o *LCD_Type) SetCTRL_BEBO(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x200)|value<<9)
}
func (o *LCD_Type) GetCTRL_BEBO() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x200) >> 9
}
func (o *LCD_Type) SetCTRL_BEPO(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x400)|value<<10)
}
func (o *LCD_Type) GetCTRL_BEPO() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x400) >> 10
}
func (o *LCD_Type) SetCTRL_LCDPWR(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x800)|value<<11)
}
func (o *LCD_Type) GetCTRL_LCDPWR() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x800) >> 11
}
func (o *LCD_Type) SetCTRL_LCDVCOMP(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x3000)|value<<12)
}
func (o *LCD_Type) GetCTRL_LCDVCOMP() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x3000) >> 12
}
func (o *LCD_Type) SetCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xc000)|value<<14)
}
func (o *LCD_Type) GetCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xc000) >> 14
}
func (o *LCD_Type) SetCTRL_WATERMARK(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *LCD_Type) GetCTRL_WATERMARK() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10000) >> 16
}
func (o *LCD_Type) SetCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xfffe0000)|value<<17)
}
func (o *LCD_Type) GetCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xfffe0000) >> 17
}

// LCD.INTMSK: Interrupt Mask register
func (o *LCD_Type) SetINTMSK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTMSK.Reg, volatile.LoadUint32(&o.INTMSK.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetINTMSK_RESERVED() uint32 {
	return volatile.LoadUint32(&o.INTMSK.Reg) & 0x1
}
func (o *LCD_Type) SetINTMSK_FUFIM(value uint32) {
	volatile.StoreUint32(&o.INTMSK.Reg, volatile.LoadUint32(&o.INTMSK.Reg)&^(0x2)|value<<1)
}
func (o *LCD_Type) GetINTMSK_FUFIM() uint32 {
	return (volatile.LoadUint32(&o.INTMSK.Reg) & 0x2) >> 1
}
func (o *LCD_Type) SetINTMSK_LNBUIM(value uint32) {
	volatile.StoreUint32(&o.INTMSK.Reg, volatile.LoadUint32(&o.INTMSK.Reg)&^(0x4)|value<<2)
}
func (o *LCD_Type) GetINTMSK_LNBUIM() uint32 {
	return (volatile.LoadUint32(&o.INTMSK.Reg) & 0x4) >> 2
}
func (o *LCD_Type) SetINTMSK_VCOMPIM(value uint32) {
	volatile.StoreUint32(&o.INTMSK.Reg, volatile.LoadUint32(&o.INTMSK.Reg)&^(0x8)|value<<3)
}
func (o *LCD_Type) GetINTMSK_VCOMPIM() uint32 {
	return (volatile.LoadUint32(&o.INTMSK.Reg) & 0x8) >> 3
}
func (o *LCD_Type) SetINTMSK_BERIM(value uint32) {
	volatile.StoreUint32(&o.INTMSK.Reg, volatile.LoadUint32(&o.INTMSK.Reg)&^(0x10)|value<<4)
}
func (o *LCD_Type) GetINTMSK_BERIM() uint32 {
	return (volatile.LoadUint32(&o.INTMSK.Reg) & 0x10) >> 4
}
func (o *LCD_Type) SetINTMSK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTMSK.Reg, volatile.LoadUint32(&o.INTMSK.Reg)&^(0xffffffe0)|value<<5)
}
func (o *LCD_Type) GetINTMSK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTMSK.Reg) & 0xffffffe0) >> 5
}

// LCD.INTRAW: Raw Interrupt Status register
func (o *LCD_Type) SetINTRAW_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTRAW.Reg, volatile.LoadUint32(&o.INTRAW.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetINTRAW_RESERVED() uint32 {
	return volatile.LoadUint32(&o.INTRAW.Reg) & 0x1
}
func (o *LCD_Type) SetINTRAW_FUFRIS(value uint32) {
	volatile.StoreUint32(&o.INTRAW.Reg, volatile.LoadUint32(&o.INTRAW.Reg)&^(0x2)|value<<1)
}
func (o *LCD_Type) GetINTRAW_FUFRIS() uint32 {
	return (volatile.LoadUint32(&o.INTRAW.Reg) & 0x2) >> 1
}
func (o *LCD_Type) SetINTRAW_LNBURIS(value uint32) {
	volatile.StoreUint32(&o.INTRAW.Reg, volatile.LoadUint32(&o.INTRAW.Reg)&^(0x4)|value<<2)
}
func (o *LCD_Type) GetINTRAW_LNBURIS() uint32 {
	return (volatile.LoadUint32(&o.INTRAW.Reg) & 0x4) >> 2
}
func (o *LCD_Type) SetINTRAW_VCOMPRIS(value uint32) {
	volatile.StoreUint32(&o.INTRAW.Reg, volatile.LoadUint32(&o.INTRAW.Reg)&^(0x8)|value<<3)
}
func (o *LCD_Type) GetINTRAW_VCOMPRIS() uint32 {
	return (volatile.LoadUint32(&o.INTRAW.Reg) & 0x8) >> 3
}
func (o *LCD_Type) SetINTRAW_BERRAW(value uint32) {
	volatile.StoreUint32(&o.INTRAW.Reg, volatile.LoadUint32(&o.INTRAW.Reg)&^(0x10)|value<<4)
}
func (o *LCD_Type) GetINTRAW_BERRAW() uint32 {
	return (volatile.LoadUint32(&o.INTRAW.Reg) & 0x10) >> 4
}
func (o *LCD_Type) SetINTRAW_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTRAW.Reg, volatile.LoadUint32(&o.INTRAW.Reg)&^(0xffffffe0)|value<<5)
}
func (o *LCD_Type) GetINTRAW_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTRAW.Reg) & 0xffffffe0) >> 5
}

// LCD.INTSTAT: Masked Interrupt Status register
func (o *LCD_Type) SetINTSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetINTSTAT_RESERVED() uint32 {
	return volatile.LoadUint32(&o.INTSTAT.Reg) & 0x1
}
func (o *LCD_Type) SetINTSTAT_FUFMIS(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x2)|value<<1)
}
func (o *LCD_Type) GetINTSTAT_FUFMIS() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x2) >> 1
}
func (o *LCD_Type) SetINTSTAT_LNBUMIS(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x4)|value<<2)
}
func (o *LCD_Type) GetINTSTAT_LNBUMIS() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x4) >> 2
}
func (o *LCD_Type) SetINTSTAT_VCOMPMIS(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x8)|value<<3)
}
func (o *LCD_Type) GetINTSTAT_VCOMPMIS() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x8) >> 3
}
func (o *LCD_Type) SetINTSTAT_BERMIS(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x10)|value<<4)
}
func (o *LCD_Type) GetINTSTAT_BERMIS() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x10) >> 4
}
func (o *LCD_Type) SetINTSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0xffffffe0)|value<<5)
}
func (o *LCD_Type) GetINTSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0xffffffe0) >> 5
}

// LCD.INTCLR: Interrupt Clear register
func (o *LCD_Type) SetINTCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTCLR.Reg, volatile.LoadUint32(&o.INTCLR.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetINTCLR_RESERVED() uint32 {
	return volatile.LoadUint32(&o.INTCLR.Reg) & 0x1
}
func (o *LCD_Type) SetINTCLR_FUFIC(value uint32) {
	volatile.StoreUint32(&o.INTCLR.Reg, volatile.LoadUint32(&o.INTCLR.Reg)&^(0x2)|value<<1)
}
func (o *LCD_Type) GetINTCLR_FUFIC() uint32 {
	return (volatile.LoadUint32(&o.INTCLR.Reg) & 0x2) >> 1
}
func (o *LCD_Type) SetINTCLR_LNBUIC(value uint32) {
	volatile.StoreUint32(&o.INTCLR.Reg, volatile.LoadUint32(&o.INTCLR.Reg)&^(0x4)|value<<2)
}
func (o *LCD_Type) GetINTCLR_LNBUIC() uint32 {
	return (volatile.LoadUint32(&o.INTCLR.Reg) & 0x4) >> 2
}
func (o *LCD_Type) SetINTCLR_VCOMPIC(value uint32) {
	volatile.StoreUint32(&o.INTCLR.Reg, volatile.LoadUint32(&o.INTCLR.Reg)&^(0x8)|value<<3)
}
func (o *LCD_Type) GetINTCLR_VCOMPIC() uint32 {
	return (volatile.LoadUint32(&o.INTCLR.Reg) & 0x8) >> 3
}
func (o *LCD_Type) SetINTCLR_BERIC(value uint32) {
	volatile.StoreUint32(&o.INTCLR.Reg, volatile.LoadUint32(&o.INTCLR.Reg)&^(0x10)|value<<4)
}
func (o *LCD_Type) GetINTCLR_BERIC() uint32 {
	return (volatile.LoadUint32(&o.INTCLR.Reg) & 0x10) >> 4
}
func (o *LCD_Type) SetINTCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTCLR.Reg, volatile.LoadUint32(&o.INTCLR.Reg)&^(0xffffffe0)|value<<5)
}
func (o *LCD_Type) GetINTCLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTCLR.Reg) & 0xffffffe0) >> 5
}

// LCD.UPCURR: Upper Panel Current Address Value register
func (o *LCD_Type) SetUPCURR(value uint32) {
	volatile.StoreUint32(&o.UPCURR.Reg, value)
}
func (o *LCD_Type) GetUPCURR() uint32 {
	return volatile.LoadUint32(&o.UPCURR.Reg)
}

// LCD.LPCURR: Lower Panel Current Address Value register
func (o *LCD_Type) SetLPCURR(value uint32) {
	volatile.StoreUint32(&o.LPCURR.Reg, value)
}
func (o *LCD_Type) GetLPCURR() uint32 {
	return volatile.LoadUint32(&o.LPCURR.Reg)
}

// LCD.PAL: 256x16-bit Color Palette registers
func (o *LCD_Type) SetPAL_R04_0(idx int, value uint32) {
	volatile.StoreUint32(&o.PAL[idx].Reg, volatile.LoadUint32(&o.PAL[idx].Reg)&^(0x1f)|value)
}
func (o *LCD_Type) GetPAL_R04_0(idx int) uint32 {
	return volatile.LoadUint32(&o.PAL[idx].Reg) & 0x1f
}
func (o *LCD_Type) SetPAL_G04_0(idx int, value uint32) {
	volatile.StoreUint32(&o.PAL[idx].Reg, volatile.LoadUint32(&o.PAL[idx].Reg)&^(0x3e0)|value<<5)
}
func (o *LCD_Type) GetPAL_G04_0(idx int) uint32 {
	return (volatile.LoadUint32(&o.PAL[idx].Reg) & 0x3e0) >> 5
}
func (o *LCD_Type) SetPAL_B04_0(idx int, value uint32) {
	volatile.StoreUint32(&o.PAL[idx].Reg, volatile.LoadUint32(&o.PAL[idx].Reg)&^(0x7c00)|value<<10)
}
func (o *LCD_Type) GetPAL_B04_0(idx int) uint32 {
	return (volatile.LoadUint32(&o.PAL[idx].Reg) & 0x7c00) >> 10
}
func (o *LCD_Type) SetPAL_I0(idx int, value uint32) {
	volatile.StoreUint32(&o.PAL[idx].Reg, volatile.LoadUint32(&o.PAL[idx].Reg)&^(0x8000)|value<<15)
}
func (o *LCD_Type) GetPAL_I0(idx int) uint32 {
	return (volatile.LoadUint32(&o.PAL[idx].Reg) & 0x8000) >> 15
}
func (o *LCD_Type) SetPAL_R14_0(idx int, value uint32) {
	volatile.StoreUint32(&o.PAL[idx].Reg, volatile.LoadUint32(&o.PAL[idx].Reg)&^(0x1f0000)|value<<16)
}
func (o *LCD_Type) GetPAL_R14_0(idx int) uint32 {
	return (volatile.LoadUint32(&o.PAL[idx].Reg) & 0x1f0000) >> 16
}
func (o *LCD_Type) SetPAL_G14_0(idx int, value uint32) {
	volatile.StoreUint32(&o.PAL[idx].Reg, volatile.LoadUint32(&o.PAL[idx].Reg)&^(0x3e00000)|value<<21)
}
func (o *LCD_Type) GetPAL_G14_0(idx int) uint32 {
	return (volatile.LoadUint32(&o.PAL[idx].Reg) & 0x3e00000) >> 21
}
func (o *LCD_Type) SetPAL_B14_0(idx int, value uint32) {
	volatile.StoreUint32(&o.PAL[idx].Reg, volatile.LoadUint32(&o.PAL[idx].Reg)&^(0x7c000000)|value<<26)
}
func (o *LCD_Type) GetPAL_B14_0(idx int) uint32 {
	return (volatile.LoadUint32(&o.PAL[idx].Reg) & 0x7c000000) >> 26
}
func (o *LCD_Type) SetPAL_I1(idx int, value uint32) {
	volatile.StoreUint32(&o.PAL[idx].Reg, volatile.LoadUint32(&o.PAL[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *LCD_Type) GetPAL_I1(idx int) uint32 {
	return (volatile.LoadUint32(&o.PAL[idx].Reg) & 0x80000000) >> 31
}

// LCD.CRSR_IMG: Cursor Image registers
func (o *LCD_Type) SetCRSR_IMG(idx int, value uint32) {
	volatile.StoreUint32(&o.CRSR_IMG[idx].Reg, value)
}
func (o *LCD_Type) GetCRSR_IMG(idx int) uint32 {
	return volatile.LoadUint32(&o.CRSR_IMG[idx].Reg)
}

// LCD.CRSR_CTRL: Cursor Control register
func (o *LCD_Type) SetCRSR_CTRL_CRSRON(value uint32) {
	volatile.StoreUint32(&o.CRSR_CTRL.Reg, volatile.LoadUint32(&o.CRSR_CTRL.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetCRSR_CTRL_CRSRON() uint32 {
	return volatile.LoadUint32(&o.CRSR_CTRL.Reg) & 0x1
}
func (o *LCD_Type) SetCRSR_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CRSR_CTRL.Reg, volatile.LoadUint32(&o.CRSR_CTRL.Reg)&^(0xe)|value<<1)
}
func (o *LCD_Type) GetCRSR_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CRSR_CTRL.Reg) & 0xe) >> 1
}
func (o *LCD_Type) SetCRSR_CTRL_CRSRNUM1_0(value uint32) {
	volatile.StoreUint32(&o.CRSR_CTRL.Reg, volatile.LoadUint32(&o.CRSR_CTRL.Reg)&^(0x30)|value<<4)
}
func (o *LCD_Type) GetCRSR_CTRL_CRSRNUM1_0() uint32 {
	return (volatile.LoadUint32(&o.CRSR_CTRL.Reg) & 0x30) >> 4
}
func (o *LCD_Type) SetCRSR_CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CRSR_CTRL.Reg, volatile.LoadUint32(&o.CRSR_CTRL.Reg)&^(0xffffffc0)|value<<6)
}
func (o *LCD_Type) GetCRSR_CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CRSR_CTRL.Reg) & 0xffffffc0) >> 6
}

// LCD.CRSR_CFG: Cursor Configuration register
func (o *LCD_Type) SetCRSR_CFG_CRSRSIZE(value uint32) {
	volatile.StoreUint32(&o.CRSR_CFG.Reg, volatile.LoadUint32(&o.CRSR_CFG.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetCRSR_CFG_CRSRSIZE() uint32 {
	return volatile.LoadUint32(&o.CRSR_CFG.Reg) & 0x1
}
func (o *LCD_Type) SetCRSR_CFG_FRAMESYNC(value uint32) {
	volatile.StoreUint32(&o.CRSR_CFG.Reg, volatile.LoadUint32(&o.CRSR_CFG.Reg)&^(0x2)|value<<1)
}
func (o *LCD_Type) GetCRSR_CFG_FRAMESYNC() uint32 {
	return (volatile.LoadUint32(&o.CRSR_CFG.Reg) & 0x2) >> 1
}
func (o *LCD_Type) SetCRSR_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CRSR_CFG.Reg, volatile.LoadUint32(&o.CRSR_CFG.Reg)&^(0xfffffffc)|value<<2)
}
func (o *LCD_Type) GetCRSR_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CRSR_CFG.Reg) & 0xfffffffc) >> 2
}

// LCD.CRSR_PAL0: Cursor Palette register 0
func (o *LCD_Type) SetCRSR_PAL0_RED(value uint32) {
	volatile.StoreUint32(&o.CRSR_PAL0.Reg, volatile.LoadUint32(&o.CRSR_PAL0.Reg)&^(0xff)|value)
}
func (o *LCD_Type) GetCRSR_PAL0_RED() uint32 {
	return volatile.LoadUint32(&o.CRSR_PAL0.Reg) & 0xff
}
func (o *LCD_Type) SetCRSR_PAL0_GREEN(value uint32) {
	volatile.StoreUint32(&o.CRSR_PAL0.Reg, volatile.LoadUint32(&o.CRSR_PAL0.Reg)&^(0xff00)|value<<8)
}
func (o *LCD_Type) GetCRSR_PAL0_GREEN() uint32 {
	return (volatile.LoadUint32(&o.CRSR_PAL0.Reg) & 0xff00) >> 8
}
func (o *LCD_Type) SetCRSR_PAL0_BLUE(value uint32) {
	volatile.StoreUint32(&o.CRSR_PAL0.Reg, volatile.LoadUint32(&o.CRSR_PAL0.Reg)&^(0xff0000)|value<<16)
}
func (o *LCD_Type) GetCRSR_PAL0_BLUE() uint32 {
	return (volatile.LoadUint32(&o.CRSR_PAL0.Reg) & 0xff0000) >> 16
}
func (o *LCD_Type) SetCRSR_PAL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CRSR_PAL0.Reg, volatile.LoadUint32(&o.CRSR_PAL0.Reg)&^(0xff000000)|value<<24)
}
func (o *LCD_Type) GetCRSR_PAL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CRSR_PAL0.Reg) & 0xff000000) >> 24
}

// LCD.CRSR_PAL1: Cursor Palette register 1
func (o *LCD_Type) SetCRSR_PAL1_RED(value uint32) {
	volatile.StoreUint32(&o.CRSR_PAL1.Reg, volatile.LoadUint32(&o.CRSR_PAL1.Reg)&^(0xff)|value)
}
func (o *LCD_Type) GetCRSR_PAL1_RED() uint32 {
	return volatile.LoadUint32(&o.CRSR_PAL1.Reg) & 0xff
}
func (o *LCD_Type) SetCRSR_PAL1_GREEN(value uint32) {
	volatile.StoreUint32(&o.CRSR_PAL1.Reg, volatile.LoadUint32(&o.CRSR_PAL1.Reg)&^(0xff00)|value<<8)
}
func (o *LCD_Type) GetCRSR_PAL1_GREEN() uint32 {
	return (volatile.LoadUint32(&o.CRSR_PAL1.Reg) & 0xff00) >> 8
}
func (o *LCD_Type) SetCRSR_PAL1_BLUE(value uint32) {
	volatile.StoreUint32(&o.CRSR_PAL1.Reg, volatile.LoadUint32(&o.CRSR_PAL1.Reg)&^(0xff0000)|value<<16)
}
func (o *LCD_Type) GetCRSR_PAL1_BLUE() uint32 {
	return (volatile.LoadUint32(&o.CRSR_PAL1.Reg) & 0xff0000) >> 16
}
func (o *LCD_Type) SetCRSR_PAL1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CRSR_PAL1.Reg, volatile.LoadUint32(&o.CRSR_PAL1.Reg)&^(0xff000000)|value<<24)
}
func (o *LCD_Type) GetCRSR_PAL1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CRSR_PAL1.Reg) & 0xff000000) >> 24
}

// LCD.CRSR_XY: Cursor XY Position register
func (o *LCD_Type) SetCRSR_XY_CRSRX(value uint32) {
	volatile.StoreUint32(&o.CRSR_XY.Reg, volatile.LoadUint32(&o.CRSR_XY.Reg)&^(0x3ff)|value)
}
func (o *LCD_Type) GetCRSR_XY_CRSRX() uint32 {
	return volatile.LoadUint32(&o.CRSR_XY.Reg) & 0x3ff
}
func (o *LCD_Type) SetCRSR_XY_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CRSR_XY.Reg, volatile.LoadUint32(&o.CRSR_XY.Reg)&^(0xfc00)|value<<10)
}
func (o *LCD_Type) GetCRSR_XY_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CRSR_XY.Reg) & 0xfc00) >> 10
}
func (o *LCD_Type) SetCRSR_XY_CRSRY(value uint32) {
	volatile.StoreUint32(&o.CRSR_XY.Reg, volatile.LoadUint32(&o.CRSR_XY.Reg)&^(0x3ff0000)|value<<16)
}
func (o *LCD_Type) GetCRSR_XY_CRSRY() uint32 {
	return (volatile.LoadUint32(&o.CRSR_XY.Reg) & 0x3ff0000) >> 16
}
func (o *LCD_Type) SetCRSR_XY_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CRSR_XY.Reg, volatile.LoadUint32(&o.CRSR_XY.Reg)&^(0xfc000000)|value<<26)
}
func (o *LCD_Type) GetCRSR_XY_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CRSR_XY.Reg) & 0xfc000000) >> 26
}

// LCD.CRSR_CLIP: Cursor Clip Position register
func (o *LCD_Type) SetCRSR_CLIP_CRSRCLIPX(value uint32) {
	volatile.StoreUint32(&o.CRSR_CLIP.Reg, volatile.LoadUint32(&o.CRSR_CLIP.Reg)&^(0x3f)|value)
}
func (o *LCD_Type) GetCRSR_CLIP_CRSRCLIPX() uint32 {
	return volatile.LoadUint32(&o.CRSR_CLIP.Reg) & 0x3f
}
func (o *LCD_Type) SetCRSR_CLIP_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CRSR_CLIP.Reg, volatile.LoadUint32(&o.CRSR_CLIP.Reg)&^(0xc0)|value<<6)
}
func (o *LCD_Type) GetCRSR_CLIP_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CRSR_CLIP.Reg) & 0xc0) >> 6
}
func (o *LCD_Type) SetCRSR_CLIP_CRSRCLIPY(value uint32) {
	volatile.StoreUint32(&o.CRSR_CLIP.Reg, volatile.LoadUint32(&o.CRSR_CLIP.Reg)&^(0x3f00)|value<<8)
}
func (o *LCD_Type) GetCRSR_CLIP_CRSRCLIPY() uint32 {
	return (volatile.LoadUint32(&o.CRSR_CLIP.Reg) & 0x3f00) >> 8
}
func (o *LCD_Type) SetCRSR_CLIP_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CRSR_CLIP.Reg, volatile.LoadUint32(&o.CRSR_CLIP.Reg)&^(0xffffc000)|value<<14)
}
func (o *LCD_Type) GetCRSR_CLIP_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CRSR_CLIP.Reg) & 0xffffc000) >> 14
}

// LCD.CRSR_INTMSK: Cursor Interrupt Mask register
func (o *LCD_Type) SetCRSR_INTMSK_CRSRIM(value uint32) {
	volatile.StoreUint32(&o.CRSR_INTMSK.Reg, volatile.LoadUint32(&o.CRSR_INTMSK.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetCRSR_INTMSK_CRSRIM() uint32 {
	return volatile.LoadUint32(&o.CRSR_INTMSK.Reg) & 0x1
}
func (o *LCD_Type) SetCRSR_INTMSK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CRSR_INTMSK.Reg, volatile.LoadUint32(&o.CRSR_INTMSK.Reg)&^(0xfffffffe)|value<<1)
}
func (o *LCD_Type) GetCRSR_INTMSK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CRSR_INTMSK.Reg) & 0xfffffffe) >> 1
}

// LCD.CRSR_INTCLR: Cursor Interrupt Clear register
func (o *LCD_Type) SetCRSR_INTCLR_CRSRIC(value uint32) {
	volatile.StoreUint32(&o.CRSR_INTCLR.Reg, volatile.LoadUint32(&o.CRSR_INTCLR.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetCRSR_INTCLR_CRSRIC() uint32 {
	return volatile.LoadUint32(&o.CRSR_INTCLR.Reg) & 0x1
}
func (o *LCD_Type) SetCRSR_INTCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CRSR_INTCLR.Reg, volatile.LoadUint32(&o.CRSR_INTCLR.Reg)&^(0xfffffffe)|value<<1)
}
func (o *LCD_Type) GetCRSR_INTCLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CRSR_INTCLR.Reg) & 0xfffffffe) >> 1
}

// LCD.CRSR_INTRAW: Cursor Raw Interrupt Status register
func (o *LCD_Type) SetCRSR_INTRAW_CRSRRIS(value uint32) {
	volatile.StoreUint32(&o.CRSR_INTRAW.Reg, volatile.LoadUint32(&o.CRSR_INTRAW.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetCRSR_INTRAW_CRSRRIS() uint32 {
	return volatile.LoadUint32(&o.CRSR_INTRAW.Reg) & 0x1
}
func (o *LCD_Type) SetCRSR_INTRAW_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CRSR_INTRAW.Reg, volatile.LoadUint32(&o.CRSR_INTRAW.Reg)&^(0xfffffffe)|value<<1)
}
func (o *LCD_Type) GetCRSR_INTRAW_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CRSR_INTRAW.Reg) & 0xfffffffe) >> 1
}

// LCD.CRSR_INTSTAT: Cursor Masked Interrupt Status register
func (o *LCD_Type) SetCRSR_INTSTAT_CRSRMIS(value uint32) {
	volatile.StoreUint32(&o.CRSR_INTSTAT.Reg, volatile.LoadUint32(&o.CRSR_INTSTAT.Reg)&^(0x1)|value)
}
func (o *LCD_Type) GetCRSR_INTSTAT_CRSRMIS() uint32 {
	return volatile.LoadUint32(&o.CRSR_INTSTAT.Reg) & 0x1
}
func (o *LCD_Type) SetCRSR_INTSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CRSR_INTSTAT.Reg, volatile.LoadUint32(&o.CRSR_INTSTAT.Reg)&^(0xfffffffe)|value<<1)
}
func (o *LCD_Type) GetCRSR_INTSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CRSR_INTSTAT.Reg) & 0xfffffffe) >> 1
}

// USB device controller
type USB_Type struct {
	_            [220]byte
	RXPLEN       volatile.Register32 // 0xDC
	_            [32]byte
	INTST        volatile.Register32 // 0x100
	INTEN        volatile.Register32 // 0x104
	INTSET       volatile.Register32 // 0x108
	INCLR        volatile.Register32 // 0x10C
	PORTSEL      volatile.Register32 // 0x110
	TMR          volatile.Register32 // 0x114
	_            [232]byte
	DEVINTST     volatile.Register32 // 0x200
	DEVINTEN     volatile.Register32 // 0x204
	DEVINTCLR    volatile.Register32 // 0x208
	DEVINTSET    volatile.Register32 // 0x20C
	CMDCODE      volatile.Register32 // 0x210
	CMDDATA      volatile.Register32 // 0x214
	RXDATA       volatile.Register32 // 0x218
	TXDATA       volatile.Register32 // 0x21C
	_            [4]byte
	TXPLEN       volatile.Register32 // 0x224
	CTRL         volatile.Register32 // 0x228
	DEVINTPRI    volatile.Register32 // 0x22C
	EPINTST      volatile.Register32 // 0x230
	EPINTEN      volatile.Register32 // 0x234
	EPINTCLR     volatile.Register32 // 0x238
	EPINTSET     volatile.Register32 // 0x23C
	EPINTPRI     volatile.Register32 // 0x240
	REEP         volatile.Register32 // 0x244
	EPIN         volatile.Register32 // 0x248
	MAXPSIZE     volatile.Register32 // 0x24C
	DMARST       volatile.Register32 // 0x250
	DMARCLR      volatile.Register32 // 0x254
	DMARSET      volatile.Register32 // 0x258
	_            [36]byte
	UDCAH        volatile.Register32 // 0x280
	EPDMAST      volatile.Register32 // 0x284
	EPDMAEN      volatile.Register32 // 0x288
	EPDMADIS     volatile.Register32 // 0x28C
	DMAINTST     volatile.Register32 // 0x290
	DMAINTEN     volatile.Register32 // 0x294
	_            [8]byte
	EOTINTST     volatile.Register32 // 0x2A0
	EOTINTCLR    volatile.Register32 // 0x2A4
	EOTINTSET    volatile.Register32 // 0x2A8
	NDDRINTST    volatile.Register32 // 0x2AC
	NDDRINTCLR   volatile.Register32 // 0x2B0
	NDDRINTSET   volatile.Register32 // 0x2B4
	SYSERRINTST  volatile.Register32 // 0x2B8
	SYSERRINTCLR volatile.Register32 // 0x2BC
	SYSERRINTSET volatile.Register32 // 0x2C0
	_            [60]byte
	I2C_RX       volatile.Register32 // 0x300
	I2C_STS      volatile.Register32 // 0x304
	I2C_CTL      volatile.Register32 // 0x308
	I2C_CLKHI    volatile.Register32 // 0x30C
	I2C_CLKLO    volatile.Register32 // 0x310
	_            [3296]byte
	CLKCTRL      volatile.Register32 // 0xFF4
	OTGClkSt     volatile.Register32 // 0xFF8
}

// USB.RXPLEN: USB Receive Packet Length
func (o *USB_Type) SetRXPLEN_PKT_LNGTH(value uint32) {
	volatile.StoreUint32(&o.RXPLEN.Reg, volatile.LoadUint32(&o.RXPLEN.Reg)&^(0x3ff)|value)
}
func (o *USB_Type) GetRXPLEN_PKT_LNGTH() uint32 {
	return volatile.LoadUint32(&o.RXPLEN.Reg) & 0x3ff
}
func (o *USB_Type) SetRXPLEN_DV(value uint32) {
	volatile.StoreUint32(&o.RXPLEN.Reg, volatile.LoadUint32(&o.RXPLEN.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetRXPLEN_DV() uint32 {
	return (volatile.LoadUint32(&o.RXPLEN.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetRXPLEN_PKT_RDY(value uint32) {
	volatile.StoreUint32(&o.RXPLEN.Reg, volatile.LoadUint32(&o.RXPLEN.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetRXPLEN_PKT_RDY() uint32 {
	return (volatile.LoadUint32(&o.RXPLEN.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetRXPLEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RXPLEN.Reg, volatile.LoadUint32(&o.RXPLEN.Reg)&^(0xfffff000)|value<<12)
}
func (o *USB_Type) GetRXPLEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RXPLEN.Reg) & 0xfffff000) >> 12
}

// USB.INTST: OTG Interrupt Status
func (o *USB_Type) SetINTST_TMR(value uint32) {
	volatile.StoreUint32(&o.INTST.Reg, volatile.LoadUint32(&o.INTST.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetINTST_TMR() uint32 {
	return volatile.LoadUint32(&o.INTST.Reg) & 0x1
}
func (o *USB_Type) SetINTST_REMOVE_PU(value uint32) {
	volatile.StoreUint32(&o.INTST.Reg, volatile.LoadUint32(&o.INTST.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetINTST_REMOVE_PU() uint32 {
	return (volatile.LoadUint32(&o.INTST.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetINTST_HNP_FAILURE(value uint32) {
	volatile.StoreUint32(&o.INTST.Reg, volatile.LoadUint32(&o.INTST.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetINTST_HNP_FAILURE() uint32 {
	return (volatile.LoadUint32(&o.INTST.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetINTST_HNP_SUCCESS(value uint32) {
	volatile.StoreUint32(&o.INTST.Reg, volatile.LoadUint32(&o.INTST.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetINTST_HNP_SUCCESS() uint32 {
	return (volatile.LoadUint32(&o.INTST.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetINTST_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTST.Reg, volatile.LoadUint32(&o.INTST.Reg)&^(0xfffffff0)|value<<4)
}
func (o *USB_Type) GetINTST_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTST.Reg) & 0xfffffff0) >> 4
}

// USB.INTEN: OTG Interrupt Enable
func (o *USB_Type) SetINTEN_TMR_EN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetINTEN_TMR_EN() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *USB_Type) SetINTEN_REMOVE_PU_EN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetINTEN_REMOVE_PU_EN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetINTEN_HNP_FAILURE_EN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetINTEN_HNP_FAILURE_EN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetINTEN_HNP_SUCCES_EN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetINTEN_HNP_SUCCES_EN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetINTEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0xfffffff0)|value<<4)
}
func (o *USB_Type) GetINTEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0xfffffff0) >> 4
}

// USB.INTSET: OTG Interrupt Set
func (o *USB_Type) SetINTSET_TMR_SET(value uint32) {
	volatile.StoreUint32(&o.INTSET.Reg, volatile.LoadUint32(&o.INTSET.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetINTSET_TMR_SET() uint32 {
	return volatile.LoadUint32(&o.INTSET.Reg) & 0x1
}
func (o *USB_Type) SetINTSET_REMOVE_PU_SET(value uint32) {
	volatile.StoreUint32(&o.INTSET.Reg, volatile.LoadUint32(&o.INTSET.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetINTSET_REMOVE_PU_SET() uint32 {
	return (volatile.LoadUint32(&o.INTSET.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetINTSET_HNP_FAILURE_SET(value uint32) {
	volatile.StoreUint32(&o.INTSET.Reg, volatile.LoadUint32(&o.INTSET.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetINTSET_HNP_FAILURE_SET() uint32 {
	return (volatile.LoadUint32(&o.INTSET.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetINTSET_HNP_SUCCES_SET(value uint32) {
	volatile.StoreUint32(&o.INTSET.Reg, volatile.LoadUint32(&o.INTSET.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetINTSET_HNP_SUCCES_SET() uint32 {
	return (volatile.LoadUint32(&o.INTSET.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetINTSET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTSET.Reg, volatile.LoadUint32(&o.INTSET.Reg)&^(0xfffffff0)|value<<4)
}
func (o *USB_Type) GetINTSET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTSET.Reg) & 0xfffffff0) >> 4
}

// USB.INCLR: OTG Interrupt Clear
func (o *USB_Type) SetINCLR_TMR_CLR(value uint32) {
	volatile.StoreUint32(&o.INCLR.Reg, volatile.LoadUint32(&o.INCLR.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetINCLR_TMR_CLR() uint32 {
	return volatile.LoadUint32(&o.INCLR.Reg) & 0x1
}
func (o *USB_Type) SetINCLR_REMOVE_PU_CLR(value uint32) {
	volatile.StoreUint32(&o.INCLR.Reg, volatile.LoadUint32(&o.INCLR.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetINCLR_REMOVE_PU_CLR() uint32 {
	return (volatile.LoadUint32(&o.INCLR.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetINCLR_HNP_FAILURE_CLR(value uint32) {
	volatile.StoreUint32(&o.INCLR.Reg, volatile.LoadUint32(&o.INCLR.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetINCLR_HNP_FAILURE_CLR() uint32 {
	return (volatile.LoadUint32(&o.INCLR.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetINCLR_HNP_SUCCES_CLR(value uint32) {
	volatile.StoreUint32(&o.INCLR.Reg, volatile.LoadUint32(&o.INCLR.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetINCLR_HNP_SUCCES_CLR() uint32 {
	return (volatile.LoadUint32(&o.INCLR.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetINCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INCLR.Reg, volatile.LoadUint32(&o.INCLR.Reg)&^(0xfffffff0)|value<<4)
}
func (o *USB_Type) GetINCLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INCLR.Reg) & 0xfffffff0) >> 4
}

// USB.PORTSEL: USB Port Select. The USBPortSel register is identical to the OTGStCtrl register (see Section 15.8.6). In device-only operations only bits 0 and 1 of this register are used to control the routing of USB pins to Port 1 or Port 2.
func (o *USB_Type) SetPORTSEL(value uint32) {
	volatile.StoreUint32(&o.PORTSEL.Reg, volatile.LoadUint32(&o.PORTSEL.Reg)&^(0x3)|value)
}
func (o *USB_Type) GetPORTSEL() uint32 {
	return volatile.LoadUint32(&o.PORTSEL.Reg) & 0x3
}
func (o *USB_Type) SetPORTSEL_TMR_SCALE(value uint32) {
	volatile.StoreUint32(&o.PORTSEL.Reg, volatile.LoadUint32(&o.PORTSEL.Reg)&^(0xc)|value<<2)
}
func (o *USB_Type) GetPORTSEL_TMR_SCALE() uint32 {
	return (volatile.LoadUint32(&o.PORTSEL.Reg) & 0xc) >> 2
}
func (o *USB_Type) SetPORTSEL_TMR_MODE(value uint32) {
	volatile.StoreUint32(&o.PORTSEL.Reg, volatile.LoadUint32(&o.PORTSEL.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetPORTSEL_TMR_MODE() uint32 {
	return (volatile.LoadUint32(&o.PORTSEL.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetPORTSEL_TMR_EN(value uint32) {
	volatile.StoreUint32(&o.PORTSEL.Reg, volatile.LoadUint32(&o.PORTSEL.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetPORTSEL_TMR_EN() uint32 {
	return (volatile.LoadUint32(&o.PORTSEL.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetPORTSEL_TMR_RST(value uint32) {
	volatile.StoreUint32(&o.PORTSEL.Reg, volatile.LoadUint32(&o.PORTSEL.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetPORTSEL_TMR_RST() uint32 {
	return (volatile.LoadUint32(&o.PORTSEL.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetPORTSEL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PORTSEL.Reg, volatile.LoadUint32(&o.PORTSEL.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetPORTSEL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PORTSEL.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetPORTSEL_B_HNP_TRACK(value uint32) {
	volatile.StoreUint32(&o.PORTSEL.Reg, volatile.LoadUint32(&o.PORTSEL.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetPORTSEL_B_HNP_TRACK() uint32 {
	return (volatile.LoadUint32(&o.PORTSEL.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetPORTSEL_A_HNP_TRACK(value uint32) {
	volatile.StoreUint32(&o.PORTSEL.Reg, volatile.LoadUint32(&o.PORTSEL.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetPORTSEL_A_HNP_TRACK() uint32 {
	return (volatile.LoadUint32(&o.PORTSEL.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetPORTSEL_PU_REMOVED(value uint32) {
	volatile.StoreUint32(&o.PORTSEL.Reg, volatile.LoadUint32(&o.PORTSEL.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetPORTSEL_PU_REMOVED() uint32 {
	return (volatile.LoadUint32(&o.PORTSEL.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetPORTSEL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PORTSEL.Reg, volatile.LoadUint32(&o.PORTSEL.Reg)&^(0xf800)|value<<11)
}
func (o *USB_Type) GetPORTSEL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PORTSEL.Reg) & 0xf800) >> 11
}
func (o *USB_Type) SetPORTSEL_TMR_CNT(value uint32) {
	volatile.StoreUint32(&o.PORTSEL.Reg, volatile.LoadUint32(&o.PORTSEL.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_Type) GetPORTSEL_TMR_CNT() uint32 {
	return (volatile.LoadUint32(&o.PORTSEL.Reg) & 0xffff0000) >> 16
}
func (o *USB_Type) SetPORTSEL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PORTSEL.Reg, volatile.LoadUint32(&o.PORTSEL.Reg)&^(0xfffffffc)|value<<2)
}
func (o *USB_Type) GetPORTSEL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PORTSEL.Reg) & 0xfffffffc) >> 2
}

// USB.TMR: OTG Timer
func (o *USB_Type) SetTMR_TIMEOUT_CNT(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0xffff)|value)
}
func (o *USB_Type) GetTMR_TIMEOUT_CNT() uint32 {
	return volatile.LoadUint32(&o.TMR.Reg) & 0xffff
}
func (o *USB_Type) SetTMR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, volatile.LoadUint32(&o.TMR.Reg)&^(0xffff0000)|value<<16)
}
func (o *USB_Type) GetTMR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TMR.Reg) & 0xffff0000) >> 16
}

// USB.DEVINTST: USB Device Interrupt Status
func (o *USB_Type) SetDEVINTST_FRAME(value uint32) {
	volatile.StoreUint32(&o.DEVINTST.Reg, volatile.LoadUint32(&o.DEVINTST.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDEVINTST_FRAME() uint32 {
	return volatile.LoadUint32(&o.DEVINTST.Reg) & 0x1
}
func (o *USB_Type) SetDEVINTST_EP_FAST(value uint32) {
	volatile.StoreUint32(&o.DEVINTST.Reg, volatile.LoadUint32(&o.DEVINTST.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDEVINTST_EP_FAST() uint32 {
	return (volatile.LoadUint32(&o.DEVINTST.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDEVINTST_EP_SLOW(value uint32) {
	volatile.StoreUint32(&o.DEVINTST.Reg, volatile.LoadUint32(&o.DEVINTST.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetDEVINTST_EP_SLOW() uint32 {
	return (volatile.LoadUint32(&o.DEVINTST.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetDEVINTST_DEV_STAT(value uint32) {
	volatile.StoreUint32(&o.DEVINTST.Reg, volatile.LoadUint32(&o.DEVINTST.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetDEVINTST_DEV_STAT() uint32 {
	return (volatile.LoadUint32(&o.DEVINTST.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetDEVINTST_CCEMPTY(value uint32) {
	volatile.StoreUint32(&o.DEVINTST.Reg, volatile.LoadUint32(&o.DEVINTST.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetDEVINTST_CCEMPTY() uint32 {
	return (volatile.LoadUint32(&o.DEVINTST.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetDEVINTST_CDFULL(value uint32) {
	volatile.StoreUint32(&o.DEVINTST.Reg, volatile.LoadUint32(&o.DEVINTST.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetDEVINTST_CDFULL() uint32 {
	return (volatile.LoadUint32(&o.DEVINTST.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetDEVINTST_RxENDPKT(value uint32) {
	volatile.StoreUint32(&o.DEVINTST.Reg, volatile.LoadUint32(&o.DEVINTST.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetDEVINTST_RxENDPKT() uint32 {
	return (volatile.LoadUint32(&o.DEVINTST.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetDEVINTST_TxENDPKT(value uint32) {
	volatile.StoreUint32(&o.DEVINTST.Reg, volatile.LoadUint32(&o.DEVINTST.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetDEVINTST_TxENDPKT() uint32 {
	return (volatile.LoadUint32(&o.DEVINTST.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetDEVINTST_EP_RLZED(value uint32) {
	volatile.StoreUint32(&o.DEVINTST.Reg, volatile.LoadUint32(&o.DEVINTST.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetDEVINTST_EP_RLZED() uint32 {
	return (volatile.LoadUint32(&o.DEVINTST.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetDEVINTST_ERR_INT(value uint32) {
	volatile.StoreUint32(&o.DEVINTST.Reg, volatile.LoadUint32(&o.DEVINTST.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetDEVINTST_ERR_INT() uint32 {
	return (volatile.LoadUint32(&o.DEVINTST.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetDEVINTST_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DEVINTST.Reg, volatile.LoadUint32(&o.DEVINTST.Reg)&^(0xfffffc00)|value<<10)
}
func (o *USB_Type) GetDEVINTST_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DEVINTST.Reg) & 0xfffffc00) >> 10
}

// USB.DEVINTEN: USB Device Interrupt Enable
func (o *USB_Type) SetDEVINTEN_FRAMEEN(value uint32) {
	volatile.StoreUint32(&o.DEVINTEN.Reg, volatile.LoadUint32(&o.DEVINTEN.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDEVINTEN_FRAMEEN() uint32 {
	return volatile.LoadUint32(&o.DEVINTEN.Reg) & 0x1
}
func (o *USB_Type) SetDEVINTEN_EP_FASTEN(value uint32) {
	volatile.StoreUint32(&o.DEVINTEN.Reg, volatile.LoadUint32(&o.DEVINTEN.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDEVINTEN_EP_FASTEN() uint32 {
	return (volatile.LoadUint32(&o.DEVINTEN.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDEVINTEN_EP_SLOWEN(value uint32) {
	volatile.StoreUint32(&o.DEVINTEN.Reg, volatile.LoadUint32(&o.DEVINTEN.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetDEVINTEN_EP_SLOWEN() uint32 {
	return (volatile.LoadUint32(&o.DEVINTEN.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetDEVINTEN_DEV_STATEN(value uint32) {
	volatile.StoreUint32(&o.DEVINTEN.Reg, volatile.LoadUint32(&o.DEVINTEN.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetDEVINTEN_DEV_STATEN() uint32 {
	return (volatile.LoadUint32(&o.DEVINTEN.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetDEVINTEN_CCEMPTYEN(value uint32) {
	volatile.StoreUint32(&o.DEVINTEN.Reg, volatile.LoadUint32(&o.DEVINTEN.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetDEVINTEN_CCEMPTYEN() uint32 {
	return (volatile.LoadUint32(&o.DEVINTEN.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetDEVINTEN_CDFULLEN(value uint32) {
	volatile.StoreUint32(&o.DEVINTEN.Reg, volatile.LoadUint32(&o.DEVINTEN.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetDEVINTEN_CDFULLEN() uint32 {
	return (volatile.LoadUint32(&o.DEVINTEN.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetDEVINTEN_RxENDPKTEN(value uint32) {
	volatile.StoreUint32(&o.DEVINTEN.Reg, volatile.LoadUint32(&o.DEVINTEN.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetDEVINTEN_RxENDPKTEN() uint32 {
	return (volatile.LoadUint32(&o.DEVINTEN.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetDEVINTEN_TxENDPKTEN(value uint32) {
	volatile.StoreUint32(&o.DEVINTEN.Reg, volatile.LoadUint32(&o.DEVINTEN.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetDEVINTEN_TxENDPKTEN() uint32 {
	return (volatile.LoadUint32(&o.DEVINTEN.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetDEVINTEN_EP_RLZEDEN(value uint32) {
	volatile.StoreUint32(&o.DEVINTEN.Reg, volatile.LoadUint32(&o.DEVINTEN.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetDEVINTEN_EP_RLZEDEN() uint32 {
	return (volatile.LoadUint32(&o.DEVINTEN.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetDEVINTEN_ERR_INTEN(value uint32) {
	volatile.StoreUint32(&o.DEVINTEN.Reg, volatile.LoadUint32(&o.DEVINTEN.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetDEVINTEN_ERR_INTEN() uint32 {
	return (volatile.LoadUint32(&o.DEVINTEN.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetDEVINTEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DEVINTEN.Reg, volatile.LoadUint32(&o.DEVINTEN.Reg)&^(0xfffffc00)|value<<10)
}
func (o *USB_Type) GetDEVINTEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DEVINTEN.Reg) & 0xfffffc00) >> 10
}

// USB.DEVINTCLR: USB Device Interrupt Clear
func (o *USB_Type) SetDEVINTCLR_FRAMECLR(value uint32) {
	volatile.StoreUint32(&o.DEVINTCLR.Reg, volatile.LoadUint32(&o.DEVINTCLR.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDEVINTCLR_FRAMECLR() uint32 {
	return volatile.LoadUint32(&o.DEVINTCLR.Reg) & 0x1
}
func (o *USB_Type) SetDEVINTCLR_EP_FASTCLR(value uint32) {
	volatile.StoreUint32(&o.DEVINTCLR.Reg, volatile.LoadUint32(&o.DEVINTCLR.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDEVINTCLR_EP_FASTCLR() uint32 {
	return (volatile.LoadUint32(&o.DEVINTCLR.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDEVINTCLR_EP_SLOWCLR(value uint32) {
	volatile.StoreUint32(&o.DEVINTCLR.Reg, volatile.LoadUint32(&o.DEVINTCLR.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetDEVINTCLR_EP_SLOWCLR() uint32 {
	return (volatile.LoadUint32(&o.DEVINTCLR.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetDEVINTCLR_DEV_STATCLR(value uint32) {
	volatile.StoreUint32(&o.DEVINTCLR.Reg, volatile.LoadUint32(&o.DEVINTCLR.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetDEVINTCLR_DEV_STATCLR() uint32 {
	return (volatile.LoadUint32(&o.DEVINTCLR.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetDEVINTCLR_CCEMPTYCLR(value uint32) {
	volatile.StoreUint32(&o.DEVINTCLR.Reg, volatile.LoadUint32(&o.DEVINTCLR.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetDEVINTCLR_CCEMPTYCLR() uint32 {
	return (volatile.LoadUint32(&o.DEVINTCLR.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetDEVINTCLR_CDFULLCLR(value uint32) {
	volatile.StoreUint32(&o.DEVINTCLR.Reg, volatile.LoadUint32(&o.DEVINTCLR.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetDEVINTCLR_CDFULLCLR() uint32 {
	return (volatile.LoadUint32(&o.DEVINTCLR.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetDEVINTCLR_RxENDPKTCLR(value uint32) {
	volatile.StoreUint32(&o.DEVINTCLR.Reg, volatile.LoadUint32(&o.DEVINTCLR.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetDEVINTCLR_RxENDPKTCLR() uint32 {
	return (volatile.LoadUint32(&o.DEVINTCLR.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetDEVINTCLR_TxENDPKTCLR(value uint32) {
	volatile.StoreUint32(&o.DEVINTCLR.Reg, volatile.LoadUint32(&o.DEVINTCLR.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetDEVINTCLR_TxENDPKTCLR() uint32 {
	return (volatile.LoadUint32(&o.DEVINTCLR.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetDEVINTCLR_EP_RLZEDCLR(value uint32) {
	volatile.StoreUint32(&o.DEVINTCLR.Reg, volatile.LoadUint32(&o.DEVINTCLR.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetDEVINTCLR_EP_RLZEDCLR() uint32 {
	return (volatile.LoadUint32(&o.DEVINTCLR.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetDEVINTCLR_ERR_INTCLR(value uint32) {
	volatile.StoreUint32(&o.DEVINTCLR.Reg, volatile.LoadUint32(&o.DEVINTCLR.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetDEVINTCLR_ERR_INTCLR() uint32 {
	return (volatile.LoadUint32(&o.DEVINTCLR.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetDEVINTCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DEVINTCLR.Reg, volatile.LoadUint32(&o.DEVINTCLR.Reg)&^(0xfffffc00)|value<<10)
}
func (o *USB_Type) GetDEVINTCLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DEVINTCLR.Reg) & 0xfffffc00) >> 10
}

// USB.DEVINTSET: USB Device Interrupt Set
func (o *USB_Type) SetDEVINTSET_FRAMESET(value uint32) {
	volatile.StoreUint32(&o.DEVINTSET.Reg, volatile.LoadUint32(&o.DEVINTSET.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDEVINTSET_FRAMESET() uint32 {
	return volatile.LoadUint32(&o.DEVINTSET.Reg) & 0x1
}
func (o *USB_Type) SetDEVINTSET_EP_FASTSET(value uint32) {
	volatile.StoreUint32(&o.DEVINTSET.Reg, volatile.LoadUint32(&o.DEVINTSET.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDEVINTSET_EP_FASTSET() uint32 {
	return (volatile.LoadUint32(&o.DEVINTSET.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDEVINTSET_EP_SLOWSET(value uint32) {
	volatile.StoreUint32(&o.DEVINTSET.Reg, volatile.LoadUint32(&o.DEVINTSET.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetDEVINTSET_EP_SLOWSET() uint32 {
	return (volatile.LoadUint32(&o.DEVINTSET.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetDEVINTSET_DEV_STATSET(value uint32) {
	volatile.StoreUint32(&o.DEVINTSET.Reg, volatile.LoadUint32(&o.DEVINTSET.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetDEVINTSET_DEV_STATSET() uint32 {
	return (volatile.LoadUint32(&o.DEVINTSET.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetDEVINTSET_CCEMPTYSET(value uint32) {
	volatile.StoreUint32(&o.DEVINTSET.Reg, volatile.LoadUint32(&o.DEVINTSET.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetDEVINTSET_CCEMPTYSET() uint32 {
	return (volatile.LoadUint32(&o.DEVINTSET.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetDEVINTSET_CDFULLSET(value uint32) {
	volatile.StoreUint32(&o.DEVINTSET.Reg, volatile.LoadUint32(&o.DEVINTSET.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetDEVINTSET_CDFULLSET() uint32 {
	return (volatile.LoadUint32(&o.DEVINTSET.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetDEVINTSET_RxENDPKTSET(value uint32) {
	volatile.StoreUint32(&o.DEVINTSET.Reg, volatile.LoadUint32(&o.DEVINTSET.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetDEVINTSET_RxENDPKTSET() uint32 {
	return (volatile.LoadUint32(&o.DEVINTSET.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetDEVINTSET_TxENDPKTSET(value uint32) {
	volatile.StoreUint32(&o.DEVINTSET.Reg, volatile.LoadUint32(&o.DEVINTSET.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetDEVINTSET_TxENDPKTSET() uint32 {
	return (volatile.LoadUint32(&o.DEVINTSET.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetDEVINTSET_EP_RLZEDSET(value uint32) {
	volatile.StoreUint32(&o.DEVINTSET.Reg, volatile.LoadUint32(&o.DEVINTSET.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetDEVINTSET_EP_RLZEDSET() uint32 {
	return (volatile.LoadUint32(&o.DEVINTSET.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetDEVINTSET_ERR_INTSET(value uint32) {
	volatile.StoreUint32(&o.DEVINTSET.Reg, volatile.LoadUint32(&o.DEVINTSET.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetDEVINTSET_ERR_INTSET() uint32 {
	return (volatile.LoadUint32(&o.DEVINTSET.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetDEVINTSET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DEVINTSET.Reg, volatile.LoadUint32(&o.DEVINTSET.Reg)&^(0xfffffc00)|value<<10)
}
func (o *USB_Type) GetDEVINTSET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DEVINTSET.Reg) & 0xfffffc00) >> 10
}

// USB.CMDCODE: USB Command Code
func (o *USB_Type) SetCMDCODE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CMDCODE.Reg, volatile.LoadUint32(&o.CMDCODE.Reg)&^(0xff)|value)
}
func (o *USB_Type) GetCMDCODE_RESERVED() uint32 {
	return volatile.LoadUint32(&o.CMDCODE.Reg) & 0xff
}
func (o *USB_Type) SetCMDCODE_CMD_PHASE(value uint32) {
	volatile.StoreUint32(&o.CMDCODE.Reg, volatile.LoadUint32(&o.CMDCODE.Reg)&^(0xff00)|value<<8)
}
func (o *USB_Type) GetCMDCODE_CMD_PHASE() uint32 {
	return (volatile.LoadUint32(&o.CMDCODE.Reg) & 0xff00) >> 8
}
func (o *USB_Type) SetCMDCODE_CMD_CODE_WDATA(value uint32) {
	volatile.StoreUint32(&o.CMDCODE.Reg, volatile.LoadUint32(&o.CMDCODE.Reg)&^(0xff0000)|value<<16)
}
func (o *USB_Type) GetCMDCODE_CMD_CODE_WDATA() uint32 {
	return (volatile.LoadUint32(&o.CMDCODE.Reg) & 0xff0000) >> 16
}
func (o *USB_Type) SetCMDCODE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CMDCODE.Reg, volatile.LoadUint32(&o.CMDCODE.Reg)&^(0xff000000)|value<<24)
}
func (o *USB_Type) GetCMDCODE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CMDCODE.Reg) & 0xff000000) >> 24
}

// USB.CMDDATA: USB Command Data
func (o *USB_Type) SetCMDDATA_CMD_RDATA(value uint32) {
	volatile.StoreUint32(&o.CMDDATA.Reg, volatile.LoadUint32(&o.CMDDATA.Reg)&^(0xff)|value)
}
func (o *USB_Type) GetCMDDATA_CMD_RDATA() uint32 {
	return volatile.LoadUint32(&o.CMDDATA.Reg) & 0xff
}
func (o *USB_Type) SetCMDDATA_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CMDDATA.Reg, volatile.LoadUint32(&o.CMDDATA.Reg)&^(0xffffff00)|value<<8)
}
func (o *USB_Type) GetCMDDATA_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CMDDATA.Reg) & 0xffffff00) >> 8
}

// USB.RXDATA: USB Receive Data
func (o *USB_Type) SetRXDATA(value uint32) {
	volatile.StoreUint32(&o.RXDATA.Reg, value)
}
func (o *USB_Type) GetRXDATA() uint32 {
	return volatile.LoadUint32(&o.RXDATA.Reg)
}

// USB.TXDATA: USB Transmit Data
func (o *USB_Type) SetTXDATA(value uint32) {
	volatile.StoreUint32(&o.TXDATA.Reg, value)
}
func (o *USB_Type) GetTXDATA() uint32 {
	return volatile.LoadUint32(&o.TXDATA.Reg)
}

// USB.TXPLEN: USB Transmit Packet Length
func (o *USB_Type) SetTXPLEN_PKT_LNGTH(value uint32) {
	volatile.StoreUint32(&o.TXPLEN.Reg, volatile.LoadUint32(&o.TXPLEN.Reg)&^(0x3ff)|value)
}
func (o *USB_Type) GetTXPLEN_PKT_LNGTH() uint32 {
	return volatile.LoadUint32(&o.TXPLEN.Reg) & 0x3ff
}
func (o *USB_Type) SetTXPLEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TXPLEN.Reg, volatile.LoadUint32(&o.TXPLEN.Reg)&^(0xfffffc00)|value<<10)
}
func (o *USB_Type) GetTXPLEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TXPLEN.Reg) & 0xfffffc00) >> 10
}

// USB.CTRL: USB Control
func (o *USB_Type) SetCTRL_RD_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetCTRL_RD_EN() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *USB_Type) SetCTRL_WR_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetCTRL_WR_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetCTRL_LOG_ENDPOINT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x3c)|value<<2)
}
func (o *USB_Type) GetCTRL_LOG_ENDPOINT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x3c) >> 2
}
func (o *USB_Type) SetCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xffffffc0)|value<<6)
}
func (o *USB_Type) GetCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xffffffc0) >> 6
}

// USB.DEVINTPRI: USB Device Interrupt Priority
func (o *USB_Type) SetDEVINTPRI_FRAME(value uint32) {
	volatile.StoreUint32(&o.DEVINTPRI.Reg, volatile.LoadUint32(&o.DEVINTPRI.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDEVINTPRI_FRAME() uint32 {
	return volatile.LoadUint32(&o.DEVINTPRI.Reg) & 0x1
}
func (o *USB_Type) SetDEVINTPRI_EP_FAST(value uint32) {
	volatile.StoreUint32(&o.DEVINTPRI.Reg, volatile.LoadUint32(&o.DEVINTPRI.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDEVINTPRI_EP_FAST() uint32 {
	return (volatile.LoadUint32(&o.DEVINTPRI.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDEVINTPRI_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DEVINTPRI.Reg, volatile.LoadUint32(&o.DEVINTPRI.Reg)&^(0xfffffffc)|value<<2)
}
func (o *USB_Type) GetDEVINTPRI_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DEVINTPRI.Reg) & 0xfffffffc) >> 2
}

// USB.EPINTST: USB Endpoint Interrupt Status
func (o *USB_Type) SetEPINTST_EPST0(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetEPINTST_EPST0() uint32 {
	return volatile.LoadUint32(&o.EPINTST.Reg) & 0x1
}
func (o *USB_Type) SetEPINTST_EPST1(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetEPINTST_EPST1() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetEPINTST_EPST2(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetEPINTST_EPST2() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetEPINTST_EPST3(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetEPINTST_EPST3() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetEPINTST_EPST4(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetEPINTST_EPST4() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetEPINTST_EPST5(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetEPINTST_EPST5() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetEPINTST_EPST6(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetEPINTST_EPST6() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetEPINTST_EPST7(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetEPINTST_EPST7() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetEPINTST_EPST8(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetEPINTST_EPST8() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetEPINTST_EPST9(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetEPINTST_EPST9() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetEPINTST_EPST10(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetEPINTST_EPST10() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetEPINTST_EPST11(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetEPINTST_EPST11() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetEPINTST_EPST12(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetEPINTST_EPST12() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetEPINTST_EPST13(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetEPINTST_EPST13() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetEPINTST_EPST14(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetEPINTST_EPST14() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetEPINTST_EPST15(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetEPINTST_EPST15() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetEPINTST_EPST16(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetEPINTST_EPST16() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetEPINTST_EPST17(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetEPINTST_EPST17() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetEPINTST_EPST18(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetEPINTST_EPST18() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x40000) >> 18
}
func (o *USB_Type) SetEPINTST_EPST19(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetEPINTST_EPST19() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetEPINTST_EPST20(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetEPINTST_EPST20() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetEPINTST_EPST21(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetEPINTST_EPST21() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetEPINTST_EPST22(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetEPINTST_EPST22() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetEPINTST_EPST23(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetEPINTST_EPST23() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x800000) >> 23
}
func (o *USB_Type) SetEPINTST_EPST24(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetEPINTST_EPST24() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetEPINTST_EPST25(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_Type) GetEPINTST_EPST25() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x2000000) >> 25
}
func (o *USB_Type) SetEPINTST_EPST26(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetEPINTST_EPST26() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetEPINTST_EPST27(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetEPINTST_EPST27() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetEPINTST_EPST28(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetEPINTST_EPST28() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetEPINTST_EPST29(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetEPINTST_EPST29() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetEPINTST_EPST30(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetEPINTST_EPST30() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetEPINTST_EPST31(value uint32) {
	volatile.StoreUint32(&o.EPINTST.Reg, volatile.LoadUint32(&o.EPINTST.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetEPINTST_EPST31() uint32 {
	return (volatile.LoadUint32(&o.EPINTST.Reg) & 0x80000000) >> 31
}

// USB.EPINTEN: USB Endpoint Interrupt Enable
func (o *USB_Type) SetEPINTEN_EPEN0(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetEPINTEN_EPEN0() uint32 {
	return volatile.LoadUint32(&o.EPINTEN.Reg) & 0x1
}
func (o *USB_Type) SetEPINTEN_EPEN1(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetEPINTEN_EPEN1() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetEPINTEN_EPEN2(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetEPINTEN_EPEN2() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetEPINTEN_EPEN3(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetEPINTEN_EPEN3() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetEPINTEN_EPEN4(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetEPINTEN_EPEN4() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetEPINTEN_EPEN5(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetEPINTEN_EPEN5() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetEPINTEN_EPEN6(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetEPINTEN_EPEN6() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetEPINTEN_EPEN7(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetEPINTEN_EPEN7() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetEPINTEN_EPEN8(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetEPINTEN_EPEN8() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetEPINTEN_EPEN9(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetEPINTEN_EPEN9() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetEPINTEN_EPEN10(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetEPINTEN_EPEN10() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetEPINTEN_EPEN11(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetEPINTEN_EPEN11() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetEPINTEN_EPEN12(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetEPINTEN_EPEN12() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetEPINTEN_EPEN13(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetEPINTEN_EPEN13() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetEPINTEN_EPEN14(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetEPINTEN_EPEN14() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetEPINTEN_EPEN15(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetEPINTEN_EPEN15() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetEPINTEN_EPEN16(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetEPINTEN_EPEN16() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetEPINTEN_EPEN17(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetEPINTEN_EPEN17() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetEPINTEN_EPEN18(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetEPINTEN_EPEN18() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x40000) >> 18
}
func (o *USB_Type) SetEPINTEN_EPEN19(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetEPINTEN_EPEN19() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetEPINTEN_EPEN20(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetEPINTEN_EPEN20() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetEPINTEN_EPEN21(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetEPINTEN_EPEN21() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetEPINTEN_EPEN22(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetEPINTEN_EPEN22() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetEPINTEN_EPEN23(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetEPINTEN_EPEN23() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x800000) >> 23
}
func (o *USB_Type) SetEPINTEN_EPEN24(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetEPINTEN_EPEN24() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetEPINTEN_EPEN25(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_Type) GetEPINTEN_EPEN25() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x2000000) >> 25
}
func (o *USB_Type) SetEPINTEN_EPEN26(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetEPINTEN_EPEN26() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetEPINTEN_EPEN27(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetEPINTEN_EPEN27() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetEPINTEN_EPEN28(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetEPINTEN_EPEN28() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetEPINTEN_EPEN29(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetEPINTEN_EPEN29() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetEPINTEN_EPEN30(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetEPINTEN_EPEN30() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetEPINTEN_EPEN31(value uint32) {
	volatile.StoreUint32(&o.EPINTEN.Reg, volatile.LoadUint32(&o.EPINTEN.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetEPINTEN_EPEN31() uint32 {
	return (volatile.LoadUint32(&o.EPINTEN.Reg) & 0x80000000) >> 31
}

// USB.EPINTCLR: USB Endpoint Interrupt Clear
func (o *USB_Type) SetEPINTCLR_EPCLR0(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetEPINTCLR_EPCLR0() uint32 {
	return volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x1
}
func (o *USB_Type) SetEPINTCLR_EPCLR1(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetEPINTCLR_EPCLR1() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetEPINTCLR_EPCLR2(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetEPINTCLR_EPCLR2() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetEPINTCLR_EPCLR3(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetEPINTCLR_EPCLR3() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetEPINTCLR_EPCLR4(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetEPINTCLR_EPCLR4() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetEPINTCLR_EPCLR5(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetEPINTCLR_EPCLR5() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetEPINTCLR_EPCLR6(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetEPINTCLR_EPCLR6() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetEPINTCLR_EPCLR7(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetEPINTCLR_EPCLR7() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetEPINTCLR_EPCLR8(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetEPINTCLR_EPCLR8() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetEPINTCLR_EPCLR9(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetEPINTCLR_EPCLR9() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetEPINTCLR_EPCLR10(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetEPINTCLR_EPCLR10() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetEPINTCLR_EPCLR11(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetEPINTCLR_EPCLR11() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetEPINTCLR_EPCLR12(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetEPINTCLR_EPCLR12() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetEPINTCLR_EPCLR13(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetEPINTCLR_EPCLR13() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetEPINTCLR_EPCLR14(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetEPINTCLR_EPCLR14() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetEPINTCLR_EPCLR15(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetEPINTCLR_EPCLR15() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetEPINTCLR_EPCLR16(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetEPINTCLR_EPCLR16() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetEPINTCLR_EPCLR17(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetEPINTCLR_EPCLR17() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetEPINTCLR_EPCLR18(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetEPINTCLR_EPCLR18() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x40000) >> 18
}
func (o *USB_Type) SetEPINTCLR_EPCLR19(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetEPINTCLR_EPCLR19() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetEPINTCLR_EPCLR20(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetEPINTCLR_EPCLR20() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetEPINTCLR_EPCLR21(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetEPINTCLR_EPCLR21() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetEPINTCLR_EPCLR22(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetEPINTCLR_EPCLR22() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetEPINTCLR_EPCLR23(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetEPINTCLR_EPCLR23() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x800000) >> 23
}
func (o *USB_Type) SetEPINTCLR_EPCLR24(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetEPINTCLR_EPCLR24() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetEPINTCLR_EPCLR25(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_Type) GetEPINTCLR_EPCLR25() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x2000000) >> 25
}
func (o *USB_Type) SetEPINTCLR_EPCLR26(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetEPINTCLR_EPCLR26() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetEPINTCLR_EPCLR27(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetEPINTCLR_EPCLR27() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetEPINTCLR_EPCLR28(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetEPINTCLR_EPCLR28() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetEPINTCLR_EPCLR29(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetEPINTCLR_EPCLR29() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetEPINTCLR_EPCLR30(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetEPINTCLR_EPCLR30() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetEPINTCLR_EPCLR31(value uint32) {
	volatile.StoreUint32(&o.EPINTCLR.Reg, volatile.LoadUint32(&o.EPINTCLR.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetEPINTCLR_EPCLR31() uint32 {
	return (volatile.LoadUint32(&o.EPINTCLR.Reg) & 0x80000000) >> 31
}

// USB.EPINTSET: USB Endpoint Interrupt Set
func (o *USB_Type) SetEPINTSET_EPSET0(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetEPINTSET_EPSET0() uint32 {
	return volatile.LoadUint32(&o.EPINTSET.Reg) & 0x1
}
func (o *USB_Type) SetEPINTSET_EPSET1(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetEPINTSET_EPSET1() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetEPINTSET_EPSET2(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetEPINTSET_EPSET2() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetEPINTSET_EPSET3(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetEPINTSET_EPSET3() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetEPINTSET_EPSET4(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetEPINTSET_EPSET4() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetEPINTSET_EPSET5(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetEPINTSET_EPSET5() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetEPINTSET_EPSET6(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetEPINTSET_EPSET6() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetEPINTSET_EPSET7(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetEPINTSET_EPSET7() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetEPINTSET_EPSET8(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetEPINTSET_EPSET8() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetEPINTSET_EPSET9(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetEPINTSET_EPSET9() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetEPINTSET_EPSET10(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetEPINTSET_EPSET10() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetEPINTSET_EPSET11(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetEPINTSET_EPSET11() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetEPINTSET_EPSET12(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetEPINTSET_EPSET12() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetEPINTSET_EPSET13(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetEPINTSET_EPSET13() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetEPINTSET_EPSET14(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetEPINTSET_EPSET14() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetEPINTSET_EPSET15(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetEPINTSET_EPSET15() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetEPINTSET_EPSET16(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetEPINTSET_EPSET16() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetEPINTSET_EPSET17(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetEPINTSET_EPSET17() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetEPINTSET_EPSET18(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetEPINTSET_EPSET18() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x40000) >> 18
}
func (o *USB_Type) SetEPINTSET_EPSET19(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetEPINTSET_EPSET19() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetEPINTSET_EPSET20(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetEPINTSET_EPSET20() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetEPINTSET_EPSET21(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetEPINTSET_EPSET21() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetEPINTSET_EPSET22(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetEPINTSET_EPSET22() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetEPINTSET_EPSET23(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetEPINTSET_EPSET23() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x800000) >> 23
}
func (o *USB_Type) SetEPINTSET_EPSET24(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetEPINTSET_EPSET24() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetEPINTSET_EPSET25(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_Type) GetEPINTSET_EPSET25() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x2000000) >> 25
}
func (o *USB_Type) SetEPINTSET_EPSET26(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetEPINTSET_EPSET26() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetEPINTSET_EPSET27(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetEPINTSET_EPSET27() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetEPINTSET_EPSET28(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetEPINTSET_EPSET28() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetEPINTSET_EPSET29(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetEPINTSET_EPSET29() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetEPINTSET_EPSET30(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetEPINTSET_EPSET30() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetEPINTSET_EPSET31(value uint32) {
	volatile.StoreUint32(&o.EPINTSET.Reg, volatile.LoadUint32(&o.EPINTSET.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetEPINTSET_EPSET31() uint32 {
	return (volatile.LoadUint32(&o.EPINTSET.Reg) & 0x80000000) >> 31
}

// USB.EPINTPRI: USB Endpoint Priority
func (o *USB_Type) SetEPINTPRI_EPPRI0(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetEPINTPRI_EPPRI0() uint32 {
	return volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x1
}
func (o *USB_Type) SetEPINTPRI_EPPRI1(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetEPINTPRI_EPPRI1() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetEPINTPRI_EPPRI2(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetEPINTPRI_EPPRI2() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetEPINTPRI_EPPRI3(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetEPINTPRI_EPPRI3() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetEPINTPRI_EPPRI4(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetEPINTPRI_EPPRI4() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetEPINTPRI_EPPRI5(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetEPINTPRI_EPPRI5() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetEPINTPRI_EPPRI6(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetEPINTPRI_EPPRI6() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetEPINTPRI_EPPRI7(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetEPINTPRI_EPPRI7() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetEPINTPRI_EPPRI8(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetEPINTPRI_EPPRI8() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetEPINTPRI_EPPRI9(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetEPINTPRI_EPPRI9() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetEPINTPRI_EPPRI10(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetEPINTPRI_EPPRI10() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetEPINTPRI_EPPRI11(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetEPINTPRI_EPPRI11() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetEPINTPRI_EPPRI12(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetEPINTPRI_EPPRI12() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetEPINTPRI_EPPRI13(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetEPINTPRI_EPPRI13() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetEPINTPRI_EPPRI14(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetEPINTPRI_EPPRI14() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetEPINTPRI_EPPRI15(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetEPINTPRI_EPPRI15() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetEPINTPRI_EPPRI16(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetEPINTPRI_EPPRI16() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetEPINTPRI_EPPRI17(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetEPINTPRI_EPPRI17() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetEPINTPRI_EPPRI18(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetEPINTPRI_EPPRI18() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x40000) >> 18
}
func (o *USB_Type) SetEPINTPRI_EPPRI19(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetEPINTPRI_EPPRI19() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetEPINTPRI_EPPRI20(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetEPINTPRI_EPPRI20() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetEPINTPRI_EPPRI21(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetEPINTPRI_EPPRI21() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetEPINTPRI_EPPRI22(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetEPINTPRI_EPPRI22() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetEPINTPRI_EPPRI23(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetEPINTPRI_EPPRI23() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x800000) >> 23
}
func (o *USB_Type) SetEPINTPRI_EPPRI24(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetEPINTPRI_EPPRI24() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetEPINTPRI_EPPRI25(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_Type) GetEPINTPRI_EPPRI25() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x2000000) >> 25
}
func (o *USB_Type) SetEPINTPRI_EPPRI26(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetEPINTPRI_EPPRI26() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetEPINTPRI_EPPRI27(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetEPINTPRI_EPPRI27() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetEPINTPRI_EPPRI28(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetEPINTPRI_EPPRI28() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetEPINTPRI_EPPRI29(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetEPINTPRI_EPPRI29() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetEPINTPRI_EPPRI30(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetEPINTPRI_EPPRI30() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetEPINTPRI_EPPRI31(value uint32) {
	volatile.StoreUint32(&o.EPINTPRI.Reg, volatile.LoadUint32(&o.EPINTPRI.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetEPINTPRI_EPPRI31() uint32 {
	return (volatile.LoadUint32(&o.EPINTPRI.Reg) & 0x80000000) >> 31
}

// USB.REEP: USB Realize Endpoint
func (o *USB_Type) SetREEP_EPR0(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetREEP_EPR0() uint32 {
	return volatile.LoadUint32(&o.REEP.Reg) & 0x1
}
func (o *USB_Type) SetREEP_EPR1(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetREEP_EPR1() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetREEP_EPR2(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetREEP_EPR2() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetREEP_EPR3(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetREEP_EPR3() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetREEP_EPR4(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetREEP_EPR4() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetREEP_EPR5(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetREEP_EPR5() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetREEP_EPR6(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetREEP_EPR6() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetREEP_EPR7(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetREEP_EPR7() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetREEP_EPR8(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetREEP_EPR8() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetREEP_EPR9(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetREEP_EPR9() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetREEP_EPR10(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetREEP_EPR10() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetREEP_EPR11(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetREEP_EPR11() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetREEP_EPR12(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetREEP_EPR12() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetREEP_EPR13(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetREEP_EPR13() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetREEP_EPR14(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetREEP_EPR14() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetREEP_EPR15(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetREEP_EPR15() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetREEP_EPR16(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetREEP_EPR16() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetREEP_EPR17(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetREEP_EPR17() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetREEP_EPR18(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetREEP_EPR18() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x40000) >> 18
}
func (o *USB_Type) SetREEP_EPR19(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetREEP_EPR19() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetREEP_EPR20(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetREEP_EPR20() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetREEP_EPR21(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetREEP_EPR21() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetREEP_EPR22(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetREEP_EPR22() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetREEP_EPR23(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetREEP_EPR23() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x800000) >> 23
}
func (o *USB_Type) SetREEP_EPR24(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetREEP_EPR24() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetREEP_EPR25(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_Type) GetREEP_EPR25() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x2000000) >> 25
}
func (o *USB_Type) SetREEP_EPR26(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetREEP_EPR26() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetREEP_EPR27(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetREEP_EPR27() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetREEP_EPR28(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetREEP_EPR28() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetREEP_EPR29(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetREEP_EPR29() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetREEP_EPR30(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetREEP_EPR30() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetREEP_EPR31(value uint32) {
	volatile.StoreUint32(&o.REEP.Reg, volatile.LoadUint32(&o.REEP.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetREEP_EPR31() uint32 {
	return (volatile.LoadUint32(&o.REEP.Reg) & 0x80000000) >> 31
}

// USB.EPIN: USB Endpoint Index
func (o *USB_Type) SetEPIN_PHY_EP(value uint32) {
	volatile.StoreUint32(&o.EPIN.Reg, volatile.LoadUint32(&o.EPIN.Reg)&^(0x1f)|value)
}
func (o *USB_Type) GetEPIN_PHY_EP() uint32 {
	return volatile.LoadUint32(&o.EPIN.Reg) & 0x1f
}
func (o *USB_Type) SetEPIN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EPIN.Reg, volatile.LoadUint32(&o.EPIN.Reg)&^(0xffffffe0)|value<<5)
}
func (o *USB_Type) GetEPIN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EPIN.Reg) & 0xffffffe0) >> 5
}

// USB.MAXPSIZE: USB MaxPacketSize
func (o *USB_Type) SetMAXPSIZE_MPS(value uint32) {
	volatile.StoreUint32(&o.MAXPSIZE.Reg, volatile.LoadUint32(&o.MAXPSIZE.Reg)&^(0x3ff)|value)
}
func (o *USB_Type) GetMAXPSIZE_MPS() uint32 {
	return volatile.LoadUint32(&o.MAXPSIZE.Reg) & 0x3ff
}
func (o *USB_Type) SetMAXPSIZE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAXPSIZE.Reg, volatile.LoadUint32(&o.MAXPSIZE.Reg)&^(0xfffffc00)|value<<10)
}
func (o *USB_Type) GetMAXPSIZE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAXPSIZE.Reg) & 0xfffffc00) >> 10
}

// USB.DMARST: USB DMA Request Status
func (o *USB_Type) SetDMARST_EPRST0(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDMARST_EPRST0() uint32 {
	return volatile.LoadUint32(&o.DMARST.Reg) & 0x1
}
func (o *USB_Type) SetDMARST_EPRST1(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDMARST_EPRST1() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDMARST_EPRST2(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetDMARST_EPRST2() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetDMARST_EPRST3(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetDMARST_EPRST3() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetDMARST_EPRST4(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetDMARST_EPRST4() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetDMARST_EPRST5(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetDMARST_EPRST5() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetDMARST_EPRST6(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetDMARST_EPRST6() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetDMARST_EPRST7(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetDMARST_EPRST7() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetDMARST_EPRST8(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetDMARST_EPRST8() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetDMARST_EPRST9(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetDMARST_EPRST9() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetDMARST_EPRST10(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetDMARST_EPRST10() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetDMARST_EPRST11(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetDMARST_EPRST11() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetDMARST_EPRST12(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetDMARST_EPRST12() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetDMARST_EPRST13(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetDMARST_EPRST13() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetDMARST_EPRST14(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetDMARST_EPRST14() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetDMARST_EPRST15(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetDMARST_EPRST15() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetDMARST_EPRST16(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetDMARST_EPRST16() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetDMARST_EPRST17(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetDMARST_EPRST17() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetDMARST_EPRST18(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetDMARST_EPRST18() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x40000) >> 18
}
func (o *USB_Type) SetDMARST_EPRST19(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetDMARST_EPRST19() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetDMARST_EPRST20(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetDMARST_EPRST20() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetDMARST_EPRST21(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetDMARST_EPRST21() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetDMARST_EPRST22(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetDMARST_EPRST22() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetDMARST_EPRST23(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetDMARST_EPRST23() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x800000) >> 23
}
func (o *USB_Type) SetDMARST_EPRST24(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetDMARST_EPRST24() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetDMARST_EPRST25(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_Type) GetDMARST_EPRST25() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x2000000) >> 25
}
func (o *USB_Type) SetDMARST_EPRST26(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetDMARST_EPRST26() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetDMARST_EPRST27(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetDMARST_EPRST27() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetDMARST_EPRST28(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetDMARST_EPRST28() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetDMARST_EPRST29(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetDMARST_EPRST29() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetDMARST_EPRST30(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetDMARST_EPRST30() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetDMARST_EPRST31(value uint32) {
	volatile.StoreUint32(&o.DMARST.Reg, volatile.LoadUint32(&o.DMARST.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetDMARST_EPRST31() uint32 {
	return (volatile.LoadUint32(&o.DMARST.Reg) & 0x80000000) >> 31
}

// USB.DMARCLR: USB DMA Request Clear
func (o *USB_Type) SetDMARCLR_EPRCLR0(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDMARCLR_EPRCLR0() uint32 {
	return volatile.LoadUint32(&o.DMARCLR.Reg) & 0x1
}
func (o *USB_Type) SetDMARCLR_EPRCLR1(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDMARCLR_EPRCLR1() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDMARCLR_EPRCLR2(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetDMARCLR_EPRCLR2() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetDMARCLR_EPRCLR3(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetDMARCLR_EPRCLR3() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetDMARCLR_EPRCLR4(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetDMARCLR_EPRCLR4() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetDMARCLR_EPRCLR5(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetDMARCLR_EPRCLR5() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetDMARCLR_EPRCLR6(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetDMARCLR_EPRCLR6() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetDMARCLR_EPRCLR7(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetDMARCLR_EPRCLR7() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetDMARCLR_EPRCLR8(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetDMARCLR_EPRCLR8() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetDMARCLR_EPRCLR9(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetDMARCLR_EPRCLR9() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetDMARCLR_EPRCLR10(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetDMARCLR_EPRCLR10() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetDMARCLR_EPRCLR11(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetDMARCLR_EPRCLR11() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetDMARCLR_EPRCLR12(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetDMARCLR_EPRCLR12() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetDMARCLR_EPRCLR13(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetDMARCLR_EPRCLR13() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetDMARCLR_EPRCLR14(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetDMARCLR_EPRCLR14() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetDMARCLR_EPRCLR15(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetDMARCLR_EPRCLR15() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetDMARCLR_EPRCLR16(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetDMARCLR_EPRCLR16() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetDMARCLR_EPRCLR17(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetDMARCLR_EPRCLR17() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetDMARCLR_EPRCLR18(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetDMARCLR_EPRCLR18() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x40000) >> 18
}
func (o *USB_Type) SetDMARCLR_EPRCLR19(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetDMARCLR_EPRCLR19() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetDMARCLR_EPRCLR20(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetDMARCLR_EPRCLR20() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetDMARCLR_EPRCLR21(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetDMARCLR_EPRCLR21() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetDMARCLR_EPRCLR22(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetDMARCLR_EPRCLR22() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetDMARCLR_EPRCLR23(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetDMARCLR_EPRCLR23() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x800000) >> 23
}
func (o *USB_Type) SetDMARCLR_EPRCLR24(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetDMARCLR_EPRCLR24() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetDMARCLR_EPRCLR25(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_Type) GetDMARCLR_EPRCLR25() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x2000000) >> 25
}
func (o *USB_Type) SetDMARCLR_EPRCLR26(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetDMARCLR_EPRCLR26() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetDMARCLR_EPRCLR27(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetDMARCLR_EPRCLR27() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetDMARCLR_EPRCLR28(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetDMARCLR_EPRCLR28() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetDMARCLR_EPRCLR29(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetDMARCLR_EPRCLR29() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetDMARCLR_EPRCLR30(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetDMARCLR_EPRCLR30() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetDMARCLR_EPRCLR31(value uint32) {
	volatile.StoreUint32(&o.DMARCLR.Reg, volatile.LoadUint32(&o.DMARCLR.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetDMARCLR_EPRCLR31() uint32 {
	return (volatile.LoadUint32(&o.DMARCLR.Reg) & 0x80000000) >> 31
}

// USB.DMARSET: USB DMA Request Set
func (o *USB_Type) SetDMARSET_EPRSET0(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDMARSET_EPRSET0() uint32 {
	return volatile.LoadUint32(&o.DMARSET.Reg) & 0x1
}
func (o *USB_Type) SetDMARSET_EPRSET1(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDMARSET_EPRSET1() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDMARSET_EPRSET2(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetDMARSET_EPRSET2() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetDMARSET_EPRSET3(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetDMARSET_EPRSET3() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetDMARSET_EPRSET4(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetDMARSET_EPRSET4() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetDMARSET_EPRSET5(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetDMARSET_EPRSET5() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetDMARSET_EPRSET6(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetDMARSET_EPRSET6() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetDMARSET_EPRSET7(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetDMARSET_EPRSET7() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetDMARSET_EPRSET8(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetDMARSET_EPRSET8() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetDMARSET_EPRSET9(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetDMARSET_EPRSET9() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetDMARSET_EPRSET10(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetDMARSET_EPRSET10() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetDMARSET_EPRSET11(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetDMARSET_EPRSET11() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetDMARSET_EPRSET12(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetDMARSET_EPRSET12() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetDMARSET_EPRSET13(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetDMARSET_EPRSET13() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetDMARSET_EPRSET14(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetDMARSET_EPRSET14() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetDMARSET_EPRSET15(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetDMARSET_EPRSET15() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetDMARSET_EPRSET16(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetDMARSET_EPRSET16() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetDMARSET_EPRSET17(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetDMARSET_EPRSET17() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetDMARSET_EPRSET18(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetDMARSET_EPRSET18() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x40000) >> 18
}
func (o *USB_Type) SetDMARSET_EPRSET19(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetDMARSET_EPRSET19() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetDMARSET_EPRSET20(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetDMARSET_EPRSET20() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetDMARSET_EPRSET21(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetDMARSET_EPRSET21() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetDMARSET_EPRSET22(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetDMARSET_EPRSET22() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetDMARSET_EPRSET23(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetDMARSET_EPRSET23() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x800000) >> 23
}
func (o *USB_Type) SetDMARSET_EPRSET24(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetDMARSET_EPRSET24() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetDMARSET_EPRSET25(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_Type) GetDMARSET_EPRSET25() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x2000000) >> 25
}
func (o *USB_Type) SetDMARSET_EPRSET26(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetDMARSET_EPRSET26() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetDMARSET_EPRSET27(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetDMARSET_EPRSET27() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetDMARSET_EPRSET28(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetDMARSET_EPRSET28() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetDMARSET_EPRSET29(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetDMARSET_EPRSET29() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetDMARSET_EPRSET30(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetDMARSET_EPRSET30() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetDMARSET_EPRSET31(value uint32) {
	volatile.StoreUint32(&o.DMARSET.Reg, volatile.LoadUint32(&o.DMARSET.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetDMARSET_EPRSET31() uint32 {
	return (volatile.LoadUint32(&o.DMARSET.Reg) & 0x80000000) >> 31
}

// USB.UDCAH: USB UDCA Head
func (o *USB_Type) SetUDCAH_RESERVED(value uint32) {
	volatile.StoreUint32(&o.UDCAH.Reg, volatile.LoadUint32(&o.UDCAH.Reg)&^(0x7f)|value)
}
func (o *USB_Type) GetUDCAH_RESERVED() uint32 {
	return volatile.LoadUint32(&o.UDCAH.Reg) & 0x7f
}
func (o *USB_Type) SetUDCAH_UDCA_ADDR(value uint32) {
	volatile.StoreUint32(&o.UDCAH.Reg, volatile.LoadUint32(&o.UDCAH.Reg)&^(0xffffff80)|value<<7)
}
func (o *USB_Type) GetUDCAH_UDCA_ADDR() uint32 {
	return (volatile.LoadUint32(&o.UDCAH.Reg) & 0xffffff80) >> 7
}

// USB.EPDMAST: USB Endpoint DMA Status
func (o *USB_Type) SetEPDMAST_EP_DMA_ST0(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST0() uint32 {
	return volatile.LoadUint32(&o.EPDMAST.Reg) & 0x1
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST1(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST1() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST2(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST2() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST3(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST3() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST4(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST4() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST5(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST5() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST6(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST6() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST7(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST7() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST8(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST8() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST9(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST9() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST10(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST10() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST11(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST11() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST12(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST12() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST13(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST13() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST14(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST14() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST15(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST15() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST16(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST16() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST17(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST17() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST18(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST18() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x40000) >> 18
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST19(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST19() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST20(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST20() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST21(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST21() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST22(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST22() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST23(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST23() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x800000) >> 23
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST24(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST24() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST25(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST25() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x2000000) >> 25
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST26(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST26() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST27(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST27() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST28(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST28() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST29(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST29() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST30(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST30() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetEPDMAST_EP_DMA_ST31(value uint32) {
	volatile.StoreUint32(&o.EPDMAST.Reg, volatile.LoadUint32(&o.EPDMAST.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetEPDMAST_EP_DMA_ST31() uint32 {
	return (volatile.LoadUint32(&o.EPDMAST.Reg) & 0x80000000) >> 31
}

// USB.EPDMAEN: USB Endpoint DMA Enable
func (o *USB_Type) SetEPDMAEN_EP_DMA_EN0(value uint32) {
	volatile.StoreUint32(&o.EPDMAEN.Reg, volatile.LoadUint32(&o.EPDMAEN.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetEPDMAEN_EP_DMA_EN0() uint32 {
	return volatile.LoadUint32(&o.EPDMAEN.Reg) & 0x1
}
func (o *USB_Type) SetEPDMAEN_EP_DMA_EN1(value uint32) {
	volatile.StoreUint32(&o.EPDMAEN.Reg, volatile.LoadUint32(&o.EPDMAEN.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetEPDMAEN_EP_DMA_EN1() uint32 {
	return (volatile.LoadUint32(&o.EPDMAEN.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetEPDMAEN_EP_DMA_EN(value uint32) {
	volatile.StoreUint32(&o.EPDMAEN.Reg, volatile.LoadUint32(&o.EPDMAEN.Reg)&^(0xfffffffc)|value<<2)
}
func (o *USB_Type) GetEPDMAEN_EP_DMA_EN() uint32 {
	return (volatile.LoadUint32(&o.EPDMAEN.Reg) & 0xfffffffc) >> 2
}

// USB.EPDMADIS: USB Endpoint DMA Disable
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS0(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS0() uint32 {
	return volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x1
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS1(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS1() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS2(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS2() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS3(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS3() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS4(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS4() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS5(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS5() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS6(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS6() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS7(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS7() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS8(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS8() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS9(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS9() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS10(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS10() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS11(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS11() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS12(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS12() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS13(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS13() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS14(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS14() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS15(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS15() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS16(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS16() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS17(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS17() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS18(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS18() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x40000) >> 18
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS19(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS19() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS20(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS20() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS21(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS21() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS22(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS22() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS23(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS23() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x800000) >> 23
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS24(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS24() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS25(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS25() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x2000000) >> 25
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS26(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS26() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS27(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS27() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS28(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS28() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS29(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS29() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS30(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS30() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetEPDMADIS_EP_DMA_DIS31(value uint32) {
	volatile.StoreUint32(&o.EPDMADIS.Reg, volatile.LoadUint32(&o.EPDMADIS.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetEPDMADIS_EP_DMA_DIS31() uint32 {
	return (volatile.LoadUint32(&o.EPDMADIS.Reg) & 0x80000000) >> 31
}

// USB.DMAINTST: USB DMA Interrupt Status
func (o *USB_Type) SetDMAINTST_EOT(value uint32) {
	volatile.StoreUint32(&o.DMAINTST.Reg, volatile.LoadUint32(&o.DMAINTST.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDMAINTST_EOT() uint32 {
	return volatile.LoadUint32(&o.DMAINTST.Reg) & 0x1
}
func (o *USB_Type) SetDMAINTST_NDDR(value uint32) {
	volatile.StoreUint32(&o.DMAINTST.Reg, volatile.LoadUint32(&o.DMAINTST.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDMAINTST_NDDR() uint32 {
	return (volatile.LoadUint32(&o.DMAINTST.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDMAINTST_ERR(value uint32) {
	volatile.StoreUint32(&o.DMAINTST.Reg, volatile.LoadUint32(&o.DMAINTST.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetDMAINTST_ERR() uint32 {
	return (volatile.LoadUint32(&o.DMAINTST.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetDMAINTST_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMAINTST.Reg, volatile.LoadUint32(&o.DMAINTST.Reg)&^(0xfffffff8)|value<<3)
}
func (o *USB_Type) GetDMAINTST_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMAINTST.Reg) & 0xfffffff8) >> 3
}

// USB.DMAINTEN: USB DMA Interrupt Enable
func (o *USB_Type) SetDMAINTEN_EOT(value uint32) {
	volatile.StoreUint32(&o.DMAINTEN.Reg, volatile.LoadUint32(&o.DMAINTEN.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetDMAINTEN_EOT() uint32 {
	return volatile.LoadUint32(&o.DMAINTEN.Reg) & 0x1
}
func (o *USB_Type) SetDMAINTEN_NDDR(value uint32) {
	volatile.StoreUint32(&o.DMAINTEN.Reg, volatile.LoadUint32(&o.DMAINTEN.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetDMAINTEN_NDDR() uint32 {
	return (volatile.LoadUint32(&o.DMAINTEN.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetDMAINTEN_ERR(value uint32) {
	volatile.StoreUint32(&o.DMAINTEN.Reg, volatile.LoadUint32(&o.DMAINTEN.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetDMAINTEN_ERR() uint32 {
	return (volatile.LoadUint32(&o.DMAINTEN.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetDMAINTEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMAINTEN.Reg, volatile.LoadUint32(&o.DMAINTEN.Reg)&^(0xfffffff8)|value<<3)
}
func (o *USB_Type) GetDMAINTEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMAINTEN.Reg) & 0xfffffff8) >> 3
}

// USB.EOTINTST: USB End of Transfer Interrupt Status
func (o *USB_Type) SetEOTINTST_EPTXINTST0(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST0() uint32 {
	return volatile.LoadUint32(&o.EOTINTST.Reg) & 0x1
}
func (o *USB_Type) SetEOTINTST_EPTXINTST1(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST1() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetEOTINTST_EPTXINTST2(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST2() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetEOTINTST_EPTXINTST3(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST3() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetEOTINTST_EPTXINTST4(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST4() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetEOTINTST_EPTXINTST5(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST5() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetEOTINTST_EPTXINTST6(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST6() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetEOTINTST_EPTXINTST7(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST7() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetEOTINTST_EPTXINTST8(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST8() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetEOTINTST_EPTXINTST9(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST9() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetEOTINTST_EPTXINTST10(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST10() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetEOTINTST_EPTXINTST11(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST11() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetEOTINTST_EPTXINTST12(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST12() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetEOTINTST_EPTXINTST13(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST13() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetEOTINTST_EPTXINTST14(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST14() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetEOTINTST_EPTXINTST15(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST15() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetEOTINTST_EPTXINTST16(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST16() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetEOTINTST_EPTXINTST17(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST17() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetEOTINTST_EPTXINTST18(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST18() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x40000) >> 18
}
func (o *USB_Type) SetEOTINTST_EPTXINTST19(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST19() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetEOTINTST_EPTXINTST20(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST20() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetEOTINTST_EPTXINTST21(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST21() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetEOTINTST_EPTXINTST22(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST22() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetEOTINTST_EPTXINTST23(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST23() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x800000) >> 23
}
func (o *USB_Type) SetEOTINTST_EPTXINTST24(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST24() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetEOTINTST_EPTXINTST25(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST25() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x2000000) >> 25
}
func (o *USB_Type) SetEOTINTST_EPTXINTST26(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST26() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetEOTINTST_EPTXINTST27(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST27() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetEOTINTST_EPTXINTST28(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST28() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetEOTINTST_EPTXINTST29(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST29() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetEOTINTST_EPTXINTST30(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST30() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetEOTINTST_EPTXINTST31(value uint32) {
	volatile.StoreUint32(&o.EOTINTST.Reg, volatile.LoadUint32(&o.EOTINTST.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetEOTINTST_EPTXINTST31() uint32 {
	return (volatile.LoadUint32(&o.EOTINTST.Reg) & 0x80000000) >> 31
}

// USB.EOTINTCLR: USB End of Transfer Interrupt Clear
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR0(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR0() uint32 {
	return volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x1
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR1(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR1() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR2(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR2() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR3(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR3() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR4(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR4() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR5(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR5() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR6(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR6() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR7(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR7() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR8(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR8() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR9(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR9() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR10(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR10() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR11(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR11() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR12(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR12() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR13(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR13() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR14(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR14() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR15(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR15() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR16(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR16() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR17(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR17() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR18(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR18() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x40000) >> 18
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR19(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR19() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR20(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR20() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR21(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR21() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR22(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR22() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR23(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR23() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x800000) >> 23
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR24(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR24() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR25(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR25() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x2000000) >> 25
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR26(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR26() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR27(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR27() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR28(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR28() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR29(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR29() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR30(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR30() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetEOTINTCLR_EPTXINTCLR31(value uint32) {
	volatile.StoreUint32(&o.EOTINTCLR.Reg, volatile.LoadUint32(&o.EOTINTCLR.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetEOTINTCLR_EPTXINTCLR31() uint32 {
	return (volatile.LoadUint32(&o.EOTINTCLR.Reg) & 0x80000000) >> 31
}

// USB.EOTINTSET: USB End of Transfer Interrupt Set
func (o *USB_Type) SetEOTINTSET_EPTXINTSET0(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET0() uint32 {
	return volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x1
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET1(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET1() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET2(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET2() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET3(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET3() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET4(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET4() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET5(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET5() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET6(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET6() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET7(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET7() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET8(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET8() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET9(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET9() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET10(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET10() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET11(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET11() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET12(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET12() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET13(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET13() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET14(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET14() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET15(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET15() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET16(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET16() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET17(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET17() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET18(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET18() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x40000) >> 18
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET19(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET19() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET20(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET20() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET21(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET21() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET22(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET22() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET23(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET23() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x800000) >> 23
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET24(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET24() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET25(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET25() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x2000000) >> 25
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET26(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET26() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET27(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET27() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET28(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET28() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET29(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET29() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET30(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET30() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetEOTINTSET_EPTXINTSET31(value uint32) {
	volatile.StoreUint32(&o.EOTINTSET.Reg, volatile.LoadUint32(&o.EOTINTSET.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetEOTINTSET_EPTXINTSET31() uint32 {
	return (volatile.LoadUint32(&o.EOTINTSET.Reg) & 0x80000000) >> 31
}

// USB.NDDRINTST: USB New DD Request Interrupt Status
func (o *USB_Type) SetNDDRINTST_EPNDDINTST0(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST0() uint32 {
	return volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x1
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST1(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST1() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST2(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST2() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST3(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST3() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST4(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST4() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST5(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST5() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST6(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST6() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST7(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST7() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST8(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST8() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST9(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST9() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST10(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST10() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST11(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST11() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST12(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST12() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST13(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST13() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST14(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST14() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST15(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST15() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST16(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST16() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST17(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST17() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST18(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST18() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x40000) >> 18
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST19(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST19() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST20(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST20() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST21(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST21() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST22(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST22() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST23(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST23() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x800000) >> 23
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST24(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST24() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST25(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST25() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x2000000) >> 25
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST26(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST26() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST27(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST27() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST28(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST28() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST29(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST29() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST30(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST30() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetNDDRINTST_EPNDDINTST31(value uint32) {
	volatile.StoreUint32(&o.NDDRINTST.Reg, volatile.LoadUint32(&o.NDDRINTST.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetNDDRINTST_EPNDDINTST31() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTST.Reg) & 0x80000000) >> 31
}

// USB.NDDRINTCLR: USB New DD Request Interrupt Clear
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR0(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR0() uint32 {
	return volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x1
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR1(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR1() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR2(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR2() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR3(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR3() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR4(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR4() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR5(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR5() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR6(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR6() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR7(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR7() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR8(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR8() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR9(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR9() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR10(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR10() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR11(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR11() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR12(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR12() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR13(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR13() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR14(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR14() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR15(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR15() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR16(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR16() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR17(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR17() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR18(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR18() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x40000) >> 18
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR19(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR19() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR20(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR20() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR21(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR21() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR22(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR22() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR23(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR23() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x800000) >> 23
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR24(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR24() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR25(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR25() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x2000000) >> 25
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR26(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR26() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR27(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR27() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR28(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR28() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR29(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR29() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR30(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR30() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetNDDRINTCLR_EPNDDINTCLR31(value uint32) {
	volatile.StoreUint32(&o.NDDRINTCLR.Reg, volatile.LoadUint32(&o.NDDRINTCLR.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetNDDRINTCLR_EPNDDINTCLR31() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTCLR.Reg) & 0x80000000) >> 31
}

// USB.NDDRINTSET: USB New DD Request Interrupt Set
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET0(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET0() uint32 {
	return volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x1
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET1(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET1() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET2(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET2() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET3(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET3() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET4(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET4() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET5(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET5() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET6(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET6() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET7(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET7() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET8(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET8() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET9(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET9() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET10(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET10() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET11(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET11() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET12(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET12() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET13(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET13() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET14(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET14() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET15(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET15() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET16(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET16() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET17(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET17() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET18(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET18() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x40000) >> 18
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET19(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET19() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET20(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET20() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET21(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET21() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET22(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET22() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET23(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET23() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x800000) >> 23
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET24(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET24() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET25(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET25() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x2000000) >> 25
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET26(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET26() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET27(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET27() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET28(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET28() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET29(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET29() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET30(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET30() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetNDDRINTSET_EPNDDINTSET31(value uint32) {
	volatile.StoreUint32(&o.NDDRINTSET.Reg, volatile.LoadUint32(&o.NDDRINTSET.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetNDDRINTSET_EPNDDINTSET31() uint32 {
	return (volatile.LoadUint32(&o.NDDRINTSET.Reg) & 0x80000000) >> 31
}

// USB.SYSERRINTST: USB System Error Interrupt Status
func (o *USB_Type) SetSYSERRINTST_EPERRINTST0(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST0() uint32 {
	return volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x1
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST1(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST1() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST2(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST2() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST3(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST3() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST4(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST4() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST5(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST5() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST6(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST6() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST7(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST7() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST8(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST8() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST9(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST9() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST10(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST10() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST11(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST11() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST12(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST12() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST13(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST13() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST14(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST14() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST15(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST15() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST16(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST16() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST17(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST17() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST18(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST18() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x40000) >> 18
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST19(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST19() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST20(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST20() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST21(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST21() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST22(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST22() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST23(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST23() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x800000) >> 23
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST24(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST24() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST25(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST25() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x2000000) >> 25
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST26(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST26() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST27(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST27() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST28(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST28() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST29(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST29() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST30(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST30() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetSYSERRINTST_EPERRINTST31(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTST.Reg, volatile.LoadUint32(&o.SYSERRINTST.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetSYSERRINTST_EPERRINTST31() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTST.Reg) & 0x80000000) >> 31
}

// USB.SYSERRINTCLR: USB System Error Interrupt Clear
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR0(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR0() uint32 {
	return volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x1
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR1(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR1() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR2(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR2() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR3(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR3() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR4(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR4() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR5(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR5() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR6(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR6() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR7(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR7() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR8(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR8() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR9(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR9() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR10(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR10() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR11(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR11() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR12(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR12() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR13(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR13() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR14(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR14() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR15(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR15() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR16(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR16() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR17(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR17() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR18(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR18() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x40000) >> 18
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR19(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR19() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR20(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR20() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR21(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR21() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR22(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR22() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR23(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR23() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x800000) >> 23
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR24(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR24() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR25(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR25() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x2000000) >> 25
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR26(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR26() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR27(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR27() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR28(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR28() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR29(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR29() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR30(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR30() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetSYSERRINTCLR_EPERRINTCLR31(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTCLR.Reg, volatile.LoadUint32(&o.SYSERRINTCLR.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetSYSERRINTCLR_EPERRINTCLR31() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTCLR.Reg) & 0x80000000) >> 31
}

// USB.SYSERRINTSET: USB System Error Interrupt Set
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET0(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET0() uint32 {
	return volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x1
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET1(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET1() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET2(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET2() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET3(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET3() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET4(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET4() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET5(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET5() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET6(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET6() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET7(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET7() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET8(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET8() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET9(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET9() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET10(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET10() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET11(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET11() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET12(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET12() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET13(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET13() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET14(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET14() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET15(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET15() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET16(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET16() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET17(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET17() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET18(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET18() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x40000) >> 18
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET19(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET19() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET20(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET20() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET21(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET21() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET22(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET22() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET23(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET23() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x800000) >> 23
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET24(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET24() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET25(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET25() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x2000000) >> 25
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET26(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET26() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET27(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET27() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET28(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET28() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET29(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET29() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET30(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET30() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetSYSERRINTSET_EPERRINTSET31(value uint32) {
	volatile.StoreUint32(&o.SYSERRINTSET.Reg, volatile.LoadUint32(&o.SYSERRINTSET.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetSYSERRINTSET_EPERRINTSET31() uint32 {
	return (volatile.LoadUint32(&o.SYSERRINTSET.Reg) & 0x80000000) >> 31
}

// USB.I2C_RX: I2C Receive
func (o *USB_Type) SetI2C_RX_RX_DATA(value uint32) {
	volatile.StoreUint32(&o.I2C_RX.Reg, volatile.LoadUint32(&o.I2C_RX.Reg)&^(0xff)|value)
}
func (o *USB_Type) GetI2C_RX_RX_DATA() uint32 {
	return volatile.LoadUint32(&o.I2C_RX.Reg) & 0xff
}
func (o *USB_Type) SetI2C_RX_RESERVED(value uint32) {
	volatile.StoreUint32(&o.I2C_RX.Reg, volatile.LoadUint32(&o.I2C_RX.Reg)&^(0xffffff00)|value<<8)
}
func (o *USB_Type) GetI2C_RX_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.I2C_RX.Reg) & 0xffffff00) >> 8
}

// USB.I2C_STS: I2C Status
func (o *USB_Type) SetI2C_STS_TDI(value uint32) {
	volatile.StoreUint32(&o.I2C_STS.Reg, volatile.LoadUint32(&o.I2C_STS.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetI2C_STS_TDI() uint32 {
	return volatile.LoadUint32(&o.I2C_STS.Reg) & 0x1
}
func (o *USB_Type) SetI2C_STS_AFI(value uint32) {
	volatile.StoreUint32(&o.I2C_STS.Reg, volatile.LoadUint32(&o.I2C_STS.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetI2C_STS_AFI() uint32 {
	return (volatile.LoadUint32(&o.I2C_STS.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetI2C_STS_NAI(value uint32) {
	volatile.StoreUint32(&o.I2C_STS.Reg, volatile.LoadUint32(&o.I2C_STS.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetI2C_STS_NAI() uint32 {
	return (volatile.LoadUint32(&o.I2C_STS.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetI2C_STS_DRMI(value uint32) {
	volatile.StoreUint32(&o.I2C_STS.Reg, volatile.LoadUint32(&o.I2C_STS.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetI2C_STS_DRMI() uint32 {
	return (volatile.LoadUint32(&o.I2C_STS.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetI2C_STS_DRSI(value uint32) {
	volatile.StoreUint32(&o.I2C_STS.Reg, volatile.LoadUint32(&o.I2C_STS.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetI2C_STS_DRSI() uint32 {
	return (volatile.LoadUint32(&o.I2C_STS.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetI2C_STS_Active(value uint32) {
	volatile.StoreUint32(&o.I2C_STS.Reg, volatile.LoadUint32(&o.I2C_STS.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetI2C_STS_Active() uint32 {
	return (volatile.LoadUint32(&o.I2C_STS.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetI2C_STS_SCL(value uint32) {
	volatile.StoreUint32(&o.I2C_STS.Reg, volatile.LoadUint32(&o.I2C_STS.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetI2C_STS_SCL() uint32 {
	return (volatile.LoadUint32(&o.I2C_STS.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetI2C_STS_SDA(value uint32) {
	volatile.StoreUint32(&o.I2C_STS.Reg, volatile.LoadUint32(&o.I2C_STS.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetI2C_STS_SDA() uint32 {
	return (volatile.LoadUint32(&o.I2C_STS.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetI2C_STS_RFF(value uint32) {
	volatile.StoreUint32(&o.I2C_STS.Reg, volatile.LoadUint32(&o.I2C_STS.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetI2C_STS_RFF() uint32 {
	return (volatile.LoadUint32(&o.I2C_STS.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetI2C_STS_RFE(value uint32) {
	volatile.StoreUint32(&o.I2C_STS.Reg, volatile.LoadUint32(&o.I2C_STS.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetI2C_STS_RFE() uint32 {
	return (volatile.LoadUint32(&o.I2C_STS.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetI2C_STS_TFF(value uint32) {
	volatile.StoreUint32(&o.I2C_STS.Reg, volatile.LoadUint32(&o.I2C_STS.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetI2C_STS_TFF() uint32 {
	return (volatile.LoadUint32(&o.I2C_STS.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetI2C_STS_TFE(value uint32) {
	volatile.StoreUint32(&o.I2C_STS.Reg, volatile.LoadUint32(&o.I2C_STS.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetI2C_STS_TFE() uint32 {
	return (volatile.LoadUint32(&o.I2C_STS.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetI2C_STS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.I2C_STS.Reg, volatile.LoadUint32(&o.I2C_STS.Reg)&^(0xfffff000)|value<<12)
}
func (o *USB_Type) GetI2C_STS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.I2C_STS.Reg) & 0xfffff000) >> 12
}

// USB.I2C_CTL: I2C Control
func (o *USB_Type) SetI2C_CTL_TDIE(value uint32) {
	volatile.StoreUint32(&o.I2C_CTL.Reg, volatile.LoadUint32(&o.I2C_CTL.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetI2C_CTL_TDIE() uint32 {
	return volatile.LoadUint32(&o.I2C_CTL.Reg) & 0x1
}
func (o *USB_Type) SetI2C_CTL_AFIE(value uint32) {
	volatile.StoreUint32(&o.I2C_CTL.Reg, volatile.LoadUint32(&o.I2C_CTL.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetI2C_CTL_AFIE() uint32 {
	return (volatile.LoadUint32(&o.I2C_CTL.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetI2C_CTL_NAIE(value uint32) {
	volatile.StoreUint32(&o.I2C_CTL.Reg, volatile.LoadUint32(&o.I2C_CTL.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetI2C_CTL_NAIE() uint32 {
	return (volatile.LoadUint32(&o.I2C_CTL.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetI2C_CTL_DRMIE(value uint32) {
	volatile.StoreUint32(&o.I2C_CTL.Reg, volatile.LoadUint32(&o.I2C_CTL.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetI2C_CTL_DRMIE() uint32 {
	return (volatile.LoadUint32(&o.I2C_CTL.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetI2C_CTL_DRSIE(value uint32) {
	volatile.StoreUint32(&o.I2C_CTL.Reg, volatile.LoadUint32(&o.I2C_CTL.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetI2C_CTL_DRSIE() uint32 {
	return (volatile.LoadUint32(&o.I2C_CTL.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetI2C_CTL_REFIE(value uint32) {
	volatile.StoreUint32(&o.I2C_CTL.Reg, volatile.LoadUint32(&o.I2C_CTL.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetI2C_CTL_REFIE() uint32 {
	return (volatile.LoadUint32(&o.I2C_CTL.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetI2C_CTL_RFDAIE(value uint32) {
	volatile.StoreUint32(&o.I2C_CTL.Reg, volatile.LoadUint32(&o.I2C_CTL.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetI2C_CTL_RFDAIE() uint32 {
	return (volatile.LoadUint32(&o.I2C_CTL.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetI2C_CTL_TFFIE(value uint32) {
	volatile.StoreUint32(&o.I2C_CTL.Reg, volatile.LoadUint32(&o.I2C_CTL.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetI2C_CTL_TFFIE() uint32 {
	return (volatile.LoadUint32(&o.I2C_CTL.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetI2C_CTL_SRST(value uint32) {
	volatile.StoreUint32(&o.I2C_CTL.Reg, volatile.LoadUint32(&o.I2C_CTL.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetI2C_CTL_SRST() uint32 {
	return (volatile.LoadUint32(&o.I2C_CTL.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetI2C_CTL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.I2C_CTL.Reg, volatile.LoadUint32(&o.I2C_CTL.Reg)&^(0xfffffe00)|value<<9)
}
func (o *USB_Type) GetI2C_CTL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.I2C_CTL.Reg) & 0xfffffe00) >> 9
}

// USB.I2C_CLKHI: I2C Clock High
func (o *USB_Type) SetI2C_CLKHI_CDHI(value uint32) {
	volatile.StoreUint32(&o.I2C_CLKHI.Reg, volatile.LoadUint32(&o.I2C_CLKHI.Reg)&^(0xff)|value)
}
func (o *USB_Type) GetI2C_CLKHI_CDHI() uint32 {
	return volatile.LoadUint32(&o.I2C_CLKHI.Reg) & 0xff
}
func (o *USB_Type) SetI2C_CLKHI_RESERVED(value uint32) {
	volatile.StoreUint32(&o.I2C_CLKHI.Reg, volatile.LoadUint32(&o.I2C_CLKHI.Reg)&^(0xffffff00)|value<<8)
}
func (o *USB_Type) GetI2C_CLKHI_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.I2C_CLKHI.Reg) & 0xffffff00) >> 8
}

// USB.I2C_CLKLO: I2C Clock Low
func (o *USB_Type) SetI2C_CLKLO_CDLO(value uint32) {
	volatile.StoreUint32(&o.I2C_CLKLO.Reg, volatile.LoadUint32(&o.I2C_CLKLO.Reg)&^(0xff)|value)
}
func (o *USB_Type) GetI2C_CLKLO_CDLO() uint32 {
	return volatile.LoadUint32(&o.I2C_CLKLO.Reg) & 0xff
}
func (o *USB_Type) SetI2C_CLKLO_RESERVED(value uint32) {
	volatile.StoreUint32(&o.I2C_CLKLO.Reg, volatile.LoadUint32(&o.I2C_CLKLO.Reg)&^(0xffffff00)|value<<8)
}
func (o *USB_Type) GetI2C_CLKLO_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.I2C_CLKLO.Reg) & 0xffffff00) >> 8
}

// USB.CLKCTRL: OTG clock controller
func (o *USB_Type) SetCLKCTRL_HOST_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLKCTRL.Reg, volatile.LoadUint32(&o.CLKCTRL.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetCLKCTRL_HOST_CLK_EN() uint32 {
	return volatile.LoadUint32(&o.CLKCTRL.Reg) & 0x1
}
func (o *USB_Type) SetCLKCTRL_DEV_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLKCTRL.Reg, volatile.LoadUint32(&o.CLKCTRL.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetCLKCTRL_DEV_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CLKCTRL.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetCLKCTRL_I2C_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLKCTRL.Reg, volatile.LoadUint32(&o.CLKCTRL.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetCLKCTRL_I2C_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CLKCTRL.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetCLKCTRL_OTG_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLKCTRL.Reg, volatile.LoadUint32(&o.CLKCTRL.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetCLKCTRL_OTG_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CLKCTRL.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetCLKCTRL_AHB_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.CLKCTRL.Reg, volatile.LoadUint32(&o.CLKCTRL.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetCLKCTRL_AHB_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CLKCTRL.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetCLKCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLKCTRL.Reg, volatile.LoadUint32(&o.CLKCTRL.Reg)&^(0xffffffe0)|value<<5)
}
func (o *USB_Type) GetCLKCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLKCTRL.Reg) & 0xffffffe0) >> 5
}

// USB.OTGClkSt: OTG clock status
func (o *USB_Type) SetOTGClkSt_HOST_CLK_ON(value uint32) {
	volatile.StoreUint32(&o.OTGClkSt.Reg, volatile.LoadUint32(&o.OTGClkSt.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetOTGClkSt_HOST_CLK_ON() uint32 {
	return volatile.LoadUint32(&o.OTGClkSt.Reg) & 0x1
}
func (o *USB_Type) SetOTGClkSt_DEV_CLK_ON(value uint32) {
	volatile.StoreUint32(&o.OTGClkSt.Reg, volatile.LoadUint32(&o.OTGClkSt.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetOTGClkSt_DEV_CLK_ON() uint32 {
	return (volatile.LoadUint32(&o.OTGClkSt.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetOTGClkSt_I2C_CLK_ON(value uint32) {
	volatile.StoreUint32(&o.OTGClkSt.Reg, volatile.LoadUint32(&o.OTGClkSt.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetOTGClkSt_I2C_CLK_ON() uint32 {
	return (volatile.LoadUint32(&o.OTGClkSt.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetOTGClkSt_OTG_CLK_ON(value uint32) {
	volatile.StoreUint32(&o.OTGClkSt.Reg, volatile.LoadUint32(&o.OTGClkSt.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetOTGClkSt_OTG_CLK_ON() uint32 {
	return (volatile.LoadUint32(&o.OTGClkSt.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetOTGClkSt_AHB_CLK_ON(value uint32) {
	volatile.StoreUint32(&o.OTGClkSt.Reg, volatile.LoadUint32(&o.OTGClkSt.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetOTGClkSt_AHB_CLK_ON() uint32 {
	return (volatile.LoadUint32(&o.OTGClkSt.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetOTGClkSt_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OTGClkSt.Reg, volatile.LoadUint32(&o.OTGClkSt.Reg)&^(0xffffffe0)|value<<5)
}
func (o *USB_Type) GetOTGClkSt_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OTGClkSt.Reg) & 0xffffffe0) >> 5
}

// CRC engine
type CRC_Type struct {
	MODE volatile.Register32 // 0x0
	SEED volatile.Register32 // 0x4
	SUM  volatile.Register32 // 0x8
}

// CRC.MODE: CRC mode register
func (o *CRC_Type) SetMODE_CRC_POLY(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x3)|value)
}
func (o *CRC_Type) GetMODE_CRC_POLY() uint32 {
	return volatile.LoadUint32(&o.MODE.Reg) & 0x3
}
func (o *CRC_Type) SetMODE_BIT_RVS_WR(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x4)|value<<2)
}
func (o *CRC_Type) GetMODE_BIT_RVS_WR() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x4) >> 2
}
func (o *CRC_Type) SetMODE_CMPL_WR(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x8)|value<<3)
}
func (o *CRC_Type) GetMODE_CMPL_WR() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x8) >> 3
}
func (o *CRC_Type) SetMODE_BIT_RVS_SUM(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x10)|value<<4)
}
func (o *CRC_Type) GetMODE_BIT_RVS_SUM() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x10) >> 4
}
func (o *CRC_Type) SetMODE_CMPL_SUM(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0x20)|value<<5)
}
func (o *CRC_Type) GetMODE_CMPL_SUM() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0x20) >> 5
}
func (o *CRC_Type) SetMODE_Reserved(value uint32) {
	volatile.StoreUint32(&o.MODE.Reg, volatile.LoadUint32(&o.MODE.Reg)&^(0xffffffc0)|value<<6)
}
func (o *CRC_Type) GetMODE_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MODE.Reg) & 0xffffffc0) >> 6
}

// CRC.SEED: CRC seed register
func (o *CRC_Type) SetSEED(value uint32) {
	volatile.StoreUint32(&o.SEED.Reg, value)
}
func (o *CRC_Type) GetSEED() uint32 {
	return volatile.LoadUint32(&o.SEED.Reg)
}

// CRC.SUM: CRC checksum register
func (o *CRC_Type) SetSUM(value uint32) {
	volatile.StoreUint32(&o.SUM.Reg, value)
}
func (o *CRC_Type) GetSUM() uint32 {
	return volatile.LoadUint32(&o.SUM.Reg)
}

// GPIO
type GPIO_Type struct {
	DIR0  volatile.Register32 // 0x0
	_     [12]byte
	MASK0 volatile.Register32 // 0x10
	PIN0  volatile.Register32 // 0x14
	SET0  volatile.Register32 // 0x18
	CLR0  volatile.Register32 // 0x1C
	DIR1  volatile.Register32 // 0x20
	_     [12]byte
	MASK1 volatile.Register32 // 0x30
	PIN1  volatile.Register32 // 0x34
	SET1  volatile.Register32 // 0x38
	CLR1  volatile.Register32 // 0x3C
	DIR2  volatile.Register32 // 0x40
	_     [12]byte
	MASK2 volatile.Register32 // 0x50
	PIN2  volatile.Register32 // 0x54
	SET2  volatile.Register32 // 0x58
	CLR2  volatile.Register32 // 0x5C
	DIR3  volatile.Register32 // 0x60
	_     [12]byte
	MASK3 volatile.Register32 // 0x70
	PIN3  volatile.Register32 // 0x74
	SET3  volatile.Register32 // 0x78
	CLR3  volatile.Register32 // 0x7C
	DIR4  volatile.Register32 // 0x80
	_     [12]byte
	MASK4 volatile.Register32 // 0x90
	PIN4  volatile.Register32 // 0x94
	SET4  volatile.Register32 // 0x98
	CLR4  volatile.Register32 // 0x9C
	DIR5  volatile.Register32 // 0xA0
	_     [12]byte
	MASK5 volatile.Register32 // 0xB0
	PIN5  volatile.Register32 // 0xB4
	SET5  volatile.Register32 // 0xB8
	CLR5  volatile.Register32 // 0xBC
}

// GPIO.DIR0: GPIO Port Direction control register.
func (o *GPIO_Type) SetDIR0_PDIR0(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetDIR0_PDIR0() uint32 {
	return volatile.LoadUint32(&o.DIR0.Reg) & 0x1
}
func (o *GPIO_Type) SetDIR0_PDIR1(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetDIR0_PDIR1() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetDIR0_PDIR2(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetDIR0_PDIR2() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetDIR0_PDIR3(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetDIR0_PDIR3() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetDIR0_PDIR4(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetDIR0_PDIR4() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetDIR0_PDIR5(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetDIR0_PDIR5() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetDIR0_PDIR6(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetDIR0_PDIR6() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetDIR0_PDIR7(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetDIR0_PDIR7() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetDIR0_PDIR8(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetDIR0_PDIR8() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetDIR0_PDIR9(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetDIR0_PDIR9() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetDIR0_PDIR10(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetDIR0_PDIR10() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetDIR0_PDIR11(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetDIR0_PDIR11() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetDIR0_PDIR12(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetDIR0_PDIR12() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetDIR0_PDIR13(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetDIR0_PDIR13() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetDIR0_PDIR14(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetDIR0_PDIR14() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetDIR0_PDIR15(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetDIR0_PDIR15() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetDIR0_PDIR16(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetDIR0_PDIR16() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetDIR0_PDIR17(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetDIR0_PDIR17() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetDIR0_PDIR18(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetDIR0_PDIR18() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetDIR0_PDIR19(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetDIR0_PDIR19() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetDIR0_PDIR20(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetDIR0_PDIR20() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetDIR0_PDIR21(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetDIR0_PDIR21() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetDIR0_PDIR22(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetDIR0_PDIR22() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetDIR0_PDIR23(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetDIR0_PDIR23() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetDIR0_PDIR24(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetDIR0_PDIR24() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetDIR0_PDIR25(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetDIR0_PDIR25() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetDIR0_PDIR26(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetDIR0_PDIR26() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetDIR0_PDIR27(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetDIR0_PDIR27() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetDIR0_PDIR28(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetDIR0_PDIR28() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetDIR0_PDIR29(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetDIR0_PDIR29() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetDIR0_PDIR30(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetDIR0_PDIR30() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetDIR0_PDIR31(value uint32) {
	volatile.StoreUint32(&o.DIR0.Reg, volatile.LoadUint32(&o.DIR0.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetDIR0_PDIR31() uint32 {
	return (volatile.LoadUint32(&o.DIR0.Reg) & 0x80000000) >> 31
}

// GPIO.MASK0: Mask register for Port.
func (o *GPIO_Type) SetMASK0_PMASK0(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetMASK0_PMASK0() uint32 {
	return volatile.LoadUint32(&o.MASK0.Reg) & 0x1
}
func (o *GPIO_Type) SetMASK0_PMASK1(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetMASK0_PMASK1() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetMASK0_PMASK2(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetMASK0_PMASK2() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetMASK0_PMASK3(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetMASK0_PMASK3() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetMASK0_PMASK4(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetMASK0_PMASK4() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetMASK0_PMASK5(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetMASK0_PMASK5() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetMASK0_PMASK6(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetMASK0_PMASK6() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetMASK0_PMASK7(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetMASK0_PMASK7() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetMASK0_PMASK8(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetMASK0_PMASK8() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetMASK0_PMASK9(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetMASK0_PMASK9() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetMASK0_PMASK10(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetMASK0_PMASK10() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetMASK0_PMASK11(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetMASK0_PMASK11() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetMASK0_PMASK12(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetMASK0_PMASK12() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetMASK0_PMASK13(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetMASK0_PMASK13() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetMASK0_PMASK14(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetMASK0_PMASK14() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetMASK0_PMASK15(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetMASK0_PMASK15() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetMASK0_PMASK16(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetMASK0_PMASK16() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetMASK0_PMASK17(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetMASK0_PMASK17() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetMASK0_PMASK18(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetMASK0_PMASK18() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetMASK0_PMASK19(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetMASK0_PMASK19() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetMASK0_PMASK20(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetMASK0_PMASK20() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetMASK0_PMASK21(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetMASK0_PMASK21() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetMASK0_PMASK22(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetMASK0_PMASK22() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetMASK0_PMASK23(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetMASK0_PMASK23() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetMASK0_PMASK24(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetMASK0_PMASK24() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetMASK0_PMASK25(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetMASK0_PMASK25() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetMASK0_PMASK26(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetMASK0_PMASK26() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetMASK0_PMASK27(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetMASK0_PMASK27() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetMASK0_PMASK28(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetMASK0_PMASK28() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetMASK0_PMASK29(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetMASK0_PMASK29() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetMASK0_PMASK30(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetMASK0_PMASK30() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetMASK0_PMASK31(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetMASK0_PMASK31() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x80000000) >> 31
}

// GPIO.PIN0: Port Pin value register using MASK.
func (o *GPIO_Type) SetPIN0_VAL0(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetPIN0_VAL0() uint32 {
	return volatile.LoadUint32(&o.PIN0.Reg) & 0x1
}
func (o *GPIO_Type) SetPIN0_VAL1(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetPIN0_VAL1() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetPIN0_VAL2(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN0_VAL2() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN0_VAL3(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetPIN0_VAL3() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetPIN0_VAL4(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetPIN0_VAL4() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetPIN0_VAL5(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetPIN0_VAL5() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetPIN0_VAL6(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetPIN0_VAL6() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetPIN0_VAL7(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetPIN0_VAL7() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetPIN0_VAL8(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetPIN0_VAL8() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetPIN0_VAL9(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetPIN0_VAL9() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetPIN0_VAL10(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN0_VAL10() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN0_VAL11(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetPIN0_VAL11() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetPIN0_VAL12(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetPIN0_VAL12() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetPIN0_VAL13(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetPIN0_VAL13() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetPIN0_VAL14(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetPIN0_VAL14() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetPIN0_VAL15(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetPIN0_VAL15() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetPIN0_VAL16(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetPIN0_VAL16() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetPIN0_VAL17(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetPIN0_VAL17() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetPIN0_VAL18(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetPIN0_VAL18() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetPIN0_VAL19(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetPIN0_VAL19() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetPIN0_VAL20(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetPIN0_VAL20() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetPIN0_VAL21(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetPIN0_VAL21() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetPIN0_VAL22(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetPIN0_VAL22() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetPIN0_VAL23(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetPIN0_VAL23() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetPIN0_VAL24(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetPIN0_VAL24() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetPIN0_VAL25(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetPIN0_VAL25() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetPIN0_VAL26(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetPIN0_VAL26() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetPIN0_VAL27(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetPIN0_VAL27() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetPIN0_VAL28(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetPIN0_VAL28() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetPIN0_VAL29(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetPIN0_VAL29() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetPIN0_VAL30(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetPIN0_VAL30() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetPIN0_VAL31(value uint32) {
	volatile.StoreUint32(&o.PIN0.Reg, volatile.LoadUint32(&o.PIN0.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetPIN0_VAL31() uint32 {
	return (volatile.LoadUint32(&o.PIN0.Reg) & 0x80000000) >> 31
}

// GPIO.SET0: Port Output Set register using MASK.
func (o *GPIO_Type) SetSET0_PSET0(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetSET0_PSET0() uint32 {
	return volatile.LoadUint32(&o.SET0.Reg) & 0x1
}
func (o *GPIO_Type) SetSET0_PSET1(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetSET0_PSET1() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetSET0_PSET2(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetSET0_PSET2() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetSET0_PSET3(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetSET0_PSET3() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetSET0_PSET4(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetSET0_PSET4() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetSET0_PSET5(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetSET0_PSET5() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetSET0_PSET6(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetSET0_PSET6() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetSET0_PSET7(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetSET0_PSET7() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetSET0_PSET8(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetSET0_PSET8() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetSET0_PSET9(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetSET0_PSET9() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetSET0_PSET10(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetSET0_PSET10() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetSET0_PSET11(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetSET0_PSET11() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetSET0_PSET12(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetSET0_PSET12() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetSET0_PSET13(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetSET0_PSET13() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetSET0_PSET14(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetSET0_PSET14() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetSET0_PSET15(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetSET0_PSET15() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetSET0_PSET16(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetSET0_PSET16() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetSET0_PSET17(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetSET0_PSET17() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetSET0_PSET18(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetSET0_PSET18() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetSET0_PSET19(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetSET0_PSET19() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetSET0_PSET20(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetSET0_PSET20() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetSET0_PSET21(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetSET0_PSET21() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetSET0_PSET22(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetSET0_PSET22() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetSET0_PSET23(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetSET0_PSET23() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetSET0_PSET24(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetSET0_PSET24() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetSET0_PSET25(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetSET0_PSET25() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetSET0_PSET26(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetSET0_PSET26() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetSET0_PSET27(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetSET0_PSET27() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetSET0_PSET28(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetSET0_PSET28() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetSET0_PSET29(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetSET0_PSET29() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetSET0_PSET30(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetSET0_PSET30() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetSET0_PSET31(value uint32) {
	volatile.StoreUint32(&o.SET0.Reg, volatile.LoadUint32(&o.SET0.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetSET0_PSET31() uint32 {
	return (volatile.LoadUint32(&o.SET0.Reg) & 0x80000000) >> 31
}

// GPIO.CLR0: Port Output Clear register using MASK.
func (o *GPIO_Type) SetCLR0_PCLR0(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetCLR0_PCLR0() uint32 {
	return volatile.LoadUint32(&o.CLR0.Reg) & 0x1
}
func (o *GPIO_Type) SetCLR0_PCLR1(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetCLR0_PCLR1() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetCLR0_PCLR2(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetCLR0_PCLR2() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetCLR0_PCLR3(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetCLR0_PCLR3() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetCLR0_PCLR4(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetCLR0_PCLR4() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetCLR0_PCLR5(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetCLR0_PCLR5() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetCLR0_PCLR6(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetCLR0_PCLR6() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetCLR0_PCLR7(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetCLR0_PCLR7() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetCLR0_PCLR8(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetCLR0_PCLR8() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetCLR0_PCLR9(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetCLR0_PCLR9() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetCLR0_PCLR10(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetCLR0_PCLR10() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetCLR0_PCLR11(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetCLR0_PCLR11() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetCLR0_PCLR12(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetCLR0_PCLR12() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetCLR0_PCLR13(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetCLR0_PCLR13() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetCLR0_PCLR14(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetCLR0_PCLR14() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetCLR0_PCLR15(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetCLR0_PCLR15() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetCLR0_PCLR16(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetCLR0_PCLR16() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetCLR0_PCLR17(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetCLR0_PCLR17() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetCLR0_PCLR18(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetCLR0_PCLR18() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetCLR0_PCLR19(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetCLR0_PCLR19() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetCLR0_PCLR20(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetCLR0_PCLR20() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetCLR0_PCLR21(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetCLR0_PCLR21() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetCLR0_PCLR22(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetCLR0_PCLR22() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetCLR0_PCLR23(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetCLR0_PCLR23() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetCLR0_PCLR24(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetCLR0_PCLR24() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetCLR0_PCLR25(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetCLR0_PCLR25() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetCLR0_PCLR26(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetCLR0_PCLR26() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetCLR0_PCLR27(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetCLR0_PCLR27() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetCLR0_PCLR28(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetCLR0_PCLR28() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetCLR0_PCLR29(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetCLR0_PCLR29() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetCLR0_PCLR30(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetCLR0_PCLR30() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetCLR0_PCLR31(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetCLR0_PCLR31() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x80000000) >> 31
}

// GPIO.DIR1: GPIO Port Direction control register.
func (o *GPIO_Type) SetDIR1_PDIR0(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetDIR1_PDIR0() uint32 {
	return volatile.LoadUint32(&o.DIR1.Reg) & 0x1
}
func (o *GPIO_Type) SetDIR1_PDIR1(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetDIR1_PDIR1() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetDIR1_PDIR2(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetDIR1_PDIR2() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetDIR1_PDIR3(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetDIR1_PDIR3() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetDIR1_PDIR4(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetDIR1_PDIR4() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetDIR1_PDIR5(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetDIR1_PDIR5() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetDIR1_PDIR6(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetDIR1_PDIR6() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetDIR1_PDIR7(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetDIR1_PDIR7() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetDIR1_PDIR8(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetDIR1_PDIR8() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetDIR1_PDIR9(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetDIR1_PDIR9() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetDIR1_PDIR10(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetDIR1_PDIR10() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetDIR1_PDIR11(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetDIR1_PDIR11() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetDIR1_PDIR12(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetDIR1_PDIR12() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetDIR1_PDIR13(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetDIR1_PDIR13() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetDIR1_PDIR14(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetDIR1_PDIR14() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetDIR1_PDIR15(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetDIR1_PDIR15() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetDIR1_PDIR16(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetDIR1_PDIR16() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetDIR1_PDIR17(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetDIR1_PDIR17() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetDIR1_PDIR18(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetDIR1_PDIR18() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetDIR1_PDIR19(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetDIR1_PDIR19() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetDIR1_PDIR20(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetDIR1_PDIR20() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetDIR1_PDIR21(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetDIR1_PDIR21() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetDIR1_PDIR22(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetDIR1_PDIR22() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetDIR1_PDIR23(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetDIR1_PDIR23() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetDIR1_PDIR24(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetDIR1_PDIR24() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetDIR1_PDIR25(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetDIR1_PDIR25() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetDIR1_PDIR26(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetDIR1_PDIR26() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetDIR1_PDIR27(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetDIR1_PDIR27() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetDIR1_PDIR28(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetDIR1_PDIR28() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetDIR1_PDIR29(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetDIR1_PDIR29() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetDIR1_PDIR30(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetDIR1_PDIR30() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetDIR1_PDIR31(value uint32) {
	volatile.StoreUint32(&o.DIR1.Reg, volatile.LoadUint32(&o.DIR1.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetDIR1_PDIR31() uint32 {
	return (volatile.LoadUint32(&o.DIR1.Reg) & 0x80000000) >> 31
}

// GPIO.MASK1: Mask register for Port.
func (o *GPIO_Type) SetMASK1_PMASK0(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetMASK1_PMASK0() uint32 {
	return volatile.LoadUint32(&o.MASK1.Reg) & 0x1
}
func (o *GPIO_Type) SetMASK1_PMASK1(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetMASK1_PMASK1() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetMASK1_PMASK2(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetMASK1_PMASK2() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetMASK1_PMASK3(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetMASK1_PMASK3() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetMASK1_PMASK4(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetMASK1_PMASK4() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetMASK1_PMASK5(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetMASK1_PMASK5() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetMASK1_PMASK6(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetMASK1_PMASK6() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetMASK1_PMASK7(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetMASK1_PMASK7() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetMASK1_PMASK8(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetMASK1_PMASK8() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetMASK1_PMASK9(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetMASK1_PMASK9() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetMASK1_PMASK10(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetMASK1_PMASK10() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetMASK1_PMASK11(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetMASK1_PMASK11() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetMASK1_PMASK12(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetMASK1_PMASK12() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetMASK1_PMASK13(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetMASK1_PMASK13() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetMASK1_PMASK14(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetMASK1_PMASK14() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetMASK1_PMASK15(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetMASK1_PMASK15() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetMASK1_PMASK16(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetMASK1_PMASK16() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetMASK1_PMASK17(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetMASK1_PMASK17() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetMASK1_PMASK18(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetMASK1_PMASK18() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetMASK1_PMASK19(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetMASK1_PMASK19() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetMASK1_PMASK20(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetMASK1_PMASK20() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetMASK1_PMASK21(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetMASK1_PMASK21() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetMASK1_PMASK22(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetMASK1_PMASK22() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetMASK1_PMASK23(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetMASK1_PMASK23() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetMASK1_PMASK24(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetMASK1_PMASK24() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetMASK1_PMASK25(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetMASK1_PMASK25() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetMASK1_PMASK26(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetMASK1_PMASK26() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetMASK1_PMASK27(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetMASK1_PMASK27() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetMASK1_PMASK28(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetMASK1_PMASK28() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetMASK1_PMASK29(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetMASK1_PMASK29() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetMASK1_PMASK30(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetMASK1_PMASK30() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetMASK1_PMASK31(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetMASK1_PMASK31() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0x80000000) >> 31
}

// GPIO.PIN1: Port Pin value register using MASK.
func (o *GPIO_Type) SetPIN1_VAL0(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetPIN1_VAL0() uint32 {
	return volatile.LoadUint32(&o.PIN1.Reg) & 0x1
}
func (o *GPIO_Type) SetPIN1_VAL1(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetPIN1_VAL1() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetPIN1_VAL2(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN1_VAL2() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN1_VAL3(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetPIN1_VAL3() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetPIN1_VAL4(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetPIN1_VAL4() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetPIN1_VAL5(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetPIN1_VAL5() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetPIN1_VAL6(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetPIN1_VAL6() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetPIN1_VAL7(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetPIN1_VAL7() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetPIN1_VAL8(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetPIN1_VAL8() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetPIN1_VAL9(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetPIN1_VAL9() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetPIN1_VAL10(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN1_VAL10() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN1_VAL11(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetPIN1_VAL11() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetPIN1_VAL12(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetPIN1_VAL12() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetPIN1_VAL13(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetPIN1_VAL13() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetPIN1_VAL14(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetPIN1_VAL14() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetPIN1_VAL15(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetPIN1_VAL15() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetPIN1_VAL16(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetPIN1_VAL16() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetPIN1_VAL17(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetPIN1_VAL17() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetPIN1_VAL18(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetPIN1_VAL18() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetPIN1_VAL19(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetPIN1_VAL19() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetPIN1_VAL20(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetPIN1_VAL20() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetPIN1_VAL21(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetPIN1_VAL21() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetPIN1_VAL22(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetPIN1_VAL22() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetPIN1_VAL23(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetPIN1_VAL23() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetPIN1_VAL24(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetPIN1_VAL24() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetPIN1_VAL25(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetPIN1_VAL25() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetPIN1_VAL26(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetPIN1_VAL26() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetPIN1_VAL27(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetPIN1_VAL27() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetPIN1_VAL28(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetPIN1_VAL28() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetPIN1_VAL29(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetPIN1_VAL29() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetPIN1_VAL30(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetPIN1_VAL30() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetPIN1_VAL31(value uint32) {
	volatile.StoreUint32(&o.PIN1.Reg, volatile.LoadUint32(&o.PIN1.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetPIN1_VAL31() uint32 {
	return (volatile.LoadUint32(&o.PIN1.Reg) & 0x80000000) >> 31
}

// GPIO.SET1: Port Output Set register using MASK.
func (o *GPIO_Type) SetSET1_PSET0(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetSET1_PSET0() uint32 {
	return volatile.LoadUint32(&o.SET1.Reg) & 0x1
}
func (o *GPIO_Type) SetSET1_PSET1(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetSET1_PSET1() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetSET1_PSET2(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetSET1_PSET2() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetSET1_PSET3(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetSET1_PSET3() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetSET1_PSET4(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetSET1_PSET4() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetSET1_PSET5(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetSET1_PSET5() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetSET1_PSET6(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetSET1_PSET6() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetSET1_PSET7(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetSET1_PSET7() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetSET1_PSET8(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetSET1_PSET8() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetSET1_PSET9(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetSET1_PSET9() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetSET1_PSET10(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetSET1_PSET10() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetSET1_PSET11(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetSET1_PSET11() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetSET1_PSET12(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetSET1_PSET12() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetSET1_PSET13(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetSET1_PSET13() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetSET1_PSET14(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetSET1_PSET14() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetSET1_PSET15(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetSET1_PSET15() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetSET1_PSET16(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetSET1_PSET16() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetSET1_PSET17(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetSET1_PSET17() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetSET1_PSET18(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetSET1_PSET18() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetSET1_PSET19(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetSET1_PSET19() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetSET1_PSET20(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetSET1_PSET20() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetSET1_PSET21(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetSET1_PSET21() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetSET1_PSET22(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetSET1_PSET22() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetSET1_PSET23(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetSET1_PSET23() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetSET1_PSET24(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetSET1_PSET24() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetSET1_PSET25(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetSET1_PSET25() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetSET1_PSET26(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetSET1_PSET26() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetSET1_PSET27(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetSET1_PSET27() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetSET1_PSET28(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetSET1_PSET28() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetSET1_PSET29(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetSET1_PSET29() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetSET1_PSET30(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetSET1_PSET30() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetSET1_PSET31(value uint32) {
	volatile.StoreUint32(&o.SET1.Reg, volatile.LoadUint32(&o.SET1.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetSET1_PSET31() uint32 {
	return (volatile.LoadUint32(&o.SET1.Reg) & 0x80000000) >> 31
}

// GPIO.CLR1: Port Output Clear register using MASK.
func (o *GPIO_Type) SetCLR1_PCLR0(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetCLR1_PCLR0() uint32 {
	return volatile.LoadUint32(&o.CLR1.Reg) & 0x1
}
func (o *GPIO_Type) SetCLR1_PCLR1(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetCLR1_PCLR1() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetCLR1_PCLR2(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetCLR1_PCLR2() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetCLR1_PCLR3(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetCLR1_PCLR3() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetCLR1_PCLR4(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetCLR1_PCLR4() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetCLR1_PCLR5(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetCLR1_PCLR5() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetCLR1_PCLR6(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetCLR1_PCLR6() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetCLR1_PCLR7(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetCLR1_PCLR7() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetCLR1_PCLR8(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetCLR1_PCLR8() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetCLR1_PCLR9(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetCLR1_PCLR9() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetCLR1_PCLR10(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetCLR1_PCLR10() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetCLR1_PCLR11(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetCLR1_PCLR11() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetCLR1_PCLR12(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetCLR1_PCLR12() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetCLR1_PCLR13(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetCLR1_PCLR13() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetCLR1_PCLR14(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetCLR1_PCLR14() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetCLR1_PCLR15(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetCLR1_PCLR15() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetCLR1_PCLR16(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetCLR1_PCLR16() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetCLR1_PCLR17(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetCLR1_PCLR17() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetCLR1_PCLR18(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetCLR1_PCLR18() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetCLR1_PCLR19(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetCLR1_PCLR19() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetCLR1_PCLR20(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetCLR1_PCLR20() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetCLR1_PCLR21(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetCLR1_PCLR21() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetCLR1_PCLR22(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetCLR1_PCLR22() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetCLR1_PCLR23(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetCLR1_PCLR23() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetCLR1_PCLR24(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetCLR1_PCLR24() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetCLR1_PCLR25(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetCLR1_PCLR25() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetCLR1_PCLR26(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetCLR1_PCLR26() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetCLR1_PCLR27(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetCLR1_PCLR27() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetCLR1_PCLR28(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetCLR1_PCLR28() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetCLR1_PCLR29(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetCLR1_PCLR29() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetCLR1_PCLR30(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetCLR1_PCLR30() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetCLR1_PCLR31(value uint32) {
	volatile.StoreUint32(&o.CLR1.Reg, volatile.LoadUint32(&o.CLR1.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetCLR1_PCLR31() uint32 {
	return (volatile.LoadUint32(&o.CLR1.Reg) & 0x80000000) >> 31
}

// GPIO.DIR2: GPIO Port Direction control register.
func (o *GPIO_Type) SetDIR2_PDIR0(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetDIR2_PDIR0() uint32 {
	return volatile.LoadUint32(&o.DIR2.Reg) & 0x1
}
func (o *GPIO_Type) SetDIR2_PDIR1(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetDIR2_PDIR1() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetDIR2_PDIR2(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetDIR2_PDIR2() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetDIR2_PDIR3(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetDIR2_PDIR3() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetDIR2_PDIR4(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetDIR2_PDIR4() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetDIR2_PDIR5(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetDIR2_PDIR5() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetDIR2_PDIR6(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetDIR2_PDIR6() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetDIR2_PDIR7(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetDIR2_PDIR7() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetDIR2_PDIR8(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetDIR2_PDIR8() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetDIR2_PDIR9(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetDIR2_PDIR9() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetDIR2_PDIR10(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetDIR2_PDIR10() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetDIR2_PDIR11(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetDIR2_PDIR11() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetDIR2_PDIR12(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetDIR2_PDIR12() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetDIR2_PDIR13(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetDIR2_PDIR13() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetDIR2_PDIR14(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetDIR2_PDIR14() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetDIR2_PDIR15(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetDIR2_PDIR15() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetDIR2_PDIR16(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetDIR2_PDIR16() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetDIR2_PDIR17(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetDIR2_PDIR17() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetDIR2_PDIR18(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetDIR2_PDIR18() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetDIR2_PDIR19(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetDIR2_PDIR19() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetDIR2_PDIR20(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetDIR2_PDIR20() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetDIR2_PDIR21(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetDIR2_PDIR21() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetDIR2_PDIR22(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetDIR2_PDIR22() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetDIR2_PDIR23(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetDIR2_PDIR23() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetDIR2_PDIR24(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetDIR2_PDIR24() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetDIR2_PDIR25(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetDIR2_PDIR25() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetDIR2_PDIR26(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetDIR2_PDIR26() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetDIR2_PDIR27(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetDIR2_PDIR27() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetDIR2_PDIR28(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetDIR2_PDIR28() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetDIR2_PDIR29(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetDIR2_PDIR29() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetDIR2_PDIR30(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetDIR2_PDIR30() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetDIR2_PDIR31(value uint32) {
	volatile.StoreUint32(&o.DIR2.Reg, volatile.LoadUint32(&o.DIR2.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetDIR2_PDIR31() uint32 {
	return (volatile.LoadUint32(&o.DIR2.Reg) & 0x80000000) >> 31
}

// GPIO.MASK2: Mask register for Port.
func (o *GPIO_Type) SetMASK2_PMASK0(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetMASK2_PMASK0() uint32 {
	return volatile.LoadUint32(&o.MASK2.Reg) & 0x1
}
func (o *GPIO_Type) SetMASK2_PMASK1(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetMASK2_PMASK1() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetMASK2_PMASK2(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetMASK2_PMASK2() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetMASK2_PMASK3(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetMASK2_PMASK3() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetMASK2_PMASK4(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetMASK2_PMASK4() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetMASK2_PMASK5(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetMASK2_PMASK5() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetMASK2_PMASK6(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetMASK2_PMASK6() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetMASK2_PMASK7(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetMASK2_PMASK7() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetMASK2_PMASK8(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetMASK2_PMASK8() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetMASK2_PMASK9(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetMASK2_PMASK9() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetMASK2_PMASK10(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetMASK2_PMASK10() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetMASK2_PMASK11(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetMASK2_PMASK11() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetMASK2_PMASK12(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetMASK2_PMASK12() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetMASK2_PMASK13(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetMASK2_PMASK13() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetMASK2_PMASK14(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetMASK2_PMASK14() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetMASK2_PMASK15(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetMASK2_PMASK15() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetMASK2_PMASK16(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetMASK2_PMASK16() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetMASK2_PMASK17(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetMASK2_PMASK17() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetMASK2_PMASK18(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetMASK2_PMASK18() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetMASK2_PMASK19(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetMASK2_PMASK19() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetMASK2_PMASK20(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetMASK2_PMASK20() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetMASK2_PMASK21(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetMASK2_PMASK21() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetMASK2_PMASK22(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetMASK2_PMASK22() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetMASK2_PMASK23(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetMASK2_PMASK23() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetMASK2_PMASK24(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetMASK2_PMASK24() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetMASK2_PMASK25(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetMASK2_PMASK25() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetMASK2_PMASK26(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetMASK2_PMASK26() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetMASK2_PMASK27(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetMASK2_PMASK27() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetMASK2_PMASK28(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetMASK2_PMASK28() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetMASK2_PMASK29(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetMASK2_PMASK29() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetMASK2_PMASK30(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetMASK2_PMASK30() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetMASK2_PMASK31(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetMASK2_PMASK31() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0x80000000) >> 31
}

// GPIO.PIN2: Port Pin value register using MASK.
func (o *GPIO_Type) SetPIN2_VAL0(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetPIN2_VAL0() uint32 {
	return volatile.LoadUint32(&o.PIN2.Reg) & 0x1
}
func (o *GPIO_Type) SetPIN2_VAL1(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetPIN2_VAL1() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetPIN2_VAL2(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN2_VAL2() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN2_VAL3(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetPIN2_VAL3() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetPIN2_VAL4(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetPIN2_VAL4() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetPIN2_VAL5(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetPIN2_VAL5() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetPIN2_VAL6(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetPIN2_VAL6() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetPIN2_VAL7(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetPIN2_VAL7() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetPIN2_VAL8(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetPIN2_VAL8() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetPIN2_VAL9(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetPIN2_VAL9() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetPIN2_VAL10(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN2_VAL10() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN2_VAL11(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetPIN2_VAL11() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetPIN2_VAL12(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetPIN2_VAL12() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetPIN2_VAL13(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetPIN2_VAL13() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetPIN2_VAL14(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetPIN2_VAL14() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetPIN2_VAL15(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetPIN2_VAL15() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetPIN2_VAL16(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetPIN2_VAL16() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetPIN2_VAL17(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetPIN2_VAL17() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetPIN2_VAL18(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetPIN2_VAL18() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetPIN2_VAL19(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetPIN2_VAL19() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetPIN2_VAL20(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetPIN2_VAL20() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetPIN2_VAL21(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetPIN2_VAL21() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetPIN2_VAL22(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetPIN2_VAL22() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetPIN2_VAL23(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetPIN2_VAL23() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetPIN2_VAL24(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetPIN2_VAL24() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetPIN2_VAL25(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetPIN2_VAL25() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetPIN2_VAL26(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetPIN2_VAL26() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetPIN2_VAL27(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetPIN2_VAL27() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetPIN2_VAL28(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetPIN2_VAL28() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetPIN2_VAL29(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetPIN2_VAL29() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetPIN2_VAL30(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetPIN2_VAL30() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetPIN2_VAL31(value uint32) {
	volatile.StoreUint32(&o.PIN2.Reg, volatile.LoadUint32(&o.PIN2.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetPIN2_VAL31() uint32 {
	return (volatile.LoadUint32(&o.PIN2.Reg) & 0x80000000) >> 31
}

// GPIO.SET2: Port Output Set register using MASK.
func (o *GPIO_Type) SetSET2_PSET0(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetSET2_PSET0() uint32 {
	return volatile.LoadUint32(&o.SET2.Reg) & 0x1
}
func (o *GPIO_Type) SetSET2_PSET1(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetSET2_PSET1() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetSET2_PSET2(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetSET2_PSET2() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetSET2_PSET3(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetSET2_PSET3() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetSET2_PSET4(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetSET2_PSET4() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetSET2_PSET5(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetSET2_PSET5() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetSET2_PSET6(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetSET2_PSET6() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetSET2_PSET7(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetSET2_PSET7() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetSET2_PSET8(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetSET2_PSET8() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetSET2_PSET9(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetSET2_PSET9() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetSET2_PSET10(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetSET2_PSET10() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetSET2_PSET11(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetSET2_PSET11() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetSET2_PSET12(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetSET2_PSET12() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetSET2_PSET13(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetSET2_PSET13() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetSET2_PSET14(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetSET2_PSET14() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetSET2_PSET15(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetSET2_PSET15() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetSET2_PSET16(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetSET2_PSET16() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetSET2_PSET17(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetSET2_PSET17() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetSET2_PSET18(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetSET2_PSET18() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetSET2_PSET19(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetSET2_PSET19() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetSET2_PSET20(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetSET2_PSET20() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetSET2_PSET21(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetSET2_PSET21() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetSET2_PSET22(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetSET2_PSET22() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetSET2_PSET23(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetSET2_PSET23() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetSET2_PSET24(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetSET2_PSET24() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetSET2_PSET25(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetSET2_PSET25() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetSET2_PSET26(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetSET2_PSET26() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetSET2_PSET27(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetSET2_PSET27() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetSET2_PSET28(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetSET2_PSET28() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetSET2_PSET29(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetSET2_PSET29() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetSET2_PSET30(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetSET2_PSET30() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetSET2_PSET31(value uint32) {
	volatile.StoreUint32(&o.SET2.Reg, volatile.LoadUint32(&o.SET2.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetSET2_PSET31() uint32 {
	return (volatile.LoadUint32(&o.SET2.Reg) & 0x80000000) >> 31
}

// GPIO.CLR2: Port Output Clear register using MASK.
func (o *GPIO_Type) SetCLR2_PCLR0(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetCLR2_PCLR0() uint32 {
	return volatile.LoadUint32(&o.CLR2.Reg) & 0x1
}
func (o *GPIO_Type) SetCLR2_PCLR1(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetCLR2_PCLR1() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetCLR2_PCLR2(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetCLR2_PCLR2() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetCLR2_PCLR3(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetCLR2_PCLR3() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetCLR2_PCLR4(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetCLR2_PCLR4() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetCLR2_PCLR5(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetCLR2_PCLR5() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetCLR2_PCLR6(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetCLR2_PCLR6() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetCLR2_PCLR7(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetCLR2_PCLR7() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetCLR2_PCLR8(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetCLR2_PCLR8() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetCLR2_PCLR9(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetCLR2_PCLR9() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetCLR2_PCLR10(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetCLR2_PCLR10() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetCLR2_PCLR11(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetCLR2_PCLR11() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetCLR2_PCLR12(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetCLR2_PCLR12() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetCLR2_PCLR13(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetCLR2_PCLR13() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetCLR2_PCLR14(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetCLR2_PCLR14() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetCLR2_PCLR15(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetCLR2_PCLR15() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetCLR2_PCLR16(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetCLR2_PCLR16() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetCLR2_PCLR17(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetCLR2_PCLR17() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetCLR2_PCLR18(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetCLR2_PCLR18() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetCLR2_PCLR19(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetCLR2_PCLR19() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetCLR2_PCLR20(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetCLR2_PCLR20() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetCLR2_PCLR21(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetCLR2_PCLR21() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetCLR2_PCLR22(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetCLR2_PCLR22() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetCLR2_PCLR23(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetCLR2_PCLR23() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetCLR2_PCLR24(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetCLR2_PCLR24() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetCLR2_PCLR25(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetCLR2_PCLR25() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetCLR2_PCLR26(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetCLR2_PCLR26() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetCLR2_PCLR27(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetCLR2_PCLR27() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetCLR2_PCLR28(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetCLR2_PCLR28() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetCLR2_PCLR29(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetCLR2_PCLR29() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetCLR2_PCLR30(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetCLR2_PCLR30() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetCLR2_PCLR31(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetCLR2_PCLR31() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x80000000) >> 31
}

// GPIO.DIR3: GPIO Port Direction control register.
func (o *GPIO_Type) SetDIR3_PDIR0(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetDIR3_PDIR0() uint32 {
	return volatile.LoadUint32(&o.DIR3.Reg) & 0x1
}
func (o *GPIO_Type) SetDIR3_PDIR1(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetDIR3_PDIR1() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetDIR3_PDIR2(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetDIR3_PDIR2() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetDIR3_PDIR3(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetDIR3_PDIR3() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetDIR3_PDIR4(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetDIR3_PDIR4() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetDIR3_PDIR5(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetDIR3_PDIR5() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetDIR3_PDIR6(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetDIR3_PDIR6() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetDIR3_PDIR7(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetDIR3_PDIR7() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetDIR3_PDIR8(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetDIR3_PDIR8() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetDIR3_PDIR9(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetDIR3_PDIR9() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetDIR3_PDIR10(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetDIR3_PDIR10() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetDIR3_PDIR11(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetDIR3_PDIR11() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetDIR3_PDIR12(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetDIR3_PDIR12() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetDIR3_PDIR13(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetDIR3_PDIR13() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetDIR3_PDIR14(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetDIR3_PDIR14() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetDIR3_PDIR15(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetDIR3_PDIR15() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetDIR3_PDIR16(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetDIR3_PDIR16() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetDIR3_PDIR17(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetDIR3_PDIR17() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetDIR3_PDIR18(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetDIR3_PDIR18() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetDIR3_PDIR19(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetDIR3_PDIR19() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetDIR3_PDIR20(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetDIR3_PDIR20() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetDIR3_PDIR21(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetDIR3_PDIR21() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetDIR3_PDIR22(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetDIR3_PDIR22() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetDIR3_PDIR23(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetDIR3_PDIR23() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetDIR3_PDIR24(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetDIR3_PDIR24() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetDIR3_PDIR25(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetDIR3_PDIR25() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetDIR3_PDIR26(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetDIR3_PDIR26() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetDIR3_PDIR27(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetDIR3_PDIR27() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetDIR3_PDIR28(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetDIR3_PDIR28() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetDIR3_PDIR29(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetDIR3_PDIR29() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetDIR3_PDIR30(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetDIR3_PDIR30() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetDIR3_PDIR31(value uint32) {
	volatile.StoreUint32(&o.DIR3.Reg, volatile.LoadUint32(&o.DIR3.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetDIR3_PDIR31() uint32 {
	return (volatile.LoadUint32(&o.DIR3.Reg) & 0x80000000) >> 31
}

// GPIO.MASK3: Mask register for Port.
func (o *GPIO_Type) SetMASK3_PMASK0(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetMASK3_PMASK0() uint32 {
	return volatile.LoadUint32(&o.MASK3.Reg) & 0x1
}
func (o *GPIO_Type) SetMASK3_PMASK1(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetMASK3_PMASK1() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetMASK3_PMASK2(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetMASK3_PMASK2() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetMASK3_PMASK3(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetMASK3_PMASK3() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetMASK3_PMASK4(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetMASK3_PMASK4() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetMASK3_PMASK5(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetMASK3_PMASK5() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetMASK3_PMASK6(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetMASK3_PMASK6() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetMASK3_PMASK7(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetMASK3_PMASK7() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetMASK3_PMASK8(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetMASK3_PMASK8() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetMASK3_PMASK9(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetMASK3_PMASK9() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetMASK3_PMASK10(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetMASK3_PMASK10() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetMASK3_PMASK11(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetMASK3_PMASK11() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetMASK3_PMASK12(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetMASK3_PMASK12() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetMASK3_PMASK13(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetMASK3_PMASK13() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetMASK3_PMASK14(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetMASK3_PMASK14() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetMASK3_PMASK15(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetMASK3_PMASK15() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetMASK3_PMASK16(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetMASK3_PMASK16() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetMASK3_PMASK17(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetMASK3_PMASK17() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetMASK3_PMASK18(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetMASK3_PMASK18() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetMASK3_PMASK19(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetMASK3_PMASK19() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetMASK3_PMASK20(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetMASK3_PMASK20() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetMASK3_PMASK21(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetMASK3_PMASK21() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetMASK3_PMASK22(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetMASK3_PMASK22() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetMASK3_PMASK23(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetMASK3_PMASK23() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetMASK3_PMASK24(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetMASK3_PMASK24() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetMASK3_PMASK25(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetMASK3_PMASK25() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetMASK3_PMASK26(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetMASK3_PMASK26() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetMASK3_PMASK27(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetMASK3_PMASK27() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetMASK3_PMASK28(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetMASK3_PMASK28() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetMASK3_PMASK29(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetMASK3_PMASK29() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetMASK3_PMASK30(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetMASK3_PMASK30() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetMASK3_PMASK31(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetMASK3_PMASK31() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0x80000000) >> 31
}

// GPIO.PIN3: Port Pin value register using MASK.
func (o *GPIO_Type) SetPIN3_VAL0(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetPIN3_VAL0() uint32 {
	return volatile.LoadUint32(&o.PIN3.Reg) & 0x1
}
func (o *GPIO_Type) SetPIN3_VAL1(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetPIN3_VAL1() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetPIN3_VAL2(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN3_VAL2() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN3_VAL3(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetPIN3_VAL3() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetPIN3_VAL4(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetPIN3_VAL4() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetPIN3_VAL5(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetPIN3_VAL5() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetPIN3_VAL6(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetPIN3_VAL6() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetPIN3_VAL7(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetPIN3_VAL7() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetPIN3_VAL8(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetPIN3_VAL8() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetPIN3_VAL9(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetPIN3_VAL9() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetPIN3_VAL10(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN3_VAL10() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN3_VAL11(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetPIN3_VAL11() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetPIN3_VAL12(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetPIN3_VAL12() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetPIN3_VAL13(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetPIN3_VAL13() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetPIN3_VAL14(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetPIN3_VAL14() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetPIN3_VAL15(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetPIN3_VAL15() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetPIN3_VAL16(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetPIN3_VAL16() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetPIN3_VAL17(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetPIN3_VAL17() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetPIN3_VAL18(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetPIN3_VAL18() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetPIN3_VAL19(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetPIN3_VAL19() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetPIN3_VAL20(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetPIN3_VAL20() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetPIN3_VAL21(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetPIN3_VAL21() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetPIN3_VAL22(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetPIN3_VAL22() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetPIN3_VAL23(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetPIN3_VAL23() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetPIN3_VAL24(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetPIN3_VAL24() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetPIN3_VAL25(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetPIN3_VAL25() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetPIN3_VAL26(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetPIN3_VAL26() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetPIN3_VAL27(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetPIN3_VAL27() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetPIN3_VAL28(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetPIN3_VAL28() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetPIN3_VAL29(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetPIN3_VAL29() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetPIN3_VAL30(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetPIN3_VAL30() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetPIN3_VAL31(value uint32) {
	volatile.StoreUint32(&o.PIN3.Reg, volatile.LoadUint32(&o.PIN3.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetPIN3_VAL31() uint32 {
	return (volatile.LoadUint32(&o.PIN3.Reg) & 0x80000000) >> 31
}

// GPIO.SET3: Port Output Set register using MASK.
func (o *GPIO_Type) SetSET3_PSET0(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetSET3_PSET0() uint32 {
	return volatile.LoadUint32(&o.SET3.Reg) & 0x1
}
func (o *GPIO_Type) SetSET3_PSET1(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetSET3_PSET1() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetSET3_PSET2(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetSET3_PSET2() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetSET3_PSET3(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetSET3_PSET3() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetSET3_PSET4(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetSET3_PSET4() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetSET3_PSET5(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetSET3_PSET5() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetSET3_PSET6(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetSET3_PSET6() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetSET3_PSET7(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetSET3_PSET7() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetSET3_PSET8(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetSET3_PSET8() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetSET3_PSET9(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetSET3_PSET9() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetSET3_PSET10(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetSET3_PSET10() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetSET3_PSET11(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetSET3_PSET11() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetSET3_PSET12(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetSET3_PSET12() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetSET3_PSET13(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetSET3_PSET13() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetSET3_PSET14(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetSET3_PSET14() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetSET3_PSET15(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetSET3_PSET15() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetSET3_PSET16(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetSET3_PSET16() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetSET3_PSET17(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetSET3_PSET17() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetSET3_PSET18(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetSET3_PSET18() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetSET3_PSET19(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetSET3_PSET19() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetSET3_PSET20(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetSET3_PSET20() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetSET3_PSET21(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetSET3_PSET21() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetSET3_PSET22(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetSET3_PSET22() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetSET3_PSET23(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetSET3_PSET23() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetSET3_PSET24(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetSET3_PSET24() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetSET3_PSET25(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetSET3_PSET25() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetSET3_PSET26(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetSET3_PSET26() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetSET3_PSET27(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetSET3_PSET27() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetSET3_PSET28(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetSET3_PSET28() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetSET3_PSET29(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetSET3_PSET29() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetSET3_PSET30(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetSET3_PSET30() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetSET3_PSET31(value uint32) {
	volatile.StoreUint32(&o.SET3.Reg, volatile.LoadUint32(&o.SET3.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetSET3_PSET31() uint32 {
	return (volatile.LoadUint32(&o.SET3.Reg) & 0x80000000) >> 31
}

// GPIO.CLR3: Port Output Clear register using MASK.
func (o *GPIO_Type) SetCLR3_PCLR0(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetCLR3_PCLR0() uint32 {
	return volatile.LoadUint32(&o.CLR3.Reg) & 0x1
}
func (o *GPIO_Type) SetCLR3_PCLR1(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetCLR3_PCLR1() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetCLR3_PCLR2(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetCLR3_PCLR2() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetCLR3_PCLR3(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetCLR3_PCLR3() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetCLR3_PCLR4(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetCLR3_PCLR4() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetCLR3_PCLR5(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetCLR3_PCLR5() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetCLR3_PCLR6(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetCLR3_PCLR6() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetCLR3_PCLR7(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetCLR3_PCLR7() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetCLR3_PCLR8(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetCLR3_PCLR8() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetCLR3_PCLR9(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetCLR3_PCLR9() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetCLR3_PCLR10(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetCLR3_PCLR10() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetCLR3_PCLR11(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetCLR3_PCLR11() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetCLR3_PCLR12(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetCLR3_PCLR12() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetCLR3_PCLR13(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetCLR3_PCLR13() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetCLR3_PCLR14(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetCLR3_PCLR14() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetCLR3_PCLR15(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetCLR3_PCLR15() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetCLR3_PCLR16(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetCLR3_PCLR16() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetCLR3_PCLR17(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetCLR3_PCLR17() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetCLR3_PCLR18(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetCLR3_PCLR18() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetCLR3_PCLR19(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetCLR3_PCLR19() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetCLR3_PCLR20(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetCLR3_PCLR20() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetCLR3_PCLR21(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetCLR3_PCLR21() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetCLR3_PCLR22(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetCLR3_PCLR22() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetCLR3_PCLR23(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetCLR3_PCLR23() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetCLR3_PCLR24(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetCLR3_PCLR24() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetCLR3_PCLR25(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetCLR3_PCLR25() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetCLR3_PCLR26(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetCLR3_PCLR26() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetCLR3_PCLR27(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetCLR3_PCLR27() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetCLR3_PCLR28(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetCLR3_PCLR28() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetCLR3_PCLR29(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetCLR3_PCLR29() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetCLR3_PCLR30(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetCLR3_PCLR30() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetCLR3_PCLR31(value uint32) {
	volatile.StoreUint32(&o.CLR3.Reg, volatile.LoadUint32(&o.CLR3.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetCLR3_PCLR31() uint32 {
	return (volatile.LoadUint32(&o.CLR3.Reg) & 0x80000000) >> 31
}

// GPIO.DIR4: GPIO Port Direction control register.
func (o *GPIO_Type) SetDIR4_PDIR0(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetDIR4_PDIR0() uint32 {
	return volatile.LoadUint32(&o.DIR4.Reg) & 0x1
}
func (o *GPIO_Type) SetDIR4_PDIR1(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetDIR4_PDIR1() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetDIR4_PDIR2(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetDIR4_PDIR2() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetDIR4_PDIR3(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetDIR4_PDIR3() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetDIR4_PDIR4(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetDIR4_PDIR4() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetDIR4_PDIR5(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetDIR4_PDIR5() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetDIR4_PDIR6(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetDIR4_PDIR6() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetDIR4_PDIR7(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetDIR4_PDIR7() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetDIR4_PDIR8(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetDIR4_PDIR8() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetDIR4_PDIR9(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetDIR4_PDIR9() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetDIR4_PDIR10(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetDIR4_PDIR10() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetDIR4_PDIR11(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetDIR4_PDIR11() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetDIR4_PDIR12(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetDIR4_PDIR12() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetDIR4_PDIR13(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetDIR4_PDIR13() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetDIR4_PDIR14(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetDIR4_PDIR14() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetDIR4_PDIR15(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetDIR4_PDIR15() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetDIR4_PDIR16(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetDIR4_PDIR16() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetDIR4_PDIR17(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetDIR4_PDIR17() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetDIR4_PDIR18(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetDIR4_PDIR18() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetDIR4_PDIR19(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetDIR4_PDIR19() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetDIR4_PDIR20(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetDIR4_PDIR20() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetDIR4_PDIR21(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetDIR4_PDIR21() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetDIR4_PDIR22(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetDIR4_PDIR22() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetDIR4_PDIR23(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetDIR4_PDIR23() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetDIR4_PDIR24(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetDIR4_PDIR24() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetDIR4_PDIR25(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetDIR4_PDIR25() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetDIR4_PDIR26(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetDIR4_PDIR26() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetDIR4_PDIR27(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetDIR4_PDIR27() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetDIR4_PDIR28(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetDIR4_PDIR28() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetDIR4_PDIR29(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetDIR4_PDIR29() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetDIR4_PDIR30(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetDIR4_PDIR30() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetDIR4_PDIR31(value uint32) {
	volatile.StoreUint32(&o.DIR4.Reg, volatile.LoadUint32(&o.DIR4.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetDIR4_PDIR31() uint32 {
	return (volatile.LoadUint32(&o.DIR4.Reg) & 0x80000000) >> 31
}

// GPIO.MASK4: Mask register for Port.
func (o *GPIO_Type) SetMASK4_PMASK0(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetMASK4_PMASK0() uint32 {
	return volatile.LoadUint32(&o.MASK4.Reg) & 0x1
}
func (o *GPIO_Type) SetMASK4_PMASK1(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetMASK4_PMASK1() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetMASK4_PMASK2(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetMASK4_PMASK2() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetMASK4_PMASK3(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetMASK4_PMASK3() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetMASK4_PMASK4(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetMASK4_PMASK4() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetMASK4_PMASK5(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetMASK4_PMASK5() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetMASK4_PMASK6(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetMASK4_PMASK6() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetMASK4_PMASK7(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetMASK4_PMASK7() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetMASK4_PMASK8(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetMASK4_PMASK8() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetMASK4_PMASK9(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetMASK4_PMASK9() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetMASK4_PMASK10(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetMASK4_PMASK10() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetMASK4_PMASK11(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetMASK4_PMASK11() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetMASK4_PMASK12(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetMASK4_PMASK12() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetMASK4_PMASK13(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetMASK4_PMASK13() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetMASK4_PMASK14(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetMASK4_PMASK14() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetMASK4_PMASK15(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetMASK4_PMASK15() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetMASK4_PMASK16(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetMASK4_PMASK16() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetMASK4_PMASK17(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetMASK4_PMASK17() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetMASK4_PMASK18(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetMASK4_PMASK18() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetMASK4_PMASK19(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetMASK4_PMASK19() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetMASK4_PMASK20(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetMASK4_PMASK20() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetMASK4_PMASK21(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetMASK4_PMASK21() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetMASK4_PMASK22(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetMASK4_PMASK22() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetMASK4_PMASK23(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetMASK4_PMASK23() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetMASK4_PMASK24(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetMASK4_PMASK24() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetMASK4_PMASK25(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetMASK4_PMASK25() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetMASK4_PMASK26(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetMASK4_PMASK26() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetMASK4_PMASK27(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetMASK4_PMASK27() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetMASK4_PMASK28(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetMASK4_PMASK28() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetMASK4_PMASK29(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetMASK4_PMASK29() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetMASK4_PMASK30(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetMASK4_PMASK30() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetMASK4_PMASK31(value uint32) {
	volatile.StoreUint32(&o.MASK4.Reg, volatile.LoadUint32(&o.MASK4.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetMASK4_PMASK31() uint32 {
	return (volatile.LoadUint32(&o.MASK4.Reg) & 0x80000000) >> 31
}

// GPIO.PIN4: Port Pin value register using MASK.
func (o *GPIO_Type) SetPIN4_VAL0(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetPIN4_VAL0() uint32 {
	return volatile.LoadUint32(&o.PIN4.Reg) & 0x1
}
func (o *GPIO_Type) SetPIN4_VAL1(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetPIN4_VAL1() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetPIN4_VAL2(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN4_VAL2() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN4_VAL3(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetPIN4_VAL3() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetPIN4_VAL4(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetPIN4_VAL4() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetPIN4_VAL5(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetPIN4_VAL5() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetPIN4_VAL6(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetPIN4_VAL6() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetPIN4_VAL7(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetPIN4_VAL7() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetPIN4_VAL8(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetPIN4_VAL8() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetPIN4_VAL9(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetPIN4_VAL9() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetPIN4_VAL10(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN4_VAL10() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN4_VAL11(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetPIN4_VAL11() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetPIN4_VAL12(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetPIN4_VAL12() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetPIN4_VAL13(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetPIN4_VAL13() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetPIN4_VAL14(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetPIN4_VAL14() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetPIN4_VAL15(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetPIN4_VAL15() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetPIN4_VAL16(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetPIN4_VAL16() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetPIN4_VAL17(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetPIN4_VAL17() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetPIN4_VAL18(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetPIN4_VAL18() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetPIN4_VAL19(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetPIN4_VAL19() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetPIN4_VAL20(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetPIN4_VAL20() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetPIN4_VAL21(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetPIN4_VAL21() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetPIN4_VAL22(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetPIN4_VAL22() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetPIN4_VAL23(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetPIN4_VAL23() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetPIN4_VAL24(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetPIN4_VAL24() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetPIN4_VAL25(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetPIN4_VAL25() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetPIN4_VAL26(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetPIN4_VAL26() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetPIN4_VAL27(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetPIN4_VAL27() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetPIN4_VAL28(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetPIN4_VAL28() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetPIN4_VAL29(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetPIN4_VAL29() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetPIN4_VAL30(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetPIN4_VAL30() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetPIN4_VAL31(value uint32) {
	volatile.StoreUint32(&o.PIN4.Reg, volatile.LoadUint32(&o.PIN4.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetPIN4_VAL31() uint32 {
	return (volatile.LoadUint32(&o.PIN4.Reg) & 0x80000000) >> 31
}

// GPIO.SET4: Port Output Set register using MASK.
func (o *GPIO_Type) SetSET4_PSET0(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetSET4_PSET0() uint32 {
	return volatile.LoadUint32(&o.SET4.Reg) & 0x1
}
func (o *GPIO_Type) SetSET4_PSET1(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetSET4_PSET1() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetSET4_PSET2(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetSET4_PSET2() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetSET4_PSET3(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetSET4_PSET3() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetSET4_PSET4(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetSET4_PSET4() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetSET4_PSET5(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetSET4_PSET5() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetSET4_PSET6(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetSET4_PSET6() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetSET4_PSET7(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetSET4_PSET7() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetSET4_PSET8(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetSET4_PSET8() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetSET4_PSET9(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetSET4_PSET9() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetSET4_PSET10(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetSET4_PSET10() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetSET4_PSET11(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetSET4_PSET11() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetSET4_PSET12(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetSET4_PSET12() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetSET4_PSET13(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetSET4_PSET13() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetSET4_PSET14(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetSET4_PSET14() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetSET4_PSET15(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetSET4_PSET15() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetSET4_PSET16(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetSET4_PSET16() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetSET4_PSET17(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetSET4_PSET17() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetSET4_PSET18(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetSET4_PSET18() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetSET4_PSET19(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetSET4_PSET19() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetSET4_PSET20(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetSET4_PSET20() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetSET4_PSET21(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetSET4_PSET21() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetSET4_PSET22(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetSET4_PSET22() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetSET4_PSET23(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetSET4_PSET23() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetSET4_PSET24(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetSET4_PSET24() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetSET4_PSET25(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetSET4_PSET25() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetSET4_PSET26(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetSET4_PSET26() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetSET4_PSET27(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetSET4_PSET27() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetSET4_PSET28(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetSET4_PSET28() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetSET4_PSET29(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetSET4_PSET29() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetSET4_PSET30(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetSET4_PSET30() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetSET4_PSET31(value uint32) {
	volatile.StoreUint32(&o.SET4.Reg, volatile.LoadUint32(&o.SET4.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetSET4_PSET31() uint32 {
	return (volatile.LoadUint32(&o.SET4.Reg) & 0x80000000) >> 31
}

// GPIO.CLR4: Port Output Clear register using MASK.
func (o *GPIO_Type) SetCLR4_PCLR0(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetCLR4_PCLR0() uint32 {
	return volatile.LoadUint32(&o.CLR4.Reg) & 0x1
}
func (o *GPIO_Type) SetCLR4_PCLR1(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetCLR4_PCLR1() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetCLR4_PCLR2(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetCLR4_PCLR2() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetCLR4_PCLR3(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetCLR4_PCLR3() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetCLR4_PCLR4(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetCLR4_PCLR4() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetCLR4_PCLR5(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetCLR4_PCLR5() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetCLR4_PCLR6(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetCLR4_PCLR6() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetCLR4_PCLR7(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetCLR4_PCLR7() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetCLR4_PCLR8(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetCLR4_PCLR8() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetCLR4_PCLR9(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetCLR4_PCLR9() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetCLR4_PCLR10(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetCLR4_PCLR10() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetCLR4_PCLR11(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetCLR4_PCLR11() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetCLR4_PCLR12(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetCLR4_PCLR12() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetCLR4_PCLR13(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetCLR4_PCLR13() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetCLR4_PCLR14(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetCLR4_PCLR14() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetCLR4_PCLR15(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetCLR4_PCLR15() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetCLR4_PCLR16(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetCLR4_PCLR16() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetCLR4_PCLR17(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetCLR4_PCLR17() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetCLR4_PCLR18(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetCLR4_PCLR18() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetCLR4_PCLR19(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetCLR4_PCLR19() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetCLR4_PCLR20(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetCLR4_PCLR20() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetCLR4_PCLR21(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetCLR4_PCLR21() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetCLR4_PCLR22(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetCLR4_PCLR22() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetCLR4_PCLR23(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetCLR4_PCLR23() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetCLR4_PCLR24(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetCLR4_PCLR24() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetCLR4_PCLR25(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetCLR4_PCLR25() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetCLR4_PCLR26(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetCLR4_PCLR26() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetCLR4_PCLR27(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetCLR4_PCLR27() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetCLR4_PCLR28(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetCLR4_PCLR28() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetCLR4_PCLR29(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetCLR4_PCLR29() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetCLR4_PCLR30(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetCLR4_PCLR30() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetCLR4_PCLR31(value uint32) {
	volatile.StoreUint32(&o.CLR4.Reg, volatile.LoadUint32(&o.CLR4.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetCLR4_PCLR31() uint32 {
	return (volatile.LoadUint32(&o.CLR4.Reg) & 0x80000000) >> 31
}

// GPIO.DIR5: GPIO Port Direction control register.
func (o *GPIO_Type) SetDIR5_PDIR0(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetDIR5_PDIR0() uint32 {
	return volatile.LoadUint32(&o.DIR5.Reg) & 0x1
}
func (o *GPIO_Type) SetDIR5_PDIR1(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetDIR5_PDIR1() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetDIR5_PDIR2(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetDIR5_PDIR2() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetDIR5_PDIR3(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetDIR5_PDIR3() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetDIR5_PDIR4(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetDIR5_PDIR4() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetDIR5_PDIR5(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetDIR5_PDIR5() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetDIR5_PDIR6(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetDIR5_PDIR6() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetDIR5_PDIR7(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetDIR5_PDIR7() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetDIR5_PDIR8(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetDIR5_PDIR8() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetDIR5_PDIR9(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetDIR5_PDIR9() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetDIR5_PDIR10(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetDIR5_PDIR10() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetDIR5_PDIR11(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetDIR5_PDIR11() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetDIR5_PDIR12(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetDIR5_PDIR12() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetDIR5_PDIR13(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetDIR5_PDIR13() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetDIR5_PDIR14(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetDIR5_PDIR14() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetDIR5_PDIR15(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetDIR5_PDIR15() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetDIR5_PDIR16(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetDIR5_PDIR16() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetDIR5_PDIR17(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetDIR5_PDIR17() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetDIR5_PDIR18(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetDIR5_PDIR18() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetDIR5_PDIR19(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetDIR5_PDIR19() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetDIR5_PDIR20(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetDIR5_PDIR20() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetDIR5_PDIR21(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetDIR5_PDIR21() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetDIR5_PDIR22(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetDIR5_PDIR22() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetDIR5_PDIR23(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetDIR5_PDIR23() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetDIR5_PDIR24(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetDIR5_PDIR24() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetDIR5_PDIR25(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetDIR5_PDIR25() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetDIR5_PDIR26(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetDIR5_PDIR26() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetDIR5_PDIR27(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetDIR5_PDIR27() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetDIR5_PDIR28(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetDIR5_PDIR28() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetDIR5_PDIR29(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetDIR5_PDIR29() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetDIR5_PDIR30(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetDIR5_PDIR30() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetDIR5_PDIR31(value uint32) {
	volatile.StoreUint32(&o.DIR5.Reg, volatile.LoadUint32(&o.DIR5.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetDIR5_PDIR31() uint32 {
	return (volatile.LoadUint32(&o.DIR5.Reg) & 0x80000000) >> 31
}

// GPIO.MASK5: Mask register for Port.
func (o *GPIO_Type) SetMASK5_PMASK0(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetMASK5_PMASK0() uint32 {
	return volatile.LoadUint32(&o.MASK5.Reg) & 0x1
}
func (o *GPIO_Type) SetMASK5_PMASK1(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetMASK5_PMASK1() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetMASK5_PMASK2(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetMASK5_PMASK2() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetMASK5_PMASK3(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetMASK5_PMASK3() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetMASK5_PMASK4(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetMASK5_PMASK4() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetMASK5_PMASK5(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetMASK5_PMASK5() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetMASK5_PMASK6(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetMASK5_PMASK6() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetMASK5_PMASK7(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetMASK5_PMASK7() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetMASK5_PMASK8(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetMASK5_PMASK8() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetMASK5_PMASK9(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetMASK5_PMASK9() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetMASK5_PMASK10(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetMASK5_PMASK10() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetMASK5_PMASK11(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetMASK5_PMASK11() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetMASK5_PMASK12(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetMASK5_PMASK12() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetMASK5_PMASK13(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetMASK5_PMASK13() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetMASK5_PMASK14(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetMASK5_PMASK14() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetMASK5_PMASK15(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetMASK5_PMASK15() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetMASK5_PMASK16(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetMASK5_PMASK16() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetMASK5_PMASK17(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetMASK5_PMASK17() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetMASK5_PMASK18(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetMASK5_PMASK18() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetMASK5_PMASK19(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetMASK5_PMASK19() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetMASK5_PMASK20(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetMASK5_PMASK20() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetMASK5_PMASK21(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetMASK5_PMASK21() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetMASK5_PMASK22(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetMASK5_PMASK22() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetMASK5_PMASK23(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetMASK5_PMASK23() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetMASK5_PMASK24(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetMASK5_PMASK24() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetMASK5_PMASK25(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetMASK5_PMASK25() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetMASK5_PMASK26(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetMASK5_PMASK26() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetMASK5_PMASK27(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetMASK5_PMASK27() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetMASK5_PMASK28(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetMASK5_PMASK28() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetMASK5_PMASK29(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetMASK5_PMASK29() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetMASK5_PMASK30(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetMASK5_PMASK30() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetMASK5_PMASK31(value uint32) {
	volatile.StoreUint32(&o.MASK5.Reg, volatile.LoadUint32(&o.MASK5.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetMASK5_PMASK31() uint32 {
	return (volatile.LoadUint32(&o.MASK5.Reg) & 0x80000000) >> 31
}

// GPIO.PIN5: Port Pin value register using MASK.
func (o *GPIO_Type) SetPIN5_VAL0(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetPIN5_VAL0() uint32 {
	return volatile.LoadUint32(&o.PIN5.Reg) & 0x1
}
func (o *GPIO_Type) SetPIN5_VAL1(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetPIN5_VAL1() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetPIN5_VAL2(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetPIN5_VAL2() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetPIN5_VAL3(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetPIN5_VAL3() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetPIN5_VAL4(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetPIN5_VAL4() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetPIN5_VAL5(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetPIN5_VAL5() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetPIN5_VAL6(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetPIN5_VAL6() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetPIN5_VAL7(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetPIN5_VAL7() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetPIN5_VAL8(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetPIN5_VAL8() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetPIN5_VAL9(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetPIN5_VAL9() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetPIN5_VAL10(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetPIN5_VAL10() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetPIN5_VAL11(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetPIN5_VAL11() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetPIN5_VAL12(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetPIN5_VAL12() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetPIN5_VAL13(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetPIN5_VAL13() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetPIN5_VAL14(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetPIN5_VAL14() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetPIN5_VAL15(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetPIN5_VAL15() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetPIN5_VAL16(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetPIN5_VAL16() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetPIN5_VAL17(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetPIN5_VAL17() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetPIN5_VAL18(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetPIN5_VAL18() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetPIN5_VAL19(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetPIN5_VAL19() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetPIN5_VAL20(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetPIN5_VAL20() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetPIN5_VAL21(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetPIN5_VAL21() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetPIN5_VAL22(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetPIN5_VAL22() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetPIN5_VAL23(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetPIN5_VAL23() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetPIN5_VAL24(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetPIN5_VAL24() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetPIN5_VAL25(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetPIN5_VAL25() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetPIN5_VAL26(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetPIN5_VAL26() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetPIN5_VAL27(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetPIN5_VAL27() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetPIN5_VAL28(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetPIN5_VAL28() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetPIN5_VAL29(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetPIN5_VAL29() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetPIN5_VAL30(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetPIN5_VAL30() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetPIN5_VAL31(value uint32) {
	volatile.StoreUint32(&o.PIN5.Reg, volatile.LoadUint32(&o.PIN5.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetPIN5_VAL31() uint32 {
	return (volatile.LoadUint32(&o.PIN5.Reg) & 0x80000000) >> 31
}

// GPIO.SET5: Port Output Set register using MASK.
func (o *GPIO_Type) SetSET5_PSET0(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetSET5_PSET0() uint32 {
	return volatile.LoadUint32(&o.SET5.Reg) & 0x1
}
func (o *GPIO_Type) SetSET5_PSET1(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetSET5_PSET1() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetSET5_PSET2(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetSET5_PSET2() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetSET5_PSET3(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetSET5_PSET3() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetSET5_PSET4(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetSET5_PSET4() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetSET5_PSET5(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetSET5_PSET5() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetSET5_PSET6(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetSET5_PSET6() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetSET5_PSET7(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetSET5_PSET7() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetSET5_PSET8(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetSET5_PSET8() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetSET5_PSET9(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetSET5_PSET9() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetSET5_PSET10(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetSET5_PSET10() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetSET5_PSET11(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetSET5_PSET11() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetSET5_PSET12(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetSET5_PSET12() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetSET5_PSET13(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetSET5_PSET13() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetSET5_PSET14(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetSET5_PSET14() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetSET5_PSET15(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetSET5_PSET15() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetSET5_PSET16(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetSET5_PSET16() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetSET5_PSET17(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetSET5_PSET17() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetSET5_PSET18(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetSET5_PSET18() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetSET5_PSET19(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetSET5_PSET19() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetSET5_PSET20(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetSET5_PSET20() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetSET5_PSET21(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetSET5_PSET21() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetSET5_PSET22(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetSET5_PSET22() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetSET5_PSET23(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetSET5_PSET23() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetSET5_PSET24(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetSET5_PSET24() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetSET5_PSET25(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetSET5_PSET25() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetSET5_PSET26(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetSET5_PSET26() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetSET5_PSET27(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetSET5_PSET27() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetSET5_PSET28(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetSET5_PSET28() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetSET5_PSET29(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetSET5_PSET29() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetSET5_PSET30(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetSET5_PSET30() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetSET5_PSET31(value uint32) {
	volatile.StoreUint32(&o.SET5.Reg, volatile.LoadUint32(&o.SET5.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetSET5_PSET31() uint32 {
	return (volatile.LoadUint32(&o.SET5.Reg) & 0x80000000) >> 31
}

// GPIO.CLR5: Port Output Clear register using MASK.
func (o *GPIO_Type) SetCLR5_PCLR0(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetCLR5_PCLR0() uint32 {
	return volatile.LoadUint32(&o.CLR5.Reg) & 0x1
}
func (o *GPIO_Type) SetCLR5_PCLR1(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetCLR5_PCLR1() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetCLR5_PCLR2(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetCLR5_PCLR2() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetCLR5_PCLR3(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetCLR5_PCLR3() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetCLR5_PCLR4(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetCLR5_PCLR4() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetCLR5_PCLR5(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetCLR5_PCLR5() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetCLR5_PCLR6(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetCLR5_PCLR6() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetCLR5_PCLR7(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetCLR5_PCLR7() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetCLR5_PCLR8(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetCLR5_PCLR8() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetCLR5_PCLR9(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetCLR5_PCLR9() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetCLR5_PCLR10(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetCLR5_PCLR10() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetCLR5_PCLR11(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetCLR5_PCLR11() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetCLR5_PCLR12(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x1000)|value<<12)
}
func (o *GPIO_Type) GetCLR5_PCLR12() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x1000) >> 12
}
func (o *GPIO_Type) SetCLR5_PCLR13(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x2000)|value<<13)
}
func (o *GPIO_Type) GetCLR5_PCLR13() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x2000) >> 13
}
func (o *GPIO_Type) SetCLR5_PCLR14(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x4000)|value<<14)
}
func (o *GPIO_Type) GetCLR5_PCLR14() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x4000) >> 14
}
func (o *GPIO_Type) SetCLR5_PCLR15(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x8000)|value<<15)
}
func (o *GPIO_Type) GetCLR5_PCLR15() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x8000) >> 15
}
func (o *GPIO_Type) SetCLR5_PCLR16(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x10000)|value<<16)
}
func (o *GPIO_Type) GetCLR5_PCLR16() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x10000) >> 16
}
func (o *GPIO_Type) SetCLR5_PCLR17(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x20000)|value<<17)
}
func (o *GPIO_Type) GetCLR5_PCLR17() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x20000) >> 17
}
func (o *GPIO_Type) SetCLR5_PCLR18(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x40000)|value<<18)
}
func (o *GPIO_Type) GetCLR5_PCLR18() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x40000) >> 18
}
func (o *GPIO_Type) SetCLR5_PCLR19(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x80000)|value<<19)
}
func (o *GPIO_Type) GetCLR5_PCLR19() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x80000) >> 19
}
func (o *GPIO_Type) SetCLR5_PCLR20(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x100000)|value<<20)
}
func (o *GPIO_Type) GetCLR5_PCLR20() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x100000) >> 20
}
func (o *GPIO_Type) SetCLR5_PCLR21(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x200000)|value<<21)
}
func (o *GPIO_Type) GetCLR5_PCLR21() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x200000) >> 21
}
func (o *GPIO_Type) SetCLR5_PCLR22(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x400000)|value<<22)
}
func (o *GPIO_Type) GetCLR5_PCLR22() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x400000) >> 22
}
func (o *GPIO_Type) SetCLR5_PCLR23(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x800000)|value<<23)
}
func (o *GPIO_Type) GetCLR5_PCLR23() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x800000) >> 23
}
func (o *GPIO_Type) SetCLR5_PCLR24(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIO_Type) GetCLR5_PCLR24() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x1000000) >> 24
}
func (o *GPIO_Type) SetCLR5_PCLR25(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIO_Type) GetCLR5_PCLR25() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x2000000) >> 25
}
func (o *GPIO_Type) SetCLR5_PCLR26(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIO_Type) GetCLR5_PCLR26() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x4000000) >> 26
}
func (o *GPIO_Type) SetCLR5_PCLR27(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIO_Type) GetCLR5_PCLR27() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x8000000) >> 27
}
func (o *GPIO_Type) SetCLR5_PCLR28(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIO_Type) GetCLR5_PCLR28() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x10000000) >> 28
}
func (o *GPIO_Type) SetCLR5_PCLR29(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIO_Type) GetCLR5_PCLR29() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x20000000) >> 29
}
func (o *GPIO_Type) SetCLR5_PCLR30(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIO_Type) GetCLR5_PCLR30() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x40000000) >> 30
}
func (o *GPIO_Type) SetCLR5_PCLR31(value uint32) {
	volatile.StoreUint32(&o.CLR5.Reg, volatile.LoadUint32(&o.CLR5.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIO_Type) GetCLR5_PCLR31() uint32 {
	return (volatile.LoadUint32(&o.CLR5.Reg) & 0x80000000) >> 31
}

// External Memory Controller (EMC)
type EMC_Type struct {
	CONTROL            volatile.Register32 // 0x0
	STATUS             volatile.Register32 // 0x4
	CONFIG             volatile.Register32 // 0x8
	_                  [20]byte
	DYNAMICCONTROL     volatile.Register32 // 0x20
	DYNAMICREFRESH     volatile.Register32 // 0x24
	DYNAMICREADCONFIG  volatile.Register32 // 0x28
	_                  [4]byte
	DYNAMICRP          volatile.Register32 // 0x30
	DYNAMICRAS         volatile.Register32 // 0x34
	DYNAMICSREX        volatile.Register32 // 0x38
	DYNAMICAPR         volatile.Register32 // 0x3C
	DYNAMICDAL         volatile.Register32 // 0x40
	DYNAMICWR          volatile.Register32 // 0x44
	DYNAMICRC          volatile.Register32 // 0x48
	DYNAMICRFC         volatile.Register32 // 0x4C
	DYNAMICXSR         volatile.Register32 // 0x50
	DYNAMICRRD         volatile.Register32 // 0x54
	DYNAMICMRD         volatile.Register32 // 0x58
	_                  [36]byte
	STATICEXTENDEDWAIT volatile.Register32 // 0x80
	_                  [124]byte
	DYNAMICCONFIG0     volatile.Register32 // 0x100
	DYNAMICRASCAS0     volatile.Register32 // 0x104
	_                  [24]byte
	DYNAMICCONFIG1     volatile.Register32 // 0x120
	DYNAMICRASCAS1     volatile.Register32 // 0x124
	_                  [24]byte
	DYNAMICCONFIG2     volatile.Register32 // 0x140
	DYNAMICRASCAS2     volatile.Register32 // 0x144
	_                  [24]byte
	DYNAMICCONFIG3     volatile.Register32 // 0x160
	DYNAMICRASCAS3     volatile.Register32 // 0x164
	_                  [152]byte
	STATICCONFIG0      volatile.Register32 // 0x200
	STATICWAITWEN0     volatile.Register32 // 0x204
	STATICWAITOEN0     volatile.Register32 // 0x208
	STATICWAITRD0      volatile.Register32 // 0x20C
	STATICWAITPAGE0    volatile.Register32 // 0x210
	STATICWAITWR0      volatile.Register32 // 0x214
	STATICWAITTURN0    volatile.Register32 // 0x218
	_                  [4]byte
	STATICCONFIG1      volatile.Register32 // 0x220
	STATICWAITWEN1     volatile.Register32 // 0x224
	STATICWAITOEN1     volatile.Register32 // 0x228
	STATICWAITRD1      volatile.Register32 // 0x22C
	STATICWAITPAGE1    volatile.Register32 // 0x230
	STATICWAITWR1      volatile.Register32 // 0x234
	STATICWAITTURN1    volatile.Register32 // 0x238
	_                  [4]byte
	STATICCONFIG2      volatile.Register32 // 0x240
	STATICWAITWEN2     volatile.Register32 // 0x244
	STATICWAITOEN2     volatile.Register32 // 0x248
	STATICWAITRD2      volatile.Register32 // 0x24C
	STATICWAITPAGE2    volatile.Register32 // 0x250
	STATICWAITWR2      volatile.Register32 // 0x254
	STATICWAITTURN2    volatile.Register32 // 0x258
	_                  [4]byte
	STATICCONFIG3      volatile.Register32 // 0x260
	STATICWAITWEN3     volatile.Register32 // 0x264
	STATICWAITOEN3     volatile.Register32 // 0x268
	STATICWAITRD3      volatile.Register32 // 0x26C
	STATICWAITPAGE3    volatile.Register32 // 0x270
	STATICWAITWR3      volatile.Register32 // 0x274
	STATICWAITTURN3    volatile.Register32 // 0x278
}

// EMC.CONTROL: Controls operation of the memory controller.
func (o *EMC_Type) SetCONTROL_E(value uint32) {
	volatile.StoreUint32(&o.CONTROL.Reg, volatile.LoadUint32(&o.CONTROL.Reg)&^(0x1)|value)
}
func (o *EMC_Type) GetCONTROL_E() uint32 {
	return volatile.LoadUint32(&o.CONTROL.Reg) & 0x1
}
func (o *EMC_Type) SetCONTROL_M(value uint32) {
	volatile.StoreUint32(&o.CONTROL.Reg, volatile.LoadUint32(&o.CONTROL.Reg)&^(0x2)|value<<1)
}
func (o *EMC_Type) GetCONTROL_M() uint32 {
	return (volatile.LoadUint32(&o.CONTROL.Reg) & 0x2) >> 1
}
func (o *EMC_Type) SetCONTROL_L(value uint32) {
	volatile.StoreUint32(&o.CONTROL.Reg, volatile.LoadUint32(&o.CONTROL.Reg)&^(0x4)|value<<2)
}
func (o *EMC_Type) GetCONTROL_L() uint32 {
	return (volatile.LoadUint32(&o.CONTROL.Reg) & 0x4) >> 2
}
func (o *EMC_Type) SetCONTROL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONTROL.Reg, volatile.LoadUint32(&o.CONTROL.Reg)&^(0xfffffff8)|value<<3)
}
func (o *EMC_Type) GetCONTROL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONTROL.Reg) & 0xfffffff8) >> 3
}

// EMC.STATUS: Provides EMC status information.
func (o *EMC_Type) SetSTATUS_B(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *EMC_Type) GetSTATUS_B() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1
}
func (o *EMC_Type) SetSTATUS_S(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *EMC_Type) GetSTATUS_S() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *EMC_Type) SetSTATUS_SA(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x4)|value<<2)
}
func (o *EMC_Type) GetSTATUS_SA() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x4) >> 2
}
func (o *EMC_Type) SetSTATUS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0xfffffff8)|value<<3)
}
func (o *EMC_Type) GetSTATUS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0xfffffff8) >> 3
}

// EMC.CONFIG: Configures operation of the memory controller
func (o *EMC_Type) SetCONFIG_EM(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x1)|value)
}
func (o *EMC_Type) GetCONFIG_EM() uint32 {
	return volatile.LoadUint32(&o.CONFIG.Reg) & 0x1
}
func (o *EMC_Type) SetCONFIG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0xfe)|value<<1)
}
func (o *EMC_Type) GetCONFIG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0xfe) >> 1
}
func (o *EMC_Type) SetCONFIG_CLKR(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0x100)|value<<8)
}
func (o *EMC_Type) GetCONFIG_CLKR() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0x100) >> 8
}
func (o *EMC_Type) SetCONFIG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONFIG.Reg, volatile.LoadUint32(&o.CONFIG.Reg)&^(0xfffffe00)|value<<9)
}
func (o *EMC_Type) GetCONFIG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONFIG.Reg) & 0xfffffe00) >> 9
}

// EMC.DYNAMICCONTROL: Controls dynamic memory operation.
func (o *EMC_Type) SetDYNAMICCONTROL_CE(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONTROL.Reg, volatile.LoadUint32(&o.DYNAMICCONTROL.Reg)&^(0x1)|value)
}
func (o *EMC_Type) GetDYNAMICCONTROL_CE() uint32 {
	return volatile.LoadUint32(&o.DYNAMICCONTROL.Reg) & 0x1
}
func (o *EMC_Type) SetDYNAMICCONTROL_CS(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONTROL.Reg, volatile.LoadUint32(&o.DYNAMICCONTROL.Reg)&^(0x2)|value<<1)
}
func (o *EMC_Type) GetDYNAMICCONTROL_CS() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONTROL.Reg) & 0x2) >> 1
}
func (o *EMC_Type) SetDYNAMICCONTROL_SR(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONTROL.Reg, volatile.LoadUint32(&o.DYNAMICCONTROL.Reg)&^(0x4)|value<<2)
}
func (o *EMC_Type) GetDYNAMICCONTROL_SR() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONTROL.Reg) & 0x4) >> 2
}
func (o *EMC_Type) SetDYNAMICCONTROL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONTROL.Reg, volatile.LoadUint32(&o.DYNAMICCONTROL.Reg)&^(0x18)|value<<3)
}
func (o *EMC_Type) GetDYNAMICCONTROL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONTROL.Reg) & 0x18) >> 3
}
func (o *EMC_Type) SetDYNAMICCONTROL_MMC(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONTROL.Reg, volatile.LoadUint32(&o.DYNAMICCONTROL.Reg)&^(0x20)|value<<5)
}
func (o *EMC_Type) GetDYNAMICCONTROL_MMC() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONTROL.Reg) & 0x20) >> 5
}
func (o *EMC_Type) SetDYNAMICCONTROL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONTROL.Reg, volatile.LoadUint32(&o.DYNAMICCONTROL.Reg)&^(0x40)|value<<6)
}
func (o *EMC_Type) GetDYNAMICCONTROL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONTROL.Reg) & 0x40) >> 6
}
func (o *EMC_Type) SetDYNAMICCONTROL_I(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONTROL.Reg, volatile.LoadUint32(&o.DYNAMICCONTROL.Reg)&^(0x180)|value<<7)
}
func (o *EMC_Type) GetDYNAMICCONTROL_I() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONTROL.Reg) & 0x180) >> 7
}
func (o *EMC_Type) SetDYNAMICCONTROL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONTROL.Reg, volatile.LoadUint32(&o.DYNAMICCONTROL.Reg)&^(0x3e00)|value<<9)
}
func (o *EMC_Type) GetDYNAMICCONTROL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONTROL.Reg) & 0x3e00) >> 9
}
func (o *EMC_Type) SetDYNAMICCONTROL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONTROL.Reg, volatile.LoadUint32(&o.DYNAMICCONTROL.Reg)&^(0xffffc000)|value<<14)
}
func (o *EMC_Type) GetDYNAMICCONTROL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONTROL.Reg) & 0xffffc000) >> 14
}

// EMC.DYNAMICREFRESH: Configures dynamic memory refresh.
func (o *EMC_Type) SetDYNAMICREFRESH_REFRESH(value uint32) {
	volatile.StoreUint32(&o.DYNAMICREFRESH.Reg, volatile.LoadUint32(&o.DYNAMICREFRESH.Reg)&^(0x7ff)|value)
}
func (o *EMC_Type) GetDYNAMICREFRESH_REFRESH() uint32 {
	return volatile.LoadUint32(&o.DYNAMICREFRESH.Reg) & 0x7ff
}
func (o *EMC_Type) SetDYNAMICREFRESH_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICREFRESH.Reg, volatile.LoadUint32(&o.DYNAMICREFRESH.Reg)&^(0xfffff800)|value<<11)
}
func (o *EMC_Type) GetDYNAMICREFRESH_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICREFRESH.Reg) & 0xfffff800) >> 11
}

// EMC.DYNAMICREADCONFIG: Configures dynamic memory read strategy.
func (o *EMC_Type) SetDYNAMICREADCONFIG_RD(value uint32) {
	volatile.StoreUint32(&o.DYNAMICREADCONFIG.Reg, volatile.LoadUint32(&o.DYNAMICREADCONFIG.Reg)&^(0x3)|value)
}
func (o *EMC_Type) GetDYNAMICREADCONFIG_RD() uint32 {
	return volatile.LoadUint32(&o.DYNAMICREADCONFIG.Reg) & 0x3
}
func (o *EMC_Type) SetDYNAMICREADCONFIG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICREADCONFIG.Reg, volatile.LoadUint32(&o.DYNAMICREADCONFIG.Reg)&^(0xfffffffc)|value<<2)
}
func (o *EMC_Type) GetDYNAMICREADCONFIG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICREADCONFIG.Reg) & 0xfffffffc) >> 2
}

// EMC.DYNAMICRP: Precharge command period.
func (o *EMC_Type) SetDYNAMICRP_TRP(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRP.Reg, volatile.LoadUint32(&o.DYNAMICRP.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetDYNAMICRP_TRP() uint32 {
	return volatile.LoadUint32(&o.DYNAMICRP.Reg) & 0xf
}
func (o *EMC_Type) SetDYNAMICRP_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRP.Reg, volatile.LoadUint32(&o.DYNAMICRP.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetDYNAMICRP_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRP.Reg) & 0xfffffff0) >> 4
}

// EMC.DYNAMICRAS: Active to precharge command period.
func (o *EMC_Type) SetDYNAMICRAS_TRAS(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRAS.Reg, volatile.LoadUint32(&o.DYNAMICRAS.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetDYNAMICRAS_TRAS() uint32 {
	return volatile.LoadUint32(&o.DYNAMICRAS.Reg) & 0xf
}
func (o *EMC_Type) SetDYNAMICRAS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRAS.Reg, volatile.LoadUint32(&o.DYNAMICRAS.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetDYNAMICRAS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRAS.Reg) & 0xfffffff0) >> 4
}

// EMC.DYNAMICSREX: Self-refresh exit time.
func (o *EMC_Type) SetDYNAMICSREX_TSREX(value uint32) {
	volatile.StoreUint32(&o.DYNAMICSREX.Reg, volatile.LoadUint32(&o.DYNAMICSREX.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetDYNAMICSREX_TSREX() uint32 {
	return volatile.LoadUint32(&o.DYNAMICSREX.Reg) & 0xf
}
func (o *EMC_Type) SetDYNAMICSREX_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICSREX.Reg, volatile.LoadUint32(&o.DYNAMICSREX.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetDYNAMICSREX_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICSREX.Reg) & 0xfffffff0) >> 4
}

// EMC.DYNAMICAPR: Last-data-out to active command time.
func (o *EMC_Type) SetDYNAMICAPR_TAPR(value uint32) {
	volatile.StoreUint32(&o.DYNAMICAPR.Reg, volatile.LoadUint32(&o.DYNAMICAPR.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetDYNAMICAPR_TAPR() uint32 {
	return volatile.LoadUint32(&o.DYNAMICAPR.Reg) & 0xf
}
func (o *EMC_Type) SetDYNAMICAPR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICAPR.Reg, volatile.LoadUint32(&o.DYNAMICAPR.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetDYNAMICAPR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICAPR.Reg) & 0xfffffff0) >> 4
}

// EMC.DYNAMICDAL: Data-in to active command time.
func (o *EMC_Type) SetDYNAMICDAL_TDAL(value uint32) {
	volatile.StoreUint32(&o.DYNAMICDAL.Reg, volatile.LoadUint32(&o.DYNAMICDAL.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetDYNAMICDAL_TDAL() uint32 {
	return volatile.LoadUint32(&o.DYNAMICDAL.Reg) & 0xf
}
func (o *EMC_Type) SetDYNAMICDAL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICDAL.Reg, volatile.LoadUint32(&o.DYNAMICDAL.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetDYNAMICDAL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICDAL.Reg) & 0xfffffff0) >> 4
}

// EMC.DYNAMICWR: Write recovery time.
func (o *EMC_Type) SetDYNAMICWR_TWR(value uint32) {
	volatile.StoreUint32(&o.DYNAMICWR.Reg, volatile.LoadUint32(&o.DYNAMICWR.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetDYNAMICWR_TWR() uint32 {
	return volatile.LoadUint32(&o.DYNAMICWR.Reg) & 0xf
}
func (o *EMC_Type) SetDYNAMICWR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICWR.Reg, volatile.LoadUint32(&o.DYNAMICWR.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetDYNAMICWR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICWR.Reg) & 0xfffffff0) >> 4
}

// EMC.DYNAMICRC: Selects the active to active command period.
func (o *EMC_Type) SetDYNAMICRC_TRC(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRC.Reg, volatile.LoadUint32(&o.DYNAMICRC.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetDYNAMICRC_TRC() uint32 {
	return volatile.LoadUint32(&o.DYNAMICRC.Reg) & 0x1f
}
func (o *EMC_Type) SetDYNAMICRC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRC.Reg, volatile.LoadUint32(&o.DYNAMICRC.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetDYNAMICRC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRC.Reg) & 0xffffffe0) >> 5
}

// EMC.DYNAMICRFC: Selects the auto-refresh period.
func (o *EMC_Type) SetDYNAMICRFC_TRFC(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRFC.Reg, volatile.LoadUint32(&o.DYNAMICRFC.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetDYNAMICRFC_TRFC() uint32 {
	return volatile.LoadUint32(&o.DYNAMICRFC.Reg) & 0x1f
}
func (o *EMC_Type) SetDYNAMICRFC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRFC.Reg, volatile.LoadUint32(&o.DYNAMICRFC.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetDYNAMICRFC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRFC.Reg) & 0xffffffe0) >> 5
}

// EMC.DYNAMICXSR: Time for exit self-refresh to active command.
func (o *EMC_Type) SetDYNAMICXSR_TXSR(value uint32) {
	volatile.StoreUint32(&o.DYNAMICXSR.Reg, volatile.LoadUint32(&o.DYNAMICXSR.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetDYNAMICXSR_TXSR() uint32 {
	return volatile.LoadUint32(&o.DYNAMICXSR.Reg) & 0x1f
}
func (o *EMC_Type) SetDYNAMICXSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICXSR.Reg, volatile.LoadUint32(&o.DYNAMICXSR.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetDYNAMICXSR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICXSR.Reg) & 0xffffffe0) >> 5
}

// EMC.DYNAMICRRD: Latency for active bank A to active bank B.
func (o *EMC_Type) SetDYNAMICRRD_TRRD(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRRD.Reg, volatile.LoadUint32(&o.DYNAMICRRD.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetDYNAMICRRD_TRRD() uint32 {
	return volatile.LoadUint32(&o.DYNAMICRRD.Reg) & 0xf
}
func (o *EMC_Type) SetDYNAMICRRD_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRRD.Reg, volatile.LoadUint32(&o.DYNAMICRRD.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetDYNAMICRRD_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRRD.Reg) & 0xfffffff0) >> 4
}

// EMC.DYNAMICMRD: Time for load mode register to active command.
func (o *EMC_Type) SetDYNAMICMRD_TMRD(value uint32) {
	volatile.StoreUint32(&o.DYNAMICMRD.Reg, volatile.LoadUint32(&o.DYNAMICMRD.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetDYNAMICMRD_TMRD() uint32 {
	return volatile.LoadUint32(&o.DYNAMICMRD.Reg) & 0xf
}
func (o *EMC_Type) SetDYNAMICMRD_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICMRD.Reg, volatile.LoadUint32(&o.DYNAMICMRD.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetDYNAMICMRD_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICMRD.Reg) & 0xfffffff0) >> 4
}

// EMC.STATICEXTENDEDWAIT: Time for long static memory read and write transfers.
func (o *EMC_Type) SetSTATICEXTENDEDWAIT_EXTENDEDWAIT(value uint32) {
	volatile.StoreUint32(&o.STATICEXTENDEDWAIT.Reg, volatile.LoadUint32(&o.STATICEXTENDEDWAIT.Reg)&^(0x3ff)|value)
}
func (o *EMC_Type) GetSTATICEXTENDEDWAIT_EXTENDEDWAIT() uint32 {
	return volatile.LoadUint32(&o.STATICEXTENDEDWAIT.Reg) & 0x3ff
}
func (o *EMC_Type) SetSTATICEXTENDEDWAIT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICEXTENDEDWAIT.Reg, volatile.LoadUint32(&o.STATICEXTENDEDWAIT.Reg)&^(0xfffffc00)|value<<10)
}
func (o *EMC_Type) GetSTATICEXTENDEDWAIT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICEXTENDEDWAIT.Reg) & 0xfffffc00) >> 10
}

// EMC.DYNAMICCONFIG0: Configuration information for EMC_DYCS0.
func (o *EMC_Type) SetDYNAMICCONFIG0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG0.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg)&^(0x7)|value)
}
func (o *EMC_Type) GetDYNAMICCONFIG0_RESERVED() uint32 {
	return volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg) & 0x7
}
func (o *EMC_Type) SetDYNAMICCONFIG0_MD(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG0.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg)&^(0x18)|value<<3)
}
func (o *EMC_Type) GetDYNAMICCONFIG0_MD() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg) & 0x18) >> 3
}
func (o *EMC_Type) SetDYNAMICCONFIG0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG0.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg)&^(0x60)|value<<5)
}
func (o *EMC_Type) GetDYNAMICCONFIG0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg) & 0x60) >> 5
}
func (o *EMC_Type) SetDYNAMICCONFIG0_AM0(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG0.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg)&^(0x1f80)|value<<7)
}
func (o *EMC_Type) GetDYNAMICCONFIG0_AM0() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg) & 0x1f80) >> 7
}
func (o *EMC_Type) SetDYNAMICCONFIG0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG0.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg)&^(0x2000)|value<<13)
}
func (o *EMC_Type) GetDYNAMICCONFIG0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg) & 0x2000) >> 13
}
func (o *EMC_Type) SetDYNAMICCONFIG0_AM1(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG0.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg)&^(0x4000)|value<<14)
}
func (o *EMC_Type) GetDYNAMICCONFIG0_AM1() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg) & 0x4000) >> 14
}
func (o *EMC_Type) SetDYNAMICCONFIG0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG0.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg)&^(0x78000)|value<<15)
}
func (o *EMC_Type) GetDYNAMICCONFIG0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg) & 0x78000) >> 15
}
func (o *EMC_Type) SetDYNAMICCONFIG0_B(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG0.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg)&^(0x80000)|value<<19)
}
func (o *EMC_Type) GetDYNAMICCONFIG0_B() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg) & 0x80000) >> 19
}
func (o *EMC_Type) SetDYNAMICCONFIG0_P(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG0.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg)&^(0x100000)|value<<20)
}
func (o *EMC_Type) GetDYNAMICCONFIG0_P() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg) & 0x100000) >> 20
}
func (o *EMC_Type) SetDYNAMICCONFIG0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG0.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg)&^(0xffe00000)|value<<21)
}
func (o *EMC_Type) GetDYNAMICCONFIG0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG0.Reg) & 0xffe00000) >> 21
}

// EMC.DYNAMICRASCAS0: RAS and CAS latencies for EMC_DYCS0.
func (o *EMC_Type) SetDYNAMICRASCAS0_RAS(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS0.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS0.Reg)&^(0x3)|value)
}
func (o *EMC_Type) GetDYNAMICRASCAS0_RAS() uint32 {
	return volatile.LoadUint32(&o.DYNAMICRASCAS0.Reg) & 0x3
}
func (o *EMC_Type) SetDYNAMICRASCAS0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS0.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS0.Reg)&^(0xfc)|value<<2)
}
func (o *EMC_Type) GetDYNAMICRASCAS0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRASCAS0.Reg) & 0xfc) >> 2
}
func (o *EMC_Type) SetDYNAMICRASCAS0_CAS(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS0.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS0.Reg)&^(0x300)|value<<8)
}
func (o *EMC_Type) GetDYNAMICRASCAS0_CAS() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRASCAS0.Reg) & 0x300) >> 8
}
func (o *EMC_Type) SetDYNAMICRASCAS0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS0.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS0.Reg)&^(0xfffffc00)|value<<10)
}
func (o *EMC_Type) GetDYNAMICRASCAS0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRASCAS0.Reg) & 0xfffffc00) >> 10
}

// EMC.DYNAMICCONFIG1: Configuration information for EMC_DYCS0.
func (o *EMC_Type) SetDYNAMICCONFIG1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG1.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg)&^(0x7)|value)
}
func (o *EMC_Type) GetDYNAMICCONFIG1_RESERVED() uint32 {
	return volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg) & 0x7
}
func (o *EMC_Type) SetDYNAMICCONFIG1_MD(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG1.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg)&^(0x18)|value<<3)
}
func (o *EMC_Type) GetDYNAMICCONFIG1_MD() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg) & 0x18) >> 3
}
func (o *EMC_Type) SetDYNAMICCONFIG1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG1.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg)&^(0x60)|value<<5)
}
func (o *EMC_Type) GetDYNAMICCONFIG1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg) & 0x60) >> 5
}
func (o *EMC_Type) SetDYNAMICCONFIG1_AM0(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG1.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg)&^(0x1f80)|value<<7)
}
func (o *EMC_Type) GetDYNAMICCONFIG1_AM0() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg) & 0x1f80) >> 7
}
func (o *EMC_Type) SetDYNAMICCONFIG1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG1.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg)&^(0x2000)|value<<13)
}
func (o *EMC_Type) GetDYNAMICCONFIG1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg) & 0x2000) >> 13
}
func (o *EMC_Type) SetDYNAMICCONFIG1_AM1(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG1.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg)&^(0x4000)|value<<14)
}
func (o *EMC_Type) GetDYNAMICCONFIG1_AM1() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg) & 0x4000) >> 14
}
func (o *EMC_Type) SetDYNAMICCONFIG1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG1.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg)&^(0x78000)|value<<15)
}
func (o *EMC_Type) GetDYNAMICCONFIG1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg) & 0x78000) >> 15
}
func (o *EMC_Type) SetDYNAMICCONFIG1_B(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG1.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg)&^(0x80000)|value<<19)
}
func (o *EMC_Type) GetDYNAMICCONFIG1_B() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg) & 0x80000) >> 19
}
func (o *EMC_Type) SetDYNAMICCONFIG1_P(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG1.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg)&^(0x100000)|value<<20)
}
func (o *EMC_Type) GetDYNAMICCONFIG1_P() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg) & 0x100000) >> 20
}
func (o *EMC_Type) SetDYNAMICCONFIG1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG1.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg)&^(0xffe00000)|value<<21)
}
func (o *EMC_Type) GetDYNAMICCONFIG1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG1.Reg) & 0xffe00000) >> 21
}

// EMC.DYNAMICRASCAS1: RAS and CAS latencies for EMC_DYCS0.
func (o *EMC_Type) SetDYNAMICRASCAS1_RAS(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS1.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS1.Reg)&^(0x3)|value)
}
func (o *EMC_Type) GetDYNAMICRASCAS1_RAS() uint32 {
	return volatile.LoadUint32(&o.DYNAMICRASCAS1.Reg) & 0x3
}
func (o *EMC_Type) SetDYNAMICRASCAS1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS1.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS1.Reg)&^(0xfc)|value<<2)
}
func (o *EMC_Type) GetDYNAMICRASCAS1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRASCAS1.Reg) & 0xfc) >> 2
}
func (o *EMC_Type) SetDYNAMICRASCAS1_CAS(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS1.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS1.Reg)&^(0x300)|value<<8)
}
func (o *EMC_Type) GetDYNAMICRASCAS1_CAS() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRASCAS1.Reg) & 0x300) >> 8
}
func (o *EMC_Type) SetDYNAMICRASCAS1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS1.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS1.Reg)&^(0xfffffc00)|value<<10)
}
func (o *EMC_Type) GetDYNAMICRASCAS1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRASCAS1.Reg) & 0xfffffc00) >> 10
}

// EMC.DYNAMICCONFIG2: Configuration information for EMC_DYCS0.
func (o *EMC_Type) SetDYNAMICCONFIG2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG2.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg)&^(0x7)|value)
}
func (o *EMC_Type) GetDYNAMICCONFIG2_RESERVED() uint32 {
	return volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg) & 0x7
}
func (o *EMC_Type) SetDYNAMICCONFIG2_MD(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG2.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg)&^(0x18)|value<<3)
}
func (o *EMC_Type) GetDYNAMICCONFIG2_MD() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg) & 0x18) >> 3
}
func (o *EMC_Type) SetDYNAMICCONFIG2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG2.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg)&^(0x60)|value<<5)
}
func (o *EMC_Type) GetDYNAMICCONFIG2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg) & 0x60) >> 5
}
func (o *EMC_Type) SetDYNAMICCONFIG2_AM0(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG2.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg)&^(0x1f80)|value<<7)
}
func (o *EMC_Type) GetDYNAMICCONFIG2_AM0() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg) & 0x1f80) >> 7
}
func (o *EMC_Type) SetDYNAMICCONFIG2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG2.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg)&^(0x2000)|value<<13)
}
func (o *EMC_Type) GetDYNAMICCONFIG2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg) & 0x2000) >> 13
}
func (o *EMC_Type) SetDYNAMICCONFIG2_AM1(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG2.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg)&^(0x4000)|value<<14)
}
func (o *EMC_Type) GetDYNAMICCONFIG2_AM1() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg) & 0x4000) >> 14
}
func (o *EMC_Type) SetDYNAMICCONFIG2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG2.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg)&^(0x78000)|value<<15)
}
func (o *EMC_Type) GetDYNAMICCONFIG2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg) & 0x78000) >> 15
}
func (o *EMC_Type) SetDYNAMICCONFIG2_B(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG2.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg)&^(0x80000)|value<<19)
}
func (o *EMC_Type) GetDYNAMICCONFIG2_B() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg) & 0x80000) >> 19
}
func (o *EMC_Type) SetDYNAMICCONFIG2_P(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG2.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg)&^(0x100000)|value<<20)
}
func (o *EMC_Type) GetDYNAMICCONFIG2_P() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg) & 0x100000) >> 20
}
func (o *EMC_Type) SetDYNAMICCONFIG2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG2.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg)&^(0xffe00000)|value<<21)
}
func (o *EMC_Type) GetDYNAMICCONFIG2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG2.Reg) & 0xffe00000) >> 21
}

// EMC.DYNAMICRASCAS2: RAS and CAS latencies for EMC_DYCS0.
func (o *EMC_Type) SetDYNAMICRASCAS2_RAS(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS2.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS2.Reg)&^(0x3)|value)
}
func (o *EMC_Type) GetDYNAMICRASCAS2_RAS() uint32 {
	return volatile.LoadUint32(&o.DYNAMICRASCAS2.Reg) & 0x3
}
func (o *EMC_Type) SetDYNAMICRASCAS2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS2.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS2.Reg)&^(0xfc)|value<<2)
}
func (o *EMC_Type) GetDYNAMICRASCAS2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRASCAS2.Reg) & 0xfc) >> 2
}
func (o *EMC_Type) SetDYNAMICRASCAS2_CAS(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS2.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS2.Reg)&^(0x300)|value<<8)
}
func (o *EMC_Type) GetDYNAMICRASCAS2_CAS() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRASCAS2.Reg) & 0x300) >> 8
}
func (o *EMC_Type) SetDYNAMICRASCAS2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS2.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS2.Reg)&^(0xfffffc00)|value<<10)
}
func (o *EMC_Type) GetDYNAMICRASCAS2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRASCAS2.Reg) & 0xfffffc00) >> 10
}

// EMC.DYNAMICCONFIG3: Configuration information for EMC_DYCS0.
func (o *EMC_Type) SetDYNAMICCONFIG3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG3.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg)&^(0x7)|value)
}
func (o *EMC_Type) GetDYNAMICCONFIG3_RESERVED() uint32 {
	return volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg) & 0x7
}
func (o *EMC_Type) SetDYNAMICCONFIG3_MD(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG3.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg)&^(0x18)|value<<3)
}
func (o *EMC_Type) GetDYNAMICCONFIG3_MD() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg) & 0x18) >> 3
}
func (o *EMC_Type) SetDYNAMICCONFIG3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG3.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg)&^(0x60)|value<<5)
}
func (o *EMC_Type) GetDYNAMICCONFIG3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg) & 0x60) >> 5
}
func (o *EMC_Type) SetDYNAMICCONFIG3_AM0(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG3.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg)&^(0x1f80)|value<<7)
}
func (o *EMC_Type) GetDYNAMICCONFIG3_AM0() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg) & 0x1f80) >> 7
}
func (o *EMC_Type) SetDYNAMICCONFIG3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG3.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg)&^(0x2000)|value<<13)
}
func (o *EMC_Type) GetDYNAMICCONFIG3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg) & 0x2000) >> 13
}
func (o *EMC_Type) SetDYNAMICCONFIG3_AM1(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG3.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg)&^(0x4000)|value<<14)
}
func (o *EMC_Type) GetDYNAMICCONFIG3_AM1() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg) & 0x4000) >> 14
}
func (o *EMC_Type) SetDYNAMICCONFIG3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG3.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg)&^(0x78000)|value<<15)
}
func (o *EMC_Type) GetDYNAMICCONFIG3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg) & 0x78000) >> 15
}
func (o *EMC_Type) SetDYNAMICCONFIG3_B(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG3.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg)&^(0x80000)|value<<19)
}
func (o *EMC_Type) GetDYNAMICCONFIG3_B() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg) & 0x80000) >> 19
}
func (o *EMC_Type) SetDYNAMICCONFIG3_P(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG3.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg)&^(0x100000)|value<<20)
}
func (o *EMC_Type) GetDYNAMICCONFIG3_P() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg) & 0x100000) >> 20
}
func (o *EMC_Type) SetDYNAMICCONFIG3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICCONFIG3.Reg, volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg)&^(0xffe00000)|value<<21)
}
func (o *EMC_Type) GetDYNAMICCONFIG3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICCONFIG3.Reg) & 0xffe00000) >> 21
}

// EMC.DYNAMICRASCAS3: RAS and CAS latencies for EMC_DYCS0.
func (o *EMC_Type) SetDYNAMICRASCAS3_RAS(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS3.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS3.Reg)&^(0x3)|value)
}
func (o *EMC_Type) GetDYNAMICRASCAS3_RAS() uint32 {
	return volatile.LoadUint32(&o.DYNAMICRASCAS3.Reg) & 0x3
}
func (o *EMC_Type) SetDYNAMICRASCAS3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS3.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS3.Reg)&^(0xfc)|value<<2)
}
func (o *EMC_Type) GetDYNAMICRASCAS3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRASCAS3.Reg) & 0xfc) >> 2
}
func (o *EMC_Type) SetDYNAMICRASCAS3_CAS(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS3.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS3.Reg)&^(0x300)|value<<8)
}
func (o *EMC_Type) GetDYNAMICRASCAS3_CAS() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRASCAS3.Reg) & 0x300) >> 8
}
func (o *EMC_Type) SetDYNAMICRASCAS3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DYNAMICRASCAS3.Reg, volatile.LoadUint32(&o.DYNAMICRASCAS3.Reg)&^(0xfffffc00)|value<<10)
}
func (o *EMC_Type) GetDYNAMICRASCAS3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DYNAMICRASCAS3.Reg) & 0xfffffc00) >> 10
}

// EMC.STATICCONFIG0: Configuration for EMC_CS0.
func (o *EMC_Type) SetSTATICCONFIG0_MW(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG0.Reg, volatile.LoadUint32(&o.STATICCONFIG0.Reg)&^(0x3)|value)
}
func (o *EMC_Type) GetSTATICCONFIG0_MW() uint32 {
	return volatile.LoadUint32(&o.STATICCONFIG0.Reg) & 0x3
}
func (o *EMC_Type) SetSTATICCONFIG0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG0.Reg, volatile.LoadUint32(&o.STATICCONFIG0.Reg)&^(0x4)|value<<2)
}
func (o *EMC_Type) GetSTATICCONFIG0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG0.Reg) & 0x4) >> 2
}
func (o *EMC_Type) SetSTATICCONFIG0_PM(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG0.Reg, volatile.LoadUint32(&o.STATICCONFIG0.Reg)&^(0x8)|value<<3)
}
func (o *EMC_Type) GetSTATICCONFIG0_PM() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG0.Reg) & 0x8) >> 3
}
func (o *EMC_Type) SetSTATICCONFIG0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG0.Reg, volatile.LoadUint32(&o.STATICCONFIG0.Reg)&^(0x30)|value<<4)
}
func (o *EMC_Type) GetSTATICCONFIG0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG0.Reg) & 0x30) >> 4
}
func (o *EMC_Type) SetSTATICCONFIG0_PC(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG0.Reg, volatile.LoadUint32(&o.STATICCONFIG0.Reg)&^(0x40)|value<<6)
}
func (o *EMC_Type) GetSTATICCONFIG0_PC() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG0.Reg) & 0x40) >> 6
}
func (o *EMC_Type) SetSTATICCONFIG0_PB(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG0.Reg, volatile.LoadUint32(&o.STATICCONFIG0.Reg)&^(0x80)|value<<7)
}
func (o *EMC_Type) GetSTATICCONFIG0_PB() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG0.Reg) & 0x80) >> 7
}
func (o *EMC_Type) SetSTATICCONFIG0_EW(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG0.Reg, volatile.LoadUint32(&o.STATICCONFIG0.Reg)&^(0x100)|value<<8)
}
func (o *EMC_Type) GetSTATICCONFIG0_EW() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG0.Reg) & 0x100) >> 8
}
func (o *EMC_Type) SetSTATICCONFIG0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG0.Reg, volatile.LoadUint32(&o.STATICCONFIG0.Reg)&^(0x7fe00)|value<<9)
}
func (o *EMC_Type) GetSTATICCONFIG0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG0.Reg) & 0x7fe00) >> 9
}
func (o *EMC_Type) SetSTATICCONFIG0_B(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG0.Reg, volatile.LoadUint32(&o.STATICCONFIG0.Reg)&^(0x80000)|value<<19)
}
func (o *EMC_Type) GetSTATICCONFIG0_B() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG0.Reg) & 0x80000) >> 19
}
func (o *EMC_Type) SetSTATICCONFIG0_P(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG0.Reg, volatile.LoadUint32(&o.STATICCONFIG0.Reg)&^(0x100000)|value<<20)
}
func (o *EMC_Type) GetSTATICCONFIG0_P() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG0.Reg) & 0x100000) >> 20
}
func (o *EMC_Type) SetSTATICCONFIG0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG0.Reg, volatile.LoadUint32(&o.STATICCONFIG0.Reg)&^(0xffe00000)|value<<21)
}
func (o *EMC_Type) GetSTATICCONFIG0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG0.Reg) & 0xffe00000) >> 21
}

// EMC.STATICWAITWEN0: Delay from EMC_CS0 to write enable.
func (o *EMC_Type) SetSTATICWAITWEN0_WAITWEN(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWEN0.Reg, volatile.LoadUint32(&o.STATICWAITWEN0.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetSTATICWAITWEN0_WAITWEN() uint32 {
	return volatile.LoadUint32(&o.STATICWAITWEN0.Reg) & 0xf
}
func (o *EMC_Type) SetSTATICWAITWEN0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWEN0.Reg, volatile.LoadUint32(&o.STATICWAITWEN0.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetSTATICWAITWEN0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITWEN0.Reg) & 0xfffffff0) >> 4
}

// EMC.STATICWAITOEN0: Delay from EMC_CS0 or address change, whichever is later, to output enable.
func (o *EMC_Type) SetSTATICWAITOEN0_WAITOEN(value uint32) {
	volatile.StoreUint32(&o.STATICWAITOEN0.Reg, volatile.LoadUint32(&o.STATICWAITOEN0.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetSTATICWAITOEN0_WAITOEN() uint32 {
	return volatile.LoadUint32(&o.STATICWAITOEN0.Reg) & 0xf
}
func (o *EMC_Type) SetSTATICWAITOEN0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITOEN0.Reg, volatile.LoadUint32(&o.STATICWAITOEN0.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetSTATICWAITOEN0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITOEN0.Reg) & 0xfffffff0) >> 4
}

// EMC.STATICWAITRD0: Delay from EMC_CS0 to a read access.
func (o *EMC_Type) SetSTATICWAITRD0_WAITRD(value uint32) {
	volatile.StoreUint32(&o.STATICWAITRD0.Reg, volatile.LoadUint32(&o.STATICWAITRD0.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetSTATICWAITRD0_WAITRD() uint32 {
	return volatile.LoadUint32(&o.STATICWAITRD0.Reg) & 0x1f
}
func (o *EMC_Type) SetSTATICWAITRD0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITRD0.Reg, volatile.LoadUint32(&o.STATICWAITRD0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetSTATICWAITRD0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITRD0.Reg) & 0xffffffe0) >> 5
}

// EMC.STATICWAITPAGE0: Delay for asynchronous page mode sequential accesses for EMC_CS0.
func (o *EMC_Type) SetSTATICWAITPAGE0_WAITPAGE(value uint32) {
	volatile.StoreUint32(&o.STATICWAITPAGE0.Reg, volatile.LoadUint32(&o.STATICWAITPAGE0.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetSTATICWAITPAGE0_WAITPAGE() uint32 {
	return volatile.LoadUint32(&o.STATICWAITPAGE0.Reg) & 0x1f
}
func (o *EMC_Type) SetSTATICWAITPAGE0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITPAGE0.Reg, volatile.LoadUint32(&o.STATICWAITPAGE0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetSTATICWAITPAGE0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITPAGE0.Reg) & 0xffffffe0) >> 5
}

// EMC.STATICWAITWR0: Delay from EMC_CS0 to a write access.
func (o *EMC_Type) SetSTATICWAITWR0_WAITWR(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWR0.Reg, volatile.LoadUint32(&o.STATICWAITWR0.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetSTATICWAITWR0_WAITWR() uint32 {
	return volatile.LoadUint32(&o.STATICWAITWR0.Reg) & 0x1f
}
func (o *EMC_Type) SetSTATICWAITWR0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWR0.Reg, volatile.LoadUint32(&o.STATICWAITWR0.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetSTATICWAITWR0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITWR0.Reg) & 0xffffffe0) >> 5
}

// EMC.STATICWAITTURN0: Number of bus turnaround cycles EMC_CS0.
func (o *EMC_Type) SetSTATICWAITTURN0_WAITTURN(value uint32) {
	volatile.StoreUint32(&o.STATICWAITTURN0.Reg, volatile.LoadUint32(&o.STATICWAITTURN0.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetSTATICWAITTURN0_WAITTURN() uint32 {
	return volatile.LoadUint32(&o.STATICWAITTURN0.Reg) & 0xf
}
func (o *EMC_Type) SetSTATICWAITTURN0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITTURN0.Reg, volatile.LoadUint32(&o.STATICWAITTURN0.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetSTATICWAITTURN0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITTURN0.Reg) & 0xfffffff0) >> 4
}

// EMC.STATICCONFIG1: Configuration for EMC_CS0.
func (o *EMC_Type) SetSTATICCONFIG1_MW(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG1.Reg, volatile.LoadUint32(&o.STATICCONFIG1.Reg)&^(0x3)|value)
}
func (o *EMC_Type) GetSTATICCONFIG1_MW() uint32 {
	return volatile.LoadUint32(&o.STATICCONFIG1.Reg) & 0x3
}
func (o *EMC_Type) SetSTATICCONFIG1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG1.Reg, volatile.LoadUint32(&o.STATICCONFIG1.Reg)&^(0x4)|value<<2)
}
func (o *EMC_Type) GetSTATICCONFIG1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG1.Reg) & 0x4) >> 2
}
func (o *EMC_Type) SetSTATICCONFIG1_PM(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG1.Reg, volatile.LoadUint32(&o.STATICCONFIG1.Reg)&^(0x8)|value<<3)
}
func (o *EMC_Type) GetSTATICCONFIG1_PM() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG1.Reg) & 0x8) >> 3
}
func (o *EMC_Type) SetSTATICCONFIG1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG1.Reg, volatile.LoadUint32(&o.STATICCONFIG1.Reg)&^(0x30)|value<<4)
}
func (o *EMC_Type) GetSTATICCONFIG1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG1.Reg) & 0x30) >> 4
}
func (o *EMC_Type) SetSTATICCONFIG1_PC(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG1.Reg, volatile.LoadUint32(&o.STATICCONFIG1.Reg)&^(0x40)|value<<6)
}
func (o *EMC_Type) GetSTATICCONFIG1_PC() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG1.Reg) & 0x40) >> 6
}
func (o *EMC_Type) SetSTATICCONFIG1_PB(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG1.Reg, volatile.LoadUint32(&o.STATICCONFIG1.Reg)&^(0x80)|value<<7)
}
func (o *EMC_Type) GetSTATICCONFIG1_PB() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG1.Reg) & 0x80) >> 7
}
func (o *EMC_Type) SetSTATICCONFIG1_EW(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG1.Reg, volatile.LoadUint32(&o.STATICCONFIG1.Reg)&^(0x100)|value<<8)
}
func (o *EMC_Type) GetSTATICCONFIG1_EW() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG1.Reg) & 0x100) >> 8
}
func (o *EMC_Type) SetSTATICCONFIG1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG1.Reg, volatile.LoadUint32(&o.STATICCONFIG1.Reg)&^(0x7fe00)|value<<9)
}
func (o *EMC_Type) GetSTATICCONFIG1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG1.Reg) & 0x7fe00) >> 9
}
func (o *EMC_Type) SetSTATICCONFIG1_B(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG1.Reg, volatile.LoadUint32(&o.STATICCONFIG1.Reg)&^(0x80000)|value<<19)
}
func (o *EMC_Type) GetSTATICCONFIG1_B() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG1.Reg) & 0x80000) >> 19
}
func (o *EMC_Type) SetSTATICCONFIG1_P(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG1.Reg, volatile.LoadUint32(&o.STATICCONFIG1.Reg)&^(0x100000)|value<<20)
}
func (o *EMC_Type) GetSTATICCONFIG1_P() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG1.Reg) & 0x100000) >> 20
}
func (o *EMC_Type) SetSTATICCONFIG1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG1.Reg, volatile.LoadUint32(&o.STATICCONFIG1.Reg)&^(0xffe00000)|value<<21)
}
func (o *EMC_Type) GetSTATICCONFIG1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG1.Reg) & 0xffe00000) >> 21
}

// EMC.STATICWAITWEN1: Delay from EMC_CS0 to write enable.
func (o *EMC_Type) SetSTATICWAITWEN1_WAITWEN(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWEN1.Reg, volatile.LoadUint32(&o.STATICWAITWEN1.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetSTATICWAITWEN1_WAITWEN() uint32 {
	return volatile.LoadUint32(&o.STATICWAITWEN1.Reg) & 0xf
}
func (o *EMC_Type) SetSTATICWAITWEN1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWEN1.Reg, volatile.LoadUint32(&o.STATICWAITWEN1.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetSTATICWAITWEN1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITWEN1.Reg) & 0xfffffff0) >> 4
}

// EMC.STATICWAITOEN1: Delay from EMC_CS0 or address change, whichever is later, to output enable.
func (o *EMC_Type) SetSTATICWAITOEN1_WAITOEN(value uint32) {
	volatile.StoreUint32(&o.STATICWAITOEN1.Reg, volatile.LoadUint32(&o.STATICWAITOEN1.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetSTATICWAITOEN1_WAITOEN() uint32 {
	return volatile.LoadUint32(&o.STATICWAITOEN1.Reg) & 0xf
}
func (o *EMC_Type) SetSTATICWAITOEN1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITOEN1.Reg, volatile.LoadUint32(&o.STATICWAITOEN1.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetSTATICWAITOEN1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITOEN1.Reg) & 0xfffffff0) >> 4
}

// EMC.STATICWAITRD1: Delay from EMC_CS0 to a read access.
func (o *EMC_Type) SetSTATICWAITRD1_WAITRD(value uint32) {
	volatile.StoreUint32(&o.STATICWAITRD1.Reg, volatile.LoadUint32(&o.STATICWAITRD1.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetSTATICWAITRD1_WAITRD() uint32 {
	return volatile.LoadUint32(&o.STATICWAITRD1.Reg) & 0x1f
}
func (o *EMC_Type) SetSTATICWAITRD1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITRD1.Reg, volatile.LoadUint32(&o.STATICWAITRD1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetSTATICWAITRD1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITRD1.Reg) & 0xffffffe0) >> 5
}

// EMC.STATICWAITPAGE1: Delay for asynchronous page mode sequential accesses for EMC_CS0.
func (o *EMC_Type) SetSTATICWAITPAGE1_WAITPAGE(value uint32) {
	volatile.StoreUint32(&o.STATICWAITPAGE1.Reg, volatile.LoadUint32(&o.STATICWAITPAGE1.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetSTATICWAITPAGE1_WAITPAGE() uint32 {
	return volatile.LoadUint32(&o.STATICWAITPAGE1.Reg) & 0x1f
}
func (o *EMC_Type) SetSTATICWAITPAGE1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITPAGE1.Reg, volatile.LoadUint32(&o.STATICWAITPAGE1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetSTATICWAITPAGE1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITPAGE1.Reg) & 0xffffffe0) >> 5
}

// EMC.STATICWAITWR1: Delay from EMC_CS0 to a write access.
func (o *EMC_Type) SetSTATICWAITWR1_WAITWR(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWR1.Reg, volatile.LoadUint32(&o.STATICWAITWR1.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetSTATICWAITWR1_WAITWR() uint32 {
	return volatile.LoadUint32(&o.STATICWAITWR1.Reg) & 0x1f
}
func (o *EMC_Type) SetSTATICWAITWR1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWR1.Reg, volatile.LoadUint32(&o.STATICWAITWR1.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetSTATICWAITWR1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITWR1.Reg) & 0xffffffe0) >> 5
}

// EMC.STATICWAITTURN1: Number of bus turnaround cycles EMC_CS0.
func (o *EMC_Type) SetSTATICWAITTURN1_WAITTURN(value uint32) {
	volatile.StoreUint32(&o.STATICWAITTURN1.Reg, volatile.LoadUint32(&o.STATICWAITTURN1.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetSTATICWAITTURN1_WAITTURN() uint32 {
	return volatile.LoadUint32(&o.STATICWAITTURN1.Reg) & 0xf
}
func (o *EMC_Type) SetSTATICWAITTURN1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITTURN1.Reg, volatile.LoadUint32(&o.STATICWAITTURN1.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetSTATICWAITTURN1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITTURN1.Reg) & 0xfffffff0) >> 4
}

// EMC.STATICCONFIG2: Configuration for EMC_CS0.
func (o *EMC_Type) SetSTATICCONFIG2_MW(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG2.Reg, volatile.LoadUint32(&o.STATICCONFIG2.Reg)&^(0x3)|value)
}
func (o *EMC_Type) GetSTATICCONFIG2_MW() uint32 {
	return volatile.LoadUint32(&o.STATICCONFIG2.Reg) & 0x3
}
func (o *EMC_Type) SetSTATICCONFIG2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG2.Reg, volatile.LoadUint32(&o.STATICCONFIG2.Reg)&^(0x4)|value<<2)
}
func (o *EMC_Type) GetSTATICCONFIG2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG2.Reg) & 0x4) >> 2
}
func (o *EMC_Type) SetSTATICCONFIG2_PM(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG2.Reg, volatile.LoadUint32(&o.STATICCONFIG2.Reg)&^(0x8)|value<<3)
}
func (o *EMC_Type) GetSTATICCONFIG2_PM() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG2.Reg) & 0x8) >> 3
}
func (o *EMC_Type) SetSTATICCONFIG2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG2.Reg, volatile.LoadUint32(&o.STATICCONFIG2.Reg)&^(0x30)|value<<4)
}
func (o *EMC_Type) GetSTATICCONFIG2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG2.Reg) & 0x30) >> 4
}
func (o *EMC_Type) SetSTATICCONFIG2_PC(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG2.Reg, volatile.LoadUint32(&o.STATICCONFIG2.Reg)&^(0x40)|value<<6)
}
func (o *EMC_Type) GetSTATICCONFIG2_PC() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG2.Reg) & 0x40) >> 6
}
func (o *EMC_Type) SetSTATICCONFIG2_PB(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG2.Reg, volatile.LoadUint32(&o.STATICCONFIG2.Reg)&^(0x80)|value<<7)
}
func (o *EMC_Type) GetSTATICCONFIG2_PB() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG2.Reg) & 0x80) >> 7
}
func (o *EMC_Type) SetSTATICCONFIG2_EW(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG2.Reg, volatile.LoadUint32(&o.STATICCONFIG2.Reg)&^(0x100)|value<<8)
}
func (o *EMC_Type) GetSTATICCONFIG2_EW() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG2.Reg) & 0x100) >> 8
}
func (o *EMC_Type) SetSTATICCONFIG2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG2.Reg, volatile.LoadUint32(&o.STATICCONFIG2.Reg)&^(0x7fe00)|value<<9)
}
func (o *EMC_Type) GetSTATICCONFIG2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG2.Reg) & 0x7fe00) >> 9
}
func (o *EMC_Type) SetSTATICCONFIG2_B(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG2.Reg, volatile.LoadUint32(&o.STATICCONFIG2.Reg)&^(0x80000)|value<<19)
}
func (o *EMC_Type) GetSTATICCONFIG2_B() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG2.Reg) & 0x80000) >> 19
}
func (o *EMC_Type) SetSTATICCONFIG2_P(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG2.Reg, volatile.LoadUint32(&o.STATICCONFIG2.Reg)&^(0x100000)|value<<20)
}
func (o *EMC_Type) GetSTATICCONFIG2_P() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG2.Reg) & 0x100000) >> 20
}
func (o *EMC_Type) SetSTATICCONFIG2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG2.Reg, volatile.LoadUint32(&o.STATICCONFIG2.Reg)&^(0xffe00000)|value<<21)
}
func (o *EMC_Type) GetSTATICCONFIG2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG2.Reg) & 0xffe00000) >> 21
}

// EMC.STATICWAITWEN2: Delay from EMC_CS0 to write enable.
func (o *EMC_Type) SetSTATICWAITWEN2_WAITWEN(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWEN2.Reg, volatile.LoadUint32(&o.STATICWAITWEN2.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetSTATICWAITWEN2_WAITWEN() uint32 {
	return volatile.LoadUint32(&o.STATICWAITWEN2.Reg) & 0xf
}
func (o *EMC_Type) SetSTATICWAITWEN2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWEN2.Reg, volatile.LoadUint32(&o.STATICWAITWEN2.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetSTATICWAITWEN2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITWEN2.Reg) & 0xfffffff0) >> 4
}

// EMC.STATICWAITOEN2: Delay from EMC_CS0 or address change, whichever is later, to output enable.
func (o *EMC_Type) SetSTATICWAITOEN2_WAITOEN(value uint32) {
	volatile.StoreUint32(&o.STATICWAITOEN2.Reg, volatile.LoadUint32(&o.STATICWAITOEN2.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetSTATICWAITOEN2_WAITOEN() uint32 {
	return volatile.LoadUint32(&o.STATICWAITOEN2.Reg) & 0xf
}
func (o *EMC_Type) SetSTATICWAITOEN2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITOEN2.Reg, volatile.LoadUint32(&o.STATICWAITOEN2.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetSTATICWAITOEN2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITOEN2.Reg) & 0xfffffff0) >> 4
}

// EMC.STATICWAITRD2: Delay from EMC_CS0 to a read access.
func (o *EMC_Type) SetSTATICWAITRD2_WAITRD(value uint32) {
	volatile.StoreUint32(&o.STATICWAITRD2.Reg, volatile.LoadUint32(&o.STATICWAITRD2.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetSTATICWAITRD2_WAITRD() uint32 {
	return volatile.LoadUint32(&o.STATICWAITRD2.Reg) & 0x1f
}
func (o *EMC_Type) SetSTATICWAITRD2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITRD2.Reg, volatile.LoadUint32(&o.STATICWAITRD2.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetSTATICWAITRD2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITRD2.Reg) & 0xffffffe0) >> 5
}

// EMC.STATICWAITPAGE2: Delay for asynchronous page mode sequential accesses for EMC_CS0.
func (o *EMC_Type) SetSTATICWAITPAGE2_WAITPAGE(value uint32) {
	volatile.StoreUint32(&o.STATICWAITPAGE2.Reg, volatile.LoadUint32(&o.STATICWAITPAGE2.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetSTATICWAITPAGE2_WAITPAGE() uint32 {
	return volatile.LoadUint32(&o.STATICWAITPAGE2.Reg) & 0x1f
}
func (o *EMC_Type) SetSTATICWAITPAGE2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITPAGE2.Reg, volatile.LoadUint32(&o.STATICWAITPAGE2.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetSTATICWAITPAGE2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITPAGE2.Reg) & 0xffffffe0) >> 5
}

// EMC.STATICWAITWR2: Delay from EMC_CS0 to a write access.
func (o *EMC_Type) SetSTATICWAITWR2_WAITWR(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWR2.Reg, volatile.LoadUint32(&o.STATICWAITWR2.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetSTATICWAITWR2_WAITWR() uint32 {
	return volatile.LoadUint32(&o.STATICWAITWR2.Reg) & 0x1f
}
func (o *EMC_Type) SetSTATICWAITWR2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWR2.Reg, volatile.LoadUint32(&o.STATICWAITWR2.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetSTATICWAITWR2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITWR2.Reg) & 0xffffffe0) >> 5
}

// EMC.STATICWAITTURN2: Number of bus turnaround cycles EMC_CS0.
func (o *EMC_Type) SetSTATICWAITTURN2_WAITTURN(value uint32) {
	volatile.StoreUint32(&o.STATICWAITTURN2.Reg, volatile.LoadUint32(&o.STATICWAITTURN2.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetSTATICWAITTURN2_WAITTURN() uint32 {
	return volatile.LoadUint32(&o.STATICWAITTURN2.Reg) & 0xf
}
func (o *EMC_Type) SetSTATICWAITTURN2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITTURN2.Reg, volatile.LoadUint32(&o.STATICWAITTURN2.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetSTATICWAITTURN2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITTURN2.Reg) & 0xfffffff0) >> 4
}

// EMC.STATICCONFIG3: Configuration for EMC_CS0.
func (o *EMC_Type) SetSTATICCONFIG3_MW(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG3.Reg, volatile.LoadUint32(&o.STATICCONFIG3.Reg)&^(0x3)|value)
}
func (o *EMC_Type) GetSTATICCONFIG3_MW() uint32 {
	return volatile.LoadUint32(&o.STATICCONFIG3.Reg) & 0x3
}
func (o *EMC_Type) SetSTATICCONFIG3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG3.Reg, volatile.LoadUint32(&o.STATICCONFIG3.Reg)&^(0x4)|value<<2)
}
func (o *EMC_Type) GetSTATICCONFIG3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG3.Reg) & 0x4) >> 2
}
func (o *EMC_Type) SetSTATICCONFIG3_PM(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG3.Reg, volatile.LoadUint32(&o.STATICCONFIG3.Reg)&^(0x8)|value<<3)
}
func (o *EMC_Type) GetSTATICCONFIG3_PM() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG3.Reg) & 0x8) >> 3
}
func (o *EMC_Type) SetSTATICCONFIG3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG3.Reg, volatile.LoadUint32(&o.STATICCONFIG3.Reg)&^(0x30)|value<<4)
}
func (o *EMC_Type) GetSTATICCONFIG3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG3.Reg) & 0x30) >> 4
}
func (o *EMC_Type) SetSTATICCONFIG3_PC(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG3.Reg, volatile.LoadUint32(&o.STATICCONFIG3.Reg)&^(0x40)|value<<6)
}
func (o *EMC_Type) GetSTATICCONFIG3_PC() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG3.Reg) & 0x40) >> 6
}
func (o *EMC_Type) SetSTATICCONFIG3_PB(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG3.Reg, volatile.LoadUint32(&o.STATICCONFIG3.Reg)&^(0x80)|value<<7)
}
func (o *EMC_Type) GetSTATICCONFIG3_PB() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG3.Reg) & 0x80) >> 7
}
func (o *EMC_Type) SetSTATICCONFIG3_EW(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG3.Reg, volatile.LoadUint32(&o.STATICCONFIG3.Reg)&^(0x100)|value<<8)
}
func (o *EMC_Type) GetSTATICCONFIG3_EW() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG3.Reg) & 0x100) >> 8
}
func (o *EMC_Type) SetSTATICCONFIG3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG3.Reg, volatile.LoadUint32(&o.STATICCONFIG3.Reg)&^(0x7fe00)|value<<9)
}
func (o *EMC_Type) GetSTATICCONFIG3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG3.Reg) & 0x7fe00) >> 9
}
func (o *EMC_Type) SetSTATICCONFIG3_B(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG3.Reg, volatile.LoadUint32(&o.STATICCONFIG3.Reg)&^(0x80000)|value<<19)
}
func (o *EMC_Type) GetSTATICCONFIG3_B() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG3.Reg) & 0x80000) >> 19
}
func (o *EMC_Type) SetSTATICCONFIG3_P(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG3.Reg, volatile.LoadUint32(&o.STATICCONFIG3.Reg)&^(0x100000)|value<<20)
}
func (o *EMC_Type) GetSTATICCONFIG3_P() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG3.Reg) & 0x100000) >> 20
}
func (o *EMC_Type) SetSTATICCONFIG3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICCONFIG3.Reg, volatile.LoadUint32(&o.STATICCONFIG3.Reg)&^(0xffe00000)|value<<21)
}
func (o *EMC_Type) GetSTATICCONFIG3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICCONFIG3.Reg) & 0xffe00000) >> 21
}

// EMC.STATICWAITWEN3: Delay from EMC_CS0 to write enable.
func (o *EMC_Type) SetSTATICWAITWEN3_WAITWEN(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWEN3.Reg, volatile.LoadUint32(&o.STATICWAITWEN3.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetSTATICWAITWEN3_WAITWEN() uint32 {
	return volatile.LoadUint32(&o.STATICWAITWEN3.Reg) & 0xf
}
func (o *EMC_Type) SetSTATICWAITWEN3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWEN3.Reg, volatile.LoadUint32(&o.STATICWAITWEN3.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetSTATICWAITWEN3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITWEN3.Reg) & 0xfffffff0) >> 4
}

// EMC.STATICWAITOEN3: Delay from EMC_CS0 or address change, whichever is later, to output enable.
func (o *EMC_Type) SetSTATICWAITOEN3_WAITOEN(value uint32) {
	volatile.StoreUint32(&o.STATICWAITOEN3.Reg, volatile.LoadUint32(&o.STATICWAITOEN3.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetSTATICWAITOEN3_WAITOEN() uint32 {
	return volatile.LoadUint32(&o.STATICWAITOEN3.Reg) & 0xf
}
func (o *EMC_Type) SetSTATICWAITOEN3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITOEN3.Reg, volatile.LoadUint32(&o.STATICWAITOEN3.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetSTATICWAITOEN3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITOEN3.Reg) & 0xfffffff0) >> 4
}

// EMC.STATICWAITRD3: Delay from EMC_CS0 to a read access.
func (o *EMC_Type) SetSTATICWAITRD3_WAITRD(value uint32) {
	volatile.StoreUint32(&o.STATICWAITRD3.Reg, volatile.LoadUint32(&o.STATICWAITRD3.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetSTATICWAITRD3_WAITRD() uint32 {
	return volatile.LoadUint32(&o.STATICWAITRD3.Reg) & 0x1f
}
func (o *EMC_Type) SetSTATICWAITRD3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITRD3.Reg, volatile.LoadUint32(&o.STATICWAITRD3.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetSTATICWAITRD3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITRD3.Reg) & 0xffffffe0) >> 5
}

// EMC.STATICWAITPAGE3: Delay for asynchronous page mode sequential accesses for EMC_CS0.
func (o *EMC_Type) SetSTATICWAITPAGE3_WAITPAGE(value uint32) {
	volatile.StoreUint32(&o.STATICWAITPAGE3.Reg, volatile.LoadUint32(&o.STATICWAITPAGE3.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetSTATICWAITPAGE3_WAITPAGE() uint32 {
	return volatile.LoadUint32(&o.STATICWAITPAGE3.Reg) & 0x1f
}
func (o *EMC_Type) SetSTATICWAITPAGE3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITPAGE3.Reg, volatile.LoadUint32(&o.STATICWAITPAGE3.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetSTATICWAITPAGE3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITPAGE3.Reg) & 0xffffffe0) >> 5
}

// EMC.STATICWAITWR3: Delay from EMC_CS0 to a write access.
func (o *EMC_Type) SetSTATICWAITWR3_WAITWR(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWR3.Reg, volatile.LoadUint32(&o.STATICWAITWR3.Reg)&^(0x1f)|value)
}
func (o *EMC_Type) GetSTATICWAITWR3_WAITWR() uint32 {
	return volatile.LoadUint32(&o.STATICWAITWR3.Reg) & 0x1f
}
func (o *EMC_Type) SetSTATICWAITWR3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITWR3.Reg, volatile.LoadUint32(&o.STATICWAITWR3.Reg)&^(0xffffffe0)|value<<5)
}
func (o *EMC_Type) GetSTATICWAITWR3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITWR3.Reg) & 0xffffffe0) >> 5
}

// EMC.STATICWAITTURN3: Number of bus turnaround cycles EMC_CS0.
func (o *EMC_Type) SetSTATICWAITTURN3_WAITTURN(value uint32) {
	volatile.StoreUint32(&o.STATICWAITTURN3.Reg, volatile.LoadUint32(&o.STATICWAITTURN3.Reg)&^(0xf)|value)
}
func (o *EMC_Type) GetSTATICWAITTURN3_WAITTURN() uint32 {
	return volatile.LoadUint32(&o.STATICWAITTURN3.Reg) & 0xf
}
func (o *EMC_Type) SetSTATICWAITTURN3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATICWAITTURN3.Reg, volatile.LoadUint32(&o.STATICWAITTURN3.Reg)&^(0xfffffff0)|value<<4)
}
func (o *EMC_Type) GetSTATICWAITTURN3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATICWAITTURN3.Reg) & 0xfffffff0) >> 4
}

// Windowed Watchdog Timer (WWDT)
type WWDT_Type struct {
	MOD     volatile.Register32 // 0x0
	TC      volatile.Register32 // 0x4
	FEED    volatile.Register32 // 0x8
	TV      volatile.Register32 // 0xC
	_       [4]byte
	WARNINT volatile.Register32 // 0x14
	WINDOW  volatile.Register32 // 0x18
}

// WWDT.MOD: Watchdog mode register. This register determines the basic mode and status of the Watchdog Timer.
func (o *WWDT_Type) SetMOD_WDEN(value uint32) {
	volatile.StoreUint32(&o.MOD.Reg, volatile.LoadUint32(&o.MOD.Reg)&^(0x1)|value)
}
func (o *WWDT_Type) GetMOD_WDEN() uint32 {
	return volatile.LoadUint32(&o.MOD.Reg) & 0x1
}
func (o *WWDT_Type) SetMOD_WDRESET(value uint32) {
	volatile.StoreUint32(&o.MOD.Reg, volatile.LoadUint32(&o.MOD.Reg)&^(0x2)|value<<1)
}
func (o *WWDT_Type) GetMOD_WDRESET() uint32 {
	return (volatile.LoadUint32(&o.MOD.Reg) & 0x2) >> 1
}
func (o *WWDT_Type) SetMOD_WDTOF(value uint32) {
	volatile.StoreUint32(&o.MOD.Reg, volatile.LoadUint32(&o.MOD.Reg)&^(0x4)|value<<2)
}
func (o *WWDT_Type) GetMOD_WDTOF() uint32 {
	return (volatile.LoadUint32(&o.MOD.Reg) & 0x4) >> 2
}
func (o *WWDT_Type) SetMOD_WDINT(value uint32) {
	volatile.StoreUint32(&o.MOD.Reg, volatile.LoadUint32(&o.MOD.Reg)&^(0x8)|value<<3)
}
func (o *WWDT_Type) GetMOD_WDINT() uint32 {
	return (volatile.LoadUint32(&o.MOD.Reg) & 0x8) >> 3
}
func (o *WWDT_Type) SetMOD_WDPROTECT(value uint32) {
	volatile.StoreUint32(&o.MOD.Reg, volatile.LoadUint32(&o.MOD.Reg)&^(0x10)|value<<4)
}
func (o *WWDT_Type) GetMOD_WDPROTECT() uint32 {
	return (volatile.LoadUint32(&o.MOD.Reg) & 0x10) >> 4
}
func (o *WWDT_Type) SetMOD_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MOD.Reg, volatile.LoadUint32(&o.MOD.Reg)&^(0xe0)|value<<5)
}
func (o *WWDT_Type) GetMOD_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MOD.Reg) & 0xe0) >> 5
}

// WWDT.TC: Watchdog timer constant register. The value in this register determines the time-out value.
func (o *WWDT_Type) SetTC_Count(value uint32) {
	volatile.StoreUint32(&o.TC.Reg, volatile.LoadUint32(&o.TC.Reg)&^(0xffffff)|value)
}
func (o *WWDT_Type) GetTC_Count() uint32 {
	return volatile.LoadUint32(&o.TC.Reg) & 0xffffff
}
func (o *WWDT_Type) SetTC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TC.Reg, volatile.LoadUint32(&o.TC.Reg)&^(0xff000000)|value<<24)
}
func (o *WWDT_Type) GetTC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TC.Reg) & 0xff000000) >> 24
}

// WWDT.FEED: Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in WDTC.
func (o *WWDT_Type) SetFEED_Feed(value uint32) {
	volatile.StoreUint32(&o.FEED.Reg, volatile.LoadUint32(&o.FEED.Reg)&^(0xff)|value)
}
func (o *WWDT_Type) GetFEED_Feed() uint32 {
	return volatile.LoadUint32(&o.FEED.Reg) & 0xff
}

// WWDT.TV: Watchdog timer value register. This register reads out the current value of the Watchdog timer.
func (o *WWDT_Type) SetTV_Count(value uint32) {
	volatile.StoreUint32(&o.TV.Reg, volatile.LoadUint32(&o.TV.Reg)&^(0xffffff)|value)
}
func (o *WWDT_Type) GetTV_Count() uint32 {
	return volatile.LoadUint32(&o.TV.Reg) & 0xffffff
}
func (o *WWDT_Type) SetTV_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TV.Reg, volatile.LoadUint32(&o.TV.Reg)&^(0xff000000)|value<<24)
}
func (o *WWDT_Type) GetTV_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TV.Reg) & 0xff000000) >> 24
}

// WWDT.WARNINT: Watchdog Warning Interrupt compare value.
func (o *WWDT_Type) SetWARNINT(value uint32) {
	volatile.StoreUint32(&o.WARNINT.Reg, volatile.LoadUint32(&o.WARNINT.Reg)&^(0x3ff)|value)
}
func (o *WWDT_Type) GetWARNINT() uint32 {
	return volatile.LoadUint32(&o.WARNINT.Reg) & 0x3ff
}
func (o *WWDT_Type) SetWARNINT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.WARNINT.Reg, volatile.LoadUint32(&o.WARNINT.Reg)&^(0xfffffc00)|value<<10)
}
func (o *WWDT_Type) GetWARNINT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.WARNINT.Reg) & 0xfffffc00) >> 10
}

// WWDT.WINDOW: Watchdog Window compare value.
func (o *WWDT_Type) SetWINDOW(value uint32) {
	volatile.StoreUint32(&o.WINDOW.Reg, volatile.LoadUint32(&o.WINDOW.Reg)&^(0xffffff)|value)
}
func (o *WWDT_Type) GetWINDOW() uint32 {
	return volatile.LoadUint32(&o.WINDOW.Reg) & 0xffffff
}
func (o *WWDT_Type) SetWINDOW_RESERVED(value uint32) {
	volatile.StoreUint32(&o.WINDOW.Reg, volatile.LoadUint32(&o.WINDOW.Reg)&^(0xff000000)|value<<24)
}
func (o *WWDT_Type) GetWINDOW_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.WINDOW.Reg) & 0xff000000) >> 24
}

// Timer0/1/2/3
type TIMER0_Type struct {
	IR   volatile.Register32    // 0x0
	TCR  volatile.Register32    // 0x4
	TC   volatile.Register32    // 0x8
	PR   volatile.Register32    // 0xC
	PC   volatile.Register32    // 0x10
	MCR  volatile.Register32    // 0x14
	MR   [4]volatile.Register32 // 0x18
	CCR  volatile.Register32    // 0x28
	CR   [2]volatile.Register32 // 0x2C
	_    [8]byte
	EMR  volatile.Register32 // 0x3C
	_    [48]byte
	CTCR volatile.Register32 // 0x70
}

// TIMER0.IR: Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending.
func (o *TIMER0_Type) SetIR_MR0INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x1)|value)
}
func (o *TIMER0_Type) GetIR_MR0INT() uint32 {
	return volatile.LoadUint32(&o.IR.Reg) & 0x1
}
func (o *TIMER0_Type) SetIR_MR1INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x2)|value<<1)
}
func (o *TIMER0_Type) GetIR_MR1INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x2) >> 1
}
func (o *TIMER0_Type) SetIR_MR2INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x4)|value<<2)
}
func (o *TIMER0_Type) GetIR_MR2INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x4) >> 2
}
func (o *TIMER0_Type) SetIR_MR3INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x8)|value<<3)
}
func (o *TIMER0_Type) GetIR_MR3INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x8) >> 3
}
func (o *TIMER0_Type) SetIR_CR0INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x10)|value<<4)
}
func (o *TIMER0_Type) GetIR_CR0INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x10) >> 4
}
func (o *TIMER0_Type) SetIR_CR1INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x20)|value<<5)
}
func (o *TIMER0_Type) GetIR_CR1INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x20) >> 5
}
func (o *TIMER0_Type) SetIR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0xffffffc0)|value<<6)
}
func (o *TIMER0_Type) GetIR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0xffffffc0) >> 6
}

// TIMER0.TCR: Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR.
func (o *TIMER0_Type) SetTCR_CEN(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x1)|value)
}
func (o *TIMER0_Type) GetTCR_CEN() uint32 {
	return volatile.LoadUint32(&o.TCR.Reg) & 0x1
}
func (o *TIMER0_Type) SetTCR_CRST(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x2)|value<<1)
}
func (o *TIMER0_Type) GetTCR_CRST() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x2) >> 1
}
func (o *TIMER0_Type) SetTCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *TIMER0_Type) GetTCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0xfffffffc) >> 2
}

// TIMER0.TC: Timer Counter. The 32 bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR.
func (o *TIMER0_Type) SetTC(value uint32) {
	volatile.StoreUint32(&o.TC.Reg, value)
}
func (o *TIMER0_Type) GetTC() uint32 {
	return volatile.LoadUint32(&o.TC.Reg)
}

// TIMER0.PR: Prescale Register. When the Prescale Counter (PC) is equal to this value, the next clock increments the TC and clears the PC.
func (o *TIMER0_Type) SetPR(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, value)
}
func (o *TIMER0_Type) GetPR() uint32 {
	return volatile.LoadUint32(&o.PR.Reg)
}

// TIMER0.PC: Prescale Counter. The 32 bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface.
func (o *TIMER0_Type) SetPC(value uint32) {
	volatile.StoreUint32(&o.PC.Reg, value)
}
func (o *TIMER0_Type) GetPC() uint32 {
	return volatile.LoadUint32(&o.PC.Reg)
}

// TIMER0.MCR: Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs.
func (o *TIMER0_Type) SetMCR_MR0I(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x1)|value)
}
func (o *TIMER0_Type) GetMCR_MR0I() uint32 {
	return volatile.LoadUint32(&o.MCR.Reg) & 0x1
}
func (o *TIMER0_Type) SetMCR_MR0R(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x2)|value<<1)
}
func (o *TIMER0_Type) GetMCR_MR0R() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x2) >> 1
}
func (o *TIMER0_Type) SetMCR_MR0S(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x4)|value<<2)
}
func (o *TIMER0_Type) GetMCR_MR0S() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x4) >> 2
}
func (o *TIMER0_Type) SetMCR_MR1I(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x8)|value<<3)
}
func (o *TIMER0_Type) GetMCR_MR1I() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x8) >> 3
}
func (o *TIMER0_Type) SetMCR_MR1R(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x10)|value<<4)
}
func (o *TIMER0_Type) GetMCR_MR1R() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x10) >> 4
}
func (o *TIMER0_Type) SetMCR_MR1S(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x20)|value<<5)
}
func (o *TIMER0_Type) GetMCR_MR1S() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x20) >> 5
}
func (o *TIMER0_Type) SetMCR_MR2I(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x40)|value<<6)
}
func (o *TIMER0_Type) GetMCR_MR2I() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x40) >> 6
}
func (o *TIMER0_Type) SetMCR_MR2R(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x80)|value<<7)
}
func (o *TIMER0_Type) GetMCR_MR2R() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x80) >> 7
}
func (o *TIMER0_Type) SetMCR_MR2S(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x100)|value<<8)
}
func (o *TIMER0_Type) GetMCR_MR2S() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x100) >> 8
}
func (o *TIMER0_Type) SetMCR_MR3I(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x200)|value<<9)
}
func (o *TIMER0_Type) GetMCR_MR3I() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x200) >> 9
}
func (o *TIMER0_Type) SetMCR_MR3R(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x400)|value<<10)
}
func (o *TIMER0_Type) GetMCR_MR3R() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x400) >> 10
}
func (o *TIMER0_Type) SetMCR_MR3S(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x800)|value<<11)
}
func (o *TIMER0_Type) GetMCR_MR3S() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x800) >> 11
}
func (o *TIMER0_Type) SetMCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0xfffff000)|value<<12)
}
func (o *TIMER0_Type) GetMCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0xfffff000) >> 12
}

// TIMER0.MR: Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
func (o *TIMER0_Type) SetMR(idx int, value uint32) {
	volatile.StoreUint32(&o.MR[idx].Reg, value)
}
func (o *TIMER0_Type) GetMR(idx int) uint32 {
	return volatile.LoadUint32(&o.MR[idx].Reg)
}

// TIMER0.CCR: Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place.
func (o *TIMER0_Type) SetCCR_CAP0RE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x1)|value)
}
func (o *TIMER0_Type) GetCCR_CAP0RE() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0x1
}
func (o *TIMER0_Type) SetCCR_CAP0FE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x2)|value<<1)
}
func (o *TIMER0_Type) GetCCR_CAP0FE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x2) >> 1
}
func (o *TIMER0_Type) SetCCR_CAP0I(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x4)|value<<2)
}
func (o *TIMER0_Type) GetCCR_CAP0I() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x4) >> 2
}
func (o *TIMER0_Type) SetCCR_CAP1RE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x8)|value<<3)
}
func (o *TIMER0_Type) GetCCR_CAP1RE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x8) >> 3
}
func (o *TIMER0_Type) SetCCR_CAP1FE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x10)|value<<4)
}
func (o *TIMER0_Type) GetCCR_CAP1FE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x10) >> 4
}
func (o *TIMER0_Type) SetCCR_CAP1I(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x20)|value<<5)
}
func (o *TIMER0_Type) GetCCR_CAP1I() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x20) >> 5
}
func (o *TIMER0_Type) SetCCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0xffffffc0)|value<<6)
}
func (o *TIMER0_Type) GetCCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0xffffffc0) >> 6
}

// TIMER0.CR: Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CAPn.0 input.
func (o *TIMER0_Type) SetCR(idx int, value uint32) {
	volatile.StoreUint32(&o.CR[idx].Reg, value)
}
func (o *TIMER0_Type) GetCR(idx int) uint32 {
	return volatile.LoadUint32(&o.CR[idx].Reg)
}

// TIMER0.EMR: External Match Register. The EMR controls the external match pins.
func (o *TIMER0_Type) SetEMR_EM0(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x1)|value)
}
func (o *TIMER0_Type) GetEMR_EM0() uint32 {
	return volatile.LoadUint32(&o.EMR.Reg) & 0x1
}
func (o *TIMER0_Type) SetEMR_EM1(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x2)|value<<1)
}
func (o *TIMER0_Type) GetEMR_EM1() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x2) >> 1
}
func (o *TIMER0_Type) SetEMR_EM2(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x4)|value<<2)
}
func (o *TIMER0_Type) GetEMR_EM2() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x4) >> 2
}
func (o *TIMER0_Type) SetEMR_EM3(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x8)|value<<3)
}
func (o *TIMER0_Type) GetEMR_EM3() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x8) >> 3
}
func (o *TIMER0_Type) SetEMR_EMC0(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x30)|value<<4)
}
func (o *TIMER0_Type) GetEMR_EMC0() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x30) >> 4
}
func (o *TIMER0_Type) SetEMR_EMC1(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0xc0)|value<<6)
}
func (o *TIMER0_Type) GetEMR_EMC1() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0xc0) >> 6
}
func (o *TIMER0_Type) SetEMR_EMC2(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x300)|value<<8)
}
func (o *TIMER0_Type) GetEMR_EMC2() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x300) >> 8
}
func (o *TIMER0_Type) SetEMR_EMC3(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0xc00)|value<<10)
}
func (o *TIMER0_Type) GetEMR_EMC3() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0xc00) >> 10
}
func (o *TIMER0_Type) SetEMR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0xfffff000)|value<<12)
}
func (o *TIMER0_Type) GetEMR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0xfffff000) >> 12
}

// TIMER0.CTCR: Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.
func (o *TIMER0_Type) SetCTCR_CTMODE(value uint32) {
	volatile.StoreUint32(&o.CTCR.Reg, volatile.LoadUint32(&o.CTCR.Reg)&^(0x3)|value)
}
func (o *TIMER0_Type) GetCTCR_CTMODE() uint32 {
	return volatile.LoadUint32(&o.CTCR.Reg) & 0x3
}
func (o *TIMER0_Type) SetCTCR_CINSEL(value uint32) {
	volatile.StoreUint32(&o.CTCR.Reg, volatile.LoadUint32(&o.CTCR.Reg)&^(0xc)|value<<2)
}
func (o *TIMER0_Type) GetCTCR_CINSEL() uint32 {
	return (volatile.LoadUint32(&o.CTCR.Reg) & 0xc) >> 2
}
func (o *TIMER0_Type) SetCTCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTCR.Reg, volatile.LoadUint32(&o.CTCR.Reg)&^(0xfffffff0)|value<<4)
}
func (o *TIMER0_Type) GetCTCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTCR.Reg) & 0xfffffff0) >> 4
}

// UART0/2/3
type UART0_Type struct {
	RBR           volatile.Register32 // 0x0
	DLM           volatile.Register32 // 0x4
	IIR           volatile.Register32 // 0x8
	LCR           volatile.Register32 // 0xC
	_             [4]byte
	LSR           volatile.Register32 // 0x14
	_             [4]byte
	SCR           volatile.Register32 // 0x1C
	ACR           volatile.Register32 // 0x20
	_             [4]byte
	FDR           volatile.Register32 // 0x28
	_             [4]byte
	TER           volatile.Register32 // 0x30
	_             [24]byte
	RS485CTRL     volatile.Register32 // 0x4C
	RS485ADRMATCH volatile.Register32 // 0x50
	RS485DLY      volatile.Register32 // 0x54
}

// UART0.RBR: Receiver Buffer Register. Contains the next received character to be read (DLAB =0).
func (o *UART0_Type) SetRBR(value uint32) {
	volatile.StoreUint32(&o.RBR.Reg, volatile.LoadUint32(&o.RBR.Reg)&^(0xff)|value)
}
func (o *UART0_Type) GetRBR() uint32 {
	return volatile.LoadUint32(&o.RBR.Reg) & 0xff
}
func (o *UART0_Type) SetRBR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RBR.Reg, volatile.LoadUint32(&o.RBR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART0_Type) GetRBR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RBR.Reg) & 0xffffff00) >> 8
}

// UART0.DLM: Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider (DLAB =1).
func (o *UART0_Type) SetDLM_DLMSB(value uint32) {
	volatile.StoreUint32(&o.DLM.Reg, volatile.LoadUint32(&o.DLM.Reg)&^(0xff)|value)
}
func (o *UART0_Type) GetDLM_DLMSB() uint32 {
	return volatile.LoadUint32(&o.DLM.Reg) & 0xff
}
func (o *UART0_Type) SetDLM_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DLM.Reg, volatile.LoadUint32(&o.DLM.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART0_Type) GetDLM_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DLM.Reg) & 0xffffff00) >> 8
}

// UART0.IIR: Interrupt ID Register. Identifies which interrupt(s) are pending.
func (o *UART0_Type) SetIIR_INTSTATUS(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0x1)|value)
}
func (o *UART0_Type) GetIIR_INTSTATUS() uint32 {
	return volatile.LoadUint32(&o.IIR.Reg) & 0x1
}
func (o *UART0_Type) SetIIR_INTID(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0xe)|value<<1)
}
func (o *UART0_Type) GetIIR_INTID() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0xe) >> 1
}
func (o *UART0_Type) SetIIR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0x30)|value<<4)
}
func (o *UART0_Type) GetIIR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0x30) >> 4
}
func (o *UART0_Type) SetIIR_FIFOENABLE(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0xc0)|value<<6)
}
func (o *UART0_Type) GetIIR_FIFOENABLE() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0xc0) >> 6
}
func (o *UART0_Type) SetIIR_ABEOINT(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0x100)|value<<8)
}
func (o *UART0_Type) GetIIR_ABEOINT() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0x100) >> 8
}
func (o *UART0_Type) SetIIR_ABTOINT(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0x200)|value<<9)
}
func (o *UART0_Type) GetIIR_ABTOINT() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0x200) >> 9
}
func (o *UART0_Type) SetIIR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0xfffffc00)|value<<10)
}
func (o *UART0_Type) GetIIR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0xfffffc00) >> 10
}

// UART0.LCR: Line Control Register. Contains controls for frame formatting and break generation.
func (o *UART0_Type) SetLCR_WLS(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x3)|value)
}
func (o *UART0_Type) GetLCR_WLS() uint32 {
	return volatile.LoadUint32(&o.LCR.Reg) & 0x3
}
func (o *UART0_Type) SetLCR_SBS(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x4)|value<<2)
}
func (o *UART0_Type) GetLCR_SBS() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x4) >> 2
}
func (o *UART0_Type) SetLCR_PE(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x8)|value<<3)
}
func (o *UART0_Type) GetLCR_PE() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x8) >> 3
}
func (o *UART0_Type) SetLCR_PS(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x30)|value<<4)
}
func (o *UART0_Type) GetLCR_PS() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x30) >> 4
}
func (o *UART0_Type) SetLCR_BC(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x40)|value<<6)
}
func (o *UART0_Type) GetLCR_BC() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x40) >> 6
}
func (o *UART0_Type) SetLCR_DLAB(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x80)|value<<7)
}
func (o *UART0_Type) GetLCR_DLAB() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x80) >> 7
}
func (o *UART0_Type) SetLCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART0_Type) GetLCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0xffffff00) >> 8
}

// UART0.LSR: Line Status Register. Contains flags for transmit and receive status, including line errors.
func (o *UART0_Type) SetLSR_RDR(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x1)|value)
}
func (o *UART0_Type) GetLSR_RDR() uint32 {
	return volatile.LoadUint32(&o.LSR.Reg) & 0x1
}
func (o *UART0_Type) SetLSR_OE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x2)|value<<1)
}
func (o *UART0_Type) GetLSR_OE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x2) >> 1
}
func (o *UART0_Type) SetLSR_PE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x4)|value<<2)
}
func (o *UART0_Type) GetLSR_PE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x4) >> 2
}
func (o *UART0_Type) SetLSR_FE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x8)|value<<3)
}
func (o *UART0_Type) GetLSR_FE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x8) >> 3
}
func (o *UART0_Type) SetLSR_BI(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x10)|value<<4)
}
func (o *UART0_Type) GetLSR_BI() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x10) >> 4
}
func (o *UART0_Type) SetLSR_THRE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x20)|value<<5)
}
func (o *UART0_Type) GetLSR_THRE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x20) >> 5
}
func (o *UART0_Type) SetLSR_TEMT(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x40)|value<<6)
}
func (o *UART0_Type) GetLSR_TEMT() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x40) >> 6
}
func (o *UART0_Type) SetLSR_RXFE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x80)|value<<7)
}
func (o *UART0_Type) GetLSR_RXFE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x80) >> 7
}
func (o *UART0_Type) SetLSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART0_Type) GetLSR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0xffffff00) >> 8
}

// UART0.SCR: Scratch Pad Register. 8-bit temporary storage for software.
func (o *UART0_Type) SetSCR_PAD(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0xff)|value)
}
func (o *UART0_Type) GetSCR_PAD() uint32 {
	return volatile.LoadUint32(&o.SCR.Reg) & 0xff
}
func (o *UART0_Type) SetSCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART0_Type) GetSCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0xffffff00) >> 8
}

// UART0.ACR: Auto-baud Control Register. Contains controls for the auto-baud feature.
func (o *UART0_Type) SetACR_START(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x1)|value)
}
func (o *UART0_Type) GetACR_START() uint32 {
	return volatile.LoadUint32(&o.ACR.Reg) & 0x1
}
func (o *UART0_Type) SetACR_MODE(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x2)|value<<1)
}
func (o *UART0_Type) GetACR_MODE() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x2) >> 1
}
func (o *UART0_Type) SetACR_AUTORESTART(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x4)|value<<2)
}
func (o *UART0_Type) GetACR_AUTORESTART() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x4) >> 2
}
func (o *UART0_Type) SetACR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0xf8)|value<<3)
}
func (o *UART0_Type) GetACR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0xf8) >> 3
}
func (o *UART0_Type) SetACR_ABEOINTCLR(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x100)|value<<8)
}
func (o *UART0_Type) GetACR_ABEOINTCLR() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x100) >> 8
}
func (o *UART0_Type) SetACR_ABTOINTCLR(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x200)|value<<9)
}
func (o *UART0_Type) GetACR_ABTOINTCLR() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x200) >> 9
}
func (o *UART0_Type) SetACR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0xfffffc00)|value<<10)
}
func (o *UART0_Type) GetACR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0xfffffc00) >> 10
}

// UART0.FDR: Fractional Divider Register. Generates a clock input for the baud rate divider.
func (o *UART0_Type) SetFDR_DIVADDVAL(value uint32) {
	volatile.StoreUint32(&o.FDR.Reg, volatile.LoadUint32(&o.FDR.Reg)&^(0xf)|value)
}
func (o *UART0_Type) GetFDR_DIVADDVAL() uint32 {
	return volatile.LoadUint32(&o.FDR.Reg) & 0xf
}
func (o *UART0_Type) SetFDR_MULVAL(value uint32) {
	volatile.StoreUint32(&o.FDR.Reg, volatile.LoadUint32(&o.FDR.Reg)&^(0xf0)|value<<4)
}
func (o *UART0_Type) GetFDR_MULVAL() uint32 {
	return (volatile.LoadUint32(&o.FDR.Reg) & 0xf0) >> 4
}
func (o *UART0_Type) SetFDR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FDR.Reg, volatile.LoadUint32(&o.FDR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART0_Type) GetFDR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FDR.Reg) & 0xffffff00) >> 8
}

// UART0.TER: Transmit Enable Register. Turns off UART transmitter for use with software flow control.
func (o *UART0_Type) SetTER_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TER.Reg, volatile.LoadUint32(&o.TER.Reg)&^(0x7f)|value)
}
func (o *UART0_Type) GetTER_RESERVED() uint32 {
	return volatile.LoadUint32(&o.TER.Reg) & 0x7f
}
func (o *UART0_Type) SetTER_TXEN(value uint32) {
	volatile.StoreUint32(&o.TER.Reg, volatile.LoadUint32(&o.TER.Reg)&^(0x80)|value<<7)
}
func (o *UART0_Type) GetTER_TXEN() uint32 {
	return (volatile.LoadUint32(&o.TER.Reg) & 0x80) >> 7
}
func (o *UART0_Type) SetTER_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TER.Reg, volatile.LoadUint32(&o.TER.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART0_Type) GetTER_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TER.Reg) & 0xffffff00) >> 8
}

// UART0.RS485CTRL: RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes.
func (o *UART0_Type) SetRS485CTRL_NMMEN(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x1)|value)
}
func (o *UART0_Type) GetRS485CTRL_NMMEN() uint32 {
	return volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x1
}
func (o *UART0_Type) SetRS485CTRL_RXDIS(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x2)|value<<1)
}
func (o *UART0_Type) GetRS485CTRL_RXDIS() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x2) >> 1
}
func (o *UART0_Type) SetRS485CTRL_AADEN(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x4)|value<<2)
}
func (o *UART0_Type) GetRS485CTRL_AADEN() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x4) >> 2
}
func (o *UART0_Type) SetRS485CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x8)|value<<3)
}
func (o *UART0_Type) GetRS485CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x8) >> 3
}
func (o *UART0_Type) SetRS485CTRL_DCTRL(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x10)|value<<4)
}
func (o *UART0_Type) GetRS485CTRL_DCTRL() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x10) >> 4
}
func (o *UART0_Type) SetRS485CTRL_OINV(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x20)|value<<5)
}
func (o *UART0_Type) GetRS485CTRL_OINV() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x20) >> 5
}
func (o *UART0_Type) SetRS485CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0xffffffc0)|value<<6)
}
func (o *UART0_Type) GetRS485CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0xffffffc0) >> 6
}

// UART0.RS485ADRMATCH: RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode.
func (o *UART0_Type) SetRS485ADRMATCH_ADRMATCH(value uint32) {
	volatile.StoreUint32(&o.RS485ADRMATCH.Reg, volatile.LoadUint32(&o.RS485ADRMATCH.Reg)&^(0xff)|value)
}
func (o *UART0_Type) GetRS485ADRMATCH_ADRMATCH() uint32 {
	return volatile.LoadUint32(&o.RS485ADRMATCH.Reg) & 0xff
}
func (o *UART0_Type) SetRS485ADRMATCH_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RS485ADRMATCH.Reg, volatile.LoadUint32(&o.RS485ADRMATCH.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART0_Type) GetRS485ADRMATCH_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RS485ADRMATCH.Reg) & 0xffffff00) >> 8
}

// UART0.RS485DLY: RS-485/EIA-485 direction control delay.
func (o *UART0_Type) SetRS485DLY_DLY(value uint32) {
	volatile.StoreUint32(&o.RS485DLY.Reg, volatile.LoadUint32(&o.RS485DLY.Reg)&^(0xff)|value)
}
func (o *UART0_Type) GetRS485DLY_DLY() uint32 {
	return volatile.LoadUint32(&o.RS485DLY.Reg) & 0xff
}
func (o *UART0_Type) SetRS485DLY_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RS485DLY.Reg, volatile.LoadUint32(&o.RS485DLY.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART0_Type) GetRS485DLY_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RS485DLY.Reg) & 0xffffff00) >> 8
}

// UART1
type UART1_Type struct {
	RBR           volatile.Register32 // 0x0
	DLM           volatile.Register32 // 0x4
	IIR           volatile.Register32 // 0x8
	LCR           volatile.Register32 // 0xC
	MCR           volatile.Register32 // 0x10
	LSR           volatile.Register32 // 0x14
	MSR           volatile.Register32 // 0x18
	SCR           volatile.Register32 // 0x1C
	ACR           volatile.Register32 // 0x20
	_             [4]byte
	FDR           volatile.Register32 // 0x28
	_             [4]byte
	TER           volatile.Register32 // 0x30
	_             [24]byte
	RS485CTRL     volatile.Register32 // 0x4C
	RS485ADRMATCH volatile.Register32 // 0x50
	RS485DLY      volatile.Register32 // 0x54
}

// UART1.RBR: DLAB =0 Receiver Buffer Register. Contains the next received character to be read.
func (o *UART1_Type) SetRBR(value uint32) {
	volatile.StoreUint32(&o.RBR.Reg, volatile.LoadUint32(&o.RBR.Reg)&^(0xff)|value)
}
func (o *UART1_Type) GetRBR() uint32 {
	return volatile.LoadUint32(&o.RBR.Reg) & 0xff
}
func (o *UART1_Type) SetRBR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RBR.Reg, volatile.LoadUint32(&o.RBR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART1_Type) GetRBR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RBR.Reg) & 0xffffff00) >> 8
}

// UART1.DLM: DLAB =1. Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider.
func (o *UART1_Type) SetDLM_DLMSB(value uint32) {
	volatile.StoreUint32(&o.DLM.Reg, volatile.LoadUint32(&o.DLM.Reg)&^(0xff)|value)
}
func (o *UART1_Type) GetDLM_DLMSB() uint32 {
	return volatile.LoadUint32(&o.DLM.Reg) & 0xff
}
func (o *UART1_Type) SetDLM_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DLM.Reg, volatile.LoadUint32(&o.DLM.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART1_Type) GetDLM_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DLM.Reg) & 0xffffff00) >> 8
}

// UART1.IIR: Interrupt ID Register. Identifies which interrupt(s) are pending.
func (o *UART1_Type) SetIIR_INTSTATUS(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0x1)|value)
}
func (o *UART1_Type) GetIIR_INTSTATUS() uint32 {
	return volatile.LoadUint32(&o.IIR.Reg) & 0x1
}
func (o *UART1_Type) SetIIR_INTID(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0xe)|value<<1)
}
func (o *UART1_Type) GetIIR_INTID() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0xe) >> 1
}
func (o *UART1_Type) SetIIR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0x30)|value<<4)
}
func (o *UART1_Type) GetIIR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0x30) >> 4
}
func (o *UART1_Type) SetIIR_FIFOENABLE(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0xc0)|value<<6)
}
func (o *UART1_Type) GetIIR_FIFOENABLE() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0xc0) >> 6
}
func (o *UART1_Type) SetIIR_ABEOINT(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0x100)|value<<8)
}
func (o *UART1_Type) GetIIR_ABEOINT() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0x100) >> 8
}
func (o *UART1_Type) SetIIR_ABTOINT(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0x200)|value<<9)
}
func (o *UART1_Type) GetIIR_ABTOINT() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0x200) >> 9
}
func (o *UART1_Type) SetIIR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0xfffffc00)|value<<10)
}
func (o *UART1_Type) GetIIR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0xfffffc00) >> 10
}

// UART1.LCR: Line Control Register. Contains controls for frame formatting and break generation.
func (o *UART1_Type) SetLCR_WLS(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x3)|value)
}
func (o *UART1_Type) GetLCR_WLS() uint32 {
	return volatile.LoadUint32(&o.LCR.Reg) & 0x3
}
func (o *UART1_Type) SetLCR_SBS(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x4)|value<<2)
}
func (o *UART1_Type) GetLCR_SBS() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x4) >> 2
}
func (o *UART1_Type) SetLCR_PE(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x8)|value<<3)
}
func (o *UART1_Type) GetLCR_PE() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x8) >> 3
}
func (o *UART1_Type) SetLCR_PS(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x30)|value<<4)
}
func (o *UART1_Type) GetLCR_PS() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x30) >> 4
}
func (o *UART1_Type) SetLCR_BC(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x40)|value<<6)
}
func (o *UART1_Type) GetLCR_BC() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x40) >> 6
}
func (o *UART1_Type) SetLCR_DLAB(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x80)|value<<7)
}
func (o *UART1_Type) GetLCR_DLAB() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x80) >> 7
}
func (o *UART1_Type) SetLCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART1_Type) GetLCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0xffffff00) >> 8
}

// UART1.MCR: Modem Control Register. Contains controls for flow control handshaking and loopback mode.
func (o *UART1_Type) SetMCR_DTRCTRL(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x1)|value)
}
func (o *UART1_Type) GetMCR_DTRCTRL() uint32 {
	return volatile.LoadUint32(&o.MCR.Reg) & 0x1
}
func (o *UART1_Type) SetMCR_RTSCTRL(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x2)|value<<1)
}
func (o *UART1_Type) GetMCR_RTSCTRL() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x2) >> 1
}
func (o *UART1_Type) SetMCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0xc)|value<<2)
}
func (o *UART1_Type) GetMCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0xc) >> 2
}
func (o *UART1_Type) SetMCR_LMS(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x10)|value<<4)
}
func (o *UART1_Type) GetMCR_LMS() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x10) >> 4
}
func (o *UART1_Type) SetMCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x20)|value<<5)
}
func (o *UART1_Type) GetMCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x20) >> 5
}
func (o *UART1_Type) SetMCR_RTSEN(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x40)|value<<6)
}
func (o *UART1_Type) GetMCR_RTSEN() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x40) >> 6
}
func (o *UART1_Type) SetMCR_CTSEN(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x80)|value<<7)
}
func (o *UART1_Type) GetMCR_CTSEN() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x80) >> 7
}
func (o *UART1_Type) SetMCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART1_Type) GetMCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0xffffff00) >> 8
}

// UART1.LSR: Line Status Register. Contains flags for transmit and receive status, including line errors.
func (o *UART1_Type) SetLSR_RDR(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x1)|value)
}
func (o *UART1_Type) GetLSR_RDR() uint32 {
	return volatile.LoadUint32(&o.LSR.Reg) & 0x1
}
func (o *UART1_Type) SetLSR_OE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x2)|value<<1)
}
func (o *UART1_Type) GetLSR_OE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x2) >> 1
}
func (o *UART1_Type) SetLSR_PE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x4)|value<<2)
}
func (o *UART1_Type) GetLSR_PE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x4) >> 2
}
func (o *UART1_Type) SetLSR_FE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x8)|value<<3)
}
func (o *UART1_Type) GetLSR_FE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x8) >> 3
}
func (o *UART1_Type) SetLSR_BI(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x10)|value<<4)
}
func (o *UART1_Type) GetLSR_BI() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x10) >> 4
}
func (o *UART1_Type) SetLSR_THRE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x20)|value<<5)
}
func (o *UART1_Type) GetLSR_THRE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x20) >> 5
}
func (o *UART1_Type) SetLSR_TEMT(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x40)|value<<6)
}
func (o *UART1_Type) GetLSR_TEMT() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x40) >> 6
}
func (o *UART1_Type) SetLSR_RXFE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x80)|value<<7)
}
func (o *UART1_Type) GetLSR_RXFE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x80) >> 7
}
func (o *UART1_Type) SetLSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART1_Type) GetLSR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0xffffff00) >> 8
}

// UART1.MSR: Modem Status Register. Contains handshake signal status flags.
func (o *UART1_Type) SetMSR_DCTS(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x1)|value)
}
func (o *UART1_Type) GetMSR_DCTS() uint32 {
	return volatile.LoadUint32(&o.MSR.Reg) & 0x1
}
func (o *UART1_Type) SetMSR_DDSR(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x2)|value<<1)
}
func (o *UART1_Type) GetMSR_DDSR() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x2) >> 1
}
func (o *UART1_Type) SetMSR_TERI(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x4)|value<<2)
}
func (o *UART1_Type) GetMSR_TERI() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x4) >> 2
}
func (o *UART1_Type) SetMSR_DDCD(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x8)|value<<3)
}
func (o *UART1_Type) GetMSR_DDCD() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x8) >> 3
}
func (o *UART1_Type) SetMSR_CTS(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x10)|value<<4)
}
func (o *UART1_Type) GetMSR_CTS() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x10) >> 4
}
func (o *UART1_Type) SetMSR_DSR(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x20)|value<<5)
}
func (o *UART1_Type) GetMSR_DSR() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x20) >> 5
}
func (o *UART1_Type) SetMSR_RI(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x40)|value<<6)
}
func (o *UART1_Type) GetMSR_RI() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x40) >> 6
}
func (o *UART1_Type) SetMSR_DCD(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x80)|value<<7)
}
func (o *UART1_Type) GetMSR_DCD() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x80) >> 7
}
func (o *UART1_Type) SetMSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART1_Type) GetMSR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0xffffff00) >> 8
}

// UART1.SCR: Scratch Pad Register. 8-bit temporary storage for software.
func (o *UART1_Type) SetSCR_Pad(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0xff)|value)
}
func (o *UART1_Type) GetSCR_Pad() uint32 {
	return volatile.LoadUint32(&o.SCR.Reg) & 0xff
}
func (o *UART1_Type) SetSCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART1_Type) GetSCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0xffffff00) >> 8
}

// UART1.ACR: Auto-baud Control Register. Contains controls for the auto-baud feature.
func (o *UART1_Type) SetACR_START(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x1)|value)
}
func (o *UART1_Type) GetACR_START() uint32 {
	return volatile.LoadUint32(&o.ACR.Reg) & 0x1
}
func (o *UART1_Type) SetACR_MODE(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x2)|value<<1)
}
func (o *UART1_Type) GetACR_MODE() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x2) >> 1
}
func (o *UART1_Type) SetACR_AUTORESTART(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x4)|value<<2)
}
func (o *UART1_Type) GetACR_AUTORESTART() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x4) >> 2
}
func (o *UART1_Type) SetACR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0xf8)|value<<3)
}
func (o *UART1_Type) GetACR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0xf8) >> 3
}
func (o *UART1_Type) SetACR_ABEOINTCLR(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x100)|value<<8)
}
func (o *UART1_Type) GetACR_ABEOINTCLR() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x100) >> 8
}
func (o *UART1_Type) SetACR_ABTOINTCLR(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x200)|value<<9)
}
func (o *UART1_Type) GetACR_ABTOINTCLR() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x200) >> 9
}
func (o *UART1_Type) SetACR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0xfffffc00)|value<<10)
}
func (o *UART1_Type) GetACR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0xfffffc00) >> 10
}

// UART1.FDR: Fractional Divider Register. Generates a clock input for the baud rate divider.
func (o *UART1_Type) SetFDR_DIVADDVAL(value uint32) {
	volatile.StoreUint32(&o.FDR.Reg, volatile.LoadUint32(&o.FDR.Reg)&^(0xf)|value)
}
func (o *UART1_Type) GetFDR_DIVADDVAL() uint32 {
	return volatile.LoadUint32(&o.FDR.Reg) & 0xf
}
func (o *UART1_Type) SetFDR_MULVAL(value uint32) {
	volatile.StoreUint32(&o.FDR.Reg, volatile.LoadUint32(&o.FDR.Reg)&^(0xf0)|value<<4)
}
func (o *UART1_Type) GetFDR_MULVAL() uint32 {
	return (volatile.LoadUint32(&o.FDR.Reg) & 0xf0) >> 4
}
func (o *UART1_Type) SetFDR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FDR.Reg, volatile.LoadUint32(&o.FDR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART1_Type) GetFDR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FDR.Reg) & 0xffffff00) >> 8
}

// UART1.TER: Transmit Enable Register. Turns off UART transmitter for use with software flow control.
func (o *UART1_Type) SetTER_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TER.Reg, volatile.LoadUint32(&o.TER.Reg)&^(0x7f)|value)
}
func (o *UART1_Type) GetTER_RESERVED() uint32 {
	return volatile.LoadUint32(&o.TER.Reg) & 0x7f
}
func (o *UART1_Type) SetTER_TXEN(value uint32) {
	volatile.StoreUint32(&o.TER.Reg, volatile.LoadUint32(&o.TER.Reg)&^(0x80)|value<<7)
}
func (o *UART1_Type) GetTER_TXEN() uint32 {
	return (volatile.LoadUint32(&o.TER.Reg) & 0x80) >> 7
}
func (o *UART1_Type) SetTER_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TER.Reg, volatile.LoadUint32(&o.TER.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART1_Type) GetTER_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TER.Reg) & 0xffffff00) >> 8
}

// UART1.RS485CTRL: RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes.
func (o *UART1_Type) SetRS485CTRL_NMMEN(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x1)|value)
}
func (o *UART1_Type) GetRS485CTRL_NMMEN() uint32 {
	return volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x1
}
func (o *UART1_Type) SetRS485CTRL_RXDIS(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x2)|value<<1)
}
func (o *UART1_Type) GetRS485CTRL_RXDIS() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x2) >> 1
}
func (o *UART1_Type) SetRS485CTRL_AADEN(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x4)|value<<2)
}
func (o *UART1_Type) GetRS485CTRL_AADEN() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x4) >> 2
}
func (o *UART1_Type) SetRS485CTRL_SEL(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x8)|value<<3)
}
func (o *UART1_Type) GetRS485CTRL_SEL() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x8) >> 3
}
func (o *UART1_Type) SetRS485CTRL_DCTRL(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x10)|value<<4)
}
func (o *UART1_Type) GetRS485CTRL_DCTRL() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x10) >> 4
}
func (o *UART1_Type) SetRS485CTRL_OINV(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x20)|value<<5)
}
func (o *UART1_Type) GetRS485CTRL_OINV() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x20) >> 5
}
func (o *UART1_Type) SetRS485CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0xffffffc0)|value<<6)
}
func (o *UART1_Type) GetRS485CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0xffffffc0) >> 6
}

// UART1.RS485ADRMATCH: RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode.
func (o *UART1_Type) SetRS485ADRMATCH_ADRMATCH(value uint32) {
	volatile.StoreUint32(&o.RS485ADRMATCH.Reg, volatile.LoadUint32(&o.RS485ADRMATCH.Reg)&^(0xff)|value)
}
func (o *UART1_Type) GetRS485ADRMATCH_ADRMATCH() uint32 {
	return volatile.LoadUint32(&o.RS485ADRMATCH.Reg) & 0xff
}
func (o *UART1_Type) SetRS485ADRMATCH_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RS485ADRMATCH.Reg, volatile.LoadUint32(&o.RS485ADRMATCH.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART1_Type) GetRS485ADRMATCH_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RS485ADRMATCH.Reg) & 0xffffff00) >> 8
}

// UART1.RS485DLY: RS-485/EIA-485 direction control delay.
func (o *UART1_Type) SetRS485DLY_DLY(value uint32) {
	volatile.StoreUint32(&o.RS485DLY.Reg, volatile.LoadUint32(&o.RS485DLY.Reg)&^(0xff)|value)
}
func (o *UART1_Type) GetRS485DLY_DLY() uint32 {
	return volatile.LoadUint32(&o.RS485DLY.Reg) & 0xff
}
func (o *UART1_Type) SetRS485DLY_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RS485DLY.Reg, volatile.LoadUint32(&o.RS485DLY.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART1_Type) GetRS485DLY_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RS485DLY.Reg) & 0xffffff00) >> 8
}

// Pulse Width Modulators (PWM0/1)
type PWM_Type struct {
	IR   volatile.Register32    // 0x0
	TCR  volatile.Register32    // 0x4
	TC   volatile.Register32    // 0x8
	PR   volatile.Register32    // 0xC
	PC   volatile.Register32    // 0x10
	MCR  volatile.Register32    // 0x14
	MR0  volatile.Register32    // 0x18
	MR1  volatile.Register32    // 0x1C
	MR2  volatile.Register32    // 0x20
	MR3  volatile.Register32    // 0x24
	CCR  volatile.Register32    // 0x28
	CR   [2]volatile.Register32 // 0x2C
	_    [12]byte
	MR4  volatile.Register32 // 0x40
	MR5  volatile.Register32 // 0x44
	MR6  volatile.Register32 // 0x48
	PCR  volatile.Register32 // 0x4C
	LER  volatile.Register32 // 0x50
	_    [28]byte
	CTCR volatile.Register32 // 0x70
}

// PWM.IR: Interrupt Register. The IR can be written to clear interrupts, or read to identify which PWM interrupt sources are pending.
func (o *PWM_Type) SetIR_PWMMR0INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetIR_PWMMR0INT() uint32 {
	return volatile.LoadUint32(&o.IR.Reg) & 0x1
}
func (o *PWM_Type) SetIR_PWMMR1INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetIR_PWMMR1INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetIR_PWMMR2INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetIR_PWMMR2INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetIR_PWMMR3INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetIR_PWMMR3INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetIR_PWMCAP0INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetIR_PWMCAP0INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetIR_PWMCAP1INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetIR_PWMCAP1INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetIR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0xc0)|value<<6)
}
func (o *PWM_Type) GetIR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0xc0) >> 6
}
func (o *PWM_Type) SetIR_PWMMR4INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetIR_PWMMR4INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetIR_PWMMR5INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetIR_PWMMR5INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetIR_PWMMR6INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetIR_PWMMR6INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetIR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0xfffff800)|value<<11)
}
func (o *PWM_Type) GetIR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0xfffff800) >> 11
}

// PWM.TCR: Timer Control Register. The TCR is used to control the Timer Counter functions.
func (o *PWM_Type) SetTCR_CE(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetTCR_CE() uint32 {
	return volatile.LoadUint32(&o.TCR.Reg) & 0x1
}
func (o *PWM_Type) SetTCR_CR(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetTCR_CR() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetTCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetTCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetTCR_PWMEN(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetTCR_PWMEN() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetTCR_MDIS(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetTCR_MDIS() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetTCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xffffffe0)|value<<5)
}
func (o *PWM_Type) GetTCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0xffffffe0) >> 5
}

// PWM.TC: Timer Counter. The 32 bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR.
func (o *PWM_Type) SetTC(value uint32) {
	volatile.StoreUint32(&o.TC.Reg, value)
}
func (o *PWM_Type) GetTC() uint32 {
	return volatile.LoadUint32(&o.TC.Reg)
}

// PWM.PR: Prescale Register. Determines how often the PWM counter is incremented.
func (o *PWM_Type) SetPR(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, value)
}
func (o *PWM_Type) GetPR() uint32 {
	return volatile.LoadUint32(&o.PR.Reg)
}

// PWM.PC: Prescale Counter. Prescaler for the main PWM counter.
func (o *PWM_Type) SetPC(value uint32) {
	volatile.StoreUint32(&o.PC.Reg, value)
}
func (o *PWM_Type) GetPC() uint32 {
	return volatile.LoadUint32(&o.PC.Reg)
}

// PWM.MCR: Match Control Register. The MCR is used to control whether an interrupt is generated and if the PWM counter is reset when a Match occurs.
func (o *PWM_Type) SetMCR_PWMMR0I(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetMCR_PWMMR0I() uint32 {
	return volatile.LoadUint32(&o.MCR.Reg) & 0x1
}
func (o *PWM_Type) SetMCR_PWMMR0R(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetMCR_PWMMR0R() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetMCR_PWMMR0S(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetMCR_PWMMR0S() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetMCR_PWMMR1I(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetMCR_PWMMR1I() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetMCR_PWMMR1R(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetMCR_PWMMR1R() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetMCR_PWMMR1S(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetMCR_PWMMR1S() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetMCR_PWMMR2I(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetMCR_PWMMR2I() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetMCR_PWMMR2R(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetMCR_PWMMR2R() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetMCR_PWMMR2S(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetMCR_PWMMR2S() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetMCR_PWMMR3I(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetMCR_PWMMR3I() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetMCR_PWMMR3R(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetMCR_PWMMR3R() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetMCR_PWMMR3S(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetMCR_PWMMR3S() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetMCR_PWMMR4I(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetMCR_PWMMR4I() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetMCR_PWMMR4R(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetMCR_PWMMR4R() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetMCR_PWMMR4S(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetMCR_PWMMR4S() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x4000) >> 14
}
func (o *PWM_Type) SetMCR_PWMMR5I(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetMCR_PWMMR5I() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x8000) >> 15
}
func (o *PWM_Type) SetMCR_PWMMR5R(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x10000)|value<<16)
}
func (o *PWM_Type) GetMCR_PWMMR5R() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x10000) >> 16
}
func (o *PWM_Type) SetMCR_PWMMR5S(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x20000)|value<<17)
}
func (o *PWM_Type) GetMCR_PWMMR5S() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x20000) >> 17
}
func (o *PWM_Type) SetMCR_PWMMR6I(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x40000)|value<<18)
}
func (o *PWM_Type) GetMCR_PWMMR6I() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x40000) >> 18
}
func (o *PWM_Type) SetMCR_PWMMR6R(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x80000)|value<<19)
}
func (o *PWM_Type) GetMCR_PWMMR6R() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x80000) >> 19
}
func (o *PWM_Type) SetMCR_PWMMR6S(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x100000)|value<<20)
}
func (o *PWM_Type) GetMCR_PWMMR6S() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x100000) >> 20
}
func (o *PWM_Type) SetMCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0xffe00000)|value<<21)
}
func (o *PWM_Type) GetMCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0xffe00000) >> 21
}

// PWM.MR0: Match Register. Match registers are continuously compared to the PWM counter in order to control PWM output edges.
func (o *PWM_Type) SetMR0(value uint32) {
	volatile.StoreUint32(&o.MR0.Reg, value)
}
func (o *PWM_Type) GetMR0() uint32 {
	return volatile.LoadUint32(&o.MR0.Reg)
}

// PWM.MR1: Match Register. Match registers are continuously compared to the PWM counter in order to control PWM output edges.
func (o *PWM_Type) SetMR1(value uint32) {
	volatile.StoreUint32(&o.MR1.Reg, value)
}
func (o *PWM_Type) GetMR1() uint32 {
	return volatile.LoadUint32(&o.MR1.Reg)
}

// PWM.MR2: Match Register. Match registers are continuously compared to the PWM counter in order to control PWM output edges.
func (o *PWM_Type) SetMR2(value uint32) {
	volatile.StoreUint32(&o.MR2.Reg, value)
}
func (o *PWM_Type) GetMR2() uint32 {
	return volatile.LoadUint32(&o.MR2.Reg)
}

// PWM.MR3: Match Register. Match registers are continuously compared to the PWM counter in order to control PWM output edges.
func (o *PWM_Type) SetMR3(value uint32) {
	volatile.StoreUint32(&o.MR3.Reg, value)
}
func (o *PWM_Type) GetMR3() uint32 {
	return volatile.LoadUint32(&o.MR3.Reg)
}

// PWM.CCR: Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated for a capture event.
func (o *PWM_Type) SetCCR_CAP0_R(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetCCR_CAP0_R() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0x1
}
func (o *PWM_Type) SetCCR_CAP0_F(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetCCR_CAP0_F() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetCCR_CAP0_I(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetCCR_CAP0_I() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetCCR_CAP1_R(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetCCR_CAP1_R() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetCCR_CAP1_F(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetCCR_CAP1_F() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetCCR_CAP1_I(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetCCR_CAP1_I() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetCCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0xffffffc0)|value<<6)
}
func (o *PWM_Type) GetCCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0xffffffc0) >> 6
}

// PWM.CR: PWM Control Register. Enables PWM outputs and selects either single edge or double edge controlled PWM outputs.
func (o *PWM_Type) SetCR_RESERVED(idx int, value uint32) {
	volatile.StoreUint32(&o.CR[idx].Reg, volatile.LoadUint32(&o.CR[idx].Reg)&^(0x3)|value)
}
func (o *PWM_Type) GetCR_RESERVED(idx int) uint32 {
	return volatile.LoadUint32(&o.CR[idx].Reg) & 0x3
}
func (o *PWM_Type) SetCR_PWMSEL2(idx int, value uint32) {
	volatile.StoreUint32(&o.CR[idx].Reg, volatile.LoadUint32(&o.CR[idx].Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetCR_PWMSEL2(idx int) uint32 {
	return (volatile.LoadUint32(&o.CR[idx].Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetCR_PWMSEL3(idx int, value uint32) {
	volatile.StoreUint32(&o.CR[idx].Reg, volatile.LoadUint32(&o.CR[idx].Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetCR_PWMSEL3(idx int) uint32 {
	return (volatile.LoadUint32(&o.CR[idx].Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetCR_PWMSEL4(idx int, value uint32) {
	volatile.StoreUint32(&o.CR[idx].Reg, volatile.LoadUint32(&o.CR[idx].Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetCR_PWMSEL4(idx int) uint32 {
	return (volatile.LoadUint32(&o.CR[idx].Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetCR_PWMSEL5(idx int, value uint32) {
	volatile.StoreUint32(&o.CR[idx].Reg, volatile.LoadUint32(&o.CR[idx].Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetCR_PWMSEL5(idx int) uint32 {
	return (volatile.LoadUint32(&o.CR[idx].Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetCR_PWMSEL6(idx int, value uint32) {
	volatile.StoreUint32(&o.CR[idx].Reg, volatile.LoadUint32(&o.CR[idx].Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetCR_PWMSEL6(idx int) uint32 {
	return (volatile.LoadUint32(&o.CR[idx].Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetCR_RESERVED(idx int, value uint32) {
	volatile.StoreUint32(&o.CR[idx].Reg, volatile.LoadUint32(&o.CR[idx].Reg)&^(0x180)|value<<7)
}
func (o *PWM_Type) GetCR_RESERVED(idx int) uint32 {
	return (volatile.LoadUint32(&o.CR[idx].Reg) & 0x180) >> 7
}
func (o *PWM_Type) SetCR_PWMENA1(idx int, value uint32) {
	volatile.StoreUint32(&o.CR[idx].Reg, volatile.LoadUint32(&o.CR[idx].Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetCR_PWMENA1(idx int) uint32 {
	return (volatile.LoadUint32(&o.CR[idx].Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetCR_PWMENA2(idx int, value uint32) {
	volatile.StoreUint32(&o.CR[idx].Reg, volatile.LoadUint32(&o.CR[idx].Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetCR_PWMENA2(idx int) uint32 {
	return (volatile.LoadUint32(&o.CR[idx].Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetCR_PWMENA3(idx int, value uint32) {
	volatile.StoreUint32(&o.CR[idx].Reg, volatile.LoadUint32(&o.CR[idx].Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetCR_PWMENA3(idx int) uint32 {
	return (volatile.LoadUint32(&o.CR[idx].Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetCR_PWMENA4(idx int, value uint32) {
	volatile.StoreUint32(&o.CR[idx].Reg, volatile.LoadUint32(&o.CR[idx].Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetCR_PWMENA4(idx int) uint32 {
	return (volatile.LoadUint32(&o.CR[idx].Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetCR_PWMENA5(idx int, value uint32) {
	volatile.StoreUint32(&o.CR[idx].Reg, volatile.LoadUint32(&o.CR[idx].Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetCR_PWMENA5(idx int) uint32 {
	return (volatile.LoadUint32(&o.CR[idx].Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetCR_PWMENA6(idx int, value uint32) {
	volatile.StoreUint32(&o.CR[idx].Reg, volatile.LoadUint32(&o.CR[idx].Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetCR_PWMENA6(idx int) uint32 {
	return (volatile.LoadUint32(&o.CR[idx].Reg) & 0x4000) >> 14
}
func (o *PWM_Type) SetCR_RESERVED(idx int, value uint32) {
	volatile.StoreUint32(&o.CR[idx].Reg, volatile.LoadUint32(&o.CR[idx].Reg)&^(0xffff8000)|value<<15)
}
func (o *PWM_Type) GetCR_RESERVED(idx int) uint32 {
	return (volatile.LoadUint32(&o.CR[idx].Reg) & 0xffff8000) >> 15
}

// PWM.MR4: Match Register. Match registers are continuously compared to the PWM counter in order to control PWM output edges.
func (o *PWM_Type) SetMR4(value uint32) {
	volatile.StoreUint32(&o.MR4.Reg, value)
}
func (o *PWM_Type) GetMR4() uint32 {
	return volatile.LoadUint32(&o.MR4.Reg)
}

// PWM.MR5: Match Register. Match registers are continuously compared to the PWM counter in order to control PWM output edges.
func (o *PWM_Type) SetMR5(value uint32) {
	volatile.StoreUint32(&o.MR5.Reg, value)
}
func (o *PWM_Type) GetMR5() uint32 {
	return volatile.LoadUint32(&o.MR5.Reg)
}

// PWM.MR6: Match Register. Match registers are continuously compared to the PWM counter in order to control PWM output edges.
func (o *PWM_Type) SetMR6(value uint32) {
	volatile.StoreUint32(&o.MR6.Reg, value)
}
func (o *PWM_Type) GetMR6() uint32 {
	return volatile.LoadUint32(&o.MR6.Reg)
}

// PWM.PCR: PWM Control Register. Enables PWM outputs and selects either single edge or double edge controlled PWM outputs.
func (o *PWM_Type) SetPCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x3)|value)
}
func (o *PWM_Type) GetPCR_RESERVED() uint32 {
	return volatile.LoadUint32(&o.PCR.Reg) & 0x3
}
func (o *PWM_Type) SetPCR_PWMSEL2(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetPCR_PWMSEL2() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetPCR_PWMSEL3(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetPCR_PWMSEL3() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetPCR_PWMSEL4(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetPCR_PWMSEL4() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetPCR_PWMSEL5(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetPCR_PWMSEL5() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetPCR_PWMSEL6(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetPCR_PWMSEL6() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetPCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x180)|value<<7)
}
func (o *PWM_Type) GetPCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x180) >> 7
}
func (o *PWM_Type) SetPCR_PWMENA1(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetPCR_PWMENA1() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetPCR_PWMENA2(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetPCR_PWMENA2() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetPCR_PWMENA3(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetPCR_PWMENA3() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetPCR_PWMENA4(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetPCR_PWMENA4() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetPCR_PWMENA5(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetPCR_PWMENA5() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetPCR_PWMENA6(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetPCR_PWMENA6() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0x4000) >> 14
}
func (o *PWM_Type) SetPCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PCR.Reg, volatile.LoadUint32(&o.PCR.Reg)&^(0xffff8000)|value<<15)
}
func (o *PWM_Type) GetPCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PCR.Reg) & 0xffff8000) >> 15
}

// PWM.LER: Load Enable Register. Enables use of updated PWM match values.
func (o *PWM_Type) SetLER_MAT0LATCHEN(value uint32) {
	volatile.StoreUint32(&o.LER.Reg, volatile.LoadUint32(&o.LER.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetLER_MAT0LATCHEN() uint32 {
	return volatile.LoadUint32(&o.LER.Reg) & 0x1
}
func (o *PWM_Type) SetLER_MAT1LATCHEN(value uint32) {
	volatile.StoreUint32(&o.LER.Reg, volatile.LoadUint32(&o.LER.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetLER_MAT1LATCHEN() uint32 {
	return (volatile.LoadUint32(&o.LER.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetLER_MAT2LATCHEN(value uint32) {
	volatile.StoreUint32(&o.LER.Reg, volatile.LoadUint32(&o.LER.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetLER_MAT2LATCHEN() uint32 {
	return (volatile.LoadUint32(&o.LER.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetLER_MAT3LATCHEN(value uint32) {
	volatile.StoreUint32(&o.LER.Reg, volatile.LoadUint32(&o.LER.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetLER_MAT3LATCHEN() uint32 {
	return (volatile.LoadUint32(&o.LER.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetLER_MAT4LATCHEN(value uint32) {
	volatile.StoreUint32(&o.LER.Reg, volatile.LoadUint32(&o.LER.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetLER_MAT4LATCHEN() uint32 {
	return (volatile.LoadUint32(&o.LER.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetLER_MAT5LATCHEN(value uint32) {
	volatile.StoreUint32(&o.LER.Reg, volatile.LoadUint32(&o.LER.Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetLER_MAT5LATCHEN() uint32 {
	return (volatile.LoadUint32(&o.LER.Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetLER_MAT6LATCHEN(value uint32) {
	volatile.StoreUint32(&o.LER.Reg, volatile.LoadUint32(&o.LER.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetLER_MAT6LATCHEN() uint32 {
	return (volatile.LoadUint32(&o.LER.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetLER_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LER.Reg, volatile.LoadUint32(&o.LER.Reg)&^(0xffffff80)|value<<7)
}
func (o *PWM_Type) GetLER_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.LER.Reg) & 0xffffff80) >> 7
}

// PWM.CTCR: Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.
func (o *PWM_Type) SetCTCR_MOD(value uint32) {
	volatile.StoreUint32(&o.CTCR.Reg, volatile.LoadUint32(&o.CTCR.Reg)&^(0x3)|value)
}
func (o *PWM_Type) GetCTCR_MOD() uint32 {
	return volatile.LoadUint32(&o.CTCR.Reg) & 0x3
}
func (o *PWM_Type) SetCTCR_CIS(value uint32) {
	volatile.StoreUint32(&o.CTCR.Reg, volatile.LoadUint32(&o.CTCR.Reg)&^(0xc)|value<<2)
}
func (o *PWM_Type) GetCTCR_CIS() uint32 {
	return (volatile.LoadUint32(&o.CTCR.Reg) & 0xc) >> 2
}
func (o *PWM_Type) SetCTCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTCR.Reg, volatile.LoadUint32(&o.CTCR.Reg)&^(0xfffffff0)|value<<4)
}
func (o *PWM_Type) GetCTCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTCR.Reg) & 0xfffffff0) >> 4
}

// I2C bus interface
type I2C_Type struct {
	CONSET      volatile.Register32    // 0x0
	STAT        volatile.Register32    // 0x4
	DAT         volatile.Register32    // 0x8
	ADR0        volatile.Register32    // 0xC
	SCLH        volatile.Register32    // 0x10
	SCLL        volatile.Register32    // 0x14
	CONCLR      volatile.Register32    // 0x18
	MMCTRL      volatile.Register32    // 0x1C
	ADR1        volatile.Register32    // 0x20
	ADR2        volatile.Register32    // 0x24
	ADR3        volatile.Register32    // 0x28
	DATA_BUFFER volatile.Register32    // 0x2C
	MASK        [4]volatile.Register32 // 0x30
}

// I2C.CONSET: I2C Control Set Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is set. Writing a zero has no effect on the corresponding bit in the I2C control register.
func (o *I2C_Type) SetCONSET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONSET.Reg, volatile.LoadUint32(&o.CONSET.Reg)&^(0x3)|value)
}
func (o *I2C_Type) GetCONSET_RESERVED() uint32 {
	return volatile.LoadUint32(&o.CONSET.Reg) & 0x3
}
func (o *I2C_Type) SetCONSET_AA(value uint32) {
	volatile.StoreUint32(&o.CONSET.Reg, volatile.LoadUint32(&o.CONSET.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetCONSET_AA() uint32 {
	return (volatile.LoadUint32(&o.CONSET.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetCONSET_SI(value uint32) {
	volatile.StoreUint32(&o.CONSET.Reg, volatile.LoadUint32(&o.CONSET.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetCONSET_SI() uint32 {
	return (volatile.LoadUint32(&o.CONSET.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetCONSET_STO(value uint32) {
	volatile.StoreUint32(&o.CONSET.Reg, volatile.LoadUint32(&o.CONSET.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetCONSET_STO() uint32 {
	return (volatile.LoadUint32(&o.CONSET.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetCONSET_STA(value uint32) {
	volatile.StoreUint32(&o.CONSET.Reg, volatile.LoadUint32(&o.CONSET.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetCONSET_STA() uint32 {
	return (volatile.LoadUint32(&o.CONSET.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetCONSET_I2EN(value uint32) {
	volatile.StoreUint32(&o.CONSET.Reg, volatile.LoadUint32(&o.CONSET.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetCONSET_I2EN() uint32 {
	return (volatile.LoadUint32(&o.CONSET.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetCONSET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONSET.Reg, volatile.LoadUint32(&o.CONSET.Reg)&^(0xffffff80)|value<<7)
}
func (o *I2C_Type) GetCONSET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONSET.Reg) & 0xffffff80) >> 7
}

// I2C.STAT: I2C Status Register. During I2C operation, this register provides detailed status codes that allow software to determine the next action needed.
func (o *I2C_Type) SetSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x7)|value)
}
func (o *I2C_Type) GetSTAT_RESERVED() uint32 {
	return volatile.LoadUint32(&o.STAT.Reg) & 0x7
}
func (o *I2C_Type) SetSTAT_Status(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0xf8)|value<<3)
}
func (o *I2C_Type) GetSTAT_Status() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0xf8) >> 3
}
func (o *I2C_Type) SetSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0xffffff00) >> 8
}

// I2C.DAT: I2C Data Register. During master or slave transmit mode, data to be transmitted is written to this register. During master or slave receive mode, data that has been received may be read from this register.
func (o *I2C_Type) SetDAT_Data(value uint32) {
	volatile.StoreUint32(&o.DAT.Reg, volatile.LoadUint32(&o.DAT.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetDAT_Data() uint32 {
	return volatile.LoadUint32(&o.DAT.Reg) & 0xff
}
func (o *I2C_Type) SetDAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DAT.Reg, volatile.LoadUint32(&o.DAT.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetDAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DAT.Reg) & 0xffffff00) >> 8
}

// I2C.ADR0: I2C Slave Address Register 0. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
func (o *I2C_Type) SetADR0_GC(value uint32) {
	volatile.StoreUint32(&o.ADR0.Reg, volatile.LoadUint32(&o.ADR0.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetADR0_GC() uint32 {
	return volatile.LoadUint32(&o.ADR0.Reg) & 0x1
}
func (o *I2C_Type) SetADR0_Address(value uint32) {
	volatile.StoreUint32(&o.ADR0.Reg, volatile.LoadUint32(&o.ADR0.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetADR0_Address() uint32 {
	return (volatile.LoadUint32(&o.ADR0.Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetADR0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ADR0.Reg, volatile.LoadUint32(&o.ADR0.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetADR0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ADR0.Reg) & 0xffffff00) >> 8
}

// I2C.SCLH: SCH Duty Cycle Register High Half Word. Determines the high time of the I2C clock.
func (o *I2C_Type) SetSCLH(value uint32) {
	volatile.StoreUint32(&o.SCLH.Reg, volatile.LoadUint32(&o.SCLH.Reg)&^(0xffff)|value)
}
func (o *I2C_Type) GetSCLH() uint32 {
	return volatile.LoadUint32(&o.SCLH.Reg) & 0xffff
}
func (o *I2C_Type) SetSCLH_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SCLH.Reg, volatile.LoadUint32(&o.SCLH.Reg)&^(0xffff0000)|value<<16)
}
func (o *I2C_Type) GetSCLH_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SCLH.Reg) & 0xffff0000) >> 16
}

// I2C.SCLL: SCL Duty Cycle Register Low Half Word. Determines the low time of the I2C clock. SCLL and SCLH together determine the clock frequency generated by an I2C master and certain times used in slave mode.
func (o *I2C_Type) SetSCLL(value uint32) {
	volatile.StoreUint32(&o.SCLL.Reg, volatile.LoadUint32(&o.SCLL.Reg)&^(0xffff)|value)
}
func (o *I2C_Type) GetSCLL() uint32 {
	return volatile.LoadUint32(&o.SCLL.Reg) & 0xffff
}
func (o *I2C_Type) SetSCLL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SCLL.Reg, volatile.LoadUint32(&o.SCLL.Reg)&^(0xffff0000)|value<<16)
}
func (o *I2C_Type) GetSCLL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SCLL.Reg) & 0xffff0000) >> 16
}

// I2C.CONCLR: I2C Control Clear Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is cleared. Writing a zero has no effect on the corresponding bit in the I2C control register.
func (o *I2C_Type) SetCONCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONCLR.Reg, volatile.LoadUint32(&o.CONCLR.Reg)&^(0x3)|value)
}
func (o *I2C_Type) GetCONCLR_RESERVED() uint32 {
	return volatile.LoadUint32(&o.CONCLR.Reg) & 0x3
}
func (o *I2C_Type) SetCONCLR_AAC(value uint32) {
	volatile.StoreUint32(&o.CONCLR.Reg, volatile.LoadUint32(&o.CONCLR.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetCONCLR_AAC() uint32 {
	return (volatile.LoadUint32(&o.CONCLR.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetCONCLR_SIC(value uint32) {
	volatile.StoreUint32(&o.CONCLR.Reg, volatile.LoadUint32(&o.CONCLR.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetCONCLR_SIC() uint32 {
	return (volatile.LoadUint32(&o.CONCLR.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetCONCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONCLR.Reg, volatile.LoadUint32(&o.CONCLR.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetCONCLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONCLR.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetCONCLR_STAC(value uint32) {
	volatile.StoreUint32(&o.CONCLR.Reg, volatile.LoadUint32(&o.CONCLR.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetCONCLR_STAC() uint32 {
	return (volatile.LoadUint32(&o.CONCLR.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetCONCLR_I2ENC(value uint32) {
	volatile.StoreUint32(&o.CONCLR.Reg, volatile.LoadUint32(&o.CONCLR.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetCONCLR_I2ENC() uint32 {
	return (volatile.LoadUint32(&o.CONCLR.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetCONCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONCLR.Reg, volatile.LoadUint32(&o.CONCLR.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetCONCLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONCLR.Reg) & 0x80) >> 7
}
func (o *I2C_Type) SetCONCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONCLR.Reg, volatile.LoadUint32(&o.CONCLR.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetCONCLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONCLR.Reg) & 0xffffff00) >> 8
}

// I2C.MMCTRL: Monitor mode control register.
func (o *I2C_Type) SetMMCTRL_MM_ENA(value uint32) {
	volatile.StoreUint32(&o.MMCTRL.Reg, volatile.LoadUint32(&o.MMCTRL.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetMMCTRL_MM_ENA() uint32 {
	return volatile.LoadUint32(&o.MMCTRL.Reg) & 0x1
}
func (o *I2C_Type) SetMMCTRL_ENA_SCL(value uint32) {
	volatile.StoreUint32(&o.MMCTRL.Reg, volatile.LoadUint32(&o.MMCTRL.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetMMCTRL_ENA_SCL() uint32 {
	return (volatile.LoadUint32(&o.MMCTRL.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetMMCTRL_MATCH_ALL(value uint32) {
	volatile.StoreUint32(&o.MMCTRL.Reg, volatile.LoadUint32(&o.MMCTRL.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetMMCTRL_MATCH_ALL() uint32 {
	return (volatile.LoadUint32(&o.MMCTRL.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetMMCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MMCTRL.Reg, volatile.LoadUint32(&o.MMCTRL.Reg)&^(0xfffffff8)|value<<3)
}
func (o *I2C_Type) GetMMCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MMCTRL.Reg) & 0xfffffff8) >> 3
}

// I2C.ADR1: I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
func (o *I2C_Type) SetADR1_GC(value uint32) {
	volatile.StoreUint32(&o.ADR1.Reg, volatile.LoadUint32(&o.ADR1.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetADR1_GC() uint32 {
	return volatile.LoadUint32(&o.ADR1.Reg) & 0x1
}
func (o *I2C_Type) SetADR1_Address(value uint32) {
	volatile.StoreUint32(&o.ADR1.Reg, volatile.LoadUint32(&o.ADR1.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetADR1_Address() uint32 {
	return (volatile.LoadUint32(&o.ADR1.Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetADR1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ADR1.Reg, volatile.LoadUint32(&o.ADR1.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetADR1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ADR1.Reg) & 0xffffff00) >> 8
}

// I2C.ADR2: I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
func (o *I2C_Type) SetADR2_GC(value uint32) {
	volatile.StoreUint32(&o.ADR2.Reg, volatile.LoadUint32(&o.ADR2.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetADR2_GC() uint32 {
	return volatile.LoadUint32(&o.ADR2.Reg) & 0x1
}
func (o *I2C_Type) SetADR2_Address(value uint32) {
	volatile.StoreUint32(&o.ADR2.Reg, volatile.LoadUint32(&o.ADR2.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetADR2_Address() uint32 {
	return (volatile.LoadUint32(&o.ADR2.Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetADR2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ADR2.Reg, volatile.LoadUint32(&o.ADR2.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetADR2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ADR2.Reg) & 0xffffff00) >> 8
}

// I2C.ADR3: I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
func (o *I2C_Type) SetADR3_GC(value uint32) {
	volatile.StoreUint32(&o.ADR3.Reg, volatile.LoadUint32(&o.ADR3.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetADR3_GC() uint32 {
	return volatile.LoadUint32(&o.ADR3.Reg) & 0x1
}
func (o *I2C_Type) SetADR3_Address(value uint32) {
	volatile.StoreUint32(&o.ADR3.Reg, volatile.LoadUint32(&o.ADR3.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetADR3_Address() uint32 {
	return (volatile.LoadUint32(&o.ADR3.Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetADR3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ADR3.Reg, volatile.LoadUint32(&o.ADR3.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetADR3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ADR3.Reg) & 0xffffff00) >> 8
}

// I2C.DATA_BUFFER: Data buffer register. The contents of the 8 MSBs of the DAT shift register will be transferred to the DATA_BUFFER automatically after every nine bits (8 bits of data plus ACK or NACK) has been received on the bus.
func (o *I2C_Type) SetDATA_BUFFER_Data(value uint32) {
	volatile.StoreUint32(&o.DATA_BUFFER.Reg, volatile.LoadUint32(&o.DATA_BUFFER.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetDATA_BUFFER_Data() uint32 {
	return volatile.LoadUint32(&o.DATA_BUFFER.Reg) & 0xff
}
func (o *I2C_Type) SetDATA_BUFFER_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DATA_BUFFER.Reg, volatile.LoadUint32(&o.DATA_BUFFER.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetDATA_BUFFER_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DATA_BUFFER.Reg) & 0xffffff00) >> 8
}

// I2C.MASK: I2C Slave address mask register
func (o *I2C_Type) SetMASK_RESERVED(idx int, value uint32) {
	volatile.StoreUint32(&o.MASK[idx].Reg, volatile.LoadUint32(&o.MASK[idx].Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetMASK_RESERVED(idx int) uint32 {
	return volatile.LoadUint32(&o.MASK[idx].Reg) & 0x1
}
func (o *I2C_Type) SetMASK(idx int, value uint32) {
	volatile.StoreUint32(&o.MASK[idx].Reg, volatile.LoadUint32(&o.MASK[idx].Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetMASK(idx int) uint32 {
	return (volatile.LoadUint32(&o.MASK[idx].Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetMASK_RESERVED(idx int, value uint32) {
	volatile.StoreUint32(&o.MASK[idx].Reg, volatile.LoadUint32(&o.MASK[idx].Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetMASK_RESERVED(idx int) uint32 {
	return (volatile.LoadUint32(&o.MASK[idx].Reg) & 0xffffff00) >> 8
}

// Comparators
type COMPARATOR_Type struct {
	CTRL  volatile.Register32 // 0x0
	CTRL0 volatile.Register32 // 0x4
	CTRL1 volatile.Register32 // 0x8
}

// COMPARATOR.CTRL: Comparator block control register
func (o *COMPARATOR_Type) SetCTRL_CMP_PD_IREF(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x3)|value)
}
func (o *COMPARATOR_Type) GetCTRL_CMP_PD_IREF() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x3
}
func (o *COMPARATOR_Type) SetCTRL_CMP_PD_VBG(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xc)|value<<2)
}
func (o *COMPARATOR_Type) GetCTRL_CMP_PD_VBG() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xc) >> 2
}
func (o *COMPARATOR_Type) SetCTRL_CMP_VTEMP(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x30)|value<<4)
}
func (o *COMPARATOR_Type) GetCTRL_CMP_VTEMP() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x30) >> 4
}
func (o *COMPARATOR_Type) SetCTRL_CMP_TEMPSEN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xc0)|value<<6)
}
func (o *COMPARATOR_Type) GetCTRL_CMP_TEMPSEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xc0) >> 6
}
func (o *COMPARATOR_Type) SetCTRL_CMP_ROSCCTL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x100)|value<<8)
}
func (o *COMPARATOR_Type) GetCTRL_CMP_ROSCCTL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x100) >> 8
}
func (o *COMPARATOR_Type) SetCTRL_CMP_EXT_RESET(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x200)|value<<9)
}
func (o *COMPARATOR_Type) GetCTRL_CMP_EXT_RESET() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x200) >> 9
}
func (o *COMPARATOR_Type) SetCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xc00)|value<<10)
}
func (o *COMPARATOR_Type) GetCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xc00) >> 10
}
func (o *COMPARATOR_Type) SetCTRL_CMP_T0CAP2(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1000)|value<<12)
}
func (o *COMPARATOR_Type) GetCTRL_CMP_T0CAP2() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x1000) >> 12
}
func (o *COMPARATOR_Type) SetCTRL_CMP_T0CAP3(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2000)|value<<13)
}
func (o *COMPARATOR_Type) GetCTRL_CMP_T0CAP3() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2000) >> 13
}
func (o *COMPARATOR_Type) SetCTRL_CMP_T1CAP2(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *COMPARATOR_Type) GetCTRL_CMP_T1CAP2() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4000) >> 14
}
func (o *COMPARATOR_Type) SetCTRL_CMP_T1CAP3(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8000)|value<<15)
}
func (o *COMPARATOR_Type) GetCTRL_CMP_T1CAP3() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8000) >> 15
}
func (o *COMPARATOR_Type) SetCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xffff0000)|value<<16)
}
func (o *COMPARATOR_Type) GetCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xffff0000) >> 16
}

// COMPARATOR.CTRL0: Comparator 0 control register
func (o *COMPARATOR_Type) SetCTRL0_CMP0_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x3)|value)
}
func (o *COMPARATOR_Type) GetCTRL0_CMP0_EN() uint32 {
	return volatile.LoadUint32(&o.CTRL0.Reg) & 0x3
}
func (o *COMPARATOR_Type) SetCTRL0_CMP0_OE(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x4)|value<<2)
}
func (o *COMPARATOR_Type) GetCTRL0_CMP0_OE() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0x4) >> 2
}
func (o *COMPARATOR_Type) SetCTRL0_CMP0_STAT(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x8)|value<<3)
}
func (o *COMPARATOR_Type) GetCTRL0_CMP0_STAT() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0x8) >> 3
}
func (o *COMPARATOR_Type) SetCTRL0_CMP0_VM(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x70)|value<<4)
}
func (o *COMPARATOR_Type) GetCTRL0_CMP0_VM() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0x70) >> 4
}
func (o *COMPARATOR_Type) SetCTRL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x80)|value<<7)
}
func (o *COMPARATOR_Type) GetCTRL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0x80) >> 7
}
func (o *COMPARATOR_Type) SetCTRL0_CMP0_VP(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x700)|value<<8)
}
func (o *COMPARATOR_Type) GetCTRL0_CMP0_VP() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0x700) >> 8
}
func (o *COMPARATOR_Type) SetCTRL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x800)|value<<11)
}
func (o *COMPARATOR_Type) GetCTRL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0x800) >> 11
}
func (o *COMPARATOR_Type) SetCTRL0_CMP0_SYNC(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x1000)|value<<12)
}
func (o *COMPARATOR_Type) GetCTRL0_CMP0_SYNC() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0x1000) >> 12
}
func (o *COMPARATOR_Type) SetCTRL0_CMP0_HYS(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x6000)|value<<13)
}
func (o *COMPARATOR_Type) GetCTRL0_CMP0_HYS() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0x6000) >> 13
}
func (o *COMPARATOR_Type) SetCTRL0_CMP0_INTPOL(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x8000)|value<<15)
}
func (o *COMPARATOR_Type) GetCTRL0_CMP0_INTPOL() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0x8000) >> 15
}
func (o *COMPARATOR_Type) SetCTRL0_CMP0_INTTYPE(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x10000)|value<<16)
}
func (o *COMPARATOR_Type) GetCTRL0_CMP0_INTTYPE() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0x10000) >> 16
}
func (o *COMPARATOR_Type) SetCTRL0_CMP0_INTEDGE(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x60000)|value<<17)
}
func (o *COMPARATOR_Type) GetCTRL0_CMP0_INTEDGE() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0x60000) >> 17
}
func (o *COMPARATOR_Type) SetCTRL0_CMP0_INTFLAG(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x80000)|value<<19)
}
func (o *COMPARATOR_Type) GetCTRL0_CMP0_INTFLAG() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0x80000) >> 19
}
func (o *COMPARATOR_Type) SetCTRL0_CMP0_VLADEN(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x300000)|value<<20)
}
func (o *COMPARATOR_Type) GetCTRL0_CMP0_VLADEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0x300000) >> 20
}
func (o *COMPARATOR_Type) SetCTRL0_CMP0_VLADREF(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x400000)|value<<22)
}
func (o *COMPARATOR_Type) GetCTRL0_CMP0_VLADREF() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0x400000) >> 22
}
func (o *COMPARATOR_Type) SetCTRL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x800000)|value<<23)
}
func (o *COMPARATOR_Type) GetCTRL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0x800000) >> 23
}
func (o *COMPARATOR_Type) SetCTRL0_CMP0_VSEL(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0x1f000000)|value<<24)
}
func (o *COMPARATOR_Type) GetCTRL0_CMP0_VSEL() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0x1f000000) >> 24
}
func (o *COMPARATOR_Type) SetCTRL0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTRL0.Reg, volatile.LoadUint32(&o.CTRL0.Reg)&^(0xe0000000)|value<<29)
}
func (o *COMPARATOR_Type) GetCTRL0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTRL0.Reg) & 0xe0000000) >> 29
}

// COMPARATOR.CTRL1: Comparator 1 control register
func (o *COMPARATOR_Type) SetCTRL1_CMP1_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x3)|value)
}
func (o *COMPARATOR_Type) GetCTRL1_CMP1_EN() uint32 {
	return volatile.LoadUint32(&o.CTRL1.Reg) & 0x3
}
func (o *COMPARATOR_Type) SetCTRL1_CMP1_OE(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x4)|value<<2)
}
func (o *COMPARATOR_Type) GetCTRL1_CMP1_OE() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x4) >> 2
}
func (o *COMPARATOR_Type) SetCTRL1_CMP1_STAT(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x8)|value<<3)
}
func (o *COMPARATOR_Type) GetCTRL1_CMP1_STAT() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x8) >> 3
}
func (o *COMPARATOR_Type) SetCTRL1_CMP1_VM(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x70)|value<<4)
}
func (o *COMPARATOR_Type) GetCTRL1_CMP1_VM() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x70) >> 4
}
func (o *COMPARATOR_Type) SetCTRL1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x80)|value<<7)
}
func (o *COMPARATOR_Type) GetCTRL1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x80) >> 7
}
func (o *COMPARATOR_Type) SetCTRL1_CMP1_VP(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x700)|value<<8)
}
func (o *COMPARATOR_Type) GetCTRL1_CMP1_VP() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x700) >> 8
}
func (o *COMPARATOR_Type) SetCTRL1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x800)|value<<11)
}
func (o *COMPARATOR_Type) GetCTRL1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x800) >> 11
}
func (o *COMPARATOR_Type) SetCTRL1_CMP1_SYNC(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x1000)|value<<12)
}
func (o *COMPARATOR_Type) GetCTRL1_CMP1_SYNC() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x1000) >> 12
}
func (o *COMPARATOR_Type) SetCTRL1_CMP1_HYS(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x6000)|value<<13)
}
func (o *COMPARATOR_Type) GetCTRL1_CMP1_HYS() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x6000) >> 13
}
func (o *COMPARATOR_Type) SetCTRL1_CMP1_INTPOL(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x8000)|value<<15)
}
func (o *COMPARATOR_Type) GetCTRL1_CMP1_INTPOL() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x8000) >> 15
}
func (o *COMPARATOR_Type) SetCTRL1_CMP1_INTTYPE(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x10000)|value<<16)
}
func (o *COMPARATOR_Type) GetCTRL1_CMP1_INTTYPE() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x10000) >> 16
}
func (o *COMPARATOR_Type) SetCTRL1_CMP1_INTEDGE(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x60000)|value<<17)
}
func (o *COMPARATOR_Type) GetCTRL1_CMP1_INTEDGE() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x60000) >> 17
}
func (o *COMPARATOR_Type) SetCTRL1_CMP1_INTFLAG(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x80000)|value<<19)
}
func (o *COMPARATOR_Type) GetCTRL1_CMP1_INTFLAG() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x80000) >> 19
}
func (o *COMPARATOR_Type) SetCTRL1_CMP1_VLADEN(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x300000)|value<<20)
}
func (o *COMPARATOR_Type) GetCTRL1_CMP1_VLADEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x300000) >> 20
}
func (o *COMPARATOR_Type) SetCTRL1_CMP1_VLADREF(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x400000)|value<<22)
}
func (o *COMPARATOR_Type) GetCTRL1_CMP1_VLADREF() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x400000) >> 22
}
func (o *COMPARATOR_Type) SetCTRL1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x800000)|value<<23)
}
func (o *COMPARATOR_Type) GetCTRL1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x800000) >> 23
}
func (o *COMPARATOR_Type) SetCTRL1_CMP1_VSel(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0x1f000000)|value<<24)
}
func (o *COMPARATOR_Type) GetCTRL1_CMP1_VSel() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0x1f000000) >> 24
}
func (o *COMPARATOR_Type) SetCTRL1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTRL1.Reg, volatile.LoadUint32(&o.CTRL1.Reg)&^(0xe0000000)|value<<29)
}
func (o *COMPARATOR_Type) GetCTRL1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTRL1.Reg) & 0xe0000000) >> 29
}

// Real Time Clock (RTC)
type RTC_Type struct {
	ILR           volatile.Register32 // 0x0
	_             [4]byte
	CCR           volatile.Register32 // 0x8
	CIIR          volatile.Register32 // 0xC
	AMR           volatile.Register32 // 0x10
	CTIME0        volatile.Register32 // 0x14
	CTIME1        volatile.Register32 // 0x18
	CTIME2        volatile.Register32 // 0x1C
	SEC           volatile.Register32 // 0x20
	MIN           volatile.Register32 // 0x24
	HRS           volatile.Register32 // 0x28
	DOM           volatile.Register32 // 0x2C
	DOW           volatile.Register32 // 0x30
	DOY           volatile.Register32 // 0x34
	MONTH         volatile.Register32 // 0x38
	YEAR          volatile.Register32 // 0x3C
	CALIBRATION   volatile.Register32 // 0x40
	GPREG0        volatile.Register32 // 0x44
	GPREG1        volatile.Register32 // 0x48
	GPREG2        volatile.Register32 // 0x4C
	GPREG3        volatile.Register32 // 0x50
	GPREG4        volatile.Register32 // 0x54
	RTC_AUXEN     volatile.Register32 // 0x58
	RTC_AUX       volatile.Register32 // 0x5C
	ASEC          volatile.Register32 // 0x60
	AMIN          volatile.Register32 // 0x64
	AHRS          volatile.Register32 // 0x68
	ADOM          volatile.Register32 // 0x6C
	ADOW          volatile.Register32 // 0x70
	ADOY          volatile.Register32 // 0x74
	AMON          volatile.Register32 // 0x78
	AYRS          volatile.Register32 // 0x7C
	ERSTATUS      volatile.Register32 // 0x80
	ERCONTROL     volatile.Register32 // 0x84
	ERCOUNTERS    volatile.Register32 // 0x88
	_             [4]byte
	ERFIRSTSTAMP0 volatile.Register32 // 0x90
	ERFIRSTSTAMP1 volatile.Register32 // 0x94
	ERFIRSTSTAMP2 volatile.Register32 // 0x98
	_             [4]byte
	ERLASTSTAMP0  volatile.Register32 // 0xA0
	ERLASTSTAMP1  volatile.Register32 // 0xA4
	ERLASTSTAMP2  volatile.Register32 // 0xA8
}

// RTC.ILR: Interrupt Location Register
func (o *RTC_Type) SetILR_RTCCIF(value uint32) {
	volatile.StoreUint32(&o.ILR.Reg, volatile.LoadUint32(&o.ILR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetILR_RTCCIF() uint32 {
	return volatile.LoadUint32(&o.ILR.Reg) & 0x1
}
func (o *RTC_Type) SetILR_RTCALF(value uint32) {
	volatile.StoreUint32(&o.ILR.Reg, volatile.LoadUint32(&o.ILR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetILR_RTCALF() uint32 {
	return (volatile.LoadUint32(&o.ILR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetILR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ILR.Reg, volatile.LoadUint32(&o.ILR.Reg)&^(0xffe00000)|value<<21)
}
func (o *RTC_Type) GetILR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ILR.Reg) & 0xffe00000) >> 21
}

// RTC.CCR: Clock Control Register
func (o *RTC_Type) SetCCR_CLKEN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetCCR_CLKEN() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0x1
}
func (o *RTC_Type) SetCCR_CTCRST(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetCCR_CTCRST() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetCCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0xc)|value<<2)
}
func (o *RTC_Type) GetCCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0xc) >> 2
}
func (o *RTC_Type) SetCCR_CCALEN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetCCR_CCALEN() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetCCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RTC_Type) GetCCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0xffffffe0) >> 5
}

// RTC.CIIR: Counter Increment Interrupt Register
func (o *RTC_Type) SetCIIR_IMSEC(value uint32) {
	volatile.StoreUint32(&o.CIIR.Reg, volatile.LoadUint32(&o.CIIR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetCIIR_IMSEC() uint32 {
	return volatile.LoadUint32(&o.CIIR.Reg) & 0x1
}
func (o *RTC_Type) SetCIIR_IMMIN(value uint32) {
	volatile.StoreUint32(&o.CIIR.Reg, volatile.LoadUint32(&o.CIIR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetCIIR_IMMIN() uint32 {
	return (volatile.LoadUint32(&o.CIIR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetCIIR_IMHOUR(value uint32) {
	volatile.StoreUint32(&o.CIIR.Reg, volatile.LoadUint32(&o.CIIR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetCIIR_IMHOUR() uint32 {
	return (volatile.LoadUint32(&o.CIIR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetCIIR_IMDOM(value uint32) {
	volatile.StoreUint32(&o.CIIR.Reg, volatile.LoadUint32(&o.CIIR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetCIIR_IMDOM() uint32 {
	return (volatile.LoadUint32(&o.CIIR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetCIIR_IMDOW(value uint32) {
	volatile.StoreUint32(&o.CIIR.Reg, volatile.LoadUint32(&o.CIIR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetCIIR_IMDOW() uint32 {
	return (volatile.LoadUint32(&o.CIIR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetCIIR_IMDOY(value uint32) {
	volatile.StoreUint32(&o.CIIR.Reg, volatile.LoadUint32(&o.CIIR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetCIIR_IMDOY() uint32 {
	return (volatile.LoadUint32(&o.CIIR.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetCIIR_IMMON(value uint32) {
	volatile.StoreUint32(&o.CIIR.Reg, volatile.LoadUint32(&o.CIIR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetCIIR_IMMON() uint32 {
	return (volatile.LoadUint32(&o.CIIR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetCIIR_IMYEAR(value uint32) {
	volatile.StoreUint32(&o.CIIR.Reg, volatile.LoadUint32(&o.CIIR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetCIIR_IMYEAR() uint32 {
	return (volatile.LoadUint32(&o.CIIR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetCIIR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CIIR.Reg, volatile.LoadUint32(&o.CIIR.Reg)&^(0xffffff00)|value<<8)
}
func (o *RTC_Type) GetCIIR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CIIR.Reg) & 0xffffff00) >> 8
}

// RTC.AMR: Alarm Mask Register
func (o *RTC_Type) SetAMR_AMRSEC(value uint32) {
	volatile.StoreUint32(&o.AMR.Reg, volatile.LoadUint32(&o.AMR.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetAMR_AMRSEC() uint32 {
	return volatile.LoadUint32(&o.AMR.Reg) & 0x1
}
func (o *RTC_Type) SetAMR_AMRMIN(value uint32) {
	volatile.StoreUint32(&o.AMR.Reg, volatile.LoadUint32(&o.AMR.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetAMR_AMRMIN() uint32 {
	return (volatile.LoadUint32(&o.AMR.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetAMR_AMRHOUR(value uint32) {
	volatile.StoreUint32(&o.AMR.Reg, volatile.LoadUint32(&o.AMR.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetAMR_AMRHOUR() uint32 {
	return (volatile.LoadUint32(&o.AMR.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetAMR_AMRDOM(value uint32) {
	volatile.StoreUint32(&o.AMR.Reg, volatile.LoadUint32(&o.AMR.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetAMR_AMRDOM() uint32 {
	return (volatile.LoadUint32(&o.AMR.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetAMR_AMRDOW(value uint32) {
	volatile.StoreUint32(&o.AMR.Reg, volatile.LoadUint32(&o.AMR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetAMR_AMRDOW() uint32 {
	return (volatile.LoadUint32(&o.AMR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetAMR_AMRDOY(value uint32) {
	volatile.StoreUint32(&o.AMR.Reg, volatile.LoadUint32(&o.AMR.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetAMR_AMRDOY() uint32 {
	return (volatile.LoadUint32(&o.AMR.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetAMR_AMRMON(value uint32) {
	volatile.StoreUint32(&o.AMR.Reg, volatile.LoadUint32(&o.AMR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetAMR_AMRMON() uint32 {
	return (volatile.LoadUint32(&o.AMR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetAMR_AMRYEAR(value uint32) {
	volatile.StoreUint32(&o.AMR.Reg, volatile.LoadUint32(&o.AMR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetAMR_AMRYEAR() uint32 {
	return (volatile.LoadUint32(&o.AMR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetAMR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.AMR.Reg, volatile.LoadUint32(&o.AMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *RTC_Type) GetAMR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.AMR.Reg) & 0xffffff00) >> 8
}

// RTC.CTIME0: Consolidated Time Register 0
func (o *RTC_Type) SetCTIME0_SECONDS(value uint32) {
	volatile.StoreUint32(&o.CTIME0.Reg, volatile.LoadUint32(&o.CTIME0.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetCTIME0_SECONDS() uint32 {
	return volatile.LoadUint32(&o.CTIME0.Reg) & 0x3f
}
func (o *RTC_Type) SetCTIME0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTIME0.Reg, volatile.LoadUint32(&o.CTIME0.Reg)&^(0xc0)|value<<6)
}
func (o *RTC_Type) GetCTIME0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTIME0.Reg) & 0xc0) >> 6
}
func (o *RTC_Type) SetCTIME0_MINUTES(value uint32) {
	volatile.StoreUint32(&o.CTIME0.Reg, volatile.LoadUint32(&o.CTIME0.Reg)&^(0x3f00)|value<<8)
}
func (o *RTC_Type) GetCTIME0_MINUTES() uint32 {
	return (volatile.LoadUint32(&o.CTIME0.Reg) & 0x3f00) >> 8
}
func (o *RTC_Type) SetCTIME0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTIME0.Reg, volatile.LoadUint32(&o.CTIME0.Reg)&^(0xc000)|value<<14)
}
func (o *RTC_Type) GetCTIME0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTIME0.Reg) & 0xc000) >> 14
}
func (o *RTC_Type) SetCTIME0_HOURS(value uint32) {
	volatile.StoreUint32(&o.CTIME0.Reg, volatile.LoadUint32(&o.CTIME0.Reg)&^(0x1f0000)|value<<16)
}
func (o *RTC_Type) GetCTIME0_HOURS() uint32 {
	return (volatile.LoadUint32(&o.CTIME0.Reg) & 0x1f0000) >> 16
}
func (o *RTC_Type) SetCTIME0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTIME0.Reg, volatile.LoadUint32(&o.CTIME0.Reg)&^(0xe00000)|value<<21)
}
func (o *RTC_Type) GetCTIME0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTIME0.Reg) & 0xe00000) >> 21
}
func (o *RTC_Type) SetCTIME0_DOW(value uint32) {
	volatile.StoreUint32(&o.CTIME0.Reg, volatile.LoadUint32(&o.CTIME0.Reg)&^(0x7000000)|value<<24)
}
func (o *RTC_Type) GetCTIME0_DOW() uint32 {
	return (volatile.LoadUint32(&o.CTIME0.Reg) & 0x7000000) >> 24
}
func (o *RTC_Type) SetCTIME0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTIME0.Reg, volatile.LoadUint32(&o.CTIME0.Reg)&^(0xf8000000)|value<<27)
}
func (o *RTC_Type) GetCTIME0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTIME0.Reg) & 0xf8000000) >> 27
}

// RTC.CTIME1: Consolidated Time Register 1
func (o *RTC_Type) SetCTIME1_DOM(value uint32) {
	volatile.StoreUint32(&o.CTIME1.Reg, volatile.LoadUint32(&o.CTIME1.Reg)&^(0x1f)|value)
}
func (o *RTC_Type) GetCTIME1_DOM() uint32 {
	return volatile.LoadUint32(&o.CTIME1.Reg) & 0x1f
}
func (o *RTC_Type) SetCTIME1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTIME1.Reg, volatile.LoadUint32(&o.CTIME1.Reg)&^(0xe0)|value<<5)
}
func (o *RTC_Type) GetCTIME1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTIME1.Reg) & 0xe0) >> 5
}
func (o *RTC_Type) SetCTIME1_MONTH(value uint32) {
	volatile.StoreUint32(&o.CTIME1.Reg, volatile.LoadUint32(&o.CTIME1.Reg)&^(0xf00)|value<<8)
}
func (o *RTC_Type) GetCTIME1_MONTH() uint32 {
	return (volatile.LoadUint32(&o.CTIME1.Reg) & 0xf00) >> 8
}
func (o *RTC_Type) SetCTIME1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTIME1.Reg, volatile.LoadUint32(&o.CTIME1.Reg)&^(0xf000)|value<<12)
}
func (o *RTC_Type) GetCTIME1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTIME1.Reg) & 0xf000) >> 12
}
func (o *RTC_Type) SetCTIME1_YEAR(value uint32) {
	volatile.StoreUint32(&o.CTIME1.Reg, volatile.LoadUint32(&o.CTIME1.Reg)&^(0xfff0000)|value<<16)
}
func (o *RTC_Type) GetCTIME1_YEAR() uint32 {
	return (volatile.LoadUint32(&o.CTIME1.Reg) & 0xfff0000) >> 16
}
func (o *RTC_Type) SetCTIME1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTIME1.Reg, volatile.LoadUint32(&o.CTIME1.Reg)&^(0xf0000000)|value<<28)
}
func (o *RTC_Type) GetCTIME1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTIME1.Reg) & 0xf0000000) >> 28
}

// RTC.CTIME2: Consolidated Time Register 2
func (o *RTC_Type) SetCTIME2_DOY(value uint32) {
	volatile.StoreUint32(&o.CTIME2.Reg, volatile.LoadUint32(&o.CTIME2.Reg)&^(0xfff)|value)
}
func (o *RTC_Type) GetCTIME2_DOY() uint32 {
	return volatile.LoadUint32(&o.CTIME2.Reg) & 0xfff
}
func (o *RTC_Type) SetCTIME2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTIME2.Reg, volatile.LoadUint32(&o.CTIME2.Reg)&^(0xfffff000)|value<<12)
}
func (o *RTC_Type) GetCTIME2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTIME2.Reg) & 0xfffff000) >> 12
}

// RTC.SEC: Seconds Counter
func (o *RTC_Type) SetSEC_SECONDS(value uint32) {
	volatile.StoreUint32(&o.SEC.Reg, volatile.LoadUint32(&o.SEC.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetSEC_SECONDS() uint32 {
	return volatile.LoadUint32(&o.SEC.Reg) & 0x3f
}
func (o *RTC_Type) SetSEC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SEC.Reg, volatile.LoadUint32(&o.SEC.Reg)&^(0xffffffc0)|value<<6)
}
func (o *RTC_Type) GetSEC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SEC.Reg) & 0xffffffc0) >> 6
}

// RTC.MIN: Minutes Register
func (o *RTC_Type) SetMIN_MINUTES(value uint32) {
	volatile.StoreUint32(&o.MIN.Reg, volatile.LoadUint32(&o.MIN.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetMIN_MINUTES() uint32 {
	return volatile.LoadUint32(&o.MIN.Reg) & 0x3f
}
func (o *RTC_Type) SetMIN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MIN.Reg, volatile.LoadUint32(&o.MIN.Reg)&^(0xffffffc0)|value<<6)
}
func (o *RTC_Type) GetMIN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MIN.Reg) & 0xffffffc0) >> 6
}

// RTC.HRS: Hours Register
func (o *RTC_Type) SetHRS_HOURS(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x1f)|value)
}
func (o *RTC_Type) GetHRS_HOURS() uint32 {
	return volatile.LoadUint32(&o.HRS.Reg) & 0x1f
}
func (o *RTC_Type) SetHRS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RTC_Type) GetHRS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0xffffffe0) >> 5
}

// RTC.DOM: Day of Month Register
func (o *RTC_Type) SetDOM(value uint32) {
	volatile.StoreUint32(&o.DOM.Reg, volatile.LoadUint32(&o.DOM.Reg)&^(0x1f)|value)
}
func (o *RTC_Type) GetDOM() uint32 {
	return volatile.LoadUint32(&o.DOM.Reg) & 0x1f
}
func (o *RTC_Type) SetDOM_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DOM.Reg, volatile.LoadUint32(&o.DOM.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RTC_Type) GetDOM_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DOM.Reg) & 0xffffffe0) >> 5
}

// RTC.DOW: Day of Week Register
func (o *RTC_Type) SetDOW(value uint32) {
	volatile.StoreUint32(&o.DOW.Reg, volatile.LoadUint32(&o.DOW.Reg)&^(0x7)|value)
}
func (o *RTC_Type) GetDOW() uint32 {
	return volatile.LoadUint32(&o.DOW.Reg) & 0x7
}
func (o *RTC_Type) SetDOW_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DOW.Reg, volatile.LoadUint32(&o.DOW.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RTC_Type) GetDOW_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DOW.Reg) & 0xfffffff8) >> 3
}

// RTC.DOY: Day of Year Register
func (o *RTC_Type) SetDOY(value uint32) {
	volatile.StoreUint32(&o.DOY.Reg, volatile.LoadUint32(&o.DOY.Reg)&^(0x1ff)|value)
}
func (o *RTC_Type) GetDOY() uint32 {
	return volatile.LoadUint32(&o.DOY.Reg) & 0x1ff
}
func (o *RTC_Type) SetDOY_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DOY.Reg, volatile.LoadUint32(&o.DOY.Reg)&^(0xfffffe00)|value<<9)
}
func (o *RTC_Type) GetDOY_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DOY.Reg) & 0xfffffe00) >> 9
}

// RTC.MONTH: Months Register
func (o *RTC_Type) SetMONTH(value uint32) {
	volatile.StoreUint32(&o.MONTH.Reg, volatile.LoadUint32(&o.MONTH.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetMONTH() uint32 {
	return volatile.LoadUint32(&o.MONTH.Reg) & 0xf
}
func (o *RTC_Type) SetMONTH_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MONTH.Reg, volatile.LoadUint32(&o.MONTH.Reg)&^(0xfffffff0)|value<<4)
}
func (o *RTC_Type) GetMONTH_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MONTH.Reg) & 0xfffffff0) >> 4
}

// RTC.YEAR: Years Register
func (o *RTC_Type) SetYEAR(value uint32) {
	volatile.StoreUint32(&o.YEAR.Reg, volatile.LoadUint32(&o.YEAR.Reg)&^(0xfff)|value)
}
func (o *RTC_Type) GetYEAR() uint32 {
	return volatile.LoadUint32(&o.YEAR.Reg) & 0xfff
}
func (o *RTC_Type) SetYEAR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.YEAR.Reg, volatile.LoadUint32(&o.YEAR.Reg)&^(0xfffff000)|value<<12)
}
func (o *RTC_Type) GetYEAR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.YEAR.Reg) & 0xfffff000) >> 12
}

// RTC.CALIBRATION: Calibration Value Register
func (o *RTC_Type) SetCALIBRATION_CALVAL(value uint32) {
	volatile.StoreUint32(&o.CALIBRATION.Reg, volatile.LoadUint32(&o.CALIBRATION.Reg)&^(0x1ffff)|value)
}
func (o *RTC_Type) GetCALIBRATION_CALVAL() uint32 {
	return volatile.LoadUint32(&o.CALIBRATION.Reg) & 0x1ffff
}
func (o *RTC_Type) SetCALIBRATION_CALDIR(value uint32) {
	volatile.StoreUint32(&o.CALIBRATION.Reg, volatile.LoadUint32(&o.CALIBRATION.Reg)&^(0x20000)|value<<17)
}
func (o *RTC_Type) GetCALIBRATION_CALDIR() uint32 {
	return (volatile.LoadUint32(&o.CALIBRATION.Reg) & 0x20000) >> 17
}

// RTC.GPREG0: General Purpose Register 0
func (o *RTC_Type) SetGPREG0(value uint32) {
	volatile.StoreUint32(&o.GPREG0.Reg, value)
}
func (o *RTC_Type) GetGPREG0() uint32 {
	return volatile.LoadUint32(&o.GPREG0.Reg)
}

// RTC.GPREG1: General Purpose Register 0
func (o *RTC_Type) SetGPREG1(value uint32) {
	volatile.StoreUint32(&o.GPREG1.Reg, value)
}
func (o *RTC_Type) GetGPREG1() uint32 {
	return volatile.LoadUint32(&o.GPREG1.Reg)
}

// RTC.GPREG2: General Purpose Register 0
func (o *RTC_Type) SetGPREG2(value uint32) {
	volatile.StoreUint32(&o.GPREG2.Reg, value)
}
func (o *RTC_Type) GetGPREG2() uint32 {
	return volatile.LoadUint32(&o.GPREG2.Reg)
}

// RTC.GPREG3: General Purpose Register 0
func (o *RTC_Type) SetGPREG3(value uint32) {
	volatile.StoreUint32(&o.GPREG3.Reg, value)
}
func (o *RTC_Type) GetGPREG3() uint32 {
	return volatile.LoadUint32(&o.GPREG3.Reg)
}

// RTC.GPREG4: General Purpose Register 0
func (o *RTC_Type) SetGPREG4(value uint32) {
	volatile.StoreUint32(&o.GPREG4.Reg, value)
}
func (o *RTC_Type) GetGPREG4() uint32 {
	return volatile.LoadUint32(&o.GPREG4.Reg)
}

// RTC.RTC_AUXEN: RTC Auxiliary Enable register
func (o *RTC_Type) SetRTC_AUXEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RTC_AUXEN.Reg, volatile.LoadUint32(&o.RTC_AUXEN.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRTC_AUXEN_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RTC_AUXEN.Reg) & 0xf
}
func (o *RTC_Type) SetRTC_AUXEN_RTC_OSCFEN(value uint32) {
	volatile.StoreUint32(&o.RTC_AUXEN.Reg, volatile.LoadUint32(&o.RTC_AUXEN.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetRTC_AUXEN_RTC_OSCFEN() uint32 {
	return (volatile.LoadUint32(&o.RTC_AUXEN.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetRTC_AUXEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RTC_AUXEN.Reg, volatile.LoadUint32(&o.RTC_AUXEN.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RTC_Type) GetRTC_AUXEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RTC_AUXEN.Reg) & 0xffffffe0) >> 5
}

// RTC.RTC_AUX: RTC Auxiliary control register
func (o *RTC_Type) SetRTC_AUX_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RTC_AUX.Reg, volatile.LoadUint32(&o.RTC_AUX.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRTC_AUX_RESERVED() uint32 {
	return volatile.LoadUint32(&o.RTC_AUX.Reg) & 0xf
}
func (o *RTC_Type) SetRTC_AUX_RTC_OSCF(value uint32) {
	volatile.StoreUint32(&o.RTC_AUX.Reg, volatile.LoadUint32(&o.RTC_AUX.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetRTC_AUX_RTC_OSCF() uint32 {
	return (volatile.LoadUint32(&o.RTC_AUX.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetRTC_AUX_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RTC_AUX.Reg, volatile.LoadUint32(&o.RTC_AUX.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetRTC_AUX_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RTC_AUX.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetRTC_AUX_RTC_PDOUT(value uint32) {
	volatile.StoreUint32(&o.RTC_AUX.Reg, volatile.LoadUint32(&o.RTC_AUX.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetRTC_AUX_RTC_PDOUT() uint32 {
	return (volatile.LoadUint32(&o.RTC_AUX.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetRTC_AUX_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RTC_AUX.Reg, volatile.LoadUint32(&o.RTC_AUX.Reg)&^(0xffffff80)|value<<7)
}
func (o *RTC_Type) GetRTC_AUX_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RTC_AUX.Reg) & 0xffffff80) >> 7
}

// RTC.ASEC: Alarm value for Seconds
func (o *RTC_Type) SetASEC_SECONDS(value uint32) {
	volatile.StoreUint32(&o.ASEC.Reg, volatile.LoadUint32(&o.ASEC.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetASEC_SECONDS() uint32 {
	return volatile.LoadUint32(&o.ASEC.Reg) & 0x3f
}
func (o *RTC_Type) SetASEC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ASEC.Reg, volatile.LoadUint32(&o.ASEC.Reg)&^(0xffffffc0)|value<<6)
}
func (o *RTC_Type) GetASEC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ASEC.Reg) & 0xffffffc0) >> 6
}

// RTC.AMIN: Alarm value for Minutes
func (o *RTC_Type) SetAMIN_MINUTES(value uint32) {
	volatile.StoreUint32(&o.AMIN.Reg, volatile.LoadUint32(&o.AMIN.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetAMIN_MINUTES() uint32 {
	return volatile.LoadUint32(&o.AMIN.Reg) & 0x3f
}
func (o *RTC_Type) SetAMIN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.AMIN.Reg, volatile.LoadUint32(&o.AMIN.Reg)&^(0xffffffc0)|value<<6)
}
func (o *RTC_Type) GetAMIN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.AMIN.Reg) & 0xffffffc0) >> 6
}

// RTC.AHRS: Alarm value for Hours
func (o *RTC_Type) SetAHRS_HOURS(value uint32) {
	volatile.StoreUint32(&o.AHRS.Reg, volatile.LoadUint32(&o.AHRS.Reg)&^(0x1f)|value)
}
func (o *RTC_Type) GetAHRS_HOURS() uint32 {
	return volatile.LoadUint32(&o.AHRS.Reg) & 0x1f
}
func (o *RTC_Type) SetAHRS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.AHRS.Reg, volatile.LoadUint32(&o.AHRS.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RTC_Type) GetAHRS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.AHRS.Reg) & 0xffffffe0) >> 5
}

// RTC.ADOM: Alarm value for Day of Month
func (o *RTC_Type) SetADOM_DOM(value uint32) {
	volatile.StoreUint32(&o.ADOM.Reg, volatile.LoadUint32(&o.ADOM.Reg)&^(0x1f)|value)
}
func (o *RTC_Type) GetADOM_DOM() uint32 {
	return volatile.LoadUint32(&o.ADOM.Reg) & 0x1f
}
func (o *RTC_Type) SetADOM_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ADOM.Reg, volatile.LoadUint32(&o.ADOM.Reg)&^(0xffffffe0)|value<<5)
}
func (o *RTC_Type) GetADOM_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ADOM.Reg) & 0xffffffe0) >> 5
}

// RTC.ADOW: Alarm value for Day of Week
func (o *RTC_Type) SetADOW_DOW(value uint32) {
	volatile.StoreUint32(&o.ADOW.Reg, volatile.LoadUint32(&o.ADOW.Reg)&^(0x7)|value)
}
func (o *RTC_Type) GetADOW_DOW() uint32 {
	return volatile.LoadUint32(&o.ADOW.Reg) & 0x7
}
func (o *RTC_Type) SetADOW_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ADOW.Reg, volatile.LoadUint32(&o.ADOW.Reg)&^(0xfffffff8)|value<<3)
}
func (o *RTC_Type) GetADOW_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ADOW.Reg) & 0xfffffff8) >> 3
}

// RTC.ADOY: Alarm value for Day of Year
func (o *RTC_Type) SetADOY_DOY(value uint32) {
	volatile.StoreUint32(&o.ADOY.Reg, volatile.LoadUint32(&o.ADOY.Reg)&^(0x1ff)|value)
}
func (o *RTC_Type) GetADOY_DOY() uint32 {
	return volatile.LoadUint32(&o.ADOY.Reg) & 0x1ff
}
func (o *RTC_Type) SetADOY_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ADOY.Reg, volatile.LoadUint32(&o.ADOY.Reg)&^(0xfffffe00)|value<<9)
}
func (o *RTC_Type) GetADOY_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ADOY.Reg) & 0xfffffe00) >> 9
}

// RTC.AMON: Alarm value for Months
func (o *RTC_Type) SetAMON_MONTH(value uint32) {
	volatile.StoreUint32(&o.AMON.Reg, volatile.LoadUint32(&o.AMON.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetAMON_MONTH() uint32 {
	return volatile.LoadUint32(&o.AMON.Reg) & 0xf
}
func (o *RTC_Type) SetAMON_RESERVED(value uint32) {
	volatile.StoreUint32(&o.AMON.Reg, volatile.LoadUint32(&o.AMON.Reg)&^(0xfffffff0)|value<<4)
}
func (o *RTC_Type) GetAMON_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.AMON.Reg) & 0xfffffff0) >> 4
}

// RTC.AYRS: Alarm value for Year
func (o *RTC_Type) SetAYRS_YEAR(value uint32) {
	volatile.StoreUint32(&o.AYRS.Reg, volatile.LoadUint32(&o.AYRS.Reg)&^(0xfff)|value)
}
func (o *RTC_Type) GetAYRS_YEAR() uint32 {
	return volatile.LoadUint32(&o.AYRS.Reg) & 0xfff
}
func (o *RTC_Type) SetAYRS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.AYRS.Reg, volatile.LoadUint32(&o.AYRS.Reg)&^(0xfffff000)|value<<12)
}
func (o *RTC_Type) GetAYRS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.AYRS.Reg) & 0xfffff000) >> 12
}

// RTC.ERSTATUS: Event Monitor/Recorder Status register. Contains status flags for event channels and other Event Monitor/Recorder conditions.
func (o *RTC_Type) SetERSTATUS_EV0(value uint32) {
	volatile.StoreUint32(&o.ERSTATUS.Reg, volatile.LoadUint32(&o.ERSTATUS.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetERSTATUS_EV0() uint32 {
	return volatile.LoadUint32(&o.ERSTATUS.Reg) & 0x1
}
func (o *RTC_Type) SetERSTATUS_EV1(value uint32) {
	volatile.StoreUint32(&o.ERSTATUS.Reg, volatile.LoadUint32(&o.ERSTATUS.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetERSTATUS_EV1() uint32 {
	return (volatile.LoadUint32(&o.ERSTATUS.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetERSTATUS_EV2(value uint32) {
	volatile.StoreUint32(&o.ERSTATUS.Reg, volatile.LoadUint32(&o.ERSTATUS.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetERSTATUS_EV2() uint32 {
	return (volatile.LoadUint32(&o.ERSTATUS.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetERSTATUS_GP_CLEARED(value uint32) {
	volatile.StoreUint32(&o.ERSTATUS.Reg, volatile.LoadUint32(&o.ERSTATUS.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetERSTATUS_GP_CLEARED() uint32 {
	return (volatile.LoadUint32(&o.ERSTATUS.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetERSTATUS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ERSTATUS.Reg, volatile.LoadUint32(&o.ERSTATUS.Reg)&^(0x7ffffff0)|value<<4)
}
func (o *RTC_Type) GetERSTATUS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ERSTATUS.Reg) & 0x7ffffff0) >> 4
}
func (o *RTC_Type) SetERSTATUS_WAKEUP(value uint32) {
	volatile.StoreUint32(&o.ERSTATUS.Reg, volatile.LoadUint32(&o.ERSTATUS.Reg)&^(0x80000000)|value<<31)
}
func (o *RTC_Type) GetERSTATUS_WAKEUP() uint32 {
	return (volatile.LoadUint32(&o.ERSTATUS.Reg) & 0x80000000) >> 31
}

// RTC.ERCONTROL: Event Monitor/Recorder Control register. Contains bits that control actions for the event channels as well as for Event Monitor/Recorder setup.
func (o *RTC_Type) SetERCONTROL_INTWAKE_EN0(value uint32) {
	volatile.StoreUint32(&o.ERCONTROL.Reg, volatile.LoadUint32(&o.ERCONTROL.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetERCONTROL_INTWAKE_EN0() uint32 {
	return volatile.LoadUint32(&o.ERCONTROL.Reg) & 0x1
}
func (o *RTC_Type) SetERCONTROL_GPCLEAR_EN0(value uint32) {
	volatile.StoreUint32(&o.ERCONTROL.Reg, volatile.LoadUint32(&o.ERCONTROL.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetERCONTROL_GPCLEAR_EN0() uint32 {
	return (volatile.LoadUint32(&o.ERCONTROL.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetERCONTROL_POL0(value uint32) {
	volatile.StoreUint32(&o.ERCONTROL.Reg, volatile.LoadUint32(&o.ERCONTROL.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetERCONTROL_POL0() uint32 {
	return (volatile.LoadUint32(&o.ERCONTROL.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetERCONTROL_EV0_INPUT_EN(value uint32) {
	volatile.StoreUint32(&o.ERCONTROL.Reg, volatile.LoadUint32(&o.ERCONTROL.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetERCONTROL_EV0_INPUT_EN() uint32 {
	return (volatile.LoadUint32(&o.ERCONTROL.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetERCONTROL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ERCONTROL.Reg, volatile.LoadUint32(&o.ERCONTROL.Reg)&^(0x3f0)|value<<4)
}
func (o *RTC_Type) GetERCONTROL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ERCONTROL.Reg) & 0x3f0) >> 4
}
func (o *RTC_Type) SetERCONTROL_INTWAKE_EN1(value uint32) {
	volatile.StoreUint32(&o.ERCONTROL.Reg, volatile.LoadUint32(&o.ERCONTROL.Reg)&^(0x400)|value<<10)
}
func (o *RTC_Type) GetERCONTROL_INTWAKE_EN1() uint32 {
	return (volatile.LoadUint32(&o.ERCONTROL.Reg) & 0x400) >> 10
}
func (o *RTC_Type) SetERCONTROL_GPCLEAR_EN1(value uint32) {
	volatile.StoreUint32(&o.ERCONTROL.Reg, volatile.LoadUint32(&o.ERCONTROL.Reg)&^(0x800)|value<<11)
}
func (o *RTC_Type) GetERCONTROL_GPCLEAR_EN1() uint32 {
	return (volatile.LoadUint32(&o.ERCONTROL.Reg) & 0x800) >> 11
}
func (o *RTC_Type) SetERCONTROL_POL1(value uint32) {
	volatile.StoreUint32(&o.ERCONTROL.Reg, volatile.LoadUint32(&o.ERCONTROL.Reg)&^(0x1000)|value<<12)
}
func (o *RTC_Type) GetERCONTROL_POL1() uint32 {
	return (volatile.LoadUint32(&o.ERCONTROL.Reg) & 0x1000) >> 12
}
func (o *RTC_Type) SetERCONTROL_EV1_INPUT_EN(value uint32) {
	volatile.StoreUint32(&o.ERCONTROL.Reg, volatile.LoadUint32(&o.ERCONTROL.Reg)&^(0x2000)|value<<13)
}
func (o *RTC_Type) GetERCONTROL_EV1_INPUT_EN() uint32 {
	return (volatile.LoadUint32(&o.ERCONTROL.Reg) & 0x2000) >> 13
}
func (o *RTC_Type) SetERCONTROL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ERCONTROL.Reg, volatile.LoadUint32(&o.ERCONTROL.Reg)&^(0xfc000)|value<<14)
}
func (o *RTC_Type) GetERCONTROL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ERCONTROL.Reg) & 0xfc000) >> 14
}
func (o *RTC_Type) SetERCONTROL_INTWAKE_EN2(value uint32) {
	volatile.StoreUint32(&o.ERCONTROL.Reg, volatile.LoadUint32(&o.ERCONTROL.Reg)&^(0x100000)|value<<20)
}
func (o *RTC_Type) GetERCONTROL_INTWAKE_EN2() uint32 {
	return (volatile.LoadUint32(&o.ERCONTROL.Reg) & 0x100000) >> 20
}
func (o *RTC_Type) SetERCONTROL_GPCLEAR_EN2(value uint32) {
	volatile.StoreUint32(&o.ERCONTROL.Reg, volatile.LoadUint32(&o.ERCONTROL.Reg)&^(0x200000)|value<<21)
}
func (o *RTC_Type) GetERCONTROL_GPCLEAR_EN2() uint32 {
	return (volatile.LoadUint32(&o.ERCONTROL.Reg) & 0x200000) >> 21
}
func (o *RTC_Type) SetERCONTROL_POL2(value uint32) {
	volatile.StoreUint32(&o.ERCONTROL.Reg, volatile.LoadUint32(&o.ERCONTROL.Reg)&^(0x400000)|value<<22)
}
func (o *RTC_Type) GetERCONTROL_POL2() uint32 {
	return (volatile.LoadUint32(&o.ERCONTROL.Reg) & 0x400000) >> 22
}
func (o *RTC_Type) SetERCONTROL_EV2_INPUT_EN(value uint32) {
	volatile.StoreUint32(&o.ERCONTROL.Reg, volatile.LoadUint32(&o.ERCONTROL.Reg)&^(0x800000)|value<<23)
}
func (o *RTC_Type) GetERCONTROL_EV2_INPUT_EN() uint32 {
	return (volatile.LoadUint32(&o.ERCONTROL.Reg) & 0x800000) >> 23
}
func (o *RTC_Type) SetERCONTROL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ERCONTROL.Reg, volatile.LoadUint32(&o.ERCONTROL.Reg)&^(0x3f000000)|value<<24)
}
func (o *RTC_Type) GetERCONTROL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ERCONTROL.Reg) & 0x3f000000) >> 24
}
func (o *RTC_Type) SetERCONTROL_ERMODE(value uint32) {
	volatile.StoreUint32(&o.ERCONTROL.Reg, volatile.LoadUint32(&o.ERCONTROL.Reg)&^(0xc0000000)|value<<30)
}
func (o *RTC_Type) GetERCONTROL_ERMODE() uint32 {
	return (volatile.LoadUint32(&o.ERCONTROL.Reg) & 0xc0000000) >> 30
}

// RTC.ERCOUNTERS: Event Monitor/Recorder Counters register. Allows reading the counters associated with the event channels.
func (o *RTC_Type) SetERCOUNTERS_COUNTER0(value uint32) {
	volatile.StoreUint32(&o.ERCOUNTERS.Reg, volatile.LoadUint32(&o.ERCOUNTERS.Reg)&^(0x7)|value)
}
func (o *RTC_Type) GetERCOUNTERS_COUNTER0() uint32 {
	return volatile.LoadUint32(&o.ERCOUNTERS.Reg) & 0x7
}
func (o *RTC_Type) SetERCOUNTERS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ERCOUNTERS.Reg, volatile.LoadUint32(&o.ERCOUNTERS.Reg)&^(0xf8)|value<<3)
}
func (o *RTC_Type) GetERCOUNTERS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ERCOUNTERS.Reg) & 0xf8) >> 3
}
func (o *RTC_Type) SetERCOUNTERS_COUNTER1(value uint32) {
	volatile.StoreUint32(&o.ERCOUNTERS.Reg, volatile.LoadUint32(&o.ERCOUNTERS.Reg)&^(0x700)|value<<8)
}
func (o *RTC_Type) GetERCOUNTERS_COUNTER1() uint32 {
	return (volatile.LoadUint32(&o.ERCOUNTERS.Reg) & 0x700) >> 8
}
func (o *RTC_Type) SetERCOUNTERS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ERCOUNTERS.Reg, volatile.LoadUint32(&o.ERCOUNTERS.Reg)&^(0xf800)|value<<11)
}
func (o *RTC_Type) GetERCOUNTERS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ERCOUNTERS.Reg) & 0xf800) >> 11
}
func (o *RTC_Type) SetERCOUNTERS_COUNTER2(value uint32) {
	volatile.StoreUint32(&o.ERCOUNTERS.Reg, volatile.LoadUint32(&o.ERCOUNTERS.Reg)&^(0x70000)|value<<16)
}
func (o *RTC_Type) GetERCOUNTERS_COUNTER2() uint32 {
	return (volatile.LoadUint32(&o.ERCOUNTERS.Reg) & 0x70000) >> 16
}
func (o *RTC_Type) SetERCOUNTERS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ERCOUNTERS.Reg, volatile.LoadUint32(&o.ERCOUNTERS.Reg)&^(0xfff80000)|value<<19)
}
func (o *RTC_Type) GetERCOUNTERS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ERCOUNTERS.Reg) & 0xfff80000) >> 19
}

// RTC.ERFIRSTSTAMP0: Event Monitor/Recorder First Stamp register for channel 0. Retains the time stamp for the first event on channel 0.
func (o *RTC_Type) SetERFIRSTSTAMP0_SEC(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP0.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP0.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetERFIRSTSTAMP0_SEC() uint32 {
	return volatile.LoadUint32(&o.ERFIRSTSTAMP0.Reg) & 0x3f
}
func (o *RTC_Type) SetERFIRSTSTAMP0_MIN(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP0.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP0.Reg)&^(0xfc0)|value<<6)
}
func (o *RTC_Type) GetERFIRSTSTAMP0_MIN() uint32 {
	return (volatile.LoadUint32(&o.ERFIRSTSTAMP0.Reg) & 0xfc0) >> 6
}
func (o *RTC_Type) SetERFIRSTSTAMP0_HOUR(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP0.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP0.Reg)&^(0x1f000)|value<<12)
}
func (o *RTC_Type) GetERFIRSTSTAMP0_HOUR() uint32 {
	return (volatile.LoadUint32(&o.ERFIRSTSTAMP0.Reg) & 0x1f000) >> 12
}
func (o *RTC_Type) SetERFIRSTSTAMP0_DOY(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP0.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP0.Reg)&^(0x3fe0000)|value<<17)
}
func (o *RTC_Type) GetERFIRSTSTAMP0_DOY() uint32 {
	return (volatile.LoadUint32(&o.ERFIRSTSTAMP0.Reg) & 0x3fe0000) >> 17
}
func (o *RTC_Type) SetERFIRSTSTAMP0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP0.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP0.Reg)&^(0xfc000000)|value<<26)
}
func (o *RTC_Type) GetERFIRSTSTAMP0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ERFIRSTSTAMP0.Reg) & 0xfc000000) >> 26
}

// RTC.ERFIRSTSTAMP1: Event Monitor/Recorder First Stamp register for channel 0. Retains the time stamp for the first event on channel 0.
func (o *RTC_Type) SetERFIRSTSTAMP1_SEC(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP1.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP1.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetERFIRSTSTAMP1_SEC() uint32 {
	return volatile.LoadUint32(&o.ERFIRSTSTAMP1.Reg) & 0x3f
}
func (o *RTC_Type) SetERFIRSTSTAMP1_MIN(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP1.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP1.Reg)&^(0xfc0)|value<<6)
}
func (o *RTC_Type) GetERFIRSTSTAMP1_MIN() uint32 {
	return (volatile.LoadUint32(&o.ERFIRSTSTAMP1.Reg) & 0xfc0) >> 6
}
func (o *RTC_Type) SetERFIRSTSTAMP1_HOUR(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP1.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP1.Reg)&^(0x1f000)|value<<12)
}
func (o *RTC_Type) GetERFIRSTSTAMP1_HOUR() uint32 {
	return (volatile.LoadUint32(&o.ERFIRSTSTAMP1.Reg) & 0x1f000) >> 12
}
func (o *RTC_Type) SetERFIRSTSTAMP1_DOY(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP1.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP1.Reg)&^(0x3fe0000)|value<<17)
}
func (o *RTC_Type) GetERFIRSTSTAMP1_DOY() uint32 {
	return (volatile.LoadUint32(&o.ERFIRSTSTAMP1.Reg) & 0x3fe0000) >> 17
}
func (o *RTC_Type) SetERFIRSTSTAMP1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP1.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP1.Reg)&^(0xfc000000)|value<<26)
}
func (o *RTC_Type) GetERFIRSTSTAMP1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ERFIRSTSTAMP1.Reg) & 0xfc000000) >> 26
}

// RTC.ERFIRSTSTAMP2: Event Monitor/Recorder First Stamp register for channel 0. Retains the time stamp for the first event on channel 0.
func (o *RTC_Type) SetERFIRSTSTAMP2_SEC(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP2.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP2.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetERFIRSTSTAMP2_SEC() uint32 {
	return volatile.LoadUint32(&o.ERFIRSTSTAMP2.Reg) & 0x3f
}
func (o *RTC_Type) SetERFIRSTSTAMP2_MIN(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP2.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP2.Reg)&^(0xfc0)|value<<6)
}
func (o *RTC_Type) GetERFIRSTSTAMP2_MIN() uint32 {
	return (volatile.LoadUint32(&o.ERFIRSTSTAMP2.Reg) & 0xfc0) >> 6
}
func (o *RTC_Type) SetERFIRSTSTAMP2_HOUR(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP2.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP2.Reg)&^(0x1f000)|value<<12)
}
func (o *RTC_Type) GetERFIRSTSTAMP2_HOUR() uint32 {
	return (volatile.LoadUint32(&o.ERFIRSTSTAMP2.Reg) & 0x1f000) >> 12
}
func (o *RTC_Type) SetERFIRSTSTAMP2_DOY(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP2.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP2.Reg)&^(0x3fe0000)|value<<17)
}
func (o *RTC_Type) GetERFIRSTSTAMP2_DOY() uint32 {
	return (volatile.LoadUint32(&o.ERFIRSTSTAMP2.Reg) & 0x3fe0000) >> 17
}
func (o *RTC_Type) SetERFIRSTSTAMP2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ERFIRSTSTAMP2.Reg, volatile.LoadUint32(&o.ERFIRSTSTAMP2.Reg)&^(0xfc000000)|value<<26)
}
func (o *RTC_Type) GetERFIRSTSTAMP2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ERFIRSTSTAMP2.Reg) & 0xfc000000) >> 26
}

// RTC.ERLASTSTAMP0: Event Monitor/Recorder Last Stamp register for channel 0. Retains the time stamp for the last (i.e. most recent) event on channel 0.
func (o *RTC_Type) SetERLASTSTAMP0_SEC(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP0.Reg, volatile.LoadUint32(&o.ERLASTSTAMP0.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetERLASTSTAMP0_SEC() uint32 {
	return volatile.LoadUint32(&o.ERLASTSTAMP0.Reg) & 0x3f
}
func (o *RTC_Type) SetERLASTSTAMP0_MIN(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP0.Reg, volatile.LoadUint32(&o.ERLASTSTAMP0.Reg)&^(0xfc0)|value<<6)
}
func (o *RTC_Type) GetERLASTSTAMP0_MIN() uint32 {
	return (volatile.LoadUint32(&o.ERLASTSTAMP0.Reg) & 0xfc0) >> 6
}
func (o *RTC_Type) SetERLASTSTAMP0_HOUR(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP0.Reg, volatile.LoadUint32(&o.ERLASTSTAMP0.Reg)&^(0x1f000)|value<<12)
}
func (o *RTC_Type) GetERLASTSTAMP0_HOUR() uint32 {
	return (volatile.LoadUint32(&o.ERLASTSTAMP0.Reg) & 0x1f000) >> 12
}
func (o *RTC_Type) SetERLASTSTAMP0_DOY(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP0.Reg, volatile.LoadUint32(&o.ERLASTSTAMP0.Reg)&^(0x3fe0000)|value<<17)
}
func (o *RTC_Type) GetERLASTSTAMP0_DOY() uint32 {
	return (volatile.LoadUint32(&o.ERLASTSTAMP0.Reg) & 0x3fe0000) >> 17
}
func (o *RTC_Type) SetERLASTSTAMP0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP0.Reg, volatile.LoadUint32(&o.ERLASTSTAMP0.Reg)&^(0xfc000000)|value<<26)
}
func (o *RTC_Type) GetERLASTSTAMP0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ERLASTSTAMP0.Reg) & 0xfc000000) >> 26
}

// RTC.ERLASTSTAMP1: Event Monitor/Recorder Last Stamp register for channel 0. Retains the time stamp for the last (i.e. most recent) event on channel 0.
func (o *RTC_Type) SetERLASTSTAMP1_SEC(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP1.Reg, volatile.LoadUint32(&o.ERLASTSTAMP1.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetERLASTSTAMP1_SEC() uint32 {
	return volatile.LoadUint32(&o.ERLASTSTAMP1.Reg) & 0x3f
}
func (o *RTC_Type) SetERLASTSTAMP1_MIN(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP1.Reg, volatile.LoadUint32(&o.ERLASTSTAMP1.Reg)&^(0xfc0)|value<<6)
}
func (o *RTC_Type) GetERLASTSTAMP1_MIN() uint32 {
	return (volatile.LoadUint32(&o.ERLASTSTAMP1.Reg) & 0xfc0) >> 6
}
func (o *RTC_Type) SetERLASTSTAMP1_HOUR(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP1.Reg, volatile.LoadUint32(&o.ERLASTSTAMP1.Reg)&^(0x1f000)|value<<12)
}
func (o *RTC_Type) GetERLASTSTAMP1_HOUR() uint32 {
	return (volatile.LoadUint32(&o.ERLASTSTAMP1.Reg) & 0x1f000) >> 12
}
func (o *RTC_Type) SetERLASTSTAMP1_DOY(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP1.Reg, volatile.LoadUint32(&o.ERLASTSTAMP1.Reg)&^(0x3fe0000)|value<<17)
}
func (o *RTC_Type) GetERLASTSTAMP1_DOY() uint32 {
	return (volatile.LoadUint32(&o.ERLASTSTAMP1.Reg) & 0x3fe0000) >> 17
}
func (o *RTC_Type) SetERLASTSTAMP1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP1.Reg, volatile.LoadUint32(&o.ERLASTSTAMP1.Reg)&^(0xfc000000)|value<<26)
}
func (o *RTC_Type) GetERLASTSTAMP1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ERLASTSTAMP1.Reg) & 0xfc000000) >> 26
}

// RTC.ERLASTSTAMP2: Event Monitor/Recorder Last Stamp register for channel 0. Retains the time stamp for the last (i.e. most recent) event on channel 0.
func (o *RTC_Type) SetERLASTSTAMP2_SEC(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP2.Reg, volatile.LoadUint32(&o.ERLASTSTAMP2.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetERLASTSTAMP2_SEC() uint32 {
	return volatile.LoadUint32(&o.ERLASTSTAMP2.Reg) & 0x3f
}
func (o *RTC_Type) SetERLASTSTAMP2_MIN(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP2.Reg, volatile.LoadUint32(&o.ERLASTSTAMP2.Reg)&^(0xfc0)|value<<6)
}
func (o *RTC_Type) GetERLASTSTAMP2_MIN() uint32 {
	return (volatile.LoadUint32(&o.ERLASTSTAMP2.Reg) & 0xfc0) >> 6
}
func (o *RTC_Type) SetERLASTSTAMP2_HOUR(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP2.Reg, volatile.LoadUint32(&o.ERLASTSTAMP2.Reg)&^(0x1f000)|value<<12)
}
func (o *RTC_Type) GetERLASTSTAMP2_HOUR() uint32 {
	return (volatile.LoadUint32(&o.ERLASTSTAMP2.Reg) & 0x1f000) >> 12
}
func (o *RTC_Type) SetERLASTSTAMP2_DOY(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP2.Reg, volatile.LoadUint32(&o.ERLASTSTAMP2.Reg)&^(0x3fe0000)|value<<17)
}
func (o *RTC_Type) GetERLASTSTAMP2_DOY() uint32 {
	return (volatile.LoadUint32(&o.ERLASTSTAMP2.Reg) & 0x3fe0000) >> 17
}
func (o *RTC_Type) SetERLASTSTAMP2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ERLASTSTAMP2.Reg, volatile.LoadUint32(&o.ERLASTSTAMP2.Reg)&^(0xfc000000)|value<<26)
}
func (o *RTC_Type) GetERLASTSTAMP2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ERLASTSTAMP2.Reg) & 0xfc000000) >> 26
}

// GPIO
type GPIOINT_Type struct {
	STATUS volatile.Register32 // 0x0
	STATR0 volatile.Register32 // 0x4
	STATF0 volatile.Register32 // 0x8
	CLR0   volatile.Register32 // 0xC
	ENR0   volatile.Register32 // 0x10
	ENF0   volatile.Register32 // 0x14
	_      [12]byte
	STATR2 volatile.Register32 // 0x24
	STATF2 volatile.Register32 // 0x28
	CLR2   volatile.Register32 // 0x2C
	ENR2   volatile.Register32 // 0x30
	ENF2   volatile.Register32 // 0x34
}

// GPIOINT.STATUS: GPIO overall Interrupt Status.
func (o *GPIOINT_Type) SetSTATUS_P0Int(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *GPIOINT_Type) GetSTATUS_P0Int() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1
}
func (o *GPIOINT_Type) SetSTATUS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *GPIOINT_Type) GetSTATUS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *GPIOINT_Type) SetSTATUS_P2Int(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x4)|value<<2)
}
func (o *GPIOINT_Type) GetSTATUS_P2Int() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x4) >> 2
}
func (o *GPIOINT_Type) SetSTATUS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0xfffffffc)|value<<2)
}
func (o *GPIOINT_Type) GetSTATUS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0xfffffffc) >> 2
}

// GPIOINT.STATR0: GPIO Interrupt Status for Rising edge for Port 0.
func (o *GPIOINT_Type) SetSTATR0_P0_0REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x1)|value)
}
func (o *GPIOINT_Type) GetSTATR0_P0_0REI() uint32 {
	return volatile.LoadUint32(&o.STATR0.Reg) & 0x1
}
func (o *GPIOINT_Type) SetSTATR0_P0_1REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x2)|value<<1)
}
func (o *GPIOINT_Type) GetSTATR0_P0_1REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x2) >> 1
}
func (o *GPIOINT_Type) SetSTATR0_P0_2REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x4)|value<<2)
}
func (o *GPIOINT_Type) GetSTATR0_P0_2REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x4) >> 2
}
func (o *GPIOINT_Type) SetSTATR0_P0_3REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x8)|value<<3)
}
func (o *GPIOINT_Type) GetSTATR0_P0_3REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x8) >> 3
}
func (o *GPIOINT_Type) SetSTATR0_P0_4REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x10)|value<<4)
}
func (o *GPIOINT_Type) GetSTATR0_P0_4REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x10) >> 4
}
func (o *GPIOINT_Type) SetSTATR0_P0_5REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x20)|value<<5)
}
func (o *GPIOINT_Type) GetSTATR0_P0_5REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x20) >> 5
}
func (o *GPIOINT_Type) SetSTATR0_P0_6REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x40)|value<<6)
}
func (o *GPIOINT_Type) GetSTATR0_P0_6REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x40) >> 6
}
func (o *GPIOINT_Type) SetSTATR0_P0_7REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x80)|value<<7)
}
func (o *GPIOINT_Type) GetSTATR0_P0_7REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x80) >> 7
}
func (o *GPIOINT_Type) SetSTATR0_P0_8REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x100)|value<<8)
}
func (o *GPIOINT_Type) GetSTATR0_P0_8REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x100) >> 8
}
func (o *GPIOINT_Type) SetSTATR0_P0_9REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x200)|value<<9)
}
func (o *GPIOINT_Type) GetSTATR0_P0_9REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x200) >> 9
}
func (o *GPIOINT_Type) SetSTATR0_P0_10REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x400)|value<<10)
}
func (o *GPIOINT_Type) GetSTATR0_P0_10REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x400) >> 10
}
func (o *GPIOINT_Type) SetSTATR0_P0_11REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x800)|value<<11)
}
func (o *GPIOINT_Type) GetSTATR0_P0_11REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x800) >> 11
}
func (o *GPIOINT_Type) SetSTATR0_P0_12REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x1000)|value<<12)
}
func (o *GPIOINT_Type) GetSTATR0_P0_12REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x1000) >> 12
}
func (o *GPIOINT_Type) SetSTATR0_P0_13REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x2000)|value<<13)
}
func (o *GPIOINT_Type) GetSTATR0_P0_13REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x2000) >> 13
}
func (o *GPIOINT_Type) SetSTATR0_P0_14REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x4000)|value<<14)
}
func (o *GPIOINT_Type) GetSTATR0_P0_14REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x4000) >> 14
}
func (o *GPIOINT_Type) SetSTATR0_P0_15REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x8000)|value<<15)
}
func (o *GPIOINT_Type) GetSTATR0_P0_15REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x8000) >> 15
}
func (o *GPIOINT_Type) SetSTATR0_P0_16REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x10000)|value<<16)
}
func (o *GPIOINT_Type) GetSTATR0_P0_16REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x10000) >> 16
}
func (o *GPIOINT_Type) SetSTATR0_P0_17REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x20000)|value<<17)
}
func (o *GPIOINT_Type) GetSTATR0_P0_17REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x20000) >> 17
}
func (o *GPIOINT_Type) SetSTATR0_P0_18REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x40000)|value<<18)
}
func (o *GPIOINT_Type) GetSTATR0_P0_18REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x40000) >> 18
}
func (o *GPIOINT_Type) SetSTATR0_P0_19REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x80000)|value<<19)
}
func (o *GPIOINT_Type) GetSTATR0_P0_19REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x80000) >> 19
}
func (o *GPIOINT_Type) SetSTATR0_P0_20REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x100000)|value<<20)
}
func (o *GPIOINT_Type) GetSTATR0_P0_20REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x100000) >> 20
}
func (o *GPIOINT_Type) SetSTATR0_P0_21REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x200000)|value<<21)
}
func (o *GPIOINT_Type) GetSTATR0_P0_21REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x200000) >> 21
}
func (o *GPIOINT_Type) SetSTATR0_P0_22REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x400000)|value<<22)
}
func (o *GPIOINT_Type) GetSTATR0_P0_22REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x400000) >> 22
}
func (o *GPIOINT_Type) SetSTATR0_P0_23REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x800000)|value<<23)
}
func (o *GPIOINT_Type) GetSTATR0_P0_23REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x800000) >> 23
}
func (o *GPIOINT_Type) SetSTATR0_P0_24REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIOINT_Type) GetSTATR0_P0_24REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x1000000) >> 24
}
func (o *GPIOINT_Type) SetSTATR0_P0_25REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIOINT_Type) GetSTATR0_P0_25REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x2000000) >> 25
}
func (o *GPIOINT_Type) SetSTATR0_P0_26REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIOINT_Type) GetSTATR0_P0_26REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x4000000) >> 26
}
func (o *GPIOINT_Type) SetSTATR0_P0_27REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIOINT_Type) GetSTATR0_P0_27REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x8000000) >> 27
}
func (o *GPIOINT_Type) SetSTATR0_P0_28REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIOINT_Type) GetSTATR0_P0_28REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x10000000) >> 28
}
func (o *GPIOINT_Type) SetSTATR0_P0_29REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIOINT_Type) GetSTATR0_P0_29REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x20000000) >> 29
}
func (o *GPIOINT_Type) SetSTATR0_P0_30REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIOINT_Type) GetSTATR0_P0_30REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x40000000) >> 30
}
func (o *GPIOINT_Type) SetSTATR0_P0_31REI(value uint32) {
	volatile.StoreUint32(&o.STATR0.Reg, volatile.LoadUint32(&o.STATR0.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIOINT_Type) GetSTATR0_P0_31REI() uint32 {
	return (volatile.LoadUint32(&o.STATR0.Reg) & 0x80000000) >> 31
}

// GPIOINT.STATF0: GPIO Interrupt Status for Falling edge for Port 0.
func (o *GPIOINT_Type) SetSTATF0_P0_0FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x1)|value)
}
func (o *GPIOINT_Type) GetSTATF0_P0_0FEI() uint32 {
	return volatile.LoadUint32(&o.STATF0.Reg) & 0x1
}
func (o *GPIOINT_Type) SetSTATF0_P0_1FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x2)|value<<1)
}
func (o *GPIOINT_Type) GetSTATF0_P0_1FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x2) >> 1
}
func (o *GPIOINT_Type) SetSTATF0_P0_2FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x4)|value<<2)
}
func (o *GPIOINT_Type) GetSTATF0_P0_2FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x4) >> 2
}
func (o *GPIOINT_Type) SetSTATF0_P0_3FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x8)|value<<3)
}
func (o *GPIOINT_Type) GetSTATF0_P0_3FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x8) >> 3
}
func (o *GPIOINT_Type) SetSTATF0_P0_4FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x10)|value<<4)
}
func (o *GPIOINT_Type) GetSTATF0_P0_4FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x10) >> 4
}
func (o *GPIOINT_Type) SetSTATF0_P0_5FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x20)|value<<5)
}
func (o *GPIOINT_Type) GetSTATF0_P0_5FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x20) >> 5
}
func (o *GPIOINT_Type) SetSTATF0_P0_6FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x40)|value<<6)
}
func (o *GPIOINT_Type) GetSTATF0_P0_6FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x40) >> 6
}
func (o *GPIOINT_Type) SetSTATF0_P0_7FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x80)|value<<7)
}
func (o *GPIOINT_Type) GetSTATF0_P0_7FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x80) >> 7
}
func (o *GPIOINT_Type) SetSTATF0_P0_8FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x100)|value<<8)
}
func (o *GPIOINT_Type) GetSTATF0_P0_8FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x100) >> 8
}
func (o *GPIOINT_Type) SetSTATF0_P0_9FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x200)|value<<9)
}
func (o *GPIOINT_Type) GetSTATF0_P0_9FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x200) >> 9
}
func (o *GPIOINT_Type) SetSTATF0_P0_10FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x400)|value<<10)
}
func (o *GPIOINT_Type) GetSTATF0_P0_10FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x400) >> 10
}
func (o *GPIOINT_Type) SetSTATF0_P0_11FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x800)|value<<11)
}
func (o *GPIOINT_Type) GetSTATF0_P0_11FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x800) >> 11
}
func (o *GPIOINT_Type) SetSTATF0_P0_12FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x1000)|value<<12)
}
func (o *GPIOINT_Type) GetSTATF0_P0_12FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x1000) >> 12
}
func (o *GPIOINT_Type) SetSTATF0_P0_13FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x2000)|value<<13)
}
func (o *GPIOINT_Type) GetSTATF0_P0_13FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x2000) >> 13
}
func (o *GPIOINT_Type) SetSTATF0_P0_14FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x4000)|value<<14)
}
func (o *GPIOINT_Type) GetSTATF0_P0_14FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x4000) >> 14
}
func (o *GPIOINT_Type) SetSTATF0_P0_15FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x8000)|value<<15)
}
func (o *GPIOINT_Type) GetSTATF0_P0_15FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x8000) >> 15
}
func (o *GPIOINT_Type) SetSTATF0_P0_16FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x10000)|value<<16)
}
func (o *GPIOINT_Type) GetSTATF0_P0_16FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x10000) >> 16
}
func (o *GPIOINT_Type) SetSTATF0_P0_17FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x20000)|value<<17)
}
func (o *GPIOINT_Type) GetSTATF0_P0_17FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x20000) >> 17
}
func (o *GPIOINT_Type) SetSTATF0_P0_18FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x40000)|value<<18)
}
func (o *GPIOINT_Type) GetSTATF0_P0_18FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x40000) >> 18
}
func (o *GPIOINT_Type) SetSTATF0_P0_19FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x80000)|value<<19)
}
func (o *GPIOINT_Type) GetSTATF0_P0_19FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x80000) >> 19
}
func (o *GPIOINT_Type) SetSTATF0_P0_20FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x100000)|value<<20)
}
func (o *GPIOINT_Type) GetSTATF0_P0_20FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x100000) >> 20
}
func (o *GPIOINT_Type) SetSTATF0_P0_21FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x200000)|value<<21)
}
func (o *GPIOINT_Type) GetSTATF0_P0_21FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x200000) >> 21
}
func (o *GPIOINT_Type) SetSTATF0_P0_22FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x400000)|value<<22)
}
func (o *GPIOINT_Type) GetSTATF0_P0_22FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x400000) >> 22
}
func (o *GPIOINT_Type) SetSTATF0_P0_23FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x800000)|value<<23)
}
func (o *GPIOINT_Type) GetSTATF0_P0_23FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x800000) >> 23
}
func (o *GPIOINT_Type) SetSTATF0_P0_24FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIOINT_Type) GetSTATF0_P0_24FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x1000000) >> 24
}
func (o *GPIOINT_Type) SetSTATF0_P0_25FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIOINT_Type) GetSTATF0_P0_25FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x2000000) >> 25
}
func (o *GPIOINT_Type) SetSTATF0_P0_26FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIOINT_Type) GetSTATF0_P0_26FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x4000000) >> 26
}
func (o *GPIOINT_Type) SetSTATF0_P0_27FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIOINT_Type) GetSTATF0_P0_27FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x8000000) >> 27
}
func (o *GPIOINT_Type) SetSTATF0_P0_28FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIOINT_Type) GetSTATF0_P0_28FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x10000000) >> 28
}
func (o *GPIOINT_Type) SetSTATF0_P0_29FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIOINT_Type) GetSTATF0_P0_29FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x20000000) >> 29
}
func (o *GPIOINT_Type) SetSTATF0_P0_30FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIOINT_Type) GetSTATF0_P0_30FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x40000000) >> 30
}
func (o *GPIOINT_Type) SetSTATF0_P0_31FEI(value uint32) {
	volatile.StoreUint32(&o.STATF0.Reg, volatile.LoadUint32(&o.STATF0.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIOINT_Type) GetSTATF0_P0_31FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF0.Reg) & 0x80000000) >> 31
}

// GPIOINT.CLR0: GPIO Interrupt Clear.
func (o *GPIOINT_Type) SetCLR0_P0_0CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x1)|value)
}
func (o *GPIOINT_Type) GetCLR0_P0_0CI() uint32 {
	return volatile.LoadUint32(&o.CLR0.Reg) & 0x1
}
func (o *GPIOINT_Type) SetCLR0_P0_1CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x2)|value<<1)
}
func (o *GPIOINT_Type) GetCLR0_P0_1CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x2) >> 1
}
func (o *GPIOINT_Type) SetCLR0_P0_2CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x4)|value<<2)
}
func (o *GPIOINT_Type) GetCLR0_P0_2CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x4) >> 2
}
func (o *GPIOINT_Type) SetCLR0_P0_3CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x8)|value<<3)
}
func (o *GPIOINT_Type) GetCLR0_P0_3CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x8) >> 3
}
func (o *GPIOINT_Type) SetCLR0_P0_4CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x10)|value<<4)
}
func (o *GPIOINT_Type) GetCLR0_P0_4CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x10) >> 4
}
func (o *GPIOINT_Type) SetCLR0_P0_5CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x20)|value<<5)
}
func (o *GPIOINT_Type) GetCLR0_P0_5CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x20) >> 5
}
func (o *GPIOINT_Type) SetCLR0_P0_6CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x40)|value<<6)
}
func (o *GPIOINT_Type) GetCLR0_P0_6CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x40) >> 6
}
func (o *GPIOINT_Type) SetCLR0_P0_7CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x80)|value<<7)
}
func (o *GPIOINT_Type) GetCLR0_P0_7CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x80) >> 7
}
func (o *GPIOINT_Type) SetCLR0_P0_8CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x100)|value<<8)
}
func (o *GPIOINT_Type) GetCLR0_P0_8CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x100) >> 8
}
func (o *GPIOINT_Type) SetCLR0_P0_9CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x200)|value<<9)
}
func (o *GPIOINT_Type) GetCLR0_P0_9CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x200) >> 9
}
func (o *GPIOINT_Type) SetCLR0_P0_10CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x400)|value<<10)
}
func (o *GPIOINT_Type) GetCLR0_P0_10CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x400) >> 10
}
func (o *GPIOINT_Type) SetCLR0_P0_11CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x800)|value<<11)
}
func (o *GPIOINT_Type) GetCLR0_P0_11CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x800) >> 11
}
func (o *GPIOINT_Type) SetCLR0_P0_12CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x1000)|value<<12)
}
func (o *GPIOINT_Type) GetCLR0_P0_12CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x1000) >> 12
}
func (o *GPIOINT_Type) SetCLR0_P0_13CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x2000)|value<<13)
}
func (o *GPIOINT_Type) GetCLR0_P0_13CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x2000) >> 13
}
func (o *GPIOINT_Type) SetCLR0_P0_14CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x4000)|value<<14)
}
func (o *GPIOINT_Type) GetCLR0_P0_14CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x4000) >> 14
}
func (o *GPIOINT_Type) SetCLR0_P0_15CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x8000)|value<<15)
}
func (o *GPIOINT_Type) GetCLR0_P0_15CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x8000) >> 15
}
func (o *GPIOINT_Type) SetCLR0_P0_16CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x10000)|value<<16)
}
func (o *GPIOINT_Type) GetCLR0_P0_16CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x10000) >> 16
}
func (o *GPIOINT_Type) SetCLR0_P0_17CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x20000)|value<<17)
}
func (o *GPIOINT_Type) GetCLR0_P0_17CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x20000) >> 17
}
func (o *GPIOINT_Type) SetCLR0_P0_18CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x40000)|value<<18)
}
func (o *GPIOINT_Type) GetCLR0_P0_18CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x40000) >> 18
}
func (o *GPIOINT_Type) SetCLR0_P0_19CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x80000)|value<<19)
}
func (o *GPIOINT_Type) GetCLR0_P0_19CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x80000) >> 19
}
func (o *GPIOINT_Type) SetCLR0_P0_20CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x100000)|value<<20)
}
func (o *GPIOINT_Type) GetCLR0_P0_20CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x100000) >> 20
}
func (o *GPIOINT_Type) SetCLR0_P0_21CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x200000)|value<<21)
}
func (o *GPIOINT_Type) GetCLR0_P0_21CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x200000) >> 21
}
func (o *GPIOINT_Type) SetCLR0_P0_22CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x400000)|value<<22)
}
func (o *GPIOINT_Type) GetCLR0_P0_22CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x400000) >> 22
}
func (o *GPIOINT_Type) SetCLR0_P0_23CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x800000)|value<<23)
}
func (o *GPIOINT_Type) GetCLR0_P0_23CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x800000) >> 23
}
func (o *GPIOINT_Type) SetCLR0_P0_24CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIOINT_Type) GetCLR0_P0_24CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x1000000) >> 24
}
func (o *GPIOINT_Type) SetCLR0_P0_25CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIOINT_Type) GetCLR0_P0_25CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x2000000) >> 25
}
func (o *GPIOINT_Type) SetCLR0_P0_26CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIOINT_Type) GetCLR0_P0_26CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x4000000) >> 26
}
func (o *GPIOINT_Type) SetCLR0_P0_27CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIOINT_Type) GetCLR0_P0_27CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x8000000) >> 27
}
func (o *GPIOINT_Type) SetCLR0_P0_28CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIOINT_Type) GetCLR0_P0_28CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x10000000) >> 28
}
func (o *GPIOINT_Type) SetCLR0_P0_29CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIOINT_Type) GetCLR0_P0_29CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x20000000) >> 29
}
func (o *GPIOINT_Type) SetCLR0_P0_30CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIOINT_Type) GetCLR0_P0_30CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x40000000) >> 30
}
func (o *GPIOINT_Type) SetCLR0_P0_31CI(value uint32) {
	volatile.StoreUint32(&o.CLR0.Reg, volatile.LoadUint32(&o.CLR0.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIOINT_Type) GetCLR0_P0_31CI() uint32 {
	return (volatile.LoadUint32(&o.CLR0.Reg) & 0x80000000) >> 31
}

// GPIOINT.ENR0: GPIO Interrupt Enable for Rising edge for Port 0.
func (o *GPIOINT_Type) SetENR0_P0_0ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x1)|value)
}
func (o *GPIOINT_Type) GetENR0_P0_0ER() uint32 {
	return volatile.LoadUint32(&o.ENR0.Reg) & 0x1
}
func (o *GPIOINT_Type) SetENR0_P0_1ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x2)|value<<1)
}
func (o *GPIOINT_Type) GetENR0_P0_1ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x2) >> 1
}
func (o *GPIOINT_Type) SetENR0_P0_2ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x4)|value<<2)
}
func (o *GPIOINT_Type) GetENR0_P0_2ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x4) >> 2
}
func (o *GPIOINT_Type) SetENR0_P0_3ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x8)|value<<3)
}
func (o *GPIOINT_Type) GetENR0_P0_3ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x8) >> 3
}
func (o *GPIOINT_Type) SetENR0_P0_4ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x10)|value<<4)
}
func (o *GPIOINT_Type) GetENR0_P0_4ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x10) >> 4
}
func (o *GPIOINT_Type) SetENR0_P0_5ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x20)|value<<5)
}
func (o *GPIOINT_Type) GetENR0_P0_5ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x20) >> 5
}
func (o *GPIOINT_Type) SetENR0_P0_6ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x40)|value<<6)
}
func (o *GPIOINT_Type) GetENR0_P0_6ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x40) >> 6
}
func (o *GPIOINT_Type) SetENR0_P0_7ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x80)|value<<7)
}
func (o *GPIOINT_Type) GetENR0_P0_7ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x80) >> 7
}
func (o *GPIOINT_Type) SetENR0_P0_8ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x100)|value<<8)
}
func (o *GPIOINT_Type) GetENR0_P0_8ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x100) >> 8
}
func (o *GPIOINT_Type) SetENR0_P0_9ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x200)|value<<9)
}
func (o *GPIOINT_Type) GetENR0_P0_9ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x200) >> 9
}
func (o *GPIOINT_Type) SetENR0_P0_10ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x400)|value<<10)
}
func (o *GPIOINT_Type) GetENR0_P0_10ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x400) >> 10
}
func (o *GPIOINT_Type) SetENR0_P0_11ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x800)|value<<11)
}
func (o *GPIOINT_Type) GetENR0_P0_11ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x800) >> 11
}
func (o *GPIOINT_Type) SetENR0_P0_12ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x1000)|value<<12)
}
func (o *GPIOINT_Type) GetENR0_P0_12ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x1000) >> 12
}
func (o *GPIOINT_Type) SetENR0_P0_13ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x2000)|value<<13)
}
func (o *GPIOINT_Type) GetENR0_P0_13ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x2000) >> 13
}
func (o *GPIOINT_Type) SetENR0_P0_14ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x4000)|value<<14)
}
func (o *GPIOINT_Type) GetENR0_P0_14ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x4000) >> 14
}
func (o *GPIOINT_Type) SetENR0_P0_15ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x8000)|value<<15)
}
func (o *GPIOINT_Type) GetENR0_P0_15ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x8000) >> 15
}
func (o *GPIOINT_Type) SetENR0_P0_16ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x10000)|value<<16)
}
func (o *GPIOINT_Type) GetENR0_P0_16ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x10000) >> 16
}
func (o *GPIOINT_Type) SetENR0_P0_17ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x20000)|value<<17)
}
func (o *GPIOINT_Type) GetENR0_P0_17ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x20000) >> 17
}
func (o *GPIOINT_Type) SetENR0_P0_18ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x40000)|value<<18)
}
func (o *GPIOINT_Type) GetENR0_P0_18ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x40000) >> 18
}
func (o *GPIOINT_Type) SetENR0_P0_19ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x80000)|value<<19)
}
func (o *GPIOINT_Type) GetENR0_P0_19ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x80000) >> 19
}
func (o *GPIOINT_Type) SetENR0_P0_20ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x100000)|value<<20)
}
func (o *GPIOINT_Type) GetENR0_P0_20ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x100000) >> 20
}
func (o *GPIOINT_Type) SetENR0_P0_21ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x200000)|value<<21)
}
func (o *GPIOINT_Type) GetENR0_P0_21ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x200000) >> 21
}
func (o *GPIOINT_Type) SetENR0_P0_22ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x400000)|value<<22)
}
func (o *GPIOINT_Type) GetENR0_P0_22ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x400000) >> 22
}
func (o *GPIOINT_Type) SetENR0_P0_23ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x800000)|value<<23)
}
func (o *GPIOINT_Type) GetENR0_P0_23ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x800000) >> 23
}
func (o *GPIOINT_Type) SetENR0_P0_24ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIOINT_Type) GetENR0_P0_24ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x1000000) >> 24
}
func (o *GPIOINT_Type) SetENR0_P0_25ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIOINT_Type) GetENR0_P0_25ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x2000000) >> 25
}
func (o *GPIOINT_Type) SetENR0_P0_26ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIOINT_Type) GetENR0_P0_26ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x4000000) >> 26
}
func (o *GPIOINT_Type) SetENR0_P0_27ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIOINT_Type) GetENR0_P0_27ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x8000000) >> 27
}
func (o *GPIOINT_Type) SetENR0_P0_28ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIOINT_Type) GetENR0_P0_28ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x10000000) >> 28
}
func (o *GPIOINT_Type) SetENR0_P0_29ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIOINT_Type) GetENR0_P0_29ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x20000000) >> 29
}
func (o *GPIOINT_Type) SetENR0_P0_30ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIOINT_Type) GetENR0_P0_30ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x40000000) >> 30
}
func (o *GPIOINT_Type) SetENR0_P0_31ER(value uint32) {
	volatile.StoreUint32(&o.ENR0.Reg, volatile.LoadUint32(&o.ENR0.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIOINT_Type) GetENR0_P0_31ER() uint32 {
	return (volatile.LoadUint32(&o.ENR0.Reg) & 0x80000000) >> 31
}

// GPIOINT.ENF0: GPIO Interrupt Enable for Falling edge for Port 0.
func (o *GPIOINT_Type) SetENF0_P0_0EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x1)|value)
}
func (o *GPIOINT_Type) GetENF0_P0_0EF() uint32 {
	return volatile.LoadUint32(&o.ENF0.Reg) & 0x1
}
func (o *GPIOINT_Type) SetENF0_P0_1EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x2)|value<<1)
}
func (o *GPIOINT_Type) GetENF0_P0_1EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x2) >> 1
}
func (o *GPIOINT_Type) SetENF0_P0_2EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x4)|value<<2)
}
func (o *GPIOINT_Type) GetENF0_P0_2EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x4) >> 2
}
func (o *GPIOINT_Type) SetENF0_P0_3EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x8)|value<<3)
}
func (o *GPIOINT_Type) GetENF0_P0_3EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x8) >> 3
}
func (o *GPIOINT_Type) SetENF0_P0_4EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x10)|value<<4)
}
func (o *GPIOINT_Type) GetENF0_P0_4EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x10) >> 4
}
func (o *GPIOINT_Type) SetENF0_P0_5EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x20)|value<<5)
}
func (o *GPIOINT_Type) GetENF0_P0_5EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x20) >> 5
}
func (o *GPIOINT_Type) SetENF0_P0_6EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x40)|value<<6)
}
func (o *GPIOINT_Type) GetENF0_P0_6EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x40) >> 6
}
func (o *GPIOINT_Type) SetENF0_P0_7EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x80)|value<<7)
}
func (o *GPIOINT_Type) GetENF0_P0_7EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x80) >> 7
}
func (o *GPIOINT_Type) SetENF0_P0_8EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x100)|value<<8)
}
func (o *GPIOINT_Type) GetENF0_P0_8EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x100) >> 8
}
func (o *GPIOINT_Type) SetENF0_P0_9EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x200)|value<<9)
}
func (o *GPIOINT_Type) GetENF0_P0_9EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x200) >> 9
}
func (o *GPIOINT_Type) SetENF0_P0_10EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x400)|value<<10)
}
func (o *GPIOINT_Type) GetENF0_P0_10EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x400) >> 10
}
func (o *GPIOINT_Type) SetENF0_P0_11EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x800)|value<<11)
}
func (o *GPIOINT_Type) GetENF0_P0_11EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x800) >> 11
}
func (o *GPIOINT_Type) SetENF0_P0_12EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x1000)|value<<12)
}
func (o *GPIOINT_Type) GetENF0_P0_12EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x1000) >> 12
}
func (o *GPIOINT_Type) SetENF0_P0_13EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x2000)|value<<13)
}
func (o *GPIOINT_Type) GetENF0_P0_13EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x2000) >> 13
}
func (o *GPIOINT_Type) SetENF0_P0_14EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x4000)|value<<14)
}
func (o *GPIOINT_Type) GetENF0_P0_14EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x4000) >> 14
}
func (o *GPIOINT_Type) SetENF0_P0_15EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x8000)|value<<15)
}
func (o *GPIOINT_Type) GetENF0_P0_15EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x8000) >> 15
}
func (o *GPIOINT_Type) SetENF0_P0_16EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x10000)|value<<16)
}
func (o *GPIOINT_Type) GetENF0_P0_16EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x10000) >> 16
}
func (o *GPIOINT_Type) SetENF0_P0_17EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x20000)|value<<17)
}
func (o *GPIOINT_Type) GetENF0_P0_17EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x20000) >> 17
}
func (o *GPIOINT_Type) SetENF0_P0_18EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x40000)|value<<18)
}
func (o *GPIOINT_Type) GetENF0_P0_18EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x40000) >> 18
}
func (o *GPIOINT_Type) SetENF0_P0_19EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x80000)|value<<19)
}
func (o *GPIOINT_Type) GetENF0_P0_19EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x80000) >> 19
}
func (o *GPIOINT_Type) SetENF0_P0_20EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x100000)|value<<20)
}
func (o *GPIOINT_Type) GetENF0_P0_20EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x100000) >> 20
}
func (o *GPIOINT_Type) SetENF0_P0_21EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x200000)|value<<21)
}
func (o *GPIOINT_Type) GetENF0_P0_21EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x200000) >> 21
}
func (o *GPIOINT_Type) SetENF0_P0_22EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x400000)|value<<22)
}
func (o *GPIOINT_Type) GetENF0_P0_22EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x400000) >> 22
}
func (o *GPIOINT_Type) SetENF0_P0_23EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x800000)|value<<23)
}
func (o *GPIOINT_Type) GetENF0_P0_23EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x800000) >> 23
}
func (o *GPIOINT_Type) SetENF0_P0_24EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIOINT_Type) GetENF0_P0_24EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x1000000) >> 24
}
func (o *GPIOINT_Type) SetENF0_P0_25EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIOINT_Type) GetENF0_P0_25EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x2000000) >> 25
}
func (o *GPIOINT_Type) SetENF0_P0_26EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIOINT_Type) GetENF0_P0_26EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x4000000) >> 26
}
func (o *GPIOINT_Type) SetENF0_P0_27EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIOINT_Type) GetENF0_P0_27EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x8000000) >> 27
}
func (o *GPIOINT_Type) SetENF0_P0_28EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIOINT_Type) GetENF0_P0_28EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x10000000) >> 28
}
func (o *GPIOINT_Type) SetENF0_P0_29EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIOINT_Type) GetENF0_P0_29EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x20000000) >> 29
}
func (o *GPIOINT_Type) SetENF0_P0_30EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIOINT_Type) GetENF0_P0_30EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x40000000) >> 30
}
func (o *GPIOINT_Type) SetENF0_P0_31EF(value uint32) {
	volatile.StoreUint32(&o.ENF0.Reg, volatile.LoadUint32(&o.ENF0.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIOINT_Type) GetENF0_P0_31EF() uint32 {
	return (volatile.LoadUint32(&o.ENF0.Reg) & 0x80000000) >> 31
}

// GPIOINT.STATR2: GPIO Interrupt Status for Rising edge for Port 0.
func (o *GPIOINT_Type) SetSTATR2_P2_0REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x1)|value)
}
func (o *GPIOINT_Type) GetSTATR2_P2_0REI() uint32 {
	return volatile.LoadUint32(&o.STATR2.Reg) & 0x1
}
func (o *GPIOINT_Type) SetSTATR2_P2_1REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x2)|value<<1)
}
func (o *GPIOINT_Type) GetSTATR2_P2_1REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x2) >> 1
}
func (o *GPIOINT_Type) SetSTATR2_P2_2REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x4)|value<<2)
}
func (o *GPIOINT_Type) GetSTATR2_P2_2REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x4) >> 2
}
func (o *GPIOINT_Type) SetSTATR2_P2_3REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x8)|value<<3)
}
func (o *GPIOINT_Type) GetSTATR2_P2_3REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x8) >> 3
}
func (o *GPIOINT_Type) SetSTATR2_P2_4REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x10)|value<<4)
}
func (o *GPIOINT_Type) GetSTATR2_P2_4REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x10) >> 4
}
func (o *GPIOINT_Type) SetSTATR2_P2_5REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x20)|value<<5)
}
func (o *GPIOINT_Type) GetSTATR2_P2_5REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x20) >> 5
}
func (o *GPIOINT_Type) SetSTATR2_P2_6REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x40)|value<<6)
}
func (o *GPIOINT_Type) GetSTATR2_P2_6REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x40) >> 6
}
func (o *GPIOINT_Type) SetSTATR2_P2_7REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x80)|value<<7)
}
func (o *GPIOINT_Type) GetSTATR2_P2_7REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x80) >> 7
}
func (o *GPIOINT_Type) SetSTATR2_P2_8REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x100)|value<<8)
}
func (o *GPIOINT_Type) GetSTATR2_P2_8REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x100) >> 8
}
func (o *GPIOINT_Type) SetSTATR2_P2_9REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x200)|value<<9)
}
func (o *GPIOINT_Type) GetSTATR2_P2_9REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x200) >> 9
}
func (o *GPIOINT_Type) SetSTATR2_P2_10REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x400)|value<<10)
}
func (o *GPIOINT_Type) GetSTATR2_P2_10REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x400) >> 10
}
func (o *GPIOINT_Type) SetSTATR2_P2_11REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x800)|value<<11)
}
func (o *GPIOINT_Type) GetSTATR2_P2_11REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x800) >> 11
}
func (o *GPIOINT_Type) SetSTATR2_P2_12REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x1000)|value<<12)
}
func (o *GPIOINT_Type) GetSTATR2_P2_12REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x1000) >> 12
}
func (o *GPIOINT_Type) SetSTATR2_P2_13REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x2000)|value<<13)
}
func (o *GPIOINT_Type) GetSTATR2_P2_13REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x2000) >> 13
}
func (o *GPIOINT_Type) SetSTATR2_P2_14REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x4000)|value<<14)
}
func (o *GPIOINT_Type) GetSTATR2_P2_14REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x4000) >> 14
}
func (o *GPIOINT_Type) SetSTATR2_P2_15REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x8000)|value<<15)
}
func (o *GPIOINT_Type) GetSTATR2_P2_15REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x8000) >> 15
}
func (o *GPIOINT_Type) SetSTATR2_P2_16REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x10000)|value<<16)
}
func (o *GPIOINT_Type) GetSTATR2_P2_16REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x10000) >> 16
}
func (o *GPIOINT_Type) SetSTATR2_P2_17REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x20000)|value<<17)
}
func (o *GPIOINT_Type) GetSTATR2_P2_17REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x20000) >> 17
}
func (o *GPIOINT_Type) SetSTATR2_P2_18REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x40000)|value<<18)
}
func (o *GPIOINT_Type) GetSTATR2_P2_18REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x40000) >> 18
}
func (o *GPIOINT_Type) SetSTATR2_P2_19REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x80000)|value<<19)
}
func (o *GPIOINT_Type) GetSTATR2_P2_19REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x80000) >> 19
}
func (o *GPIOINT_Type) SetSTATR2_P2_20REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x100000)|value<<20)
}
func (o *GPIOINT_Type) GetSTATR2_P2_20REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x100000) >> 20
}
func (o *GPIOINT_Type) SetSTATR2_P2_21REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x200000)|value<<21)
}
func (o *GPIOINT_Type) GetSTATR2_P2_21REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x200000) >> 21
}
func (o *GPIOINT_Type) SetSTATR2_P2_22REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x400000)|value<<22)
}
func (o *GPIOINT_Type) GetSTATR2_P2_22REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x400000) >> 22
}
func (o *GPIOINT_Type) SetSTATR2_P2_23REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x800000)|value<<23)
}
func (o *GPIOINT_Type) GetSTATR2_P2_23REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x800000) >> 23
}
func (o *GPIOINT_Type) SetSTATR2_P2_24REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIOINT_Type) GetSTATR2_P2_24REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x1000000) >> 24
}
func (o *GPIOINT_Type) SetSTATR2_P2_25REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIOINT_Type) GetSTATR2_P2_25REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x2000000) >> 25
}
func (o *GPIOINT_Type) SetSTATR2_P2_26REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIOINT_Type) GetSTATR2_P2_26REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x4000000) >> 26
}
func (o *GPIOINT_Type) SetSTATR2_P2_27REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIOINT_Type) GetSTATR2_P2_27REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x8000000) >> 27
}
func (o *GPIOINT_Type) SetSTATR2_P2_28REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIOINT_Type) GetSTATR2_P2_28REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x10000000) >> 28
}
func (o *GPIOINT_Type) SetSTATR2_P2_29REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIOINT_Type) GetSTATR2_P2_29REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x20000000) >> 29
}
func (o *GPIOINT_Type) SetSTATR2_P2_30REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIOINT_Type) GetSTATR2_P2_30REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x40000000) >> 30
}
func (o *GPIOINT_Type) SetSTATR2_P2_31REI(value uint32) {
	volatile.StoreUint32(&o.STATR2.Reg, volatile.LoadUint32(&o.STATR2.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIOINT_Type) GetSTATR2_P2_31REI() uint32 {
	return (volatile.LoadUint32(&o.STATR2.Reg) & 0x80000000) >> 31
}

// GPIOINT.STATF2: GPIO Interrupt Status for Falling edge for Port 0.
func (o *GPIOINT_Type) SetSTATF2_P2_0FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x1)|value)
}
func (o *GPIOINT_Type) GetSTATF2_P2_0FEI() uint32 {
	return volatile.LoadUint32(&o.STATF2.Reg) & 0x1
}
func (o *GPIOINT_Type) SetSTATF2_P2_1FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x2)|value<<1)
}
func (o *GPIOINT_Type) GetSTATF2_P2_1FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x2) >> 1
}
func (o *GPIOINT_Type) SetSTATF2_P2_2FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x4)|value<<2)
}
func (o *GPIOINT_Type) GetSTATF2_P2_2FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x4) >> 2
}
func (o *GPIOINT_Type) SetSTATF2_P2_3FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x8)|value<<3)
}
func (o *GPIOINT_Type) GetSTATF2_P2_3FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x8) >> 3
}
func (o *GPIOINT_Type) SetSTATF2_P2_4FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x10)|value<<4)
}
func (o *GPIOINT_Type) GetSTATF2_P2_4FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x10) >> 4
}
func (o *GPIOINT_Type) SetSTATF2_P2_5FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x20)|value<<5)
}
func (o *GPIOINT_Type) GetSTATF2_P2_5FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x20) >> 5
}
func (o *GPIOINT_Type) SetSTATF2_P2_6FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x40)|value<<6)
}
func (o *GPIOINT_Type) GetSTATF2_P2_6FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x40) >> 6
}
func (o *GPIOINT_Type) SetSTATF2_P2_7FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x80)|value<<7)
}
func (o *GPIOINT_Type) GetSTATF2_P2_7FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x80) >> 7
}
func (o *GPIOINT_Type) SetSTATF2_P2_8FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x100)|value<<8)
}
func (o *GPIOINT_Type) GetSTATF2_P2_8FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x100) >> 8
}
func (o *GPIOINT_Type) SetSTATF2_P2_9FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x200)|value<<9)
}
func (o *GPIOINT_Type) GetSTATF2_P2_9FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x200) >> 9
}
func (o *GPIOINT_Type) SetSTATF2_P2_10FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x400)|value<<10)
}
func (o *GPIOINT_Type) GetSTATF2_P2_10FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x400) >> 10
}
func (o *GPIOINT_Type) SetSTATF2_P2_11FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x800)|value<<11)
}
func (o *GPIOINT_Type) GetSTATF2_P2_11FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x800) >> 11
}
func (o *GPIOINT_Type) SetSTATF2_P2_12FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x1000)|value<<12)
}
func (o *GPIOINT_Type) GetSTATF2_P2_12FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x1000) >> 12
}
func (o *GPIOINT_Type) SetSTATF2_P2_13FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x2000)|value<<13)
}
func (o *GPIOINT_Type) GetSTATF2_P2_13FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x2000) >> 13
}
func (o *GPIOINT_Type) SetSTATF2_P2_14FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x4000)|value<<14)
}
func (o *GPIOINT_Type) GetSTATF2_P2_14FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x4000) >> 14
}
func (o *GPIOINT_Type) SetSTATF2_P2_15FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x8000)|value<<15)
}
func (o *GPIOINT_Type) GetSTATF2_P2_15FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x8000) >> 15
}
func (o *GPIOINT_Type) SetSTATF2_P2_16FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x10000)|value<<16)
}
func (o *GPIOINT_Type) GetSTATF2_P2_16FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x10000) >> 16
}
func (o *GPIOINT_Type) SetSTATF2_P2_17FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x20000)|value<<17)
}
func (o *GPIOINT_Type) GetSTATF2_P2_17FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x20000) >> 17
}
func (o *GPIOINT_Type) SetSTATF2_P2_18FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x40000)|value<<18)
}
func (o *GPIOINT_Type) GetSTATF2_P2_18FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x40000) >> 18
}
func (o *GPIOINT_Type) SetSTATF2_P2_19FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x80000)|value<<19)
}
func (o *GPIOINT_Type) GetSTATF2_P2_19FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x80000) >> 19
}
func (o *GPIOINT_Type) SetSTATF2_P2_20FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x100000)|value<<20)
}
func (o *GPIOINT_Type) GetSTATF2_P2_20FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x100000) >> 20
}
func (o *GPIOINT_Type) SetSTATF2_P2_21FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x200000)|value<<21)
}
func (o *GPIOINT_Type) GetSTATF2_P2_21FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x200000) >> 21
}
func (o *GPIOINT_Type) SetSTATF2_P2_22FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x400000)|value<<22)
}
func (o *GPIOINT_Type) GetSTATF2_P2_22FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x400000) >> 22
}
func (o *GPIOINT_Type) SetSTATF2_P2_23FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x800000)|value<<23)
}
func (o *GPIOINT_Type) GetSTATF2_P2_23FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x800000) >> 23
}
func (o *GPIOINT_Type) SetSTATF2_P2_24FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIOINT_Type) GetSTATF2_P2_24FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x1000000) >> 24
}
func (o *GPIOINT_Type) SetSTATF2_P2_25FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIOINT_Type) GetSTATF2_P2_25FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x2000000) >> 25
}
func (o *GPIOINT_Type) SetSTATF2_P2_26FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIOINT_Type) GetSTATF2_P2_26FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x4000000) >> 26
}
func (o *GPIOINT_Type) SetSTATF2_P2_27FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIOINT_Type) GetSTATF2_P2_27FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x8000000) >> 27
}
func (o *GPIOINT_Type) SetSTATF2_P2_28FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIOINT_Type) GetSTATF2_P2_28FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x10000000) >> 28
}
func (o *GPIOINT_Type) SetSTATF2_P2_29FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIOINT_Type) GetSTATF2_P2_29FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x20000000) >> 29
}
func (o *GPIOINT_Type) SetSTATF2_P2_30FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIOINT_Type) GetSTATF2_P2_30FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x40000000) >> 30
}
func (o *GPIOINT_Type) SetSTATF2_P2_31FEI(value uint32) {
	volatile.StoreUint32(&o.STATF2.Reg, volatile.LoadUint32(&o.STATF2.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIOINT_Type) GetSTATF2_P2_31FEI() uint32 {
	return (volatile.LoadUint32(&o.STATF2.Reg) & 0x80000000) >> 31
}

// GPIOINT.CLR2: GPIO Interrupt Clear.
func (o *GPIOINT_Type) SetCLR2_P2_0CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x1)|value)
}
func (o *GPIOINT_Type) GetCLR2_P2_0CI() uint32 {
	return volatile.LoadUint32(&o.CLR2.Reg) & 0x1
}
func (o *GPIOINT_Type) SetCLR2_P2_1CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x2)|value<<1)
}
func (o *GPIOINT_Type) GetCLR2_P2_1CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x2) >> 1
}
func (o *GPIOINT_Type) SetCLR2_P2_2CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x4)|value<<2)
}
func (o *GPIOINT_Type) GetCLR2_P2_2CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x4) >> 2
}
func (o *GPIOINT_Type) SetCLR2_P2_3CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x8)|value<<3)
}
func (o *GPIOINT_Type) GetCLR2_P2_3CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x8) >> 3
}
func (o *GPIOINT_Type) SetCLR2_P2_4CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x10)|value<<4)
}
func (o *GPIOINT_Type) GetCLR2_P2_4CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x10) >> 4
}
func (o *GPIOINT_Type) SetCLR2_P2_5CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x20)|value<<5)
}
func (o *GPIOINT_Type) GetCLR2_P2_5CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x20) >> 5
}
func (o *GPIOINT_Type) SetCLR2_P2_6CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x40)|value<<6)
}
func (o *GPIOINT_Type) GetCLR2_P2_6CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x40) >> 6
}
func (o *GPIOINT_Type) SetCLR2_P2_7CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x80)|value<<7)
}
func (o *GPIOINT_Type) GetCLR2_P2_7CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x80) >> 7
}
func (o *GPIOINT_Type) SetCLR2_P2_8CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x100)|value<<8)
}
func (o *GPIOINT_Type) GetCLR2_P2_8CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x100) >> 8
}
func (o *GPIOINT_Type) SetCLR2_P2_9CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x200)|value<<9)
}
func (o *GPIOINT_Type) GetCLR2_P2_9CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x200) >> 9
}
func (o *GPIOINT_Type) SetCLR2_P2_10CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x400)|value<<10)
}
func (o *GPIOINT_Type) GetCLR2_P2_10CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x400) >> 10
}
func (o *GPIOINT_Type) SetCLR2_P2_11CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x800)|value<<11)
}
func (o *GPIOINT_Type) GetCLR2_P2_11CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x800) >> 11
}
func (o *GPIOINT_Type) SetCLR2_P2_12CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x1000)|value<<12)
}
func (o *GPIOINT_Type) GetCLR2_P2_12CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x1000) >> 12
}
func (o *GPIOINT_Type) SetCLR2_P2_13CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x2000)|value<<13)
}
func (o *GPIOINT_Type) GetCLR2_P2_13CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x2000) >> 13
}
func (o *GPIOINT_Type) SetCLR2_P2_14CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x4000)|value<<14)
}
func (o *GPIOINT_Type) GetCLR2_P2_14CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x4000) >> 14
}
func (o *GPIOINT_Type) SetCLR2_P2_15CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x8000)|value<<15)
}
func (o *GPIOINT_Type) GetCLR2_P2_15CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x8000) >> 15
}
func (o *GPIOINT_Type) SetCLR2_P2_16CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x10000)|value<<16)
}
func (o *GPIOINT_Type) GetCLR2_P2_16CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x10000) >> 16
}
func (o *GPIOINT_Type) SetCLR2_P2_17CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x20000)|value<<17)
}
func (o *GPIOINT_Type) GetCLR2_P2_17CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x20000) >> 17
}
func (o *GPIOINT_Type) SetCLR2_P2_18CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x40000)|value<<18)
}
func (o *GPIOINT_Type) GetCLR2_P2_18CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x40000) >> 18
}
func (o *GPIOINT_Type) SetCLR2_P2_19CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x80000)|value<<19)
}
func (o *GPIOINT_Type) GetCLR2_P2_19CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x80000) >> 19
}
func (o *GPIOINT_Type) SetCLR2_P2_20CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x100000)|value<<20)
}
func (o *GPIOINT_Type) GetCLR2_P2_20CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x100000) >> 20
}
func (o *GPIOINT_Type) SetCLR2_P2_21CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x200000)|value<<21)
}
func (o *GPIOINT_Type) GetCLR2_P2_21CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x200000) >> 21
}
func (o *GPIOINT_Type) SetCLR2_P2_22CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x400000)|value<<22)
}
func (o *GPIOINT_Type) GetCLR2_P2_22CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x400000) >> 22
}
func (o *GPIOINT_Type) SetCLR2_P2_23CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x800000)|value<<23)
}
func (o *GPIOINT_Type) GetCLR2_P2_23CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x800000) >> 23
}
func (o *GPIOINT_Type) SetCLR2_P2_24CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIOINT_Type) GetCLR2_P2_24CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x1000000) >> 24
}
func (o *GPIOINT_Type) SetCLR2_P2_25CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIOINT_Type) GetCLR2_P2_25CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x2000000) >> 25
}
func (o *GPIOINT_Type) SetCLR2_P2_26CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIOINT_Type) GetCLR2_P2_26CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x4000000) >> 26
}
func (o *GPIOINT_Type) SetCLR2_P2_27CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIOINT_Type) GetCLR2_P2_27CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x8000000) >> 27
}
func (o *GPIOINT_Type) SetCLR2_P2_28CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIOINT_Type) GetCLR2_P2_28CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x10000000) >> 28
}
func (o *GPIOINT_Type) SetCLR2_P2_29CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIOINT_Type) GetCLR2_P2_29CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x20000000) >> 29
}
func (o *GPIOINT_Type) SetCLR2_P2_30CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIOINT_Type) GetCLR2_P2_30CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x40000000) >> 30
}
func (o *GPIOINT_Type) SetCLR2_P2_31CI(value uint32) {
	volatile.StoreUint32(&o.CLR2.Reg, volatile.LoadUint32(&o.CLR2.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIOINT_Type) GetCLR2_P2_31CI() uint32 {
	return (volatile.LoadUint32(&o.CLR2.Reg) & 0x80000000) >> 31
}

// GPIOINT.ENR2: GPIO Interrupt Enable for Rising edge for Port 0.
func (o *GPIOINT_Type) SetENR2_P2_0ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x1)|value)
}
func (o *GPIOINT_Type) GetENR2_P2_0ER() uint32 {
	return volatile.LoadUint32(&o.ENR2.Reg) & 0x1
}
func (o *GPIOINT_Type) SetENR2_P2_1ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x2)|value<<1)
}
func (o *GPIOINT_Type) GetENR2_P2_1ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x2) >> 1
}
func (o *GPIOINT_Type) SetENR2_P2_2ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x4)|value<<2)
}
func (o *GPIOINT_Type) GetENR2_P2_2ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x4) >> 2
}
func (o *GPIOINT_Type) SetENR2_P2_3ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x8)|value<<3)
}
func (o *GPIOINT_Type) GetENR2_P2_3ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x8) >> 3
}
func (o *GPIOINT_Type) SetENR2_P2_4ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x10)|value<<4)
}
func (o *GPIOINT_Type) GetENR2_P2_4ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x10) >> 4
}
func (o *GPIOINT_Type) SetENR2_P2_5ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x20)|value<<5)
}
func (o *GPIOINT_Type) GetENR2_P2_5ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x20) >> 5
}
func (o *GPIOINT_Type) SetENR2_P2_6ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x40)|value<<6)
}
func (o *GPIOINT_Type) GetENR2_P2_6ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x40) >> 6
}
func (o *GPIOINT_Type) SetENR2_P2_7ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x80)|value<<7)
}
func (o *GPIOINT_Type) GetENR2_P2_7ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x80) >> 7
}
func (o *GPIOINT_Type) SetENR2_P2_8ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x100)|value<<8)
}
func (o *GPIOINT_Type) GetENR2_P2_8ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x100) >> 8
}
func (o *GPIOINT_Type) SetENR2_P2_9ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x200)|value<<9)
}
func (o *GPIOINT_Type) GetENR2_P2_9ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x200) >> 9
}
func (o *GPIOINT_Type) SetENR2_P2_10ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x400)|value<<10)
}
func (o *GPIOINT_Type) GetENR2_P2_10ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x400) >> 10
}
func (o *GPIOINT_Type) SetENR2_P2_11ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x800)|value<<11)
}
func (o *GPIOINT_Type) GetENR2_P2_11ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x800) >> 11
}
func (o *GPIOINT_Type) SetENR2_P2_12ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x1000)|value<<12)
}
func (o *GPIOINT_Type) GetENR2_P2_12ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x1000) >> 12
}
func (o *GPIOINT_Type) SetENR2_P2_13ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x2000)|value<<13)
}
func (o *GPIOINT_Type) GetENR2_P2_13ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x2000) >> 13
}
func (o *GPIOINT_Type) SetENR2_P2_14ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x4000)|value<<14)
}
func (o *GPIOINT_Type) GetENR2_P2_14ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x4000) >> 14
}
func (o *GPIOINT_Type) SetENR2_P2_15ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x8000)|value<<15)
}
func (o *GPIOINT_Type) GetENR2_P2_15ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x8000) >> 15
}
func (o *GPIOINT_Type) SetENR2_P2_16ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x10000)|value<<16)
}
func (o *GPIOINT_Type) GetENR2_P2_16ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x10000) >> 16
}
func (o *GPIOINT_Type) SetENR2_P2_17ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x20000)|value<<17)
}
func (o *GPIOINT_Type) GetENR2_P2_17ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x20000) >> 17
}
func (o *GPIOINT_Type) SetENR2_P2_18ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x40000)|value<<18)
}
func (o *GPIOINT_Type) GetENR2_P2_18ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x40000) >> 18
}
func (o *GPIOINT_Type) SetENR2_P2_19ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x80000)|value<<19)
}
func (o *GPIOINT_Type) GetENR2_P2_19ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x80000) >> 19
}
func (o *GPIOINT_Type) SetENR2_P2_20ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x100000)|value<<20)
}
func (o *GPIOINT_Type) GetENR2_P2_20ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x100000) >> 20
}
func (o *GPIOINT_Type) SetENR2_P2_21ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x200000)|value<<21)
}
func (o *GPIOINT_Type) GetENR2_P2_21ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x200000) >> 21
}
func (o *GPIOINT_Type) SetENR2_P2_22ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x400000)|value<<22)
}
func (o *GPIOINT_Type) GetENR2_P2_22ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x400000) >> 22
}
func (o *GPIOINT_Type) SetENR2_P2_23ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x800000)|value<<23)
}
func (o *GPIOINT_Type) GetENR2_P2_23ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x800000) >> 23
}
func (o *GPIOINT_Type) SetENR2_P2_24ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIOINT_Type) GetENR2_P2_24ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x1000000) >> 24
}
func (o *GPIOINT_Type) SetENR2_P2_25ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIOINT_Type) GetENR2_P2_25ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x2000000) >> 25
}
func (o *GPIOINT_Type) SetENR2_P2_26ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIOINT_Type) GetENR2_P2_26ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x4000000) >> 26
}
func (o *GPIOINT_Type) SetENR2_P2_27ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIOINT_Type) GetENR2_P2_27ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x8000000) >> 27
}
func (o *GPIOINT_Type) SetENR2_P2_28ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIOINT_Type) GetENR2_P2_28ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x10000000) >> 28
}
func (o *GPIOINT_Type) SetENR2_P2_29ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIOINT_Type) GetENR2_P2_29ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x20000000) >> 29
}
func (o *GPIOINT_Type) SetENR2_P2_30ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIOINT_Type) GetENR2_P2_30ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x40000000) >> 30
}
func (o *GPIOINT_Type) SetENR2_P2_31ER(value uint32) {
	volatile.StoreUint32(&o.ENR2.Reg, volatile.LoadUint32(&o.ENR2.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIOINT_Type) GetENR2_P2_31ER() uint32 {
	return (volatile.LoadUint32(&o.ENR2.Reg) & 0x80000000) >> 31
}

// GPIOINT.ENF2: GPIO Interrupt Enable for Falling edge for Port 0.
func (o *GPIOINT_Type) SetENF2_P2_0EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x1)|value)
}
func (o *GPIOINT_Type) GetENF2_P2_0EF() uint32 {
	return volatile.LoadUint32(&o.ENF2.Reg) & 0x1
}
func (o *GPIOINT_Type) SetENF2_P2_1EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x2)|value<<1)
}
func (o *GPIOINT_Type) GetENF2_P2_1EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x2) >> 1
}
func (o *GPIOINT_Type) SetENF2_P2_2EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x4)|value<<2)
}
func (o *GPIOINT_Type) GetENF2_P2_2EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x4) >> 2
}
func (o *GPIOINT_Type) SetENF2_P2_3EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x8)|value<<3)
}
func (o *GPIOINT_Type) GetENF2_P2_3EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x8) >> 3
}
func (o *GPIOINT_Type) SetENF2_P2_4EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x10)|value<<4)
}
func (o *GPIOINT_Type) GetENF2_P2_4EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x10) >> 4
}
func (o *GPIOINT_Type) SetENF2_P2_5EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x20)|value<<5)
}
func (o *GPIOINT_Type) GetENF2_P2_5EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x20) >> 5
}
func (o *GPIOINT_Type) SetENF2_P2_6EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x40)|value<<6)
}
func (o *GPIOINT_Type) GetENF2_P2_6EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x40) >> 6
}
func (o *GPIOINT_Type) SetENF2_P2_7EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x80)|value<<7)
}
func (o *GPIOINT_Type) GetENF2_P2_7EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x80) >> 7
}
func (o *GPIOINT_Type) SetENF2_P2_8EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x100)|value<<8)
}
func (o *GPIOINT_Type) GetENF2_P2_8EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x100) >> 8
}
func (o *GPIOINT_Type) SetENF2_P2_9EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x200)|value<<9)
}
func (o *GPIOINT_Type) GetENF2_P2_9EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x200) >> 9
}
func (o *GPIOINT_Type) SetENF2_P2_10EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x400)|value<<10)
}
func (o *GPIOINT_Type) GetENF2_P2_10EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x400) >> 10
}
func (o *GPIOINT_Type) SetENF2_P2_11EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x800)|value<<11)
}
func (o *GPIOINT_Type) GetENF2_P2_11EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x800) >> 11
}
func (o *GPIOINT_Type) SetENF2_P2_12EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x1000)|value<<12)
}
func (o *GPIOINT_Type) GetENF2_P2_12EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x1000) >> 12
}
func (o *GPIOINT_Type) SetENF2_P2_13EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x2000)|value<<13)
}
func (o *GPIOINT_Type) GetENF2_P2_13EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x2000) >> 13
}
func (o *GPIOINT_Type) SetENF2_P2_14EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x4000)|value<<14)
}
func (o *GPIOINT_Type) GetENF2_P2_14EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x4000) >> 14
}
func (o *GPIOINT_Type) SetENF2_P2_15EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x8000)|value<<15)
}
func (o *GPIOINT_Type) GetENF2_P2_15EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x8000) >> 15
}
func (o *GPIOINT_Type) SetENF2_P2_16EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x10000)|value<<16)
}
func (o *GPIOINT_Type) GetENF2_P2_16EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x10000) >> 16
}
func (o *GPIOINT_Type) SetENF2_P2_17EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x20000)|value<<17)
}
func (o *GPIOINT_Type) GetENF2_P2_17EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x20000) >> 17
}
func (o *GPIOINT_Type) SetENF2_P2_18EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x40000)|value<<18)
}
func (o *GPIOINT_Type) GetENF2_P2_18EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x40000) >> 18
}
func (o *GPIOINT_Type) SetENF2_P2_19EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x80000)|value<<19)
}
func (o *GPIOINT_Type) GetENF2_P2_19EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x80000) >> 19
}
func (o *GPIOINT_Type) SetENF2_P2_20EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x100000)|value<<20)
}
func (o *GPIOINT_Type) GetENF2_P2_20EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x100000) >> 20
}
func (o *GPIOINT_Type) SetENF2_P2_21EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x200000)|value<<21)
}
func (o *GPIOINT_Type) GetENF2_P2_21EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x200000) >> 21
}
func (o *GPIOINT_Type) SetENF2_P2_22EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x400000)|value<<22)
}
func (o *GPIOINT_Type) GetENF2_P2_22EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x400000) >> 22
}
func (o *GPIOINT_Type) SetENF2_P2_23EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x800000)|value<<23)
}
func (o *GPIOINT_Type) GetENF2_P2_23EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x800000) >> 23
}
func (o *GPIOINT_Type) SetENF2_P2_24EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x1000000)|value<<24)
}
func (o *GPIOINT_Type) GetENF2_P2_24EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x1000000) >> 24
}
func (o *GPIOINT_Type) SetENF2_P2_25EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x2000000)|value<<25)
}
func (o *GPIOINT_Type) GetENF2_P2_25EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x2000000) >> 25
}
func (o *GPIOINT_Type) SetENF2_P2_26EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x4000000)|value<<26)
}
func (o *GPIOINT_Type) GetENF2_P2_26EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x4000000) >> 26
}
func (o *GPIOINT_Type) SetENF2_P2_27EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x8000000)|value<<27)
}
func (o *GPIOINT_Type) GetENF2_P2_27EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x8000000) >> 27
}
func (o *GPIOINT_Type) SetENF2_P2_28EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x10000000)|value<<28)
}
func (o *GPIOINT_Type) GetENF2_P2_28EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x10000000) >> 28
}
func (o *GPIOINT_Type) SetENF2_P2_29EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x20000000)|value<<29)
}
func (o *GPIOINT_Type) GetENF2_P2_29EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x20000000) >> 29
}
func (o *GPIOINT_Type) SetENF2_P2_30EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x40000000)|value<<30)
}
func (o *GPIOINT_Type) GetENF2_P2_30EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x40000000) >> 30
}
func (o *GPIOINT_Type) SetENF2_P2_31EF(value uint32) {
	volatile.StoreUint32(&o.ENF2.Reg, volatile.LoadUint32(&o.ENF2.Reg)&^(0x80000000)|value<<31)
}
func (o *GPIOINT_Type) GetENF2_P2_31EF() uint32 {
	return (volatile.LoadUint32(&o.ENF2.Reg) & 0x80000000) >> 31
}

// IOCON pin configuration
type IOCON_Type struct {
	P0_0  volatile.Register32 // 0x0
	P0_1  volatile.Register32 // 0x4
	P0_2  volatile.Register32 // 0x8
	P0_3  volatile.Register32 // 0xC
	P0_4  volatile.Register32 // 0x10
	P0_5  volatile.Register32 // 0x14
	P0_6  volatile.Register32 // 0x18
	P0_7  volatile.Register32 // 0x1C
	P0_8  volatile.Register32 // 0x20
	P0_9  volatile.Register32 // 0x24
	P0_10 volatile.Register32 // 0x28
	P0_11 volatile.Register32 // 0x2C
	P0_12 volatile.Register32 // 0x30
	P0_13 volatile.Register32 // 0x34
	P0_14 volatile.Register32 // 0x38
	P0_15 volatile.Register32 // 0x3C
	P0_16 volatile.Register32 // 0x40
	P0_17 volatile.Register32 // 0x44
	P0_18 volatile.Register32 // 0x48
	P0_19 volatile.Register32 // 0x4C
	P0_20 volatile.Register32 // 0x50
	P0_21 volatile.Register32 // 0x54
	P0_22 volatile.Register32 // 0x58
	P0_23 volatile.Register32 // 0x5C
	P0_24 volatile.Register32 // 0x60
	P0_25 volatile.Register32 // 0x64
	P0_26 volatile.Register32 // 0x68
	P0_27 volatile.Register32 // 0x6C
	P0_28 volatile.Register32 // 0x70
	P0_29 volatile.Register32 // 0x74
	P0_30 volatile.Register32 // 0x78
	P0_31 volatile.Register32 // 0x7C
	P1_0  volatile.Register32 // 0x80
	P1_1  volatile.Register32 // 0x84
	P1_2  volatile.Register32 // 0x88
	P1_3  volatile.Register32 // 0x8C
	P1_4  volatile.Register32 // 0x90
	P1_5  volatile.Register32 // 0x94
	P1_6  volatile.Register32 // 0x98
	P1_7  volatile.Register32 // 0x9C
	P1_8  volatile.Register32 // 0xA0
	P1_9  volatile.Register32 // 0xA4
	P1_10 volatile.Register32 // 0xA8
	P1_11 volatile.Register32 // 0xAC
	P1_12 volatile.Register32 // 0xB0
	P1_13 volatile.Register32 // 0xB4
	P1_14 volatile.Register32 // 0xB8
	P1_15 volatile.Register32 // 0xBC
	P1_16 volatile.Register32 // 0xC0
	P1_17 volatile.Register32 // 0xC4
	P1_18 volatile.Register32 // 0xC8
	P1_19 volatile.Register32 // 0xCC
	P1_20 volatile.Register32 // 0xD0
	P1_21 volatile.Register32 // 0xD4
	P1_22 volatile.Register32 // 0xD8
	P1_23 volatile.Register32 // 0xDC
	P1_24 volatile.Register32 // 0xE0
	P1_25 volatile.Register32 // 0xE4
	P1_26 volatile.Register32 // 0xE8
	P1_27 volatile.Register32 // 0xEC
	P1_28 volatile.Register32 // 0xF0
	P1_29 volatile.Register32 // 0xF4
	P1_30 volatile.Register32 // 0xF8
	P1_31 volatile.Register32 // 0xFC
	P2_0  volatile.Register32 // 0x100
	P2_1  volatile.Register32 // 0x104
	P2_2  volatile.Register32 // 0x108
	P2_3  volatile.Register32 // 0x10C
	P2_4  volatile.Register32 // 0x110
	P2_5  volatile.Register32 // 0x114
	P2_6  volatile.Register32 // 0x118
	P2_7  volatile.Register32 // 0x11C
	P2_8  volatile.Register32 // 0x120
	P2_9  volatile.Register32 // 0x124
	P2_10 volatile.Register32 // 0x128
	P2_11 volatile.Register32 // 0x12C
	P2_12 volatile.Register32 // 0x130
	P2_13 volatile.Register32 // 0x134
	P2_14 volatile.Register32 // 0x138
	P2_15 volatile.Register32 // 0x13C
	P2_16 volatile.Register32 // 0x140
	P2_17 volatile.Register32 // 0x144
	P2_18 volatile.Register32 // 0x148
	P2_19 volatile.Register32 // 0x14C
	P2_20 volatile.Register32 // 0x150
	P2_21 volatile.Register32 // 0x154
	P2_22 volatile.Register32 // 0x158
	P2_23 volatile.Register32 // 0x15C
	P2_24 volatile.Register32 // 0x160
	P2_25 volatile.Register32 // 0x164
	P2_26 volatile.Register32 // 0x168
	P2_27 volatile.Register32 // 0x16C
	P2_28 volatile.Register32 // 0x170
	P2_29 volatile.Register32 // 0x174
	P2_30 volatile.Register32 // 0x178
	P2_31 volatile.Register32 // 0x17C
	P3_0  volatile.Register32 // 0x180
	P3_1  volatile.Register32 // 0x184
	P3_2  volatile.Register32 // 0x188
	P3_3  volatile.Register32 // 0x18C
	P3_4  volatile.Register32 // 0x190
	P3_5  volatile.Register32 // 0x194
	P3_6  volatile.Register32 // 0x198
	P3_7  volatile.Register32 // 0x19C
	P3_8  volatile.Register32 // 0x1A0
	P3_9  volatile.Register32 // 0x1A4
	P3_10 volatile.Register32 // 0x1A8
	P3_11 volatile.Register32 // 0x1AC
	P3_12 volatile.Register32 // 0x1B0
	P3_13 volatile.Register32 // 0x1B4
	P3_14 volatile.Register32 // 0x1B8
	P3_15 volatile.Register32 // 0x1BC
	P3_16 volatile.Register32 // 0x1C0
	P3_17 volatile.Register32 // 0x1C4
	P3_18 volatile.Register32 // 0x1C8
	P3_19 volatile.Register32 // 0x1CC
	P3_20 volatile.Register32 // 0x1D0
	P3_21 volatile.Register32 // 0x1D4
	P3_22 volatile.Register32 // 0x1D8
	P3_23 volatile.Register32 // 0x1DC
	P3_24 volatile.Register32 // 0x1E0
	P3_25 volatile.Register32 // 0x1E4
	P3_26 volatile.Register32 // 0x1E8
	P3_27 volatile.Register32 // 0x1EC
	P3_28 volatile.Register32 // 0x1F0
	P3_29 volatile.Register32 // 0x1F4
	P3_30 volatile.Register32 // 0x1F8
	P3_31 volatile.Register32 // 0x1FC
	P4_0  volatile.Register32 // 0x200
	P4_1  volatile.Register32 // 0x204
	P4_2  volatile.Register32 // 0x208
	P4_3  volatile.Register32 // 0x20C
	P4_4  volatile.Register32 // 0x210
	P4_5  volatile.Register32 // 0x214
	P4_6  volatile.Register32 // 0x218
	P4_7  volatile.Register32 // 0x21C
	P4_8  volatile.Register32 // 0x220
	P4_9  volatile.Register32 // 0x224
	P4_10 volatile.Register32 // 0x228
	P4_11 volatile.Register32 // 0x22C
	P4_12 volatile.Register32 // 0x230
	P4_13 volatile.Register32 // 0x234
	P4_14 volatile.Register32 // 0x238
	P4_15 volatile.Register32 // 0x23C
	P4_16 volatile.Register32 // 0x240
	P4_17 volatile.Register32 // 0x244
	P4_18 volatile.Register32 // 0x248
	P4_19 volatile.Register32 // 0x24C
	P4_20 volatile.Register32 // 0x250
	P4_21 volatile.Register32 // 0x254
	P4_22 volatile.Register32 // 0x258
	P4_23 volatile.Register32 // 0x25C
	P4_24 volatile.Register32 // 0x260
	P4_25 volatile.Register32 // 0x264
	P4_26 volatile.Register32 // 0x268
	P4_27 volatile.Register32 // 0x26C
	P4_28 volatile.Register32 // 0x270
	P4_29 volatile.Register32 // 0x274
	P4_30 volatile.Register32 // 0x278
	P4_31 volatile.Register32 // 0x27C
	P5_0  volatile.Register32 // 0x280
	P5_1  volatile.Register32 // 0x284
	P5_2  volatile.Register32 // 0x288
	P5_3  volatile.Register32 // 0x28C
	P5_4  volatile.Register32 // 0x290
}

// IOCON.P0_0: I/O configuration register for pin P0[0]
func (o *IOCON_Type) SetP0_0_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_0.Reg, volatile.LoadUint32(&o.P0_0.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_0_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_0.Reg) & 0x7
}
func (o *IOCON_Type) SetP0_0_MODE(value uint32) {
	volatile.StoreUint32(&o.P0_0.Reg, volatile.LoadUint32(&o.P0_0.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP0_0_MODE() uint32 {
	return (volatile.LoadUint32(&o.P0_0.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP0_0_HYS(value uint32) {
	volatile.StoreUint32(&o.P0_0.Reg, volatile.LoadUint32(&o.P0_0.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP0_0_HYS() uint32 {
	return (volatile.LoadUint32(&o.P0_0.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP0_0_INV(value uint32) {
	volatile.StoreUint32(&o.P0_0.Reg, volatile.LoadUint32(&o.P0_0.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP0_0_INV() uint32 {
	return (volatile.LoadUint32(&o.P0_0.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP0_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_0.Reg, volatile.LoadUint32(&o.P0_0.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP0_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_0.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP0_0_SLEW(value uint32) {
	volatile.StoreUint32(&o.P0_0.Reg, volatile.LoadUint32(&o.P0_0.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP0_0_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P0_0.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP0_0_OD(value uint32) {
	volatile.StoreUint32(&o.P0_0.Reg, volatile.LoadUint32(&o.P0_0.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP0_0_OD() uint32 {
	return (volatile.LoadUint32(&o.P0_0.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP0_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_0.Reg, volatile.LoadUint32(&o.P0_0.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP0_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_0.Reg) & 0xfffff800) >> 11
}

// IOCON.P0_1: I/O configuration register for pin P0[1]
func (o *IOCON_Type) SetP0_1_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_1.Reg, volatile.LoadUint32(&o.P0_1.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_1_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_1.Reg) & 0x7
}
func (o *IOCON_Type) SetP0_1_MODE(value uint32) {
	volatile.StoreUint32(&o.P0_1.Reg, volatile.LoadUint32(&o.P0_1.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP0_1_MODE() uint32 {
	return (volatile.LoadUint32(&o.P0_1.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP0_1_HYS(value uint32) {
	volatile.StoreUint32(&o.P0_1.Reg, volatile.LoadUint32(&o.P0_1.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP0_1_HYS() uint32 {
	return (volatile.LoadUint32(&o.P0_1.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP0_1_INV(value uint32) {
	volatile.StoreUint32(&o.P0_1.Reg, volatile.LoadUint32(&o.P0_1.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP0_1_INV() uint32 {
	return (volatile.LoadUint32(&o.P0_1.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP0_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_1.Reg, volatile.LoadUint32(&o.P0_1.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP0_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_1.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP0_1_SLEW(value uint32) {
	volatile.StoreUint32(&o.P0_1.Reg, volatile.LoadUint32(&o.P0_1.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP0_1_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P0_1.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP0_1_OD(value uint32) {
	volatile.StoreUint32(&o.P0_1.Reg, volatile.LoadUint32(&o.P0_1.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP0_1_OD() uint32 {
	return (volatile.LoadUint32(&o.P0_1.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP0_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_1.Reg, volatile.LoadUint32(&o.P0_1.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP0_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_1.Reg) & 0xfffff800) >> 11
}

// IOCON.P0_2: I/O configuration register for pin P0[2]
func (o *IOCON_Type) SetP0_2_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_2.Reg, volatile.LoadUint32(&o.P0_2.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_2_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_2.Reg) & 0x7
}
func (o *IOCON_Type) SetP0_2_MODE(value uint32) {
	volatile.StoreUint32(&o.P0_2.Reg, volatile.LoadUint32(&o.P0_2.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP0_2_MODE() uint32 {
	return (volatile.LoadUint32(&o.P0_2.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP0_2_HYS(value uint32) {
	volatile.StoreUint32(&o.P0_2.Reg, volatile.LoadUint32(&o.P0_2.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP0_2_HYS() uint32 {
	return (volatile.LoadUint32(&o.P0_2.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP0_2_INV(value uint32) {
	volatile.StoreUint32(&o.P0_2.Reg, volatile.LoadUint32(&o.P0_2.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP0_2_INV() uint32 {
	return (volatile.LoadUint32(&o.P0_2.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP0_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_2.Reg, volatile.LoadUint32(&o.P0_2.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP0_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_2.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP0_2_SLEW(value uint32) {
	volatile.StoreUint32(&o.P0_2.Reg, volatile.LoadUint32(&o.P0_2.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP0_2_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P0_2.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP0_2_OD(value uint32) {
	volatile.StoreUint32(&o.P0_2.Reg, volatile.LoadUint32(&o.P0_2.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP0_2_OD() uint32 {
	return (volatile.LoadUint32(&o.P0_2.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP0_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_2.Reg, volatile.LoadUint32(&o.P0_2.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP0_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_2.Reg) & 0xfffff800) >> 11
}

// IOCON.P0_3: I/O configuration register for pin P0[3]
func (o *IOCON_Type) SetP0_3_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_3.Reg, volatile.LoadUint32(&o.P0_3.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_3_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_3.Reg) & 0x7
}
func (o *IOCON_Type) SetP0_3_MODE(value uint32) {
	volatile.StoreUint32(&o.P0_3.Reg, volatile.LoadUint32(&o.P0_3.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP0_3_MODE() uint32 {
	return (volatile.LoadUint32(&o.P0_3.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP0_3_HYS(value uint32) {
	volatile.StoreUint32(&o.P0_3.Reg, volatile.LoadUint32(&o.P0_3.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP0_3_HYS() uint32 {
	return (volatile.LoadUint32(&o.P0_3.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP0_3_INV(value uint32) {
	volatile.StoreUint32(&o.P0_3.Reg, volatile.LoadUint32(&o.P0_3.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP0_3_INV() uint32 {
	return (volatile.LoadUint32(&o.P0_3.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP0_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_3.Reg, volatile.LoadUint32(&o.P0_3.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP0_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_3.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP0_3_SLEW(value uint32) {
	volatile.StoreUint32(&o.P0_3.Reg, volatile.LoadUint32(&o.P0_3.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP0_3_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P0_3.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP0_3_OD(value uint32) {
	volatile.StoreUint32(&o.P0_3.Reg, volatile.LoadUint32(&o.P0_3.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP0_3_OD() uint32 {
	return (volatile.LoadUint32(&o.P0_3.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP0_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_3.Reg, volatile.LoadUint32(&o.P0_3.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP0_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_3.Reg) & 0xfffff800) >> 11
}

// IOCON.P0_4: I/O configuration register for pin P0[4]
func (o *IOCON_Type) SetP0_4_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_4.Reg, volatile.LoadUint32(&o.P0_4.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_4_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_4.Reg) & 0x7
}
func (o *IOCON_Type) SetP0_4_MODE(value uint32) {
	volatile.StoreUint32(&o.P0_4.Reg, volatile.LoadUint32(&o.P0_4.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP0_4_MODE() uint32 {
	return (volatile.LoadUint32(&o.P0_4.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP0_4_HYS(value uint32) {
	volatile.StoreUint32(&o.P0_4.Reg, volatile.LoadUint32(&o.P0_4.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP0_4_HYS() uint32 {
	return (volatile.LoadUint32(&o.P0_4.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP0_4_INV(value uint32) {
	volatile.StoreUint32(&o.P0_4.Reg, volatile.LoadUint32(&o.P0_4.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP0_4_INV() uint32 {
	return (volatile.LoadUint32(&o.P0_4.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP0_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_4.Reg, volatile.LoadUint32(&o.P0_4.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP0_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_4.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP0_4_SLEW(value uint32) {
	volatile.StoreUint32(&o.P0_4.Reg, volatile.LoadUint32(&o.P0_4.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP0_4_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P0_4.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP0_4_OD(value uint32) {
	volatile.StoreUint32(&o.P0_4.Reg, volatile.LoadUint32(&o.P0_4.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP0_4_OD() uint32 {
	return (volatile.LoadUint32(&o.P0_4.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP0_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_4.Reg, volatile.LoadUint32(&o.P0_4.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP0_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_4.Reg) & 0xfffff800) >> 11
}

// IOCON.P0_5: I/O configuration register for pin P0[5]
func (o *IOCON_Type) SetP0_5_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_5.Reg, volatile.LoadUint32(&o.P0_5.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_5_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_5.Reg) & 0x7
}
func (o *IOCON_Type) SetP0_5_MODE(value uint32) {
	volatile.StoreUint32(&o.P0_5.Reg, volatile.LoadUint32(&o.P0_5.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP0_5_MODE() uint32 {
	return (volatile.LoadUint32(&o.P0_5.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP0_5_HYS(value uint32) {
	volatile.StoreUint32(&o.P0_5.Reg, volatile.LoadUint32(&o.P0_5.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP0_5_HYS() uint32 {
	return (volatile.LoadUint32(&o.P0_5.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP0_5_INV(value uint32) {
	volatile.StoreUint32(&o.P0_5.Reg, volatile.LoadUint32(&o.P0_5.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP0_5_INV() uint32 {
	return (volatile.LoadUint32(&o.P0_5.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP0_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_5.Reg, volatile.LoadUint32(&o.P0_5.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP0_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_5.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP0_5_SLEW(value uint32) {
	volatile.StoreUint32(&o.P0_5.Reg, volatile.LoadUint32(&o.P0_5.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP0_5_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P0_5.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP0_5_OD(value uint32) {
	volatile.StoreUint32(&o.P0_5.Reg, volatile.LoadUint32(&o.P0_5.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP0_5_OD() uint32 {
	return (volatile.LoadUint32(&o.P0_5.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP0_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_5.Reg, volatile.LoadUint32(&o.P0_5.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP0_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_5.Reg) & 0xfffff800) >> 11
}

// IOCON.P0_6: I/O configuration register for pin P0[6]
func (o *IOCON_Type) SetP0_6_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_6.Reg, volatile.LoadUint32(&o.P0_6.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_6_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_6.Reg) & 0x7
}
func (o *IOCON_Type) SetP0_6_MODE(value uint32) {
	volatile.StoreUint32(&o.P0_6.Reg, volatile.LoadUint32(&o.P0_6.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP0_6_MODE() uint32 {
	return (volatile.LoadUint32(&o.P0_6.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP0_6_HYS(value uint32) {
	volatile.StoreUint32(&o.P0_6.Reg, volatile.LoadUint32(&o.P0_6.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP0_6_HYS() uint32 {
	return (volatile.LoadUint32(&o.P0_6.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP0_6_INV(value uint32) {
	volatile.StoreUint32(&o.P0_6.Reg, volatile.LoadUint32(&o.P0_6.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP0_6_INV() uint32 {
	return (volatile.LoadUint32(&o.P0_6.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP0_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_6.Reg, volatile.LoadUint32(&o.P0_6.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP0_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_6.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP0_6_SLEW(value uint32) {
	volatile.StoreUint32(&o.P0_6.Reg, volatile.LoadUint32(&o.P0_6.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP0_6_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P0_6.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP0_6_OD(value uint32) {
	volatile.StoreUint32(&o.P0_6.Reg, volatile.LoadUint32(&o.P0_6.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP0_6_OD() uint32 {
	return (volatile.LoadUint32(&o.P0_6.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP0_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_6.Reg, volatile.LoadUint32(&o.P0_6.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP0_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_6.Reg) & 0xfffff800) >> 11
}

// IOCON.P0_7: I/O configuration register for pin P0[7]
func (o *IOCON_Type) SetP0_7_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_7.Reg, volatile.LoadUint32(&o.P0_7.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_7_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_7.Reg) & 0x7
}
func (o *IOCON_Type) SetP0_7_MODE(value uint32) {
	volatile.StoreUint32(&o.P0_7.Reg, volatile.LoadUint32(&o.P0_7.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP0_7_MODE() uint32 {
	return (volatile.LoadUint32(&o.P0_7.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP0_7_HYS(value uint32) {
	volatile.StoreUint32(&o.P0_7.Reg, volatile.LoadUint32(&o.P0_7.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP0_7_HYS() uint32 {
	return (volatile.LoadUint32(&o.P0_7.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP0_7_INV(value uint32) {
	volatile.StoreUint32(&o.P0_7.Reg, volatile.LoadUint32(&o.P0_7.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP0_7_INV() uint32 {
	return (volatile.LoadUint32(&o.P0_7.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP0_7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_7.Reg, volatile.LoadUint32(&o.P0_7.Reg)&^(0x80)|value<<7)
}
func (o *IOCON_Type) GetP0_7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_7.Reg) & 0x80) >> 7
}
func (o *IOCON_Type) SetP0_7_FILTER(value uint32) {
	volatile.StoreUint32(&o.P0_7.Reg, volatile.LoadUint32(&o.P0_7.Reg)&^(0x100)|value<<8)
}
func (o *IOCON_Type) GetP0_7_FILTER() uint32 {
	return (volatile.LoadUint32(&o.P0_7.Reg) & 0x100) >> 8
}
func (o *IOCON_Type) SetP0_7_SLEW(value uint32) {
	volatile.StoreUint32(&o.P0_7.Reg, volatile.LoadUint32(&o.P0_7.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP0_7_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P0_7.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP0_7_OD(value uint32) {
	volatile.StoreUint32(&o.P0_7.Reg, volatile.LoadUint32(&o.P0_7.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP0_7_OD() uint32 {
	return (volatile.LoadUint32(&o.P0_7.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP0_7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_7.Reg, volatile.LoadUint32(&o.P0_7.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP0_7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_7.Reg) & 0xfffff800) >> 11
}

// IOCON.P0_8: I/O configuration register for pin P0[8]
func (o *IOCON_Type) SetP0_8_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_8.Reg, volatile.LoadUint32(&o.P0_8.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_8_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_8.Reg) & 0x7
}
func (o *IOCON_Type) SetP0_8_MODE(value uint32) {
	volatile.StoreUint32(&o.P0_8.Reg, volatile.LoadUint32(&o.P0_8.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP0_8_MODE() uint32 {
	return (volatile.LoadUint32(&o.P0_8.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP0_8_HYS(value uint32) {
	volatile.StoreUint32(&o.P0_8.Reg, volatile.LoadUint32(&o.P0_8.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP0_8_HYS() uint32 {
	return (volatile.LoadUint32(&o.P0_8.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP0_8_INV(value uint32) {
	volatile.StoreUint32(&o.P0_8.Reg, volatile.LoadUint32(&o.P0_8.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP0_8_INV() uint32 {
	return (volatile.LoadUint32(&o.P0_8.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP0_8_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_8.Reg, volatile.LoadUint32(&o.P0_8.Reg)&^(0x80)|value<<7)
}
func (o *IOCON_Type) GetP0_8_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_8.Reg) & 0x80) >> 7
}
func (o *IOCON_Type) SetP0_8_FILTER(value uint32) {
	volatile.StoreUint32(&o.P0_8.Reg, volatile.LoadUint32(&o.P0_8.Reg)&^(0x100)|value<<8)
}
func (o *IOCON_Type) GetP0_8_FILTER() uint32 {
	return (volatile.LoadUint32(&o.P0_8.Reg) & 0x100) >> 8
}
func (o *IOCON_Type) SetP0_8_SLEW(value uint32) {
	volatile.StoreUint32(&o.P0_8.Reg, volatile.LoadUint32(&o.P0_8.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP0_8_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P0_8.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP0_8_OD(value uint32) {
	volatile.StoreUint32(&o.P0_8.Reg, volatile.LoadUint32(&o.P0_8.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP0_8_OD() uint32 {
	return (volatile.LoadUint32(&o.P0_8.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP0_8_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_8.Reg, volatile.LoadUint32(&o.P0_8.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP0_8_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_8.Reg) & 0xfffff800) >> 11
}

// IOCON.P0_9: I/O configuration register for pin P0[9]
func (o *IOCON_Type) SetP0_9_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_9.Reg, volatile.LoadUint32(&o.P0_9.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_9_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_9.Reg) & 0x7
}
func (o *IOCON_Type) SetP0_9_MODE(value uint32) {
	volatile.StoreUint32(&o.P0_9.Reg, volatile.LoadUint32(&o.P0_9.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP0_9_MODE() uint32 {
	return (volatile.LoadUint32(&o.P0_9.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP0_9_HYS(value uint32) {
	volatile.StoreUint32(&o.P0_9.Reg, volatile.LoadUint32(&o.P0_9.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP0_9_HYS() uint32 {
	return (volatile.LoadUint32(&o.P0_9.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP0_9_INV(value uint32) {
	volatile.StoreUint32(&o.P0_9.Reg, volatile.LoadUint32(&o.P0_9.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP0_9_INV() uint32 {
	return (volatile.LoadUint32(&o.P0_9.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP0_9_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_9.Reg, volatile.LoadUint32(&o.P0_9.Reg)&^(0x80)|value<<7)
}
func (o *IOCON_Type) GetP0_9_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_9.Reg) & 0x80) >> 7
}
func (o *IOCON_Type) SetP0_9_FILTER(value uint32) {
	volatile.StoreUint32(&o.P0_9.Reg, volatile.LoadUint32(&o.P0_9.Reg)&^(0x100)|value<<8)
}
func (o *IOCON_Type) GetP0_9_FILTER() uint32 {
	return (volatile.LoadUint32(&o.P0_9.Reg) & 0x100) >> 8
}
func (o *IOCON_Type) SetP0_9_SLEW(value uint32) {
	volatile.StoreUint32(&o.P0_9.Reg, volatile.LoadUint32(&o.P0_9.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP0_9_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P0_9.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP0_9_OD(value uint32) {
	volatile.StoreUint32(&o.P0_9.Reg, volatile.LoadUint32(&o.P0_9.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP0_9_OD() uint32 {
	return (volatile.LoadUint32(&o.P0_9.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP0_9_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_9.Reg, volatile.LoadUint32(&o.P0_9.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP0_9_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_9.Reg) & 0xfffff800) >> 11
}

// IOCON.P0_10: I/O configuration register for pin P0[10]
func (o *IOCON_Type) SetP0_10_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_10.Reg, volatile.LoadUint32(&o.P0_10.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_10_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_10.Reg) & 0x7
}
func (o *IOCON_Type) SetP0_10_MODE(value uint32) {
	volatile.StoreUint32(&o.P0_10.Reg, volatile.LoadUint32(&o.P0_10.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP0_10_MODE() uint32 {
	return (volatile.LoadUint32(&o.P0_10.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP0_10_HYS(value uint32) {
	volatile.StoreUint32(&o.P0_10.Reg, volatile.LoadUint32(&o.P0_10.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP0_10_HYS() uint32 {
	return (volatile.LoadUint32(&o.P0_10.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP0_10_INV(value uint32) {
	volatile.StoreUint32(&o.P0_10.Reg, volatile.LoadUint32(&o.P0_10.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP0_10_INV() uint32 {
	return (volatile.LoadUint32(&o.P0_10.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP0_10_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_10.Reg, volatile.LoadUint32(&o.P0_10.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP0_10_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_10.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP0_10_SLEW(value uint32) {
	volatile.StoreUint32(&o.P0_10.Reg, volatile.LoadUint32(&o.P0_10.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP0_10_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P0_10.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP0_10_OD(value uint32) {
	volatile.StoreUint32(&o.P0_10.Reg, volatile.LoadUint32(&o.P0_10.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP0_10_OD() uint32 {
	return (volatile.LoadUint32(&o.P0_10.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP0_10_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_10.Reg, volatile.LoadUint32(&o.P0_10.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP0_10_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_10.Reg) & 0xfffff800) >> 11
}

// IOCON.P0_11: I/O configuration register for pin P0[11]
func (o *IOCON_Type) SetP0_11_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_11.Reg, volatile.LoadUint32(&o.P0_11.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_11_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_11.Reg) & 0x7
}
func (o *IOCON_Type) SetP0_11_MODE(value uint32) {
	volatile.StoreUint32(&o.P0_11.Reg, volatile.LoadUint32(&o.P0_11.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP0_11_MODE() uint32 {
	return (volatile.LoadUint32(&o.P0_11.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP0_11_HYS(value uint32) {
	volatile.StoreUint32(&o.P0_11.Reg, volatile.LoadUint32(&o.P0_11.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP0_11_HYS() uint32 {
	return (volatile.LoadUint32(&o.P0_11.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP0_11_INV(value uint32) {
	volatile.StoreUint32(&o.P0_11.Reg, volatile.LoadUint32(&o.P0_11.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP0_11_INV() uint32 {
	return (volatile.LoadUint32(&o.P0_11.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP0_11_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_11.Reg, volatile.LoadUint32(&o.P0_11.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP0_11_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_11.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP0_11_SLEW(value uint32) {
	volatile.StoreUint32(&o.P0_11.Reg, volatile.LoadUint32(&o.P0_11.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP0_11_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P0_11.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP0_11_OD(value uint32) {
	volatile.StoreUint32(&o.P0_11.Reg, volatile.LoadUint32(&o.P0_11.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP0_11_OD() uint32 {
	return (volatile.LoadUint32(&o.P0_11.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP0_11_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_11.Reg, volatile.LoadUint32(&o.P0_11.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP0_11_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_11.Reg) & 0xfffff800) >> 11
}

// IOCON.P0_12: I/O configuration register for pin P0[12]
func (o *IOCON_Type) SetP0_12_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_12.Reg, volatile.LoadUint32(&o.P0_12.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_12_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_12.Reg) & 0x7
}

// IOCON.P0_13: I/O configuration register for pin P0[13]
func (o *IOCON_Type) SetP0_13_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_13.Reg, volatile.LoadUint32(&o.P0_13.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_13_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_13.Reg) & 0x7
}

// IOCON.P0_14: I/O configuration register for pin P0[14]
func (o *IOCON_Type) SetP0_14_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_14.Reg, volatile.LoadUint32(&o.P0_14.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_14_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_14.Reg) & 0x7
}
func (o *IOCON_Type) SetP0_14_MODE(value uint32) {
	volatile.StoreUint32(&o.P0_14.Reg, volatile.LoadUint32(&o.P0_14.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP0_14_MODE() uint32 {
	return (volatile.LoadUint32(&o.P0_14.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP0_14_HYS(value uint32) {
	volatile.StoreUint32(&o.P0_14.Reg, volatile.LoadUint32(&o.P0_14.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP0_14_HYS() uint32 {
	return (volatile.LoadUint32(&o.P0_14.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP0_14_INV(value uint32) {
	volatile.StoreUint32(&o.P0_14.Reg, volatile.LoadUint32(&o.P0_14.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP0_14_INV() uint32 {
	return (volatile.LoadUint32(&o.P0_14.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP0_14_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_14.Reg, volatile.LoadUint32(&o.P0_14.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP0_14_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_14.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP0_14_SLEW(value uint32) {
	volatile.StoreUint32(&o.P0_14.Reg, volatile.LoadUint32(&o.P0_14.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP0_14_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P0_14.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP0_14_OD(value uint32) {
	volatile.StoreUint32(&o.P0_14.Reg, volatile.LoadUint32(&o.P0_14.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP0_14_OD() uint32 {
	return (volatile.LoadUint32(&o.P0_14.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP0_14_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_14.Reg, volatile.LoadUint32(&o.P0_14.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP0_14_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_14.Reg) & 0xfffff800) >> 11
}

// IOCON.P0_15: I/O configuration register for pin P0[15]
func (o *IOCON_Type) SetP0_15_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_15.Reg, volatile.LoadUint32(&o.P0_15.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_15_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_15.Reg) & 0x7
}
func (o *IOCON_Type) SetP0_15_MODE(value uint32) {
	volatile.StoreUint32(&o.P0_15.Reg, volatile.LoadUint32(&o.P0_15.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP0_15_MODE() uint32 {
	return (volatile.LoadUint32(&o.P0_15.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP0_15_HYS(value uint32) {
	volatile.StoreUint32(&o.P0_15.Reg, volatile.LoadUint32(&o.P0_15.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP0_15_HYS() uint32 {
	return (volatile.LoadUint32(&o.P0_15.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP0_15_INV(value uint32) {
	volatile.StoreUint32(&o.P0_15.Reg, volatile.LoadUint32(&o.P0_15.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP0_15_INV() uint32 {
	return (volatile.LoadUint32(&o.P0_15.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP0_15_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_15.Reg, volatile.LoadUint32(&o.P0_15.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP0_15_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_15.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP0_15_SLEW(value uint32) {
	volatile.StoreUint32(&o.P0_15.Reg, volatile.LoadUint32(&o.P0_15.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP0_15_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P0_15.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP0_15_OD(value uint32) {
	volatile.StoreUint32(&o.P0_15.Reg, volatile.LoadUint32(&o.P0_15.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP0_15_OD() uint32 {
	return (volatile.LoadUint32(&o.P0_15.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP0_15_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_15.Reg, volatile.LoadUint32(&o.P0_15.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP0_15_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_15.Reg) & 0xfffff800) >> 11
}

// IOCON.P0_16: I/O configuration register for pin P0[16]
func (o *IOCON_Type) SetP0_16_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_16.Reg, volatile.LoadUint32(&o.P0_16.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_16_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_16.Reg) & 0x7
}
func (o *IOCON_Type) SetP0_16_MODE(value uint32) {
	volatile.StoreUint32(&o.P0_16.Reg, volatile.LoadUint32(&o.P0_16.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP0_16_MODE() uint32 {
	return (volatile.LoadUint32(&o.P0_16.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP0_16_HYS(value uint32) {
	volatile.StoreUint32(&o.P0_16.Reg, volatile.LoadUint32(&o.P0_16.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP0_16_HYS() uint32 {
	return (volatile.LoadUint32(&o.P0_16.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP0_16_INV(value uint32) {
	volatile.StoreUint32(&o.P0_16.Reg, volatile.LoadUint32(&o.P0_16.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP0_16_INV() uint32 {
	return (volatile.LoadUint32(&o.P0_16.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP0_16_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_16.Reg, volatile.LoadUint32(&o.P0_16.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP0_16_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_16.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP0_16_SLEW(value uint32) {
	volatile.StoreUint32(&o.P0_16.Reg, volatile.LoadUint32(&o.P0_16.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP0_16_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P0_16.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP0_16_OD(value uint32) {
	volatile.StoreUint32(&o.P0_16.Reg, volatile.LoadUint32(&o.P0_16.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP0_16_OD() uint32 {
	return (volatile.LoadUint32(&o.P0_16.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP0_16_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_16.Reg, volatile.LoadUint32(&o.P0_16.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP0_16_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_16.Reg) & 0xfffff800) >> 11
}

// IOCON.P0_17: I/O configuration register for pin P0[17]
func (o *IOCON_Type) SetP0_17_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_17.Reg, volatile.LoadUint32(&o.P0_17.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_17_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_17.Reg) & 0x7
}
func (o *IOCON_Type) SetP0_17_MODE(value uint32) {
	volatile.StoreUint32(&o.P0_17.Reg, volatile.LoadUint32(&o.P0_17.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP0_17_MODE() uint32 {
	return (volatile.LoadUint32(&o.P0_17.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP0_17_HYS(value uint32) {
	volatile.StoreUint32(&o.P0_17.Reg, volatile.LoadUint32(&o.P0_17.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP0_17_HYS() uint32 {
	return (volatile.LoadUint32(&o.P0_17.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP0_17_INV(value uint32) {
	volatile.StoreUint32(&o.P0_17.Reg, volatile.LoadUint32(&o.P0_17.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP0_17_INV() uint32 {
	return (volatile.LoadUint32(&o.P0_17.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP0_17_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_17.Reg, volatile.LoadUint32(&o.P0_17.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP0_17_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_17.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP0_17_SLEW(value uint32) {
	volatile.StoreUint32(&o.P0_17.Reg, volatile.LoadUint32(&o.P0_17.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP0_17_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P0_17.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP0_17_OD(value uint32) {
	volatile.StoreUint32(&o.P0_17.Reg, volatile.LoadUint32(&o.P0_17.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP0_17_OD() uint32 {
	return (volatile.LoadUint32(&o.P0_17.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP0_17_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_17.Reg, volatile.LoadUint32(&o.P0_17.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP0_17_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_17.Reg) & 0xfffff800) >> 11
}

// IOCON.P0_18: I/O configuration register for pin P0[18]
func (o *IOCON_Type) SetP0_18_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_18.Reg, volatile.LoadUint32(&o.P0_18.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_18_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_18.Reg) & 0x7
}
func (o *IOCON_Type) SetP0_18_MODE(value uint32) {
	volatile.StoreUint32(&o.P0_18.Reg, volatile.LoadUint32(&o.P0_18.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP0_18_MODE() uint32 {
	return (volatile.LoadUint32(&o.P0_18.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP0_18_HYS(value uint32) {
	volatile.StoreUint32(&o.P0_18.Reg, volatile.LoadUint32(&o.P0_18.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP0_18_HYS() uint32 {
	return (volatile.LoadUint32(&o.P0_18.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP0_18_INV(value uint32) {
	volatile.StoreUint32(&o.P0_18.Reg, volatile.LoadUint32(&o.P0_18.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP0_18_INV() uint32 {
	return (volatile.LoadUint32(&o.P0_18.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP0_18_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_18.Reg, volatile.LoadUint32(&o.P0_18.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP0_18_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_18.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP0_18_SLEW(value uint32) {
	volatile.StoreUint32(&o.P0_18.Reg, volatile.LoadUint32(&o.P0_18.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP0_18_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P0_18.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP0_18_OD(value uint32) {
	volatile.StoreUint32(&o.P0_18.Reg, volatile.LoadUint32(&o.P0_18.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP0_18_OD() uint32 {
	return (volatile.LoadUint32(&o.P0_18.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP0_18_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_18.Reg, volatile.LoadUint32(&o.P0_18.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP0_18_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_18.Reg) & 0xfffff800) >> 11
}

// IOCON.P0_19: I/O configuration register for pin P0[19]
func (o *IOCON_Type) SetP0_19_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_19.Reg, volatile.LoadUint32(&o.P0_19.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_19_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_19.Reg) & 0x7
}
func (o *IOCON_Type) SetP0_19_MODE(value uint32) {
	volatile.StoreUint32(&o.P0_19.Reg, volatile.LoadUint32(&o.P0_19.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP0_19_MODE() uint32 {
	return (volatile.LoadUint32(&o.P0_19.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP0_19_HYS(value uint32) {
	volatile.StoreUint32(&o.P0_19.Reg, volatile.LoadUint32(&o.P0_19.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP0_19_HYS() uint32 {
	return (volatile.LoadUint32(&o.P0_19.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP0_19_INV(value uint32) {
	volatile.StoreUint32(&o.P0_19.Reg, volatile.LoadUint32(&o.P0_19.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP0_19_INV() uint32 {
	return (volatile.LoadUint32(&o.P0_19.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP0_19_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_19.Reg, volatile.LoadUint32(&o.P0_19.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP0_19_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_19.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP0_19_SLEW(value uint32) {
	volatile.StoreUint32(&o.P0_19.Reg, volatile.LoadUint32(&o.P0_19.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP0_19_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P0_19.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP0_19_OD(value uint32) {
	volatile.StoreUint32(&o.P0_19.Reg, volatile.LoadUint32(&o.P0_19.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP0_19_OD() uint32 {
	return (volatile.LoadUint32(&o.P0_19.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP0_19_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_19.Reg, volatile.LoadUint32(&o.P0_19.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP0_19_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_19.Reg) & 0xfffff800) >> 11
}

// IOCON.P0_20: I/O configuration register for pin P0[20]
func (o *IOCON_Type) SetP0_20_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_20.Reg, volatile.LoadUint32(&o.P0_20.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_20_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_20.Reg) & 0x7
}
func (o *IOCON_Type) SetP0_20_MODE(value uint32) {
	volatile.StoreUint32(&o.P0_20.Reg, volatile.LoadUint32(&o.P0_20.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP0_20_MODE() uint32 {
	return (volatile.LoadUint32(&o.P0_20.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP0_20_HYS(value uint32) {
	volatile.StoreUint32(&o.P0_20.Reg, volatile.LoadUint32(&o.P0_20.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP0_20_HYS() uint32 {
	return (volatile.LoadUint32(&o.P0_20.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP0_20_INV(value uint32) {
	volatile.StoreUint32(&o.P0_20.Reg, volatile.LoadUint32(&o.P0_20.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP0_20_INV() uint32 {
	return (volatile.LoadUint32(&o.P0_20.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP0_20_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_20.Reg, volatile.LoadUint32(&o.P0_20.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP0_20_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_20.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP0_20_SLEW(value uint32) {
	volatile.StoreUint32(&o.P0_20.Reg, volatile.LoadUint32(&o.P0_20.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP0_20_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P0_20.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP0_20_OD(value uint32) {
	volatile.StoreUint32(&o.P0_20.Reg, volatile.LoadUint32(&o.P0_20.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP0_20_OD() uint32 {
	return (volatile.LoadUint32(&o.P0_20.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP0_20_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_20.Reg, volatile.LoadUint32(&o.P0_20.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP0_20_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_20.Reg) & 0xfffff800) >> 11
}

// IOCON.P0_21: I/O configuration register for pin P0[21]
func (o *IOCON_Type) SetP0_21_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_21.Reg, volatile.LoadUint32(&o.P0_21.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_21_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_21.Reg) & 0x7
}
func (o *IOCON_Type) SetP0_21_MODE(value uint32) {
	volatile.StoreUint32(&o.P0_21.Reg, volatile.LoadUint32(&o.P0_21.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP0_21_MODE() uint32 {
	return (volatile.LoadUint32(&o.P0_21.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP0_21_HYS(value uint32) {
	volatile.StoreUint32(&o.P0_21.Reg, volatile.LoadUint32(&o.P0_21.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP0_21_HYS() uint32 {
	return (volatile.LoadUint32(&o.P0_21.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP0_21_INV(value uint32) {
	volatile.StoreUint32(&o.P0_21.Reg, volatile.LoadUint32(&o.P0_21.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP0_21_INV() uint32 {
	return (volatile.LoadUint32(&o.P0_21.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP0_21_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_21.Reg, volatile.LoadUint32(&o.P0_21.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP0_21_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_21.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP0_21_SLEW(value uint32) {
	volatile.StoreUint32(&o.P0_21.Reg, volatile.LoadUint32(&o.P0_21.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP0_21_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P0_21.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP0_21_OD(value uint32) {
	volatile.StoreUint32(&o.P0_21.Reg, volatile.LoadUint32(&o.P0_21.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP0_21_OD() uint32 {
	return (volatile.LoadUint32(&o.P0_21.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP0_21_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_21.Reg, volatile.LoadUint32(&o.P0_21.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP0_21_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_21.Reg) & 0xfffff800) >> 11
}

// IOCON.P0_22: I/O configuration register for pin P0[22]
func (o *IOCON_Type) SetP0_22_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_22.Reg, volatile.LoadUint32(&o.P0_22.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_22_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_22.Reg) & 0x7
}
func (o *IOCON_Type) SetP0_22_MODE(value uint32) {
	volatile.StoreUint32(&o.P0_22.Reg, volatile.LoadUint32(&o.P0_22.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP0_22_MODE() uint32 {
	return (volatile.LoadUint32(&o.P0_22.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP0_22_HYS(value uint32) {
	volatile.StoreUint32(&o.P0_22.Reg, volatile.LoadUint32(&o.P0_22.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP0_22_HYS() uint32 {
	return (volatile.LoadUint32(&o.P0_22.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP0_22_INV(value uint32) {
	volatile.StoreUint32(&o.P0_22.Reg, volatile.LoadUint32(&o.P0_22.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP0_22_INV() uint32 {
	return (volatile.LoadUint32(&o.P0_22.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP0_22_ADMODE(value uint32) {
	volatile.StoreUint32(&o.P0_22.Reg, volatile.LoadUint32(&o.P0_22.Reg)&^(0x80)|value<<7)
}
func (o *IOCON_Type) GetP0_22_ADMODE() uint32 {
	return (volatile.LoadUint32(&o.P0_22.Reg) & 0x80) >> 7
}
func (o *IOCON_Type) SetP0_22_FILTR(value uint32) {
	volatile.StoreUint32(&o.P0_22.Reg, volatile.LoadUint32(&o.P0_22.Reg)&^(0x100)|value<<8)
}
func (o *IOCON_Type) GetP0_22_FILTR() uint32 {
	return (volatile.LoadUint32(&o.P0_22.Reg) & 0x100) >> 8
}
func (o *IOCON_Type) SetP0_22_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_22.Reg, volatile.LoadUint32(&o.P0_22.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP0_22_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_22.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP0_22_OD(value uint32) {
	volatile.StoreUint32(&o.P0_22.Reg, volatile.LoadUint32(&o.P0_22.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP0_22_OD() uint32 {
	return (volatile.LoadUint32(&o.P0_22.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP0_22_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_22.Reg, volatile.LoadUint32(&o.P0_22.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP0_22_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_22.Reg) & 0xfffff800) >> 11
}

// IOCON.P0_23: I/O configuration register for pin P0[23]
func (o *IOCON_Type) SetP0_23_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_23.Reg, volatile.LoadUint32(&o.P0_23.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_23_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_23.Reg) & 0x7
}

// IOCON.P0_24: I/O configuration register for pin P0[24]
func (o *IOCON_Type) SetP0_24_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_24.Reg, volatile.LoadUint32(&o.P0_24.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_24_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_24.Reg) & 0x7
}

// IOCON.P0_25: I/O configuration register for pin P0[25]
func (o *IOCON_Type) SetP0_25_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_25.Reg, volatile.LoadUint32(&o.P0_25.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_25_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_25.Reg) & 0x7
}

// IOCON.P0_26: I/O configuration register for pin P0[26]
func (o *IOCON_Type) SetP0_26_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_26.Reg, volatile.LoadUint32(&o.P0_26.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_26_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_26.Reg) & 0x7
}
func (o *IOCON_Type) SetP0_26_MODE(value uint32) {
	volatile.StoreUint32(&o.P0_26.Reg, volatile.LoadUint32(&o.P0_26.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP0_26_MODE() uint32 {
	return (volatile.LoadUint32(&o.P0_26.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP0_26_HYS(value uint32) {
	volatile.StoreUint32(&o.P0_26.Reg, volatile.LoadUint32(&o.P0_26.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP0_26_HYS() uint32 {
	return (volatile.LoadUint32(&o.P0_26.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP0_26_INV(value uint32) {
	volatile.StoreUint32(&o.P0_26.Reg, volatile.LoadUint32(&o.P0_26.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP0_26_INV() uint32 {
	return (volatile.LoadUint32(&o.P0_26.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP0_26_ADMODE(value uint32) {
	volatile.StoreUint32(&o.P0_26.Reg, volatile.LoadUint32(&o.P0_26.Reg)&^(0x80)|value<<7)
}
func (o *IOCON_Type) GetP0_26_ADMODE() uint32 {
	return (volatile.LoadUint32(&o.P0_26.Reg) & 0x80) >> 7
}
func (o *IOCON_Type) SetP0_26_FILTR(value uint32) {
	volatile.StoreUint32(&o.P0_26.Reg, volatile.LoadUint32(&o.P0_26.Reg)&^(0x100)|value<<8)
}
func (o *IOCON_Type) GetP0_26_FILTR() uint32 {
	return (volatile.LoadUint32(&o.P0_26.Reg) & 0x100) >> 8
}
func (o *IOCON_Type) SetP0_26_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_26.Reg, volatile.LoadUint32(&o.P0_26.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP0_26_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_26.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP0_26_OD(value uint32) {
	volatile.StoreUint32(&o.P0_26.Reg, volatile.LoadUint32(&o.P0_26.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP0_26_OD() uint32 {
	return (volatile.LoadUint32(&o.P0_26.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP0_26_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_26.Reg, volatile.LoadUint32(&o.P0_26.Reg)&^(0xf800)|value<<11)
}
func (o *IOCON_Type) GetP0_26_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_26.Reg) & 0xf800) >> 11
}
func (o *IOCON_Type) SetP0_26_DACEN(value uint32) {
	volatile.StoreUint32(&o.P0_26.Reg, volatile.LoadUint32(&o.P0_26.Reg)&^(0x10000)|value<<16)
}
func (o *IOCON_Type) GetP0_26_DACEN() uint32 {
	return (volatile.LoadUint32(&o.P0_26.Reg) & 0x10000) >> 16
}
func (o *IOCON_Type) SetP0_26_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_26.Reg, volatile.LoadUint32(&o.P0_26.Reg)&^(0xfffe0000)|value<<17)
}
func (o *IOCON_Type) GetP0_26_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_26.Reg) & 0xfffe0000) >> 17
}

// IOCON.P0_27: I/O configuration register for pin P0[27]
func (o *IOCON_Type) SetP0_27_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_27.Reg, volatile.LoadUint32(&o.P0_27.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_27_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_27.Reg) & 0x7
}
func (o *IOCON_Type) SetP0_27_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_27.Reg, volatile.LoadUint32(&o.P0_27.Reg)&^(0x38)|value<<3)
}
func (o *IOCON_Type) GetP0_27_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_27.Reg) & 0x38) >> 3
}
func (o *IOCON_Type) SetP0_27_INV(value uint32) {
	volatile.StoreUint32(&o.P0_27.Reg, volatile.LoadUint32(&o.P0_27.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP0_27_INV() uint32 {
	return (volatile.LoadUint32(&o.P0_27.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP0_27_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_27.Reg, volatile.LoadUint32(&o.P0_27.Reg)&^(0x80)|value<<7)
}
func (o *IOCON_Type) GetP0_27_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_27.Reg) & 0x80) >> 7
}
func (o *IOCON_Type) SetP0_27_HS(value uint32) {
	volatile.StoreUint32(&o.P0_27.Reg, volatile.LoadUint32(&o.P0_27.Reg)&^(0x100)|value<<8)
}
func (o *IOCON_Type) GetP0_27_HS() uint32 {
	return (volatile.LoadUint32(&o.P0_27.Reg) & 0x100) >> 8
}
func (o *IOCON_Type) SetP0_27_HIDRIVE(value uint32) {
	volatile.StoreUint32(&o.P0_27.Reg, volatile.LoadUint32(&o.P0_27.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP0_27_HIDRIVE() uint32 {
	return (volatile.LoadUint32(&o.P0_27.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP0_27_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_27.Reg, volatile.LoadUint32(&o.P0_27.Reg)&^(0xfffffc00)|value<<10)
}
func (o *IOCON_Type) GetP0_27_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_27.Reg) & 0xfffffc00) >> 10
}

// IOCON.P0_28: I/O configuration register for pin P0[28]
func (o *IOCON_Type) SetP0_28_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_28.Reg, volatile.LoadUint32(&o.P0_28.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_28_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_28.Reg) & 0x7
}
func (o *IOCON_Type) SetP0_28_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_28.Reg, volatile.LoadUint32(&o.P0_28.Reg)&^(0x38)|value<<3)
}
func (o *IOCON_Type) GetP0_28_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_28.Reg) & 0x38) >> 3
}
func (o *IOCON_Type) SetP0_28_INV(value uint32) {
	volatile.StoreUint32(&o.P0_28.Reg, volatile.LoadUint32(&o.P0_28.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP0_28_INV() uint32 {
	return (volatile.LoadUint32(&o.P0_28.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP0_28_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_28.Reg, volatile.LoadUint32(&o.P0_28.Reg)&^(0x80)|value<<7)
}
func (o *IOCON_Type) GetP0_28_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_28.Reg) & 0x80) >> 7
}
func (o *IOCON_Type) SetP0_28_HS(value uint32) {
	volatile.StoreUint32(&o.P0_28.Reg, volatile.LoadUint32(&o.P0_28.Reg)&^(0x100)|value<<8)
}
func (o *IOCON_Type) GetP0_28_HS() uint32 {
	return (volatile.LoadUint32(&o.P0_28.Reg) & 0x100) >> 8
}
func (o *IOCON_Type) SetP0_28_HIDRIVE(value uint32) {
	volatile.StoreUint32(&o.P0_28.Reg, volatile.LoadUint32(&o.P0_28.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP0_28_HIDRIVE() uint32 {
	return (volatile.LoadUint32(&o.P0_28.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP0_28_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_28.Reg, volatile.LoadUint32(&o.P0_28.Reg)&^(0xfffffc00)|value<<10)
}
func (o *IOCON_Type) GetP0_28_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_28.Reg) & 0xfffffc00) >> 10
}

// IOCON.P0_29: I/O configuration register for pin P0[29]
func (o *IOCON_Type) SetP0_29_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_29.Reg, volatile.LoadUint32(&o.P0_29.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_29_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_29.Reg) & 0x7
}
func (o *IOCON_Type) SetP0_29_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_29.Reg, volatile.LoadUint32(&o.P0_29.Reg)&^(0xfffffff8)|value<<3)
}
func (o *IOCON_Type) GetP0_29_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_29.Reg) & 0xfffffff8) >> 3
}

// IOCON.P0_30: I/O configuration register for pin P0[30]
func (o *IOCON_Type) SetP0_30_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_30.Reg, volatile.LoadUint32(&o.P0_30.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_30_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_30.Reg) & 0x7
}
func (o *IOCON_Type) SetP0_30_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_30.Reg, volatile.LoadUint32(&o.P0_30.Reg)&^(0xfffffff8)|value<<3)
}
func (o *IOCON_Type) GetP0_30_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_30.Reg) & 0xfffffff8) >> 3
}

// IOCON.P0_31: I/O configuration register for pin P0[31]
func (o *IOCON_Type) SetP0_31_FUNC(value uint32) {
	volatile.StoreUint32(&o.P0_31.Reg, volatile.LoadUint32(&o.P0_31.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP0_31_FUNC() uint32 {
	return volatile.LoadUint32(&o.P0_31.Reg) & 0x7
}
func (o *IOCON_Type) SetP0_31_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P0_31.Reg, volatile.LoadUint32(&o.P0_31.Reg)&^(0xfffffff8)|value<<3)
}
func (o *IOCON_Type) GetP0_31_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P0_31.Reg) & 0xfffffff8) >> 3
}

// IOCON.P1_0: I/O configuration register for pin P1[0]
func (o *IOCON_Type) SetP1_0_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_0.Reg, volatile.LoadUint32(&o.P1_0.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_0_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_0.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_0_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_0.Reg, volatile.LoadUint32(&o.P1_0.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_0_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_0.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_0_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_0.Reg, volatile.LoadUint32(&o.P1_0.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_0_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_0.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_0_INV(value uint32) {
	volatile.StoreUint32(&o.P1_0.Reg, volatile.LoadUint32(&o.P1_0.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_0_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_0.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_0.Reg, volatile.LoadUint32(&o.P1_0.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_0.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_0_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_0.Reg, volatile.LoadUint32(&o.P1_0.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_0_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_0.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_0_OD(value uint32) {
	volatile.StoreUint32(&o.P1_0.Reg, volatile.LoadUint32(&o.P1_0.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_0_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_0.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_0.Reg, volatile.LoadUint32(&o.P1_0.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_0.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_1: I/O configuration register for pin P1[1]
func (o *IOCON_Type) SetP1_1_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_1.Reg, volatile.LoadUint32(&o.P1_1.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_1_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_1.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_1_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_1.Reg, volatile.LoadUint32(&o.P1_1.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_1_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_1.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_1_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_1.Reg, volatile.LoadUint32(&o.P1_1.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_1_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_1.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_1_INV(value uint32) {
	volatile.StoreUint32(&o.P1_1.Reg, volatile.LoadUint32(&o.P1_1.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_1_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_1.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_1.Reg, volatile.LoadUint32(&o.P1_1.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_1.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_1_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_1.Reg, volatile.LoadUint32(&o.P1_1.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_1_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_1.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_1_OD(value uint32) {
	volatile.StoreUint32(&o.P1_1.Reg, volatile.LoadUint32(&o.P1_1.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_1_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_1.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_1.Reg, volatile.LoadUint32(&o.P1_1.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_1.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_2: I/O configuration register for pin P1[2]
func (o *IOCON_Type) SetP1_2_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_2.Reg, volatile.LoadUint32(&o.P1_2.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_2_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_2.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_2_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_2.Reg, volatile.LoadUint32(&o.P1_2.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_2_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_2.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_2_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_2.Reg, volatile.LoadUint32(&o.P1_2.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_2_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_2.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_2_INV(value uint32) {
	volatile.StoreUint32(&o.P1_2.Reg, volatile.LoadUint32(&o.P1_2.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_2_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_2.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_2.Reg, volatile.LoadUint32(&o.P1_2.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_2.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_2_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_2.Reg, volatile.LoadUint32(&o.P1_2.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_2_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_2.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_2_OD(value uint32) {
	volatile.StoreUint32(&o.P1_2.Reg, volatile.LoadUint32(&o.P1_2.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_2_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_2.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_2.Reg, volatile.LoadUint32(&o.P1_2.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_2.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_3: I/O configuration register for pin P1[3]
func (o *IOCON_Type) SetP1_3_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_3.Reg, volatile.LoadUint32(&o.P1_3.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_3_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_3.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_3_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_3.Reg, volatile.LoadUint32(&o.P1_3.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_3_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_3.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_3_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_3.Reg, volatile.LoadUint32(&o.P1_3.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_3_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_3.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_3_INV(value uint32) {
	volatile.StoreUint32(&o.P1_3.Reg, volatile.LoadUint32(&o.P1_3.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_3_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_3.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_3.Reg, volatile.LoadUint32(&o.P1_3.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_3.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_3_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_3.Reg, volatile.LoadUint32(&o.P1_3.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_3_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_3.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_3_OD(value uint32) {
	volatile.StoreUint32(&o.P1_3.Reg, volatile.LoadUint32(&o.P1_3.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_3_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_3.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_3.Reg, volatile.LoadUint32(&o.P1_3.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_3.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_4: I/O configuration register for pin P1[4]
func (o *IOCON_Type) SetP1_4_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_4.Reg, volatile.LoadUint32(&o.P1_4.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_4_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_4.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_4_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_4.Reg, volatile.LoadUint32(&o.P1_4.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_4_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_4.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_4_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_4.Reg, volatile.LoadUint32(&o.P1_4.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_4_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_4.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_4_INV(value uint32) {
	volatile.StoreUint32(&o.P1_4.Reg, volatile.LoadUint32(&o.P1_4.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_4_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_4.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_4.Reg, volatile.LoadUint32(&o.P1_4.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_4.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_4_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_4.Reg, volatile.LoadUint32(&o.P1_4.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_4_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_4.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_4_OD(value uint32) {
	volatile.StoreUint32(&o.P1_4.Reg, volatile.LoadUint32(&o.P1_4.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_4_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_4.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_4.Reg, volatile.LoadUint32(&o.P1_4.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_4.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_5: I/O configuration register for pin P1[5]
func (o *IOCON_Type) SetP1_5_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_5.Reg, volatile.LoadUint32(&o.P1_5.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_5_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_5.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_5_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_5.Reg, volatile.LoadUint32(&o.P1_5.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_5_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_5.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_5_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_5.Reg, volatile.LoadUint32(&o.P1_5.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_5_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_5.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_5_INV(value uint32) {
	volatile.StoreUint32(&o.P1_5.Reg, volatile.LoadUint32(&o.P1_5.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_5_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_5.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_5.Reg, volatile.LoadUint32(&o.P1_5.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_5.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_5_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_5.Reg, volatile.LoadUint32(&o.P1_5.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_5_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_5.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_5_OD(value uint32) {
	volatile.StoreUint32(&o.P1_5.Reg, volatile.LoadUint32(&o.P1_5.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_5_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_5.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_5.Reg, volatile.LoadUint32(&o.P1_5.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_5.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_6: I/O configuration register for pin P1[6]
func (o *IOCON_Type) SetP1_6_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_6.Reg, volatile.LoadUint32(&o.P1_6.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_6_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_6.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_6_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_6.Reg, volatile.LoadUint32(&o.P1_6.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_6_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_6.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_6_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_6.Reg, volatile.LoadUint32(&o.P1_6.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_6_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_6.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_6_INV(value uint32) {
	volatile.StoreUint32(&o.P1_6.Reg, volatile.LoadUint32(&o.P1_6.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_6_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_6.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_6.Reg, volatile.LoadUint32(&o.P1_6.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_6.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_6_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_6.Reg, volatile.LoadUint32(&o.P1_6.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_6_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_6.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_6_OD(value uint32) {
	volatile.StoreUint32(&o.P1_6.Reg, volatile.LoadUint32(&o.P1_6.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_6_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_6.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_6.Reg, volatile.LoadUint32(&o.P1_6.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_6.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_7: I/O configuration register for pin P1[7]
func (o *IOCON_Type) SetP1_7_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_7.Reg, volatile.LoadUint32(&o.P1_7.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_7_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_7.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_7_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_7.Reg, volatile.LoadUint32(&o.P1_7.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_7_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_7.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_7_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_7.Reg, volatile.LoadUint32(&o.P1_7.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_7_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_7.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_7_INV(value uint32) {
	volatile.StoreUint32(&o.P1_7.Reg, volatile.LoadUint32(&o.P1_7.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_7_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_7.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_7.Reg, volatile.LoadUint32(&o.P1_7.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_7.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_7_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_7.Reg, volatile.LoadUint32(&o.P1_7.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_7_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_7.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_7_OD(value uint32) {
	volatile.StoreUint32(&o.P1_7.Reg, volatile.LoadUint32(&o.P1_7.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_7_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_7.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_7.Reg, volatile.LoadUint32(&o.P1_7.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_7.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_8: I/O configuration register for pin P1[8]
func (o *IOCON_Type) SetP1_8_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_8.Reg, volatile.LoadUint32(&o.P1_8.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_8_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_8.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_8_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_8.Reg, volatile.LoadUint32(&o.P1_8.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_8_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_8.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_8_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_8.Reg, volatile.LoadUint32(&o.P1_8.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_8_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_8.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_8_INV(value uint32) {
	volatile.StoreUint32(&o.P1_8.Reg, volatile.LoadUint32(&o.P1_8.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_8_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_8.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_8_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_8.Reg, volatile.LoadUint32(&o.P1_8.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_8_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_8.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_8_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_8.Reg, volatile.LoadUint32(&o.P1_8.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_8_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_8.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_8_OD(value uint32) {
	volatile.StoreUint32(&o.P1_8.Reg, volatile.LoadUint32(&o.P1_8.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_8_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_8.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_8_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_8.Reg, volatile.LoadUint32(&o.P1_8.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_8_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_8.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_9: I/O configuration register for pin P1[9]
func (o *IOCON_Type) SetP1_9_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_9.Reg, volatile.LoadUint32(&o.P1_9.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_9_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_9.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_9_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_9.Reg, volatile.LoadUint32(&o.P1_9.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_9_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_9.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_9_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_9.Reg, volatile.LoadUint32(&o.P1_9.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_9_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_9.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_9_INV(value uint32) {
	volatile.StoreUint32(&o.P1_9.Reg, volatile.LoadUint32(&o.P1_9.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_9_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_9.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_9_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_9.Reg, volatile.LoadUint32(&o.P1_9.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_9_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_9.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_9_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_9.Reg, volatile.LoadUint32(&o.P1_9.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_9_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_9.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_9_OD(value uint32) {
	volatile.StoreUint32(&o.P1_9.Reg, volatile.LoadUint32(&o.P1_9.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_9_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_9.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_9_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_9.Reg, volatile.LoadUint32(&o.P1_9.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_9_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_9.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_10: I/O configuration register for pin P1[10]
func (o *IOCON_Type) SetP1_10_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_10.Reg, volatile.LoadUint32(&o.P1_10.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_10_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_10.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_10_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_10.Reg, volatile.LoadUint32(&o.P1_10.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_10_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_10.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_10_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_10.Reg, volatile.LoadUint32(&o.P1_10.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_10_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_10.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_10_INV(value uint32) {
	volatile.StoreUint32(&o.P1_10.Reg, volatile.LoadUint32(&o.P1_10.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_10_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_10.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_10_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_10.Reg, volatile.LoadUint32(&o.P1_10.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_10_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_10.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_10_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_10.Reg, volatile.LoadUint32(&o.P1_10.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_10_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_10.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_10_OD(value uint32) {
	volatile.StoreUint32(&o.P1_10.Reg, volatile.LoadUint32(&o.P1_10.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_10_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_10.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_10_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_10.Reg, volatile.LoadUint32(&o.P1_10.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_10_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_10.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_11: I/O configuration register for pin P1[11]
func (o *IOCON_Type) SetP1_11_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_11.Reg, volatile.LoadUint32(&o.P1_11.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_11_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_11.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_11_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_11.Reg, volatile.LoadUint32(&o.P1_11.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_11_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_11.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_11_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_11.Reg, volatile.LoadUint32(&o.P1_11.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_11_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_11.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_11_INV(value uint32) {
	volatile.StoreUint32(&o.P1_11.Reg, volatile.LoadUint32(&o.P1_11.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_11_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_11.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_11_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_11.Reg, volatile.LoadUint32(&o.P1_11.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_11_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_11.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_11_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_11.Reg, volatile.LoadUint32(&o.P1_11.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_11_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_11.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_11_OD(value uint32) {
	volatile.StoreUint32(&o.P1_11.Reg, volatile.LoadUint32(&o.P1_11.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_11_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_11.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_11_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_11.Reg, volatile.LoadUint32(&o.P1_11.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_11_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_11.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_12: I/O configuration register for pin P1[12]
func (o *IOCON_Type) SetP1_12_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_12.Reg, volatile.LoadUint32(&o.P1_12.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_12_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_12.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_12_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_12.Reg, volatile.LoadUint32(&o.P1_12.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_12_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_12.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_12_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_12.Reg, volatile.LoadUint32(&o.P1_12.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_12_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_12.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_12_INV(value uint32) {
	volatile.StoreUint32(&o.P1_12.Reg, volatile.LoadUint32(&o.P1_12.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_12_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_12.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_12_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_12.Reg, volatile.LoadUint32(&o.P1_12.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_12_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_12.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_12_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_12.Reg, volatile.LoadUint32(&o.P1_12.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_12_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_12.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_12_OD(value uint32) {
	volatile.StoreUint32(&o.P1_12.Reg, volatile.LoadUint32(&o.P1_12.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_12_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_12.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_12_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_12.Reg, volatile.LoadUint32(&o.P1_12.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_12_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_12.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_13: I/O configuration register for pin P1[13]
func (o *IOCON_Type) SetP1_13_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_13.Reg, volatile.LoadUint32(&o.P1_13.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_13_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_13.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_13_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_13.Reg, volatile.LoadUint32(&o.P1_13.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_13_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_13.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_13_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_13.Reg, volatile.LoadUint32(&o.P1_13.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_13_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_13.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_13_INV(value uint32) {
	volatile.StoreUint32(&o.P1_13.Reg, volatile.LoadUint32(&o.P1_13.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_13_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_13.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_13_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_13.Reg, volatile.LoadUint32(&o.P1_13.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_13_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_13.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_13_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_13.Reg, volatile.LoadUint32(&o.P1_13.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_13_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_13.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_13_OD(value uint32) {
	volatile.StoreUint32(&o.P1_13.Reg, volatile.LoadUint32(&o.P1_13.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_13_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_13.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_13_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_13.Reg, volatile.LoadUint32(&o.P1_13.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_13_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_13.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_14: I/O configuration register for pin P1[14]
func (o *IOCON_Type) SetP1_14_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_14.Reg, volatile.LoadUint32(&o.P1_14.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_14_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_14.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_14_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_14.Reg, volatile.LoadUint32(&o.P1_14.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_14_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_14.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_14_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_14.Reg, volatile.LoadUint32(&o.P1_14.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_14_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_14.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_14_INV(value uint32) {
	volatile.StoreUint32(&o.P1_14.Reg, volatile.LoadUint32(&o.P1_14.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_14_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_14.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_14_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_14.Reg, volatile.LoadUint32(&o.P1_14.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_14_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_14.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_14_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_14.Reg, volatile.LoadUint32(&o.P1_14.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_14_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_14.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_14_OD(value uint32) {
	volatile.StoreUint32(&o.P1_14.Reg, volatile.LoadUint32(&o.P1_14.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_14_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_14.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_14_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_14.Reg, volatile.LoadUint32(&o.P1_14.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_14_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_14.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_15: I/O configuration register for pin P1[15]
func (o *IOCON_Type) SetP1_15_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_15.Reg, volatile.LoadUint32(&o.P1_15.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_15_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_15.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_15_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_15.Reg, volatile.LoadUint32(&o.P1_15.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_15_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_15.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_15_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_15.Reg, volatile.LoadUint32(&o.P1_15.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_15_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_15.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_15_INV(value uint32) {
	volatile.StoreUint32(&o.P1_15.Reg, volatile.LoadUint32(&o.P1_15.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_15_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_15.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_15_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_15.Reg, volatile.LoadUint32(&o.P1_15.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_15_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_15.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_15_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_15.Reg, volatile.LoadUint32(&o.P1_15.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_15_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_15.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_15_OD(value uint32) {
	volatile.StoreUint32(&o.P1_15.Reg, volatile.LoadUint32(&o.P1_15.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_15_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_15.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_15_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_15.Reg, volatile.LoadUint32(&o.P1_15.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_15_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_15.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_16: I/O configuration register for pin P1[16]
func (o *IOCON_Type) SetP1_16_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_16.Reg, volatile.LoadUint32(&o.P1_16.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_16_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_16.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_16_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_16.Reg, volatile.LoadUint32(&o.P1_16.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_16_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_16.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_16_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_16.Reg, volatile.LoadUint32(&o.P1_16.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_16_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_16.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_16_INV(value uint32) {
	volatile.StoreUint32(&o.P1_16.Reg, volatile.LoadUint32(&o.P1_16.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_16_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_16.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_16_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_16.Reg, volatile.LoadUint32(&o.P1_16.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_16_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_16.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_16_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_16.Reg, volatile.LoadUint32(&o.P1_16.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_16_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_16.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_16_OD(value uint32) {
	volatile.StoreUint32(&o.P1_16.Reg, volatile.LoadUint32(&o.P1_16.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_16_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_16.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_16_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_16.Reg, volatile.LoadUint32(&o.P1_16.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_16_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_16.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_17: I/O configuration register for pin P1[17]
func (o *IOCON_Type) SetP1_17_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_17.Reg, volatile.LoadUint32(&o.P1_17.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_17_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_17.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_17_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_17.Reg, volatile.LoadUint32(&o.P1_17.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_17_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_17.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_17_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_17.Reg, volatile.LoadUint32(&o.P1_17.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_17_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_17.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_17_INV(value uint32) {
	volatile.StoreUint32(&o.P1_17.Reg, volatile.LoadUint32(&o.P1_17.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_17_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_17.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_17_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_17.Reg, volatile.LoadUint32(&o.P1_17.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_17_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_17.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_17_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_17.Reg, volatile.LoadUint32(&o.P1_17.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_17_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_17.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_17_OD(value uint32) {
	volatile.StoreUint32(&o.P1_17.Reg, volatile.LoadUint32(&o.P1_17.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_17_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_17.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_17_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_17.Reg, volatile.LoadUint32(&o.P1_17.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_17_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_17.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_18: I/O configuration register for pin P1[18]
func (o *IOCON_Type) SetP1_18_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_18.Reg, volatile.LoadUint32(&o.P1_18.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_18_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_18.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_18_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_18.Reg, volatile.LoadUint32(&o.P1_18.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_18_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_18.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_18_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_18.Reg, volatile.LoadUint32(&o.P1_18.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_18_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_18.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_18_INV(value uint32) {
	volatile.StoreUint32(&o.P1_18.Reg, volatile.LoadUint32(&o.P1_18.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_18_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_18.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_18_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_18.Reg, volatile.LoadUint32(&o.P1_18.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_18_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_18.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_18_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_18.Reg, volatile.LoadUint32(&o.P1_18.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_18_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_18.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_18_OD(value uint32) {
	volatile.StoreUint32(&o.P1_18.Reg, volatile.LoadUint32(&o.P1_18.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_18_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_18.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_18_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_18.Reg, volatile.LoadUint32(&o.P1_18.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_18_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_18.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_19: I/O configuration register for pin P1[19]
func (o *IOCON_Type) SetP1_19_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_19.Reg, volatile.LoadUint32(&o.P1_19.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_19_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_19.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_19_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_19.Reg, volatile.LoadUint32(&o.P1_19.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_19_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_19.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_19_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_19.Reg, volatile.LoadUint32(&o.P1_19.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_19_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_19.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_19_INV(value uint32) {
	volatile.StoreUint32(&o.P1_19.Reg, volatile.LoadUint32(&o.P1_19.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_19_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_19.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_19_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_19.Reg, volatile.LoadUint32(&o.P1_19.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_19_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_19.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_19_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_19.Reg, volatile.LoadUint32(&o.P1_19.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_19_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_19.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_19_OD(value uint32) {
	volatile.StoreUint32(&o.P1_19.Reg, volatile.LoadUint32(&o.P1_19.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_19_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_19.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_19_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_19.Reg, volatile.LoadUint32(&o.P1_19.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_19_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_19.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_20: I/O configuration register for pin P1[20]
func (o *IOCON_Type) SetP1_20_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_20.Reg, volatile.LoadUint32(&o.P1_20.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_20_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_20.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_20_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_20.Reg, volatile.LoadUint32(&o.P1_20.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_20_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_20.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_20_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_20.Reg, volatile.LoadUint32(&o.P1_20.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_20_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_20.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_20_INV(value uint32) {
	volatile.StoreUint32(&o.P1_20.Reg, volatile.LoadUint32(&o.P1_20.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_20_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_20.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_20_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_20.Reg, volatile.LoadUint32(&o.P1_20.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_20_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_20.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_20_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_20.Reg, volatile.LoadUint32(&o.P1_20.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_20_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_20.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_20_OD(value uint32) {
	volatile.StoreUint32(&o.P1_20.Reg, volatile.LoadUint32(&o.P1_20.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_20_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_20.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_20_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_20.Reg, volatile.LoadUint32(&o.P1_20.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_20_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_20.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_21: I/O configuration register for pin P1[21]
func (o *IOCON_Type) SetP1_21_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_21.Reg, volatile.LoadUint32(&o.P1_21.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_21_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_21.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_21_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_21.Reg, volatile.LoadUint32(&o.P1_21.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_21_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_21.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_21_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_21.Reg, volatile.LoadUint32(&o.P1_21.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_21_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_21.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_21_INV(value uint32) {
	volatile.StoreUint32(&o.P1_21.Reg, volatile.LoadUint32(&o.P1_21.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_21_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_21.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_21_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_21.Reg, volatile.LoadUint32(&o.P1_21.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_21_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_21.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_21_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_21.Reg, volatile.LoadUint32(&o.P1_21.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_21_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_21.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_21_OD(value uint32) {
	volatile.StoreUint32(&o.P1_21.Reg, volatile.LoadUint32(&o.P1_21.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_21_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_21.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_21_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_21.Reg, volatile.LoadUint32(&o.P1_21.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_21_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_21.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_22: I/O configuration register for pin P1[22]
func (o *IOCON_Type) SetP1_22_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_22.Reg, volatile.LoadUint32(&o.P1_22.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_22_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_22.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_22_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_22.Reg, volatile.LoadUint32(&o.P1_22.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_22_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_22.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_22_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_22.Reg, volatile.LoadUint32(&o.P1_22.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_22_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_22.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_22_INV(value uint32) {
	volatile.StoreUint32(&o.P1_22.Reg, volatile.LoadUint32(&o.P1_22.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_22_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_22.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_22_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_22.Reg, volatile.LoadUint32(&o.P1_22.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_22_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_22.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_22_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_22.Reg, volatile.LoadUint32(&o.P1_22.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_22_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_22.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_22_OD(value uint32) {
	volatile.StoreUint32(&o.P1_22.Reg, volatile.LoadUint32(&o.P1_22.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_22_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_22.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_22_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_22.Reg, volatile.LoadUint32(&o.P1_22.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_22_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_22.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_23: I/O configuration register for pin P1[23]
func (o *IOCON_Type) SetP1_23_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_23.Reg, volatile.LoadUint32(&o.P1_23.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_23_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_23.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_23_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_23.Reg, volatile.LoadUint32(&o.P1_23.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_23_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_23.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_23_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_23.Reg, volatile.LoadUint32(&o.P1_23.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_23_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_23.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_23_INV(value uint32) {
	volatile.StoreUint32(&o.P1_23.Reg, volatile.LoadUint32(&o.P1_23.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_23_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_23.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_23_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_23.Reg, volatile.LoadUint32(&o.P1_23.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_23_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_23.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_23_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_23.Reg, volatile.LoadUint32(&o.P1_23.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_23_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_23.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_23_OD(value uint32) {
	volatile.StoreUint32(&o.P1_23.Reg, volatile.LoadUint32(&o.P1_23.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_23_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_23.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_23_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_23.Reg, volatile.LoadUint32(&o.P1_23.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_23_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_23.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_24: I/O configuration register for pin P1[24]
func (o *IOCON_Type) SetP1_24_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_24.Reg, volatile.LoadUint32(&o.P1_24.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_24_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_24.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_24_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_24.Reg, volatile.LoadUint32(&o.P1_24.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_24_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_24.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_24_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_24.Reg, volatile.LoadUint32(&o.P1_24.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_24_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_24.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_24_INV(value uint32) {
	volatile.StoreUint32(&o.P1_24.Reg, volatile.LoadUint32(&o.P1_24.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_24_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_24.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_24_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_24.Reg, volatile.LoadUint32(&o.P1_24.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_24_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_24.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_24_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_24.Reg, volatile.LoadUint32(&o.P1_24.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_24_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_24.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_24_OD(value uint32) {
	volatile.StoreUint32(&o.P1_24.Reg, volatile.LoadUint32(&o.P1_24.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_24_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_24.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_24_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_24.Reg, volatile.LoadUint32(&o.P1_24.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_24_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_24.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_25: I/O configuration register for pin P1[25]
func (o *IOCON_Type) SetP1_25_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_25.Reg, volatile.LoadUint32(&o.P1_25.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_25_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_25.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_25_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_25.Reg, volatile.LoadUint32(&o.P1_25.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_25_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_25.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_25_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_25.Reg, volatile.LoadUint32(&o.P1_25.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_25_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_25.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_25_INV(value uint32) {
	volatile.StoreUint32(&o.P1_25.Reg, volatile.LoadUint32(&o.P1_25.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_25_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_25.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_25_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_25.Reg, volatile.LoadUint32(&o.P1_25.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_25_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_25.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_25_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_25.Reg, volatile.LoadUint32(&o.P1_25.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_25_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_25.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_25_OD(value uint32) {
	volatile.StoreUint32(&o.P1_25.Reg, volatile.LoadUint32(&o.P1_25.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_25_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_25.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_25_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_25.Reg, volatile.LoadUint32(&o.P1_25.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_25_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_25.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_26: I/O configuration register for pin P1[26]
func (o *IOCON_Type) SetP1_26_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_26.Reg, volatile.LoadUint32(&o.P1_26.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_26_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_26.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_26_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_26.Reg, volatile.LoadUint32(&o.P1_26.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_26_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_26.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_26_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_26.Reg, volatile.LoadUint32(&o.P1_26.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_26_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_26.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_26_INV(value uint32) {
	volatile.StoreUint32(&o.P1_26.Reg, volatile.LoadUint32(&o.P1_26.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_26_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_26.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_26_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_26.Reg, volatile.LoadUint32(&o.P1_26.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_26_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_26.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_26_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_26.Reg, volatile.LoadUint32(&o.P1_26.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_26_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_26.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_26_OD(value uint32) {
	volatile.StoreUint32(&o.P1_26.Reg, volatile.LoadUint32(&o.P1_26.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_26_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_26.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_26_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_26.Reg, volatile.LoadUint32(&o.P1_26.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_26_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_26.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_27: I/O configuration register for pin P1[27]
func (o *IOCON_Type) SetP1_27_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_27.Reg, volatile.LoadUint32(&o.P1_27.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_27_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_27.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_27_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_27.Reg, volatile.LoadUint32(&o.P1_27.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_27_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_27.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_27_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_27.Reg, volatile.LoadUint32(&o.P1_27.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_27_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_27.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_27_INV(value uint32) {
	volatile.StoreUint32(&o.P1_27.Reg, volatile.LoadUint32(&o.P1_27.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_27_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_27.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_27_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_27.Reg, volatile.LoadUint32(&o.P1_27.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_27_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_27.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_27_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_27.Reg, volatile.LoadUint32(&o.P1_27.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_27_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_27.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_27_OD(value uint32) {
	volatile.StoreUint32(&o.P1_27.Reg, volatile.LoadUint32(&o.P1_27.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_27_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_27.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_27_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_27.Reg, volatile.LoadUint32(&o.P1_27.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_27_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_27.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_28: I/O configuration register for pin P1[28]
func (o *IOCON_Type) SetP1_28_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_28.Reg, volatile.LoadUint32(&o.P1_28.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_28_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_28.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_28_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_28.Reg, volatile.LoadUint32(&o.P1_28.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_28_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_28.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_28_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_28.Reg, volatile.LoadUint32(&o.P1_28.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_28_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_28.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_28_INV(value uint32) {
	volatile.StoreUint32(&o.P1_28.Reg, volatile.LoadUint32(&o.P1_28.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_28_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_28.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_28_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_28.Reg, volatile.LoadUint32(&o.P1_28.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_28_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_28.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_28_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_28.Reg, volatile.LoadUint32(&o.P1_28.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_28_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_28.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_28_OD(value uint32) {
	volatile.StoreUint32(&o.P1_28.Reg, volatile.LoadUint32(&o.P1_28.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_28_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_28.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_28_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_28.Reg, volatile.LoadUint32(&o.P1_28.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_28_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_28.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_29: I/O configuration register for pin P1[29]
func (o *IOCON_Type) SetP1_29_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_29.Reg, volatile.LoadUint32(&o.P1_29.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_29_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_29.Reg) & 0x7
}
func (o *IOCON_Type) SetP1_29_MODE(value uint32) {
	volatile.StoreUint32(&o.P1_29.Reg, volatile.LoadUint32(&o.P1_29.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP1_29_MODE() uint32 {
	return (volatile.LoadUint32(&o.P1_29.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP1_29_HYS(value uint32) {
	volatile.StoreUint32(&o.P1_29.Reg, volatile.LoadUint32(&o.P1_29.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP1_29_HYS() uint32 {
	return (volatile.LoadUint32(&o.P1_29.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP1_29_INV(value uint32) {
	volatile.StoreUint32(&o.P1_29.Reg, volatile.LoadUint32(&o.P1_29.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP1_29_INV() uint32 {
	return (volatile.LoadUint32(&o.P1_29.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP1_29_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_29.Reg, volatile.LoadUint32(&o.P1_29.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP1_29_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_29.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP1_29_SLEW(value uint32) {
	volatile.StoreUint32(&o.P1_29.Reg, volatile.LoadUint32(&o.P1_29.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP1_29_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P1_29.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP1_29_OD(value uint32) {
	volatile.StoreUint32(&o.P1_29.Reg, volatile.LoadUint32(&o.P1_29.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP1_29_OD() uint32 {
	return (volatile.LoadUint32(&o.P1_29.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP1_29_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P1_29.Reg, volatile.LoadUint32(&o.P1_29.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP1_29_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P1_29.Reg) & 0xfffff800) >> 11
}

// IOCON.P1_30: I/O configuration register for pin P1[30]
func (o *IOCON_Type) SetP1_30_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_30.Reg, volatile.LoadUint32(&o.P1_30.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_30_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_30.Reg) & 0x7
}

// IOCON.P1_31: I/O configuration register for pin P1[31]
func (o *IOCON_Type) SetP1_31_FUNC(value uint32) {
	volatile.StoreUint32(&o.P1_31.Reg, volatile.LoadUint32(&o.P1_31.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP1_31_FUNC() uint32 {
	return volatile.LoadUint32(&o.P1_31.Reg) & 0x7
}

// IOCON.P2_0: I/O configuration register for pin P2[0]
func (o *IOCON_Type) SetP2_0_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_0.Reg, volatile.LoadUint32(&o.P2_0.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_0_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_0.Reg) & 0x7
}
func (o *IOCON_Type) SetP2_0_MODE(value uint32) {
	volatile.StoreUint32(&o.P2_0.Reg, volatile.LoadUint32(&o.P2_0.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP2_0_MODE() uint32 {
	return (volatile.LoadUint32(&o.P2_0.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP2_0_HYS(value uint32) {
	volatile.StoreUint32(&o.P2_0.Reg, volatile.LoadUint32(&o.P2_0.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP2_0_HYS() uint32 {
	return (volatile.LoadUint32(&o.P2_0.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP2_0_INV(value uint32) {
	volatile.StoreUint32(&o.P2_0.Reg, volatile.LoadUint32(&o.P2_0.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP2_0_INV() uint32 {
	return (volatile.LoadUint32(&o.P2_0.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP2_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_0.Reg, volatile.LoadUint32(&o.P2_0.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP2_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_0.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP2_0_SLEW(value uint32) {
	volatile.StoreUint32(&o.P2_0.Reg, volatile.LoadUint32(&o.P2_0.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP2_0_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P2_0.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP2_0_OD(value uint32) {
	volatile.StoreUint32(&o.P2_0.Reg, volatile.LoadUint32(&o.P2_0.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP2_0_OD() uint32 {
	return (volatile.LoadUint32(&o.P2_0.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP2_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_0.Reg, volatile.LoadUint32(&o.P2_0.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP2_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_0.Reg) & 0xfffff800) >> 11
}

// IOCON.P2_1: I/O configuration register for pin P2[1]
func (o *IOCON_Type) SetP2_1_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_1.Reg, volatile.LoadUint32(&o.P2_1.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_1_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_1.Reg) & 0x7
}
func (o *IOCON_Type) SetP2_1_MODE(value uint32) {
	volatile.StoreUint32(&o.P2_1.Reg, volatile.LoadUint32(&o.P2_1.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP2_1_MODE() uint32 {
	return (volatile.LoadUint32(&o.P2_1.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP2_1_HYS(value uint32) {
	volatile.StoreUint32(&o.P2_1.Reg, volatile.LoadUint32(&o.P2_1.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP2_1_HYS() uint32 {
	return (volatile.LoadUint32(&o.P2_1.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP2_1_INV(value uint32) {
	volatile.StoreUint32(&o.P2_1.Reg, volatile.LoadUint32(&o.P2_1.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP2_1_INV() uint32 {
	return (volatile.LoadUint32(&o.P2_1.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP2_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_1.Reg, volatile.LoadUint32(&o.P2_1.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP2_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_1.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP2_1_SLEW(value uint32) {
	volatile.StoreUint32(&o.P2_1.Reg, volatile.LoadUint32(&o.P2_1.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP2_1_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P2_1.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP2_1_OD(value uint32) {
	volatile.StoreUint32(&o.P2_1.Reg, volatile.LoadUint32(&o.P2_1.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP2_1_OD() uint32 {
	return (volatile.LoadUint32(&o.P2_1.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP2_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_1.Reg, volatile.LoadUint32(&o.P2_1.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP2_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_1.Reg) & 0xfffff800) >> 11
}

// IOCON.P2_2: I/O configuration register for pin P2[2]
func (o *IOCON_Type) SetP2_2_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_2.Reg, volatile.LoadUint32(&o.P2_2.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_2_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_2.Reg) & 0x7
}
func (o *IOCON_Type) SetP2_2_MODE(value uint32) {
	volatile.StoreUint32(&o.P2_2.Reg, volatile.LoadUint32(&o.P2_2.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP2_2_MODE() uint32 {
	return (volatile.LoadUint32(&o.P2_2.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP2_2_HYS(value uint32) {
	volatile.StoreUint32(&o.P2_2.Reg, volatile.LoadUint32(&o.P2_2.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP2_2_HYS() uint32 {
	return (volatile.LoadUint32(&o.P2_2.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP2_2_INV(value uint32) {
	volatile.StoreUint32(&o.P2_2.Reg, volatile.LoadUint32(&o.P2_2.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP2_2_INV() uint32 {
	return (volatile.LoadUint32(&o.P2_2.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP2_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_2.Reg, volatile.LoadUint32(&o.P2_2.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP2_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_2.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP2_2_SLEW(value uint32) {
	volatile.StoreUint32(&o.P2_2.Reg, volatile.LoadUint32(&o.P2_2.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP2_2_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P2_2.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP2_2_OD(value uint32) {
	volatile.StoreUint32(&o.P2_2.Reg, volatile.LoadUint32(&o.P2_2.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP2_2_OD() uint32 {
	return (volatile.LoadUint32(&o.P2_2.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP2_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_2.Reg, volatile.LoadUint32(&o.P2_2.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP2_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_2.Reg) & 0xfffff800) >> 11
}

// IOCON.P2_3: I/O configuration register for pin P2[3]
func (o *IOCON_Type) SetP2_3_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_3.Reg, volatile.LoadUint32(&o.P2_3.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_3_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_3.Reg) & 0x7
}
func (o *IOCON_Type) SetP2_3_MODE(value uint32) {
	volatile.StoreUint32(&o.P2_3.Reg, volatile.LoadUint32(&o.P2_3.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP2_3_MODE() uint32 {
	return (volatile.LoadUint32(&o.P2_3.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP2_3_HYS(value uint32) {
	volatile.StoreUint32(&o.P2_3.Reg, volatile.LoadUint32(&o.P2_3.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP2_3_HYS() uint32 {
	return (volatile.LoadUint32(&o.P2_3.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP2_3_INV(value uint32) {
	volatile.StoreUint32(&o.P2_3.Reg, volatile.LoadUint32(&o.P2_3.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP2_3_INV() uint32 {
	return (volatile.LoadUint32(&o.P2_3.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP2_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_3.Reg, volatile.LoadUint32(&o.P2_3.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP2_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_3.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP2_3_SLEW(value uint32) {
	volatile.StoreUint32(&o.P2_3.Reg, volatile.LoadUint32(&o.P2_3.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP2_3_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P2_3.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP2_3_OD(value uint32) {
	volatile.StoreUint32(&o.P2_3.Reg, volatile.LoadUint32(&o.P2_3.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP2_3_OD() uint32 {
	return (volatile.LoadUint32(&o.P2_3.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP2_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_3.Reg, volatile.LoadUint32(&o.P2_3.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP2_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_3.Reg) & 0xfffff800) >> 11
}

// IOCON.P2_4: I/O configuration register for pin P2[4]
func (o *IOCON_Type) SetP2_4_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_4.Reg, volatile.LoadUint32(&o.P2_4.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_4_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_4.Reg) & 0x7
}
func (o *IOCON_Type) SetP2_4_MODE(value uint32) {
	volatile.StoreUint32(&o.P2_4.Reg, volatile.LoadUint32(&o.P2_4.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP2_4_MODE() uint32 {
	return (volatile.LoadUint32(&o.P2_4.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP2_4_HYS(value uint32) {
	volatile.StoreUint32(&o.P2_4.Reg, volatile.LoadUint32(&o.P2_4.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP2_4_HYS() uint32 {
	return (volatile.LoadUint32(&o.P2_4.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP2_4_INV(value uint32) {
	volatile.StoreUint32(&o.P2_4.Reg, volatile.LoadUint32(&o.P2_4.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP2_4_INV() uint32 {
	return (volatile.LoadUint32(&o.P2_4.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP2_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_4.Reg, volatile.LoadUint32(&o.P2_4.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP2_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_4.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP2_4_SLEW(value uint32) {
	volatile.StoreUint32(&o.P2_4.Reg, volatile.LoadUint32(&o.P2_4.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP2_4_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P2_4.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP2_4_OD(value uint32) {
	volatile.StoreUint32(&o.P2_4.Reg, volatile.LoadUint32(&o.P2_4.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP2_4_OD() uint32 {
	return (volatile.LoadUint32(&o.P2_4.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP2_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_4.Reg, volatile.LoadUint32(&o.P2_4.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP2_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_4.Reg) & 0xfffff800) >> 11
}

// IOCON.P2_5: I/O configuration register for pin P2[5]
func (o *IOCON_Type) SetP2_5_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_5.Reg, volatile.LoadUint32(&o.P2_5.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_5_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_5.Reg) & 0x7
}
func (o *IOCON_Type) SetP2_5_MODE(value uint32) {
	volatile.StoreUint32(&o.P2_5.Reg, volatile.LoadUint32(&o.P2_5.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP2_5_MODE() uint32 {
	return (volatile.LoadUint32(&o.P2_5.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP2_5_HYS(value uint32) {
	volatile.StoreUint32(&o.P2_5.Reg, volatile.LoadUint32(&o.P2_5.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP2_5_HYS() uint32 {
	return (volatile.LoadUint32(&o.P2_5.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP2_5_INV(value uint32) {
	volatile.StoreUint32(&o.P2_5.Reg, volatile.LoadUint32(&o.P2_5.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP2_5_INV() uint32 {
	return (volatile.LoadUint32(&o.P2_5.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP2_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_5.Reg, volatile.LoadUint32(&o.P2_5.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP2_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_5.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP2_5_SLEW(value uint32) {
	volatile.StoreUint32(&o.P2_5.Reg, volatile.LoadUint32(&o.P2_5.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP2_5_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P2_5.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP2_5_OD(value uint32) {
	volatile.StoreUint32(&o.P2_5.Reg, volatile.LoadUint32(&o.P2_5.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP2_5_OD() uint32 {
	return (volatile.LoadUint32(&o.P2_5.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP2_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_5.Reg, volatile.LoadUint32(&o.P2_5.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP2_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_5.Reg) & 0xfffff800) >> 11
}

// IOCON.P2_6: I/O configuration register for pin P2[6]
func (o *IOCON_Type) SetP2_6_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_6.Reg, volatile.LoadUint32(&o.P2_6.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_6_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_6.Reg) & 0x7
}
func (o *IOCON_Type) SetP2_6_MODE(value uint32) {
	volatile.StoreUint32(&o.P2_6.Reg, volatile.LoadUint32(&o.P2_6.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP2_6_MODE() uint32 {
	return (volatile.LoadUint32(&o.P2_6.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP2_6_HYS(value uint32) {
	volatile.StoreUint32(&o.P2_6.Reg, volatile.LoadUint32(&o.P2_6.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP2_6_HYS() uint32 {
	return (volatile.LoadUint32(&o.P2_6.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP2_6_INV(value uint32) {
	volatile.StoreUint32(&o.P2_6.Reg, volatile.LoadUint32(&o.P2_6.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP2_6_INV() uint32 {
	return (volatile.LoadUint32(&o.P2_6.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP2_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_6.Reg, volatile.LoadUint32(&o.P2_6.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP2_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_6.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP2_6_SLEW(value uint32) {
	volatile.StoreUint32(&o.P2_6.Reg, volatile.LoadUint32(&o.P2_6.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP2_6_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P2_6.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP2_6_OD(value uint32) {
	volatile.StoreUint32(&o.P2_6.Reg, volatile.LoadUint32(&o.P2_6.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP2_6_OD() uint32 {
	return (volatile.LoadUint32(&o.P2_6.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP2_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_6.Reg, volatile.LoadUint32(&o.P2_6.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP2_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_6.Reg) & 0xfffff800) >> 11
}

// IOCON.P2_7: I/O configuration register for pin P2[7]
func (o *IOCON_Type) SetP2_7_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_7.Reg, volatile.LoadUint32(&o.P2_7.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_7_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_7.Reg) & 0x7
}
func (o *IOCON_Type) SetP2_7_MODE(value uint32) {
	volatile.StoreUint32(&o.P2_7.Reg, volatile.LoadUint32(&o.P2_7.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP2_7_MODE() uint32 {
	return (volatile.LoadUint32(&o.P2_7.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP2_7_HYS(value uint32) {
	volatile.StoreUint32(&o.P2_7.Reg, volatile.LoadUint32(&o.P2_7.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP2_7_HYS() uint32 {
	return (volatile.LoadUint32(&o.P2_7.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP2_7_INV(value uint32) {
	volatile.StoreUint32(&o.P2_7.Reg, volatile.LoadUint32(&o.P2_7.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP2_7_INV() uint32 {
	return (volatile.LoadUint32(&o.P2_7.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP2_7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_7.Reg, volatile.LoadUint32(&o.P2_7.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP2_7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_7.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP2_7_SLEW(value uint32) {
	volatile.StoreUint32(&o.P2_7.Reg, volatile.LoadUint32(&o.P2_7.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP2_7_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P2_7.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP2_7_OD(value uint32) {
	volatile.StoreUint32(&o.P2_7.Reg, volatile.LoadUint32(&o.P2_7.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP2_7_OD() uint32 {
	return (volatile.LoadUint32(&o.P2_7.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP2_7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_7.Reg, volatile.LoadUint32(&o.P2_7.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP2_7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_7.Reg) & 0xfffff800) >> 11
}

// IOCON.P2_8: I/O configuration register for pin P2[8]
func (o *IOCON_Type) SetP2_8_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_8.Reg, volatile.LoadUint32(&o.P2_8.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_8_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_8.Reg) & 0x7
}
func (o *IOCON_Type) SetP2_8_MODE(value uint32) {
	volatile.StoreUint32(&o.P2_8.Reg, volatile.LoadUint32(&o.P2_8.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP2_8_MODE() uint32 {
	return (volatile.LoadUint32(&o.P2_8.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP2_8_HYS(value uint32) {
	volatile.StoreUint32(&o.P2_8.Reg, volatile.LoadUint32(&o.P2_8.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP2_8_HYS() uint32 {
	return (volatile.LoadUint32(&o.P2_8.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP2_8_INV(value uint32) {
	volatile.StoreUint32(&o.P2_8.Reg, volatile.LoadUint32(&o.P2_8.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP2_8_INV() uint32 {
	return (volatile.LoadUint32(&o.P2_8.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP2_8_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_8.Reg, volatile.LoadUint32(&o.P2_8.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP2_8_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_8.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP2_8_SLEW(value uint32) {
	volatile.StoreUint32(&o.P2_8.Reg, volatile.LoadUint32(&o.P2_8.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP2_8_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P2_8.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP2_8_OD(value uint32) {
	volatile.StoreUint32(&o.P2_8.Reg, volatile.LoadUint32(&o.P2_8.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP2_8_OD() uint32 {
	return (volatile.LoadUint32(&o.P2_8.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP2_8_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_8.Reg, volatile.LoadUint32(&o.P2_8.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP2_8_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_8.Reg) & 0xfffff800) >> 11
}

// IOCON.P2_9: I/O configuration register for pin P2[9]
func (o *IOCON_Type) SetP2_9_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_9.Reg, volatile.LoadUint32(&o.P2_9.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_9_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_9.Reg) & 0x7
}
func (o *IOCON_Type) SetP2_9_MODE(value uint32) {
	volatile.StoreUint32(&o.P2_9.Reg, volatile.LoadUint32(&o.P2_9.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP2_9_MODE() uint32 {
	return (volatile.LoadUint32(&o.P2_9.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP2_9_HYS(value uint32) {
	volatile.StoreUint32(&o.P2_9.Reg, volatile.LoadUint32(&o.P2_9.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP2_9_HYS() uint32 {
	return (volatile.LoadUint32(&o.P2_9.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP2_9_INV(value uint32) {
	volatile.StoreUint32(&o.P2_9.Reg, volatile.LoadUint32(&o.P2_9.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP2_9_INV() uint32 {
	return (volatile.LoadUint32(&o.P2_9.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP2_9_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_9.Reg, volatile.LoadUint32(&o.P2_9.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP2_9_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_9.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP2_9_SLEW(value uint32) {
	volatile.StoreUint32(&o.P2_9.Reg, volatile.LoadUint32(&o.P2_9.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP2_9_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P2_9.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP2_9_OD(value uint32) {
	volatile.StoreUint32(&o.P2_9.Reg, volatile.LoadUint32(&o.P2_9.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP2_9_OD() uint32 {
	return (volatile.LoadUint32(&o.P2_9.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP2_9_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_9.Reg, volatile.LoadUint32(&o.P2_9.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP2_9_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_9.Reg) & 0xfffff800) >> 11
}

// IOCON.P2_10: I/O configuration register for pin P2[10]
func (o *IOCON_Type) SetP2_10_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_10.Reg, volatile.LoadUint32(&o.P2_10.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_10_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_10.Reg) & 0x7
}

// IOCON.P2_11: I/O configuration register for pin P2[11]
func (o *IOCON_Type) SetP2_11_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_11.Reg, volatile.LoadUint32(&o.P2_11.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_11_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_11.Reg) & 0x7
}

// IOCON.P2_12: I/O configuration register for pin P2[12]
func (o *IOCON_Type) SetP2_12_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_12.Reg, volatile.LoadUint32(&o.P2_12.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_12_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_12.Reg) & 0x7
}

// IOCON.P2_13: I/O configuration register for pin P2[13]
func (o *IOCON_Type) SetP2_13_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_13.Reg, volatile.LoadUint32(&o.P2_13.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_13_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_13.Reg) & 0x7
}

// IOCON.P2_14: I/O configuration register for pin P2[14]
func (o *IOCON_Type) SetP2_14_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_14.Reg, volatile.LoadUint32(&o.P2_14.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_14_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_14.Reg) & 0x7
}
func (o *IOCON_Type) SetP2_14_MODE(value uint32) {
	volatile.StoreUint32(&o.P2_14.Reg, volatile.LoadUint32(&o.P2_14.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP2_14_MODE() uint32 {
	return (volatile.LoadUint32(&o.P2_14.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP2_14_HYS(value uint32) {
	volatile.StoreUint32(&o.P2_14.Reg, volatile.LoadUint32(&o.P2_14.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP2_14_HYS() uint32 {
	return (volatile.LoadUint32(&o.P2_14.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP2_14_INV(value uint32) {
	volatile.StoreUint32(&o.P2_14.Reg, volatile.LoadUint32(&o.P2_14.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP2_14_INV() uint32 {
	return (volatile.LoadUint32(&o.P2_14.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP2_14_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_14.Reg, volatile.LoadUint32(&o.P2_14.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP2_14_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_14.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP2_14_SLEW(value uint32) {
	volatile.StoreUint32(&o.P2_14.Reg, volatile.LoadUint32(&o.P2_14.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP2_14_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P2_14.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP2_14_OD(value uint32) {
	volatile.StoreUint32(&o.P2_14.Reg, volatile.LoadUint32(&o.P2_14.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP2_14_OD() uint32 {
	return (volatile.LoadUint32(&o.P2_14.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP2_14_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_14.Reg, volatile.LoadUint32(&o.P2_14.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP2_14_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_14.Reg) & 0xfffff800) >> 11
}

// IOCON.P2_15: I/O configuration register for pin P2[15]
func (o *IOCON_Type) SetP2_15_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_15.Reg, volatile.LoadUint32(&o.P2_15.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_15_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_15.Reg) & 0x7
}
func (o *IOCON_Type) SetP2_15_MODE(value uint32) {
	volatile.StoreUint32(&o.P2_15.Reg, volatile.LoadUint32(&o.P2_15.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP2_15_MODE() uint32 {
	return (volatile.LoadUint32(&o.P2_15.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP2_15_HYS(value uint32) {
	volatile.StoreUint32(&o.P2_15.Reg, volatile.LoadUint32(&o.P2_15.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP2_15_HYS() uint32 {
	return (volatile.LoadUint32(&o.P2_15.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP2_15_INV(value uint32) {
	volatile.StoreUint32(&o.P2_15.Reg, volatile.LoadUint32(&o.P2_15.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP2_15_INV() uint32 {
	return (volatile.LoadUint32(&o.P2_15.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP2_15_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_15.Reg, volatile.LoadUint32(&o.P2_15.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP2_15_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_15.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP2_15_SLEW(value uint32) {
	volatile.StoreUint32(&o.P2_15.Reg, volatile.LoadUint32(&o.P2_15.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP2_15_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P2_15.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP2_15_OD(value uint32) {
	volatile.StoreUint32(&o.P2_15.Reg, volatile.LoadUint32(&o.P2_15.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP2_15_OD() uint32 {
	return (volatile.LoadUint32(&o.P2_15.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP2_15_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_15.Reg, volatile.LoadUint32(&o.P2_15.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP2_15_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_15.Reg) & 0xfffff800) >> 11
}

// IOCON.P2_16: I/O configuration register for pin P2[16]
func (o *IOCON_Type) SetP2_16_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_16.Reg, volatile.LoadUint32(&o.P2_16.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_16_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_16.Reg) & 0x7
}
func (o *IOCON_Type) SetP2_16_MODE(value uint32) {
	volatile.StoreUint32(&o.P2_16.Reg, volatile.LoadUint32(&o.P2_16.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP2_16_MODE() uint32 {
	return (volatile.LoadUint32(&o.P2_16.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP2_16_HYS(value uint32) {
	volatile.StoreUint32(&o.P2_16.Reg, volatile.LoadUint32(&o.P2_16.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP2_16_HYS() uint32 {
	return (volatile.LoadUint32(&o.P2_16.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP2_16_INV(value uint32) {
	volatile.StoreUint32(&o.P2_16.Reg, volatile.LoadUint32(&o.P2_16.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP2_16_INV() uint32 {
	return (volatile.LoadUint32(&o.P2_16.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP2_16_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_16.Reg, volatile.LoadUint32(&o.P2_16.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP2_16_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_16.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP2_16_SLEW(value uint32) {
	volatile.StoreUint32(&o.P2_16.Reg, volatile.LoadUint32(&o.P2_16.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP2_16_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P2_16.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP2_16_OD(value uint32) {
	volatile.StoreUint32(&o.P2_16.Reg, volatile.LoadUint32(&o.P2_16.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP2_16_OD() uint32 {
	return (volatile.LoadUint32(&o.P2_16.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP2_16_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_16.Reg, volatile.LoadUint32(&o.P2_16.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP2_16_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_16.Reg) & 0xfffff800) >> 11
}

// IOCON.P2_17: I/O configuration register for pin P2[17]
func (o *IOCON_Type) SetP2_17_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_17.Reg, volatile.LoadUint32(&o.P2_17.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_17_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_17.Reg) & 0x7
}
func (o *IOCON_Type) SetP2_17_MODE(value uint32) {
	volatile.StoreUint32(&o.P2_17.Reg, volatile.LoadUint32(&o.P2_17.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP2_17_MODE() uint32 {
	return (volatile.LoadUint32(&o.P2_17.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP2_17_HYS(value uint32) {
	volatile.StoreUint32(&o.P2_17.Reg, volatile.LoadUint32(&o.P2_17.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP2_17_HYS() uint32 {
	return (volatile.LoadUint32(&o.P2_17.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP2_17_INV(value uint32) {
	volatile.StoreUint32(&o.P2_17.Reg, volatile.LoadUint32(&o.P2_17.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP2_17_INV() uint32 {
	return (volatile.LoadUint32(&o.P2_17.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP2_17_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_17.Reg, volatile.LoadUint32(&o.P2_17.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP2_17_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_17.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP2_17_SLEW(value uint32) {
	volatile.StoreUint32(&o.P2_17.Reg, volatile.LoadUint32(&o.P2_17.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP2_17_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P2_17.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP2_17_OD(value uint32) {
	volatile.StoreUint32(&o.P2_17.Reg, volatile.LoadUint32(&o.P2_17.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP2_17_OD() uint32 {
	return (volatile.LoadUint32(&o.P2_17.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP2_17_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_17.Reg, volatile.LoadUint32(&o.P2_17.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP2_17_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_17.Reg) & 0xfffff800) >> 11
}

// IOCON.P2_18: I/O configuration register for pin P2[18]
func (o *IOCON_Type) SetP2_18_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_18.Reg, volatile.LoadUint32(&o.P2_18.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_18_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_18.Reg) & 0x7
}
func (o *IOCON_Type) SetP2_18_MODE(value uint32) {
	volatile.StoreUint32(&o.P2_18.Reg, volatile.LoadUint32(&o.P2_18.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP2_18_MODE() uint32 {
	return (volatile.LoadUint32(&o.P2_18.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP2_18_HYS(value uint32) {
	volatile.StoreUint32(&o.P2_18.Reg, volatile.LoadUint32(&o.P2_18.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP2_18_HYS() uint32 {
	return (volatile.LoadUint32(&o.P2_18.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP2_18_INV(value uint32) {
	volatile.StoreUint32(&o.P2_18.Reg, volatile.LoadUint32(&o.P2_18.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP2_18_INV() uint32 {
	return (volatile.LoadUint32(&o.P2_18.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP2_18_ADMODE(value uint32) {
	volatile.StoreUint32(&o.P2_18.Reg, volatile.LoadUint32(&o.P2_18.Reg)&^(0x80)|value<<7)
}
func (o *IOCON_Type) GetP2_18_ADMODE() uint32 {
	return (volatile.LoadUint32(&o.P2_18.Reg) & 0x80) >> 7
}
func (o *IOCON_Type) SetP2_18_FILTR(value uint32) {
	volatile.StoreUint32(&o.P2_18.Reg, volatile.LoadUint32(&o.P2_18.Reg)&^(0x100)|value<<8)
}
func (o *IOCON_Type) GetP2_18_FILTR() uint32 {
	return (volatile.LoadUint32(&o.P2_18.Reg) & 0x100) >> 8
}
func (o *IOCON_Type) SetP2_18_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_18.Reg, volatile.LoadUint32(&o.P2_18.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP2_18_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_18.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP2_18_OD(value uint32) {
	volatile.StoreUint32(&o.P2_18.Reg, volatile.LoadUint32(&o.P2_18.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP2_18_OD() uint32 {
	return (volatile.LoadUint32(&o.P2_18.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP2_18_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_18.Reg, volatile.LoadUint32(&o.P2_18.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP2_18_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_18.Reg) & 0xfffff800) >> 11
}

// IOCON.P2_19: I/O configuration register for pin P2[19]
func (o *IOCON_Type) SetP2_19_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_19.Reg, volatile.LoadUint32(&o.P2_19.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_19_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_19.Reg) & 0x7
}
func (o *IOCON_Type) SetP2_19_MODE(value uint32) {
	volatile.StoreUint32(&o.P2_19.Reg, volatile.LoadUint32(&o.P2_19.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP2_19_MODE() uint32 {
	return (volatile.LoadUint32(&o.P2_19.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP2_19_HYS(value uint32) {
	volatile.StoreUint32(&o.P2_19.Reg, volatile.LoadUint32(&o.P2_19.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP2_19_HYS() uint32 {
	return (volatile.LoadUint32(&o.P2_19.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP2_19_INV(value uint32) {
	volatile.StoreUint32(&o.P2_19.Reg, volatile.LoadUint32(&o.P2_19.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP2_19_INV() uint32 {
	return (volatile.LoadUint32(&o.P2_19.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP2_19_ADMODE(value uint32) {
	volatile.StoreUint32(&o.P2_19.Reg, volatile.LoadUint32(&o.P2_19.Reg)&^(0x80)|value<<7)
}
func (o *IOCON_Type) GetP2_19_ADMODE() uint32 {
	return (volatile.LoadUint32(&o.P2_19.Reg) & 0x80) >> 7
}
func (o *IOCON_Type) SetP2_19_FILTR(value uint32) {
	volatile.StoreUint32(&o.P2_19.Reg, volatile.LoadUint32(&o.P2_19.Reg)&^(0x100)|value<<8)
}
func (o *IOCON_Type) GetP2_19_FILTR() uint32 {
	return (volatile.LoadUint32(&o.P2_19.Reg) & 0x100) >> 8
}
func (o *IOCON_Type) SetP2_19_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_19.Reg, volatile.LoadUint32(&o.P2_19.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP2_19_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_19.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP2_19_OD(value uint32) {
	volatile.StoreUint32(&o.P2_19.Reg, volatile.LoadUint32(&o.P2_19.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP2_19_OD() uint32 {
	return (volatile.LoadUint32(&o.P2_19.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP2_19_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_19.Reg, volatile.LoadUint32(&o.P2_19.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP2_19_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_19.Reg) & 0xfffff800) >> 11
}

// IOCON.P2_20: I/O configuration register for pin P2[20]
func (o *IOCON_Type) SetP2_20_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_20.Reg, volatile.LoadUint32(&o.P2_20.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_20_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_20.Reg) & 0x7
}
func (o *IOCON_Type) SetP2_20_MODE(value uint32) {
	volatile.StoreUint32(&o.P2_20.Reg, volatile.LoadUint32(&o.P2_20.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP2_20_MODE() uint32 {
	return (volatile.LoadUint32(&o.P2_20.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP2_20_HYS(value uint32) {
	volatile.StoreUint32(&o.P2_20.Reg, volatile.LoadUint32(&o.P2_20.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP2_20_HYS() uint32 {
	return (volatile.LoadUint32(&o.P2_20.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP2_20_INV(value uint32) {
	volatile.StoreUint32(&o.P2_20.Reg, volatile.LoadUint32(&o.P2_20.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP2_20_INV() uint32 {
	return (volatile.LoadUint32(&o.P2_20.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP2_20_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_20.Reg, volatile.LoadUint32(&o.P2_20.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP2_20_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_20.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP2_20_SLEW(value uint32) {
	volatile.StoreUint32(&o.P2_20.Reg, volatile.LoadUint32(&o.P2_20.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP2_20_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P2_20.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP2_20_OD(value uint32) {
	volatile.StoreUint32(&o.P2_20.Reg, volatile.LoadUint32(&o.P2_20.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP2_20_OD() uint32 {
	return (volatile.LoadUint32(&o.P2_20.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP2_20_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_20.Reg, volatile.LoadUint32(&o.P2_20.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP2_20_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_20.Reg) & 0xfffff800) >> 11
}

// IOCON.P2_21: I/O configuration register for pin P2[21]
func (o *IOCON_Type) SetP2_21_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_21.Reg, volatile.LoadUint32(&o.P2_21.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_21_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_21.Reg) & 0x7
}
func (o *IOCON_Type) SetP2_21_MODE(value uint32) {
	volatile.StoreUint32(&o.P2_21.Reg, volatile.LoadUint32(&o.P2_21.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP2_21_MODE() uint32 {
	return (volatile.LoadUint32(&o.P2_21.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP2_21_HYS(value uint32) {
	volatile.StoreUint32(&o.P2_21.Reg, volatile.LoadUint32(&o.P2_21.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP2_21_HYS() uint32 {
	return (volatile.LoadUint32(&o.P2_21.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP2_21_INV(value uint32) {
	volatile.StoreUint32(&o.P2_21.Reg, volatile.LoadUint32(&o.P2_21.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP2_21_INV() uint32 {
	return (volatile.LoadUint32(&o.P2_21.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP2_21_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_21.Reg, volatile.LoadUint32(&o.P2_21.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP2_21_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_21.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP2_21_SLEW(value uint32) {
	volatile.StoreUint32(&o.P2_21.Reg, volatile.LoadUint32(&o.P2_21.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP2_21_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P2_21.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP2_21_OD(value uint32) {
	volatile.StoreUint32(&o.P2_21.Reg, volatile.LoadUint32(&o.P2_21.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP2_21_OD() uint32 {
	return (volatile.LoadUint32(&o.P2_21.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP2_21_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_21.Reg, volatile.LoadUint32(&o.P2_21.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP2_21_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_21.Reg) & 0xfffff800) >> 11
}

// IOCON.P2_22: I/O configuration register for pin P2[22]
func (o *IOCON_Type) SetP2_22_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_22.Reg, volatile.LoadUint32(&o.P2_22.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_22_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_22.Reg) & 0x7
}
func (o *IOCON_Type) SetP2_22_MODE(value uint32) {
	volatile.StoreUint32(&o.P2_22.Reg, volatile.LoadUint32(&o.P2_22.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP2_22_MODE() uint32 {
	return (volatile.LoadUint32(&o.P2_22.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP2_22_HYS(value uint32) {
	volatile.StoreUint32(&o.P2_22.Reg, volatile.LoadUint32(&o.P2_22.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP2_22_HYS() uint32 {
	return (volatile.LoadUint32(&o.P2_22.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP2_22_INV(value uint32) {
	volatile.StoreUint32(&o.P2_22.Reg, volatile.LoadUint32(&o.P2_22.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP2_22_INV() uint32 {
	return (volatile.LoadUint32(&o.P2_22.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP2_22_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_22.Reg, volatile.LoadUint32(&o.P2_22.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP2_22_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_22.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP2_22_SLEW(value uint32) {
	volatile.StoreUint32(&o.P2_22.Reg, volatile.LoadUint32(&o.P2_22.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP2_22_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P2_22.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP2_22_OD(value uint32) {
	volatile.StoreUint32(&o.P2_22.Reg, volatile.LoadUint32(&o.P2_22.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP2_22_OD() uint32 {
	return (volatile.LoadUint32(&o.P2_22.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP2_22_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_22.Reg, volatile.LoadUint32(&o.P2_22.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP2_22_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_22.Reg) & 0xfffff800) >> 11
}

// IOCON.P2_23: I/O configuration register for pin P2[23]
func (o *IOCON_Type) SetP2_23_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_23.Reg, volatile.LoadUint32(&o.P2_23.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_23_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_23.Reg) & 0x7
}
func (o *IOCON_Type) SetP2_23_MODE(value uint32) {
	volatile.StoreUint32(&o.P2_23.Reg, volatile.LoadUint32(&o.P2_23.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP2_23_MODE() uint32 {
	return (volatile.LoadUint32(&o.P2_23.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP2_23_HYS(value uint32) {
	volatile.StoreUint32(&o.P2_23.Reg, volatile.LoadUint32(&o.P2_23.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP2_23_HYS() uint32 {
	return (volatile.LoadUint32(&o.P2_23.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP2_23_INV(value uint32) {
	volatile.StoreUint32(&o.P2_23.Reg, volatile.LoadUint32(&o.P2_23.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP2_23_INV() uint32 {
	return (volatile.LoadUint32(&o.P2_23.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP2_23_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_23.Reg, volatile.LoadUint32(&o.P2_23.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP2_23_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_23.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP2_23_SLEW(value uint32) {
	volatile.StoreUint32(&o.P2_23.Reg, volatile.LoadUint32(&o.P2_23.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP2_23_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P2_23.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP2_23_OD(value uint32) {
	volatile.StoreUint32(&o.P2_23.Reg, volatile.LoadUint32(&o.P2_23.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP2_23_OD() uint32 {
	return (volatile.LoadUint32(&o.P2_23.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP2_23_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_23.Reg, volatile.LoadUint32(&o.P2_23.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP2_23_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_23.Reg) & 0xfffff800) >> 11
}

// IOCON.P2_24: I/O configuration register for pin P2[24]
func (o *IOCON_Type) SetP2_24_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_24.Reg, volatile.LoadUint32(&o.P2_24.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_24_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_24.Reg) & 0x7
}
func (o *IOCON_Type) SetP2_24_MODE(value uint32) {
	volatile.StoreUint32(&o.P2_24.Reg, volatile.LoadUint32(&o.P2_24.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP2_24_MODE() uint32 {
	return (volatile.LoadUint32(&o.P2_24.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP2_24_HYS(value uint32) {
	volatile.StoreUint32(&o.P2_24.Reg, volatile.LoadUint32(&o.P2_24.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP2_24_HYS() uint32 {
	return (volatile.LoadUint32(&o.P2_24.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP2_24_INV(value uint32) {
	volatile.StoreUint32(&o.P2_24.Reg, volatile.LoadUint32(&o.P2_24.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP2_24_INV() uint32 {
	return (volatile.LoadUint32(&o.P2_24.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP2_24_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_24.Reg, volatile.LoadUint32(&o.P2_24.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP2_24_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_24.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP2_24_SLEW(value uint32) {
	volatile.StoreUint32(&o.P2_24.Reg, volatile.LoadUint32(&o.P2_24.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP2_24_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P2_24.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP2_24_OD(value uint32) {
	volatile.StoreUint32(&o.P2_24.Reg, volatile.LoadUint32(&o.P2_24.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP2_24_OD() uint32 {
	return (volatile.LoadUint32(&o.P2_24.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP2_24_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_24.Reg, volatile.LoadUint32(&o.P2_24.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP2_24_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_24.Reg) & 0xfffff800) >> 11
}

// IOCON.P2_25: I/O configuration register for pin P2[25]
func (o *IOCON_Type) SetP2_25_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_25.Reg, volatile.LoadUint32(&o.P2_25.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_25_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_25.Reg) & 0x7
}
func (o *IOCON_Type) SetP2_25_MODE(value uint32) {
	volatile.StoreUint32(&o.P2_25.Reg, volatile.LoadUint32(&o.P2_25.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP2_25_MODE() uint32 {
	return (volatile.LoadUint32(&o.P2_25.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP2_25_HYS(value uint32) {
	volatile.StoreUint32(&o.P2_25.Reg, volatile.LoadUint32(&o.P2_25.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP2_25_HYS() uint32 {
	return (volatile.LoadUint32(&o.P2_25.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP2_25_INV(value uint32) {
	volatile.StoreUint32(&o.P2_25.Reg, volatile.LoadUint32(&o.P2_25.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP2_25_INV() uint32 {
	return (volatile.LoadUint32(&o.P2_25.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP2_25_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_25.Reg, volatile.LoadUint32(&o.P2_25.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP2_25_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_25.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP2_25_SLEW(value uint32) {
	volatile.StoreUint32(&o.P2_25.Reg, volatile.LoadUint32(&o.P2_25.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP2_25_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P2_25.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP2_25_OD(value uint32) {
	volatile.StoreUint32(&o.P2_25.Reg, volatile.LoadUint32(&o.P2_25.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP2_25_OD() uint32 {
	return (volatile.LoadUint32(&o.P2_25.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP2_25_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_25.Reg, volatile.LoadUint32(&o.P2_25.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP2_25_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_25.Reg) & 0xfffff800) >> 11
}

// IOCON.P2_26: I/O configuration register for pin P2[26]
func (o *IOCON_Type) SetP2_26_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_26.Reg, volatile.LoadUint32(&o.P2_26.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_26_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_26.Reg) & 0x7
}
func (o *IOCON_Type) SetP2_26_MODE(value uint32) {
	volatile.StoreUint32(&o.P2_26.Reg, volatile.LoadUint32(&o.P2_26.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP2_26_MODE() uint32 {
	return (volatile.LoadUint32(&o.P2_26.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP2_26_HYS(value uint32) {
	volatile.StoreUint32(&o.P2_26.Reg, volatile.LoadUint32(&o.P2_26.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP2_26_HYS() uint32 {
	return (volatile.LoadUint32(&o.P2_26.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP2_26_INV(value uint32) {
	volatile.StoreUint32(&o.P2_26.Reg, volatile.LoadUint32(&o.P2_26.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP2_26_INV() uint32 {
	return (volatile.LoadUint32(&o.P2_26.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP2_26_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_26.Reg, volatile.LoadUint32(&o.P2_26.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP2_26_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_26.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP2_26_SLEW(value uint32) {
	volatile.StoreUint32(&o.P2_26.Reg, volatile.LoadUint32(&o.P2_26.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP2_26_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P2_26.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP2_26_OD(value uint32) {
	volatile.StoreUint32(&o.P2_26.Reg, volatile.LoadUint32(&o.P2_26.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP2_26_OD() uint32 {
	return (volatile.LoadUint32(&o.P2_26.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP2_26_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_26.Reg, volatile.LoadUint32(&o.P2_26.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP2_26_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_26.Reg) & 0xfffff800) >> 11
}

// IOCON.P2_27: I/O configuration register for pin P2[27]
func (o *IOCON_Type) SetP2_27_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_27.Reg, volatile.LoadUint32(&o.P2_27.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_27_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_27.Reg) & 0x7
}
func (o *IOCON_Type) SetP2_27_MODE(value uint32) {
	volatile.StoreUint32(&o.P2_27.Reg, volatile.LoadUint32(&o.P2_27.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP2_27_MODE() uint32 {
	return (volatile.LoadUint32(&o.P2_27.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP2_27_HYS(value uint32) {
	volatile.StoreUint32(&o.P2_27.Reg, volatile.LoadUint32(&o.P2_27.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP2_27_HYS() uint32 {
	return (volatile.LoadUint32(&o.P2_27.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP2_27_INV(value uint32) {
	volatile.StoreUint32(&o.P2_27.Reg, volatile.LoadUint32(&o.P2_27.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP2_27_INV() uint32 {
	return (volatile.LoadUint32(&o.P2_27.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP2_27_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_27.Reg, volatile.LoadUint32(&o.P2_27.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP2_27_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_27.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP2_27_SLEW(value uint32) {
	volatile.StoreUint32(&o.P2_27.Reg, volatile.LoadUint32(&o.P2_27.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP2_27_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P2_27.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP2_27_OD(value uint32) {
	volatile.StoreUint32(&o.P2_27.Reg, volatile.LoadUint32(&o.P2_27.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP2_27_OD() uint32 {
	return (volatile.LoadUint32(&o.P2_27.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP2_27_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_27.Reg, volatile.LoadUint32(&o.P2_27.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP2_27_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_27.Reg) & 0xfffff800) >> 11
}

// IOCON.P2_28: I/O configuration register for pin P2[28]
func (o *IOCON_Type) SetP2_28_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_28.Reg, volatile.LoadUint32(&o.P2_28.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_28_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_28.Reg) & 0x7
}
func (o *IOCON_Type) SetP2_28_MODE(value uint32) {
	volatile.StoreUint32(&o.P2_28.Reg, volatile.LoadUint32(&o.P2_28.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP2_28_MODE() uint32 {
	return (volatile.LoadUint32(&o.P2_28.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP2_28_HYS(value uint32) {
	volatile.StoreUint32(&o.P2_28.Reg, volatile.LoadUint32(&o.P2_28.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP2_28_HYS() uint32 {
	return (volatile.LoadUint32(&o.P2_28.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP2_28_INV(value uint32) {
	volatile.StoreUint32(&o.P2_28.Reg, volatile.LoadUint32(&o.P2_28.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP2_28_INV() uint32 {
	return (volatile.LoadUint32(&o.P2_28.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP2_28_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_28.Reg, volatile.LoadUint32(&o.P2_28.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP2_28_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_28.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP2_28_SLEW(value uint32) {
	volatile.StoreUint32(&o.P2_28.Reg, volatile.LoadUint32(&o.P2_28.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP2_28_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P2_28.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP2_28_OD(value uint32) {
	volatile.StoreUint32(&o.P2_28.Reg, volatile.LoadUint32(&o.P2_28.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP2_28_OD() uint32 {
	return (volatile.LoadUint32(&o.P2_28.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP2_28_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_28.Reg, volatile.LoadUint32(&o.P2_28.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP2_28_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_28.Reg) & 0xfffff800) >> 11
}

// IOCON.P2_29: I/O configuration register for pin P2[29]
func (o *IOCON_Type) SetP2_29_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_29.Reg, volatile.LoadUint32(&o.P2_29.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_29_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_29.Reg) & 0x7
}
func (o *IOCON_Type) SetP2_29_MODE(value uint32) {
	volatile.StoreUint32(&o.P2_29.Reg, volatile.LoadUint32(&o.P2_29.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP2_29_MODE() uint32 {
	return (volatile.LoadUint32(&o.P2_29.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP2_29_HYS(value uint32) {
	volatile.StoreUint32(&o.P2_29.Reg, volatile.LoadUint32(&o.P2_29.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP2_29_HYS() uint32 {
	return (volatile.LoadUint32(&o.P2_29.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP2_29_INV(value uint32) {
	volatile.StoreUint32(&o.P2_29.Reg, volatile.LoadUint32(&o.P2_29.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP2_29_INV() uint32 {
	return (volatile.LoadUint32(&o.P2_29.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP2_29_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_29.Reg, volatile.LoadUint32(&o.P2_29.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP2_29_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_29.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP2_29_SLEW(value uint32) {
	volatile.StoreUint32(&o.P2_29.Reg, volatile.LoadUint32(&o.P2_29.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP2_29_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P2_29.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP2_29_OD(value uint32) {
	volatile.StoreUint32(&o.P2_29.Reg, volatile.LoadUint32(&o.P2_29.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP2_29_OD() uint32 {
	return (volatile.LoadUint32(&o.P2_29.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP2_29_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_29.Reg, volatile.LoadUint32(&o.P2_29.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP2_29_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_29.Reg) & 0xfffff800) >> 11
}

// IOCON.P2_30: I/O configuration register for pin P2[30]
func (o *IOCON_Type) SetP2_30_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_30.Reg, volatile.LoadUint32(&o.P2_30.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_30_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_30.Reg) & 0x7
}
func (o *IOCON_Type) SetP2_30_MODE(value uint32) {
	volatile.StoreUint32(&o.P2_30.Reg, volatile.LoadUint32(&o.P2_30.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP2_30_MODE() uint32 {
	return (volatile.LoadUint32(&o.P2_30.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP2_30_HYS(value uint32) {
	volatile.StoreUint32(&o.P2_30.Reg, volatile.LoadUint32(&o.P2_30.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP2_30_HYS() uint32 {
	return (volatile.LoadUint32(&o.P2_30.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP2_30_INV(value uint32) {
	volatile.StoreUint32(&o.P2_30.Reg, volatile.LoadUint32(&o.P2_30.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP2_30_INV() uint32 {
	return (volatile.LoadUint32(&o.P2_30.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP2_30_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_30.Reg, volatile.LoadUint32(&o.P2_30.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP2_30_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_30.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP2_30_SLEW(value uint32) {
	volatile.StoreUint32(&o.P2_30.Reg, volatile.LoadUint32(&o.P2_30.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP2_30_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P2_30.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP2_30_OD(value uint32) {
	volatile.StoreUint32(&o.P2_30.Reg, volatile.LoadUint32(&o.P2_30.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP2_30_OD() uint32 {
	return (volatile.LoadUint32(&o.P2_30.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP2_30_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_30.Reg, volatile.LoadUint32(&o.P2_30.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP2_30_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_30.Reg) & 0xfffff800) >> 11
}

// IOCON.P2_31: I/O configuration register for pin P2[31]
func (o *IOCON_Type) SetP2_31_FUNC(value uint32) {
	volatile.StoreUint32(&o.P2_31.Reg, volatile.LoadUint32(&o.P2_31.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP2_31_FUNC() uint32 {
	return volatile.LoadUint32(&o.P2_31.Reg) & 0x7
}
func (o *IOCON_Type) SetP2_31_MODE(value uint32) {
	volatile.StoreUint32(&o.P2_31.Reg, volatile.LoadUint32(&o.P2_31.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP2_31_MODE() uint32 {
	return (volatile.LoadUint32(&o.P2_31.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP2_31_HYS(value uint32) {
	volatile.StoreUint32(&o.P2_31.Reg, volatile.LoadUint32(&o.P2_31.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP2_31_HYS() uint32 {
	return (volatile.LoadUint32(&o.P2_31.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP2_31_INV(value uint32) {
	volatile.StoreUint32(&o.P2_31.Reg, volatile.LoadUint32(&o.P2_31.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP2_31_INV() uint32 {
	return (volatile.LoadUint32(&o.P2_31.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP2_31_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_31.Reg, volatile.LoadUint32(&o.P2_31.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP2_31_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_31.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP2_31_SLEW(value uint32) {
	volatile.StoreUint32(&o.P2_31.Reg, volatile.LoadUint32(&o.P2_31.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP2_31_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P2_31.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP2_31_OD(value uint32) {
	volatile.StoreUint32(&o.P2_31.Reg, volatile.LoadUint32(&o.P2_31.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP2_31_OD() uint32 {
	return (volatile.LoadUint32(&o.P2_31.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP2_31_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P2_31.Reg, volatile.LoadUint32(&o.P2_31.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP2_31_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P2_31.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_0: I/O configuration register for pin P3[0]
func (o *IOCON_Type) SetP3_0_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_0.Reg, volatile.LoadUint32(&o.P3_0.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_0_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_0.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_0_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_0.Reg, volatile.LoadUint32(&o.P3_0.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_0_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_0.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_0_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_0.Reg, volatile.LoadUint32(&o.P3_0.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_0_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_0.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_0_INV(value uint32) {
	volatile.StoreUint32(&o.P3_0.Reg, volatile.LoadUint32(&o.P3_0.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_0_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_0.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_0.Reg, volatile.LoadUint32(&o.P3_0.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_0.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_0_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_0.Reg, volatile.LoadUint32(&o.P3_0.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_0_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_0.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_0_OD(value uint32) {
	volatile.StoreUint32(&o.P3_0.Reg, volatile.LoadUint32(&o.P3_0.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_0_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_0.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_0.Reg, volatile.LoadUint32(&o.P3_0.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_0.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_1: I/O configuration register for pin P3[1]
func (o *IOCON_Type) SetP3_1_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_1.Reg, volatile.LoadUint32(&o.P3_1.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_1_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_1.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_1_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_1.Reg, volatile.LoadUint32(&o.P3_1.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_1_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_1.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_1_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_1.Reg, volatile.LoadUint32(&o.P3_1.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_1_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_1.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_1_INV(value uint32) {
	volatile.StoreUint32(&o.P3_1.Reg, volatile.LoadUint32(&o.P3_1.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_1_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_1.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_1.Reg, volatile.LoadUint32(&o.P3_1.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_1.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_1_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_1.Reg, volatile.LoadUint32(&o.P3_1.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_1_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_1.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_1_OD(value uint32) {
	volatile.StoreUint32(&o.P3_1.Reg, volatile.LoadUint32(&o.P3_1.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_1_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_1.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_1.Reg, volatile.LoadUint32(&o.P3_1.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_1.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_2: I/O configuration register for pin P3[2]
func (o *IOCON_Type) SetP3_2_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_2.Reg, volatile.LoadUint32(&o.P3_2.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_2_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_2.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_2_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_2.Reg, volatile.LoadUint32(&o.P3_2.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_2_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_2.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_2_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_2.Reg, volatile.LoadUint32(&o.P3_2.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_2_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_2.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_2_INV(value uint32) {
	volatile.StoreUint32(&o.P3_2.Reg, volatile.LoadUint32(&o.P3_2.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_2_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_2.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_2.Reg, volatile.LoadUint32(&o.P3_2.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_2.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_2_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_2.Reg, volatile.LoadUint32(&o.P3_2.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_2_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_2.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_2_OD(value uint32) {
	volatile.StoreUint32(&o.P3_2.Reg, volatile.LoadUint32(&o.P3_2.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_2_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_2.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_2.Reg, volatile.LoadUint32(&o.P3_2.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_2.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_3: I/O configuration register for pin P3[3]
func (o *IOCON_Type) SetP3_3_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_3.Reg, volatile.LoadUint32(&o.P3_3.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_3_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_3.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_3_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_3.Reg, volatile.LoadUint32(&o.P3_3.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_3_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_3.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_3_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_3.Reg, volatile.LoadUint32(&o.P3_3.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_3_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_3.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_3_INV(value uint32) {
	volatile.StoreUint32(&o.P3_3.Reg, volatile.LoadUint32(&o.P3_3.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_3_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_3.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_3.Reg, volatile.LoadUint32(&o.P3_3.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_3.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_3_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_3.Reg, volatile.LoadUint32(&o.P3_3.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_3_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_3.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_3_OD(value uint32) {
	volatile.StoreUint32(&o.P3_3.Reg, volatile.LoadUint32(&o.P3_3.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_3_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_3.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_3.Reg, volatile.LoadUint32(&o.P3_3.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_3.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_4: I/O configuration register for pin P3[4]
func (o *IOCON_Type) SetP3_4_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_4.Reg, volatile.LoadUint32(&o.P3_4.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_4_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_4.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_4_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_4.Reg, volatile.LoadUint32(&o.P3_4.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_4_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_4.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_4_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_4.Reg, volatile.LoadUint32(&o.P3_4.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_4_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_4.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_4_INV(value uint32) {
	volatile.StoreUint32(&o.P3_4.Reg, volatile.LoadUint32(&o.P3_4.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_4_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_4.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_4.Reg, volatile.LoadUint32(&o.P3_4.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_4.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_4_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_4.Reg, volatile.LoadUint32(&o.P3_4.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_4_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_4.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_4_OD(value uint32) {
	volatile.StoreUint32(&o.P3_4.Reg, volatile.LoadUint32(&o.P3_4.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_4_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_4.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_4.Reg, volatile.LoadUint32(&o.P3_4.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_4.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_5: I/O configuration register for pin P3[5]
func (o *IOCON_Type) SetP3_5_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_5.Reg, volatile.LoadUint32(&o.P3_5.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_5_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_5.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_5_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_5.Reg, volatile.LoadUint32(&o.P3_5.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_5_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_5.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_5_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_5.Reg, volatile.LoadUint32(&o.P3_5.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_5_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_5.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_5_INV(value uint32) {
	volatile.StoreUint32(&o.P3_5.Reg, volatile.LoadUint32(&o.P3_5.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_5_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_5.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_5.Reg, volatile.LoadUint32(&o.P3_5.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_5.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_5_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_5.Reg, volatile.LoadUint32(&o.P3_5.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_5_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_5.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_5_OD(value uint32) {
	volatile.StoreUint32(&o.P3_5.Reg, volatile.LoadUint32(&o.P3_5.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_5_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_5.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_5.Reg, volatile.LoadUint32(&o.P3_5.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_5.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_6: I/O configuration register for pin P3[6]
func (o *IOCON_Type) SetP3_6_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_6.Reg, volatile.LoadUint32(&o.P3_6.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_6_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_6.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_6_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_6.Reg, volatile.LoadUint32(&o.P3_6.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_6_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_6.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_6_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_6.Reg, volatile.LoadUint32(&o.P3_6.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_6_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_6.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_6_INV(value uint32) {
	volatile.StoreUint32(&o.P3_6.Reg, volatile.LoadUint32(&o.P3_6.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_6_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_6.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_6.Reg, volatile.LoadUint32(&o.P3_6.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_6.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_6_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_6.Reg, volatile.LoadUint32(&o.P3_6.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_6_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_6.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_6_OD(value uint32) {
	volatile.StoreUint32(&o.P3_6.Reg, volatile.LoadUint32(&o.P3_6.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_6_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_6.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_6.Reg, volatile.LoadUint32(&o.P3_6.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_6.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_7: I/O configuration register for pin P3[7]
func (o *IOCON_Type) SetP3_7_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_7.Reg, volatile.LoadUint32(&o.P3_7.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_7_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_7.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_7_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_7.Reg, volatile.LoadUint32(&o.P3_7.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_7_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_7.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_7_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_7.Reg, volatile.LoadUint32(&o.P3_7.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_7_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_7.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_7_INV(value uint32) {
	volatile.StoreUint32(&o.P3_7.Reg, volatile.LoadUint32(&o.P3_7.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_7_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_7.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_7.Reg, volatile.LoadUint32(&o.P3_7.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_7.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_7_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_7.Reg, volatile.LoadUint32(&o.P3_7.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_7_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_7.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_7_OD(value uint32) {
	volatile.StoreUint32(&o.P3_7.Reg, volatile.LoadUint32(&o.P3_7.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_7_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_7.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_7.Reg, volatile.LoadUint32(&o.P3_7.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_7.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_8: I/O configuration register for pin P3[8]
func (o *IOCON_Type) SetP3_8_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_8.Reg, volatile.LoadUint32(&o.P3_8.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_8_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_8.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_8_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_8.Reg, volatile.LoadUint32(&o.P3_8.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_8_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_8.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_8_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_8.Reg, volatile.LoadUint32(&o.P3_8.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_8_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_8.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_8_INV(value uint32) {
	volatile.StoreUint32(&o.P3_8.Reg, volatile.LoadUint32(&o.P3_8.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_8_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_8.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_8_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_8.Reg, volatile.LoadUint32(&o.P3_8.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_8_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_8.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_8_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_8.Reg, volatile.LoadUint32(&o.P3_8.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_8_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_8.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_8_OD(value uint32) {
	volatile.StoreUint32(&o.P3_8.Reg, volatile.LoadUint32(&o.P3_8.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_8_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_8.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_8_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_8.Reg, volatile.LoadUint32(&o.P3_8.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_8_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_8.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_9: I/O configuration register for pin P3[9]
func (o *IOCON_Type) SetP3_9_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_9.Reg, volatile.LoadUint32(&o.P3_9.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_9_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_9.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_9_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_9.Reg, volatile.LoadUint32(&o.P3_9.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_9_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_9.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_9_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_9.Reg, volatile.LoadUint32(&o.P3_9.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_9_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_9.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_9_INV(value uint32) {
	volatile.StoreUint32(&o.P3_9.Reg, volatile.LoadUint32(&o.P3_9.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_9_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_9.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_9_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_9.Reg, volatile.LoadUint32(&o.P3_9.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_9_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_9.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_9_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_9.Reg, volatile.LoadUint32(&o.P3_9.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_9_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_9.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_9_OD(value uint32) {
	volatile.StoreUint32(&o.P3_9.Reg, volatile.LoadUint32(&o.P3_9.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_9_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_9.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_9_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_9.Reg, volatile.LoadUint32(&o.P3_9.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_9_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_9.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_10: I/O configuration register for pin P3[10]
func (o *IOCON_Type) SetP3_10_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_10.Reg, volatile.LoadUint32(&o.P3_10.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_10_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_10.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_10_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_10.Reg, volatile.LoadUint32(&o.P3_10.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_10_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_10.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_10_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_10.Reg, volatile.LoadUint32(&o.P3_10.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_10_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_10.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_10_INV(value uint32) {
	volatile.StoreUint32(&o.P3_10.Reg, volatile.LoadUint32(&o.P3_10.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_10_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_10.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_10_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_10.Reg, volatile.LoadUint32(&o.P3_10.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_10_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_10.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_10_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_10.Reg, volatile.LoadUint32(&o.P3_10.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_10_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_10.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_10_OD(value uint32) {
	volatile.StoreUint32(&o.P3_10.Reg, volatile.LoadUint32(&o.P3_10.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_10_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_10.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_10_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_10.Reg, volatile.LoadUint32(&o.P3_10.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_10_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_10.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_11: I/O configuration register for pin P3[11]
func (o *IOCON_Type) SetP3_11_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_11.Reg, volatile.LoadUint32(&o.P3_11.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_11_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_11.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_11_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_11.Reg, volatile.LoadUint32(&o.P3_11.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_11_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_11.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_11_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_11.Reg, volatile.LoadUint32(&o.P3_11.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_11_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_11.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_11_INV(value uint32) {
	volatile.StoreUint32(&o.P3_11.Reg, volatile.LoadUint32(&o.P3_11.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_11_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_11.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_11_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_11.Reg, volatile.LoadUint32(&o.P3_11.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_11_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_11.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_11_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_11.Reg, volatile.LoadUint32(&o.P3_11.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_11_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_11.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_11_OD(value uint32) {
	volatile.StoreUint32(&o.P3_11.Reg, volatile.LoadUint32(&o.P3_11.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_11_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_11.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_11_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_11.Reg, volatile.LoadUint32(&o.P3_11.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_11_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_11.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_12: I/O configuration register for pin P3[12]
func (o *IOCON_Type) SetP3_12_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_12.Reg, volatile.LoadUint32(&o.P3_12.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_12_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_12.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_12_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_12.Reg, volatile.LoadUint32(&o.P3_12.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_12_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_12.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_12_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_12.Reg, volatile.LoadUint32(&o.P3_12.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_12_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_12.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_12_INV(value uint32) {
	volatile.StoreUint32(&o.P3_12.Reg, volatile.LoadUint32(&o.P3_12.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_12_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_12.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_12_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_12.Reg, volatile.LoadUint32(&o.P3_12.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_12_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_12.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_12_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_12.Reg, volatile.LoadUint32(&o.P3_12.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_12_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_12.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_12_OD(value uint32) {
	volatile.StoreUint32(&o.P3_12.Reg, volatile.LoadUint32(&o.P3_12.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_12_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_12.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_12_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_12.Reg, volatile.LoadUint32(&o.P3_12.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_12_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_12.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_13: I/O configuration register for pin P3[13]
func (o *IOCON_Type) SetP3_13_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_13.Reg, volatile.LoadUint32(&o.P3_13.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_13_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_13.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_13_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_13.Reg, volatile.LoadUint32(&o.P3_13.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_13_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_13.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_13_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_13.Reg, volatile.LoadUint32(&o.P3_13.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_13_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_13.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_13_INV(value uint32) {
	volatile.StoreUint32(&o.P3_13.Reg, volatile.LoadUint32(&o.P3_13.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_13_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_13.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_13_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_13.Reg, volatile.LoadUint32(&o.P3_13.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_13_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_13.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_13_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_13.Reg, volatile.LoadUint32(&o.P3_13.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_13_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_13.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_13_OD(value uint32) {
	volatile.StoreUint32(&o.P3_13.Reg, volatile.LoadUint32(&o.P3_13.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_13_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_13.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_13_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_13.Reg, volatile.LoadUint32(&o.P3_13.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_13_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_13.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_14: I/O configuration register for pin P3[14]
func (o *IOCON_Type) SetP3_14_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_14.Reg, volatile.LoadUint32(&o.P3_14.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_14_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_14.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_14_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_14.Reg, volatile.LoadUint32(&o.P3_14.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_14_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_14.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_14_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_14.Reg, volatile.LoadUint32(&o.P3_14.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_14_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_14.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_14_INV(value uint32) {
	volatile.StoreUint32(&o.P3_14.Reg, volatile.LoadUint32(&o.P3_14.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_14_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_14.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_14_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_14.Reg, volatile.LoadUint32(&o.P3_14.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_14_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_14.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_14_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_14.Reg, volatile.LoadUint32(&o.P3_14.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_14_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_14.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_14_OD(value uint32) {
	volatile.StoreUint32(&o.P3_14.Reg, volatile.LoadUint32(&o.P3_14.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_14_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_14.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_14_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_14.Reg, volatile.LoadUint32(&o.P3_14.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_14_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_14.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_15: I/O configuration register for pin P3[15]
func (o *IOCON_Type) SetP3_15_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_15.Reg, volatile.LoadUint32(&o.P3_15.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_15_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_15.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_15_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_15.Reg, volatile.LoadUint32(&o.P3_15.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_15_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_15.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_15_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_15.Reg, volatile.LoadUint32(&o.P3_15.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_15_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_15.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_15_INV(value uint32) {
	volatile.StoreUint32(&o.P3_15.Reg, volatile.LoadUint32(&o.P3_15.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_15_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_15.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_15_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_15.Reg, volatile.LoadUint32(&o.P3_15.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_15_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_15.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_15_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_15.Reg, volatile.LoadUint32(&o.P3_15.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_15_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_15.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_15_OD(value uint32) {
	volatile.StoreUint32(&o.P3_15.Reg, volatile.LoadUint32(&o.P3_15.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_15_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_15.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_15_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_15.Reg, volatile.LoadUint32(&o.P3_15.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_15_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_15.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_16: I/O configuration register for pin P3[16]
func (o *IOCON_Type) SetP3_16_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_16.Reg, volatile.LoadUint32(&o.P3_16.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_16_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_16.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_16_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_16.Reg, volatile.LoadUint32(&o.P3_16.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_16_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_16.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_16_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_16.Reg, volatile.LoadUint32(&o.P3_16.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_16_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_16.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_16_INV(value uint32) {
	volatile.StoreUint32(&o.P3_16.Reg, volatile.LoadUint32(&o.P3_16.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_16_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_16.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_16_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_16.Reg, volatile.LoadUint32(&o.P3_16.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_16_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_16.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_16_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_16.Reg, volatile.LoadUint32(&o.P3_16.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_16_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_16.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_16_OD(value uint32) {
	volatile.StoreUint32(&o.P3_16.Reg, volatile.LoadUint32(&o.P3_16.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_16_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_16.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_16_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_16.Reg, volatile.LoadUint32(&o.P3_16.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_16_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_16.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_17: I/O configuration register for pin P3[17]
func (o *IOCON_Type) SetP3_17_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_17.Reg, volatile.LoadUint32(&o.P3_17.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_17_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_17.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_17_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_17.Reg, volatile.LoadUint32(&o.P3_17.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_17_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_17.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_17_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_17.Reg, volatile.LoadUint32(&o.P3_17.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_17_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_17.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_17_INV(value uint32) {
	volatile.StoreUint32(&o.P3_17.Reg, volatile.LoadUint32(&o.P3_17.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_17_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_17.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_17_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_17.Reg, volatile.LoadUint32(&o.P3_17.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_17_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_17.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_17_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_17.Reg, volatile.LoadUint32(&o.P3_17.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_17_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_17.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_17_OD(value uint32) {
	volatile.StoreUint32(&o.P3_17.Reg, volatile.LoadUint32(&o.P3_17.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_17_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_17.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_17_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_17.Reg, volatile.LoadUint32(&o.P3_17.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_17_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_17.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_18: I/O configuration register for pin P3[18]
func (o *IOCON_Type) SetP3_18_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_18.Reg, volatile.LoadUint32(&o.P3_18.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_18_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_18.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_18_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_18.Reg, volatile.LoadUint32(&o.P3_18.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_18_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_18.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_18_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_18.Reg, volatile.LoadUint32(&o.P3_18.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_18_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_18.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_18_INV(value uint32) {
	volatile.StoreUint32(&o.P3_18.Reg, volatile.LoadUint32(&o.P3_18.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_18_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_18.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_18_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_18.Reg, volatile.LoadUint32(&o.P3_18.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_18_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_18.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_18_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_18.Reg, volatile.LoadUint32(&o.P3_18.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_18_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_18.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_18_OD(value uint32) {
	volatile.StoreUint32(&o.P3_18.Reg, volatile.LoadUint32(&o.P3_18.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_18_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_18.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_18_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_18.Reg, volatile.LoadUint32(&o.P3_18.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_18_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_18.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_19: I/O configuration register for pin P3[19]
func (o *IOCON_Type) SetP3_19_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_19.Reg, volatile.LoadUint32(&o.P3_19.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_19_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_19.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_19_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_19.Reg, volatile.LoadUint32(&o.P3_19.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_19_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_19.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_19_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_19.Reg, volatile.LoadUint32(&o.P3_19.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_19_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_19.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_19_INV(value uint32) {
	volatile.StoreUint32(&o.P3_19.Reg, volatile.LoadUint32(&o.P3_19.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_19_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_19.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_19_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_19.Reg, volatile.LoadUint32(&o.P3_19.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_19_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_19.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_19_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_19.Reg, volatile.LoadUint32(&o.P3_19.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_19_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_19.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_19_OD(value uint32) {
	volatile.StoreUint32(&o.P3_19.Reg, volatile.LoadUint32(&o.P3_19.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_19_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_19.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_19_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_19.Reg, volatile.LoadUint32(&o.P3_19.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_19_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_19.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_20: I/O configuration register for pin P3[20]
func (o *IOCON_Type) SetP3_20_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_20.Reg, volatile.LoadUint32(&o.P3_20.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_20_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_20.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_20_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_20.Reg, volatile.LoadUint32(&o.P3_20.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_20_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_20.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_20_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_20.Reg, volatile.LoadUint32(&o.P3_20.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_20_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_20.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_20_INV(value uint32) {
	volatile.StoreUint32(&o.P3_20.Reg, volatile.LoadUint32(&o.P3_20.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_20_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_20.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_20_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_20.Reg, volatile.LoadUint32(&o.P3_20.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_20_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_20.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_20_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_20.Reg, volatile.LoadUint32(&o.P3_20.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_20_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_20.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_20_OD(value uint32) {
	volatile.StoreUint32(&o.P3_20.Reg, volatile.LoadUint32(&o.P3_20.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_20_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_20.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_20_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_20.Reg, volatile.LoadUint32(&o.P3_20.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_20_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_20.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_21: I/O configuration register for pin P3[21]
func (o *IOCON_Type) SetP3_21_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_21.Reg, volatile.LoadUint32(&o.P3_21.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_21_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_21.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_21_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_21.Reg, volatile.LoadUint32(&o.P3_21.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_21_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_21.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_21_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_21.Reg, volatile.LoadUint32(&o.P3_21.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_21_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_21.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_21_INV(value uint32) {
	volatile.StoreUint32(&o.P3_21.Reg, volatile.LoadUint32(&o.P3_21.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_21_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_21.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_21_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_21.Reg, volatile.LoadUint32(&o.P3_21.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_21_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_21.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_21_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_21.Reg, volatile.LoadUint32(&o.P3_21.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_21_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_21.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_21_OD(value uint32) {
	volatile.StoreUint32(&o.P3_21.Reg, volatile.LoadUint32(&o.P3_21.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_21_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_21.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_21_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_21.Reg, volatile.LoadUint32(&o.P3_21.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_21_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_21.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_22: I/O configuration register for pin P3[22]
func (o *IOCON_Type) SetP3_22_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_22.Reg, volatile.LoadUint32(&o.P3_22.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_22_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_22.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_22_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_22.Reg, volatile.LoadUint32(&o.P3_22.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_22_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_22.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_22_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_22.Reg, volatile.LoadUint32(&o.P3_22.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_22_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_22.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_22_INV(value uint32) {
	volatile.StoreUint32(&o.P3_22.Reg, volatile.LoadUint32(&o.P3_22.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_22_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_22.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_22_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_22.Reg, volatile.LoadUint32(&o.P3_22.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_22_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_22.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_22_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_22.Reg, volatile.LoadUint32(&o.P3_22.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_22_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_22.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_22_OD(value uint32) {
	volatile.StoreUint32(&o.P3_22.Reg, volatile.LoadUint32(&o.P3_22.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_22_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_22.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_22_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_22.Reg, volatile.LoadUint32(&o.P3_22.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_22_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_22.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_23: I/O configuration register for pin P3[23]
func (o *IOCON_Type) SetP3_23_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_23.Reg, volatile.LoadUint32(&o.P3_23.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_23_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_23.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_23_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_23.Reg, volatile.LoadUint32(&o.P3_23.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_23_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_23.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_23_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_23.Reg, volatile.LoadUint32(&o.P3_23.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_23_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_23.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_23_INV(value uint32) {
	volatile.StoreUint32(&o.P3_23.Reg, volatile.LoadUint32(&o.P3_23.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_23_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_23.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_23_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_23.Reg, volatile.LoadUint32(&o.P3_23.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_23_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_23.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_23_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_23.Reg, volatile.LoadUint32(&o.P3_23.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_23_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_23.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_23_OD(value uint32) {
	volatile.StoreUint32(&o.P3_23.Reg, volatile.LoadUint32(&o.P3_23.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_23_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_23.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_23_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_23.Reg, volatile.LoadUint32(&o.P3_23.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_23_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_23.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_24: I/O configuration register for pin P3[24]
func (o *IOCON_Type) SetP3_24_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_24.Reg, volatile.LoadUint32(&o.P3_24.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_24_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_24.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_24_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_24.Reg, volatile.LoadUint32(&o.P3_24.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_24_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_24.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_24_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_24.Reg, volatile.LoadUint32(&o.P3_24.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_24_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_24.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_24_INV(value uint32) {
	volatile.StoreUint32(&o.P3_24.Reg, volatile.LoadUint32(&o.P3_24.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_24_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_24.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_24_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_24.Reg, volatile.LoadUint32(&o.P3_24.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_24_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_24.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_24_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_24.Reg, volatile.LoadUint32(&o.P3_24.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_24_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_24.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_24_OD(value uint32) {
	volatile.StoreUint32(&o.P3_24.Reg, volatile.LoadUint32(&o.P3_24.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_24_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_24.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_24_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_24.Reg, volatile.LoadUint32(&o.P3_24.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_24_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_24.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_25: I/O configuration register for pin P3[25]
func (o *IOCON_Type) SetP3_25_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_25.Reg, volatile.LoadUint32(&o.P3_25.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_25_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_25.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_25_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_25.Reg, volatile.LoadUint32(&o.P3_25.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_25_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_25.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_25_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_25.Reg, volatile.LoadUint32(&o.P3_25.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_25_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_25.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_25_INV(value uint32) {
	volatile.StoreUint32(&o.P3_25.Reg, volatile.LoadUint32(&o.P3_25.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_25_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_25.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_25_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_25.Reg, volatile.LoadUint32(&o.P3_25.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_25_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_25.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_25_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_25.Reg, volatile.LoadUint32(&o.P3_25.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_25_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_25.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_25_OD(value uint32) {
	volatile.StoreUint32(&o.P3_25.Reg, volatile.LoadUint32(&o.P3_25.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_25_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_25.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_25_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_25.Reg, volatile.LoadUint32(&o.P3_25.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_25_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_25.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_26: I/O configuration register for pin P3[26]
func (o *IOCON_Type) SetP3_26_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_26.Reg, volatile.LoadUint32(&o.P3_26.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_26_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_26.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_26_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_26.Reg, volatile.LoadUint32(&o.P3_26.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_26_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_26.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_26_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_26.Reg, volatile.LoadUint32(&o.P3_26.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_26_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_26.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_26_INV(value uint32) {
	volatile.StoreUint32(&o.P3_26.Reg, volatile.LoadUint32(&o.P3_26.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_26_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_26.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_26_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_26.Reg, volatile.LoadUint32(&o.P3_26.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_26_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_26.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_26_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_26.Reg, volatile.LoadUint32(&o.P3_26.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_26_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_26.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_26_OD(value uint32) {
	volatile.StoreUint32(&o.P3_26.Reg, volatile.LoadUint32(&o.P3_26.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_26_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_26.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_26_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_26.Reg, volatile.LoadUint32(&o.P3_26.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_26_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_26.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_27: I/O configuration register for pin P3[27]
func (o *IOCON_Type) SetP3_27_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_27.Reg, volatile.LoadUint32(&o.P3_27.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_27_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_27.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_27_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_27.Reg, volatile.LoadUint32(&o.P3_27.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_27_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_27.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_27_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_27.Reg, volatile.LoadUint32(&o.P3_27.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_27_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_27.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_27_INV(value uint32) {
	volatile.StoreUint32(&o.P3_27.Reg, volatile.LoadUint32(&o.P3_27.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_27_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_27.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_27_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_27.Reg, volatile.LoadUint32(&o.P3_27.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_27_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_27.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_27_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_27.Reg, volatile.LoadUint32(&o.P3_27.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_27_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_27.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_27_OD(value uint32) {
	volatile.StoreUint32(&o.P3_27.Reg, volatile.LoadUint32(&o.P3_27.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_27_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_27.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_27_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_27.Reg, volatile.LoadUint32(&o.P3_27.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_27_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_27.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_28: I/O configuration register for pin P3[28]
func (o *IOCON_Type) SetP3_28_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_28.Reg, volatile.LoadUint32(&o.P3_28.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_28_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_28.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_28_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_28.Reg, volatile.LoadUint32(&o.P3_28.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_28_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_28.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_28_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_28.Reg, volatile.LoadUint32(&o.P3_28.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_28_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_28.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_28_INV(value uint32) {
	volatile.StoreUint32(&o.P3_28.Reg, volatile.LoadUint32(&o.P3_28.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_28_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_28.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_28_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_28.Reg, volatile.LoadUint32(&o.P3_28.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_28_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_28.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_28_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_28.Reg, volatile.LoadUint32(&o.P3_28.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_28_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_28.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_28_OD(value uint32) {
	volatile.StoreUint32(&o.P3_28.Reg, volatile.LoadUint32(&o.P3_28.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_28_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_28.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_28_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_28.Reg, volatile.LoadUint32(&o.P3_28.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_28_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_28.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_29: I/O configuration register for pin P3[29]
func (o *IOCON_Type) SetP3_29_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_29.Reg, volatile.LoadUint32(&o.P3_29.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_29_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_29.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_29_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_29.Reg, volatile.LoadUint32(&o.P3_29.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_29_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_29.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_29_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_29.Reg, volatile.LoadUint32(&o.P3_29.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_29_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_29.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_29_INV(value uint32) {
	volatile.StoreUint32(&o.P3_29.Reg, volatile.LoadUint32(&o.P3_29.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_29_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_29.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_29_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_29.Reg, volatile.LoadUint32(&o.P3_29.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_29_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_29.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_29_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_29.Reg, volatile.LoadUint32(&o.P3_29.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_29_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_29.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_29_OD(value uint32) {
	volatile.StoreUint32(&o.P3_29.Reg, volatile.LoadUint32(&o.P3_29.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_29_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_29.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_29_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_29.Reg, volatile.LoadUint32(&o.P3_29.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_29_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_29.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_30: I/O configuration register for pin P3[30]
func (o *IOCON_Type) SetP3_30_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_30.Reg, volatile.LoadUint32(&o.P3_30.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_30_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_30.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_30_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_30.Reg, volatile.LoadUint32(&o.P3_30.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_30_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_30.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_30_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_30.Reg, volatile.LoadUint32(&o.P3_30.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_30_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_30.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_30_INV(value uint32) {
	volatile.StoreUint32(&o.P3_30.Reg, volatile.LoadUint32(&o.P3_30.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_30_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_30.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_30_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_30.Reg, volatile.LoadUint32(&o.P3_30.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_30_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_30.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_30_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_30.Reg, volatile.LoadUint32(&o.P3_30.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_30_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_30.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_30_OD(value uint32) {
	volatile.StoreUint32(&o.P3_30.Reg, volatile.LoadUint32(&o.P3_30.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_30_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_30.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_30_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_30.Reg, volatile.LoadUint32(&o.P3_30.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_30_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_30.Reg) & 0xfffff800) >> 11
}

// IOCON.P3_31: I/O configuration register for pin P3[31]
func (o *IOCON_Type) SetP3_31_FUNC(value uint32) {
	volatile.StoreUint32(&o.P3_31.Reg, volatile.LoadUint32(&o.P3_31.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP3_31_FUNC() uint32 {
	return volatile.LoadUint32(&o.P3_31.Reg) & 0x7
}
func (o *IOCON_Type) SetP3_31_MODE(value uint32) {
	volatile.StoreUint32(&o.P3_31.Reg, volatile.LoadUint32(&o.P3_31.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP3_31_MODE() uint32 {
	return (volatile.LoadUint32(&o.P3_31.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP3_31_HYS(value uint32) {
	volatile.StoreUint32(&o.P3_31.Reg, volatile.LoadUint32(&o.P3_31.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP3_31_HYS() uint32 {
	return (volatile.LoadUint32(&o.P3_31.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP3_31_INV(value uint32) {
	volatile.StoreUint32(&o.P3_31.Reg, volatile.LoadUint32(&o.P3_31.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP3_31_INV() uint32 {
	return (volatile.LoadUint32(&o.P3_31.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP3_31_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_31.Reg, volatile.LoadUint32(&o.P3_31.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP3_31_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_31.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP3_31_SLEW(value uint32) {
	volatile.StoreUint32(&o.P3_31.Reg, volatile.LoadUint32(&o.P3_31.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP3_31_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P3_31.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP3_31_OD(value uint32) {
	volatile.StoreUint32(&o.P3_31.Reg, volatile.LoadUint32(&o.P3_31.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP3_31_OD() uint32 {
	return (volatile.LoadUint32(&o.P3_31.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP3_31_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P3_31.Reg, volatile.LoadUint32(&o.P3_31.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP3_31_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P3_31.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_0: I/O configuration register for pin P4[0]
func (o *IOCON_Type) SetP4_0_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_0.Reg, volatile.LoadUint32(&o.P4_0.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_0_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_0.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_0_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_0.Reg, volatile.LoadUint32(&o.P4_0.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_0_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_0.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_0_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_0.Reg, volatile.LoadUint32(&o.P4_0.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_0_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_0.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_0_INV(value uint32) {
	volatile.StoreUint32(&o.P4_0.Reg, volatile.LoadUint32(&o.P4_0.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_0_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_0.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_0.Reg, volatile.LoadUint32(&o.P4_0.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_0.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_0_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_0.Reg, volatile.LoadUint32(&o.P4_0.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_0_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_0.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_0_OD(value uint32) {
	volatile.StoreUint32(&o.P4_0.Reg, volatile.LoadUint32(&o.P4_0.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_0_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_0.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_0.Reg, volatile.LoadUint32(&o.P4_0.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_0.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_1: I/O configuration register for pin P4[1]
func (o *IOCON_Type) SetP4_1_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_1.Reg, volatile.LoadUint32(&o.P4_1.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_1_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_1.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_1_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_1.Reg, volatile.LoadUint32(&o.P4_1.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_1_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_1.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_1_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_1.Reg, volatile.LoadUint32(&o.P4_1.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_1_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_1.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_1_INV(value uint32) {
	volatile.StoreUint32(&o.P4_1.Reg, volatile.LoadUint32(&o.P4_1.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_1_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_1.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_1.Reg, volatile.LoadUint32(&o.P4_1.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_1.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_1_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_1.Reg, volatile.LoadUint32(&o.P4_1.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_1_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_1.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_1_OD(value uint32) {
	volatile.StoreUint32(&o.P4_1.Reg, volatile.LoadUint32(&o.P4_1.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_1_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_1.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_1.Reg, volatile.LoadUint32(&o.P4_1.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_1.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_2: I/O configuration register for pin P4[2]
func (o *IOCON_Type) SetP4_2_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_2.Reg, volatile.LoadUint32(&o.P4_2.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_2_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_2.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_2_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_2.Reg, volatile.LoadUint32(&o.P4_2.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_2_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_2.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_2_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_2.Reg, volatile.LoadUint32(&o.P4_2.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_2_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_2.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_2_INV(value uint32) {
	volatile.StoreUint32(&o.P4_2.Reg, volatile.LoadUint32(&o.P4_2.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_2_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_2.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_2.Reg, volatile.LoadUint32(&o.P4_2.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_2.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_2_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_2.Reg, volatile.LoadUint32(&o.P4_2.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_2_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_2.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_2_OD(value uint32) {
	volatile.StoreUint32(&o.P4_2.Reg, volatile.LoadUint32(&o.P4_2.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_2_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_2.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_2.Reg, volatile.LoadUint32(&o.P4_2.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_2.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_3: I/O configuration register for pin P4[3]
func (o *IOCON_Type) SetP4_3_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_3.Reg, volatile.LoadUint32(&o.P4_3.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_3_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_3.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_3_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_3.Reg, volatile.LoadUint32(&o.P4_3.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_3_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_3.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_3_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_3.Reg, volatile.LoadUint32(&o.P4_3.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_3_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_3.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_3_INV(value uint32) {
	volatile.StoreUint32(&o.P4_3.Reg, volatile.LoadUint32(&o.P4_3.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_3_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_3.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_3.Reg, volatile.LoadUint32(&o.P4_3.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_3.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_3_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_3.Reg, volatile.LoadUint32(&o.P4_3.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_3_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_3.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_3_OD(value uint32) {
	volatile.StoreUint32(&o.P4_3.Reg, volatile.LoadUint32(&o.P4_3.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_3_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_3.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_3.Reg, volatile.LoadUint32(&o.P4_3.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_3.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_4: I/O configuration register for pin P4[4]
func (o *IOCON_Type) SetP4_4_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_4.Reg, volatile.LoadUint32(&o.P4_4.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_4_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_4.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_4_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_4.Reg, volatile.LoadUint32(&o.P4_4.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_4_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_4.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_4_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_4.Reg, volatile.LoadUint32(&o.P4_4.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_4_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_4.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_4_INV(value uint32) {
	volatile.StoreUint32(&o.P4_4.Reg, volatile.LoadUint32(&o.P4_4.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_4_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_4.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_4.Reg, volatile.LoadUint32(&o.P4_4.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_4.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_4_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_4.Reg, volatile.LoadUint32(&o.P4_4.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_4_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_4.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_4_OD(value uint32) {
	volatile.StoreUint32(&o.P4_4.Reg, volatile.LoadUint32(&o.P4_4.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_4_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_4.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_4.Reg, volatile.LoadUint32(&o.P4_4.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_4.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_5: I/O configuration register for pin P4[5]
func (o *IOCON_Type) SetP4_5_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_5.Reg, volatile.LoadUint32(&o.P4_5.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_5_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_5.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_5_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_5.Reg, volatile.LoadUint32(&o.P4_5.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_5_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_5.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_5_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_5.Reg, volatile.LoadUint32(&o.P4_5.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_5_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_5.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_5_INV(value uint32) {
	volatile.StoreUint32(&o.P4_5.Reg, volatile.LoadUint32(&o.P4_5.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_5_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_5.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_5.Reg, volatile.LoadUint32(&o.P4_5.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_5.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_5_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_5.Reg, volatile.LoadUint32(&o.P4_5.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_5_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_5.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_5_OD(value uint32) {
	volatile.StoreUint32(&o.P4_5.Reg, volatile.LoadUint32(&o.P4_5.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_5_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_5.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_5.Reg, volatile.LoadUint32(&o.P4_5.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_5.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_6: I/O configuration register for pin P4[6]
func (o *IOCON_Type) SetP4_6_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_6.Reg, volatile.LoadUint32(&o.P4_6.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_6_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_6.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_6_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_6.Reg, volatile.LoadUint32(&o.P4_6.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_6_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_6.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_6_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_6.Reg, volatile.LoadUint32(&o.P4_6.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_6_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_6.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_6_INV(value uint32) {
	volatile.StoreUint32(&o.P4_6.Reg, volatile.LoadUint32(&o.P4_6.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_6_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_6.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_6.Reg, volatile.LoadUint32(&o.P4_6.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_6.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_6_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_6.Reg, volatile.LoadUint32(&o.P4_6.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_6_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_6.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_6_OD(value uint32) {
	volatile.StoreUint32(&o.P4_6.Reg, volatile.LoadUint32(&o.P4_6.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_6_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_6.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_6.Reg, volatile.LoadUint32(&o.P4_6.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_6.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_7: I/O configuration register for pin P4[7]
func (o *IOCON_Type) SetP4_7_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_7.Reg, volatile.LoadUint32(&o.P4_7.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_7_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_7.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_7_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_7.Reg, volatile.LoadUint32(&o.P4_7.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_7_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_7.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_7_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_7.Reg, volatile.LoadUint32(&o.P4_7.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_7_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_7.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_7_INV(value uint32) {
	volatile.StoreUint32(&o.P4_7.Reg, volatile.LoadUint32(&o.P4_7.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_7_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_7.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_7.Reg, volatile.LoadUint32(&o.P4_7.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_7.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_7_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_7.Reg, volatile.LoadUint32(&o.P4_7.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_7_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_7.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_7_OD(value uint32) {
	volatile.StoreUint32(&o.P4_7.Reg, volatile.LoadUint32(&o.P4_7.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_7_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_7.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_7.Reg, volatile.LoadUint32(&o.P4_7.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_7.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_8: I/O configuration register for pin P4[8]
func (o *IOCON_Type) SetP4_8_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_8.Reg, volatile.LoadUint32(&o.P4_8.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_8_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_8.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_8_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_8.Reg, volatile.LoadUint32(&o.P4_8.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_8_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_8.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_8_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_8.Reg, volatile.LoadUint32(&o.P4_8.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_8_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_8.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_8_INV(value uint32) {
	volatile.StoreUint32(&o.P4_8.Reg, volatile.LoadUint32(&o.P4_8.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_8_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_8.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_8_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_8.Reg, volatile.LoadUint32(&o.P4_8.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_8_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_8.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_8_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_8.Reg, volatile.LoadUint32(&o.P4_8.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_8_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_8.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_8_OD(value uint32) {
	volatile.StoreUint32(&o.P4_8.Reg, volatile.LoadUint32(&o.P4_8.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_8_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_8.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_8_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_8.Reg, volatile.LoadUint32(&o.P4_8.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_8_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_8.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_9: I/O configuration register for pin P4[9]
func (o *IOCON_Type) SetP4_9_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_9.Reg, volatile.LoadUint32(&o.P4_9.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_9_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_9.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_9_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_9.Reg, volatile.LoadUint32(&o.P4_9.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_9_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_9.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_9_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_9.Reg, volatile.LoadUint32(&o.P4_9.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_9_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_9.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_9_INV(value uint32) {
	volatile.StoreUint32(&o.P4_9.Reg, volatile.LoadUint32(&o.P4_9.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_9_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_9.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_9_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_9.Reg, volatile.LoadUint32(&o.P4_9.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_9_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_9.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_9_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_9.Reg, volatile.LoadUint32(&o.P4_9.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_9_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_9.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_9_OD(value uint32) {
	volatile.StoreUint32(&o.P4_9.Reg, volatile.LoadUint32(&o.P4_9.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_9_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_9.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_9_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_9.Reg, volatile.LoadUint32(&o.P4_9.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_9_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_9.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_10: I/O configuration register for pin P4[10]
func (o *IOCON_Type) SetP4_10_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_10.Reg, volatile.LoadUint32(&o.P4_10.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_10_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_10.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_10_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_10.Reg, volatile.LoadUint32(&o.P4_10.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_10_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_10.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_10_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_10.Reg, volatile.LoadUint32(&o.P4_10.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_10_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_10.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_10_INV(value uint32) {
	volatile.StoreUint32(&o.P4_10.Reg, volatile.LoadUint32(&o.P4_10.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_10_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_10.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_10_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_10.Reg, volatile.LoadUint32(&o.P4_10.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_10_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_10.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_10_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_10.Reg, volatile.LoadUint32(&o.P4_10.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_10_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_10.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_10_OD(value uint32) {
	volatile.StoreUint32(&o.P4_10.Reg, volatile.LoadUint32(&o.P4_10.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_10_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_10.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_10_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_10.Reg, volatile.LoadUint32(&o.P4_10.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_10_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_10.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_11: I/O configuration register for pin P4[11]
func (o *IOCON_Type) SetP4_11_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_11.Reg, volatile.LoadUint32(&o.P4_11.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_11_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_11.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_11_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_11.Reg, volatile.LoadUint32(&o.P4_11.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_11_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_11.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_11_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_11.Reg, volatile.LoadUint32(&o.P4_11.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_11_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_11.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_11_INV(value uint32) {
	volatile.StoreUint32(&o.P4_11.Reg, volatile.LoadUint32(&o.P4_11.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_11_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_11.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_11_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_11.Reg, volatile.LoadUint32(&o.P4_11.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_11_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_11.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_11_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_11.Reg, volatile.LoadUint32(&o.P4_11.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_11_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_11.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_11_OD(value uint32) {
	volatile.StoreUint32(&o.P4_11.Reg, volatile.LoadUint32(&o.P4_11.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_11_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_11.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_11_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_11.Reg, volatile.LoadUint32(&o.P4_11.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_11_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_11.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_12: I/O configuration register for pin P4[12]
func (o *IOCON_Type) SetP4_12_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_12.Reg, volatile.LoadUint32(&o.P4_12.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_12_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_12.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_12_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_12.Reg, volatile.LoadUint32(&o.P4_12.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_12_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_12.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_12_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_12.Reg, volatile.LoadUint32(&o.P4_12.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_12_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_12.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_12_INV(value uint32) {
	volatile.StoreUint32(&o.P4_12.Reg, volatile.LoadUint32(&o.P4_12.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_12_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_12.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_12_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_12.Reg, volatile.LoadUint32(&o.P4_12.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_12_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_12.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_12_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_12.Reg, volatile.LoadUint32(&o.P4_12.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_12_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_12.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_12_OD(value uint32) {
	volatile.StoreUint32(&o.P4_12.Reg, volatile.LoadUint32(&o.P4_12.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_12_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_12.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_12_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_12.Reg, volatile.LoadUint32(&o.P4_12.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_12_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_12.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_13: I/O configuration register for pin P4[13]
func (o *IOCON_Type) SetP4_13_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_13.Reg, volatile.LoadUint32(&o.P4_13.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_13_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_13.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_13_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_13.Reg, volatile.LoadUint32(&o.P4_13.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_13_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_13.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_13_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_13.Reg, volatile.LoadUint32(&o.P4_13.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_13_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_13.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_13_INV(value uint32) {
	volatile.StoreUint32(&o.P4_13.Reg, volatile.LoadUint32(&o.P4_13.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_13_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_13.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_13_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_13.Reg, volatile.LoadUint32(&o.P4_13.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_13_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_13.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_13_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_13.Reg, volatile.LoadUint32(&o.P4_13.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_13_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_13.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_13_OD(value uint32) {
	volatile.StoreUint32(&o.P4_13.Reg, volatile.LoadUint32(&o.P4_13.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_13_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_13.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_13_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_13.Reg, volatile.LoadUint32(&o.P4_13.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_13_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_13.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_14: I/O configuration register for pin P4[14]
func (o *IOCON_Type) SetP4_14_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_14.Reg, volatile.LoadUint32(&o.P4_14.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_14_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_14.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_14_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_14.Reg, volatile.LoadUint32(&o.P4_14.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_14_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_14.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_14_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_14.Reg, volatile.LoadUint32(&o.P4_14.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_14_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_14.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_14_INV(value uint32) {
	volatile.StoreUint32(&o.P4_14.Reg, volatile.LoadUint32(&o.P4_14.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_14_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_14.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_14_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_14.Reg, volatile.LoadUint32(&o.P4_14.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_14_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_14.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_14_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_14.Reg, volatile.LoadUint32(&o.P4_14.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_14_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_14.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_14_OD(value uint32) {
	volatile.StoreUint32(&o.P4_14.Reg, volatile.LoadUint32(&o.P4_14.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_14_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_14.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_14_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_14.Reg, volatile.LoadUint32(&o.P4_14.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_14_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_14.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_15: I/O configuration register for pin P4[15]
func (o *IOCON_Type) SetP4_15_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_15.Reg, volatile.LoadUint32(&o.P4_15.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_15_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_15.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_15_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_15.Reg, volatile.LoadUint32(&o.P4_15.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_15_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_15.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_15_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_15.Reg, volatile.LoadUint32(&o.P4_15.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_15_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_15.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_15_INV(value uint32) {
	volatile.StoreUint32(&o.P4_15.Reg, volatile.LoadUint32(&o.P4_15.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_15_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_15.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_15_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_15.Reg, volatile.LoadUint32(&o.P4_15.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_15_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_15.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_15_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_15.Reg, volatile.LoadUint32(&o.P4_15.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_15_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_15.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_15_OD(value uint32) {
	volatile.StoreUint32(&o.P4_15.Reg, volatile.LoadUint32(&o.P4_15.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_15_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_15.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_15_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_15.Reg, volatile.LoadUint32(&o.P4_15.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_15_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_15.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_16: I/O configuration register for pin P4[16]
func (o *IOCON_Type) SetP4_16_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_16.Reg, volatile.LoadUint32(&o.P4_16.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_16_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_16.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_16_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_16.Reg, volatile.LoadUint32(&o.P4_16.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_16_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_16.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_16_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_16.Reg, volatile.LoadUint32(&o.P4_16.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_16_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_16.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_16_INV(value uint32) {
	volatile.StoreUint32(&o.P4_16.Reg, volatile.LoadUint32(&o.P4_16.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_16_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_16.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_16_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_16.Reg, volatile.LoadUint32(&o.P4_16.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_16_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_16.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_16_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_16.Reg, volatile.LoadUint32(&o.P4_16.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_16_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_16.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_16_OD(value uint32) {
	volatile.StoreUint32(&o.P4_16.Reg, volatile.LoadUint32(&o.P4_16.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_16_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_16.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_16_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_16.Reg, volatile.LoadUint32(&o.P4_16.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_16_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_16.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_17: I/O configuration register for pin P4[17]
func (o *IOCON_Type) SetP4_17_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_17.Reg, volatile.LoadUint32(&o.P4_17.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_17_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_17.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_17_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_17.Reg, volatile.LoadUint32(&o.P4_17.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_17_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_17.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_17_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_17.Reg, volatile.LoadUint32(&o.P4_17.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_17_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_17.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_17_INV(value uint32) {
	volatile.StoreUint32(&o.P4_17.Reg, volatile.LoadUint32(&o.P4_17.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_17_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_17.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_17_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_17.Reg, volatile.LoadUint32(&o.P4_17.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_17_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_17.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_17_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_17.Reg, volatile.LoadUint32(&o.P4_17.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_17_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_17.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_17_OD(value uint32) {
	volatile.StoreUint32(&o.P4_17.Reg, volatile.LoadUint32(&o.P4_17.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_17_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_17.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_17_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_17.Reg, volatile.LoadUint32(&o.P4_17.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_17_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_17.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_18: I/O configuration register for pin P4[18]
func (o *IOCON_Type) SetP4_18_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_18.Reg, volatile.LoadUint32(&o.P4_18.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_18_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_18.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_18_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_18.Reg, volatile.LoadUint32(&o.P4_18.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_18_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_18.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_18_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_18.Reg, volatile.LoadUint32(&o.P4_18.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_18_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_18.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_18_INV(value uint32) {
	volatile.StoreUint32(&o.P4_18.Reg, volatile.LoadUint32(&o.P4_18.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_18_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_18.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_18_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_18.Reg, volatile.LoadUint32(&o.P4_18.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_18_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_18.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_18_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_18.Reg, volatile.LoadUint32(&o.P4_18.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_18_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_18.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_18_OD(value uint32) {
	volatile.StoreUint32(&o.P4_18.Reg, volatile.LoadUint32(&o.P4_18.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_18_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_18.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_18_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_18.Reg, volatile.LoadUint32(&o.P4_18.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_18_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_18.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_19: I/O configuration register for pin P4[19]
func (o *IOCON_Type) SetP4_19_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_19.Reg, volatile.LoadUint32(&o.P4_19.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_19_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_19.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_19_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_19.Reg, volatile.LoadUint32(&o.P4_19.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_19_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_19.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_19_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_19.Reg, volatile.LoadUint32(&o.P4_19.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_19_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_19.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_19_INV(value uint32) {
	volatile.StoreUint32(&o.P4_19.Reg, volatile.LoadUint32(&o.P4_19.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_19_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_19.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_19_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_19.Reg, volatile.LoadUint32(&o.P4_19.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_19_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_19.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_19_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_19.Reg, volatile.LoadUint32(&o.P4_19.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_19_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_19.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_19_OD(value uint32) {
	volatile.StoreUint32(&o.P4_19.Reg, volatile.LoadUint32(&o.P4_19.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_19_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_19.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_19_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_19.Reg, volatile.LoadUint32(&o.P4_19.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_19_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_19.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_20: I/O configuration register for pin P4[20]
func (o *IOCON_Type) SetP4_20_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_20.Reg, volatile.LoadUint32(&o.P4_20.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_20_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_20.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_20_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_20.Reg, volatile.LoadUint32(&o.P4_20.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_20_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_20.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_20_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_20.Reg, volatile.LoadUint32(&o.P4_20.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_20_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_20.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_20_INV(value uint32) {
	volatile.StoreUint32(&o.P4_20.Reg, volatile.LoadUint32(&o.P4_20.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_20_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_20.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_20_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_20.Reg, volatile.LoadUint32(&o.P4_20.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_20_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_20.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_20_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_20.Reg, volatile.LoadUint32(&o.P4_20.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_20_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_20.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_20_OD(value uint32) {
	volatile.StoreUint32(&o.P4_20.Reg, volatile.LoadUint32(&o.P4_20.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_20_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_20.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_20_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_20.Reg, volatile.LoadUint32(&o.P4_20.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_20_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_20.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_21: I/O configuration register for pin P4[21]
func (o *IOCON_Type) SetP4_21_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_21.Reg, volatile.LoadUint32(&o.P4_21.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_21_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_21.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_21_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_21.Reg, volatile.LoadUint32(&o.P4_21.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_21_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_21.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_21_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_21.Reg, volatile.LoadUint32(&o.P4_21.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_21_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_21.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_21_INV(value uint32) {
	volatile.StoreUint32(&o.P4_21.Reg, volatile.LoadUint32(&o.P4_21.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_21_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_21.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_21_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_21.Reg, volatile.LoadUint32(&o.P4_21.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_21_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_21.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_21_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_21.Reg, volatile.LoadUint32(&o.P4_21.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_21_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_21.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_21_OD(value uint32) {
	volatile.StoreUint32(&o.P4_21.Reg, volatile.LoadUint32(&o.P4_21.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_21_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_21.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_21_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_21.Reg, volatile.LoadUint32(&o.P4_21.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_21_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_21.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_22: I/O configuration register for pin P4[22]
func (o *IOCON_Type) SetP4_22_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_22.Reg, volatile.LoadUint32(&o.P4_22.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_22_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_22.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_22_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_22.Reg, volatile.LoadUint32(&o.P4_22.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_22_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_22.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_22_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_22.Reg, volatile.LoadUint32(&o.P4_22.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_22_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_22.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_22_INV(value uint32) {
	volatile.StoreUint32(&o.P4_22.Reg, volatile.LoadUint32(&o.P4_22.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_22_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_22.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_22_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_22.Reg, volatile.LoadUint32(&o.P4_22.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_22_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_22.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_22_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_22.Reg, volatile.LoadUint32(&o.P4_22.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_22_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_22.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_22_OD(value uint32) {
	volatile.StoreUint32(&o.P4_22.Reg, volatile.LoadUint32(&o.P4_22.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_22_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_22.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_22_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_22.Reg, volatile.LoadUint32(&o.P4_22.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_22_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_22.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_23: I/O configuration register for pin P4[23]
func (o *IOCON_Type) SetP4_23_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_23.Reg, volatile.LoadUint32(&o.P4_23.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_23_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_23.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_23_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_23.Reg, volatile.LoadUint32(&o.P4_23.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_23_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_23.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_23_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_23.Reg, volatile.LoadUint32(&o.P4_23.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_23_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_23.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_23_INV(value uint32) {
	volatile.StoreUint32(&o.P4_23.Reg, volatile.LoadUint32(&o.P4_23.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_23_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_23.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_23_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_23.Reg, volatile.LoadUint32(&o.P4_23.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_23_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_23.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_23_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_23.Reg, volatile.LoadUint32(&o.P4_23.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_23_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_23.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_23_OD(value uint32) {
	volatile.StoreUint32(&o.P4_23.Reg, volatile.LoadUint32(&o.P4_23.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_23_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_23.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_23_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_23.Reg, volatile.LoadUint32(&o.P4_23.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_23_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_23.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_24: I/O configuration register for pin P4[24]
func (o *IOCON_Type) SetP4_24_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_24.Reg, volatile.LoadUint32(&o.P4_24.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_24_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_24.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_24_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_24.Reg, volatile.LoadUint32(&o.P4_24.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_24_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_24.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_24_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_24.Reg, volatile.LoadUint32(&o.P4_24.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_24_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_24.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_24_INV(value uint32) {
	volatile.StoreUint32(&o.P4_24.Reg, volatile.LoadUint32(&o.P4_24.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_24_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_24.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_24_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_24.Reg, volatile.LoadUint32(&o.P4_24.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_24_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_24.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_24_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_24.Reg, volatile.LoadUint32(&o.P4_24.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_24_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_24.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_24_OD(value uint32) {
	volatile.StoreUint32(&o.P4_24.Reg, volatile.LoadUint32(&o.P4_24.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_24_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_24.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_24_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_24.Reg, volatile.LoadUint32(&o.P4_24.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_24_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_24.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_25: I/O configuration register for pin P4[25]
func (o *IOCON_Type) SetP4_25_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_25.Reg, volatile.LoadUint32(&o.P4_25.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_25_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_25.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_25_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_25.Reg, volatile.LoadUint32(&o.P4_25.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_25_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_25.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_25_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_25.Reg, volatile.LoadUint32(&o.P4_25.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_25_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_25.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_25_INV(value uint32) {
	volatile.StoreUint32(&o.P4_25.Reg, volatile.LoadUint32(&o.P4_25.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_25_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_25.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_25_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_25.Reg, volatile.LoadUint32(&o.P4_25.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_25_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_25.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_25_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_25.Reg, volatile.LoadUint32(&o.P4_25.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_25_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_25.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_25_OD(value uint32) {
	volatile.StoreUint32(&o.P4_25.Reg, volatile.LoadUint32(&o.P4_25.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_25_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_25.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_25_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_25.Reg, volatile.LoadUint32(&o.P4_25.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_25_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_25.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_26: I/O configuration register for pin P4[26]
func (o *IOCON_Type) SetP4_26_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_26.Reg, volatile.LoadUint32(&o.P4_26.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_26_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_26.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_26_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_26.Reg, volatile.LoadUint32(&o.P4_26.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_26_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_26.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_26_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_26.Reg, volatile.LoadUint32(&o.P4_26.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_26_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_26.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_26_INV(value uint32) {
	volatile.StoreUint32(&o.P4_26.Reg, volatile.LoadUint32(&o.P4_26.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_26_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_26.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_26_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_26.Reg, volatile.LoadUint32(&o.P4_26.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_26_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_26.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_26_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_26.Reg, volatile.LoadUint32(&o.P4_26.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_26_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_26.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_26_OD(value uint32) {
	volatile.StoreUint32(&o.P4_26.Reg, volatile.LoadUint32(&o.P4_26.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_26_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_26.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_26_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_26.Reg, volatile.LoadUint32(&o.P4_26.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_26_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_26.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_27: I/O configuration register for pin P4[27]
func (o *IOCON_Type) SetP4_27_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_27.Reg, volatile.LoadUint32(&o.P4_27.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_27_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_27.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_27_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_27.Reg, volatile.LoadUint32(&o.P4_27.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_27_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_27.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_27_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_27.Reg, volatile.LoadUint32(&o.P4_27.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_27_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_27.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_27_INV(value uint32) {
	volatile.StoreUint32(&o.P4_27.Reg, volatile.LoadUint32(&o.P4_27.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_27_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_27.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_27_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_27.Reg, volatile.LoadUint32(&o.P4_27.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_27_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_27.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_27_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_27.Reg, volatile.LoadUint32(&o.P4_27.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_27_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_27.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_27_OD(value uint32) {
	volatile.StoreUint32(&o.P4_27.Reg, volatile.LoadUint32(&o.P4_27.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_27_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_27.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_27_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_27.Reg, volatile.LoadUint32(&o.P4_27.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_27_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_27.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_28: I/O configuration register for pin P4[28]
func (o *IOCON_Type) SetP4_28_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_28.Reg, volatile.LoadUint32(&o.P4_28.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_28_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_28.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_28_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_28.Reg, volatile.LoadUint32(&o.P4_28.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_28_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_28.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_28_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_28.Reg, volatile.LoadUint32(&o.P4_28.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_28_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_28.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_28_INV(value uint32) {
	volatile.StoreUint32(&o.P4_28.Reg, volatile.LoadUint32(&o.P4_28.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_28_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_28.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_28_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_28.Reg, volatile.LoadUint32(&o.P4_28.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_28_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_28.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_28_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_28.Reg, volatile.LoadUint32(&o.P4_28.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_28_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_28.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_28_OD(value uint32) {
	volatile.StoreUint32(&o.P4_28.Reg, volatile.LoadUint32(&o.P4_28.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_28_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_28.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_28_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_28.Reg, volatile.LoadUint32(&o.P4_28.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_28_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_28.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_29: I/O configuration register for pin P4[29]
func (o *IOCON_Type) SetP4_29_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_29.Reg, volatile.LoadUint32(&o.P4_29.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_29_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_29.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_29_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_29.Reg, volatile.LoadUint32(&o.P4_29.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_29_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_29.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_29_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_29.Reg, volatile.LoadUint32(&o.P4_29.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_29_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_29.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_29_INV(value uint32) {
	volatile.StoreUint32(&o.P4_29.Reg, volatile.LoadUint32(&o.P4_29.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_29_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_29.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_29_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_29.Reg, volatile.LoadUint32(&o.P4_29.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_29_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_29.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_29_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_29.Reg, volatile.LoadUint32(&o.P4_29.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_29_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_29.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_29_OD(value uint32) {
	volatile.StoreUint32(&o.P4_29.Reg, volatile.LoadUint32(&o.P4_29.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_29_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_29.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_29_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_29.Reg, volatile.LoadUint32(&o.P4_29.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_29_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_29.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_30: I/O configuration register for pin P4[30]
func (o *IOCON_Type) SetP4_30_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_30.Reg, volatile.LoadUint32(&o.P4_30.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_30_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_30.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_30_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_30.Reg, volatile.LoadUint32(&o.P4_30.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_30_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_30.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_30_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_30.Reg, volatile.LoadUint32(&o.P4_30.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_30_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_30.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_30_INV(value uint32) {
	volatile.StoreUint32(&o.P4_30.Reg, volatile.LoadUint32(&o.P4_30.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_30_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_30.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_30_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_30.Reg, volatile.LoadUint32(&o.P4_30.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_30_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_30.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_30_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_30.Reg, volatile.LoadUint32(&o.P4_30.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_30_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_30.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_30_OD(value uint32) {
	volatile.StoreUint32(&o.P4_30.Reg, volatile.LoadUint32(&o.P4_30.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_30_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_30.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_30_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_30.Reg, volatile.LoadUint32(&o.P4_30.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_30_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_30.Reg) & 0xfffff800) >> 11
}

// IOCON.P4_31: I/O configuration register for pin P4[31]
func (o *IOCON_Type) SetP4_31_FUNC(value uint32) {
	volatile.StoreUint32(&o.P4_31.Reg, volatile.LoadUint32(&o.P4_31.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP4_31_FUNC() uint32 {
	return volatile.LoadUint32(&o.P4_31.Reg) & 0x7
}
func (o *IOCON_Type) SetP4_31_MODE(value uint32) {
	volatile.StoreUint32(&o.P4_31.Reg, volatile.LoadUint32(&o.P4_31.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP4_31_MODE() uint32 {
	return (volatile.LoadUint32(&o.P4_31.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP4_31_HYS(value uint32) {
	volatile.StoreUint32(&o.P4_31.Reg, volatile.LoadUint32(&o.P4_31.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP4_31_HYS() uint32 {
	return (volatile.LoadUint32(&o.P4_31.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP4_31_INV(value uint32) {
	volatile.StoreUint32(&o.P4_31.Reg, volatile.LoadUint32(&o.P4_31.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP4_31_INV() uint32 {
	return (volatile.LoadUint32(&o.P4_31.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP4_31_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_31.Reg, volatile.LoadUint32(&o.P4_31.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP4_31_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_31.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP4_31_SLEW(value uint32) {
	volatile.StoreUint32(&o.P4_31.Reg, volatile.LoadUint32(&o.P4_31.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP4_31_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P4_31.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP4_31_OD(value uint32) {
	volatile.StoreUint32(&o.P4_31.Reg, volatile.LoadUint32(&o.P4_31.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP4_31_OD() uint32 {
	return (volatile.LoadUint32(&o.P4_31.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP4_31_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P4_31.Reg, volatile.LoadUint32(&o.P4_31.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP4_31_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P4_31.Reg) & 0xfffff800) >> 11
}

// IOCON.P5_0: I/O configuration register for pin P5[0]
func (o *IOCON_Type) SetP5_0_FUNC(value uint32) {
	volatile.StoreUint32(&o.P5_0.Reg, volatile.LoadUint32(&o.P5_0.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP5_0_FUNC() uint32 {
	return volatile.LoadUint32(&o.P5_0.Reg) & 0x7
}
func (o *IOCON_Type) SetP5_0_MODE(value uint32) {
	volatile.StoreUint32(&o.P5_0.Reg, volatile.LoadUint32(&o.P5_0.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP5_0_MODE() uint32 {
	return (volatile.LoadUint32(&o.P5_0.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP5_0_HYS(value uint32) {
	volatile.StoreUint32(&o.P5_0.Reg, volatile.LoadUint32(&o.P5_0.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP5_0_HYS() uint32 {
	return (volatile.LoadUint32(&o.P5_0.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP5_0_INV(value uint32) {
	volatile.StoreUint32(&o.P5_0.Reg, volatile.LoadUint32(&o.P5_0.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP5_0_INV() uint32 {
	return (volatile.LoadUint32(&o.P5_0.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP5_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P5_0.Reg, volatile.LoadUint32(&o.P5_0.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP5_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P5_0.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP5_0_SLEW(value uint32) {
	volatile.StoreUint32(&o.P5_0.Reg, volatile.LoadUint32(&o.P5_0.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP5_0_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P5_0.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP5_0_OD(value uint32) {
	volatile.StoreUint32(&o.P5_0.Reg, volatile.LoadUint32(&o.P5_0.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP5_0_OD() uint32 {
	return (volatile.LoadUint32(&o.P5_0.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP5_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P5_0.Reg, volatile.LoadUint32(&o.P5_0.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP5_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P5_0.Reg) & 0xfffff800) >> 11
}

// IOCON.P5_1: I/O configuration register for pin P5[1]
func (o *IOCON_Type) SetP5_1_FUNC(value uint32) {
	volatile.StoreUint32(&o.P5_1.Reg, volatile.LoadUint32(&o.P5_1.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP5_1_FUNC() uint32 {
	return volatile.LoadUint32(&o.P5_1.Reg) & 0x7
}
func (o *IOCON_Type) SetP5_1_MODE(value uint32) {
	volatile.StoreUint32(&o.P5_1.Reg, volatile.LoadUint32(&o.P5_1.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP5_1_MODE() uint32 {
	return (volatile.LoadUint32(&o.P5_1.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP5_1_HYS(value uint32) {
	volatile.StoreUint32(&o.P5_1.Reg, volatile.LoadUint32(&o.P5_1.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP5_1_HYS() uint32 {
	return (volatile.LoadUint32(&o.P5_1.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP5_1_INV(value uint32) {
	volatile.StoreUint32(&o.P5_1.Reg, volatile.LoadUint32(&o.P5_1.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP5_1_INV() uint32 {
	return (volatile.LoadUint32(&o.P5_1.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP5_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P5_1.Reg, volatile.LoadUint32(&o.P5_1.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP5_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P5_1.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP5_1_SLEW(value uint32) {
	volatile.StoreUint32(&o.P5_1.Reg, volatile.LoadUint32(&o.P5_1.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP5_1_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P5_1.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP5_1_OD(value uint32) {
	volatile.StoreUint32(&o.P5_1.Reg, volatile.LoadUint32(&o.P5_1.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP5_1_OD() uint32 {
	return (volatile.LoadUint32(&o.P5_1.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP5_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P5_1.Reg, volatile.LoadUint32(&o.P5_1.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP5_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P5_1.Reg) & 0xfffff800) >> 11
}

// IOCON.P5_2: I/O configuration register for pin P5[2]
func (o *IOCON_Type) SetP5_2_FUNC(value uint32) {
	volatile.StoreUint32(&o.P5_2.Reg, volatile.LoadUint32(&o.P5_2.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP5_2_FUNC() uint32 {
	return volatile.LoadUint32(&o.P5_2.Reg) & 0x7
}
func (o *IOCON_Type) SetP5_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P5_2.Reg, volatile.LoadUint32(&o.P5_2.Reg)&^(0x38)|value<<3)
}
func (o *IOCON_Type) GetP5_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P5_2.Reg) & 0x38) >> 3
}
func (o *IOCON_Type) SetP5_2_INV(value uint32) {
	volatile.StoreUint32(&o.P5_2.Reg, volatile.LoadUint32(&o.P5_2.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP5_2_INV() uint32 {
	return (volatile.LoadUint32(&o.P5_2.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP5_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P5_2.Reg, volatile.LoadUint32(&o.P5_2.Reg)&^(0x80)|value<<7)
}
func (o *IOCON_Type) GetP5_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P5_2.Reg) & 0x80) >> 7
}
func (o *IOCON_Type) SetP5_2_HS(value uint32) {
	volatile.StoreUint32(&o.P5_2.Reg, volatile.LoadUint32(&o.P5_2.Reg)&^(0x100)|value<<8)
}
func (o *IOCON_Type) GetP5_2_HS() uint32 {
	return (volatile.LoadUint32(&o.P5_2.Reg) & 0x100) >> 8
}
func (o *IOCON_Type) SetP5_2_HIDRIVE(value uint32) {
	volatile.StoreUint32(&o.P5_2.Reg, volatile.LoadUint32(&o.P5_2.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP5_2_HIDRIVE() uint32 {
	return (volatile.LoadUint32(&o.P5_2.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP5_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P5_2.Reg, volatile.LoadUint32(&o.P5_2.Reg)&^(0xfffffc00)|value<<10)
}
func (o *IOCON_Type) GetP5_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P5_2.Reg) & 0xfffffc00) >> 10
}

// IOCON.P5_3: I/O configuration register for pin P5[3]
func (o *IOCON_Type) SetP5_3_FUNC(value uint32) {
	volatile.StoreUint32(&o.P5_3.Reg, volatile.LoadUint32(&o.P5_3.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP5_3_FUNC() uint32 {
	return volatile.LoadUint32(&o.P5_3.Reg) & 0x7
}
func (o *IOCON_Type) SetP5_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P5_3.Reg, volatile.LoadUint32(&o.P5_3.Reg)&^(0x38)|value<<3)
}
func (o *IOCON_Type) GetP5_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P5_3.Reg) & 0x38) >> 3
}
func (o *IOCON_Type) SetP5_3_INV(value uint32) {
	volatile.StoreUint32(&o.P5_3.Reg, volatile.LoadUint32(&o.P5_3.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP5_3_INV() uint32 {
	return (volatile.LoadUint32(&o.P5_3.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP5_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P5_3.Reg, volatile.LoadUint32(&o.P5_3.Reg)&^(0x80)|value<<7)
}
func (o *IOCON_Type) GetP5_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P5_3.Reg) & 0x80) >> 7
}
func (o *IOCON_Type) SetP5_3_HS(value uint32) {
	volatile.StoreUint32(&o.P5_3.Reg, volatile.LoadUint32(&o.P5_3.Reg)&^(0x100)|value<<8)
}
func (o *IOCON_Type) GetP5_3_HS() uint32 {
	return (volatile.LoadUint32(&o.P5_3.Reg) & 0x100) >> 8
}
func (o *IOCON_Type) SetP5_3_HIDRIVE(value uint32) {
	volatile.StoreUint32(&o.P5_3.Reg, volatile.LoadUint32(&o.P5_3.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP5_3_HIDRIVE() uint32 {
	return (volatile.LoadUint32(&o.P5_3.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP5_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P5_3.Reg, volatile.LoadUint32(&o.P5_3.Reg)&^(0xfffffc00)|value<<10)
}
func (o *IOCON_Type) GetP5_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P5_3.Reg) & 0xfffffc00) >> 10
}

// IOCON.P5_4: I/O configuration register for pin P5[4]
func (o *IOCON_Type) SetP5_4_FUNC(value uint32) {
	volatile.StoreUint32(&o.P5_4.Reg, volatile.LoadUint32(&o.P5_4.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetP5_4_FUNC() uint32 {
	return volatile.LoadUint32(&o.P5_4.Reg) & 0x7
}
func (o *IOCON_Type) SetP5_4_MODE(value uint32) {
	volatile.StoreUint32(&o.P5_4.Reg, volatile.LoadUint32(&o.P5_4.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetP5_4_MODE() uint32 {
	return (volatile.LoadUint32(&o.P5_4.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetP5_4_HYS(value uint32) {
	volatile.StoreUint32(&o.P5_4.Reg, volatile.LoadUint32(&o.P5_4.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetP5_4_HYS() uint32 {
	return (volatile.LoadUint32(&o.P5_4.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetP5_4_INV(value uint32) {
	volatile.StoreUint32(&o.P5_4.Reg, volatile.LoadUint32(&o.P5_4.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetP5_4_INV() uint32 {
	return (volatile.LoadUint32(&o.P5_4.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetP5_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P5_4.Reg, volatile.LoadUint32(&o.P5_4.Reg)&^(0x180)|value<<7)
}
func (o *IOCON_Type) GetP5_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P5_4.Reg) & 0x180) >> 7
}
func (o *IOCON_Type) SetP5_4_SLEW(value uint32) {
	volatile.StoreUint32(&o.P5_4.Reg, volatile.LoadUint32(&o.P5_4.Reg)&^(0x200)|value<<9)
}
func (o *IOCON_Type) GetP5_4_SLEW() uint32 {
	return (volatile.LoadUint32(&o.P5_4.Reg) & 0x200) >> 9
}
func (o *IOCON_Type) SetP5_4_OD(value uint32) {
	volatile.StoreUint32(&o.P5_4.Reg, volatile.LoadUint32(&o.P5_4.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetP5_4_OD() uint32 {
	return (volatile.LoadUint32(&o.P5_4.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetP5_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.P5_4.Reg, volatile.LoadUint32(&o.P5_4.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetP5_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.P5_4.Reg) & 0xfffff800) >> 11
}

// SSP1 controller
type SSP1_Type struct {
	CR0   volatile.Register32 // 0x0
	CR1   volatile.Register32 // 0x4
	DR    volatile.Register32 // 0x8
	SR    volatile.Register32 // 0xC
	CPSR  volatile.Register32 // 0x10
	IMSC  volatile.Register32 // 0x14
	RIS   volatile.Register32 // 0x18
	MIS   volatile.Register32 // 0x1C
	ICR   volatile.Register32 // 0x20
	DMACR volatile.Register32 // 0x24
}

// SSP1.CR0: Control Register 0. Selects the serial clock rate, bus type, and data size.
func (o *SSP1_Type) SetCR0_DSS(value uint32) {
	volatile.StoreUint32(&o.CR0.Reg, volatile.LoadUint32(&o.CR0.Reg)&^(0xf)|value)
}
func (o *SSP1_Type) GetCR0_DSS() uint32 {
	return volatile.LoadUint32(&o.CR0.Reg) & 0xf
}
func (o *SSP1_Type) SetCR0_FRF(value uint32) {
	volatile.StoreUint32(&o.CR0.Reg, volatile.LoadUint32(&o.CR0.Reg)&^(0x30)|value<<4)
}
func (o *SSP1_Type) GetCR0_FRF() uint32 {
	return (volatile.LoadUint32(&o.CR0.Reg) & 0x30) >> 4
}
func (o *SSP1_Type) SetCR0_CPOL(value uint32) {
	volatile.StoreUint32(&o.CR0.Reg, volatile.LoadUint32(&o.CR0.Reg)&^(0x40)|value<<6)
}
func (o *SSP1_Type) GetCR0_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CR0.Reg) & 0x40) >> 6
}
func (o *SSP1_Type) SetCR0_CPHA(value uint32) {
	volatile.StoreUint32(&o.CR0.Reg, volatile.LoadUint32(&o.CR0.Reg)&^(0x80)|value<<7)
}
func (o *SSP1_Type) GetCR0_CPHA() uint32 {
	return (volatile.LoadUint32(&o.CR0.Reg) & 0x80) >> 7
}
func (o *SSP1_Type) SetCR0_SCR(value uint32) {
	volatile.StoreUint32(&o.CR0.Reg, volatile.LoadUint32(&o.CR0.Reg)&^(0xff00)|value<<8)
}
func (o *SSP1_Type) GetCR0_SCR() uint32 {
	return (volatile.LoadUint32(&o.CR0.Reg) & 0xff00) >> 8
}
func (o *SSP1_Type) SetCR0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CR0.Reg, volatile.LoadUint32(&o.CR0.Reg)&^(0xffff0000)|value<<16)
}
func (o *SSP1_Type) GetCR0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CR0.Reg) & 0xffff0000) >> 16
}

// SSP1.CR1: Control Register 1. Selects master/slave and other modes.
func (o *SSP1_Type) SetCR1_LBM(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *SSP1_Type) GetCR1_LBM() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}
func (o *SSP1_Type) SetCR1_SSE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *SSP1_Type) GetCR1_SSE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2) >> 1
}
func (o *SSP1_Type) SetCR1_MS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4)|value<<2)
}
func (o *SSP1_Type) GetCR1_MS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4) >> 2
}
func (o *SSP1_Type) SetCR1_SOD(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8)|value<<3)
}
func (o *SSP1_Type) GetCR1_SOD() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8) >> 3
}
func (o *SSP1_Type) SetCR1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0xfffffff0)|value<<4)
}
func (o *SSP1_Type) GetCR1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0xfffffff0) >> 4
}

// SSP1.DR: Data Register. Writes fill the transmit FIFO, and reads empty the receive FIFO.
func (o *SSP1_Type) SetDR_DATA(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xffff)|value)
}
func (o *SSP1_Type) GetDR_DATA() uint32 {
	return volatile.LoadUint32(&o.DR.Reg) & 0xffff
}
func (o *SSP1_Type) SetDR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SSP1_Type) GetDR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xffff0000) >> 16
}

// SSP1.SR: Status Register
func (o *SSP1_Type) SetSR_TFE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *SSP1_Type) GetSR_TFE() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *SSP1_Type) SetSR_TNF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *SSP1_Type) GetSR_TNF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *SSP1_Type) SetSR_RNE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *SSP1_Type) GetSR_RNE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *SSP1_Type) SetSR_RFF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *SSP1_Type) GetSR_RFF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *SSP1_Type) SetSR_BSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *SSP1_Type) GetSR_BSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *SSP1_Type) SetSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SSP1_Type) GetSR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0xffffffe0) >> 5
}

// SSP1.CPSR: Clock Prescale Register
func (o *SSP1_Type) SetCPSR_CPSDVSR(value uint32) {
	volatile.StoreUint32(&o.CPSR.Reg, volatile.LoadUint32(&o.CPSR.Reg)&^(0xff)|value)
}
func (o *SSP1_Type) GetCPSR_CPSDVSR() uint32 {
	return volatile.LoadUint32(&o.CPSR.Reg) & 0xff
}
func (o *SSP1_Type) SetCPSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CPSR.Reg, volatile.LoadUint32(&o.CPSR.Reg)&^(0xffffff00)|value<<8)
}
func (o *SSP1_Type) GetCPSR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CPSR.Reg) & 0xffffff00) >> 8
}

// SSP1.IMSC: Interrupt Mask Set and Clear Register
func (o *SSP1_Type) SetIMSC_RORIM(value uint32) {
	volatile.StoreUint32(&o.IMSC.Reg, volatile.LoadUint32(&o.IMSC.Reg)&^(0x1)|value)
}
func (o *SSP1_Type) GetIMSC_RORIM() uint32 {
	return volatile.LoadUint32(&o.IMSC.Reg) & 0x1
}
func (o *SSP1_Type) SetIMSC_RTIM(value uint32) {
	volatile.StoreUint32(&o.IMSC.Reg, volatile.LoadUint32(&o.IMSC.Reg)&^(0x2)|value<<1)
}
func (o *SSP1_Type) GetIMSC_RTIM() uint32 {
	return (volatile.LoadUint32(&o.IMSC.Reg) & 0x2) >> 1
}
func (o *SSP1_Type) SetIMSC_RXIM(value uint32) {
	volatile.StoreUint32(&o.IMSC.Reg, volatile.LoadUint32(&o.IMSC.Reg)&^(0x4)|value<<2)
}
func (o *SSP1_Type) GetIMSC_RXIM() uint32 {
	return (volatile.LoadUint32(&o.IMSC.Reg) & 0x4) >> 2
}
func (o *SSP1_Type) SetIMSC_TXIM(value uint32) {
	volatile.StoreUint32(&o.IMSC.Reg, volatile.LoadUint32(&o.IMSC.Reg)&^(0x8)|value<<3)
}
func (o *SSP1_Type) GetIMSC_TXIM() uint32 {
	return (volatile.LoadUint32(&o.IMSC.Reg) & 0x8) >> 3
}
func (o *SSP1_Type) SetIMSC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IMSC.Reg, volatile.LoadUint32(&o.IMSC.Reg)&^(0xfffffff0)|value<<4)
}
func (o *SSP1_Type) GetIMSC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IMSC.Reg) & 0xfffffff0) >> 4
}

// SSP1.RIS: Raw Interrupt Status Register
func (o *SSP1_Type) SetRIS_RORRIS(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x1)|value)
}
func (o *SSP1_Type) GetRIS_RORRIS() uint32 {
	return volatile.LoadUint32(&o.RIS.Reg) & 0x1
}
func (o *SSP1_Type) SetRIS_RTRIS(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x2)|value<<1)
}
func (o *SSP1_Type) GetRIS_RTRIS() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x2) >> 1
}
func (o *SSP1_Type) SetRIS_RXRIS(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x4)|value<<2)
}
func (o *SSP1_Type) GetRIS_RXRIS() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x4) >> 2
}
func (o *SSP1_Type) SetRIS_TXRIS(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x8)|value<<3)
}
func (o *SSP1_Type) GetRIS_TXRIS() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x8) >> 3
}
func (o *SSP1_Type) SetRIS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0xfffffff0)|value<<4)
}
func (o *SSP1_Type) GetRIS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0xfffffff0) >> 4
}

// SSP1.MIS: Masked Interrupt Status Register
func (o *SSP1_Type) SetMIS_RORMIS(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x1)|value)
}
func (o *SSP1_Type) GetMIS_RORMIS() uint32 {
	return volatile.LoadUint32(&o.MIS.Reg) & 0x1
}
func (o *SSP1_Type) SetMIS_RTMIS(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x2)|value<<1)
}
func (o *SSP1_Type) GetMIS_RTMIS() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x2) >> 1
}
func (o *SSP1_Type) SetMIS_RXMIS(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x4)|value<<2)
}
func (o *SSP1_Type) GetMIS_RXMIS() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x4) >> 2
}
func (o *SSP1_Type) SetMIS_TXMIS(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x8)|value<<3)
}
func (o *SSP1_Type) GetMIS_TXMIS() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x8) >> 3
}
func (o *SSP1_Type) SetMIS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0xfffffff0)|value<<4)
}
func (o *SSP1_Type) GetMIS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0xfffffff0) >> 4
}

// SSP1.ICR: SSPICR Interrupt Clear Register
func (o *SSP1_Type) SetICR_RORIC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *SSP1_Type) GetICR_RORIC() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}
func (o *SSP1_Type) SetICR_RTIC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *SSP1_Type) GetICR_RTIC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *SSP1_Type) SetICR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *SSP1_Type) GetICR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0xfffffffc) >> 2
}

// SSP1.DMACR: SSP0 DMA control register
func (o *SSP1_Type) SetDMACR_RXDMAE(value uint32) {
	volatile.StoreUint32(&o.DMACR.Reg, volatile.LoadUint32(&o.DMACR.Reg)&^(0x1)|value)
}
func (o *SSP1_Type) GetDMACR_RXDMAE() uint32 {
	return volatile.LoadUint32(&o.DMACR.Reg) & 0x1
}
func (o *SSP1_Type) SetDMACR_TXDMAE(value uint32) {
	volatile.StoreUint32(&o.DMACR.Reg, volatile.LoadUint32(&o.DMACR.Reg)&^(0x2)|value<<1)
}
func (o *SSP1_Type) GetDMACR_TXDMAE() uint32 {
	return (volatile.LoadUint32(&o.DMACR.Reg) & 0x2) >> 1
}
func (o *SSP1_Type) SetDMACR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMACR.Reg, volatile.LoadUint32(&o.DMACR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *SSP1_Type) GetDMACR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMACR.Reg) & 0xfffffffc) >> 2
}

// Analog-to-Digital Converter (ADC)
type ADC_Type struct {
	CR    volatile.Register32 // 0x0
	GDR   volatile.Register32 // 0x4
	_     [4]byte
	INTEN volatile.Register32    // 0xC
	DR    [8]volatile.Register32 // 0x10
	STAT  volatile.Register32    // 0x30
	TRM   volatile.Register32    // 0x34
}

// ADC.CR: A/D Control Register. The ADCR register must be written to select the operating mode before A/D conversion can occur.
func (o *ADC_Type) SetCR_SEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xff)|value)
}
func (o *ADC_Type) GetCR_SEL() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0xff
}
func (o *ADC_Type) SetCR_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xff00)|value<<8)
}
func (o *ADC_Type) GetCR_CLKDIV() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xff00) >> 8
}
func (o *ADC_Type) SetCR_BURST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *ADC_Type) GetCR_BURST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *ADC_Type) SetCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1e0000)|value<<17)
}
func (o *ADC_Type) GetCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1e0000) >> 17
}
func (o *ADC_Type) SetCR_PDN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200000)|value<<21)
}
func (o *ADC_Type) GetCR_PDN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200000) >> 21
}
func (o *ADC_Type) SetCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc00000)|value<<22)
}
func (o *ADC_Type) GetCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc00000) >> 22
}
func (o *ADC_Type) SetCR_START(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x7000000)|value<<24)
}
func (o *ADC_Type) GetCR_START() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x7000000) >> 24
}
func (o *ADC_Type) SetCR_EDGE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000000)|value<<27)
}
func (o *ADC_Type) GetCR_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000000) >> 27
}
func (o *ADC_Type) SetCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xf0000000)|value<<28)
}
func (o *ADC_Type) GetCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xf0000000) >> 28
}

// ADC.GDR: A/D Global Data Register. This register contains the ADC's DONE bit and the result of the most recent A/D conversion.
func (o *ADC_Type) SetGDR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.GDR.Reg, volatile.LoadUint32(&o.GDR.Reg)&^(0xf)|value)
}
func (o *ADC_Type) GetGDR_RESERVED() uint32 {
	return volatile.LoadUint32(&o.GDR.Reg) & 0xf
}
func (o *ADC_Type) SetGDR_RESULT(value uint32) {
	volatile.StoreUint32(&o.GDR.Reg, volatile.LoadUint32(&o.GDR.Reg)&^(0xfff0)|value<<4)
}
func (o *ADC_Type) GetGDR_RESULT() uint32 {
	return (volatile.LoadUint32(&o.GDR.Reg) & 0xfff0) >> 4
}
func (o *ADC_Type) SetGDR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.GDR.Reg, volatile.LoadUint32(&o.GDR.Reg)&^(0xff0000)|value<<16)
}
func (o *ADC_Type) GetGDR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.GDR.Reg) & 0xff0000) >> 16
}
func (o *ADC_Type) SetGDR_CHN(value uint32) {
	volatile.StoreUint32(&o.GDR.Reg, volatile.LoadUint32(&o.GDR.Reg)&^(0x7000000)|value<<24)
}
func (o *ADC_Type) GetGDR_CHN() uint32 {
	return (volatile.LoadUint32(&o.GDR.Reg) & 0x7000000) >> 24
}
func (o *ADC_Type) SetGDR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.GDR.Reg, volatile.LoadUint32(&o.GDR.Reg)&^(0x38000000)|value<<27)
}
func (o *ADC_Type) GetGDR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.GDR.Reg) & 0x38000000) >> 27
}
func (o *ADC_Type) SetGDR_OVERRUN(value uint32) {
	volatile.StoreUint32(&o.GDR.Reg, volatile.LoadUint32(&o.GDR.Reg)&^(0x40000000)|value<<30)
}
func (o *ADC_Type) GetGDR_OVERRUN() uint32 {
	return (volatile.LoadUint32(&o.GDR.Reg) & 0x40000000) >> 30
}
func (o *ADC_Type) SetGDR_DONE(value uint32) {
	volatile.StoreUint32(&o.GDR.Reg, volatile.LoadUint32(&o.GDR.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetGDR_DONE() uint32 {
	return (volatile.LoadUint32(&o.GDR.Reg) & 0x80000000) >> 31
}

// ADC.INTEN: A/D Interrupt Enable Register. This register contains enable bits that allow the DONE flag of each A/D channel to be included or excluded from contributing to the generation of an A/D interrupt.
func (o *ADC_Type) SetINTEN_ADINTEN0(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetINTEN_ADINTEN0() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *ADC_Type) SetINTEN_ADINTEN1(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetINTEN_ADINTEN1() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetINTEN_ADINTEN2(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetINTEN_ADINTEN2() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetINTEN_ADINTEN3(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetINTEN_ADINTEN3() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetINTEN_ADINTEN4(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetINTEN_ADINTEN4() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetINTEN_ADINTEN5(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetINTEN_ADINTEN5() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetINTEN_ADINTEN6(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetINTEN_ADINTEN6() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetINTEN_ADINTEN7(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetINTEN_ADINTEN7() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetINTEN_ADGINTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetINTEN_ADGINTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetINTEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0xfffffe00)|value<<9)
}
func (o *ADC_Type) GetINTEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0xfffffe00) >> 9
}

// ADC.DR: A/D Channel 0 Data Register. This register contains the result of the most recent conversion completed on channel 0.
func (o *ADC_Type) SetDR_RESERVED(idx int, value uint32) {
	volatile.StoreUint32(&o.DR[idx].Reg, volatile.LoadUint32(&o.DR[idx].Reg)&^(0xf)|value)
}
func (o *ADC_Type) GetDR_RESERVED(idx int) uint32 {
	return volatile.LoadUint32(&o.DR[idx].Reg) & 0xf
}
func (o *ADC_Type) SetDR_RESULT(idx int, value uint32) {
	volatile.StoreUint32(&o.DR[idx].Reg, volatile.LoadUint32(&o.DR[idx].Reg)&^(0xfff0)|value<<4)
}
func (o *ADC_Type) GetDR_RESULT(idx int) uint32 {
	return (volatile.LoadUint32(&o.DR[idx].Reg) & 0xfff0) >> 4
}
func (o *ADC_Type) SetDR_RESERVED(idx int, value uint32) {
	volatile.StoreUint32(&o.DR[idx].Reg, volatile.LoadUint32(&o.DR[idx].Reg)&^(0x3fff0000)|value<<16)
}
func (o *ADC_Type) GetDR_RESERVED(idx int) uint32 {
	return (volatile.LoadUint32(&o.DR[idx].Reg) & 0x3fff0000) >> 16
}
func (o *ADC_Type) SetDR_OVERRUN(idx int, value uint32) {
	volatile.StoreUint32(&o.DR[idx].Reg, volatile.LoadUint32(&o.DR[idx].Reg)&^(0x40000000)|value<<30)
}
func (o *ADC_Type) GetDR_OVERRUN(idx int) uint32 {
	return (volatile.LoadUint32(&o.DR[idx].Reg) & 0x40000000) >> 30
}
func (o *ADC_Type) SetDR_DONE(idx int, value uint32) {
	volatile.StoreUint32(&o.DR[idx].Reg, volatile.LoadUint32(&o.DR[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetDR_DONE(idx int) uint32 {
	return (volatile.LoadUint32(&o.DR[idx].Reg) & 0x80000000) >> 31
}

// ADC.STAT: A/D Status Register. This register contains DONE and OVERRUN flags for all of the A/D channels, as well as the A/D interrupt/DMA flag.
func (o *ADC_Type) SetSTAT_DONE0(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetSTAT_DONE0() uint32 {
	return volatile.LoadUint32(&o.STAT.Reg) & 0x1
}
func (o *ADC_Type) SetSTAT_DONE1(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetSTAT_DONE1() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetSTAT_DONE2(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetSTAT_DONE2() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetSTAT_DONE3(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetSTAT_DONE3() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetSTAT_DONE4(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetSTAT_DONE4() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetSTAT_DONE5(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetSTAT_DONE5() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetSTAT_DONE6(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetSTAT_DONE6() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetSTAT_DONE7(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetSTAT_DONE7() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetSTAT_OVERRUN0(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetSTAT_OVERRUN0() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetSTAT_OVERRUN1(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x200)|value<<9)
}
func (o *ADC_Type) GetSTAT_OVERRUN1() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x200) >> 9
}
func (o *ADC_Type) SetSTAT_OVERRUN2(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetSTAT_OVERRUN2() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetSTAT_OVERRUN3(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x800)|value<<11)
}
func (o *ADC_Type) GetSTAT_OVERRUN3() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x800) >> 11
}
func (o *ADC_Type) SetSTAT_OVERRUN4(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_Type) GetSTAT_OVERRUN4() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x1000) >> 12
}
func (o *ADC_Type) SetSTAT_OVERRUN5(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x2000)|value<<13)
}
func (o *ADC_Type) GetSTAT_OVERRUN5() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x2000) >> 13
}
func (o *ADC_Type) SetSTAT_OVERRUN6(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x4000)|value<<14)
}
func (o *ADC_Type) GetSTAT_OVERRUN6() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x4000) >> 14
}
func (o *ADC_Type) SetSTAT_OVERRUN7(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x8000)|value<<15)
}
func (o *ADC_Type) GetSTAT_OVERRUN7() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x8000) >> 15
}
func (o *ADC_Type) SetSTAT_ADINT(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x10000)|value<<16)
}
func (o *ADC_Type) GetSTAT_ADINT() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x10000) >> 16
}
func (o *ADC_Type) SetSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0xfffe0000)|value<<17)
}
func (o *ADC_Type) GetSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0xfffe0000) >> 17
}

// ADC.TRM: ADC trim register.
func (o *ADC_Type) SetTRM_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TRM.Reg, volatile.LoadUint32(&o.TRM.Reg)&^(0xf)|value)
}
func (o *ADC_Type) GetTRM_RESERVED() uint32 {
	return volatile.LoadUint32(&o.TRM.Reg) & 0xf
}
func (o *ADC_Type) SetTRM_ADCOFFS(value uint32) {
	volatile.StoreUint32(&o.TRM.Reg, volatile.LoadUint32(&o.TRM.Reg)&^(0xf0)|value<<4)
}
func (o *ADC_Type) GetTRM_ADCOFFS() uint32 {
	return (volatile.LoadUint32(&o.TRM.Reg) & 0xf0) >> 4
}
func (o *ADC_Type) SetTRM_TRIM(value uint32) {
	volatile.StoreUint32(&o.TRM.Reg, volatile.LoadUint32(&o.TRM.Reg)&^(0xf00)|value<<8)
}
func (o *ADC_Type) GetTRM_TRIM() uint32 {
	return (volatile.LoadUint32(&o.TRM.Reg) & 0xf00) >> 8
}
func (o *ADC_Type) SetTRM_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TRM.Reg, volatile.LoadUint32(&o.TRM.Reg)&^(0xfffff000)|value<<12)
}
func (o *ADC_Type) GetTRM_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TRM.Reg) & 0xfffff000) >> 12
}

// CAN acceptance filter RAM
type CANAFRAM_Type struct {
	MASK [512]volatile.Register32 // 0x0
}

// CANAFRAM.MASK: CAN AF ram access register
func (o *CANAFRAM_Type) SetMASK(idx int, value uint32) {
	volatile.StoreUint32(&o.MASK[idx].Reg, value)
}
func (o *CANAFRAM_Type) GetMASK(idx int) uint32 {
	return volatile.LoadUint32(&o.MASK[idx].Reg)
}

// CAN controller
type CANAF_Type struct {
	AFMR       volatile.Register32 // 0x0
	SFF_SA     volatile.Register32 // 0x4
	SFF_GRP_SA volatile.Register32 // 0x8
	EFF_SA     volatile.Register32 // 0xC
	EFF_GRP_SA volatile.Register32 // 0x10
	ENDOFTABLE volatile.Register32 // 0x14
	LUTERRAD   volatile.Register32 // 0x18
	LUTERR     volatile.Register32 // 0x1C
	FCANIE     volatile.Register32 // 0x20
	FCANIC0    volatile.Register32 // 0x24
	FCANIC1    volatile.Register32 // 0x28
}

// CANAF.AFMR: Acceptance Filter Register
func (o *CANAF_Type) SetAFMR_ACCOFF(value uint32) {
	volatile.StoreUint32(&o.AFMR.Reg, volatile.LoadUint32(&o.AFMR.Reg)&^(0x1)|value)
}
func (o *CANAF_Type) GetAFMR_ACCOFF() uint32 {
	return volatile.LoadUint32(&o.AFMR.Reg) & 0x1
}
func (o *CANAF_Type) SetAFMR_ACCBP(value uint32) {
	volatile.StoreUint32(&o.AFMR.Reg, volatile.LoadUint32(&o.AFMR.Reg)&^(0x2)|value<<1)
}
func (o *CANAF_Type) GetAFMR_ACCBP() uint32 {
	return (volatile.LoadUint32(&o.AFMR.Reg) & 0x2) >> 1
}
func (o *CANAF_Type) SetAFMR_EFCAN(value uint32) {
	volatile.StoreUint32(&o.AFMR.Reg, volatile.LoadUint32(&o.AFMR.Reg)&^(0x4)|value<<2)
}
func (o *CANAF_Type) GetAFMR_EFCAN() uint32 {
	return (volatile.LoadUint32(&o.AFMR.Reg) & 0x4) >> 2
}
func (o *CANAF_Type) SetAFMR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.AFMR.Reg, volatile.LoadUint32(&o.AFMR.Reg)&^(0xfffffff8)|value<<3)
}
func (o *CANAF_Type) GetAFMR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.AFMR.Reg) & 0xfffffff8) >> 3
}

// CANAF.SFF_SA: Standard Frame Individual Start Address Register
func (o *CANAF_Type) SetSFF_SA_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFF_SA.Reg, volatile.LoadUint32(&o.SFF_SA.Reg)&^(0x3)|value)
}
func (o *CANAF_Type) GetSFF_SA_RESERVED() uint32 {
	return volatile.LoadUint32(&o.SFF_SA.Reg) & 0x3
}
func (o *CANAF_Type) SetSFF_SA(value uint32) {
	volatile.StoreUint32(&o.SFF_SA.Reg, volatile.LoadUint32(&o.SFF_SA.Reg)&^(0x7fc)|value<<2)
}
func (o *CANAF_Type) GetSFF_SA() uint32 {
	return (volatile.LoadUint32(&o.SFF_SA.Reg) & 0x7fc) >> 2
}
func (o *CANAF_Type) SetSFF_SA_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFF_SA.Reg, volatile.LoadUint32(&o.SFF_SA.Reg)&^(0xfffff800)|value<<11)
}
func (o *CANAF_Type) GetSFF_SA_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFF_SA.Reg) & 0xfffff800) >> 11
}

// CANAF.SFF_GRP_SA: Standard Frame Group Start Address Register
func (o *CANAF_Type) SetSFF_GRP_SA_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFF_GRP_SA.Reg, volatile.LoadUint32(&o.SFF_GRP_SA.Reg)&^(0x3)|value)
}
func (o *CANAF_Type) GetSFF_GRP_SA_RESERVED() uint32 {
	return volatile.LoadUint32(&o.SFF_GRP_SA.Reg) & 0x3
}
func (o *CANAF_Type) SetSFF_GRP_SA(value uint32) {
	volatile.StoreUint32(&o.SFF_GRP_SA.Reg, volatile.LoadUint32(&o.SFF_GRP_SA.Reg)&^(0xffc)|value<<2)
}
func (o *CANAF_Type) GetSFF_GRP_SA() uint32 {
	return (volatile.LoadUint32(&o.SFF_GRP_SA.Reg) & 0xffc) >> 2
}
func (o *CANAF_Type) SetSFF_GRP_SA_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SFF_GRP_SA.Reg, volatile.LoadUint32(&o.SFF_GRP_SA.Reg)&^(0xfffff000)|value<<12)
}
func (o *CANAF_Type) GetSFF_GRP_SA_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SFF_GRP_SA.Reg) & 0xfffff000) >> 12
}

// CANAF.EFF_SA: Extended Frame Start Address Register
func (o *CANAF_Type) SetEFF_SA_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EFF_SA.Reg, volatile.LoadUint32(&o.EFF_SA.Reg)&^(0x3)|value)
}
func (o *CANAF_Type) GetEFF_SA_RESERVED() uint32 {
	return volatile.LoadUint32(&o.EFF_SA.Reg) & 0x3
}
func (o *CANAF_Type) SetEFF_SA(value uint32) {
	volatile.StoreUint32(&o.EFF_SA.Reg, volatile.LoadUint32(&o.EFF_SA.Reg)&^(0x7fc)|value<<2)
}
func (o *CANAF_Type) GetEFF_SA() uint32 {
	return (volatile.LoadUint32(&o.EFF_SA.Reg) & 0x7fc) >> 2
}
func (o *CANAF_Type) SetEFF_SA_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EFF_SA.Reg, volatile.LoadUint32(&o.EFF_SA.Reg)&^(0xfffff800)|value<<11)
}
func (o *CANAF_Type) GetEFF_SA_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EFF_SA.Reg) & 0xfffff800) >> 11
}

// CANAF.EFF_GRP_SA: Extended Frame Group Start Address Register
func (o *CANAF_Type) SetEFF_GRP_SA_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EFF_GRP_SA.Reg, volatile.LoadUint32(&o.EFF_GRP_SA.Reg)&^(0x3)|value)
}
func (o *CANAF_Type) GetEFF_GRP_SA_RESERVED() uint32 {
	return volatile.LoadUint32(&o.EFF_GRP_SA.Reg) & 0x3
}
func (o *CANAF_Type) SetEFF_GRP_SA(value uint32) {
	volatile.StoreUint32(&o.EFF_GRP_SA.Reg, volatile.LoadUint32(&o.EFF_GRP_SA.Reg)&^(0xffc)|value<<2)
}
func (o *CANAF_Type) GetEFF_GRP_SA() uint32 {
	return (volatile.LoadUint32(&o.EFF_GRP_SA.Reg) & 0xffc) >> 2
}
func (o *CANAF_Type) SetEFF_GRP_SA_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EFF_GRP_SA.Reg, volatile.LoadUint32(&o.EFF_GRP_SA.Reg)&^(0xfffff000)|value<<12)
}
func (o *CANAF_Type) GetEFF_GRP_SA_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EFF_GRP_SA.Reg) & 0xfffff000) >> 12
}

// CANAF.ENDOFTABLE: End of AF Tables register
func (o *CANAF_Type) SetENDOFTABLE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDOFTABLE.Reg, volatile.LoadUint32(&o.ENDOFTABLE.Reg)&^(0x3)|value)
}
func (o *CANAF_Type) GetENDOFTABLE_RESERVED() uint32 {
	return volatile.LoadUint32(&o.ENDOFTABLE.Reg) & 0x3
}
func (o *CANAF_Type) SetENDOFTABLE(value uint32) {
	volatile.StoreUint32(&o.ENDOFTABLE.Reg, volatile.LoadUint32(&o.ENDOFTABLE.Reg)&^(0xffc)|value<<2)
}
func (o *CANAF_Type) GetENDOFTABLE() uint32 {
	return (volatile.LoadUint32(&o.ENDOFTABLE.Reg) & 0xffc) >> 2
}
func (o *CANAF_Type) SetENDOFTABLE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ENDOFTABLE.Reg, volatile.LoadUint32(&o.ENDOFTABLE.Reg)&^(0xfffff000)|value<<12)
}
func (o *CANAF_Type) GetENDOFTABLE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ENDOFTABLE.Reg) & 0xfffff000) >> 12
}

// CANAF.LUTERRAD: LUT Error Address register
func (o *CANAF_Type) SetLUTERRAD_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LUTERRAD.Reg, volatile.LoadUint32(&o.LUTERRAD.Reg)&^(0x3)|value)
}
func (o *CANAF_Type) GetLUTERRAD_RESERVED() uint32 {
	return volatile.LoadUint32(&o.LUTERRAD.Reg) & 0x3
}
func (o *CANAF_Type) SetLUTERRAD(value uint32) {
	volatile.StoreUint32(&o.LUTERRAD.Reg, volatile.LoadUint32(&o.LUTERRAD.Reg)&^(0x7fc)|value<<2)
}
func (o *CANAF_Type) GetLUTERRAD() uint32 {
	return (volatile.LoadUint32(&o.LUTERRAD.Reg) & 0x7fc) >> 2
}
func (o *CANAF_Type) SetLUTERRAD_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LUTERRAD.Reg, volatile.LoadUint32(&o.LUTERRAD.Reg)&^(0xfffff800)|value<<11)
}
func (o *CANAF_Type) GetLUTERRAD_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.LUTERRAD.Reg) & 0xfffff800) >> 11
}

// CANAF.LUTERR: LUT Error Register
func (o *CANAF_Type) SetLUTERR(value uint32) {
	volatile.StoreUint32(&o.LUTERR.Reg, volatile.LoadUint32(&o.LUTERR.Reg)&^(0x1)|value)
}
func (o *CANAF_Type) GetLUTERR() uint32 {
	return volatile.LoadUint32(&o.LUTERR.Reg) & 0x1
}
func (o *CANAF_Type) SetLUTERR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LUTERR.Reg, volatile.LoadUint32(&o.LUTERR.Reg)&^(0xfffffffe)|value<<1)
}
func (o *CANAF_Type) GetLUTERR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.LUTERR.Reg) & 0xfffffffe) >> 1
}

// CANAF.FCANIE: FullCAN interrupt enable register
func (o *CANAF_Type) SetFCANIE(value uint32) {
	volatile.StoreUint32(&o.FCANIE.Reg, volatile.LoadUint32(&o.FCANIE.Reg)&^(0x1)|value)
}
func (o *CANAF_Type) GetFCANIE() uint32 {
	return volatile.LoadUint32(&o.FCANIE.Reg) & 0x1
}
func (o *CANAF_Type) SetFCANIE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FCANIE.Reg, volatile.LoadUint32(&o.FCANIE.Reg)&^(0xfffffffe)|value<<1)
}
func (o *CANAF_Type) GetFCANIE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FCANIE.Reg) & 0xfffffffe) >> 1
}

// CANAF.FCANIC0: FullCAN interrupt and capture register0
func (o *CANAF_Type) SetFCANIC0(value uint32) {
	volatile.StoreUint32(&o.FCANIC0.Reg, value)
}
func (o *CANAF_Type) GetFCANIC0() uint32 {
	return volatile.LoadUint32(&o.FCANIC0.Reg)
}

// CANAF.FCANIC1: FullCAN interrupt and capture register1
func (o *CANAF_Type) SetFCANIC1(value uint32) {
	volatile.StoreUint32(&o.FCANIC1.Reg, value)
}
func (o *CANAF_Type) GetFCANIC1() uint32 {
	return volatile.LoadUint32(&o.FCANIC1.Reg)
}

// CAN controller
type CCAN_Type struct {
	TXSR volatile.Register32 // 0x0
	RXSR volatile.Register32 // 0x4
	MSR  volatile.Register32 // 0x8
}

// CCAN.TXSR: CAN Central Transmit Status Register
func (o *CCAN_Type) SetTXSR_TS1(value uint32) {
	volatile.StoreUint32(&o.TXSR.Reg, volatile.LoadUint32(&o.TXSR.Reg)&^(0x1)|value)
}
func (o *CCAN_Type) GetTXSR_TS1() uint32 {
	return volatile.LoadUint32(&o.TXSR.Reg) & 0x1
}
func (o *CCAN_Type) SetTXSR_TS2(value uint32) {
	volatile.StoreUint32(&o.TXSR.Reg, volatile.LoadUint32(&o.TXSR.Reg)&^(0x2)|value<<1)
}
func (o *CCAN_Type) GetTXSR_TS2() uint32 {
	return (volatile.LoadUint32(&o.TXSR.Reg) & 0x2) >> 1
}
func (o *CCAN_Type) SetTXSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TXSR.Reg, volatile.LoadUint32(&o.TXSR.Reg)&^(0xfc)|value<<2)
}
func (o *CCAN_Type) GetTXSR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TXSR.Reg) & 0xfc) >> 2
}
func (o *CCAN_Type) SetTXSR_TBS1(value uint32) {
	volatile.StoreUint32(&o.TXSR.Reg, volatile.LoadUint32(&o.TXSR.Reg)&^(0x100)|value<<8)
}
func (o *CCAN_Type) GetTXSR_TBS1() uint32 {
	return (volatile.LoadUint32(&o.TXSR.Reg) & 0x100) >> 8
}
func (o *CCAN_Type) SetTXSR_TBS2(value uint32) {
	volatile.StoreUint32(&o.TXSR.Reg, volatile.LoadUint32(&o.TXSR.Reg)&^(0x200)|value<<9)
}
func (o *CCAN_Type) GetTXSR_TBS2() uint32 {
	return (volatile.LoadUint32(&o.TXSR.Reg) & 0x200) >> 9
}
func (o *CCAN_Type) SetTXSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TXSR.Reg, volatile.LoadUint32(&o.TXSR.Reg)&^(0xfc00)|value<<10)
}
func (o *CCAN_Type) GetTXSR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TXSR.Reg) & 0xfc00) >> 10
}
func (o *CCAN_Type) SetTXSR_TCS1(value uint32) {
	volatile.StoreUint32(&o.TXSR.Reg, volatile.LoadUint32(&o.TXSR.Reg)&^(0x10000)|value<<16)
}
func (o *CCAN_Type) GetTXSR_TCS1() uint32 {
	return (volatile.LoadUint32(&o.TXSR.Reg) & 0x10000) >> 16
}
func (o *CCAN_Type) SetTXSR_TCS2(value uint32) {
	volatile.StoreUint32(&o.TXSR.Reg, volatile.LoadUint32(&o.TXSR.Reg)&^(0x20000)|value<<17)
}
func (o *CCAN_Type) GetTXSR_TCS2() uint32 {
	return (volatile.LoadUint32(&o.TXSR.Reg) & 0x20000) >> 17
}
func (o *CCAN_Type) SetTXSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TXSR.Reg, volatile.LoadUint32(&o.TXSR.Reg)&^(0xfffc0000)|value<<18)
}
func (o *CCAN_Type) GetTXSR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TXSR.Reg) & 0xfffc0000) >> 18
}

// CCAN.RXSR: CAN Central Receive Status Register
func (o *CCAN_Type) SetRXSR_RS1(value uint32) {
	volatile.StoreUint32(&o.RXSR.Reg, volatile.LoadUint32(&o.RXSR.Reg)&^(0x1)|value)
}
func (o *CCAN_Type) GetRXSR_RS1() uint32 {
	return volatile.LoadUint32(&o.RXSR.Reg) & 0x1
}
func (o *CCAN_Type) SetRXSR_RS2(value uint32) {
	volatile.StoreUint32(&o.RXSR.Reg, volatile.LoadUint32(&o.RXSR.Reg)&^(0x2)|value<<1)
}
func (o *CCAN_Type) GetRXSR_RS2() uint32 {
	return (volatile.LoadUint32(&o.RXSR.Reg) & 0x2) >> 1
}
func (o *CCAN_Type) SetRXSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RXSR.Reg, volatile.LoadUint32(&o.RXSR.Reg)&^(0xfc)|value<<2)
}
func (o *CCAN_Type) GetRXSR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RXSR.Reg) & 0xfc) >> 2
}
func (o *CCAN_Type) SetRXSR_RB1(value uint32) {
	volatile.StoreUint32(&o.RXSR.Reg, volatile.LoadUint32(&o.RXSR.Reg)&^(0x100)|value<<8)
}
func (o *CCAN_Type) GetRXSR_RB1() uint32 {
	return (volatile.LoadUint32(&o.RXSR.Reg) & 0x100) >> 8
}
func (o *CCAN_Type) SetRXSR_RB2(value uint32) {
	volatile.StoreUint32(&o.RXSR.Reg, volatile.LoadUint32(&o.RXSR.Reg)&^(0x200)|value<<9)
}
func (o *CCAN_Type) GetRXSR_RB2() uint32 {
	return (volatile.LoadUint32(&o.RXSR.Reg) & 0x200) >> 9
}
func (o *CCAN_Type) SetRXSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RXSR.Reg, volatile.LoadUint32(&o.RXSR.Reg)&^(0xfc00)|value<<10)
}
func (o *CCAN_Type) GetRXSR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RXSR.Reg) & 0xfc00) >> 10
}
func (o *CCAN_Type) SetRXSR_DOS1(value uint32) {
	volatile.StoreUint32(&o.RXSR.Reg, volatile.LoadUint32(&o.RXSR.Reg)&^(0x10000)|value<<16)
}
func (o *CCAN_Type) GetRXSR_DOS1() uint32 {
	return (volatile.LoadUint32(&o.RXSR.Reg) & 0x10000) >> 16
}
func (o *CCAN_Type) SetRXSR_DOS2(value uint32) {
	volatile.StoreUint32(&o.RXSR.Reg, volatile.LoadUint32(&o.RXSR.Reg)&^(0x20000)|value<<17)
}
func (o *CCAN_Type) GetRXSR_DOS2() uint32 {
	return (volatile.LoadUint32(&o.RXSR.Reg) & 0x20000) >> 17
}
func (o *CCAN_Type) SetRXSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RXSR.Reg, volatile.LoadUint32(&o.RXSR.Reg)&^(0xfffc0000)|value<<18)
}
func (o *CCAN_Type) GetRXSR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RXSR.Reg) & 0xfffc0000) >> 18
}

// CCAN.MSR: CAN Central Miscellaneous Register
func (o *CCAN_Type) SetMSR_E1(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x1)|value)
}
func (o *CCAN_Type) GetMSR_E1() uint32 {
	return volatile.LoadUint32(&o.MSR.Reg) & 0x1
}
func (o *CCAN_Type) SetMSR_E2(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x2)|value<<1)
}
func (o *CCAN_Type) GetMSR_E2() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x2) >> 1
}
func (o *CCAN_Type) SetMSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0xfc)|value<<2)
}
func (o *CCAN_Type) GetMSR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0xfc) >> 2
}
func (o *CCAN_Type) SetMSR_BS1(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x100)|value<<8)
}
func (o *CCAN_Type) GetMSR_BS1() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x100) >> 8
}
func (o *CCAN_Type) SetMSR_BS2(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x200)|value<<9)
}
func (o *CCAN_Type) GetMSR_BS2() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x200) >> 9
}
func (o *CCAN_Type) SetMSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0xfffffc00)|value<<10)
}
func (o *CCAN_Type) GetMSR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0xfffffc00) >> 10
}

// CAN controller
type CAN_Type struct {
	MOD  volatile.Register32 // 0x0
	CMR  volatile.Register32 // 0x4
	GSR  volatile.Register32 // 0x8
	ICR  volatile.Register32 // 0xC
	IER  volatile.Register32 // 0x10
	BTR  volatile.Register32 // 0x14
	EWL  volatile.Register32 // 0x18
	SR   volatile.Register32 // 0x1C
	RFS  volatile.Register32 // 0x20
	RID  volatile.Register32 // 0x24
	RDA  volatile.Register32 // 0x28
	RDB  volatile.Register32 // 0x2C
	TFI1 volatile.Register32 // 0x30
	TID1 volatile.Register32 // 0x34
	TDA1 volatile.Register32 // 0x38
	TDB1 volatile.Register32 // 0x3C
	TFI2 volatile.Register32 // 0x40
	TID2 volatile.Register32 // 0x44
	TDA2 volatile.Register32 // 0x48
	TDB2 volatile.Register32 // 0x4C
	TFI3 volatile.Register32 // 0x50
	TID3 volatile.Register32 // 0x54
	TDA3 volatile.Register32 // 0x58
	TDB3 volatile.Register32 // 0x5C
}

// CAN.MOD: Controls the operating mode of the CAN Controller.
func (o *CAN_Type) SetMOD_RM(value uint32) {
	volatile.StoreUint32(&o.MOD.Reg, volatile.LoadUint32(&o.MOD.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetMOD_RM() uint32 {
	return volatile.LoadUint32(&o.MOD.Reg) & 0x1
}
func (o *CAN_Type) SetMOD_LOM(value uint32) {
	volatile.StoreUint32(&o.MOD.Reg, volatile.LoadUint32(&o.MOD.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetMOD_LOM() uint32 {
	return (volatile.LoadUint32(&o.MOD.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetMOD_STM(value uint32) {
	volatile.StoreUint32(&o.MOD.Reg, volatile.LoadUint32(&o.MOD.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetMOD_STM() uint32 {
	return (volatile.LoadUint32(&o.MOD.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetMOD_TPM(value uint32) {
	volatile.StoreUint32(&o.MOD.Reg, volatile.LoadUint32(&o.MOD.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetMOD_TPM() uint32 {
	return (volatile.LoadUint32(&o.MOD.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetMOD_SM(value uint32) {
	volatile.StoreUint32(&o.MOD.Reg, volatile.LoadUint32(&o.MOD.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetMOD_SM() uint32 {
	return (volatile.LoadUint32(&o.MOD.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetMOD_RPM(value uint32) {
	volatile.StoreUint32(&o.MOD.Reg, volatile.LoadUint32(&o.MOD.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetMOD_RPM() uint32 {
	return (volatile.LoadUint32(&o.MOD.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetMOD_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MOD.Reg, volatile.LoadUint32(&o.MOD.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetMOD_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MOD.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetMOD_TM(value uint32) {
	volatile.StoreUint32(&o.MOD.Reg, volatile.LoadUint32(&o.MOD.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetMOD_TM() uint32 {
	return (volatile.LoadUint32(&o.MOD.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetMOD_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MOD.Reg, volatile.LoadUint32(&o.MOD.Reg)&^(0xffffff00)|value<<8)
}
func (o *CAN_Type) GetMOD_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MOD.Reg) & 0xffffff00) >> 8
}

// CAN.CMR: Command bits that affect the state of the CAN Controller
func (o *CAN_Type) SetCMR_TR(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetCMR_TR() uint32 {
	return volatile.LoadUint32(&o.CMR.Reg) & 0x1
}
func (o *CAN_Type) SetCMR_AT(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetCMR_AT() uint32 {
	return (volatile.LoadUint32(&o.CMR.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetCMR_RRB(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetCMR_RRB() uint32 {
	return (volatile.LoadUint32(&o.CMR.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetCMR_CDO(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetCMR_CDO() uint32 {
	return (volatile.LoadUint32(&o.CMR.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetCMR_SRR(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetCMR_SRR() uint32 {
	return (volatile.LoadUint32(&o.CMR.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetCMR_STB1(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetCMR_STB1() uint32 {
	return (volatile.LoadUint32(&o.CMR.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetCMR_STB2(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetCMR_STB2() uint32 {
	return (volatile.LoadUint32(&o.CMR.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetCMR_STB3(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetCMR_STB3() uint32 {
	return (volatile.LoadUint32(&o.CMR.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetCMR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CMR.Reg, volatile.LoadUint32(&o.CMR.Reg)&^(0xffffff00)|value<<8)
}
func (o *CAN_Type) GetCMR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CMR.Reg) & 0xffffff00) >> 8
}

// CAN.GSR: Global Controller Status and Error Counters. The error counters can only be written when RM in CANMOD is 1.
func (o *CAN_Type) SetGSR_RBS(value uint32) {
	volatile.StoreUint32(&o.GSR.Reg, volatile.LoadUint32(&o.GSR.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetGSR_RBS() uint32 {
	return volatile.LoadUint32(&o.GSR.Reg) & 0x1
}
func (o *CAN_Type) SetGSR_DOS(value uint32) {
	volatile.StoreUint32(&o.GSR.Reg, volatile.LoadUint32(&o.GSR.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetGSR_DOS() uint32 {
	return (volatile.LoadUint32(&o.GSR.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetGSR_TBS(value uint32) {
	volatile.StoreUint32(&o.GSR.Reg, volatile.LoadUint32(&o.GSR.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetGSR_TBS() uint32 {
	return (volatile.LoadUint32(&o.GSR.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetGSR_TCS(value uint32) {
	volatile.StoreUint32(&o.GSR.Reg, volatile.LoadUint32(&o.GSR.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetGSR_TCS() uint32 {
	return (volatile.LoadUint32(&o.GSR.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetGSR_RS(value uint32) {
	volatile.StoreUint32(&o.GSR.Reg, volatile.LoadUint32(&o.GSR.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetGSR_RS() uint32 {
	return (volatile.LoadUint32(&o.GSR.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetGSR_TS(value uint32) {
	volatile.StoreUint32(&o.GSR.Reg, volatile.LoadUint32(&o.GSR.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetGSR_TS() uint32 {
	return (volatile.LoadUint32(&o.GSR.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetGSR_ES(value uint32) {
	volatile.StoreUint32(&o.GSR.Reg, volatile.LoadUint32(&o.GSR.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetGSR_ES() uint32 {
	return (volatile.LoadUint32(&o.GSR.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetGSR_BS(value uint32) {
	volatile.StoreUint32(&o.GSR.Reg, volatile.LoadUint32(&o.GSR.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetGSR_BS() uint32 {
	return (volatile.LoadUint32(&o.GSR.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetGSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.GSR.Reg, volatile.LoadUint32(&o.GSR.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetGSR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.GSR.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetGSR_RXERR(value uint32) {
	volatile.StoreUint32(&o.GSR.Reg, volatile.LoadUint32(&o.GSR.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetGSR_RXERR() uint32 {
	return (volatile.LoadUint32(&o.GSR.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetGSR_TXERR(value uint32) {
	volatile.StoreUint32(&o.GSR.Reg, volatile.LoadUint32(&o.GSR.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetGSR_TXERR() uint32 {
	return (volatile.LoadUint32(&o.GSR.Reg) & 0xff000000) >> 24
}

// CAN.ICR: Interrupt status, Arbitration Lost Capture, Error Code Capture
func (o *CAN_Type) SetICR_RI(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetICR_RI() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}
func (o *CAN_Type) SetICR_TI1(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetICR_TI1() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetICR_EI(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetICR_EI() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetICR_DOI(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetICR_DOI() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetICR_WUI(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetICR_WUI() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetICR_EPI(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetICR_EPI() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetICR_ALI(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetICR_ALI() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetICR_BEI(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetICR_BEI() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetICR_IDI(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetICR_IDI() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetICR_TI2(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetICR_TI2() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetICR_TI3(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetICR_TI3() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetICR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0xf800)|value<<11)
}
func (o *CAN_Type) GetICR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0xf800) >> 11
}
func (o *CAN_Type) SetICR_ERRBIT4_0(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1f0000)|value<<16)
}
func (o *CAN_Type) GetICR_ERRBIT4_0() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x1f0000) >> 16
}
func (o *CAN_Type) SetICR_ERRDIR(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetICR_ERRDIR() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetICR_ERRC1_0(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0xc00000)|value<<22)
}
func (o *CAN_Type) GetICR_ERRC1_0() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0xc00000) >> 22
}
func (o *CAN_Type) SetICR_ALCBIT(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetICR_ALCBIT() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0xff000000) >> 24
}

// CAN.IER: Interrupt Enable
func (o *CAN_Type) SetIER_RIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetIER_RIE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *CAN_Type) SetIER_TIE1(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetIER_TIE1() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetIER_EIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetIER_EIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetIER_DOIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetIER_DOIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetIER_WUIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetIER_WUIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetIER_EPIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetIER_EPIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetIER_ALIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetIER_ALIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetIER_BEIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetIER_BEIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetIER_IDIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetIER_IDIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetIER_TIE2(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetIER_TIE2() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetIER_TIE3(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetIER_TIE3() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetIER_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0xfffff800)|value<<11)
}
func (o *CAN_Type) GetIER_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0xfffff800) >> 11
}

// CAN.BTR: Bus Timing. Can only be written when RM in CANMOD is 1.
func (o *CAN_Type) SetBTR_BRP(value uint32) {
	volatile.StoreUint32(&o.BTR.Reg, volatile.LoadUint32(&o.BTR.Reg)&^(0x3ff)|value)
}
func (o *CAN_Type) GetBTR_BRP() uint32 {
	return volatile.LoadUint32(&o.BTR.Reg) & 0x3ff
}
func (o *CAN_Type) SetBTR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BTR.Reg, volatile.LoadUint32(&o.BTR.Reg)&^(0x3c00)|value<<10)
}
func (o *CAN_Type) GetBTR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BTR.Reg) & 0x3c00) >> 10
}
func (o *CAN_Type) SetBTR_SJW(value uint32) {
	volatile.StoreUint32(&o.BTR.Reg, volatile.LoadUint32(&o.BTR.Reg)&^(0xc000)|value<<14)
}
func (o *CAN_Type) GetBTR_SJW() uint32 {
	return (volatile.LoadUint32(&o.BTR.Reg) & 0xc000) >> 14
}
func (o *CAN_Type) SetBTR_TESG1(value uint32) {
	volatile.StoreUint32(&o.BTR.Reg, volatile.LoadUint32(&o.BTR.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetBTR_TESG1() uint32 {
	return (volatile.LoadUint32(&o.BTR.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetBTR_TESG2(value uint32) {
	volatile.StoreUint32(&o.BTR.Reg, volatile.LoadUint32(&o.BTR.Reg)&^(0x700000)|value<<20)
}
func (o *CAN_Type) GetBTR_TESG2() uint32 {
	return (volatile.LoadUint32(&o.BTR.Reg) & 0x700000) >> 20
}
func (o *CAN_Type) SetBTR_SAM(value uint32) {
	volatile.StoreUint32(&o.BTR.Reg, volatile.LoadUint32(&o.BTR.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetBTR_SAM() uint32 {
	return (volatile.LoadUint32(&o.BTR.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetBTR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BTR.Reg, volatile.LoadUint32(&o.BTR.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetBTR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BTR.Reg) & 0xff000000) >> 24
}

// CAN.EWL: Error Warning Limit. Can only be written when RM in CANMOD is 1.
func (o *CAN_Type) SetEWL(value uint32) {
	volatile.StoreUint32(&o.EWL.Reg, volatile.LoadUint32(&o.EWL.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetEWL() uint32 {
	return volatile.LoadUint32(&o.EWL.Reg) & 0xff
}
func (o *CAN_Type) SetEWL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EWL.Reg, volatile.LoadUint32(&o.EWL.Reg)&^(0xffffff00)|value<<8)
}
func (o *CAN_Type) GetEWL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EWL.Reg) & 0xffffff00) >> 8
}

// CAN.SR: Status Register
func (o *CAN_Type) SetSR_RBS_1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *CAN_Type) GetSR_RBS_1() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *CAN_Type) SetSR_DOS_1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *CAN_Type) GetSR_DOS_1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *CAN_Type) SetSR_TBS1_1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *CAN_Type) GetSR_TBS1_1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *CAN_Type) SetSR_TCS1_1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *CAN_Type) GetSR_TCS1_1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *CAN_Type) SetSR_RS_1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *CAN_Type) GetSR_RS_1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *CAN_Type) SetSR_TS1_1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *CAN_Type) GetSR_TS1_1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}
func (o *CAN_Type) SetSR_ES_1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40)|value<<6)
}
func (o *CAN_Type) GetSR_ES_1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40) >> 6
}
func (o *CAN_Type) SetSR_BS_1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80)|value<<7)
}
func (o *CAN_Type) GetSR_BS_1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80) >> 7
}
func (o *CAN_Type) SetSR_RBS_2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *CAN_Type) GetSR_RBS_2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *CAN_Type) SetSR_DOS_2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *CAN_Type) GetSR_DOS_2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *CAN_Type) SetSR_TBS2_2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetSR_TBS2_2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetSR_TCS2_2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x800)|value<<11)
}
func (o *CAN_Type) GetSR_TCS2_2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x800) >> 11
}
func (o *CAN_Type) SetSR_RS_2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1000)|value<<12)
}
func (o *CAN_Type) GetSR_RS_2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1000) >> 12
}
func (o *CAN_Type) SetSR_TS2_2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000)|value<<13)
}
func (o *CAN_Type) GetSR_TS2_2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000) >> 13
}
func (o *CAN_Type) SetSR_ES_2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4000)|value<<14)
}
func (o *CAN_Type) GetSR_ES_2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4000) >> 14
}
func (o *CAN_Type) SetSR_BS_2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8000)|value<<15)
}
func (o *CAN_Type) GetSR_BS_2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8000) >> 15
}
func (o *CAN_Type) SetSR_RBS_3(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *CAN_Type) GetSR_RBS_3() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *CAN_Type) SetSR_DOS_3(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000)|value<<17)
}
func (o *CAN_Type) GetSR_DOS_3() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000) >> 17
}
func (o *CAN_Type) SetSR_TBS3_3(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000)|value<<18)
}
func (o *CAN_Type) GetSR_TBS3_3() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000) >> 18
}
func (o *CAN_Type) SetSR_TCS3_3(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000)|value<<19)
}
func (o *CAN_Type) GetSR_TCS3_3() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000) >> 19
}
func (o *CAN_Type) SetSR_RS_3(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100000)|value<<20)
}
func (o *CAN_Type) GetSR_RS_3() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100000) >> 20
}
func (o *CAN_Type) SetSR_TS3_3(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200000)|value<<21)
}
func (o *CAN_Type) GetSR_TS3_3() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200000) >> 21
}
func (o *CAN_Type) SetSR_ES_3(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400000)|value<<22)
}
func (o *CAN_Type) GetSR_ES_3() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400000) >> 22
}
func (o *CAN_Type) SetSR_BS_3(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x800000)|value<<23)
}
func (o *CAN_Type) GetSR_BS_3() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x800000) >> 23
}
func (o *CAN_Type) SetSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetSR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0xff000000) >> 24
}

// CAN.RFS: Receive frame status. Can only be written when RM in CANMOD is 1.
func (o *CAN_Type) SetRFS_IDINDEX(value uint32) {
	volatile.StoreUint32(&o.RFS.Reg, volatile.LoadUint32(&o.RFS.Reg)&^(0x3ff)|value)
}
func (o *CAN_Type) GetRFS_IDINDEX() uint32 {
	return volatile.LoadUint32(&o.RFS.Reg) & 0x3ff
}
func (o *CAN_Type) SetRFS_BP(value uint32) {
	volatile.StoreUint32(&o.RFS.Reg, volatile.LoadUint32(&o.RFS.Reg)&^(0x400)|value<<10)
}
func (o *CAN_Type) GetRFS_BP() uint32 {
	return (volatile.LoadUint32(&o.RFS.Reg) & 0x400) >> 10
}
func (o *CAN_Type) SetRFS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RFS.Reg, volatile.LoadUint32(&o.RFS.Reg)&^(0xf800)|value<<11)
}
func (o *CAN_Type) GetRFS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RFS.Reg) & 0xf800) >> 11
}
func (o *CAN_Type) SetRFS_DLC(value uint32) {
	volatile.StoreUint32(&o.RFS.Reg, volatile.LoadUint32(&o.RFS.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetRFS_DLC() uint32 {
	return (volatile.LoadUint32(&o.RFS.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetRFS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RFS.Reg, volatile.LoadUint32(&o.RFS.Reg)&^(0x3ff00000)|value<<20)
}
func (o *CAN_Type) GetRFS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RFS.Reg) & 0x3ff00000) >> 20
}
func (o *CAN_Type) SetRFS_RTR(value uint32) {
	volatile.StoreUint32(&o.RFS.Reg, volatile.LoadUint32(&o.RFS.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetRFS_RTR() uint32 {
	return (volatile.LoadUint32(&o.RFS.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetRFS_FF(value uint32) {
	volatile.StoreUint32(&o.RFS.Reg, volatile.LoadUint32(&o.RFS.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetRFS_FF() uint32 {
	return (volatile.LoadUint32(&o.RFS.Reg) & 0x80000000) >> 31
}

// CAN.RID: Received Identifier. Can only be written when RM in CANMOD is 1.
func (o *CAN_Type) SetRID_ID(value uint32) {
	volatile.StoreUint32(&o.RID.Reg, volatile.LoadUint32(&o.RID.Reg)&^(0x7ff)|value)
}
func (o *CAN_Type) GetRID_ID() uint32 {
	return volatile.LoadUint32(&o.RID.Reg) & 0x7ff
}
func (o *CAN_Type) SetRID_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RID.Reg, volatile.LoadUint32(&o.RID.Reg)&^(0xfffff800)|value<<11)
}
func (o *CAN_Type) GetRID_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RID.Reg) & 0xfffff800) >> 11
}

// CAN.RDA: Received data bytes 1-4. Can only be written when RM in CANMOD is 1.
func (o *CAN_Type) SetRDA_DATA1(value uint32) {
	volatile.StoreUint32(&o.RDA.Reg, volatile.LoadUint32(&o.RDA.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetRDA_DATA1() uint32 {
	return volatile.LoadUint32(&o.RDA.Reg) & 0xff
}
func (o *CAN_Type) SetRDA_DATA2(value uint32) {
	volatile.StoreUint32(&o.RDA.Reg, volatile.LoadUint32(&o.RDA.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetRDA_DATA2() uint32 {
	return (volatile.LoadUint32(&o.RDA.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetRDA_DATA3(value uint32) {
	volatile.StoreUint32(&o.RDA.Reg, volatile.LoadUint32(&o.RDA.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetRDA_DATA3() uint32 {
	return (volatile.LoadUint32(&o.RDA.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetRDA_DATA4(value uint32) {
	volatile.StoreUint32(&o.RDA.Reg, volatile.LoadUint32(&o.RDA.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetRDA_DATA4() uint32 {
	return (volatile.LoadUint32(&o.RDA.Reg) & 0xff000000) >> 24
}

// CAN.RDB: Received data bytes 5-8. Can only be written when RM in CANMOD is 1.
func (o *CAN_Type) SetRDB_DATA5(value uint32) {
	volatile.StoreUint32(&o.RDB.Reg, volatile.LoadUint32(&o.RDB.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetRDB_DATA5() uint32 {
	return volatile.LoadUint32(&o.RDB.Reg) & 0xff
}
func (o *CAN_Type) SetRDB_DATA6(value uint32) {
	volatile.StoreUint32(&o.RDB.Reg, volatile.LoadUint32(&o.RDB.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetRDB_DATA6() uint32 {
	return (volatile.LoadUint32(&o.RDB.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetRDB_DATA7(value uint32) {
	volatile.StoreUint32(&o.RDB.Reg, volatile.LoadUint32(&o.RDB.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetRDB_DATA7() uint32 {
	return (volatile.LoadUint32(&o.RDB.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetRDB_DATA8(value uint32) {
	volatile.StoreUint32(&o.RDB.Reg, volatile.LoadUint32(&o.RDB.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetRDB_DATA8() uint32 {
	return (volatile.LoadUint32(&o.RDB.Reg) & 0xff000000) >> 24
}

// CAN.TFI1: Transmit frame info (Tx Buffer )
func (o *CAN_Type) SetTFI1_PRIO(value uint32) {
	volatile.StoreUint32(&o.TFI1.Reg, volatile.LoadUint32(&o.TFI1.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetTFI1_PRIO() uint32 {
	return volatile.LoadUint32(&o.TFI1.Reg) & 0xff
}
func (o *CAN_Type) SetTFI1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TFI1.Reg, volatile.LoadUint32(&o.TFI1.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetTFI1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TFI1.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetTFI1_DLC(value uint32) {
	volatile.StoreUint32(&o.TFI1.Reg, volatile.LoadUint32(&o.TFI1.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetTFI1_DLC() uint32 {
	return (volatile.LoadUint32(&o.TFI1.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetTFI1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TFI1.Reg, volatile.LoadUint32(&o.TFI1.Reg)&^(0x3ff00000)|value<<20)
}
func (o *CAN_Type) GetTFI1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TFI1.Reg) & 0x3ff00000) >> 20
}
func (o *CAN_Type) SetTFI1_RTR(value uint32) {
	volatile.StoreUint32(&o.TFI1.Reg, volatile.LoadUint32(&o.TFI1.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetTFI1_RTR() uint32 {
	return (volatile.LoadUint32(&o.TFI1.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetTFI1_FF(value uint32) {
	volatile.StoreUint32(&o.TFI1.Reg, volatile.LoadUint32(&o.TFI1.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetTFI1_FF() uint32 {
	return (volatile.LoadUint32(&o.TFI1.Reg) & 0x80000000) >> 31
}

// CAN.TID1: Transmit Identifier (Tx Buffer)
func (o *CAN_Type) SetTID1_ID(value uint32) {
	volatile.StoreUint32(&o.TID1.Reg, volatile.LoadUint32(&o.TID1.Reg)&^(0x7ff)|value)
}
func (o *CAN_Type) GetTID1_ID() uint32 {
	return volatile.LoadUint32(&o.TID1.Reg) & 0x7ff
}
func (o *CAN_Type) SetTID1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TID1.Reg, volatile.LoadUint32(&o.TID1.Reg)&^(0xfffff800)|value<<11)
}
func (o *CAN_Type) GetTID1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TID1.Reg) & 0xfffff800) >> 11
}

// CAN.TDA1: Transmit data bytes 1-4 (Tx Buffer)
func (o *CAN_Type) SetTDA1_DATA1(value uint32) {
	volatile.StoreUint32(&o.TDA1.Reg, volatile.LoadUint32(&o.TDA1.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetTDA1_DATA1() uint32 {
	return volatile.LoadUint32(&o.TDA1.Reg) & 0xff
}
func (o *CAN_Type) SetTDA1_DATA2(value uint32) {
	volatile.StoreUint32(&o.TDA1.Reg, volatile.LoadUint32(&o.TDA1.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetTDA1_DATA2() uint32 {
	return (volatile.LoadUint32(&o.TDA1.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetTDA1_DATA3(value uint32) {
	volatile.StoreUint32(&o.TDA1.Reg, volatile.LoadUint32(&o.TDA1.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetTDA1_DATA3() uint32 {
	return (volatile.LoadUint32(&o.TDA1.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetTDA1_DATA4(value uint32) {
	volatile.StoreUint32(&o.TDA1.Reg, volatile.LoadUint32(&o.TDA1.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetTDA1_DATA4() uint32 {
	return (volatile.LoadUint32(&o.TDA1.Reg) & 0xff000000) >> 24
}

// CAN.TDB1: Transmit data bytes 5-8 (Tx Buffer )
func (o *CAN_Type) SetTDB1_DATA5(value uint32) {
	volatile.StoreUint32(&o.TDB1.Reg, volatile.LoadUint32(&o.TDB1.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetTDB1_DATA5() uint32 {
	return volatile.LoadUint32(&o.TDB1.Reg) & 0xff
}
func (o *CAN_Type) SetTDB1_DATA6(value uint32) {
	volatile.StoreUint32(&o.TDB1.Reg, volatile.LoadUint32(&o.TDB1.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetTDB1_DATA6() uint32 {
	return (volatile.LoadUint32(&o.TDB1.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetTDB1_DATA7(value uint32) {
	volatile.StoreUint32(&o.TDB1.Reg, volatile.LoadUint32(&o.TDB1.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetTDB1_DATA7() uint32 {
	return (volatile.LoadUint32(&o.TDB1.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetTDB1_DATA8(value uint32) {
	volatile.StoreUint32(&o.TDB1.Reg, volatile.LoadUint32(&o.TDB1.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetTDB1_DATA8() uint32 {
	return (volatile.LoadUint32(&o.TDB1.Reg) & 0xff000000) >> 24
}

// CAN.TFI2: Transmit frame info (Tx Buffer )
func (o *CAN_Type) SetTFI2_PRIO(value uint32) {
	volatile.StoreUint32(&o.TFI2.Reg, volatile.LoadUint32(&o.TFI2.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetTFI2_PRIO() uint32 {
	return volatile.LoadUint32(&o.TFI2.Reg) & 0xff
}
func (o *CAN_Type) SetTFI2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TFI2.Reg, volatile.LoadUint32(&o.TFI2.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetTFI2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TFI2.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetTFI2_DLC(value uint32) {
	volatile.StoreUint32(&o.TFI2.Reg, volatile.LoadUint32(&o.TFI2.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetTFI2_DLC() uint32 {
	return (volatile.LoadUint32(&o.TFI2.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetTFI2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TFI2.Reg, volatile.LoadUint32(&o.TFI2.Reg)&^(0x3ff00000)|value<<20)
}
func (o *CAN_Type) GetTFI2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TFI2.Reg) & 0x3ff00000) >> 20
}
func (o *CAN_Type) SetTFI2_RTR(value uint32) {
	volatile.StoreUint32(&o.TFI2.Reg, volatile.LoadUint32(&o.TFI2.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetTFI2_RTR() uint32 {
	return (volatile.LoadUint32(&o.TFI2.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetTFI2_FF(value uint32) {
	volatile.StoreUint32(&o.TFI2.Reg, volatile.LoadUint32(&o.TFI2.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetTFI2_FF() uint32 {
	return (volatile.LoadUint32(&o.TFI2.Reg) & 0x80000000) >> 31
}

// CAN.TID2: Transmit Identifier (Tx Buffer)
func (o *CAN_Type) SetTID2_ID(value uint32) {
	volatile.StoreUint32(&o.TID2.Reg, volatile.LoadUint32(&o.TID2.Reg)&^(0x7ff)|value)
}
func (o *CAN_Type) GetTID2_ID() uint32 {
	return volatile.LoadUint32(&o.TID2.Reg) & 0x7ff
}
func (o *CAN_Type) SetTID2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TID2.Reg, volatile.LoadUint32(&o.TID2.Reg)&^(0xfffff800)|value<<11)
}
func (o *CAN_Type) GetTID2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TID2.Reg) & 0xfffff800) >> 11
}

// CAN.TDA2: Transmit data bytes 1-4 (Tx Buffer)
func (o *CAN_Type) SetTDA2_DATA1(value uint32) {
	volatile.StoreUint32(&o.TDA2.Reg, volatile.LoadUint32(&o.TDA2.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetTDA2_DATA1() uint32 {
	return volatile.LoadUint32(&o.TDA2.Reg) & 0xff
}
func (o *CAN_Type) SetTDA2_DATA2(value uint32) {
	volatile.StoreUint32(&o.TDA2.Reg, volatile.LoadUint32(&o.TDA2.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetTDA2_DATA2() uint32 {
	return (volatile.LoadUint32(&o.TDA2.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetTDA2_DATA3(value uint32) {
	volatile.StoreUint32(&o.TDA2.Reg, volatile.LoadUint32(&o.TDA2.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetTDA2_DATA3() uint32 {
	return (volatile.LoadUint32(&o.TDA2.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetTDA2_DATA4(value uint32) {
	volatile.StoreUint32(&o.TDA2.Reg, volatile.LoadUint32(&o.TDA2.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetTDA2_DATA4() uint32 {
	return (volatile.LoadUint32(&o.TDA2.Reg) & 0xff000000) >> 24
}

// CAN.TDB2: Transmit data bytes 5-8 (Tx Buffer )
func (o *CAN_Type) SetTDB2_DATA5(value uint32) {
	volatile.StoreUint32(&o.TDB2.Reg, volatile.LoadUint32(&o.TDB2.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetTDB2_DATA5() uint32 {
	return volatile.LoadUint32(&o.TDB2.Reg) & 0xff
}
func (o *CAN_Type) SetTDB2_DATA6(value uint32) {
	volatile.StoreUint32(&o.TDB2.Reg, volatile.LoadUint32(&o.TDB2.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetTDB2_DATA6() uint32 {
	return (volatile.LoadUint32(&o.TDB2.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetTDB2_DATA7(value uint32) {
	volatile.StoreUint32(&o.TDB2.Reg, volatile.LoadUint32(&o.TDB2.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetTDB2_DATA7() uint32 {
	return (volatile.LoadUint32(&o.TDB2.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetTDB2_DATA8(value uint32) {
	volatile.StoreUint32(&o.TDB2.Reg, volatile.LoadUint32(&o.TDB2.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetTDB2_DATA8() uint32 {
	return (volatile.LoadUint32(&o.TDB2.Reg) & 0xff000000) >> 24
}

// CAN.TFI3: Transmit frame info (Tx Buffer )
func (o *CAN_Type) SetTFI3_PRIO(value uint32) {
	volatile.StoreUint32(&o.TFI3.Reg, volatile.LoadUint32(&o.TFI3.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetTFI3_PRIO() uint32 {
	return volatile.LoadUint32(&o.TFI3.Reg) & 0xff
}
func (o *CAN_Type) SetTFI3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TFI3.Reg, volatile.LoadUint32(&o.TFI3.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetTFI3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TFI3.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetTFI3_DLC(value uint32) {
	volatile.StoreUint32(&o.TFI3.Reg, volatile.LoadUint32(&o.TFI3.Reg)&^(0xf0000)|value<<16)
}
func (o *CAN_Type) GetTFI3_DLC() uint32 {
	return (volatile.LoadUint32(&o.TFI3.Reg) & 0xf0000) >> 16
}
func (o *CAN_Type) SetTFI3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TFI3.Reg, volatile.LoadUint32(&o.TFI3.Reg)&^(0x3ff00000)|value<<20)
}
func (o *CAN_Type) GetTFI3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TFI3.Reg) & 0x3ff00000) >> 20
}
func (o *CAN_Type) SetTFI3_RTR(value uint32) {
	volatile.StoreUint32(&o.TFI3.Reg, volatile.LoadUint32(&o.TFI3.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN_Type) GetTFI3_RTR() uint32 {
	return (volatile.LoadUint32(&o.TFI3.Reg) & 0x40000000) >> 30
}
func (o *CAN_Type) SetTFI3_FF(value uint32) {
	volatile.StoreUint32(&o.TFI3.Reg, volatile.LoadUint32(&o.TFI3.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN_Type) GetTFI3_FF() uint32 {
	return (volatile.LoadUint32(&o.TFI3.Reg) & 0x80000000) >> 31
}

// CAN.TID3: Transmit Identifier (Tx Buffer)
func (o *CAN_Type) SetTID3_ID(value uint32) {
	volatile.StoreUint32(&o.TID3.Reg, volatile.LoadUint32(&o.TID3.Reg)&^(0x7ff)|value)
}
func (o *CAN_Type) GetTID3_ID() uint32 {
	return volatile.LoadUint32(&o.TID3.Reg) & 0x7ff
}
func (o *CAN_Type) SetTID3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TID3.Reg, volatile.LoadUint32(&o.TID3.Reg)&^(0xfffff800)|value<<11)
}
func (o *CAN_Type) GetTID3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TID3.Reg) & 0xfffff800) >> 11
}

// CAN.TDA3: Transmit data bytes 1-4 (Tx Buffer)
func (o *CAN_Type) SetTDA3_DATA1(value uint32) {
	volatile.StoreUint32(&o.TDA3.Reg, volatile.LoadUint32(&o.TDA3.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetTDA3_DATA1() uint32 {
	return volatile.LoadUint32(&o.TDA3.Reg) & 0xff
}
func (o *CAN_Type) SetTDA3_DATA2(value uint32) {
	volatile.StoreUint32(&o.TDA3.Reg, volatile.LoadUint32(&o.TDA3.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetTDA3_DATA2() uint32 {
	return (volatile.LoadUint32(&o.TDA3.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetTDA3_DATA3(value uint32) {
	volatile.StoreUint32(&o.TDA3.Reg, volatile.LoadUint32(&o.TDA3.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetTDA3_DATA3() uint32 {
	return (volatile.LoadUint32(&o.TDA3.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetTDA3_DATA4(value uint32) {
	volatile.StoreUint32(&o.TDA3.Reg, volatile.LoadUint32(&o.TDA3.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetTDA3_DATA4() uint32 {
	return (volatile.LoadUint32(&o.TDA3.Reg) & 0xff000000) >> 24
}

// CAN.TDB3: Transmit data bytes 5-8 (Tx Buffer )
func (o *CAN_Type) SetTDB3_DATA5(value uint32) {
	volatile.StoreUint32(&o.TDB3.Reg, volatile.LoadUint32(&o.TDB3.Reg)&^(0xff)|value)
}
func (o *CAN_Type) GetTDB3_DATA5() uint32 {
	return volatile.LoadUint32(&o.TDB3.Reg) & 0xff
}
func (o *CAN_Type) SetTDB3_DATA6(value uint32) {
	volatile.StoreUint32(&o.TDB3.Reg, volatile.LoadUint32(&o.TDB3.Reg)&^(0xff00)|value<<8)
}
func (o *CAN_Type) GetTDB3_DATA6() uint32 {
	return (volatile.LoadUint32(&o.TDB3.Reg) & 0xff00) >> 8
}
func (o *CAN_Type) SetTDB3_DATA7(value uint32) {
	volatile.StoreUint32(&o.TDB3.Reg, volatile.LoadUint32(&o.TDB3.Reg)&^(0xff0000)|value<<16)
}
func (o *CAN_Type) GetTDB3_DATA7() uint32 {
	return (volatile.LoadUint32(&o.TDB3.Reg) & 0xff0000) >> 16
}
func (o *CAN_Type) SetTDB3_DATA8(value uint32) {
	volatile.StoreUint32(&o.TDB3.Reg, volatile.LoadUint32(&o.TDB3.Reg)&^(0xff000000)|value<<24)
}
func (o *CAN_Type) GetTDB3_DATA8() uint32 {
	return (volatile.LoadUint32(&o.TDB3.Reg) & 0xff000000) >> 24
}

// Digital-to-Analog Converter (DAC) Modification
type DAC_Type struct {
	CR     volatile.Register32 // 0x0
	CTRL   volatile.Register32 // 0x4
	CNTVAL volatile.Register32 // 0x8
}

// DAC.CR: D/A Converter Register. This register contains the digital value to be converted to analog and a power control bit.
func (o *DAC_Type) SetCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x3f)|value)
}
func (o *DAC_Type) GetCR_RESERVED() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x3f
}
func (o *DAC_Type) SetCR_VALUE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xffc0)|value<<6)
}
func (o *DAC_Type) GetCR_VALUE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xffc0) >> 6
}
func (o *DAC_Type) SetCR_BIAS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *DAC_Type) GetCR_BIAS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *DAC_Type) SetCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xfffe0000)|value<<17)
}
func (o *DAC_Type) GetCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xfffe0000) >> 17
}

// DAC.CTRL: DAC Control register. This register controls DMA and timer operation.
func (o *DAC_Type) SetCTRL_INT_DMA_REQ(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *DAC_Type) GetCTRL_INT_DMA_REQ() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *DAC_Type) SetCTRL_DBLBUF_ENA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *DAC_Type) GetCTRL_DBLBUF_ENA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *DAC_Type) SetCTRL_CNT_ENA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *DAC_Type) GetCTRL_CNT_ENA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}
func (o *DAC_Type) SetCTRL_DMA_ENA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8)|value<<3)
}
func (o *DAC_Type) GetCTRL_DMA_ENA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8) >> 3
}
func (o *DAC_Type) SetCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xfffffff0)|value<<4)
}
func (o *DAC_Type) GetCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xfffffff0) >> 4
}

// DAC.CNTVAL: DAC Counter Value register. This register contains the reload value for the DAC DMA/Interrupt timer.
func (o *DAC_Type) SetCNTVAL_VALUE(value uint32) {
	volatile.StoreUint32(&o.CNTVAL.Reg, volatile.LoadUint32(&o.CNTVAL.Reg)&^(0xffff)|value)
}
func (o *DAC_Type) GetCNTVAL_VALUE() uint32 {
	return volatile.LoadUint32(&o.CNTVAL.Reg) & 0xffff
}
func (o *DAC_Type) SetCNTVAL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CNTVAL.Reg, volatile.LoadUint32(&o.CNTVAL.Reg)&^(0xffff0000)|value<<16)
}
func (o *DAC_Type) GetCNTVAL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CNTVAL.Reg) & 0xffff0000) >> 16
}

// UART4
type UART4_Type struct {
	RBR           volatile.Register32 // 0x0
	DLM           volatile.Register32 // 0x4
	IIR           volatile.Register32 // 0x8
	LCR           volatile.Register32 // 0xC
	_             [4]byte
	LSR           volatile.Register32 // 0x14
	_             [4]byte
	SCR           volatile.Register32 // 0x1C
	ACR           volatile.Register32 // 0x20
	ICR           volatile.Register32 // 0x24
	FDR           volatile.Register32 // 0x28
	OSR           volatile.Register32 // 0x2C
	_             [24]byte
	SCICTRL       volatile.Register32 // 0x48
	RS485CTRL     volatile.Register32 // 0x4C
	RS485ADRMATCH volatile.Register32 // 0x50
	RS485DLY      volatile.Register32 // 0x54
	SYNCCTRL      volatile.Register32 // 0x58
}

// UART4.RBR: Receiver Buffer Register. Contains the next received character to be read (DLAB =0).
func (o *UART4_Type) SetRBR(value uint32) {
	volatile.StoreUint32(&o.RBR.Reg, volatile.LoadUint32(&o.RBR.Reg)&^(0xff)|value)
}
func (o *UART4_Type) GetRBR() uint32 {
	return volatile.LoadUint32(&o.RBR.Reg) & 0xff
}
func (o *UART4_Type) SetRBR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RBR.Reg, volatile.LoadUint32(&o.RBR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART4_Type) GetRBR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RBR.Reg) & 0xffffff00) >> 8
}

// UART4.DLM: Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider (DLAB =1).
func (o *UART4_Type) SetDLM_DLMSB(value uint32) {
	volatile.StoreUint32(&o.DLM.Reg, volatile.LoadUint32(&o.DLM.Reg)&^(0xff)|value)
}
func (o *UART4_Type) GetDLM_DLMSB() uint32 {
	return volatile.LoadUint32(&o.DLM.Reg) & 0xff
}
func (o *UART4_Type) SetDLM_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DLM.Reg, volatile.LoadUint32(&o.DLM.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART4_Type) GetDLM_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DLM.Reg) & 0xffffff00) >> 8
}

// UART4.IIR: Interrupt ID Register. Identifies which interrupt(s) are pending.
func (o *UART4_Type) SetIIR_INTSTATUS(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0x1)|value)
}
func (o *UART4_Type) GetIIR_INTSTATUS() uint32 {
	return volatile.LoadUint32(&o.IIR.Reg) & 0x1
}
func (o *UART4_Type) SetIIR_INTID(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0xe)|value<<1)
}
func (o *UART4_Type) GetIIR_INTID() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0xe) >> 1
}
func (o *UART4_Type) SetIIR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0x30)|value<<4)
}
func (o *UART4_Type) GetIIR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0x30) >> 4
}
func (o *UART4_Type) SetIIR_FIFOENABLE(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0xc0)|value<<6)
}
func (o *UART4_Type) GetIIR_FIFOENABLE() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0xc0) >> 6
}
func (o *UART4_Type) SetIIR_ABEOINT(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0x100)|value<<8)
}
func (o *UART4_Type) GetIIR_ABEOINT() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0x100) >> 8
}
func (o *UART4_Type) SetIIR_ABTOINT(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0x200)|value<<9)
}
func (o *UART4_Type) GetIIR_ABTOINT() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0x200) >> 9
}
func (o *UART4_Type) SetIIR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0xfffffc00)|value<<10)
}
func (o *UART4_Type) GetIIR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0xfffffc00) >> 10
}

// UART4.LCR: Line Control Register. Contains controls for frame formatting and break generation.
func (o *UART4_Type) SetLCR_WLS(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x3)|value)
}
func (o *UART4_Type) GetLCR_WLS() uint32 {
	return volatile.LoadUint32(&o.LCR.Reg) & 0x3
}
func (o *UART4_Type) SetLCR_SBS(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x4)|value<<2)
}
func (o *UART4_Type) GetLCR_SBS() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x4) >> 2
}
func (o *UART4_Type) SetLCR_PE(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x8)|value<<3)
}
func (o *UART4_Type) GetLCR_PE() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x8) >> 3
}
func (o *UART4_Type) SetLCR_PS(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x30)|value<<4)
}
func (o *UART4_Type) GetLCR_PS() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x30) >> 4
}
func (o *UART4_Type) SetLCR_BC(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x40)|value<<6)
}
func (o *UART4_Type) GetLCR_BC() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x40) >> 6
}
func (o *UART4_Type) SetLCR_DLAB(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x80)|value<<7)
}
func (o *UART4_Type) GetLCR_DLAB() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x80) >> 7
}
func (o *UART4_Type) SetLCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART4_Type) GetLCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0xffffff00) >> 8
}

// UART4.LSR: Line Status Register. Contains flags for transmit and receive status, including line errors.
func (o *UART4_Type) SetLSR_RDR(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x1)|value)
}
func (o *UART4_Type) GetLSR_RDR() uint32 {
	return volatile.LoadUint32(&o.LSR.Reg) & 0x1
}
func (o *UART4_Type) SetLSR_OE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x2)|value<<1)
}
func (o *UART4_Type) GetLSR_OE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x2) >> 1
}
func (o *UART4_Type) SetLSR_PE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x4)|value<<2)
}
func (o *UART4_Type) GetLSR_PE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x4) >> 2
}
func (o *UART4_Type) SetLSR_FE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x8)|value<<3)
}
func (o *UART4_Type) GetLSR_FE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x8) >> 3
}
func (o *UART4_Type) SetLSR_BI(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x10)|value<<4)
}
func (o *UART4_Type) GetLSR_BI() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x10) >> 4
}
func (o *UART4_Type) SetLSR_THRE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x20)|value<<5)
}
func (o *UART4_Type) GetLSR_THRE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x20) >> 5
}
func (o *UART4_Type) SetLSR_TEMT(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x40)|value<<6)
}
func (o *UART4_Type) GetLSR_TEMT() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x40) >> 6
}
func (o *UART4_Type) SetLSR_RXFE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x80)|value<<7)
}
func (o *UART4_Type) GetLSR_RXFE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x80) >> 7
}
func (o *UART4_Type) SetLSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART4_Type) GetLSR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0xffffff00) >> 8
}

// UART4.SCR: Scratch Pad Register. 8-bit temporary storage for software.
func (o *UART4_Type) SetSCR_Pad(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0xff)|value)
}
func (o *UART4_Type) GetSCR_Pad() uint32 {
	return volatile.LoadUint32(&o.SCR.Reg) & 0xff
}
func (o *UART4_Type) SetSCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART4_Type) GetSCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0xffffff00) >> 8
}

// UART4.ACR: Auto-baud Control Register. Contains controls for the auto-baud feature.
func (o *UART4_Type) SetACR_START(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x1)|value)
}
func (o *UART4_Type) GetACR_START() uint32 {
	return volatile.LoadUint32(&o.ACR.Reg) & 0x1
}
func (o *UART4_Type) SetACR_MODE(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x2)|value<<1)
}
func (o *UART4_Type) GetACR_MODE() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x2) >> 1
}
func (o *UART4_Type) SetACR_AUTORESTART(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x4)|value<<2)
}
func (o *UART4_Type) GetACR_AUTORESTART() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x4) >> 2
}
func (o *UART4_Type) SetACR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0xf8)|value<<3)
}
func (o *UART4_Type) GetACR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0xf8) >> 3
}
func (o *UART4_Type) SetACR_ABEOINTCLR(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x100)|value<<8)
}
func (o *UART4_Type) GetACR_ABEOINTCLR() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x100) >> 8
}
func (o *UART4_Type) SetACR_ABTOINTCLR(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x200)|value<<9)
}
func (o *UART4_Type) GetACR_ABTOINTCLR() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x200) >> 9
}
func (o *UART4_Type) SetACR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0xfffffc00)|value<<10)
}
func (o *UART4_Type) GetACR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0xfffffc00) >> 10
}

// UART4.ICR: IrDA Control Register. Enables and configures the IrDA mode.
func (o *UART4_Type) SetICR_IRDAEN(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *UART4_Type) GetICR_IRDAEN() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}
func (o *UART4_Type) SetICR_IRDAINV(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *UART4_Type) GetICR_IRDAINV() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *UART4_Type) SetICR_FIXPULSEEN(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x4)|value<<2)
}
func (o *UART4_Type) GetICR_FIXPULSEEN() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x4) >> 2
}
func (o *UART4_Type) SetICR_PULSEDIV(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x38)|value<<3)
}
func (o *UART4_Type) GetICR_PULSEDIV() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x38) >> 3
}
func (o *UART4_Type) SetICR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0xffffffc0)|value<<6)
}
func (o *UART4_Type) GetICR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0xffffffc0) >> 6
}

// UART4.FDR: Fractional Divider Register. Generates a clock input for the baud rate divider.
func (o *UART4_Type) SetFDR_DIVADDVAL(value uint32) {
	volatile.StoreUint32(&o.FDR.Reg, volatile.LoadUint32(&o.FDR.Reg)&^(0xf)|value)
}
func (o *UART4_Type) GetFDR_DIVADDVAL() uint32 {
	return volatile.LoadUint32(&o.FDR.Reg) & 0xf
}
func (o *UART4_Type) SetFDR_MULVAL(value uint32) {
	volatile.StoreUint32(&o.FDR.Reg, volatile.LoadUint32(&o.FDR.Reg)&^(0xf0)|value<<4)
}
func (o *UART4_Type) GetFDR_MULVAL() uint32 {
	return (volatile.LoadUint32(&o.FDR.Reg) & 0xf0) >> 4
}
func (o *UART4_Type) SetFDR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FDR.Reg, volatile.LoadUint32(&o.FDR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART4_Type) GetFDR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FDR.Reg) & 0xffffff00) >> 8
}

// UART4.OSR: Oversampling register. Controls the degree of oversampling during each bit time.
func (o *UART4_Type) SetOSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x1)|value)
}
func (o *UART4_Type) GetOSR_RESERVED() uint32 {
	return volatile.LoadUint32(&o.OSR.Reg) & 0x1
}
func (o *UART4_Type) SetOSR_OSFRAC(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0xe)|value<<1)
}
func (o *UART4_Type) GetOSR_OSFRAC() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0xe) >> 1
}
func (o *UART4_Type) SetOSR_OSINT(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0xf0)|value<<4)
}
func (o *UART4_Type) GetOSR_OSINT() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0xf0) >> 4
}
func (o *UART4_Type) SetOSR_FDINT(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0x7f00)|value<<8)
}
func (o *UART4_Type) GetOSR_FDINT() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0x7f00) >> 8
}
func (o *UART4_Type) SetOSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.OSR.Reg, volatile.LoadUint32(&o.OSR.Reg)&^(0xffff8000)|value<<15)
}
func (o *UART4_Type) GetOSR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.OSR.Reg) & 0xffff8000) >> 15
}

// UART4.SCICTRL: Smart Card Interface control register. Enables and configures the smartcard Interface feature.
func (o *UART4_Type) SetSCICTRL_SCIEN(value uint32) {
	volatile.StoreUint32(&o.SCICTRL.Reg, volatile.LoadUint32(&o.SCICTRL.Reg)&^(0x1)|value)
}
func (o *UART4_Type) GetSCICTRL_SCIEN() uint32 {
	return volatile.LoadUint32(&o.SCICTRL.Reg) & 0x1
}
func (o *UART4_Type) SetSCICTRL_NACKDIS(value uint32) {
	volatile.StoreUint32(&o.SCICTRL.Reg, volatile.LoadUint32(&o.SCICTRL.Reg)&^(0x2)|value<<1)
}
func (o *UART4_Type) GetSCICTRL_NACKDIS() uint32 {
	return (volatile.LoadUint32(&o.SCICTRL.Reg) & 0x2) >> 1
}
func (o *UART4_Type) SetSCICTRL_PROTSEL(value uint32) {
	volatile.StoreUint32(&o.SCICTRL.Reg, volatile.LoadUint32(&o.SCICTRL.Reg)&^(0x4)|value<<2)
}
func (o *UART4_Type) GetSCICTRL_PROTSEL() uint32 {
	return (volatile.LoadUint32(&o.SCICTRL.Reg) & 0x4) >> 2
}
func (o *UART4_Type) SetSCICTRL_TXRETRY(value uint32) {
	volatile.StoreUint32(&o.SCICTRL.Reg, volatile.LoadUint32(&o.SCICTRL.Reg)&^(0xe0)|value<<5)
}
func (o *UART4_Type) GetSCICTRL_TXRETRY() uint32 {
	return (volatile.LoadUint32(&o.SCICTRL.Reg) & 0xe0) >> 5
}
func (o *UART4_Type) SetSCICTRL_GUARDTIME(value uint32) {
	volatile.StoreUint32(&o.SCICTRL.Reg, volatile.LoadUint32(&o.SCICTRL.Reg)&^(0xff00)|value<<8)
}
func (o *UART4_Type) GetSCICTRL_GUARDTIME() uint32 {
	return (volatile.LoadUint32(&o.SCICTRL.Reg) & 0xff00) >> 8
}
func (o *UART4_Type) SetSCICTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SCICTRL.Reg, volatile.LoadUint32(&o.SCICTRL.Reg)&^(0xffff0000)|value<<16)
}
func (o *UART4_Type) GetSCICTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SCICTRL.Reg) & 0xffff0000) >> 16
}

// UART4.RS485CTRL: RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes.
func (o *UART4_Type) SetRS485CTRL_NMMEN(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x1)|value)
}
func (o *UART4_Type) GetRS485CTRL_NMMEN() uint32 {
	return volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x1
}
func (o *UART4_Type) SetRS485CTRL_RXDIS(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x2)|value<<1)
}
func (o *UART4_Type) GetRS485CTRL_RXDIS() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x2) >> 1
}
func (o *UART4_Type) SetRS485CTRL_AADEN(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x4)|value<<2)
}
func (o *UART4_Type) GetRS485CTRL_AADEN() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x4) >> 2
}
func (o *UART4_Type) SetRS485CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x8)|value<<3)
}
func (o *UART4_Type) GetRS485CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x8) >> 3
}
func (o *UART4_Type) SetRS485CTRL_DCTRL(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x10)|value<<4)
}
func (o *UART4_Type) GetRS485CTRL_DCTRL() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x10) >> 4
}
func (o *UART4_Type) SetRS485CTRL_OINV(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x20)|value<<5)
}
func (o *UART4_Type) GetRS485CTRL_OINV() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x20) >> 5
}
func (o *UART4_Type) SetRS485CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0xffffffc0)|value<<6)
}
func (o *UART4_Type) GetRS485CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0xffffffc0) >> 6
}

// UART4.RS485ADRMATCH: RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode.
func (o *UART4_Type) SetRS485ADRMATCH_ADRMATCH(value uint32) {
	volatile.StoreUint32(&o.RS485ADRMATCH.Reg, volatile.LoadUint32(&o.RS485ADRMATCH.Reg)&^(0xff)|value)
}
func (o *UART4_Type) GetRS485ADRMATCH_ADRMATCH() uint32 {
	return volatile.LoadUint32(&o.RS485ADRMATCH.Reg) & 0xff
}
func (o *UART4_Type) SetRS485ADRMATCH_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RS485ADRMATCH.Reg, volatile.LoadUint32(&o.RS485ADRMATCH.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART4_Type) GetRS485ADRMATCH_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RS485ADRMATCH.Reg) & 0xffffff00) >> 8
}

// UART4.RS485DLY: RS-485/EIA-485 direction control delay.
func (o *UART4_Type) SetRS485DLY_DLY(value uint32) {
	volatile.StoreUint32(&o.RS485DLY.Reg, volatile.LoadUint32(&o.RS485DLY.Reg)&^(0xff)|value)
}
func (o *UART4_Type) GetRS485DLY_DLY() uint32 {
	return volatile.LoadUint32(&o.RS485DLY.Reg) & 0xff
}
func (o *UART4_Type) SetRS485DLY_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RS485DLY.Reg, volatile.LoadUint32(&o.RS485DLY.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART4_Type) GetRS485DLY_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RS485DLY.Reg) & 0xffffff00) >> 8
}

// UART4.SYNCCTRL: Synchronous mode control register.
func (o *UART4_Type) SetSYNCCTRL_SYNC(value uint32) {
	volatile.StoreUint32(&o.SYNCCTRL.Reg, volatile.LoadUint32(&o.SYNCCTRL.Reg)&^(0x1)|value)
}
func (o *UART4_Type) GetSYNCCTRL_SYNC() uint32 {
	return volatile.LoadUint32(&o.SYNCCTRL.Reg) & 0x1
}
func (o *UART4_Type) SetSYNCCTRL_CSRC(value uint32) {
	volatile.StoreUint32(&o.SYNCCTRL.Reg, volatile.LoadUint32(&o.SYNCCTRL.Reg)&^(0x2)|value<<1)
}
func (o *UART4_Type) GetSYNCCTRL_CSRC() uint32 {
	return (volatile.LoadUint32(&o.SYNCCTRL.Reg) & 0x2) >> 1
}
func (o *UART4_Type) SetSYNCCTRL_FES(value uint32) {
	volatile.StoreUint32(&o.SYNCCTRL.Reg, volatile.LoadUint32(&o.SYNCCTRL.Reg)&^(0x4)|value<<2)
}
func (o *UART4_Type) GetSYNCCTRL_FES() uint32 {
	return (volatile.LoadUint32(&o.SYNCCTRL.Reg) & 0x4) >> 2
}
func (o *UART4_Type) SetSYNCCTRL_TSBYPASS(value uint32) {
	volatile.StoreUint32(&o.SYNCCTRL.Reg, volatile.LoadUint32(&o.SYNCCTRL.Reg)&^(0x8)|value<<3)
}
func (o *UART4_Type) GetSYNCCTRL_TSBYPASS() uint32 {
	return (volatile.LoadUint32(&o.SYNCCTRL.Reg) & 0x8) >> 3
}
func (o *UART4_Type) SetSYNCCTRL_CSCEN(value uint32) {
	volatile.StoreUint32(&o.SYNCCTRL.Reg, volatile.LoadUint32(&o.SYNCCTRL.Reg)&^(0x10)|value<<4)
}
func (o *UART4_Type) GetSYNCCTRL_CSCEN() uint32 {
	return (volatile.LoadUint32(&o.SYNCCTRL.Reg) & 0x10) >> 4
}
func (o *UART4_Type) SetSYNCCTRL_SSSDIS(value uint32) {
	volatile.StoreUint32(&o.SYNCCTRL.Reg, volatile.LoadUint32(&o.SYNCCTRL.Reg)&^(0x20)|value<<5)
}
func (o *UART4_Type) GetSYNCCTRL_SSSDIS() uint32 {
	return (volatile.LoadUint32(&o.SYNCCTRL.Reg) & 0x20) >> 5
}
func (o *UART4_Type) SetSYNCCTRL_CCCLR(value uint32) {
	volatile.StoreUint32(&o.SYNCCTRL.Reg, volatile.LoadUint32(&o.SYNCCTRL.Reg)&^(0x40)|value<<6)
}
func (o *UART4_Type) GetSYNCCTRL_CCCLR() uint32 {
	return (volatile.LoadUint32(&o.SYNCCTRL.Reg) & 0x40) >> 6
}
func (o *UART4_Type) SetSYNCCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SYNCCTRL.Reg, volatile.LoadUint32(&o.SYNCCTRL.Reg)&^(0xffffffc0)|value<<6)
}
func (o *UART4_Type) GetSYNCCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SYNCCTRL.Reg) & 0xffffffc0) >> 6
}

// I2S interface
type I2S_Type struct {
	DAO       volatile.Register32 // 0x0
	DAI       volatile.Register32 // 0x4
	TXFIFO    volatile.Register32 // 0x8
	RXFIFO    volatile.Register32 // 0xC
	STATE     volatile.Register32 // 0x10
	DMA1      volatile.Register32 // 0x14
	DMA2      volatile.Register32 // 0x18
	IRQ       volatile.Register32 // 0x1C
	TXRATE    volatile.Register32 // 0x20
	RXRATE    volatile.Register32 // 0x24
	TXBITRATE volatile.Register32 // 0x28
	RXBITRATE volatile.Register32 // 0x2C
	TXMODE    volatile.Register32 // 0x30
	RXMODE    volatile.Register32 // 0x34
}

// I2S.DAO: I2S Digital Audio Output Register. Contains control bits for the I2S transmit channel.
func (o *I2S_Type) SetDAO_WORDWIDTH(value uint32) {
	volatile.StoreUint32(&o.DAO.Reg, volatile.LoadUint32(&o.DAO.Reg)&^(0x3)|value)
}
func (o *I2S_Type) GetDAO_WORDWIDTH() uint32 {
	return volatile.LoadUint32(&o.DAO.Reg) & 0x3
}
func (o *I2S_Type) SetDAO_MONO(value uint32) {
	volatile.StoreUint32(&o.DAO.Reg, volatile.LoadUint32(&o.DAO.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetDAO_MONO() uint32 {
	return (volatile.LoadUint32(&o.DAO.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetDAO_STOP(value uint32) {
	volatile.StoreUint32(&o.DAO.Reg, volatile.LoadUint32(&o.DAO.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetDAO_STOP() uint32 {
	return (volatile.LoadUint32(&o.DAO.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetDAO_RESET(value uint32) {
	volatile.StoreUint32(&o.DAO.Reg, volatile.LoadUint32(&o.DAO.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetDAO_RESET() uint32 {
	return (volatile.LoadUint32(&o.DAO.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetDAO_WS_SEL(value uint32) {
	volatile.StoreUint32(&o.DAO.Reg, volatile.LoadUint32(&o.DAO.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetDAO_WS_SEL() uint32 {
	return (volatile.LoadUint32(&o.DAO.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetDAO_WS_HALFPERIOD(value uint32) {
	volatile.StoreUint32(&o.DAO.Reg, volatile.LoadUint32(&o.DAO.Reg)&^(0x7fc0)|value<<6)
}
func (o *I2S_Type) GetDAO_WS_HALFPERIOD() uint32 {
	return (volatile.LoadUint32(&o.DAO.Reg) & 0x7fc0) >> 6
}
func (o *I2S_Type) SetDAO_MUTE(value uint32) {
	volatile.StoreUint32(&o.DAO.Reg, volatile.LoadUint32(&o.DAO.Reg)&^(0x8000)|value<<15)
}
func (o *I2S_Type) GetDAO_MUTE() uint32 {
	return (volatile.LoadUint32(&o.DAO.Reg) & 0x8000) >> 15
}
func (o *I2S_Type) SetDAO_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DAO.Reg, volatile.LoadUint32(&o.DAO.Reg)&^(0xffff0000)|value<<16)
}
func (o *I2S_Type) GetDAO_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DAO.Reg) & 0xffff0000) >> 16
}

// I2S.DAI: I2S Digital Audio Input Register. Contains control bits for the I2S receive channel.
func (o *I2S_Type) SetDAI_WORDWIDTH(value uint32) {
	volatile.StoreUint32(&o.DAI.Reg, volatile.LoadUint32(&o.DAI.Reg)&^(0x3)|value)
}
func (o *I2S_Type) GetDAI_WORDWIDTH() uint32 {
	return volatile.LoadUint32(&o.DAI.Reg) & 0x3
}
func (o *I2S_Type) SetDAI_MONO(value uint32) {
	volatile.StoreUint32(&o.DAI.Reg, volatile.LoadUint32(&o.DAI.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetDAI_MONO() uint32 {
	return (volatile.LoadUint32(&o.DAI.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetDAI_STOP(value uint32) {
	volatile.StoreUint32(&o.DAI.Reg, volatile.LoadUint32(&o.DAI.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetDAI_STOP() uint32 {
	return (volatile.LoadUint32(&o.DAI.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetDAI_RESET(value uint32) {
	volatile.StoreUint32(&o.DAI.Reg, volatile.LoadUint32(&o.DAI.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetDAI_RESET() uint32 {
	return (volatile.LoadUint32(&o.DAI.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetDAI_WS_SEL(value uint32) {
	volatile.StoreUint32(&o.DAI.Reg, volatile.LoadUint32(&o.DAI.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetDAI_WS_SEL() uint32 {
	return (volatile.LoadUint32(&o.DAI.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetDAI_WS_HALFPERIOD(value uint32) {
	volatile.StoreUint32(&o.DAI.Reg, volatile.LoadUint32(&o.DAI.Reg)&^(0x7fc0)|value<<6)
}
func (o *I2S_Type) GetDAI_WS_HALFPERIOD() uint32 {
	return (volatile.LoadUint32(&o.DAI.Reg) & 0x7fc0) >> 6
}
func (o *I2S_Type) SetDAI_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DAI.Reg, volatile.LoadUint32(&o.DAI.Reg)&^(0xffff8000)|value<<15)
}
func (o *I2S_Type) GetDAI_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DAI.Reg) & 0xffff8000) >> 15
}

// I2S.TXFIFO: I2S Transmit FIFO. Access register for the 8 x 32-bit transmitter FIFO.
func (o *I2S_Type) SetTXFIFO(value uint32) {
	volatile.StoreUint32(&o.TXFIFO.Reg, value)
}
func (o *I2S_Type) GetTXFIFO() uint32 {
	return volatile.LoadUint32(&o.TXFIFO.Reg)
}

// I2S.RXFIFO: I2S Receive FIFO. Access register for the 8 x 32-bit receiver FIFO.
func (o *I2S_Type) SetRXFIFO(value uint32) {
	volatile.StoreUint32(&o.RXFIFO.Reg, value)
}
func (o *I2S_Type) GetRXFIFO() uint32 {
	return volatile.LoadUint32(&o.RXFIFO.Reg)
}

// I2S.STATE: I2S Status Feedback Register. Contains status information about the I2S interface.
func (o *I2S_Type) SetSTATE_IRQ(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetSTATE_IRQ() uint32 {
	return volatile.LoadUint32(&o.STATE.Reg) & 0x1
}
func (o *I2S_Type) SetSTATE_DMAREQ1(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetSTATE_DMAREQ1() uint32 {
	return (volatile.LoadUint32(&o.STATE.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetSTATE_DMAREQ2(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetSTATE_DMAREQ2() uint32 {
	return (volatile.LoadUint32(&o.STATE.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetSTATE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0xf8)|value<<3)
}
func (o *I2S_Type) GetSTATE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATE.Reg) & 0xf8) >> 3
}
func (o *I2S_Type) SetSTATE_RX_LEVEL(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0xf00)|value<<8)
}
func (o *I2S_Type) GetSTATE_RX_LEVEL() uint32 {
	return (volatile.LoadUint32(&o.STATE.Reg) & 0xf00) >> 8
}
func (o *I2S_Type) SetSTATE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0xf000)|value<<12)
}
func (o *I2S_Type) GetSTATE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATE.Reg) & 0xf000) >> 12
}
func (o *I2S_Type) SetSTATE_TX_LEVEL(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0xf0000)|value<<16)
}
func (o *I2S_Type) GetSTATE_TX_LEVEL() uint32 {
	return (volatile.LoadUint32(&o.STATE.Reg) & 0xf0000) >> 16
}
func (o *I2S_Type) SetSTATE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATE.Reg, volatile.LoadUint32(&o.STATE.Reg)&^(0xfff00000)|value<<20)
}
func (o *I2S_Type) GetSTATE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATE.Reg) & 0xfff00000) >> 20
}

// I2S.DMA1: I2S DMA Configuration Register 1. Contains control information for DMA request 1.
func (o *I2S_Type) SetDMA1_RX_DMA1_ENABLE(value uint32) {
	volatile.StoreUint32(&o.DMA1.Reg, volatile.LoadUint32(&o.DMA1.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetDMA1_RX_DMA1_ENABLE() uint32 {
	return volatile.LoadUint32(&o.DMA1.Reg) & 0x1
}
func (o *I2S_Type) SetDMA1_TX_DMA1_ENABLE(value uint32) {
	volatile.StoreUint32(&o.DMA1.Reg, volatile.LoadUint32(&o.DMA1.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetDMA1_TX_DMA1_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.DMA1.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetDMA1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMA1.Reg, volatile.LoadUint32(&o.DMA1.Reg)&^(0xfc)|value<<2)
}
func (o *I2S_Type) GetDMA1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMA1.Reg) & 0xfc) >> 2
}
func (o *I2S_Type) SetDMA1_RX_DEPTH_DMA1(value uint32) {
	volatile.StoreUint32(&o.DMA1.Reg, volatile.LoadUint32(&o.DMA1.Reg)&^(0xf00)|value<<8)
}
func (o *I2S_Type) GetDMA1_RX_DEPTH_DMA1() uint32 {
	return (volatile.LoadUint32(&o.DMA1.Reg) & 0xf00) >> 8
}
func (o *I2S_Type) SetDMA1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMA1.Reg, volatile.LoadUint32(&o.DMA1.Reg)&^(0xf000)|value<<12)
}
func (o *I2S_Type) GetDMA1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMA1.Reg) & 0xf000) >> 12
}
func (o *I2S_Type) SetDMA1_TX_DEPTH_DMA1(value uint32) {
	volatile.StoreUint32(&o.DMA1.Reg, volatile.LoadUint32(&o.DMA1.Reg)&^(0xf0000)|value<<16)
}
func (o *I2S_Type) GetDMA1_TX_DEPTH_DMA1() uint32 {
	return (volatile.LoadUint32(&o.DMA1.Reg) & 0xf0000) >> 16
}
func (o *I2S_Type) SetDMA1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMA1.Reg, volatile.LoadUint32(&o.DMA1.Reg)&^(0xfff00000)|value<<20)
}
func (o *I2S_Type) GetDMA1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMA1.Reg) & 0xfff00000) >> 20
}

// I2S.DMA2: I2S DMA Configuration Register 2. Contains control information for DMA request 2.
func (o *I2S_Type) SetDMA2_RX_DMA2_ENABLE(value uint32) {
	volatile.StoreUint32(&o.DMA2.Reg, volatile.LoadUint32(&o.DMA2.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetDMA2_RX_DMA2_ENABLE() uint32 {
	return volatile.LoadUint32(&o.DMA2.Reg) & 0x1
}
func (o *I2S_Type) SetDMA2_TX_DMA2_ENABLE(value uint32) {
	volatile.StoreUint32(&o.DMA2.Reg, volatile.LoadUint32(&o.DMA2.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetDMA2_TX_DMA2_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.DMA2.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetDMA2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMA2.Reg, volatile.LoadUint32(&o.DMA2.Reg)&^(0xfc)|value<<2)
}
func (o *I2S_Type) GetDMA2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMA2.Reg) & 0xfc) >> 2
}
func (o *I2S_Type) SetDMA2_RX_DEPTH_DMA2(value uint32) {
	volatile.StoreUint32(&o.DMA2.Reg, volatile.LoadUint32(&o.DMA2.Reg)&^(0xf00)|value<<8)
}
func (o *I2S_Type) GetDMA2_RX_DEPTH_DMA2() uint32 {
	return (volatile.LoadUint32(&o.DMA2.Reg) & 0xf00) >> 8
}
func (o *I2S_Type) SetDMA2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMA2.Reg, volatile.LoadUint32(&o.DMA2.Reg)&^(0xf000)|value<<12)
}
func (o *I2S_Type) GetDMA2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMA2.Reg) & 0xf000) >> 12
}
func (o *I2S_Type) SetDMA2_TX_DEPTH_DMA2(value uint32) {
	volatile.StoreUint32(&o.DMA2.Reg, volatile.LoadUint32(&o.DMA2.Reg)&^(0xf0000)|value<<16)
}
func (o *I2S_Type) GetDMA2_TX_DEPTH_DMA2() uint32 {
	return (volatile.LoadUint32(&o.DMA2.Reg) & 0xf0000) >> 16
}
func (o *I2S_Type) SetDMA2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMA2.Reg, volatile.LoadUint32(&o.DMA2.Reg)&^(0xfff00000)|value<<20)
}
func (o *I2S_Type) GetDMA2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMA2.Reg) & 0xfff00000) >> 20
}

// I2S.IRQ: I2S Interrupt Request Control Register. Contains bits that control how the I2S interrupt request is generated.
func (o *I2S_Type) SetIRQ_RX_IRQ_ENABLE(value uint32) {
	volatile.StoreUint32(&o.IRQ.Reg, volatile.LoadUint32(&o.IRQ.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetIRQ_RX_IRQ_ENABLE() uint32 {
	return volatile.LoadUint32(&o.IRQ.Reg) & 0x1
}
func (o *I2S_Type) SetIRQ_TX_IRQ_ENABLE(value uint32) {
	volatile.StoreUint32(&o.IRQ.Reg, volatile.LoadUint32(&o.IRQ.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetIRQ_TX_IRQ_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.IRQ.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetIRQ_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IRQ.Reg, volatile.LoadUint32(&o.IRQ.Reg)&^(0xfc)|value<<2)
}
func (o *I2S_Type) GetIRQ_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IRQ.Reg) & 0xfc) >> 2
}
func (o *I2S_Type) SetIRQ_RX_DEPTH_IRQ(value uint32) {
	volatile.StoreUint32(&o.IRQ.Reg, volatile.LoadUint32(&o.IRQ.Reg)&^(0xf00)|value<<8)
}
func (o *I2S_Type) GetIRQ_RX_DEPTH_IRQ() uint32 {
	return (volatile.LoadUint32(&o.IRQ.Reg) & 0xf00) >> 8
}
func (o *I2S_Type) SetIRQ_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IRQ.Reg, volatile.LoadUint32(&o.IRQ.Reg)&^(0xf000)|value<<12)
}
func (o *I2S_Type) GetIRQ_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IRQ.Reg) & 0xf000) >> 12
}
func (o *I2S_Type) SetIRQ_TX_DEPTH_IRQ(value uint32) {
	volatile.StoreUint32(&o.IRQ.Reg, volatile.LoadUint32(&o.IRQ.Reg)&^(0xf0000)|value<<16)
}
func (o *I2S_Type) GetIRQ_TX_DEPTH_IRQ() uint32 {
	return (volatile.LoadUint32(&o.IRQ.Reg) & 0xf0000) >> 16
}
func (o *I2S_Type) SetIRQ_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IRQ.Reg, volatile.LoadUint32(&o.IRQ.Reg)&^(0xfff00000)|value<<20)
}
func (o *I2S_Type) GetIRQ_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IRQ.Reg) & 0xfff00000) >> 20
}

// I2S.TXRATE: I2S Transmit MCLK divider. This register determines the I2S TX MCLK rate by specifying the value to divide PCLK by in order to produce MCLK.
func (o *I2S_Type) SetTXRATE_Y_DIVIDER(value uint32) {
	volatile.StoreUint32(&o.TXRATE.Reg, volatile.LoadUint32(&o.TXRATE.Reg)&^(0xff)|value)
}
func (o *I2S_Type) GetTXRATE_Y_DIVIDER() uint32 {
	return volatile.LoadUint32(&o.TXRATE.Reg) & 0xff
}
func (o *I2S_Type) SetTXRATE_X_DIVIDER(value uint32) {
	volatile.StoreUint32(&o.TXRATE.Reg, volatile.LoadUint32(&o.TXRATE.Reg)&^(0xff00)|value<<8)
}
func (o *I2S_Type) GetTXRATE_X_DIVIDER() uint32 {
	return (volatile.LoadUint32(&o.TXRATE.Reg) & 0xff00) >> 8
}
func (o *I2S_Type) SetTXRATE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TXRATE.Reg, volatile.LoadUint32(&o.TXRATE.Reg)&^(0xffff0000)|value<<16)
}
func (o *I2S_Type) GetTXRATE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TXRATE.Reg) & 0xffff0000) >> 16
}

// I2S.RXRATE: I2S Receive MCLK divider. This register determines the I2S RX MCLK rate by specifying the value to divide PCLK by in order to produce MCLK.
func (o *I2S_Type) SetRXRATE_Y_DIVIDER(value uint32) {
	volatile.StoreUint32(&o.RXRATE.Reg, volatile.LoadUint32(&o.RXRATE.Reg)&^(0xff)|value)
}
func (o *I2S_Type) GetRXRATE_Y_DIVIDER() uint32 {
	return volatile.LoadUint32(&o.RXRATE.Reg) & 0xff
}
func (o *I2S_Type) SetRXRATE_X_DIVIDER(value uint32) {
	volatile.StoreUint32(&o.RXRATE.Reg, volatile.LoadUint32(&o.RXRATE.Reg)&^(0xff00)|value<<8)
}
func (o *I2S_Type) GetRXRATE_X_DIVIDER() uint32 {
	return (volatile.LoadUint32(&o.RXRATE.Reg) & 0xff00) >> 8
}
func (o *I2S_Type) SetRXRATE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RXRATE.Reg, volatile.LoadUint32(&o.RXRATE.Reg)&^(0xffff0000)|value<<16)
}
func (o *I2S_Type) GetRXRATE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RXRATE.Reg) & 0xffff0000) >> 16
}

// I2S.TXBITRATE: I2S Transmit bit rate divider. This register determines the I2S transmit bit rate by specifying the value to divide TX_MCLK by in order to produce the transmit bit clock.
func (o *I2S_Type) SetTXBITRATE_TX_BITRATE(value uint32) {
	volatile.StoreUint32(&o.TXBITRATE.Reg, volatile.LoadUint32(&o.TXBITRATE.Reg)&^(0x3f)|value)
}
func (o *I2S_Type) GetTXBITRATE_TX_BITRATE() uint32 {
	return volatile.LoadUint32(&o.TXBITRATE.Reg) & 0x3f
}
func (o *I2S_Type) SetTXBITRATE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TXBITRATE.Reg, volatile.LoadUint32(&o.TXBITRATE.Reg)&^(0xffffffc0)|value<<6)
}
func (o *I2S_Type) GetTXBITRATE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TXBITRATE.Reg) & 0xffffffc0) >> 6
}

// I2S.RXBITRATE: I2S Receive bit rate divider. This register determines the I2S receive bit rate by specifying the value to divide RX_MCLK by in order to produce the receive bit clock.
func (o *I2S_Type) SetRXBITRATE_RX_BITRATE(value uint32) {
	volatile.StoreUint32(&o.RXBITRATE.Reg, volatile.LoadUint32(&o.RXBITRATE.Reg)&^(0x3f)|value)
}
func (o *I2S_Type) GetRXBITRATE_RX_BITRATE() uint32 {
	return volatile.LoadUint32(&o.RXBITRATE.Reg) & 0x3f
}
func (o *I2S_Type) SetRXBITRATE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RXBITRATE.Reg, volatile.LoadUint32(&o.RXBITRATE.Reg)&^(0xffffffc0)|value<<6)
}
func (o *I2S_Type) GetRXBITRATE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RXBITRATE.Reg) & 0xffffffc0) >> 6
}

// I2S.TXMODE: I2S Transmit mode control.
func (o *I2S_Type) SetTXMODE_TXCLKSEL(value uint32) {
	volatile.StoreUint32(&o.TXMODE.Reg, volatile.LoadUint32(&o.TXMODE.Reg)&^(0x3)|value)
}
func (o *I2S_Type) GetTXMODE_TXCLKSEL() uint32 {
	return volatile.LoadUint32(&o.TXMODE.Reg) & 0x3
}
func (o *I2S_Type) SetTXMODE_TX4PIN(value uint32) {
	volatile.StoreUint32(&o.TXMODE.Reg, volatile.LoadUint32(&o.TXMODE.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetTXMODE_TX4PIN() uint32 {
	return (volatile.LoadUint32(&o.TXMODE.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetTXMODE_TXMCENA(value uint32) {
	volatile.StoreUint32(&o.TXMODE.Reg, volatile.LoadUint32(&o.TXMODE.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetTXMODE_TXMCENA() uint32 {
	return (volatile.LoadUint32(&o.TXMODE.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetTXMODE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TXMODE.Reg, volatile.LoadUint32(&o.TXMODE.Reg)&^(0xfffffff0)|value<<4)
}
func (o *I2S_Type) GetTXMODE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TXMODE.Reg) & 0xfffffff0) >> 4
}

// I2S.RXMODE: I2S Receive mode control.
func (o *I2S_Type) SetRXMODE_RXCLKSEL(value uint32) {
	volatile.StoreUint32(&o.RXMODE.Reg, volatile.LoadUint32(&o.RXMODE.Reg)&^(0x3)|value)
}
func (o *I2S_Type) GetRXMODE_RXCLKSEL() uint32 {
	return volatile.LoadUint32(&o.RXMODE.Reg) & 0x3
}
func (o *I2S_Type) SetRXMODE_RX4PIN(value uint32) {
	volatile.StoreUint32(&o.RXMODE.Reg, volatile.LoadUint32(&o.RXMODE.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetRXMODE_RX4PIN() uint32 {
	return (volatile.LoadUint32(&o.RXMODE.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetRXMODE_RXMCENA(value uint32) {
	volatile.StoreUint32(&o.RXMODE.Reg, volatile.LoadUint32(&o.RXMODE.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetRXMODE_RXMCENA() uint32 {
	return (volatile.LoadUint32(&o.RXMODE.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetRXMODE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RXMODE.Reg, volatile.LoadUint32(&o.RXMODE.Reg)&^(0xfffffff0)|value<<4)
}
func (o *I2S_Type) GetRXMODE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RXMODE.Reg) & 0xfffffff0) >> 4
}

// Motor Control PWM
type MCPWM_Type struct {
	CON        volatile.Register32    // 0x0
	CON_SET    volatile.Register32    // 0x4
	CON_CLR    volatile.Register32    // 0x8
	CAPCON     volatile.Register32    // 0xC
	CAPCON_SET volatile.Register32    // 0x10
	CAPCON_CLR volatile.Register32    // 0x14
	TC         [3]volatile.Register32 // 0x18
	LIM        [3]volatile.Register32 // 0x24
	MAT        [3]volatile.Register32 // 0x30
	DT         volatile.Register32    // 0x3C
	CCP        volatile.Register32    // 0x40
	CAP        [3]volatile.Register32 // 0x44
	INTEN      volatile.Register32    // 0x50
	INTEN_SET  volatile.Register32    // 0x54
	INTEN_CLR  volatile.Register32    // 0x58
	CNTCON     volatile.Register32    // 0x5C
	CNTCON_SET volatile.Register32    // 0x60
	CNTCON_CLR volatile.Register32    // 0x64
	INTF       volatile.Register32    // 0x68
	INTF_SET   volatile.Register32    // 0x6C
	INTF_CLR   volatile.Register32    // 0x70
	CAP_CLR    volatile.Register32    // 0x74
}

// MCPWM.CON: PWM Control read address
func (o *MCPWM_Type) SetCON_RUN0(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCON_RUN0() uint32 {
	return volatile.LoadUint32(&o.CON.Reg) & 0x1
}
func (o *MCPWM_Type) SetCON_CENTER0(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetCON_CENTER0() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetCON_POLA0(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetCON_POLA0() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetCON_DTE0(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetCON_DTE0() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetCON_DISUP0(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetCON_DISUP0() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetCON_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0xe0)|value<<5)
}
func (o *MCPWM_Type) GetCON_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0xe0) >> 5
}
func (o *MCPWM_Type) SetCON_RUN1(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetCON_RUN1() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetCON_CENTER1(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetCON_CENTER1() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetCON_POLA1(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetCON_POLA1() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetCON_DTE1(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetCON_DTE1() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetCON_DISUP1(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetCON_DISUP1() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetCON_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0xe000)|value<<13)
}
func (o *MCPWM_Type) GetCON_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0xe000) >> 13
}
func (o *MCPWM_Type) SetCON_RUN2(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetCON_RUN2() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x10000) >> 16
}
func (o *MCPWM_Type) SetCON_CENTER2(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x20000)|value<<17)
}
func (o *MCPWM_Type) GetCON_CENTER2() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x20000) >> 17
}
func (o *MCPWM_Type) SetCON_POLA2(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x40000)|value<<18)
}
func (o *MCPWM_Type) GetCON_POLA2() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x40000) >> 18
}
func (o *MCPWM_Type) SetCON_DTE2(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x80000)|value<<19)
}
func (o *MCPWM_Type) GetCON_DTE2() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x80000) >> 19
}
func (o *MCPWM_Type) SetCON_DISUP2(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x100000)|value<<20)
}
func (o *MCPWM_Type) GetCON_DISUP2() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x100000) >> 20
}
func (o *MCPWM_Type) SetCON_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x1fe00000)|value<<21)
}
func (o *MCPWM_Type) GetCON_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x1fe00000) >> 21
}
func (o *MCPWM_Type) SetCON_INVBDC(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x20000000)|value<<29)
}
func (o *MCPWM_Type) GetCON_INVBDC() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x20000000) >> 29
}
func (o *MCPWM_Type) SetCON_ACMODE(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x40000000)|value<<30)
}
func (o *MCPWM_Type) GetCON_ACMODE() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x40000000) >> 30
}
func (o *MCPWM_Type) SetCON_DCMODE(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x80000000)|value<<31)
}
func (o *MCPWM_Type) GetCON_DCMODE() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x80000000) >> 31
}

// MCPWM.CON_SET: PWM Control set address
func (o *MCPWM_Type) SetCON_SET_RUN0_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCON_SET_RUN0_SET() uint32 {
	return volatile.LoadUint32(&o.CON_SET.Reg) & 0x1
}
func (o *MCPWM_Type) SetCON_SET_CENTER0_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetCON_SET_CENTER0_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetCON_SET_POLA0_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetCON_SET_POLA0_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetCON_SET_DTE0_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetCON_SET_DTE0_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetCON_SET_DISUP0_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetCON_SET_DISUP0_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetCON_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0xe0)|value<<5)
}
func (o *MCPWM_Type) GetCON_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0xe0) >> 5
}
func (o *MCPWM_Type) SetCON_SET_RUN1_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetCON_SET_RUN1_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetCON_SET_CENTER1_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetCON_SET_CENTER1_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetCON_SET_POLA1_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetCON_SET_POLA1_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetCON_SET_DTE1_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetCON_SET_DTE1_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetCON_SET_DISUP1_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetCON_SET_DISUP1_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetCON_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0xe000)|value<<13)
}
func (o *MCPWM_Type) GetCON_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0xe000) >> 13
}
func (o *MCPWM_Type) SetCON_SET_RUN2_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetCON_SET_RUN2_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x10000) >> 16
}
func (o *MCPWM_Type) SetCON_SET_CENTER2_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x20000)|value<<17)
}
func (o *MCPWM_Type) GetCON_SET_CENTER2_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x20000) >> 17
}
func (o *MCPWM_Type) SetCON_SET_POLA2_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x40000)|value<<18)
}
func (o *MCPWM_Type) GetCON_SET_POLA2_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x40000) >> 18
}
func (o *MCPWM_Type) SetCON_SET_DTE2_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x80000)|value<<19)
}
func (o *MCPWM_Type) GetCON_SET_DTE2_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x80000) >> 19
}
func (o *MCPWM_Type) SetCON_SET_DISUP2_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x100000)|value<<20)
}
func (o *MCPWM_Type) GetCON_SET_DISUP2_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x100000) >> 20
}
func (o *MCPWM_Type) SetCON_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x1fe00000)|value<<21)
}
func (o *MCPWM_Type) GetCON_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x1fe00000) >> 21
}
func (o *MCPWM_Type) SetCON_SET_INVBDC_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x20000000)|value<<29)
}
func (o *MCPWM_Type) GetCON_SET_INVBDC_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x20000000) >> 29
}
func (o *MCPWM_Type) SetCON_SET_ACMODE_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x40000000)|value<<30)
}
func (o *MCPWM_Type) GetCON_SET_ACMODE_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x40000000) >> 30
}
func (o *MCPWM_Type) SetCON_SET_DCMODE_SET(value uint32) {
	volatile.StoreUint32(&o.CON_SET.Reg, volatile.LoadUint32(&o.CON_SET.Reg)&^(0x80000000)|value<<31)
}
func (o *MCPWM_Type) GetCON_SET_DCMODE_SET() uint32 {
	return (volatile.LoadUint32(&o.CON_SET.Reg) & 0x80000000) >> 31
}

// MCPWM.CON_CLR: PWM Control clear address
func (o *MCPWM_Type) SetCON_CLR_RUN0_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCON_CLR_RUN0_CLR() uint32 {
	return volatile.LoadUint32(&o.CON_CLR.Reg) & 0x1
}
func (o *MCPWM_Type) SetCON_CLR_CENTER0_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetCON_CLR_CENTER0_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetCON_CLR_POLA0_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetCON_CLR_POLA0_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetCON_CLR_DTE0_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetCON_CLR_DTE0_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetCON_CLR_DISUP0_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetCON_CLR_DISUP0_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetCON_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0xe0)|value<<5)
}
func (o *MCPWM_Type) GetCON_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0xe0) >> 5
}
func (o *MCPWM_Type) SetCON_CLR_RUN1_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetCON_CLR_RUN1_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetCON_CLR_CENTER1_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetCON_CLR_CENTER1_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetCON_CLR_POLA1_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetCON_CLR_POLA1_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetCON_CLR_DTE1_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetCON_CLR_DTE1_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetCON_CLR_DISUP1_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetCON_CLR_DISUP1_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetCON_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0xe000)|value<<13)
}
func (o *MCPWM_Type) GetCON_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0xe000) >> 13
}
func (o *MCPWM_Type) SetCON_CLR_RUN2_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetCON_CLR_RUN2_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x10000) >> 16
}
func (o *MCPWM_Type) SetCON_CLR_CENTER2_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *MCPWM_Type) GetCON_CLR_CENTER2_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x20000) >> 17
}
func (o *MCPWM_Type) SetCON_CLR_POLA2_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x40000)|value<<18)
}
func (o *MCPWM_Type) GetCON_CLR_POLA2_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x40000) >> 18
}
func (o *MCPWM_Type) SetCON_CLR_DTE2_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x80000)|value<<19)
}
func (o *MCPWM_Type) GetCON_CLR_DTE2_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x80000) >> 19
}
func (o *MCPWM_Type) SetCON_CLR_DISUP2_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x100000)|value<<20)
}
func (o *MCPWM_Type) GetCON_CLR_DISUP2_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x100000) >> 20
}
func (o *MCPWM_Type) SetCON_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x1fe00000)|value<<21)
}
func (o *MCPWM_Type) GetCON_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x1fe00000) >> 21
}
func (o *MCPWM_Type) SetCON_CLR_INVBDC_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x20000000)|value<<29)
}
func (o *MCPWM_Type) GetCON_CLR_INVBDC_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x20000000) >> 29
}
func (o *MCPWM_Type) SetCON_CLR_ACMOD_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x40000000)|value<<30)
}
func (o *MCPWM_Type) GetCON_CLR_ACMOD_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x40000000) >> 30
}
func (o *MCPWM_Type) SetCON_CLR_DCMODE_CLR(value uint32) {
	volatile.StoreUint32(&o.CON_CLR.Reg, volatile.LoadUint32(&o.CON_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *MCPWM_Type) GetCON_CLR_DCMODE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CON_CLR.Reg) & 0x80000000) >> 31
}

// MCPWM.CAPCON: Capture Control read address
func (o *MCPWM_Type) SetCAPCON_CAP0MCI0_RE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCAPCON_CAP0MCI0_RE() uint32 {
	return volatile.LoadUint32(&o.CAPCON.Reg) & 0x1
}
func (o *MCPWM_Type) SetCAPCON_CAP0MCI0_FE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetCAPCON_CAP0MCI0_FE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetCAPCON_CAP0MCI1_RE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetCAPCON_CAP0MCI1_RE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetCAPCON_CAP0MCI1_FE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetCAPCON_CAP0MCI1_FE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetCAPCON_CAP0MCI2_RE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetCAPCON_CAP0MCI2_RE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetCAPCON_CAP0MCI2_FE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetCAPCON_CAP0MCI2_FE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetCAPCON_CAP1MCI0_RE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetCAPCON_CAP1MCI0_RE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetCAPCON_CAP1MCI0_FE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetCAPCON_CAP1MCI0_FE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetCAPCON_CAP1MCI1_RE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetCAPCON_CAP1MCI1_RE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetCAPCON_CAP1MCI1_FE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetCAPCON_CAP1MCI1_FE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetCAPCON_CAP1MCI2_RE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetCAPCON_CAP1MCI2_RE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetCAPCON_CAP1MCI2_FE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetCAPCON_CAP1MCI2_FE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetCAPCON_CAP2MCI0_RE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetCAPCON_CAP2MCI0_RE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetCAPCON_CAP2MCI0_FE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x2000)|value<<13)
}
func (o *MCPWM_Type) GetCAPCON_CAP2MCI0_FE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x2000) >> 13
}
func (o *MCPWM_Type) SetCAPCON_CAP2MCI1_RE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x4000)|value<<14)
}
func (o *MCPWM_Type) GetCAPCON_CAP2MCI1_RE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x4000) >> 14
}
func (o *MCPWM_Type) SetCAPCON_CAP2MCI1_FE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetCAPCON_CAP2MCI1_FE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetCAPCON_CAP2MCI2_RE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetCAPCON_CAP2MCI2_RE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x10000) >> 16
}
func (o *MCPWM_Type) SetCAPCON_CAP2MCI2_FE(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x20000)|value<<17)
}
func (o *MCPWM_Type) GetCAPCON_CAP2MCI2_FE() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x20000) >> 17
}
func (o *MCPWM_Type) SetCAPCON_RT0(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x40000)|value<<18)
}
func (o *MCPWM_Type) GetCAPCON_RT0() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x40000) >> 18
}
func (o *MCPWM_Type) SetCAPCON_RT1(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x80000)|value<<19)
}
func (o *MCPWM_Type) GetCAPCON_RT1() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x80000) >> 19
}
func (o *MCPWM_Type) SetCAPCON_RT2(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0x100000)|value<<20)
}
func (o *MCPWM_Type) GetCAPCON_RT2() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0x100000) >> 20
}
func (o *MCPWM_Type) SetCAPCON_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CAPCON.Reg, volatile.LoadUint32(&o.CAPCON.Reg)&^(0xffe00000)|value<<21)
}
func (o *MCPWM_Type) GetCAPCON_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CAPCON.Reg) & 0xffe00000) >> 21
}

// MCPWM.CAPCON_SET: Capture Control set address
func (o *MCPWM_Type) SetCAPCON_SET_CAP0MCI0_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP0MCI0_RE_SET() uint32 {
	return volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x1
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP0MCI0_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP0MCI0_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP0MCI1_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP0MCI1_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP0MCI1_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP0MCI1_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP0MCI2_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP0MCI2_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP0MCI2_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP0MCI2_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP1MCI0_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP1MCI0_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP1MCI0_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP1MCI0_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP1MCI1_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP1MCI1_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP1MCI1_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP1MCI1_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP1MCI2_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP1MCI2_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP1MCI2_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP1MCI2_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP2MCI0_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP2MCI0_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP2MCI0_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x2000)|value<<13)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP2MCI0_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x2000) >> 13
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP2MCI1_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x4000)|value<<14)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP2MCI1_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x4000) >> 14
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP2MCI1_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP2MCI1_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP2MCI2_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP2MCI2_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x10000) >> 16
}
func (o *MCPWM_Type) SetCAPCON_SET_CAP2MCI2_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x20000)|value<<17)
}
func (o *MCPWM_Type) GetCAPCON_SET_CAP2MCI2_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x20000) >> 17
}
func (o *MCPWM_Type) SetCAPCON_SET_RT0_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x40000)|value<<18)
}
func (o *MCPWM_Type) GetCAPCON_SET_RT0_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x40000) >> 18
}
func (o *MCPWM_Type) SetCAPCON_SET_RT1_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x80000)|value<<19)
}
func (o *MCPWM_Type) GetCAPCON_SET_RT1_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x80000) >> 19
}
func (o *MCPWM_Type) SetCAPCON_SET_RT2_SET(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0x100000)|value<<20)
}
func (o *MCPWM_Type) GetCAPCON_SET_RT2_SET() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0x100000) >> 20
}
func (o *MCPWM_Type) SetCAPCON_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CAPCON_SET.Reg, volatile.LoadUint32(&o.CAPCON_SET.Reg)&^(0xffe00000)|value<<21)
}
func (o *MCPWM_Type) GetCAPCON_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_SET.Reg) & 0xffe00000) >> 21
}

// MCPWM.CAPCON_CLR: Event Control clear address
func (o *MCPWM_Type) SetCAPCON_CLR_CAP0MCI0_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP0MCI0_RE_CLR() uint32 {
	return volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x1
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP0MCI0_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP0MCI0_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP0MCI1_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP0MCI1_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP0MCI1_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP0MCI1_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP0MCI2_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP0MCI2_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP0MCI2_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP0MCI2_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP1MCI0_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP1MCI0_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP1MCI0_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP1MCI0_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP1MCI1_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP1MCI1_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP1MCI1_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP1MCI1_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP1MCI2_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP1MCI2_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP1MCI2_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP1MCI2_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP2MCI0_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP2MCI0_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP2MCI0_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP2MCI0_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x2000) >> 13
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP2MCI1_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP2MCI1_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x4000) >> 14
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP2MCI1_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP2MCI1_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP2MCI2_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP2MCI2_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x10000) >> 16
}
func (o *MCPWM_Type) SetCAPCON_CLR_CAP2MCI2_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *MCPWM_Type) GetCAPCON_CLR_CAP2MCI2_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x20000) >> 17
}
func (o *MCPWM_Type) SetCAPCON_CLR_RT0_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x40000)|value<<18)
}
func (o *MCPWM_Type) GetCAPCON_CLR_RT0_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x40000) >> 18
}
func (o *MCPWM_Type) SetCAPCON_CLR_RT1_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x80000)|value<<19)
}
func (o *MCPWM_Type) GetCAPCON_CLR_RT1_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x80000) >> 19
}
func (o *MCPWM_Type) SetCAPCON_CLR_RT2_CLR(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0x100000)|value<<20)
}
func (o *MCPWM_Type) GetCAPCON_CLR_RT2_CLR() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0x100000) >> 20
}
func (o *MCPWM_Type) SetCAPCON_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CAPCON_CLR.Reg, volatile.LoadUint32(&o.CAPCON_CLR.Reg)&^(0xffe00000)|value<<21)
}
func (o *MCPWM_Type) GetCAPCON_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CAPCON_CLR.Reg) & 0xffe00000) >> 21
}

// MCPWM.TC: Timer Counter register
func (o *MCPWM_Type) SetTC(idx int, value uint32) {
	volatile.StoreUint32(&o.TC[idx].Reg, value)
}
func (o *MCPWM_Type) GetTC(idx int) uint32 {
	return volatile.LoadUint32(&o.TC[idx].Reg)
}

// MCPWM.LIM: Limit register
func (o *MCPWM_Type) SetLIM(idx int, value uint32) {
	volatile.StoreUint32(&o.LIM[idx].Reg, value)
}
func (o *MCPWM_Type) GetLIM(idx int) uint32 {
	return volatile.LoadUint32(&o.LIM[idx].Reg)
}

// MCPWM.MAT: Match register
func (o *MCPWM_Type) SetMAT(idx int, value uint32) {
	volatile.StoreUint32(&o.MAT[idx].Reg, value)
}
func (o *MCPWM_Type) GetMAT(idx int) uint32 {
	return volatile.LoadUint32(&o.MAT[idx].Reg)
}

// MCPWM.DT: Dead time register
func (o *MCPWM_Type) SetDT_DT0(value uint32) {
	volatile.StoreUint32(&o.DT.Reg, volatile.LoadUint32(&o.DT.Reg)&^(0x3ff)|value)
}
func (o *MCPWM_Type) GetDT_DT0() uint32 {
	return volatile.LoadUint32(&o.DT.Reg) & 0x3ff
}
func (o *MCPWM_Type) SetDT_DT1(value uint32) {
	volatile.StoreUint32(&o.DT.Reg, volatile.LoadUint32(&o.DT.Reg)&^(0xffc00)|value<<10)
}
func (o *MCPWM_Type) GetDT_DT1() uint32 {
	return (volatile.LoadUint32(&o.DT.Reg) & 0xffc00) >> 10
}
func (o *MCPWM_Type) SetDT_DT2(value uint32) {
	volatile.StoreUint32(&o.DT.Reg, volatile.LoadUint32(&o.DT.Reg)&^(0x3ff00000)|value<<20)
}
func (o *MCPWM_Type) GetDT_DT2() uint32 {
	return (volatile.LoadUint32(&o.DT.Reg) & 0x3ff00000) >> 20
}
func (o *MCPWM_Type) SetDT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DT.Reg, volatile.LoadUint32(&o.DT.Reg)&^(0xc0000000)|value<<30)
}
func (o *MCPWM_Type) GetDT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DT.Reg) & 0xc0000000) >> 30
}

// MCPWM.CCP: Communication Pattern register
func (o *MCPWM_Type) SetCCP_CCPA0(value uint32) {
	volatile.StoreUint32(&o.CCP.Reg, volatile.LoadUint32(&o.CCP.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCCP_CCPA0() uint32 {
	return volatile.LoadUint32(&o.CCP.Reg) & 0x1
}
func (o *MCPWM_Type) SetCCP_CCPB0(value uint32) {
	volatile.StoreUint32(&o.CCP.Reg, volatile.LoadUint32(&o.CCP.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetCCP_CCPB0() uint32 {
	return (volatile.LoadUint32(&o.CCP.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetCCP_CCPA1(value uint32) {
	volatile.StoreUint32(&o.CCP.Reg, volatile.LoadUint32(&o.CCP.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetCCP_CCPA1() uint32 {
	return (volatile.LoadUint32(&o.CCP.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetCCP_CCPB1(value uint32) {
	volatile.StoreUint32(&o.CCP.Reg, volatile.LoadUint32(&o.CCP.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetCCP_CCPB1() uint32 {
	return (volatile.LoadUint32(&o.CCP.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetCCP_CCPA2(value uint32) {
	volatile.StoreUint32(&o.CCP.Reg, volatile.LoadUint32(&o.CCP.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetCCP_CCPA2() uint32 {
	return (volatile.LoadUint32(&o.CCP.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetCCP_CCPB2(value uint32) {
	volatile.StoreUint32(&o.CCP.Reg, volatile.LoadUint32(&o.CCP.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetCCP_CCPB2() uint32 {
	return (volatile.LoadUint32(&o.CCP.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetCCP_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CCP.Reg, volatile.LoadUint32(&o.CCP.Reg)&^(0xffffffc0)|value<<6)
}
func (o *MCPWM_Type) GetCCP_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CCP.Reg) & 0xffffffc0) >> 6
}

// MCPWM.CAP: Capture register
func (o *MCPWM_Type) SetCAP(idx int, value uint32) {
	volatile.StoreUint32(&o.CAP[idx].Reg, value)
}
func (o *MCPWM_Type) GetCAP(idx int) uint32 {
	return volatile.LoadUint32(&o.CAP[idx].Reg)
}

// MCPWM.INTEN: Interrupt Enable read address
func (o *MCPWM_Type) SetINTEN_ILIM0(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetINTEN_ILIM0() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *MCPWM_Type) SetINTEN_IMAT0(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetINTEN_IMAT0() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetINTEN_ICAP0(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetINTEN_ICAP0() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetINTEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetINTEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetINTEN_ILIM1(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetINTEN_ILIM1() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetINTEN_IMAT1(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetINTEN_IMAT1() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetINTEN_ICAP1(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetINTEN_ICAP1() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetINTEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetINTEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetINTEN_ILIM2(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetINTEN_ILIM2() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetINTEN_IMAT2(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetINTEN_IMAT2() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetINTEN_ICAP2(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetINTEN_ICAP2() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetINTEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x7800)|value<<11)
}
func (o *MCPWM_Type) GetINTEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x7800) >> 11
}
func (o *MCPWM_Type) SetINTEN_ABORT(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetINTEN_ABORT() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetINTEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0xffff0000)|value<<16)
}
func (o *MCPWM_Type) GetINTEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0xffff0000) >> 16
}

// MCPWM.INTEN_SET: Interrupt Enable set address
func (o *MCPWM_Type) SetINTEN_SET_ILIM0_SET(value uint32) {
	volatile.StoreUint32(&o.INTEN_SET.Reg, volatile.LoadUint32(&o.INTEN_SET.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetINTEN_SET_ILIM0_SET() uint32 {
	return volatile.LoadUint32(&o.INTEN_SET.Reg) & 0x1
}
func (o *MCPWM_Type) SetINTEN_SET_IMAT0_SET(value uint32) {
	volatile.StoreUint32(&o.INTEN_SET.Reg, volatile.LoadUint32(&o.INTEN_SET.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetINTEN_SET_IMAT0_SET() uint32 {
	return (volatile.LoadUint32(&o.INTEN_SET.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetINTEN_SET_ICAP0_SET(value uint32) {
	volatile.StoreUint32(&o.INTEN_SET.Reg, volatile.LoadUint32(&o.INTEN_SET.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetINTEN_SET_ICAP0_SET() uint32 {
	return (volatile.LoadUint32(&o.INTEN_SET.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetINTEN_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN_SET.Reg, volatile.LoadUint32(&o.INTEN_SET.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetINTEN_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN_SET.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetINTEN_SET_ILIM1_SET(value uint32) {
	volatile.StoreUint32(&o.INTEN_SET.Reg, volatile.LoadUint32(&o.INTEN_SET.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetINTEN_SET_ILIM1_SET() uint32 {
	return (volatile.LoadUint32(&o.INTEN_SET.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetINTEN_SET_IMAT1_SET(value uint32) {
	volatile.StoreUint32(&o.INTEN_SET.Reg, volatile.LoadUint32(&o.INTEN_SET.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetINTEN_SET_IMAT1_SET() uint32 {
	return (volatile.LoadUint32(&o.INTEN_SET.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetINTEN_SET_ICAP1_SET(value uint32) {
	volatile.StoreUint32(&o.INTEN_SET.Reg, volatile.LoadUint32(&o.INTEN_SET.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetINTEN_SET_ICAP1_SET() uint32 {
	return (volatile.LoadUint32(&o.INTEN_SET.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetINTEN_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN_SET.Reg, volatile.LoadUint32(&o.INTEN_SET.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetINTEN_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN_SET.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetINTEN_SET_ILIM2_SET(value uint32) {
	volatile.StoreUint32(&o.INTEN_SET.Reg, volatile.LoadUint32(&o.INTEN_SET.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetINTEN_SET_ILIM2_SET() uint32 {
	return (volatile.LoadUint32(&o.INTEN_SET.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetINTEN_SET_IMAT2_SET(value uint32) {
	volatile.StoreUint32(&o.INTEN_SET.Reg, volatile.LoadUint32(&o.INTEN_SET.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetINTEN_SET_IMAT2_SET() uint32 {
	return (volatile.LoadUint32(&o.INTEN_SET.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetINTEN_SET_ICAP2_SET(value uint32) {
	volatile.StoreUint32(&o.INTEN_SET.Reg, volatile.LoadUint32(&o.INTEN_SET.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetINTEN_SET_ICAP2_SET() uint32 {
	return (volatile.LoadUint32(&o.INTEN_SET.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetINTEN_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN_SET.Reg, volatile.LoadUint32(&o.INTEN_SET.Reg)&^(0x7000)|value<<12)
}
func (o *MCPWM_Type) GetINTEN_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN_SET.Reg) & 0x7000) >> 12
}
func (o *MCPWM_Type) SetINTEN_SET_ABORT_SET(value uint32) {
	volatile.StoreUint32(&o.INTEN_SET.Reg, volatile.LoadUint32(&o.INTEN_SET.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetINTEN_SET_ABORT_SET() uint32 {
	return (volatile.LoadUint32(&o.INTEN_SET.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetINTEN_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN_SET.Reg, volatile.LoadUint32(&o.INTEN_SET.Reg)&^(0xffff0000)|value<<16)
}
func (o *MCPWM_Type) GetINTEN_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN_SET.Reg) & 0xffff0000) >> 16
}

// MCPWM.INTEN_CLR: Interrupt Enable clear address
func (o *MCPWM_Type) SetINTEN_CLR_ILIM0_CLR(value uint32) {
	volatile.StoreUint32(&o.INTEN_CLR.Reg, volatile.LoadUint32(&o.INTEN_CLR.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetINTEN_CLR_ILIM0_CLR() uint32 {
	return volatile.LoadUint32(&o.INTEN_CLR.Reg) & 0x1
}
func (o *MCPWM_Type) SetINTEN_CLR_IMAT0_CLR(value uint32) {
	volatile.StoreUint32(&o.INTEN_CLR.Reg, volatile.LoadUint32(&o.INTEN_CLR.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetINTEN_CLR_IMAT0_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTEN_CLR.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetINTEN_CLR_ICAP0_CLR(value uint32) {
	volatile.StoreUint32(&o.INTEN_CLR.Reg, volatile.LoadUint32(&o.INTEN_CLR.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetINTEN_CLR_ICAP0_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTEN_CLR.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetINTEN_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN_CLR.Reg, volatile.LoadUint32(&o.INTEN_CLR.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetINTEN_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN_CLR.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetINTEN_CLR_ILIM1_CLR(value uint32) {
	volatile.StoreUint32(&o.INTEN_CLR.Reg, volatile.LoadUint32(&o.INTEN_CLR.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetINTEN_CLR_ILIM1_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTEN_CLR.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetINTEN_CLR_IMAT1_CLR(value uint32) {
	volatile.StoreUint32(&o.INTEN_CLR.Reg, volatile.LoadUint32(&o.INTEN_CLR.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetINTEN_CLR_IMAT1_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTEN_CLR.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetINTEN_CLR_ICAP1_CLR(value uint32) {
	volatile.StoreUint32(&o.INTEN_CLR.Reg, volatile.LoadUint32(&o.INTEN_CLR.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetINTEN_CLR_ICAP1_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTEN_CLR.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetINTEN_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN_CLR.Reg, volatile.LoadUint32(&o.INTEN_CLR.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetINTEN_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN_CLR.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetINTEN_CLR_ILIM2_CLR(value uint32) {
	volatile.StoreUint32(&o.INTEN_CLR.Reg, volatile.LoadUint32(&o.INTEN_CLR.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetINTEN_CLR_ILIM2_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTEN_CLR.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetINTEN_CLR_IMAT2_CLR(value uint32) {
	volatile.StoreUint32(&o.INTEN_CLR.Reg, volatile.LoadUint32(&o.INTEN_CLR.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetINTEN_CLR_IMAT2_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTEN_CLR.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetINTEN_CLR_ICAP2_CLR(value uint32) {
	volatile.StoreUint32(&o.INTEN_CLR.Reg, volatile.LoadUint32(&o.INTEN_CLR.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetINTEN_CLR_ICAP2_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTEN_CLR.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetINTEN_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN_CLR.Reg, volatile.LoadUint32(&o.INTEN_CLR.Reg)&^(0x7800)|value<<11)
}
func (o *MCPWM_Type) GetINTEN_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN_CLR.Reg) & 0x7800) >> 11
}
func (o *MCPWM_Type) SetINTEN_CLR_ABORT_CLR(value uint32) {
	volatile.StoreUint32(&o.INTEN_CLR.Reg, volatile.LoadUint32(&o.INTEN_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetINTEN_CLR_ABORT_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTEN_CLR.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetINTEN_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN_CLR.Reg, volatile.LoadUint32(&o.INTEN_CLR.Reg)&^(0xffff0000)|value<<16)
}
func (o *MCPWM_Type) GetINTEN_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN_CLR.Reg) & 0xffff0000) >> 16
}

// MCPWM.CNTCON: Count Control read address
func (o *MCPWM_Type) SetCNTCON_TC0MCI0_RE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCNTCON_TC0MCI0_RE() uint32 {
	return volatile.LoadUint32(&o.CNTCON.Reg) & 0x1
}
func (o *MCPWM_Type) SetCNTCON_TC0MCI0_FE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetCNTCON_TC0MCI0_FE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetCNTCON_TC0MCI1_RE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetCNTCON_TC0MCI1_RE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetCNTCON_TC0MCI1_FE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetCNTCON_TC0MCI1_FE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetCNTCON_TC0MCI2_RE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetCNTCON_TC0MCI2_RE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetCNTCON_TC0MCI2_FE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetCNTCON_TC0MCI2_FE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetCNTCON_TC1MCI0_RE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetCNTCON_TC1MCI0_RE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetCNTCON_TC1MCI0_FE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetCNTCON_TC1MCI0_FE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetCNTCON_TC1MCI1_RE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetCNTCON_TC1MCI1_RE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetCNTCON_TC1MCI1_FE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetCNTCON_TC1MCI1_FE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetCNTCON_TC1MCI2_RE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetCNTCON_TC1MCI2_RE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetCNTCON_TC1MCI2_FE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetCNTCON_TC1MCI2_FE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetCNTCON_TC2MCI0_RE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetCNTCON_TC2MCI0_RE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetCNTCON_TC2MCI0_FE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x2000)|value<<13)
}
func (o *MCPWM_Type) GetCNTCON_TC2MCI0_FE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x2000) >> 13
}
func (o *MCPWM_Type) SetCNTCON_TC2MCI1_RE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x4000)|value<<14)
}
func (o *MCPWM_Type) GetCNTCON_TC2MCI1_RE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x4000) >> 14
}
func (o *MCPWM_Type) SetCNTCON_TC2MCI1_FE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetCNTCON_TC2MCI1_FE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetCNTCON_TC2MCI2_RE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetCNTCON_TC2MCI2_RE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x10000) >> 16
}
func (o *MCPWM_Type) SetCNTCON_TC2MCI2_FE(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x20000)|value<<17)
}
func (o *MCPWM_Type) GetCNTCON_TC2MCI2_FE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x20000) >> 17
}
func (o *MCPWM_Type) SetCNTCON_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *MCPWM_Type) GetCNTCON_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x1ffc0000) >> 18
}
func (o *MCPWM_Type) SetCNTCON_CNTR0(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x20000000)|value<<29)
}
func (o *MCPWM_Type) GetCNTCON_CNTR0() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x20000000) >> 29
}
func (o *MCPWM_Type) SetCNTCON_CNTR1(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x40000000)|value<<30)
}
func (o *MCPWM_Type) GetCNTCON_CNTR1() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x40000000) >> 30
}
func (o *MCPWM_Type) SetCNTCON_CNTR2(value uint32) {
	volatile.StoreUint32(&o.CNTCON.Reg, volatile.LoadUint32(&o.CNTCON.Reg)&^(0x80000000)|value<<31)
}
func (o *MCPWM_Type) GetCNTCON_CNTR2() uint32 {
	return (volatile.LoadUint32(&o.CNTCON.Reg) & 0x80000000) >> 31
}

// MCPWM.CNTCON_SET: Count Control set address
func (o *MCPWM_Type) SetCNTCON_SET_TC0MCI0_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC0MCI0_RE_SET() uint32 {
	return volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x1
}
func (o *MCPWM_Type) SetCNTCON_SET_TC0MCI0_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC0MCI0_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetCNTCON_SET_TC0MCI1_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC0MCI1_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetCNTCON_SET_TC0MCI1_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC0MCI1_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetCNTCON_SET_TC0MCI2_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC0MCI2_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetCNTCON_SET_TC0MCI2_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC0MCI2_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetCNTCON_SET_TC1MCI0_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC1MCI0_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetCNTCON_SET_TC1MCI0_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC1MCI0_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetCNTCON_SET_TC1MCI1_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC1MCI1_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetCNTCON_SET_TC1MCI1_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC1MCI1_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetCNTCON_SET_TC1MCI2_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC1MCI2_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetCNTCON_SET_TC1MCI2_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC1MCI2_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetCNTCON_SET_TC2MCI0_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC2MCI0_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetCNTCON_SET_TC2MCI0_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x2000)|value<<13)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC2MCI0_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x2000) >> 13
}
func (o *MCPWM_Type) SetCNTCON_SET_TC2MCI1_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x4000)|value<<14)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC2MCI1_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x4000) >> 14
}
func (o *MCPWM_Type) SetCNTCON_SET_TC2MCI1_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC2MCI1_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetCNTCON_SET_TC2MCI2_RE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC2MCI2_RE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x10000) >> 16
}
func (o *MCPWM_Type) SetCNTCON_SET_TC2MCI2_FE_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x20000)|value<<17)
}
func (o *MCPWM_Type) GetCNTCON_SET_TC2MCI2_FE_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x20000) >> 17
}
func (o *MCPWM_Type) SetCNTCON_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *MCPWM_Type) GetCNTCON_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x1ffc0000) >> 18
}
func (o *MCPWM_Type) SetCNTCON_SET_CNTR0_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x20000000)|value<<29)
}
func (o *MCPWM_Type) GetCNTCON_SET_CNTR0_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x20000000) >> 29
}
func (o *MCPWM_Type) SetCNTCON_SET_CNTR1_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x40000000)|value<<30)
}
func (o *MCPWM_Type) GetCNTCON_SET_CNTR1_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x40000000) >> 30
}
func (o *MCPWM_Type) SetCNTCON_SET_CNTR2_SET(value uint32) {
	volatile.StoreUint32(&o.CNTCON_SET.Reg, volatile.LoadUint32(&o.CNTCON_SET.Reg)&^(0x80000000)|value<<31)
}
func (o *MCPWM_Type) GetCNTCON_SET_CNTR2_SET() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_SET.Reg) & 0x80000000) >> 31
}

// MCPWM.CNTCON_CLR: Count Control clear address
func (o *MCPWM_Type) SetCNTCON_CLR_TC0MCI0_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC0MCI0_RE_CLR() uint32 {
	return volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x1
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC0MCI0_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC0MCI0_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC0MCI1_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC0MCI1_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC0MCI1_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC0MCI1_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC0MCI2_RE(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC0MCI2_RE() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC0MCI2_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC0MCI2_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC1MCI0_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC1MCI0_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC1MCI0_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC1MCI0_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC1MCI1_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC1MCI1_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC1MCI1_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC1MCI1_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC1MCI2_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC1MCI2_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC1MCI2_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x800)|value<<11)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC1MCI2_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x800) >> 11
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC2MCI0_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC2MCI0_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x1000) >> 12
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC2MCI0_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC2MCI0_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x2000) >> 13
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC2MCI1_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC2MCI1_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x4000) >> 14
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC2MCI1_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC2MCI1_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC2MCI2_RE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC2MCI2_RE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x10000) >> 16
}
func (o *MCPWM_Type) SetCNTCON_CLR_TC2MCI2_FE_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *MCPWM_Type) GetCNTCON_CLR_TC2MCI2_FE_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x20000) >> 17
}
func (o *MCPWM_Type) SetCNTCON_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *MCPWM_Type) GetCNTCON_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x1ffc0000) >> 18
}
func (o *MCPWM_Type) SetCNTCON_CLR_CNTR0_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x20000000)|value<<29)
}
func (o *MCPWM_Type) GetCNTCON_CLR_CNTR0_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x20000000) >> 29
}
func (o *MCPWM_Type) SetCNTCON_CLR_CNTR1_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x40000000)|value<<30)
}
func (o *MCPWM_Type) GetCNTCON_CLR_CNTR1_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x40000000) >> 30
}
func (o *MCPWM_Type) SetCNTCON_CLR_CNTR2_CLR(value uint32) {
	volatile.StoreUint32(&o.CNTCON_CLR.Reg, volatile.LoadUint32(&o.CNTCON_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *MCPWM_Type) GetCNTCON_CLR_CNTR2_CLR() uint32 {
	return (volatile.LoadUint32(&o.CNTCON_CLR.Reg) & 0x80000000) >> 31
}

// MCPWM.INTF: Interrupt flags read address
func (o *MCPWM_Type) SetINTF_ILIM0_F(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetINTF_ILIM0_F() uint32 {
	return volatile.LoadUint32(&o.INTF.Reg) & 0x1
}
func (o *MCPWM_Type) SetINTF_IMAT0_F(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetINTF_IMAT0_F() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetINTF_ICAP0_F(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetINTF_ICAP0_F() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetINTF_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetINTF_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetINTF_ILIM1_F(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetINTF_ILIM1_F() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetINTF_IMAT1_F(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetINTF_IMAT1_F() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetINTF_ICAP1_F(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetINTF_ICAP1_F() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetINTF_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetINTF_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetINTF_ILIM2_F(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetINTF_ILIM2_F() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetINTF_IMAT2_F(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetINTF_IMAT2_F() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetINTF_ICAP2_F(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetINTF_ICAP2_F() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetINTF_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x7800)|value<<11)
}
func (o *MCPWM_Type) GetINTF_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x7800) >> 11
}
func (o *MCPWM_Type) SetINTF_ABORT_F(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetINTF_ABORT_F() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetINTF_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTF.Reg, volatile.LoadUint32(&o.INTF.Reg)&^(0xffff0000)|value<<16)
}
func (o *MCPWM_Type) GetINTF_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTF.Reg) & 0xffff0000) >> 16
}

// MCPWM.INTF_SET: Interrupt flags set address
func (o *MCPWM_Type) SetINTF_SET_ILIM0_F_SET(value uint32) {
	volatile.StoreUint32(&o.INTF_SET.Reg, volatile.LoadUint32(&o.INTF_SET.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetINTF_SET_ILIM0_F_SET() uint32 {
	return volatile.LoadUint32(&o.INTF_SET.Reg) & 0x1
}
func (o *MCPWM_Type) SetINTF_SET_IMAT0_F_SET(value uint32) {
	volatile.StoreUint32(&o.INTF_SET.Reg, volatile.LoadUint32(&o.INTF_SET.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetINTF_SET_IMAT0_F_SET() uint32 {
	return (volatile.LoadUint32(&o.INTF_SET.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetINTF_SET_ICAP0_F_SET(value uint32) {
	volatile.StoreUint32(&o.INTF_SET.Reg, volatile.LoadUint32(&o.INTF_SET.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetINTF_SET_ICAP0_F_SET() uint32 {
	return (volatile.LoadUint32(&o.INTF_SET.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetINTF_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTF_SET.Reg, volatile.LoadUint32(&o.INTF_SET.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetINTF_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTF_SET.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetINTF_SET_ILIM1_F_SET(value uint32) {
	volatile.StoreUint32(&o.INTF_SET.Reg, volatile.LoadUint32(&o.INTF_SET.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetINTF_SET_ILIM1_F_SET() uint32 {
	return (volatile.LoadUint32(&o.INTF_SET.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetINTF_SET_IMAT1_F_SET(value uint32) {
	volatile.StoreUint32(&o.INTF_SET.Reg, volatile.LoadUint32(&o.INTF_SET.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetINTF_SET_IMAT1_F_SET() uint32 {
	return (volatile.LoadUint32(&o.INTF_SET.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetINTF_SET_ICAP1_F_SET(value uint32) {
	volatile.StoreUint32(&o.INTF_SET.Reg, volatile.LoadUint32(&o.INTF_SET.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetINTF_SET_ICAP1_F_SET() uint32 {
	return (volatile.LoadUint32(&o.INTF_SET.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetINTF_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTF_SET.Reg, volatile.LoadUint32(&o.INTF_SET.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetINTF_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTF_SET.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetINTF_SET_ILIM2_F_SET(value uint32) {
	volatile.StoreUint32(&o.INTF_SET.Reg, volatile.LoadUint32(&o.INTF_SET.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetINTF_SET_ILIM2_F_SET() uint32 {
	return (volatile.LoadUint32(&o.INTF_SET.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetINTF_SET_IMAT2_F_SET(value uint32) {
	volatile.StoreUint32(&o.INTF_SET.Reg, volatile.LoadUint32(&o.INTF_SET.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetINTF_SET_IMAT2_F_SET() uint32 {
	return (volatile.LoadUint32(&o.INTF_SET.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetINTF_SET_ICAP2_F_SET(value uint32) {
	volatile.StoreUint32(&o.INTF_SET.Reg, volatile.LoadUint32(&o.INTF_SET.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetINTF_SET_ICAP2_F_SET() uint32 {
	return (volatile.LoadUint32(&o.INTF_SET.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetINTF_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTF_SET.Reg, volatile.LoadUint32(&o.INTF_SET.Reg)&^(0x7800)|value<<11)
}
func (o *MCPWM_Type) GetINTF_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTF_SET.Reg) & 0x7800) >> 11
}
func (o *MCPWM_Type) SetINTF_SET_ABORT_F_SET(value uint32) {
	volatile.StoreUint32(&o.INTF_SET.Reg, volatile.LoadUint32(&o.INTF_SET.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetINTF_SET_ABORT_F_SET() uint32 {
	return (volatile.LoadUint32(&o.INTF_SET.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetINTF_SET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTF_SET.Reg, volatile.LoadUint32(&o.INTF_SET.Reg)&^(0xffff0000)|value<<16)
}
func (o *MCPWM_Type) GetINTF_SET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTF_SET.Reg) & 0xffff0000) >> 16
}

// MCPWM.INTF_CLR: Interrupt flags clear address
func (o *MCPWM_Type) SetINTF_CLR_ILIM0_F_CLR(value uint32) {
	volatile.StoreUint32(&o.INTF_CLR.Reg, volatile.LoadUint32(&o.INTF_CLR.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetINTF_CLR_ILIM0_F_CLR() uint32 {
	return volatile.LoadUint32(&o.INTF_CLR.Reg) & 0x1
}
func (o *MCPWM_Type) SetINTF_CLR_IMAT0_F_CLR(value uint32) {
	volatile.StoreUint32(&o.INTF_CLR.Reg, volatile.LoadUint32(&o.INTF_CLR.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetINTF_CLR_IMAT0_F_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTF_CLR.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetINTF_CLR_ICAP0_F_CLR(value uint32) {
	volatile.StoreUint32(&o.INTF_CLR.Reg, volatile.LoadUint32(&o.INTF_CLR.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetINTF_CLR_ICAP0_F_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTF_CLR.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetINTF_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTF_CLR.Reg, volatile.LoadUint32(&o.INTF_CLR.Reg)&^(0x8)|value<<3)
}
func (o *MCPWM_Type) GetINTF_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTF_CLR.Reg) & 0x8) >> 3
}
func (o *MCPWM_Type) SetINTF_CLR_ILIM1_F_CLR(value uint32) {
	volatile.StoreUint32(&o.INTF_CLR.Reg, volatile.LoadUint32(&o.INTF_CLR.Reg)&^(0x10)|value<<4)
}
func (o *MCPWM_Type) GetINTF_CLR_ILIM1_F_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTF_CLR.Reg) & 0x10) >> 4
}
func (o *MCPWM_Type) SetINTF_CLR_IMAT1_F_CLR(value uint32) {
	volatile.StoreUint32(&o.INTF_CLR.Reg, volatile.LoadUint32(&o.INTF_CLR.Reg)&^(0x20)|value<<5)
}
func (o *MCPWM_Type) GetINTF_CLR_IMAT1_F_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTF_CLR.Reg) & 0x20) >> 5
}
func (o *MCPWM_Type) SetINTF_CLR_ICAP1_F_CLR(value uint32) {
	volatile.StoreUint32(&o.INTF_CLR.Reg, volatile.LoadUint32(&o.INTF_CLR.Reg)&^(0x40)|value<<6)
}
func (o *MCPWM_Type) GetINTF_CLR_ICAP1_F_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTF_CLR.Reg) & 0x40) >> 6
}
func (o *MCPWM_Type) SetINTF_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTF_CLR.Reg, volatile.LoadUint32(&o.INTF_CLR.Reg)&^(0x80)|value<<7)
}
func (o *MCPWM_Type) GetINTF_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTF_CLR.Reg) & 0x80) >> 7
}
func (o *MCPWM_Type) SetINTF_CLR_ILIM2_F_CLR(value uint32) {
	volatile.StoreUint32(&o.INTF_CLR.Reg, volatile.LoadUint32(&o.INTF_CLR.Reg)&^(0x100)|value<<8)
}
func (o *MCPWM_Type) GetINTF_CLR_ILIM2_F_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTF_CLR.Reg) & 0x100) >> 8
}
func (o *MCPWM_Type) SetINTF_CLR_IMAT2_F_CLR(value uint32) {
	volatile.StoreUint32(&o.INTF_CLR.Reg, volatile.LoadUint32(&o.INTF_CLR.Reg)&^(0x200)|value<<9)
}
func (o *MCPWM_Type) GetINTF_CLR_IMAT2_F_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTF_CLR.Reg) & 0x200) >> 9
}
func (o *MCPWM_Type) SetINTF_CLR_ICAP2_F_CLR(value uint32) {
	volatile.StoreUint32(&o.INTF_CLR.Reg, volatile.LoadUint32(&o.INTF_CLR.Reg)&^(0x400)|value<<10)
}
func (o *MCPWM_Type) GetINTF_CLR_ICAP2_F_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTF_CLR.Reg) & 0x400) >> 10
}
func (o *MCPWM_Type) SetINTF_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTF_CLR.Reg, volatile.LoadUint32(&o.INTF_CLR.Reg)&^(0x7800)|value<<11)
}
func (o *MCPWM_Type) GetINTF_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTF_CLR.Reg) & 0x7800) >> 11
}
func (o *MCPWM_Type) SetINTF_CLR_ABORT_F_CLR(value uint32) {
	volatile.StoreUint32(&o.INTF_CLR.Reg, volatile.LoadUint32(&o.INTF_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *MCPWM_Type) GetINTF_CLR_ABORT_F_CLR() uint32 {
	return (volatile.LoadUint32(&o.INTF_CLR.Reg) & 0x8000) >> 15
}
func (o *MCPWM_Type) SetINTF_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTF_CLR.Reg, volatile.LoadUint32(&o.INTF_CLR.Reg)&^(0xffff0000)|value<<16)
}
func (o *MCPWM_Type) GetINTF_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTF_CLR.Reg) & 0xffff0000) >> 16
}

// MCPWM.CAP_CLR: Capture clear address
func (o *MCPWM_Type) SetCAP_CLR_CAP_CLR0(value uint32) {
	volatile.StoreUint32(&o.CAP_CLR.Reg, volatile.LoadUint32(&o.CAP_CLR.Reg)&^(0x1)|value)
}
func (o *MCPWM_Type) GetCAP_CLR_CAP_CLR0() uint32 {
	return volatile.LoadUint32(&o.CAP_CLR.Reg) & 0x1
}
func (o *MCPWM_Type) SetCAP_CLR_CAP_CLR1(value uint32) {
	volatile.StoreUint32(&o.CAP_CLR.Reg, volatile.LoadUint32(&o.CAP_CLR.Reg)&^(0x2)|value<<1)
}
func (o *MCPWM_Type) GetCAP_CLR_CAP_CLR1() uint32 {
	return (volatile.LoadUint32(&o.CAP_CLR.Reg) & 0x2) >> 1
}
func (o *MCPWM_Type) SetCAP_CLR_CAP_CLR2(value uint32) {
	volatile.StoreUint32(&o.CAP_CLR.Reg, volatile.LoadUint32(&o.CAP_CLR.Reg)&^(0x4)|value<<2)
}
func (o *MCPWM_Type) GetCAP_CLR_CAP_CLR2() uint32 {
	return (volatile.LoadUint32(&o.CAP_CLR.Reg) & 0x4) >> 2
}
func (o *MCPWM_Type) SetCAP_CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CAP_CLR.Reg, volatile.LoadUint32(&o.CAP_CLR.Reg)&^(0xfffffff8)|value<<3)
}
func (o *MCPWM_Type) GetCAP_CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CAP_CLR.Reg) & 0xfffffff8) >> 3
}

// Quadrature Encoder Interface (QEI)
type QEI_Type struct {
	CON       volatile.Register32 // 0x0
	STAT      volatile.Register32 // 0x4
	CONF      volatile.Register32 // 0x8
	POS       volatile.Register32 // 0xC
	MAXPOS    volatile.Register32 // 0x10
	CMPOS0    volatile.Register32 // 0x14
	CMPOS1    volatile.Register32 // 0x18
	CMPOS2    volatile.Register32 // 0x1C
	INXCNT    volatile.Register32 // 0x20
	INXCMP0   volatile.Register32 // 0x24
	LOAD      volatile.Register32 // 0x28
	TIME      volatile.Register32 // 0x2C
	VEL       volatile.Register32 // 0x30
	CAP       volatile.Register32 // 0x34
	VELCOMP   volatile.Register32 // 0x38
	FILTERPHA volatile.Register32 // 0x3C
	FILTERPHB volatile.Register32 // 0x40
	FILTERINX volatile.Register32 // 0x44
	WINDOW    volatile.Register32 // 0x48
	INXCMP1   volatile.Register32 // 0x4C
	INXCMP2   volatile.Register32 // 0x50
	_         [3972]byte
	IEC       volatile.Register32 // 0xFD8
	IES       volatile.Register32 // 0xFDC
	INTSTAT   volatile.Register32 // 0xFE0
	IE        volatile.Register32 // 0xFE4
	CLR       volatile.Register32 // 0xFE8
	SET       volatile.Register32 // 0xFEC
}

// QEI.CON: Control register
func (o *QEI_Type) SetCON_RESP(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x1)|value)
}
func (o *QEI_Type) GetCON_RESP() uint32 {
	return volatile.LoadUint32(&o.CON.Reg) & 0x1
}
func (o *QEI_Type) SetCON_RESPI(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x2)|value<<1)
}
func (o *QEI_Type) GetCON_RESPI() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x2) >> 1
}
func (o *QEI_Type) SetCON_RESV(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x4)|value<<2)
}
func (o *QEI_Type) GetCON_RESV() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x4) >> 2
}
func (o *QEI_Type) SetCON_RESI(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0x8)|value<<3)
}
func (o *QEI_Type) GetCON_RESI() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0x8) >> 3
}
func (o *QEI_Type) SetCON_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CON.Reg, volatile.LoadUint32(&o.CON.Reg)&^(0xfffffff0)|value<<4)
}
func (o *QEI_Type) GetCON_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CON.Reg) & 0xfffffff0) >> 4
}

// QEI.STAT: Status register
func (o *QEI_Type) SetSTAT_DIR(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x1)|value)
}
func (o *QEI_Type) GetSTAT_DIR() uint32 {
	return volatile.LoadUint32(&o.STAT.Reg) & 0x1
}
func (o *QEI_Type) SetSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0xfffffffe)|value<<1)
}
func (o *QEI_Type) GetSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0xfffffffe) >> 1
}

// QEI.CONF: Configuration register
func (o *QEI_Type) SetCONF_DIRINV(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x1)|value)
}
func (o *QEI_Type) GetCONF_DIRINV() uint32 {
	return volatile.LoadUint32(&o.CONF.Reg) & 0x1
}
func (o *QEI_Type) SetCONF_SIGMODE(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x2)|value<<1)
}
func (o *QEI_Type) GetCONF_SIGMODE() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x2) >> 1
}
func (o *QEI_Type) SetCONF_CAPMODE(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x4)|value<<2)
}
func (o *QEI_Type) GetCONF_CAPMODE() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x4) >> 2
}
func (o *QEI_Type) SetCONF_INVINX(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x8)|value<<3)
}
func (o *QEI_Type) GetCONF_INVINX() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x8) >> 3
}
func (o *QEI_Type) SetCONF_CRESPI(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0x10)|value<<4)
}
func (o *QEI_Type) GetCONF_CRESPI() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0x10) >> 4
}
func (o *QEI_Type) SetCONF_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0xffe0)|value<<5)
}
func (o *QEI_Type) GetCONF_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0xffe0) >> 5
}
func (o *QEI_Type) SetCONF_INXGATE(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0xf0000)|value<<16)
}
func (o *QEI_Type) GetCONF_INXGATE() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0xf0000) >> 16
}
func (o *QEI_Type) SetCONF_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONF.Reg, volatile.LoadUint32(&o.CONF.Reg)&^(0xfff00000)|value<<20)
}
func (o *QEI_Type) GetCONF_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONF.Reg) & 0xfff00000) >> 20
}

// QEI.POS: Position register
func (o *QEI_Type) SetPOS(value uint32) {
	volatile.StoreUint32(&o.POS.Reg, value)
}
func (o *QEI_Type) GetPOS() uint32 {
	return volatile.LoadUint32(&o.POS.Reg)
}

// QEI.MAXPOS: Maximum position register
func (o *QEI_Type) SetMAXPOS(value uint32) {
	volatile.StoreUint32(&o.MAXPOS.Reg, value)
}
func (o *QEI_Type) GetMAXPOS() uint32 {
	return volatile.LoadUint32(&o.MAXPOS.Reg)
}

// QEI.CMPOS0: Position compare register 0
func (o *QEI_Type) SetCMPOS0(value uint32) {
	volatile.StoreUint32(&o.CMPOS0.Reg, value)
}
func (o *QEI_Type) GetCMPOS0() uint32 {
	return volatile.LoadUint32(&o.CMPOS0.Reg)
}

// QEI.CMPOS1: Position compare register 1
func (o *QEI_Type) SetCMPOS1(value uint32) {
	volatile.StoreUint32(&o.CMPOS1.Reg, value)
}
func (o *QEI_Type) GetCMPOS1() uint32 {
	return volatile.LoadUint32(&o.CMPOS1.Reg)
}

// QEI.CMPOS2: Position compare register 2
func (o *QEI_Type) SetCMPOS2(value uint32) {
	volatile.StoreUint32(&o.CMPOS2.Reg, value)
}
func (o *QEI_Type) GetCMPOS2() uint32 {
	return volatile.LoadUint32(&o.CMPOS2.Reg)
}

// QEI.INXCNT: Index count register 0
func (o *QEI_Type) SetINXCNT(value uint32) {
	volatile.StoreUint32(&o.INXCNT.Reg, value)
}
func (o *QEI_Type) GetINXCNT() uint32 {
	return volatile.LoadUint32(&o.INXCNT.Reg)
}

// QEI.INXCMP0: Index compare register 0
func (o *QEI_Type) SetINXCMP0(value uint32) {
	volatile.StoreUint32(&o.INXCMP0.Reg, value)
}
func (o *QEI_Type) GetINXCMP0() uint32 {
	return volatile.LoadUint32(&o.INXCMP0.Reg)
}

// QEI.LOAD: Velocity timer reload register
func (o *QEI_Type) SetLOAD(value uint32) {
	volatile.StoreUint32(&o.LOAD.Reg, value)
}
func (o *QEI_Type) GetLOAD() uint32 {
	return volatile.LoadUint32(&o.LOAD.Reg)
}

// QEI.TIME: Velocity timer register
func (o *QEI_Type) SetTIME(value uint32) {
	volatile.StoreUint32(&o.TIME.Reg, value)
}
func (o *QEI_Type) GetTIME() uint32 {
	return volatile.LoadUint32(&o.TIME.Reg)
}

// QEI.VEL: Velocity counter register
func (o *QEI_Type) SetVEL(value uint32) {
	volatile.StoreUint32(&o.VEL.Reg, value)
}
func (o *QEI_Type) GetVEL() uint32 {
	return volatile.LoadUint32(&o.VEL.Reg)
}

// QEI.CAP: Velocity capture register
func (o *QEI_Type) SetCAP(value uint32) {
	volatile.StoreUint32(&o.CAP.Reg, value)
}
func (o *QEI_Type) GetCAP() uint32 {
	return volatile.LoadUint32(&o.CAP.Reg)
}

// QEI.VELCOMP: Velocity compare register
func (o *QEI_Type) SetVELCOMP(value uint32) {
	volatile.StoreUint32(&o.VELCOMP.Reg, value)
}
func (o *QEI_Type) GetVELCOMP() uint32 {
	return volatile.LoadUint32(&o.VELCOMP.Reg)
}

// QEI.FILTERPHA: Digital filter register on PHA
func (o *QEI_Type) SetFILTERPHA(value uint32) {
	volatile.StoreUint32(&o.FILTERPHA.Reg, value)
}
func (o *QEI_Type) GetFILTERPHA() uint32 {
	return volatile.LoadUint32(&o.FILTERPHA.Reg)
}

// QEI.FILTERPHB: Digital filter register on PHB
func (o *QEI_Type) SetFILTERPHB(value uint32) {
	volatile.StoreUint32(&o.FILTERPHB.Reg, value)
}
func (o *QEI_Type) GetFILTERPHB() uint32 {
	return volatile.LoadUint32(&o.FILTERPHB.Reg)
}

// QEI.FILTERINX: Digital filter register on IDX
func (o *QEI_Type) SetFILTERINX(value uint32) {
	volatile.StoreUint32(&o.FILTERINX.Reg, value)
}
func (o *QEI_Type) GetFILTERINX() uint32 {
	return volatile.LoadUint32(&o.FILTERINX.Reg)
}

// QEI.WINDOW: Index acceptance window register
func (o *QEI_Type) SetWINDOW(value uint32) {
	volatile.StoreUint32(&o.WINDOW.Reg, value)
}
func (o *QEI_Type) GetWINDOW() uint32 {
	return volatile.LoadUint32(&o.WINDOW.Reg)
}

// QEI.INXCMP1: Index compare register 1
func (o *QEI_Type) SetINXCMP1(value uint32) {
	volatile.StoreUint32(&o.INXCMP1.Reg, value)
}
func (o *QEI_Type) GetINXCMP1() uint32 {
	return volatile.LoadUint32(&o.INXCMP1.Reg)
}

// QEI.INXCMP2: Index compare register 2
func (o *QEI_Type) SetINXCMP2(value uint32) {
	volatile.StoreUint32(&o.INXCMP2.Reg, value)
}
func (o *QEI_Type) GetINXCMP2() uint32 {
	return volatile.LoadUint32(&o.INXCMP2.Reg)
}

// QEI.IEC: Interrupt enable clear register
func (o *QEI_Type) SetIEC_INX_INT(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x1)|value)
}
func (o *QEI_Type) GetIEC_INX_INT() uint32 {
	return volatile.LoadUint32(&o.IEC.Reg) & 0x1
}
func (o *QEI_Type) SetIEC_TIM_INT(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x2)|value<<1)
}
func (o *QEI_Type) GetIEC_TIM_INT() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x2) >> 1
}
func (o *QEI_Type) SetIEC_VELC_INT(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x4)|value<<2)
}
func (o *QEI_Type) GetIEC_VELC_INT() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x4) >> 2
}
func (o *QEI_Type) SetIEC_DIR_INT(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x8)|value<<3)
}
func (o *QEI_Type) GetIEC_DIR_INT() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x8) >> 3
}
func (o *QEI_Type) SetIEC_ERR_INT(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x10)|value<<4)
}
func (o *QEI_Type) GetIEC_ERR_INT() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x10) >> 4
}
func (o *QEI_Type) SetIEC_ENCLK_INT(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x20)|value<<5)
}
func (o *QEI_Type) GetIEC_ENCLK_INT() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x20) >> 5
}
func (o *QEI_Type) SetIEC_POS0_INT(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x40)|value<<6)
}
func (o *QEI_Type) GetIEC_POS0_INT() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x40) >> 6
}
func (o *QEI_Type) SetIEC_POS1_INT(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x80)|value<<7)
}
func (o *QEI_Type) GetIEC_POS1_INT() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x80) >> 7
}
func (o *QEI_Type) SetIEC_POS2_INT(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x100)|value<<8)
}
func (o *QEI_Type) GetIEC_POS2_INT() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x100) >> 8
}
func (o *QEI_Type) SetIEC_REV0_INT(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x200)|value<<9)
}
func (o *QEI_Type) GetIEC_REV0_INT() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x200) >> 9
}
func (o *QEI_Type) SetIEC_POS0REV_INT(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x400)|value<<10)
}
func (o *QEI_Type) GetIEC_POS0REV_INT() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x400) >> 10
}
func (o *QEI_Type) SetIEC_POS1REV_INT(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x800)|value<<11)
}
func (o *QEI_Type) GetIEC_POS1REV_INT() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x800) >> 11
}
func (o *QEI_Type) SetIEC_POS2REV_INT(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x1000)|value<<12)
}
func (o *QEI_Type) GetIEC_POS2REV_INT() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x1000) >> 12
}
func (o *QEI_Type) SetIEC_REV1_INT(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x2000)|value<<13)
}
func (o *QEI_Type) GetIEC_REV1_INT() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x2000) >> 13
}
func (o *QEI_Type) SetIEC_REV2_INT(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x4000)|value<<14)
}
func (o *QEI_Type) GetIEC_REV2_INT() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x4000) >> 14
}
func (o *QEI_Type) SetIEC_MAXPOS_INT(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0x8000)|value<<15)
}
func (o *QEI_Type) GetIEC_MAXPOS_INT() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0x8000) >> 15
}
func (o *QEI_Type) SetIEC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IEC.Reg, volatile.LoadUint32(&o.IEC.Reg)&^(0xffff0000)|value<<16)
}
func (o *QEI_Type) GetIEC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IEC.Reg) & 0xffff0000) >> 16
}

// QEI.IES: Interrupt enable set register
func (o *QEI_Type) SetIES_INX_INT(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x1)|value)
}
func (o *QEI_Type) GetIES_INX_INT() uint32 {
	return volatile.LoadUint32(&o.IES.Reg) & 0x1
}
func (o *QEI_Type) SetIES_TIM_INT(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x2)|value<<1)
}
func (o *QEI_Type) GetIES_TIM_INT() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x2) >> 1
}
func (o *QEI_Type) SetIES_VELC_INT(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x4)|value<<2)
}
func (o *QEI_Type) GetIES_VELC_INT() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x4) >> 2
}
func (o *QEI_Type) SetIES_DIR_INT(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x8)|value<<3)
}
func (o *QEI_Type) GetIES_DIR_INT() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x8) >> 3
}
func (o *QEI_Type) SetIES_ERR_INT(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x10)|value<<4)
}
func (o *QEI_Type) GetIES_ERR_INT() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x10) >> 4
}
func (o *QEI_Type) SetIES_ENCLK_INT(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x20)|value<<5)
}
func (o *QEI_Type) GetIES_ENCLK_INT() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x20) >> 5
}
func (o *QEI_Type) SetIES_POS0_INT(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x40)|value<<6)
}
func (o *QEI_Type) GetIES_POS0_INT() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x40) >> 6
}
func (o *QEI_Type) SetIES_POS1_INT(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x80)|value<<7)
}
func (o *QEI_Type) GetIES_POS1_INT() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x80) >> 7
}
func (o *QEI_Type) SetIES_POS2_INT(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x100)|value<<8)
}
func (o *QEI_Type) GetIES_POS2_INT() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x100) >> 8
}
func (o *QEI_Type) SetIES_REV0_INT(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x200)|value<<9)
}
func (o *QEI_Type) GetIES_REV0_INT() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x200) >> 9
}
func (o *QEI_Type) SetIES_POS0REV_INT(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x400)|value<<10)
}
func (o *QEI_Type) GetIES_POS0REV_INT() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x400) >> 10
}
func (o *QEI_Type) SetIES_POS1REV_INT(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x800)|value<<11)
}
func (o *QEI_Type) GetIES_POS1REV_INT() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x800) >> 11
}
func (o *QEI_Type) SetIES_POS2REV_INT(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x1000)|value<<12)
}
func (o *QEI_Type) GetIES_POS2REV_INT() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x1000) >> 12
}
func (o *QEI_Type) SetIES_REV1_INT(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x2000)|value<<13)
}
func (o *QEI_Type) GetIES_REV1_INT() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x2000) >> 13
}
func (o *QEI_Type) SetIES_REV2_INT(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x4000)|value<<14)
}
func (o *QEI_Type) GetIES_REV2_INT() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x4000) >> 14
}
func (o *QEI_Type) SetIES_MAXPOS_INT(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0x8000)|value<<15)
}
func (o *QEI_Type) GetIES_MAXPOS_INT() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0x8000) >> 15
}
func (o *QEI_Type) SetIES_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IES.Reg, volatile.LoadUint32(&o.IES.Reg)&^(0xffff0000)|value<<16)
}
func (o *QEI_Type) GetIES_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IES.Reg) & 0xffff0000) >> 16
}

// QEI.INTSTAT: Interrupt status register
func (o *QEI_Type) SetINTSTAT_INX_INT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x1)|value)
}
func (o *QEI_Type) GetINTSTAT_INX_INT() uint32 {
	return volatile.LoadUint32(&o.INTSTAT.Reg) & 0x1
}
func (o *QEI_Type) SetINTSTAT_TIM_INT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x2)|value<<1)
}
func (o *QEI_Type) GetINTSTAT_TIM_INT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x2) >> 1
}
func (o *QEI_Type) SetINTSTAT_VELC_INT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x4)|value<<2)
}
func (o *QEI_Type) GetINTSTAT_VELC_INT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x4) >> 2
}
func (o *QEI_Type) SetINTSTAT_DIR_INT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x8)|value<<3)
}
func (o *QEI_Type) GetINTSTAT_DIR_INT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x8) >> 3
}
func (o *QEI_Type) SetINTSTAT_ERR_INT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x10)|value<<4)
}
func (o *QEI_Type) GetINTSTAT_ERR_INT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x10) >> 4
}
func (o *QEI_Type) SetINTSTAT_ENCLK_INT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x20)|value<<5)
}
func (o *QEI_Type) GetINTSTAT_ENCLK_INT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x20) >> 5
}
func (o *QEI_Type) SetINTSTAT_POS0_INT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x40)|value<<6)
}
func (o *QEI_Type) GetINTSTAT_POS0_INT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x40) >> 6
}
func (o *QEI_Type) SetINTSTAT_POS1_INT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x80)|value<<7)
}
func (o *QEI_Type) GetINTSTAT_POS1_INT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x80) >> 7
}
func (o *QEI_Type) SetINTSTAT_POS2_INT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x100)|value<<8)
}
func (o *QEI_Type) GetINTSTAT_POS2_INT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x100) >> 8
}
func (o *QEI_Type) SetINTSTAT_REV0_INT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x200)|value<<9)
}
func (o *QEI_Type) GetINTSTAT_REV0_INT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x200) >> 9
}
func (o *QEI_Type) SetINTSTAT_POS0REV_INT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x400)|value<<10)
}
func (o *QEI_Type) GetINTSTAT_POS0REV_INT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x400) >> 10
}
func (o *QEI_Type) SetINTSTAT_POS1REV_INT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x800)|value<<11)
}
func (o *QEI_Type) GetINTSTAT_POS1REV_INT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x800) >> 11
}
func (o *QEI_Type) SetINTSTAT_POS2REV_INT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x1000)|value<<12)
}
func (o *QEI_Type) GetINTSTAT_POS2REV_INT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x1000) >> 12
}
func (o *QEI_Type) SetINTSTAT_REV1_INT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x2000)|value<<13)
}
func (o *QEI_Type) GetINTSTAT_REV1_INT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x2000) >> 13
}
func (o *QEI_Type) SetINTSTAT_REV2_INT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x4000)|value<<14)
}
func (o *QEI_Type) GetINTSTAT_REV2_INT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x4000) >> 14
}
func (o *QEI_Type) SetINTSTAT_MAXPOS_INT(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0x8000)|value<<15)
}
func (o *QEI_Type) GetINTSTAT_MAXPOS_INT() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0x8000) >> 15
}
func (o *QEI_Type) SetINTSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTSTAT.Reg, volatile.LoadUint32(&o.INTSTAT.Reg)&^(0xffff0000)|value<<16)
}
func (o *QEI_Type) GetINTSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTSTAT.Reg) & 0xffff0000) >> 16
}

// QEI.IE: Interrupt enable register
func (o *QEI_Type) SetIE_INX_INT(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x1)|value)
}
func (o *QEI_Type) GetIE_INX_INT() uint32 {
	return volatile.LoadUint32(&o.IE.Reg) & 0x1
}
func (o *QEI_Type) SetIE_TIM_INT(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x2)|value<<1)
}
func (o *QEI_Type) GetIE_TIM_INT() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x2) >> 1
}
func (o *QEI_Type) SetIE_VELC_INT(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x4)|value<<2)
}
func (o *QEI_Type) GetIE_VELC_INT() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x4) >> 2
}
func (o *QEI_Type) SetIE_DIR_INT(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x8)|value<<3)
}
func (o *QEI_Type) GetIE_DIR_INT() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x8) >> 3
}
func (o *QEI_Type) SetIE_ERR_INT(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x10)|value<<4)
}
func (o *QEI_Type) GetIE_ERR_INT() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x10) >> 4
}
func (o *QEI_Type) SetIE_ENCLK_INT(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x20)|value<<5)
}
func (o *QEI_Type) GetIE_ENCLK_INT() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x20) >> 5
}
func (o *QEI_Type) SetIE_POS0_INT(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x40)|value<<6)
}
func (o *QEI_Type) GetIE_POS0_INT() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x40) >> 6
}
func (o *QEI_Type) SetIE_POS1_INT(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x80)|value<<7)
}
func (o *QEI_Type) GetIE_POS1_INT() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x80) >> 7
}
func (o *QEI_Type) SetIE_POS2_INT(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x100)|value<<8)
}
func (o *QEI_Type) GetIE_POS2_INT() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x100) >> 8
}
func (o *QEI_Type) SetIE_REV0_INT(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x200)|value<<9)
}
func (o *QEI_Type) GetIE_REV0_INT() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x200) >> 9
}
func (o *QEI_Type) SetIE_POS0REV_INT(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x400)|value<<10)
}
func (o *QEI_Type) GetIE_POS0REV_INT() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x400) >> 10
}
func (o *QEI_Type) SetIE_POS1REV_INT(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x800)|value<<11)
}
func (o *QEI_Type) GetIE_POS1REV_INT() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x800) >> 11
}
func (o *QEI_Type) SetIE_POS2REV_INT(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x1000)|value<<12)
}
func (o *QEI_Type) GetIE_POS2REV_INT() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x1000) >> 12
}
func (o *QEI_Type) SetIE_REV1_INT(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x2000)|value<<13)
}
func (o *QEI_Type) GetIE_REV1_INT() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x2000) >> 13
}
func (o *QEI_Type) SetIE_REV2_INT(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x4000)|value<<14)
}
func (o *QEI_Type) GetIE_REV2_INT() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x4000) >> 14
}
func (o *QEI_Type) SetIE_MAXPOS_INT(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x8000)|value<<15)
}
func (o *QEI_Type) GetIE_MAXPOS_INT() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x8000) >> 15
}
func (o *QEI_Type) SetIE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0xffff0000)|value<<16)
}
func (o *QEI_Type) GetIE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0xffff0000) >> 16
}

// QEI.CLR: Interrupt status clear register
func (o *QEI_Type) SetCLR_INX_INT(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x1)|value)
}
func (o *QEI_Type) GetCLR_INX_INT() uint32 {
	return volatile.LoadUint32(&o.CLR.Reg) & 0x1
}
func (o *QEI_Type) SetCLR_TIM_INT(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x2)|value<<1)
}
func (o *QEI_Type) GetCLR_TIM_INT() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0x2) >> 1
}
func (o *QEI_Type) SetCLR_VELC_INT(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x4)|value<<2)
}
func (o *QEI_Type) GetCLR_VELC_INT() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0x4) >> 2
}
func (o *QEI_Type) SetCLR_DIR_INT(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x8)|value<<3)
}
func (o *QEI_Type) GetCLR_DIR_INT() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0x8) >> 3
}
func (o *QEI_Type) SetCLR_ERR_INT(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x10)|value<<4)
}
func (o *QEI_Type) GetCLR_ERR_INT() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0x10) >> 4
}
func (o *QEI_Type) SetCLR_ENCLK_INT(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x20)|value<<5)
}
func (o *QEI_Type) GetCLR_ENCLK_INT() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0x20) >> 5
}
func (o *QEI_Type) SetCLR_POS0_INT(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x40)|value<<6)
}
func (o *QEI_Type) GetCLR_POS0_INT() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0x40) >> 6
}
func (o *QEI_Type) SetCLR_POS1_INT(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x80)|value<<7)
}
func (o *QEI_Type) GetCLR_POS1_INT() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0x80) >> 7
}
func (o *QEI_Type) SetCLR_POS2_INT(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x100)|value<<8)
}
func (o *QEI_Type) GetCLR_POS2_INT() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0x100) >> 8
}
func (o *QEI_Type) SetCLR_REV0_INT(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x200)|value<<9)
}
func (o *QEI_Type) GetCLR_REV0_INT() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0x200) >> 9
}
func (o *QEI_Type) SetCLR_POS0REV_INT(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x400)|value<<10)
}
func (o *QEI_Type) GetCLR_POS0REV_INT() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0x400) >> 10
}
func (o *QEI_Type) SetCLR_POS1REV_INT(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x800)|value<<11)
}
func (o *QEI_Type) GetCLR_POS1REV_INT() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0x800) >> 11
}
func (o *QEI_Type) SetCLR_POS2REV_INT(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x1000)|value<<12)
}
func (o *QEI_Type) GetCLR_POS2REV_INT() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0x1000) >> 12
}
func (o *QEI_Type) SetCLR_REV1_INT(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x2000)|value<<13)
}
func (o *QEI_Type) GetCLR_REV1_INT() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0x2000) >> 13
}
func (o *QEI_Type) SetCLR_REV2_INT(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x4000)|value<<14)
}
func (o *QEI_Type) GetCLR_REV2_INT() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0x4000) >> 14
}
func (o *QEI_Type) SetCLR_MAXPOS_INT(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0x8000)|value<<15)
}
func (o *QEI_Type) GetCLR_MAXPOS_INT() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0x8000) >> 15
}
func (o *QEI_Type) SetCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLR.Reg, volatile.LoadUint32(&o.CLR.Reg)&^(0xffff0000)|value<<16)
}
func (o *QEI_Type) GetCLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLR.Reg) & 0xffff0000) >> 16
}

// QEI.SET: Interrupt status set register
func (o *QEI_Type) SetSET_INX_INT(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x1)|value)
}
func (o *QEI_Type) GetSET_INX_INT() uint32 {
	return volatile.LoadUint32(&o.SET.Reg) & 0x1
}
func (o *QEI_Type) SetSET_TIM_INT(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x2)|value<<1)
}
func (o *QEI_Type) GetSET_TIM_INT() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x2) >> 1
}
func (o *QEI_Type) SetSET_VELC_INT(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x4)|value<<2)
}
func (o *QEI_Type) GetSET_VELC_INT() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x4) >> 2
}
func (o *QEI_Type) SetSET_DIR_INT(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x8)|value<<3)
}
func (o *QEI_Type) GetSET_DIR_INT() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x8) >> 3
}
func (o *QEI_Type) SetSET_ERR_INT(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x10)|value<<4)
}
func (o *QEI_Type) GetSET_ERR_INT() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x10) >> 4
}
func (o *QEI_Type) SetSET_ENCLK_INT(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x20)|value<<5)
}
func (o *QEI_Type) GetSET_ENCLK_INT() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x20) >> 5
}
func (o *QEI_Type) SetSET_POS0_INT(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x40)|value<<6)
}
func (o *QEI_Type) GetSET_POS0_INT() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x40) >> 6
}
func (o *QEI_Type) SetSET_POS1_INT(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x80)|value<<7)
}
func (o *QEI_Type) GetSET_POS1_INT() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x80) >> 7
}
func (o *QEI_Type) SetSET_POS2_INT(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x100)|value<<8)
}
func (o *QEI_Type) GetSET_POS2_INT() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x100) >> 8
}
func (o *QEI_Type) SetSET_REV0_INT(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x200)|value<<9)
}
func (o *QEI_Type) GetSET_REV0_INT() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x200) >> 9
}
func (o *QEI_Type) SetSET_POS0REV_INT(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x400)|value<<10)
}
func (o *QEI_Type) GetSET_POS0REV_INT() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x400) >> 10
}
func (o *QEI_Type) SetSET_POS1REV_INT(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x800)|value<<11)
}
func (o *QEI_Type) GetSET_POS1REV_INT() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x800) >> 11
}
func (o *QEI_Type) SetSET_POS2REV_INT(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x1000)|value<<12)
}
func (o *QEI_Type) GetSET_POS2REV_INT() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x1000) >> 12
}
func (o *QEI_Type) SetSET_REV1_INT(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x2000)|value<<13)
}
func (o *QEI_Type) GetSET_REV1_INT() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x2000) >> 13
}
func (o *QEI_Type) SetSET_REV2_INT(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x4000)|value<<14)
}
func (o *QEI_Type) GetSET_REV2_INT() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x4000) >> 14
}
func (o *QEI_Type) SetSET_MAXPOS_INT(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0x8000)|value<<15)
}
func (o *QEI_Type) GetSET_MAXPOS_INT() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0x8000) >> 15
}
func (o *QEI_Type) SetSET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SET.Reg, volatile.LoadUint32(&o.SET.Reg)&^(0xffff0000)|value<<16)
}
func (o *QEI_Type) GetSET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SET.Reg) & 0xffff0000) >> 16
}

// SD card
type SDMMC_Type struct {
	PWR        volatile.Register32 // 0x0
	CLOCK      volatile.Register32 // 0x4
	ARGUMENT   volatile.Register32 // 0x8
	COMMAND    volatile.Register32 // 0xC
	RESPCMD    volatile.Register32 // 0x10
	RESPONSE0  volatile.Register32 // 0x14
	RESPONSE1  volatile.Register32 // 0x18
	RESPONSE2  volatile.Register32 // 0x1C
	RESPONSE3  volatile.Register32 // 0x20
	DATATIMER  volatile.Register32 // 0x24
	DATALENGTH volatile.Register32 // 0x28
	DATACTRL   volatile.Register32 // 0x2C
	DATACNT    volatile.Register32 // 0x30
	STATUS     volatile.Register32 // 0x34
	CLEAR      volatile.Register32 // 0x38
	MASK0      volatile.Register32 // 0x3C
	_          [8]byte
	FIFOCNT    volatile.Register32 // 0x48
	_          [52]byte
	FIFO0      volatile.Register32 // 0x80
	FIFO1      volatile.Register32 // 0x84
	FIFO2      volatile.Register32 // 0x88
	FIFO3      volatile.Register32 // 0x8C
	FIFO4      volatile.Register32 // 0x90
	FIFO5      volatile.Register32 // 0x94
	FIFO6      volatile.Register32 // 0x98
	FIFO7      volatile.Register32 // 0x9C
	FIFO8      volatile.Register32 // 0xA0
	FIFO9      volatile.Register32 // 0xA4
	FIFO10     volatile.Register32 // 0xA8
	FIFO11     volatile.Register32 // 0xAC
	FIFO12     volatile.Register32 // 0xB0
	FIFO13     volatile.Register32 // 0xB4
	FIFO14     volatile.Register32 // 0xB8
	FIFO15     volatile.Register32 // 0xBC
}

// SDMMC.PWR: Power control register.
func (o *SDMMC_Type) SetPWR_CTRL(value uint32) {
	volatile.StoreUint32(&o.PWR.Reg, volatile.LoadUint32(&o.PWR.Reg)&^(0x3)|value)
}
func (o *SDMMC_Type) GetPWR_CTRL() uint32 {
	return volatile.LoadUint32(&o.PWR.Reg) & 0x3
}
func (o *SDMMC_Type) SetPWR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PWR.Reg, volatile.LoadUint32(&o.PWR.Reg)&^(0x3c)|value<<2)
}
func (o *SDMMC_Type) GetPWR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PWR.Reg) & 0x3c) >> 2
}
func (o *SDMMC_Type) SetPWR_OPENDRAIN(value uint32) {
	volatile.StoreUint32(&o.PWR.Reg, volatile.LoadUint32(&o.PWR.Reg)&^(0x40)|value<<6)
}
func (o *SDMMC_Type) GetPWR_OPENDRAIN() uint32 {
	return (volatile.LoadUint32(&o.PWR.Reg) & 0x40) >> 6
}
func (o *SDMMC_Type) SetPWR_ROD(value uint32) {
	volatile.StoreUint32(&o.PWR.Reg, volatile.LoadUint32(&o.PWR.Reg)&^(0x80)|value<<7)
}
func (o *SDMMC_Type) GetPWR_ROD() uint32 {
	return (volatile.LoadUint32(&o.PWR.Reg) & 0x80) >> 7
}
func (o *SDMMC_Type) SetPWR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PWR.Reg, volatile.LoadUint32(&o.PWR.Reg)&^(0xffffff00)|value<<8)
}
func (o *SDMMC_Type) GetPWR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PWR.Reg) & 0xffffff00) >> 8
}

// SDMMC.CLOCK: Clock control register.
func (o *SDMMC_Type) SetCLOCK_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.CLOCK.Reg, volatile.LoadUint32(&o.CLOCK.Reg)&^(0xff)|value)
}
func (o *SDMMC_Type) GetCLOCK_CLKDIV() uint32 {
	return volatile.LoadUint32(&o.CLOCK.Reg) & 0xff
}
func (o *SDMMC_Type) SetCLOCK_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CLOCK.Reg, volatile.LoadUint32(&o.CLOCK.Reg)&^(0x100)|value<<8)
}
func (o *SDMMC_Type) GetCLOCK_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CLOCK.Reg) & 0x100) >> 8
}
func (o *SDMMC_Type) SetCLOCK_PWRSAVE(value uint32) {
	volatile.StoreUint32(&o.CLOCK.Reg, volatile.LoadUint32(&o.CLOCK.Reg)&^(0x200)|value<<9)
}
func (o *SDMMC_Type) GetCLOCK_PWRSAVE() uint32 {
	return (volatile.LoadUint32(&o.CLOCK.Reg) & 0x200) >> 9
}
func (o *SDMMC_Type) SetCLOCK_BYPASS(value uint32) {
	volatile.StoreUint32(&o.CLOCK.Reg, volatile.LoadUint32(&o.CLOCK.Reg)&^(0x400)|value<<10)
}
func (o *SDMMC_Type) GetCLOCK_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.CLOCK.Reg) & 0x400) >> 10
}
func (o *SDMMC_Type) SetCLOCK_WIDEBUS(value uint32) {
	volatile.StoreUint32(&o.CLOCK.Reg, volatile.LoadUint32(&o.CLOCK.Reg)&^(0x800)|value<<11)
}
func (o *SDMMC_Type) GetCLOCK_WIDEBUS() uint32 {
	return (volatile.LoadUint32(&o.CLOCK.Reg) & 0x800) >> 11
}
func (o *SDMMC_Type) SetCLOCK_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLOCK.Reg, volatile.LoadUint32(&o.CLOCK.Reg)&^(0xfffff000)|value<<12)
}
func (o *SDMMC_Type) GetCLOCK_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLOCK.Reg) & 0xfffff000) >> 12
}

// SDMMC.ARGUMENT: Argument register.
func (o *SDMMC_Type) SetARGUMENT(value uint32) {
	volatile.StoreUint32(&o.ARGUMENT.Reg, value)
}
func (o *SDMMC_Type) GetARGUMENT() uint32 {
	return volatile.LoadUint32(&o.ARGUMENT.Reg)
}

// SDMMC.COMMAND: Command register.
func (o *SDMMC_Type) SetCOMMAND_CmdIndex(value uint32) {
	volatile.StoreUint32(&o.COMMAND.Reg, volatile.LoadUint32(&o.COMMAND.Reg)&^(0x3f)|value)
}
func (o *SDMMC_Type) GetCOMMAND_CmdIndex() uint32 {
	return volatile.LoadUint32(&o.COMMAND.Reg) & 0x3f
}
func (o *SDMMC_Type) SetCOMMAND_Response(value uint32) {
	volatile.StoreUint32(&o.COMMAND.Reg, volatile.LoadUint32(&o.COMMAND.Reg)&^(0x40)|value<<6)
}
func (o *SDMMC_Type) GetCOMMAND_Response() uint32 {
	return (volatile.LoadUint32(&o.COMMAND.Reg) & 0x40) >> 6
}
func (o *SDMMC_Type) SetCOMMAND_LongRsp(value uint32) {
	volatile.StoreUint32(&o.COMMAND.Reg, volatile.LoadUint32(&o.COMMAND.Reg)&^(0x80)|value<<7)
}
func (o *SDMMC_Type) GetCOMMAND_LongRsp() uint32 {
	return (volatile.LoadUint32(&o.COMMAND.Reg) & 0x80) >> 7
}
func (o *SDMMC_Type) SetCOMMAND_Interrupt(value uint32) {
	volatile.StoreUint32(&o.COMMAND.Reg, volatile.LoadUint32(&o.COMMAND.Reg)&^(0x100)|value<<8)
}
func (o *SDMMC_Type) GetCOMMAND_Interrupt() uint32 {
	return (volatile.LoadUint32(&o.COMMAND.Reg) & 0x100) >> 8
}
func (o *SDMMC_Type) SetCOMMAND_Pending(value uint32) {
	volatile.StoreUint32(&o.COMMAND.Reg, volatile.LoadUint32(&o.COMMAND.Reg)&^(0x200)|value<<9)
}
func (o *SDMMC_Type) GetCOMMAND_Pending() uint32 {
	return (volatile.LoadUint32(&o.COMMAND.Reg) & 0x200) >> 9
}
func (o *SDMMC_Type) SetCOMMAND_Enable(value uint32) {
	volatile.StoreUint32(&o.COMMAND.Reg, volatile.LoadUint32(&o.COMMAND.Reg)&^(0x400)|value<<10)
}
func (o *SDMMC_Type) GetCOMMAND_Enable() uint32 {
	return (volatile.LoadUint32(&o.COMMAND.Reg) & 0x400) >> 10
}
func (o *SDMMC_Type) SetCOMMAND_RESERVED(value uint32) {
	volatile.StoreUint32(&o.COMMAND.Reg, volatile.LoadUint32(&o.COMMAND.Reg)&^(0xfffff800)|value<<11)
}
func (o *SDMMC_Type) GetCOMMAND_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.COMMAND.Reg) & 0xfffff800) >> 11
}

// SDMMC.RESPCMD: Response command register.
func (o *SDMMC_Type) SetRESPCMD(value uint32) {
	volatile.StoreUint32(&o.RESPCMD.Reg, volatile.LoadUint32(&o.RESPCMD.Reg)&^(0x3f)|value)
}
func (o *SDMMC_Type) GetRESPCMD() uint32 {
	return volatile.LoadUint32(&o.RESPCMD.Reg) & 0x3f
}
func (o *SDMMC_Type) SetRESPCMD_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RESPCMD.Reg, volatile.LoadUint32(&o.RESPCMD.Reg)&^(0xffffffc0)|value<<6)
}
func (o *SDMMC_Type) GetRESPCMD_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RESPCMD.Reg) & 0xffffffc0) >> 6
}

// SDMMC.RESPONSE0: Response register.
func (o *SDMMC_Type) SetRESPONSE0(value uint32) {
	volatile.StoreUint32(&o.RESPONSE0.Reg, value)
}
func (o *SDMMC_Type) GetRESPONSE0() uint32 {
	return volatile.LoadUint32(&o.RESPONSE0.Reg)
}

// SDMMC.RESPONSE1: Response register.
func (o *SDMMC_Type) SetRESPONSE1(value uint32) {
	volatile.StoreUint32(&o.RESPONSE1.Reg, value)
}
func (o *SDMMC_Type) GetRESPONSE1() uint32 {
	return volatile.LoadUint32(&o.RESPONSE1.Reg)
}

// SDMMC.RESPONSE2: Response register.
func (o *SDMMC_Type) SetRESPONSE2(value uint32) {
	volatile.StoreUint32(&o.RESPONSE2.Reg, value)
}
func (o *SDMMC_Type) GetRESPONSE2() uint32 {
	return volatile.LoadUint32(&o.RESPONSE2.Reg)
}

// SDMMC.RESPONSE3: Response register.
func (o *SDMMC_Type) SetRESPONSE3(value uint32) {
	volatile.StoreUint32(&o.RESPONSE3.Reg, value)
}
func (o *SDMMC_Type) GetRESPONSE3() uint32 {
	return volatile.LoadUint32(&o.RESPONSE3.Reg)
}

// SDMMC.DATATIMER: Data Timer.
func (o *SDMMC_Type) SetDATATIMER(value uint32) {
	volatile.StoreUint32(&o.DATATIMER.Reg, value)
}
func (o *SDMMC_Type) GetDATATIMER() uint32 {
	return volatile.LoadUint32(&o.DATATIMER.Reg)
}

// SDMMC.DATALENGTH: Data length register.
func (o *SDMMC_Type) SetDATALENGTH(value uint32) {
	volatile.StoreUint32(&o.DATALENGTH.Reg, volatile.LoadUint32(&o.DATALENGTH.Reg)&^(0xffff)|value)
}
func (o *SDMMC_Type) GetDATALENGTH() uint32 {
	return volatile.LoadUint32(&o.DATALENGTH.Reg) & 0xffff
}
func (o *SDMMC_Type) SetDATALENGTH_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DATALENGTH.Reg, volatile.LoadUint32(&o.DATALENGTH.Reg)&^(0xffff0000)|value<<16)
}
func (o *SDMMC_Type) GetDATALENGTH_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DATALENGTH.Reg) & 0xffff0000) >> 16
}

// SDMMC.DATACTRL: Data control register.
func (o *SDMMC_Type) SetDATACTRL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.DATACTRL.Reg, volatile.LoadUint32(&o.DATACTRL.Reg)&^(0x1)|value)
}
func (o *SDMMC_Type) GetDATACTRL_ENABLE() uint32 {
	return volatile.LoadUint32(&o.DATACTRL.Reg) & 0x1
}
func (o *SDMMC_Type) SetDATACTRL_DIRECTION(value uint32) {
	volatile.StoreUint32(&o.DATACTRL.Reg, volatile.LoadUint32(&o.DATACTRL.Reg)&^(0x2)|value<<1)
}
func (o *SDMMC_Type) GetDATACTRL_DIRECTION() uint32 {
	return (volatile.LoadUint32(&o.DATACTRL.Reg) & 0x2) >> 1
}
func (o *SDMMC_Type) SetDATACTRL_MODE(value uint32) {
	volatile.StoreUint32(&o.DATACTRL.Reg, volatile.LoadUint32(&o.DATACTRL.Reg)&^(0x4)|value<<2)
}
func (o *SDMMC_Type) GetDATACTRL_MODE() uint32 {
	return (volatile.LoadUint32(&o.DATACTRL.Reg) & 0x4) >> 2
}
func (o *SDMMC_Type) SetDATACTRL_DMAENABLE(value uint32) {
	volatile.StoreUint32(&o.DATACTRL.Reg, volatile.LoadUint32(&o.DATACTRL.Reg)&^(0x8)|value<<3)
}
func (o *SDMMC_Type) GetDATACTRL_DMAENABLE() uint32 {
	return (volatile.LoadUint32(&o.DATACTRL.Reg) & 0x8) >> 3
}
func (o *SDMMC_Type) SetDATACTRL_BLOCKSIZE(value uint32) {
	volatile.StoreUint32(&o.DATACTRL.Reg, volatile.LoadUint32(&o.DATACTRL.Reg)&^(0xf0)|value<<4)
}
func (o *SDMMC_Type) GetDATACTRL_BLOCKSIZE() uint32 {
	return (volatile.LoadUint32(&o.DATACTRL.Reg) & 0xf0) >> 4
}
func (o *SDMMC_Type) SetDATACTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DATACTRL.Reg, volatile.LoadUint32(&o.DATACTRL.Reg)&^(0xffffff00)|value<<8)
}
func (o *SDMMC_Type) GetDATACTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DATACTRL.Reg) & 0xffffff00) >> 8
}

// SDMMC.DATACNT: Data counter.
func (o *SDMMC_Type) SetDATACNT_DATACOUNT(value uint32) {
	volatile.StoreUint32(&o.DATACNT.Reg, volatile.LoadUint32(&o.DATACNT.Reg)&^(0xffff)|value)
}
func (o *SDMMC_Type) GetDATACNT_DATACOUNT() uint32 {
	return volatile.LoadUint32(&o.DATACNT.Reg) & 0xffff
}
func (o *SDMMC_Type) SetDATACNT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DATACNT.Reg, volatile.LoadUint32(&o.DATACNT.Reg)&^(0xffff0000)|value<<16)
}
func (o *SDMMC_Type) GetDATACNT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DATACNT.Reg) & 0xffff0000) >> 16
}

// SDMMC.STATUS: Status register.
func (o *SDMMC_Type) SetSTATUS_CMDCRCFAIL(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *SDMMC_Type) GetSTATUS_CMDCRCFAIL() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1
}
func (o *SDMMC_Type) SetSTATUS_DATACRCFAIL(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *SDMMC_Type) GetSTATUS_DATACRCFAIL() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *SDMMC_Type) SetSTATUS_CMDTIMEOUT(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x4)|value<<2)
}
func (o *SDMMC_Type) GetSTATUS_CMDTIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x4) >> 2
}
func (o *SDMMC_Type) SetSTATUS_DATATIMEOUT(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x8)|value<<3)
}
func (o *SDMMC_Type) GetSTATUS_DATATIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x8) >> 3
}
func (o *SDMMC_Type) SetSTATUS_TXUNDERRUN(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x10)|value<<4)
}
func (o *SDMMC_Type) GetSTATUS_TXUNDERRUN() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x10) >> 4
}
func (o *SDMMC_Type) SetSTATUS_RXOVERRUN(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x20)|value<<5)
}
func (o *SDMMC_Type) GetSTATUS_RXOVERRUN() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x20) >> 5
}
func (o *SDMMC_Type) SetSTATUS_CMDRESPEND(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x40)|value<<6)
}
func (o *SDMMC_Type) GetSTATUS_CMDRESPEND() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x40) >> 6
}
func (o *SDMMC_Type) SetSTATUS_CMDSENT(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x80)|value<<7)
}
func (o *SDMMC_Type) GetSTATUS_CMDSENT() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x80) >> 7
}
func (o *SDMMC_Type) SetSTATUS_DATAEND(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x100)|value<<8)
}
func (o *SDMMC_Type) GetSTATUS_DATAEND() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x100) >> 8
}
func (o *SDMMC_Type) SetSTATUS_STARTBITERR(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x200)|value<<9)
}
func (o *SDMMC_Type) GetSTATUS_STARTBITERR() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x200) >> 9
}
func (o *SDMMC_Type) SetSTATUS_DATABLOCKEND(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x400)|value<<10)
}
func (o *SDMMC_Type) GetSTATUS_DATABLOCKEND() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x400) >> 10
}
func (o *SDMMC_Type) SetSTATUS_CMDACTIVE(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x800)|value<<11)
}
func (o *SDMMC_Type) GetSTATUS_CMDACTIVE() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x800) >> 11
}
func (o *SDMMC_Type) SetSTATUS_TXACTIVE(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *SDMMC_Type) GetSTATUS_TXACTIVE() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x1000) >> 12
}
func (o *SDMMC_Type) SetSTATUS_RXACTIVE(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *SDMMC_Type) GetSTATUS_RXACTIVE() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2000) >> 13
}
func (o *SDMMC_Type) SetSTATUS_TXFIFOHALFEMPTY(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x4000)|value<<14)
}
func (o *SDMMC_Type) GetSTATUS_TXFIFOHALFEMPTY() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x4000) >> 14
}
func (o *SDMMC_Type) SetSTATUS_RXFIFOHALFFULL(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x8000)|value<<15)
}
func (o *SDMMC_Type) GetSTATUS_RXFIFOHALFFULL() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x8000) >> 15
}
func (o *SDMMC_Type) SetSTATUS_TXFIFOFULL(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x10000)|value<<16)
}
func (o *SDMMC_Type) GetSTATUS_TXFIFOFULL() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x10000) >> 16
}
func (o *SDMMC_Type) SetSTATUS_RXFIFOFULL(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x20000)|value<<17)
}
func (o *SDMMC_Type) GetSTATUS_RXFIFOFULL() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x20000) >> 17
}
func (o *SDMMC_Type) SetSTATUS_TXFIFOEMPTY(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x40000)|value<<18)
}
func (o *SDMMC_Type) GetSTATUS_TXFIFOEMPTY() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x40000) >> 18
}
func (o *SDMMC_Type) SetSTATUS_RXFIFOEMPTY(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x80000)|value<<19)
}
func (o *SDMMC_Type) GetSTATUS_RXFIFOEMPTY() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x80000) >> 19
}
func (o *SDMMC_Type) SetSTATUS_TXDATAAVLBL(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x100000)|value<<20)
}
func (o *SDMMC_Type) GetSTATUS_TXDATAAVLBL() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x100000) >> 20
}
func (o *SDMMC_Type) SetSTATUS_RXDATAAVLBL(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x200000)|value<<21)
}
func (o *SDMMC_Type) GetSTATUS_RXDATAAVLBL() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x200000) >> 21
}
func (o *SDMMC_Type) SetSTATUS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0xffc00000)|value<<22)
}
func (o *SDMMC_Type) GetSTATUS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0xffc00000) >> 22
}

// SDMMC.CLEAR: Clear register.
func (o *SDMMC_Type) SetCLEAR_CMDCRCFAILCLR(value uint32) {
	volatile.StoreUint32(&o.CLEAR.Reg, volatile.LoadUint32(&o.CLEAR.Reg)&^(0x1)|value)
}
func (o *SDMMC_Type) GetCLEAR_CMDCRCFAILCLR() uint32 {
	return volatile.LoadUint32(&o.CLEAR.Reg) & 0x1
}
func (o *SDMMC_Type) SetCLEAR_DATACRCFAILCLR(value uint32) {
	volatile.StoreUint32(&o.CLEAR.Reg, volatile.LoadUint32(&o.CLEAR.Reg)&^(0x2)|value<<1)
}
func (o *SDMMC_Type) GetCLEAR_DATACRCFAILCLR() uint32 {
	return (volatile.LoadUint32(&o.CLEAR.Reg) & 0x2) >> 1
}
func (o *SDMMC_Type) SetCLEAR_CMDTIMEOUTCLR(value uint32) {
	volatile.StoreUint32(&o.CLEAR.Reg, volatile.LoadUint32(&o.CLEAR.Reg)&^(0x4)|value<<2)
}
func (o *SDMMC_Type) GetCLEAR_CMDTIMEOUTCLR() uint32 {
	return (volatile.LoadUint32(&o.CLEAR.Reg) & 0x4) >> 2
}
func (o *SDMMC_Type) SetCLEAR_DATATIMEOUTCLR(value uint32) {
	volatile.StoreUint32(&o.CLEAR.Reg, volatile.LoadUint32(&o.CLEAR.Reg)&^(0x8)|value<<3)
}
func (o *SDMMC_Type) GetCLEAR_DATATIMEOUTCLR() uint32 {
	return (volatile.LoadUint32(&o.CLEAR.Reg) & 0x8) >> 3
}
func (o *SDMMC_Type) SetCLEAR_TXUNDERRUNCLR(value uint32) {
	volatile.StoreUint32(&o.CLEAR.Reg, volatile.LoadUint32(&o.CLEAR.Reg)&^(0x10)|value<<4)
}
func (o *SDMMC_Type) GetCLEAR_TXUNDERRUNCLR() uint32 {
	return (volatile.LoadUint32(&o.CLEAR.Reg) & 0x10) >> 4
}
func (o *SDMMC_Type) SetCLEAR_RXOVERRUNCLR(value uint32) {
	volatile.StoreUint32(&o.CLEAR.Reg, volatile.LoadUint32(&o.CLEAR.Reg)&^(0x20)|value<<5)
}
func (o *SDMMC_Type) GetCLEAR_RXOVERRUNCLR() uint32 {
	return (volatile.LoadUint32(&o.CLEAR.Reg) & 0x20) >> 5
}
func (o *SDMMC_Type) SetCLEAR_CMDRESPENDCLR(value uint32) {
	volatile.StoreUint32(&o.CLEAR.Reg, volatile.LoadUint32(&o.CLEAR.Reg)&^(0x40)|value<<6)
}
func (o *SDMMC_Type) GetCLEAR_CMDRESPENDCLR() uint32 {
	return (volatile.LoadUint32(&o.CLEAR.Reg) & 0x40) >> 6
}
func (o *SDMMC_Type) SetCLEAR_CMDSENTCLR(value uint32) {
	volatile.StoreUint32(&o.CLEAR.Reg, volatile.LoadUint32(&o.CLEAR.Reg)&^(0x80)|value<<7)
}
func (o *SDMMC_Type) GetCLEAR_CMDSENTCLR() uint32 {
	return (volatile.LoadUint32(&o.CLEAR.Reg) & 0x80) >> 7
}
func (o *SDMMC_Type) SetCLEAR_DATAENDCLR(value uint32) {
	volatile.StoreUint32(&o.CLEAR.Reg, volatile.LoadUint32(&o.CLEAR.Reg)&^(0x100)|value<<8)
}
func (o *SDMMC_Type) GetCLEAR_DATAENDCLR() uint32 {
	return (volatile.LoadUint32(&o.CLEAR.Reg) & 0x100) >> 8
}
func (o *SDMMC_Type) SetCLEAR_STARTBITERRCLR(value uint32) {
	volatile.StoreUint32(&o.CLEAR.Reg, volatile.LoadUint32(&o.CLEAR.Reg)&^(0x200)|value<<9)
}
func (o *SDMMC_Type) GetCLEAR_STARTBITERRCLR() uint32 {
	return (volatile.LoadUint32(&o.CLEAR.Reg) & 0x200) >> 9
}
func (o *SDMMC_Type) SetCLEAR_DATABLOCKENDCLR(value uint32) {
	volatile.StoreUint32(&o.CLEAR.Reg, volatile.LoadUint32(&o.CLEAR.Reg)&^(0x400)|value<<10)
}
func (o *SDMMC_Type) GetCLEAR_DATABLOCKENDCLR() uint32 {
	return (volatile.LoadUint32(&o.CLEAR.Reg) & 0x400) >> 10
}
func (o *SDMMC_Type) SetCLEAR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLEAR.Reg, volatile.LoadUint32(&o.CLEAR.Reg)&^(0xfffff800)|value<<11)
}
func (o *SDMMC_Type) GetCLEAR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLEAR.Reg) & 0xfffff800) >> 11
}

// SDMMC.MASK0: Interrupt 0 mask register.
func (o *SDMMC_Type) SetMASK0(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x1)|value)
}
func (o *SDMMC_Type) GetMASK0() uint32 {
	return volatile.LoadUint32(&o.MASK0.Reg) & 0x1
}
func (o *SDMMC_Type) SetMASK0_MASK1(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x2)|value<<1)
}
func (o *SDMMC_Type) GetMASK0_MASK1() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x2) >> 1
}
func (o *SDMMC_Type) SetMASK0_MASK2(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x4)|value<<2)
}
func (o *SDMMC_Type) GetMASK0_MASK2() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x4) >> 2
}
func (o *SDMMC_Type) SetMASK0_MASK3(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x8)|value<<3)
}
func (o *SDMMC_Type) GetMASK0_MASK3() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x8) >> 3
}
func (o *SDMMC_Type) SetMASK0_MASK4(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x10)|value<<4)
}
func (o *SDMMC_Type) GetMASK0_MASK4() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x10) >> 4
}
func (o *SDMMC_Type) SetMASK0_MASK5(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x20)|value<<5)
}
func (o *SDMMC_Type) GetMASK0_MASK5() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x20) >> 5
}
func (o *SDMMC_Type) SetMASK0_MASK6(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x40)|value<<6)
}
func (o *SDMMC_Type) GetMASK0_MASK6() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x40) >> 6
}
func (o *SDMMC_Type) SetMASK0_MASK7(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x80)|value<<7)
}
func (o *SDMMC_Type) GetMASK0_MASK7() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x80) >> 7
}
func (o *SDMMC_Type) SetMASK0_MASK8(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x100)|value<<8)
}
func (o *SDMMC_Type) GetMASK0_MASK8() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x100) >> 8
}
func (o *SDMMC_Type) SetMASK0_MASK9(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x200)|value<<9)
}
func (o *SDMMC_Type) GetMASK0_MASK9() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x200) >> 9
}
func (o *SDMMC_Type) SetMASK0_MASK10(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x400)|value<<10)
}
func (o *SDMMC_Type) GetMASK0_MASK10() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x400) >> 10
}
func (o *SDMMC_Type) SetMASK0_MASK11(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x800)|value<<11)
}
func (o *SDMMC_Type) GetMASK0_MASK11() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x800) >> 11
}
func (o *SDMMC_Type) SetMASK0_MASK12(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x1000)|value<<12)
}
func (o *SDMMC_Type) GetMASK0_MASK12() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x1000) >> 12
}
func (o *SDMMC_Type) SetMASK0_MASK13(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x2000)|value<<13)
}
func (o *SDMMC_Type) GetMASK0_MASK13() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x2000) >> 13
}
func (o *SDMMC_Type) SetMASK0_MASK14(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x4000)|value<<14)
}
func (o *SDMMC_Type) GetMASK0_MASK14() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x4000) >> 14
}
func (o *SDMMC_Type) SetMASK0_MASK15(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x8000)|value<<15)
}
func (o *SDMMC_Type) GetMASK0_MASK15() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x8000) >> 15
}
func (o *SDMMC_Type) SetMASK0_MASK16(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x10000)|value<<16)
}
func (o *SDMMC_Type) GetMASK0_MASK16() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x10000) >> 16
}
func (o *SDMMC_Type) SetMASK0_MASK17(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x20000)|value<<17)
}
func (o *SDMMC_Type) GetMASK0_MASK17() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x20000) >> 17
}
func (o *SDMMC_Type) SetMASK0_MASK18(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x40000)|value<<18)
}
func (o *SDMMC_Type) GetMASK0_MASK18() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x40000) >> 18
}
func (o *SDMMC_Type) SetMASK0_MASK19(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x80000)|value<<19)
}
func (o *SDMMC_Type) GetMASK0_MASK19() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x80000) >> 19
}
func (o *SDMMC_Type) SetMASK0_MASK20(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x100000)|value<<20)
}
func (o *SDMMC_Type) GetMASK0_MASK20() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x100000) >> 20
}
func (o *SDMMC_Type) SetMASK0_MASK21(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x200000)|value<<21)
}
func (o *SDMMC_Type) GetMASK0_MASK21() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0x200000) >> 21
}
func (o *SDMMC_Type) SetMASK0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0xffc00000)|value<<22)
}
func (o *SDMMC_Type) GetMASK0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0xffc00000) >> 22
}

// SDMMC.FIFOCNT: FIFO Counter.
func (o *SDMMC_Type) SetFIFOCNT_DATACOUNT(value uint32) {
	volatile.StoreUint32(&o.FIFOCNT.Reg, volatile.LoadUint32(&o.FIFOCNT.Reg)&^(0x7fff)|value)
}
func (o *SDMMC_Type) GetFIFOCNT_DATACOUNT() uint32 {
	return volatile.LoadUint32(&o.FIFOCNT.Reg) & 0x7fff
}
func (o *SDMMC_Type) SetFIFOCNT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FIFOCNT.Reg, volatile.LoadUint32(&o.FIFOCNT.Reg)&^(0xffff8000)|value<<15)
}
func (o *SDMMC_Type) GetFIFOCNT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FIFOCNT.Reg) & 0xffff8000) >> 15
}

// SDMMC.FIFO0: Data FIFO Register.
func (o *SDMMC_Type) SetFIFO0(value uint32) {
	volatile.StoreUint32(&o.FIFO0.Reg, value)
}
func (o *SDMMC_Type) GetFIFO0() uint32 {
	return volatile.LoadUint32(&o.FIFO0.Reg)
}

// SDMMC.FIFO1: Data FIFO Register.
func (o *SDMMC_Type) SetFIFO1(value uint32) {
	volatile.StoreUint32(&o.FIFO1.Reg, value)
}
func (o *SDMMC_Type) GetFIFO1() uint32 {
	return volatile.LoadUint32(&o.FIFO1.Reg)
}

// SDMMC.FIFO2: Data FIFO Register.
func (o *SDMMC_Type) SetFIFO2(value uint32) {
	volatile.StoreUint32(&o.FIFO2.Reg, value)
}
func (o *SDMMC_Type) GetFIFO2() uint32 {
	return volatile.LoadUint32(&o.FIFO2.Reg)
}

// SDMMC.FIFO3: Data FIFO Register.
func (o *SDMMC_Type) SetFIFO3(value uint32) {
	volatile.StoreUint32(&o.FIFO3.Reg, value)
}
func (o *SDMMC_Type) GetFIFO3() uint32 {
	return volatile.LoadUint32(&o.FIFO3.Reg)
}

// SDMMC.FIFO4: Data FIFO Register.
func (o *SDMMC_Type) SetFIFO4(value uint32) {
	volatile.StoreUint32(&o.FIFO4.Reg, value)
}
func (o *SDMMC_Type) GetFIFO4() uint32 {
	return volatile.LoadUint32(&o.FIFO4.Reg)
}

// SDMMC.FIFO5: Data FIFO Register.
func (o *SDMMC_Type) SetFIFO5(value uint32) {
	volatile.StoreUint32(&o.FIFO5.Reg, value)
}
func (o *SDMMC_Type) GetFIFO5() uint32 {
	return volatile.LoadUint32(&o.FIFO5.Reg)
}

// SDMMC.FIFO6: Data FIFO Register.
func (o *SDMMC_Type) SetFIFO6(value uint32) {
	volatile.StoreUint32(&o.FIFO6.Reg, value)
}
func (o *SDMMC_Type) GetFIFO6() uint32 {
	return volatile.LoadUint32(&o.FIFO6.Reg)
}

// SDMMC.FIFO7: Data FIFO Register.
func (o *SDMMC_Type) SetFIFO7(value uint32) {
	volatile.StoreUint32(&o.FIFO7.Reg, value)
}
func (o *SDMMC_Type) GetFIFO7() uint32 {
	return volatile.LoadUint32(&o.FIFO7.Reg)
}

// SDMMC.FIFO8: Data FIFO Register.
func (o *SDMMC_Type) SetFIFO8(value uint32) {
	volatile.StoreUint32(&o.FIFO8.Reg, value)
}
func (o *SDMMC_Type) GetFIFO8() uint32 {
	return volatile.LoadUint32(&o.FIFO8.Reg)
}

// SDMMC.FIFO9: Data FIFO Register.
func (o *SDMMC_Type) SetFIFO9(value uint32) {
	volatile.StoreUint32(&o.FIFO9.Reg, value)
}
func (o *SDMMC_Type) GetFIFO9() uint32 {
	return volatile.LoadUint32(&o.FIFO9.Reg)
}

// SDMMC.FIFO10: Data FIFO Register.
func (o *SDMMC_Type) SetFIFO10(value uint32) {
	volatile.StoreUint32(&o.FIFO10.Reg, value)
}
func (o *SDMMC_Type) GetFIFO10() uint32 {
	return volatile.LoadUint32(&o.FIFO10.Reg)
}

// SDMMC.FIFO11: Data FIFO Register.
func (o *SDMMC_Type) SetFIFO11(value uint32) {
	volatile.StoreUint32(&o.FIFO11.Reg, value)
}
func (o *SDMMC_Type) GetFIFO11() uint32 {
	return volatile.LoadUint32(&o.FIFO11.Reg)
}

// SDMMC.FIFO12: Data FIFO Register.
func (o *SDMMC_Type) SetFIFO12(value uint32) {
	volatile.StoreUint32(&o.FIFO12.Reg, value)
}
func (o *SDMMC_Type) GetFIFO12() uint32 {
	return volatile.LoadUint32(&o.FIFO12.Reg)
}

// SDMMC.FIFO13: Data FIFO Register.
func (o *SDMMC_Type) SetFIFO13(value uint32) {
	volatile.StoreUint32(&o.FIFO13.Reg, value)
}
func (o *SDMMC_Type) GetFIFO13() uint32 {
	return volatile.LoadUint32(&o.FIFO13.Reg)
}

// SDMMC.FIFO14: Data FIFO Register.
func (o *SDMMC_Type) SetFIFO14(value uint32) {
	volatile.StoreUint32(&o.FIFO14.Reg, value)
}
func (o *SDMMC_Type) GetFIFO14() uint32 {
	return volatile.LoadUint32(&o.FIFO14.Reg)
}

// SDMMC.FIFO15: Data FIFO Register.
func (o *SDMMC_Type) SetFIFO15(value uint32) {
	volatile.StoreUint32(&o.FIFO15.Reg, value)
}
func (o *SDMMC_Type) GetFIFO15() uint32 {
	return volatile.LoadUint32(&o.FIFO15.Reg)
}

// System and clock control
type SYSCON_Type struct {
	FLASHCFG     volatile.Register32 // 0x0
	_            [124]byte
	PLLCON0      volatile.Register32 // 0x80
	PLLCFG0      volatile.Register32 // 0x84
	PLLSTAT0     volatile.Register32 // 0x88
	PLLFEED0     volatile.Register32 // 0x8C
	_            [16]byte
	PLLCON1      volatile.Register32 // 0xA0
	PLLCFG1      volatile.Register32 // 0xA4
	PLLSTAT1     volatile.Register32 // 0xA8
	PLLFEED1     volatile.Register32 // 0xAC
	_            [16]byte
	PCON         volatile.Register32 // 0xC0
	PCONP0       volatile.Register32 // 0xC4
	PCONP1       volatile.Register32 // 0xC8
	_            [52]byte
	EMCCLKSEL    volatile.Register32 // 0x100
	CCLKSEL      volatile.Register32 // 0x104
	USBCLKSEL    volatile.Register32 // 0x108
	CLKSRCSEL    volatile.Register32 // 0x10C
	CANSLEEPCLR  volatile.Register32 // 0x110
	CANWAKEFLAGS volatile.Register32 // 0x114
	_            [40]byte
	EXTINT       volatile.Register32 // 0x140
	_            [4]byte
	EXTMODE      volatile.Register32 // 0x148
	EXTPOLAR     volatile.Register32 // 0x14C
	_            [48]byte
	RSID         volatile.Register32 // 0x180
	_            [4]byte
	MATRIXARB    volatile.Register32 // 0x188
	_            [20]byte
	SCS          volatile.Register32 // 0x1A0
	_            [4]byte
	PCLKSEL      volatile.Register32 // 0x1A8
	_            [4]byte
	PBOOST       volatile.Register32 // 0x1B0
	SPIFICLKSEL  volatile.Register32 // 0x1B4
	LCD_CFG      volatile.Register32 // 0x1B8
	_            [4]byte
	USBINTST     volatile.Register32 // 0x1C0
	DMACREQSEL   volatile.Register32 // 0x1C4
	CLKOUTCFG    volatile.Register32 // 0x1C8
	RSTCON0      volatile.Register32 // 0x1CC
	RSTCON1      volatile.Register32 // 0x1D0
	_            [8]byte
	EMCDLYCTL    volatile.Register32 // 0x1DC
	EMCCAL       volatile.Register32 // 0x1E0
}

// SYSCON.FLASHCFG: Flash Accelerator Configuration Register. Controls flash access timing.
func (o *SYSCON_Type) SetFLASHCFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FLASHCFG.Reg, volatile.LoadUint32(&o.FLASHCFG.Reg)&^(0xfff)|value)
}
func (o *SYSCON_Type) GetFLASHCFG_RESERVED() uint32 {
	return volatile.LoadUint32(&o.FLASHCFG.Reg) & 0xfff
}
func (o *SYSCON_Type) SetFLASHCFG_FLASHTIM(value uint32) {
	volatile.StoreUint32(&o.FLASHCFG.Reg, volatile.LoadUint32(&o.FLASHCFG.Reg)&^(0xf000)|value<<12)
}
func (o *SYSCON_Type) GetFLASHCFG_FLASHTIM() uint32 {
	return (volatile.LoadUint32(&o.FLASHCFG.Reg) & 0xf000) >> 12
}
func (o *SYSCON_Type) SetFLASHCFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FLASHCFG.Reg, volatile.LoadUint32(&o.FLASHCFG.Reg)&^(0xffff0000)|value<<16)
}
func (o *SYSCON_Type) GetFLASHCFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FLASHCFG.Reg) & 0xffff0000) >> 16
}

// SYSCON.PLLCON0: PLL0 Control register
func (o *SYSCON_Type) SetPLLCON0_PLLE(value uint32) {
	volatile.StoreUint32(&o.PLLCON0.Reg, volatile.LoadUint32(&o.PLLCON0.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetPLLCON0_PLLE() uint32 {
	return volatile.LoadUint32(&o.PLLCON0.Reg) & 0x1
}
func (o *SYSCON_Type) SetPLLCON0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLLCON0.Reg, volatile.LoadUint32(&o.PLLCON0.Reg)&^(0xfffffffe)|value<<1)
}
func (o *SYSCON_Type) GetPLLCON0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLLCON0.Reg) & 0xfffffffe) >> 1
}

// SYSCON.PLLCFG0: PLL0 Configuration register
func (o *SYSCON_Type) SetPLLCFG0_MSEL(value uint32) {
	volatile.StoreUint32(&o.PLLCFG0.Reg, volatile.LoadUint32(&o.PLLCFG0.Reg)&^(0x1f)|value)
}
func (o *SYSCON_Type) GetPLLCFG0_MSEL() uint32 {
	return volatile.LoadUint32(&o.PLLCFG0.Reg) & 0x1f
}
func (o *SYSCON_Type) SetPLLCFG0_PSEL(value uint32) {
	volatile.StoreUint32(&o.PLLCFG0.Reg, volatile.LoadUint32(&o.PLLCFG0.Reg)&^(0x60)|value<<5)
}
func (o *SYSCON_Type) GetPLLCFG0_PSEL() uint32 {
	return (volatile.LoadUint32(&o.PLLCFG0.Reg) & 0x60) >> 5
}
func (o *SYSCON_Type) SetPLLCFG0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLLCFG0.Reg, volatile.LoadUint32(&o.PLLCFG0.Reg)&^(0xffffff80)|value<<7)
}
func (o *SYSCON_Type) GetPLLCFG0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLLCFG0.Reg) & 0xffffff80) >> 7
}

// SYSCON.PLLSTAT0: PLL0 Status register
func (o *SYSCON_Type) SetPLLSTAT0_MSEL(value uint32) {
	volatile.StoreUint32(&o.PLLSTAT0.Reg, volatile.LoadUint32(&o.PLLSTAT0.Reg)&^(0x1f)|value)
}
func (o *SYSCON_Type) GetPLLSTAT0_MSEL() uint32 {
	return volatile.LoadUint32(&o.PLLSTAT0.Reg) & 0x1f
}
func (o *SYSCON_Type) SetPLLSTAT0_PSEL(value uint32) {
	volatile.StoreUint32(&o.PLLSTAT0.Reg, volatile.LoadUint32(&o.PLLSTAT0.Reg)&^(0x60)|value<<5)
}
func (o *SYSCON_Type) GetPLLSTAT0_PSEL() uint32 {
	return (volatile.LoadUint32(&o.PLLSTAT0.Reg) & 0x60) >> 5
}
func (o *SYSCON_Type) SetPLLSTAT0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLLSTAT0.Reg, volatile.LoadUint32(&o.PLLSTAT0.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetPLLSTAT0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLLSTAT0.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetPLLSTAT0_PLLE_STAT(value uint32) {
	volatile.StoreUint32(&o.PLLSTAT0.Reg, volatile.LoadUint32(&o.PLLSTAT0.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetPLLSTAT0_PLLE_STAT() uint32 {
	return (volatile.LoadUint32(&o.PLLSTAT0.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetPLLSTAT0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLLSTAT0.Reg, volatile.LoadUint32(&o.PLLSTAT0.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetPLLSTAT0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLLSTAT0.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetPLLSTAT0_PLOCK(value uint32) {
	volatile.StoreUint32(&o.PLLSTAT0.Reg, volatile.LoadUint32(&o.PLLSTAT0.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetPLLSTAT0_PLOCK() uint32 {
	return (volatile.LoadUint32(&o.PLLSTAT0.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetPLLSTAT0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLLSTAT0.Reg, volatile.LoadUint32(&o.PLLSTAT0.Reg)&^(0xfffff800)|value<<11)
}
func (o *SYSCON_Type) GetPLLSTAT0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLLSTAT0.Reg) & 0xfffff800) >> 11
}

// SYSCON.PLLFEED0: PLL0 Feed register
func (o *SYSCON_Type) SetPLLFEED0_PLLFEED(value uint32) {
	volatile.StoreUint32(&o.PLLFEED0.Reg, volatile.LoadUint32(&o.PLLFEED0.Reg)&^(0xff)|value)
}
func (o *SYSCON_Type) GetPLLFEED0_PLLFEED() uint32 {
	return volatile.LoadUint32(&o.PLLFEED0.Reg) & 0xff
}
func (o *SYSCON_Type) SetPLLFEED0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLLFEED0.Reg, volatile.LoadUint32(&o.PLLFEED0.Reg)&^(0xffffff00)|value<<8)
}
func (o *SYSCON_Type) GetPLLFEED0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLLFEED0.Reg) & 0xffffff00) >> 8
}

// SYSCON.PLLCON1: PLL0 Control register
func (o *SYSCON_Type) SetPLLCON1_PLLE(value uint32) {
	volatile.StoreUint32(&o.PLLCON1.Reg, volatile.LoadUint32(&o.PLLCON1.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetPLLCON1_PLLE() uint32 {
	return volatile.LoadUint32(&o.PLLCON1.Reg) & 0x1
}
func (o *SYSCON_Type) SetPLLCON1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLLCON1.Reg, volatile.LoadUint32(&o.PLLCON1.Reg)&^(0xfffffffe)|value<<1)
}
func (o *SYSCON_Type) GetPLLCON1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLLCON1.Reg) & 0xfffffffe) >> 1
}

// SYSCON.PLLCFG1: PLL0 Configuration register
func (o *SYSCON_Type) SetPLLCFG1_MSEL(value uint32) {
	volatile.StoreUint32(&o.PLLCFG1.Reg, volatile.LoadUint32(&o.PLLCFG1.Reg)&^(0x1f)|value)
}
func (o *SYSCON_Type) GetPLLCFG1_MSEL() uint32 {
	return volatile.LoadUint32(&o.PLLCFG1.Reg) & 0x1f
}
func (o *SYSCON_Type) SetPLLCFG1_PSEL(value uint32) {
	volatile.StoreUint32(&o.PLLCFG1.Reg, volatile.LoadUint32(&o.PLLCFG1.Reg)&^(0x60)|value<<5)
}
func (o *SYSCON_Type) GetPLLCFG1_PSEL() uint32 {
	return (volatile.LoadUint32(&o.PLLCFG1.Reg) & 0x60) >> 5
}
func (o *SYSCON_Type) SetPLLCFG1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLLCFG1.Reg, volatile.LoadUint32(&o.PLLCFG1.Reg)&^(0xffffff80)|value<<7)
}
func (o *SYSCON_Type) GetPLLCFG1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLLCFG1.Reg) & 0xffffff80) >> 7
}

// SYSCON.PLLSTAT1: PLL0 Status register
func (o *SYSCON_Type) SetPLLSTAT1_MSEL(value uint32) {
	volatile.StoreUint32(&o.PLLSTAT1.Reg, volatile.LoadUint32(&o.PLLSTAT1.Reg)&^(0x1f)|value)
}
func (o *SYSCON_Type) GetPLLSTAT1_MSEL() uint32 {
	return volatile.LoadUint32(&o.PLLSTAT1.Reg) & 0x1f
}
func (o *SYSCON_Type) SetPLLSTAT1_PSEL(value uint32) {
	volatile.StoreUint32(&o.PLLSTAT1.Reg, volatile.LoadUint32(&o.PLLSTAT1.Reg)&^(0x60)|value<<5)
}
func (o *SYSCON_Type) GetPLLSTAT1_PSEL() uint32 {
	return (volatile.LoadUint32(&o.PLLSTAT1.Reg) & 0x60) >> 5
}
func (o *SYSCON_Type) SetPLLSTAT1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLLSTAT1.Reg, volatile.LoadUint32(&o.PLLSTAT1.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetPLLSTAT1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLLSTAT1.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetPLLSTAT1_PLLE_STAT(value uint32) {
	volatile.StoreUint32(&o.PLLSTAT1.Reg, volatile.LoadUint32(&o.PLLSTAT1.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetPLLSTAT1_PLLE_STAT() uint32 {
	return (volatile.LoadUint32(&o.PLLSTAT1.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetPLLSTAT1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLLSTAT1.Reg, volatile.LoadUint32(&o.PLLSTAT1.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetPLLSTAT1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLLSTAT1.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetPLLSTAT1_PLOCK(value uint32) {
	volatile.StoreUint32(&o.PLLSTAT1.Reg, volatile.LoadUint32(&o.PLLSTAT1.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetPLLSTAT1_PLOCK() uint32 {
	return (volatile.LoadUint32(&o.PLLSTAT1.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetPLLSTAT1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLLSTAT1.Reg, volatile.LoadUint32(&o.PLLSTAT1.Reg)&^(0xfffff800)|value<<11)
}
func (o *SYSCON_Type) GetPLLSTAT1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLLSTAT1.Reg) & 0xfffff800) >> 11
}

// SYSCON.PLLFEED1: PLL0 Feed register
func (o *SYSCON_Type) SetPLLFEED1_PLLFEED(value uint32) {
	volatile.StoreUint32(&o.PLLFEED1.Reg, volatile.LoadUint32(&o.PLLFEED1.Reg)&^(0xff)|value)
}
func (o *SYSCON_Type) GetPLLFEED1_PLLFEED() uint32 {
	return volatile.LoadUint32(&o.PLLFEED1.Reg) & 0xff
}
func (o *SYSCON_Type) SetPLLFEED1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PLLFEED1.Reg, volatile.LoadUint32(&o.PLLFEED1.Reg)&^(0xffffff00)|value<<8)
}
func (o *SYSCON_Type) GetPLLFEED1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PLLFEED1.Reg) & 0xffffff00) >> 8
}

// SYSCON.PCON: Power Control register
func (o *SYSCON_Type) SetPCON_PM0(value uint32) {
	volatile.StoreUint32(&o.PCON.Reg, volatile.LoadUint32(&o.PCON.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetPCON_PM0() uint32 {
	return volatile.LoadUint32(&o.PCON.Reg) & 0x1
}
func (o *SYSCON_Type) SetPCON_PM1(value uint32) {
	volatile.StoreUint32(&o.PCON.Reg, volatile.LoadUint32(&o.PCON.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetPCON_PM1() uint32 {
	return (volatile.LoadUint32(&o.PCON.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetPCON_BODRPM(value uint32) {
	volatile.StoreUint32(&o.PCON.Reg, volatile.LoadUint32(&o.PCON.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetPCON_BODRPM() uint32 {
	return (volatile.LoadUint32(&o.PCON.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetPCON_BOGD(value uint32) {
	volatile.StoreUint32(&o.PCON.Reg, volatile.LoadUint32(&o.PCON.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetPCON_BOGD() uint32 {
	return (volatile.LoadUint32(&o.PCON.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetPCON_BORD(value uint32) {
	volatile.StoreUint32(&o.PCON.Reg, volatile.LoadUint32(&o.PCON.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetPCON_BORD() uint32 {
	return (volatile.LoadUint32(&o.PCON.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetPCON_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PCON.Reg, volatile.LoadUint32(&o.PCON.Reg)&^(0xf8)|value<<3)
}
func (o *SYSCON_Type) GetPCON_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PCON.Reg) & 0xf8) >> 3
}
func (o *SYSCON_Type) SetPCON_SMFLAG(value uint32) {
	volatile.StoreUint32(&o.PCON.Reg, volatile.LoadUint32(&o.PCON.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetPCON_SMFLAG() uint32 {
	return (volatile.LoadUint32(&o.PCON.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetPCON_DSFLAG(value uint32) {
	volatile.StoreUint32(&o.PCON.Reg, volatile.LoadUint32(&o.PCON.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetPCON_DSFLAG() uint32 {
	return (volatile.LoadUint32(&o.PCON.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetPCON_PDFLAG(value uint32) {
	volatile.StoreUint32(&o.PCON.Reg, volatile.LoadUint32(&o.PCON.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetPCON_PDFLAG() uint32 {
	return (volatile.LoadUint32(&o.PCON.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetPCON_DPDFLAG(value uint32) {
	volatile.StoreUint32(&o.PCON.Reg, volatile.LoadUint32(&o.PCON.Reg)&^(0x800)|value<<11)
}
func (o *SYSCON_Type) GetPCON_DPDFLAG() uint32 {
	return (volatile.LoadUint32(&o.PCON.Reg) & 0x800) >> 11
}
func (o *SYSCON_Type) SetPCON_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PCON.Reg, volatile.LoadUint32(&o.PCON.Reg)&^(0xfffff000)|value<<12)
}
func (o *SYSCON_Type) GetPCON_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PCON.Reg) & 0xfffff000) >> 12
}

// SYSCON.PCONP0: Power Control for Peripherals
func (o *SYSCON_Type) SetPCONP0_PCLCD(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetPCONP0_PCLCD() uint32 {
	return volatile.LoadUint32(&o.PCONP0.Reg) & 0x1
}
func (o *SYSCON_Type) SetPCONP0_PCTIM0(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetPCONP0_PCTIM0() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetPCONP0_PCTIM1(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetPCONP0_PCTIM1() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetPCONP0_PCUART0(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetPCONP0_PCUART0() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetPCONP0_PCUART1(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetPCONP0_PCUART1() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetPCONP0_PCPWM0(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetPCONP0_PCPWM0() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetPCONP0_PCPWM1(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetPCONP0_PCPWM1() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetPCONP0_PCI2C0(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetPCONP0_PCI2C0() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetPCONP0_PCUART4(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetPCONP0_PCUART4() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetPCONP0_PCRTC(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetPCONP0_PCRTC() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetPCONP0_PCSSP1(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetPCONP0_PCSSP1() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetPCONP0_PCEMC(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x800)|value<<11)
}
func (o *SYSCON_Type) GetPCONP0_PCEMC() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x800) >> 11
}
func (o *SYSCON_Type) SetPCONP0_PCADC(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x1000)|value<<12)
}
func (o *SYSCON_Type) GetPCONP0_PCADC() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x1000) >> 12
}
func (o *SYSCON_Type) SetPCONP0_PCCAN1(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x2000)|value<<13)
}
func (o *SYSCON_Type) GetPCONP0_PCCAN1() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x2000) >> 13
}
func (o *SYSCON_Type) SetPCONP0_PCCAN2(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x4000)|value<<14)
}
func (o *SYSCON_Type) GetPCONP0_PCCAN2() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x4000) >> 14
}
func (o *SYSCON_Type) SetPCONP0_PCGPIO(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x8000)|value<<15)
}
func (o *SYSCON_Type) GetPCONP0_PCGPIO() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x8000) >> 15
}
func (o *SYSCON_Type) SetPCONP0_PCSPIFI(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCON_Type) GetPCONP0_PCSPIFI() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x10000) >> 16
}
func (o *SYSCON_Type) SetPCONP0_PCMCPWM(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x20000)|value<<17)
}
func (o *SYSCON_Type) GetPCONP0_PCMCPWM() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x20000) >> 17
}
func (o *SYSCON_Type) SetPCONP0_PCQEI(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x40000)|value<<18)
}
func (o *SYSCON_Type) GetPCONP0_PCQEI() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x40000) >> 18
}
func (o *SYSCON_Type) SetPCONP0_PCI2C1(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x80000)|value<<19)
}
func (o *SYSCON_Type) GetPCONP0_PCI2C1() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x80000) >> 19
}
func (o *SYSCON_Type) SetPCONP0_PCSSP2(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x100000)|value<<20)
}
func (o *SYSCON_Type) GetPCONP0_PCSSP2() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x100000) >> 20
}
func (o *SYSCON_Type) SetPCONP0_PCSSP0(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x200000)|value<<21)
}
func (o *SYSCON_Type) GetPCONP0_PCSSP0() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x200000) >> 21
}
func (o *SYSCON_Type) SetPCONP0_PCTIM2(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x400000)|value<<22)
}
func (o *SYSCON_Type) GetPCONP0_PCTIM2() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x400000) >> 22
}
func (o *SYSCON_Type) SetPCONP0_PCTIM3(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x800000)|value<<23)
}
func (o *SYSCON_Type) GetPCONP0_PCTIM3() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x800000) >> 23
}
func (o *SYSCON_Type) SetPCONP0_PCUART2(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSCON_Type) GetPCONP0_PCUART2() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x1000000) >> 24
}
func (o *SYSCON_Type) SetPCONP0_PCUART3(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSCON_Type) GetPCONP0_PCUART3() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x2000000) >> 25
}
func (o *SYSCON_Type) SetPCONP0_PCI2C2(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSCON_Type) GetPCONP0_PCI2C2() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x4000000) >> 26
}
func (o *SYSCON_Type) SetPCONP0_PCI2S(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSCON_Type) GetPCONP0_PCI2S() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x8000000) >> 27
}
func (o *SYSCON_Type) SetPCONP0_PCSDC(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSCON_Type) GetPCONP0_PCSDC() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x10000000) >> 28
}
func (o *SYSCON_Type) SetPCONP0_PCGPDMA(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSCON_Type) GetPCONP0_PCGPDMA() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x20000000) >> 29
}
func (o *SYSCON_Type) SetPCONP0_PCENET(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSCON_Type) GetPCONP0_PCENET() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x40000000) >> 30
}
func (o *SYSCON_Type) SetPCONP0_PCUSB(value uint32) {
	volatile.StoreUint32(&o.PCONP0.Reg, volatile.LoadUint32(&o.PCONP0.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSCON_Type) GetPCONP0_PCUSB() uint32 {
	return (volatile.LoadUint32(&o.PCONP0.Reg) & 0x80000000) >> 31
}

// SYSCON.PCONP1: Power Control for Peripherals
func (o *SYSCON_Type) SetPCONP1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PCONP1.Reg, volatile.LoadUint32(&o.PCONP1.Reg)&^(0x7)|value)
}
func (o *SYSCON_Type) GetPCONP1_RESERVED() uint32 {
	return volatile.LoadUint32(&o.PCONP1.Reg) & 0x7
}
func (o *SYSCON_Type) SetPCONP1_PCCMP(value uint32) {
	volatile.StoreUint32(&o.PCONP1.Reg, volatile.LoadUint32(&o.PCONP1.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetPCONP1_PCCMP() uint32 {
	return (volatile.LoadUint32(&o.PCONP1.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetPCONP1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PCONP1.Reg, volatile.LoadUint32(&o.PCONP1.Reg)&^(0xfffffff0)|value<<4)
}
func (o *SYSCON_Type) GetPCONP1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PCONP1.Reg) & 0xfffffff0) >> 4
}

// SYSCON.EMCCLKSEL: External Memory Controller Clock Selection register
func (o *SYSCON_Type) SetEMCCLKSEL_EMCDIV(value uint32) {
	volatile.StoreUint32(&o.EMCCLKSEL.Reg, volatile.LoadUint32(&o.EMCCLKSEL.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetEMCCLKSEL_EMCDIV() uint32 {
	return volatile.LoadUint32(&o.EMCCLKSEL.Reg) & 0x1
}
func (o *SYSCON_Type) SetEMCCLKSEL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EMCCLKSEL.Reg, volatile.LoadUint32(&o.EMCCLKSEL.Reg)&^(0xfffffffe)|value<<1)
}
func (o *SYSCON_Type) GetEMCCLKSEL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EMCCLKSEL.Reg) & 0xfffffffe) >> 1
}

// SYSCON.CCLKSEL: CPU Clock Selection register
func (o *SYSCON_Type) SetCCLKSEL_CCLKDIV(value uint32) {
	volatile.StoreUint32(&o.CCLKSEL.Reg, volatile.LoadUint32(&o.CCLKSEL.Reg)&^(0x1f)|value)
}
func (o *SYSCON_Type) GetCCLKSEL_CCLKDIV() uint32 {
	return volatile.LoadUint32(&o.CCLKSEL.Reg) & 0x1f
}
func (o *SYSCON_Type) SetCCLKSEL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CCLKSEL.Reg, volatile.LoadUint32(&o.CCLKSEL.Reg)&^(0xe0)|value<<5)
}
func (o *SYSCON_Type) GetCCLKSEL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CCLKSEL.Reg) & 0xe0) >> 5
}
func (o *SYSCON_Type) SetCCLKSEL(value uint32) {
	volatile.StoreUint32(&o.CCLKSEL.Reg, volatile.LoadUint32(&o.CCLKSEL.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetCCLKSEL() uint32 {
	return (volatile.LoadUint32(&o.CCLKSEL.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetCCLKSEL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CCLKSEL.Reg, volatile.LoadUint32(&o.CCLKSEL.Reg)&^(0xfffffe00)|value<<9)
}
func (o *SYSCON_Type) GetCCLKSEL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CCLKSEL.Reg) & 0xfffffe00) >> 9
}

// SYSCON.USBCLKSEL: USB Clock Selection register
func (o *SYSCON_Type) SetUSBCLKSEL_USBDIV(value uint32) {
	volatile.StoreUint32(&o.USBCLKSEL.Reg, volatile.LoadUint32(&o.USBCLKSEL.Reg)&^(0x1f)|value)
}
func (o *SYSCON_Type) GetUSBCLKSEL_USBDIV() uint32 {
	return volatile.LoadUint32(&o.USBCLKSEL.Reg) & 0x1f
}
func (o *SYSCON_Type) SetUSBCLKSEL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBCLKSEL.Reg, volatile.LoadUint32(&o.USBCLKSEL.Reg)&^(0xe0)|value<<5)
}
func (o *SYSCON_Type) GetUSBCLKSEL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBCLKSEL.Reg) & 0xe0) >> 5
}
func (o *SYSCON_Type) SetUSBCLKSEL_USBSEL(value uint32) {
	volatile.StoreUint32(&o.USBCLKSEL.Reg, volatile.LoadUint32(&o.USBCLKSEL.Reg)&^(0x300)|value<<8)
}
func (o *SYSCON_Type) GetUSBCLKSEL_USBSEL() uint32 {
	return (volatile.LoadUint32(&o.USBCLKSEL.Reg) & 0x300) >> 8
}
func (o *SYSCON_Type) SetUSBCLKSEL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBCLKSEL.Reg, volatile.LoadUint32(&o.USBCLKSEL.Reg)&^(0xfffffc00)|value<<10)
}
func (o *SYSCON_Type) GetUSBCLKSEL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBCLKSEL.Reg) & 0xfffffc00) >> 10
}

// SYSCON.CLKSRCSEL: Clock Source Select Register
func (o *SYSCON_Type) SetCLKSRCSEL_CLKSRC(value uint32) {
	volatile.StoreUint32(&o.CLKSRCSEL.Reg, volatile.LoadUint32(&o.CLKSRCSEL.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetCLKSRCSEL_CLKSRC() uint32 {
	return volatile.LoadUint32(&o.CLKSRCSEL.Reg) & 0x1
}
func (o *SYSCON_Type) SetCLKSRCSEL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLKSRCSEL.Reg, volatile.LoadUint32(&o.CLKSRCSEL.Reg)&^(0xfffffffe)|value<<1)
}
func (o *SYSCON_Type) GetCLKSRCSEL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLKSRCSEL.Reg) & 0xfffffffe) >> 1
}

// SYSCON.CANSLEEPCLR: Allows clearing the current CAN channel sleep state as well as reading that state.
func (o *SYSCON_Type) SetCANSLEEPCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANSLEEPCLR.Reg, volatile.LoadUint32(&o.CANSLEEPCLR.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetCANSLEEPCLR_RESERVED() uint32 {
	return volatile.LoadUint32(&o.CANSLEEPCLR.Reg) & 0x1
}
func (o *SYSCON_Type) SetCANSLEEPCLR_CAN1SLEEP(value uint32) {
	volatile.StoreUint32(&o.CANSLEEPCLR.Reg, volatile.LoadUint32(&o.CANSLEEPCLR.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetCANSLEEPCLR_CAN1SLEEP() uint32 {
	return (volatile.LoadUint32(&o.CANSLEEPCLR.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetCANSLEEPCLR_CAN2SLEEP(value uint32) {
	volatile.StoreUint32(&o.CANSLEEPCLR.Reg, volatile.LoadUint32(&o.CANSLEEPCLR.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetCANSLEEPCLR_CAN2SLEEP() uint32 {
	return (volatile.LoadUint32(&o.CANSLEEPCLR.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetCANSLEEPCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANSLEEPCLR.Reg, volatile.LoadUint32(&o.CANSLEEPCLR.Reg)&^(0xfffffff8)|value<<3)
}
func (o *SYSCON_Type) GetCANSLEEPCLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANSLEEPCLR.Reg) & 0xfffffff8) >> 3
}

// SYSCON.CANWAKEFLAGS: Allows reading the wake-up state of the CAN channels.
func (o *SYSCON_Type) SetCANWAKEFLAGS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANWAKEFLAGS.Reg, volatile.LoadUint32(&o.CANWAKEFLAGS.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetCANWAKEFLAGS_RESERVED() uint32 {
	return volatile.LoadUint32(&o.CANWAKEFLAGS.Reg) & 0x1
}
func (o *SYSCON_Type) SetCANWAKEFLAGS_CAN1WAKE(value uint32) {
	volatile.StoreUint32(&o.CANWAKEFLAGS.Reg, volatile.LoadUint32(&o.CANWAKEFLAGS.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetCANWAKEFLAGS_CAN1WAKE() uint32 {
	return (volatile.LoadUint32(&o.CANWAKEFLAGS.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetCANWAKEFLAGS_CAN2WAKE(value uint32) {
	volatile.StoreUint32(&o.CANWAKEFLAGS.Reg, volatile.LoadUint32(&o.CANWAKEFLAGS.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetCANWAKEFLAGS_CAN2WAKE() uint32 {
	return (volatile.LoadUint32(&o.CANWAKEFLAGS.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetCANWAKEFLAGS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANWAKEFLAGS.Reg, volatile.LoadUint32(&o.CANWAKEFLAGS.Reg)&^(0xfffffff8)|value<<3)
}
func (o *SYSCON_Type) GetCANWAKEFLAGS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANWAKEFLAGS.Reg) & 0xfffffff8) >> 3
}

// SYSCON.EXTINT: External Interrupt Flag Register
func (o *SYSCON_Type) SetEXTINT_EINT0(value uint32) {
	volatile.StoreUint32(&o.EXTINT.Reg, volatile.LoadUint32(&o.EXTINT.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetEXTINT_EINT0() uint32 {
	return volatile.LoadUint32(&o.EXTINT.Reg) & 0x1
}
func (o *SYSCON_Type) SetEXTINT_EINT1(value uint32) {
	volatile.StoreUint32(&o.EXTINT.Reg, volatile.LoadUint32(&o.EXTINT.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetEXTINT_EINT1() uint32 {
	return (volatile.LoadUint32(&o.EXTINT.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetEXTINT_EINT2(value uint32) {
	volatile.StoreUint32(&o.EXTINT.Reg, volatile.LoadUint32(&o.EXTINT.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetEXTINT_EINT2() uint32 {
	return (volatile.LoadUint32(&o.EXTINT.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetEXTINT_EINT3(value uint32) {
	volatile.StoreUint32(&o.EXTINT.Reg, volatile.LoadUint32(&o.EXTINT.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetEXTINT_EINT3() uint32 {
	return (volatile.LoadUint32(&o.EXTINT.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetEXTINT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EXTINT.Reg, volatile.LoadUint32(&o.EXTINT.Reg)&^(0xfffffff0)|value<<4)
}
func (o *SYSCON_Type) GetEXTINT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EXTINT.Reg) & 0xfffffff0) >> 4
}

// SYSCON.EXTMODE: External Interrupt Mode register
func (o *SYSCON_Type) SetEXTMODE_EXTMODE0(value uint32) {
	volatile.StoreUint32(&o.EXTMODE.Reg, volatile.LoadUint32(&o.EXTMODE.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetEXTMODE_EXTMODE0() uint32 {
	return volatile.LoadUint32(&o.EXTMODE.Reg) & 0x1
}
func (o *SYSCON_Type) SetEXTMODE_EXTMODE1(value uint32) {
	volatile.StoreUint32(&o.EXTMODE.Reg, volatile.LoadUint32(&o.EXTMODE.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetEXTMODE_EXTMODE1() uint32 {
	return (volatile.LoadUint32(&o.EXTMODE.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetEXTMODE_EXTMODE2(value uint32) {
	volatile.StoreUint32(&o.EXTMODE.Reg, volatile.LoadUint32(&o.EXTMODE.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetEXTMODE_EXTMODE2() uint32 {
	return (volatile.LoadUint32(&o.EXTMODE.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetEXTMODE_EXTMODE3(value uint32) {
	volatile.StoreUint32(&o.EXTMODE.Reg, volatile.LoadUint32(&o.EXTMODE.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetEXTMODE_EXTMODE3() uint32 {
	return (volatile.LoadUint32(&o.EXTMODE.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetEXTMODE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EXTMODE.Reg, volatile.LoadUint32(&o.EXTMODE.Reg)&^(0xfffffff0)|value<<4)
}
func (o *SYSCON_Type) GetEXTMODE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EXTMODE.Reg) & 0xfffffff0) >> 4
}

// SYSCON.EXTPOLAR: External Interrupt Polarity Register
func (o *SYSCON_Type) SetEXTPOLAR_EXTPOLAR0(value uint32) {
	volatile.StoreUint32(&o.EXTPOLAR.Reg, volatile.LoadUint32(&o.EXTPOLAR.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetEXTPOLAR_EXTPOLAR0() uint32 {
	return volatile.LoadUint32(&o.EXTPOLAR.Reg) & 0x1
}
func (o *SYSCON_Type) SetEXTPOLAR_EXTPOLAR1(value uint32) {
	volatile.StoreUint32(&o.EXTPOLAR.Reg, volatile.LoadUint32(&o.EXTPOLAR.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetEXTPOLAR_EXTPOLAR1() uint32 {
	return (volatile.LoadUint32(&o.EXTPOLAR.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetEXTPOLAR_EXTPOLAR2(value uint32) {
	volatile.StoreUint32(&o.EXTPOLAR.Reg, volatile.LoadUint32(&o.EXTPOLAR.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetEXTPOLAR_EXTPOLAR2() uint32 {
	return (volatile.LoadUint32(&o.EXTPOLAR.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetEXTPOLAR_EXTPOLAR3(value uint32) {
	volatile.StoreUint32(&o.EXTPOLAR.Reg, volatile.LoadUint32(&o.EXTPOLAR.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetEXTPOLAR_EXTPOLAR3() uint32 {
	return (volatile.LoadUint32(&o.EXTPOLAR.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetEXTPOLAR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EXTPOLAR.Reg, volatile.LoadUint32(&o.EXTPOLAR.Reg)&^(0xfffffff0)|value<<4)
}
func (o *SYSCON_Type) GetEXTPOLAR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EXTPOLAR.Reg) & 0xfffffff0) >> 4
}

// SYSCON.RSID: Reset Source Identification Register
func (o *SYSCON_Type) SetRSID_POR(value uint32) {
	volatile.StoreUint32(&o.RSID.Reg, volatile.LoadUint32(&o.RSID.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetRSID_POR() uint32 {
	return volatile.LoadUint32(&o.RSID.Reg) & 0x1
}
func (o *SYSCON_Type) SetRSID_EXTR(value uint32) {
	volatile.StoreUint32(&o.RSID.Reg, volatile.LoadUint32(&o.RSID.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetRSID_EXTR() uint32 {
	return (volatile.LoadUint32(&o.RSID.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetRSID_WDTR(value uint32) {
	volatile.StoreUint32(&o.RSID.Reg, volatile.LoadUint32(&o.RSID.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetRSID_WDTR() uint32 {
	return (volatile.LoadUint32(&o.RSID.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetRSID_BODR(value uint32) {
	volatile.StoreUint32(&o.RSID.Reg, volatile.LoadUint32(&o.RSID.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetRSID_BODR() uint32 {
	return (volatile.LoadUint32(&o.RSID.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetRSID_SYSRESET(value uint32) {
	volatile.StoreUint32(&o.RSID.Reg, volatile.LoadUint32(&o.RSID.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetRSID_SYSRESET() uint32 {
	return (volatile.LoadUint32(&o.RSID.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetRSID_LOCKUP(value uint32) {
	volatile.StoreUint32(&o.RSID.Reg, volatile.LoadUint32(&o.RSID.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetRSID_LOCKUP() uint32 {
	return (volatile.LoadUint32(&o.RSID.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetRSID_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RSID.Reg, volatile.LoadUint32(&o.RSID.Reg)&^(0xffffffc0)|value<<6)
}
func (o *SYSCON_Type) GetRSID_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RSID.Reg) & 0xffffffc0) >> 6
}

// SYSCON.MATRIXARB: Matrix arbitration register
func (o *SYSCON_Type) SetMATRIXARB_PRI_ICODE(value uint32) {
	volatile.StoreUint32(&o.MATRIXARB.Reg, volatile.LoadUint32(&o.MATRIXARB.Reg)&^(0x3)|value)
}
func (o *SYSCON_Type) GetMATRIXARB_PRI_ICODE() uint32 {
	return volatile.LoadUint32(&o.MATRIXARB.Reg) & 0x3
}
func (o *SYSCON_Type) SetMATRIXARB_PRI_DCODE(value uint32) {
	volatile.StoreUint32(&o.MATRIXARB.Reg, volatile.LoadUint32(&o.MATRIXARB.Reg)&^(0xc)|value<<2)
}
func (o *SYSCON_Type) GetMATRIXARB_PRI_DCODE() uint32 {
	return (volatile.LoadUint32(&o.MATRIXARB.Reg) & 0xc) >> 2
}
func (o *SYSCON_Type) SetMATRIXARB_PRI_SYS(value uint32) {
	volatile.StoreUint32(&o.MATRIXARB.Reg, volatile.LoadUint32(&o.MATRIXARB.Reg)&^(0x30)|value<<4)
}
func (o *SYSCON_Type) GetMATRIXARB_PRI_SYS() uint32 {
	return (volatile.LoadUint32(&o.MATRIXARB.Reg) & 0x30) >> 4
}
func (o *SYSCON_Type) SetMATRIXARB_PRI_GPDMA(value uint32) {
	volatile.StoreUint32(&o.MATRIXARB.Reg, volatile.LoadUint32(&o.MATRIXARB.Reg)&^(0xc0)|value<<6)
}
func (o *SYSCON_Type) GetMATRIXARB_PRI_GPDMA() uint32 {
	return (volatile.LoadUint32(&o.MATRIXARB.Reg) & 0xc0) >> 6
}
func (o *SYSCON_Type) SetMATRIXARB_PRI_ETH(value uint32) {
	volatile.StoreUint32(&o.MATRIXARB.Reg, volatile.LoadUint32(&o.MATRIXARB.Reg)&^(0x300)|value<<8)
}
func (o *SYSCON_Type) GetMATRIXARB_PRI_ETH() uint32 {
	return (volatile.LoadUint32(&o.MATRIXARB.Reg) & 0x300) >> 8
}
func (o *SYSCON_Type) SetMATRIXARB_PRI_LCD(value uint32) {
	volatile.StoreUint32(&o.MATRIXARB.Reg, volatile.LoadUint32(&o.MATRIXARB.Reg)&^(0xc00)|value<<10)
}
func (o *SYSCON_Type) GetMATRIXARB_PRI_LCD() uint32 {
	return (volatile.LoadUint32(&o.MATRIXARB.Reg) & 0xc00) >> 10
}
func (o *SYSCON_Type) SetMATRIXARB_PRI_USB(value uint32) {
	volatile.StoreUint32(&o.MATRIXARB.Reg, volatile.LoadUint32(&o.MATRIXARB.Reg)&^(0x3000)|value<<12)
}
func (o *SYSCON_Type) GetMATRIXARB_PRI_USB() uint32 {
	return (volatile.LoadUint32(&o.MATRIXARB.Reg) & 0x3000) >> 12
}
func (o *SYSCON_Type) SetMATRIXARB_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MATRIXARB.Reg, volatile.LoadUint32(&o.MATRIXARB.Reg)&^(0xc000)|value<<14)
}
func (o *SYSCON_Type) GetMATRIXARB_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MATRIXARB.Reg) & 0xc000) >> 14
}
func (o *SYSCON_Type) SetMATRIXARB_ROM_LAT(value uint32) {
	volatile.StoreUint32(&o.MATRIXARB.Reg, volatile.LoadUint32(&o.MATRIXARB.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCON_Type) GetMATRIXARB_ROM_LAT() uint32 {
	return (volatile.LoadUint32(&o.MATRIXARB.Reg) & 0x10000) >> 16
}
func (o *SYSCON_Type) SetMATRIXARB_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MATRIXARB.Reg, volatile.LoadUint32(&o.MATRIXARB.Reg)&^(0xfffe0000)|value<<17)
}
func (o *SYSCON_Type) GetMATRIXARB_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MATRIXARB.Reg) & 0xfffe0000) >> 17
}

// SYSCON.SCS: System Control and Status
func (o *SYSCON_Type) SetSCS_EMCSC(value uint32) {
	volatile.StoreUint32(&o.SCS.Reg, volatile.LoadUint32(&o.SCS.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetSCS_EMCSC() uint32 {
	return volatile.LoadUint32(&o.SCS.Reg) & 0x1
}
func (o *SYSCON_Type) SetSCS_EMCRD(value uint32) {
	volatile.StoreUint32(&o.SCS.Reg, volatile.LoadUint32(&o.SCS.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetSCS_EMCRD() uint32 {
	return (volatile.LoadUint32(&o.SCS.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetSCS_EMCBC(value uint32) {
	volatile.StoreUint32(&o.SCS.Reg, volatile.LoadUint32(&o.SCS.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetSCS_EMCBC() uint32 {
	return (volatile.LoadUint32(&o.SCS.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetSCS_MCIPWRAL(value uint32) {
	volatile.StoreUint32(&o.SCS.Reg, volatile.LoadUint32(&o.SCS.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetSCS_MCIPWRAL() uint32 {
	return (volatile.LoadUint32(&o.SCS.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetSCS_OSCRS(value uint32) {
	volatile.StoreUint32(&o.SCS.Reg, volatile.LoadUint32(&o.SCS.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetSCS_OSCRS() uint32 {
	return (volatile.LoadUint32(&o.SCS.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetSCS_OSCEN(value uint32) {
	volatile.StoreUint32(&o.SCS.Reg, volatile.LoadUint32(&o.SCS.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetSCS_OSCEN() uint32 {
	return (volatile.LoadUint32(&o.SCS.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetSCS_OSCSTAT(value uint32) {
	volatile.StoreUint32(&o.SCS.Reg, volatile.LoadUint32(&o.SCS.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetSCS_OSCSTAT() uint32 {
	return (volatile.LoadUint32(&o.SCS.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetSCS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SCS.Reg, volatile.LoadUint32(&o.SCS.Reg)&^(0xffffff80)|value<<7)
}
func (o *SYSCON_Type) GetSCS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SCS.Reg) & 0xffffff80) >> 7
}

// SYSCON.PCLKSEL: Peripheral Clock Selection register
func (o *SYSCON_Type) SetPCLKSEL_PCLKDIV(value uint32) {
	volatile.StoreUint32(&o.PCLKSEL.Reg, volatile.LoadUint32(&o.PCLKSEL.Reg)&^(0x1f)|value)
}
func (o *SYSCON_Type) GetPCLKSEL_PCLKDIV() uint32 {
	return volatile.LoadUint32(&o.PCLKSEL.Reg) & 0x1f
}
func (o *SYSCON_Type) SetPCLKSEL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PCLKSEL.Reg, volatile.LoadUint32(&o.PCLKSEL.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSCON_Type) GetPCLKSEL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PCLKSEL.Reg) & 0xffffffe0) >> 5
}

// SYSCON.PBOOST: Power boost register
func (o *SYSCON_Type) SetPBOOST_Boost(value uint32) {
	volatile.StoreUint32(&o.PBOOST.Reg, volatile.LoadUint32(&o.PBOOST.Reg)&^(0x3)|value)
}
func (o *SYSCON_Type) GetPBOOST_Boost() uint32 {
	return volatile.LoadUint32(&o.PBOOST.Reg) & 0x3
}
func (o *SYSCON_Type) SetPBOOST_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PBOOST.Reg, volatile.LoadUint32(&o.PBOOST.Reg)&^(0xfffffffc)|value<<2)
}
func (o *SYSCON_Type) GetPBOOST_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PBOOST.Reg) & 0xfffffffc) >> 2
}

// SYSCON.SPIFICLKSEL: SPIFI Clock Selection register
func (o *SYSCON_Type) SetSPIFICLKSEL_SPIFIDIV(value uint32) {
	volatile.StoreUint32(&o.SPIFICLKSEL.Reg, volatile.LoadUint32(&o.SPIFICLKSEL.Reg)&^(0x1f)|value)
}
func (o *SYSCON_Type) GetSPIFICLKSEL_SPIFIDIV() uint32 {
	return volatile.LoadUint32(&o.SPIFICLKSEL.Reg) & 0x1f
}
func (o *SYSCON_Type) SetSPIFICLKSEL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SPIFICLKSEL.Reg, volatile.LoadUint32(&o.SPIFICLKSEL.Reg)&^(0xe0)|value<<5)
}
func (o *SYSCON_Type) GetSPIFICLKSEL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SPIFICLKSEL.Reg) & 0xe0) >> 5
}
func (o *SYSCON_Type) SetSPIFICLKSEL_SPIFISEL(value uint32) {
	volatile.StoreUint32(&o.SPIFICLKSEL.Reg, volatile.LoadUint32(&o.SPIFICLKSEL.Reg)&^(0x300)|value<<8)
}
func (o *SYSCON_Type) GetSPIFICLKSEL_SPIFISEL() uint32 {
	return (volatile.LoadUint32(&o.SPIFICLKSEL.Reg) & 0x300) >> 8
}
func (o *SYSCON_Type) SetSPIFICLKSEL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SPIFICLKSEL.Reg, volatile.LoadUint32(&o.SPIFICLKSEL.Reg)&^(0xfffffc00)|value<<10)
}
func (o *SYSCON_Type) GetSPIFICLKSEL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SPIFICLKSEL.Reg) & 0xfffffc00) >> 10
}

// SYSCON.LCD_CFG: LCD Clock configuration register
func (o *SYSCON_Type) SetLCD_CFG_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.LCD_CFG.Reg, volatile.LoadUint32(&o.LCD_CFG.Reg)&^(0x1f)|value)
}
func (o *SYSCON_Type) GetLCD_CFG_CLKDIV() uint32 {
	return volatile.LoadUint32(&o.LCD_CFG.Reg) & 0x1f
}
func (o *SYSCON_Type) SetLCD_CFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LCD_CFG.Reg, volatile.LoadUint32(&o.LCD_CFG.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSCON_Type) GetLCD_CFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.LCD_CFG.Reg) & 0xffffffe0) >> 5
}

// SYSCON.USBINTST: USB Interrupt Status
func (o *SYSCON_Type) SetUSBINTST_USB_INT_REQ_LP(value uint32) {
	volatile.StoreUint32(&o.USBINTST.Reg, volatile.LoadUint32(&o.USBINTST.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetUSBINTST_USB_INT_REQ_LP() uint32 {
	return volatile.LoadUint32(&o.USBINTST.Reg) & 0x1
}
func (o *SYSCON_Type) SetUSBINTST_USB_INT_REQ_HP(value uint32) {
	volatile.StoreUint32(&o.USBINTST.Reg, volatile.LoadUint32(&o.USBINTST.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetUSBINTST_USB_INT_REQ_HP() uint32 {
	return (volatile.LoadUint32(&o.USBINTST.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetUSBINTST_USB_INT_REQ_DMA(value uint32) {
	volatile.StoreUint32(&o.USBINTST.Reg, volatile.LoadUint32(&o.USBINTST.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetUSBINTST_USB_INT_REQ_DMA() uint32 {
	return (volatile.LoadUint32(&o.USBINTST.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetUSBINTST_USB_HOST_INT(value uint32) {
	volatile.StoreUint32(&o.USBINTST.Reg, volatile.LoadUint32(&o.USBINTST.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetUSBINTST_USB_HOST_INT() uint32 {
	return (volatile.LoadUint32(&o.USBINTST.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetUSBINTST_USB_ATX_INT(value uint32) {
	volatile.StoreUint32(&o.USBINTST.Reg, volatile.LoadUint32(&o.USBINTST.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetUSBINTST_USB_ATX_INT() uint32 {
	return (volatile.LoadUint32(&o.USBINTST.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetUSBINTST_USB_OTG_INT(value uint32) {
	volatile.StoreUint32(&o.USBINTST.Reg, volatile.LoadUint32(&o.USBINTST.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetUSBINTST_USB_OTG_INT() uint32 {
	return (volatile.LoadUint32(&o.USBINTST.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetUSBINTST_USB_I2C_INT(value uint32) {
	volatile.StoreUint32(&o.USBINTST.Reg, volatile.LoadUint32(&o.USBINTST.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetUSBINTST_USB_I2C_INT() uint32 {
	return (volatile.LoadUint32(&o.USBINTST.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetUSBINTST_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBINTST.Reg, volatile.LoadUint32(&o.USBINTST.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetUSBINTST_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBINTST.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetUSBINTST_USB_NEED_CLK(value uint32) {
	volatile.StoreUint32(&o.USBINTST.Reg, volatile.LoadUint32(&o.USBINTST.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetUSBINTST_USB_NEED_CLK() uint32 {
	return (volatile.LoadUint32(&o.USBINTST.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetUSBINTST_RESERVED(value uint32) {
	volatile.StoreUint32(&o.USBINTST.Reg, volatile.LoadUint32(&o.USBINTST.Reg)&^(0x7ffffe00)|value<<9)
}
func (o *SYSCON_Type) GetUSBINTST_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.USBINTST.Reg) & 0x7ffffe00) >> 9
}
func (o *SYSCON_Type) SetUSBINTST_EN_USB_INTS(value uint32) {
	volatile.StoreUint32(&o.USBINTST.Reg, volatile.LoadUint32(&o.USBINTST.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSCON_Type) GetUSBINTST_EN_USB_INTS() uint32 {
	return (volatile.LoadUint32(&o.USBINTST.Reg) & 0x80000000) >> 31
}

// SYSCON.DMACREQSEL: Selects between alternative requests on DMA channels 0 through 7 and 10 through 15
func (o *SYSCON_Type) SetDMACREQSEL_DMASEL00(value uint32) {
	volatile.StoreUint32(&o.DMACREQSEL.Reg, volatile.LoadUint32(&o.DMACREQSEL.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetDMACREQSEL_DMASEL00() uint32 {
	return volatile.LoadUint32(&o.DMACREQSEL.Reg) & 0x1
}
func (o *SYSCON_Type) SetDMACREQSEL_DMASEL01(value uint32) {
	volatile.StoreUint32(&o.DMACREQSEL.Reg, volatile.LoadUint32(&o.DMACREQSEL.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetDMACREQSEL_DMASEL01() uint32 {
	return (volatile.LoadUint32(&o.DMACREQSEL.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetDMACREQSEL_DMASEL02(value uint32) {
	volatile.StoreUint32(&o.DMACREQSEL.Reg, volatile.LoadUint32(&o.DMACREQSEL.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetDMACREQSEL_DMASEL02() uint32 {
	return (volatile.LoadUint32(&o.DMACREQSEL.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetDMACREQSEL_DMASEL03(value uint32) {
	volatile.StoreUint32(&o.DMACREQSEL.Reg, volatile.LoadUint32(&o.DMACREQSEL.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetDMACREQSEL_DMASEL03() uint32 {
	return (volatile.LoadUint32(&o.DMACREQSEL.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetDMACREQSEL_DMASEL04(value uint32) {
	volatile.StoreUint32(&o.DMACREQSEL.Reg, volatile.LoadUint32(&o.DMACREQSEL.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetDMACREQSEL_DMASEL04() uint32 {
	return (volatile.LoadUint32(&o.DMACREQSEL.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetDMACREQSEL_DMASEL05(value uint32) {
	volatile.StoreUint32(&o.DMACREQSEL.Reg, volatile.LoadUint32(&o.DMACREQSEL.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetDMACREQSEL_DMASEL05() uint32 {
	return (volatile.LoadUint32(&o.DMACREQSEL.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetDMACREQSEL_DMASEL06(value uint32) {
	volatile.StoreUint32(&o.DMACREQSEL.Reg, volatile.LoadUint32(&o.DMACREQSEL.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetDMACREQSEL_DMASEL06() uint32 {
	return (volatile.LoadUint32(&o.DMACREQSEL.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetDMACREQSEL_DMASEL07(value uint32) {
	volatile.StoreUint32(&o.DMACREQSEL.Reg, volatile.LoadUint32(&o.DMACREQSEL.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetDMACREQSEL_DMASEL07() uint32 {
	return (volatile.LoadUint32(&o.DMACREQSEL.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetDMACREQSEL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMACREQSEL.Reg, volatile.LoadUint32(&o.DMACREQSEL.Reg)&^(0x300)|value<<8)
}
func (o *SYSCON_Type) GetDMACREQSEL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMACREQSEL.Reg) & 0x300) >> 8
}
func (o *SYSCON_Type) SetDMACREQSEL_DMASEL10(value uint32) {
	volatile.StoreUint32(&o.DMACREQSEL.Reg, volatile.LoadUint32(&o.DMACREQSEL.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetDMACREQSEL_DMASEL10() uint32 {
	return (volatile.LoadUint32(&o.DMACREQSEL.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetDMACREQSEL_DMASEL11(value uint32) {
	volatile.StoreUint32(&o.DMACREQSEL.Reg, volatile.LoadUint32(&o.DMACREQSEL.Reg)&^(0x800)|value<<11)
}
func (o *SYSCON_Type) GetDMACREQSEL_DMASEL11() uint32 {
	return (volatile.LoadUint32(&o.DMACREQSEL.Reg) & 0x800) >> 11
}
func (o *SYSCON_Type) SetDMACREQSEL_DMASEL12(value uint32) {
	volatile.StoreUint32(&o.DMACREQSEL.Reg, volatile.LoadUint32(&o.DMACREQSEL.Reg)&^(0x1000)|value<<12)
}
func (o *SYSCON_Type) GetDMACREQSEL_DMASEL12() uint32 {
	return (volatile.LoadUint32(&o.DMACREQSEL.Reg) & 0x1000) >> 12
}
func (o *SYSCON_Type) SetDMACREQSEL_DMASEL13(value uint32) {
	volatile.StoreUint32(&o.DMACREQSEL.Reg, volatile.LoadUint32(&o.DMACREQSEL.Reg)&^(0x2000)|value<<13)
}
func (o *SYSCON_Type) GetDMACREQSEL_DMASEL13() uint32 {
	return (volatile.LoadUint32(&o.DMACREQSEL.Reg) & 0x2000) >> 13
}
func (o *SYSCON_Type) SetDMACREQSEL_DMASEL14(value uint32) {
	volatile.StoreUint32(&o.DMACREQSEL.Reg, volatile.LoadUint32(&o.DMACREQSEL.Reg)&^(0x4000)|value<<14)
}
func (o *SYSCON_Type) GetDMACREQSEL_DMASEL14() uint32 {
	return (volatile.LoadUint32(&o.DMACREQSEL.Reg) & 0x4000) >> 14
}
func (o *SYSCON_Type) SetDMACREQSEL_DMASEL15(value uint32) {
	volatile.StoreUint32(&o.DMACREQSEL.Reg, volatile.LoadUint32(&o.DMACREQSEL.Reg)&^(0x8000)|value<<15)
}
func (o *SYSCON_Type) GetDMACREQSEL_DMASEL15() uint32 {
	return (volatile.LoadUint32(&o.DMACREQSEL.Reg) & 0x8000) >> 15
}
func (o *SYSCON_Type) SetDMACREQSEL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DMACREQSEL.Reg, volatile.LoadUint32(&o.DMACREQSEL.Reg)&^(0xffff0000)|value<<16)
}
func (o *SYSCON_Type) GetDMACREQSEL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DMACREQSEL.Reg) & 0xffff0000) >> 16
}

// SYSCON.CLKOUTCFG: Clock Output Configuration register
func (o *SYSCON_Type) SetCLKOUTCFG_CLKOUTSEL(value uint32) {
	volatile.StoreUint32(&o.CLKOUTCFG.Reg, volatile.LoadUint32(&o.CLKOUTCFG.Reg)&^(0xf)|value)
}
func (o *SYSCON_Type) GetCLKOUTCFG_CLKOUTSEL() uint32 {
	return volatile.LoadUint32(&o.CLKOUTCFG.Reg) & 0xf
}
func (o *SYSCON_Type) SetCLKOUTCFG_CLKOUTDIV(value uint32) {
	volatile.StoreUint32(&o.CLKOUTCFG.Reg, volatile.LoadUint32(&o.CLKOUTCFG.Reg)&^(0xf0)|value<<4)
}
func (o *SYSCON_Type) GetCLKOUTCFG_CLKOUTDIV() uint32 {
	return (volatile.LoadUint32(&o.CLKOUTCFG.Reg) & 0xf0) >> 4
}
func (o *SYSCON_Type) SetCLKOUTCFG_CLKOUT_EN(value uint32) {
	volatile.StoreUint32(&o.CLKOUTCFG.Reg, volatile.LoadUint32(&o.CLKOUTCFG.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetCLKOUTCFG_CLKOUT_EN() uint32 {
	return (volatile.LoadUint32(&o.CLKOUTCFG.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetCLKOUTCFG_CLKOUT_ACT(value uint32) {
	volatile.StoreUint32(&o.CLKOUTCFG.Reg, volatile.LoadUint32(&o.CLKOUTCFG.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetCLKOUTCFG_CLKOUT_ACT() uint32 {
	return (volatile.LoadUint32(&o.CLKOUTCFG.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetCLKOUTCFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLKOUTCFG.Reg, volatile.LoadUint32(&o.CLKOUTCFG.Reg)&^(0xfffffc00)|value<<10)
}
func (o *SYSCON_Type) GetCLKOUTCFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLKOUTCFG.Reg) & 0xfffffc00) >> 10
}

// SYSCON.RSTCON0: Individual peripheral reset control bits
func (o *SYSCON_Type) SetRSTCON0_RSTLCD(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetRSTCON0_RSTLCD() uint32 {
	return volatile.LoadUint32(&o.RSTCON0.Reg) & 0x1
}
func (o *SYSCON_Type) SetRSTCON0_RSTTIM0(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetRSTCON0_RSTTIM0() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetRSTCON0_RSTTIM1(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetRSTCON0_RSTTIM1() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetRSTCON0_RSTUART0(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetRSTCON0_RSTUART0() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetRSTCON0_RSTUART1(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetRSTCON0_RSTUART1() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetRSTCON0_RSTPWM0(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetRSTCON0_RSTPWM0() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetRSTCON0_RSTPWM1(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetRSTCON0_RSTPWM1() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetRSTCON0_RSTI2C0(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetRSTCON0_RSTI2C0() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetRSTCON0_RSTUART4(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetRSTCON0_RSTUART4() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetRSTCON0_RSTRTC(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetRSTCON0_RSTRTC() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetRSTCON0_RSTSSP1(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetRSTCON0_RSTSSP1() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetRSTCON0_RSTEMC(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x800)|value<<11)
}
func (o *SYSCON_Type) GetRSTCON0_RSTEMC() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x800) >> 11
}
func (o *SYSCON_Type) SetRSTCON0_RSTADC(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x1000)|value<<12)
}
func (o *SYSCON_Type) GetRSTCON0_RSTADC() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x1000) >> 12
}
func (o *SYSCON_Type) SetRSTCON0_RSTCAN1(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x2000)|value<<13)
}
func (o *SYSCON_Type) GetRSTCON0_RSTCAN1() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x2000) >> 13
}
func (o *SYSCON_Type) SetRSTCON0_RSTCAN2(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x4000)|value<<14)
}
func (o *SYSCON_Type) GetRSTCON0_RSTCAN2() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x4000) >> 14
}
func (o *SYSCON_Type) SetRSTCON0_RSTGPIO(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x8000)|value<<15)
}
func (o *SYSCON_Type) GetRSTCON0_RSTGPIO() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x8000) >> 15
}
func (o *SYSCON_Type) SetRSTCON0_RSTSPIFI(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCON_Type) GetRSTCON0_RSTSPIFI() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x10000) >> 16
}
func (o *SYSCON_Type) SetRSTCON0_RSTMCPWM(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x20000)|value<<17)
}
func (o *SYSCON_Type) GetRSTCON0_RSTMCPWM() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x20000) >> 17
}
func (o *SYSCON_Type) SetRSTCON0_RSTQEI(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x40000)|value<<18)
}
func (o *SYSCON_Type) GetRSTCON0_RSTQEI() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x40000) >> 18
}
func (o *SYSCON_Type) SetRSTCON0_RSTI2C1(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x80000)|value<<19)
}
func (o *SYSCON_Type) GetRSTCON0_RSTI2C1() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x80000) >> 19
}
func (o *SYSCON_Type) SetRSTCON0_RSTSSP2(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x100000)|value<<20)
}
func (o *SYSCON_Type) GetRSTCON0_RSTSSP2() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x100000) >> 20
}
func (o *SYSCON_Type) SetRSTCON0_RSTSSP0(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x200000)|value<<21)
}
func (o *SYSCON_Type) GetRSTCON0_RSTSSP0() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x200000) >> 21
}
func (o *SYSCON_Type) SetRSTCON0_RSTTIM2(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x400000)|value<<22)
}
func (o *SYSCON_Type) GetRSTCON0_RSTTIM2() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x400000) >> 22
}
func (o *SYSCON_Type) SetRSTCON0_RSTTIM3(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x800000)|value<<23)
}
func (o *SYSCON_Type) GetRSTCON0_RSTTIM3() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x800000) >> 23
}
func (o *SYSCON_Type) SetRSTCON0_RSTUART2(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSCON_Type) GetRSTCON0_RSTUART2() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x1000000) >> 24
}
func (o *SYSCON_Type) SetRSTCON0_RSTUART3(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSCON_Type) GetRSTCON0_RSTUART3() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x2000000) >> 25
}
func (o *SYSCON_Type) SetRSTCON0_RSTI2C2(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x4000000)|value<<26)
}
func (o *SYSCON_Type) GetRSTCON0_RSTI2C2() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x4000000) >> 26
}
func (o *SYSCON_Type) SetRSTCON0_RSTI2S(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x8000000)|value<<27)
}
func (o *SYSCON_Type) GetRSTCON0_RSTI2S() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x8000000) >> 27
}
func (o *SYSCON_Type) SetRSTCON0_RSTSDC(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSCON_Type) GetRSTCON0_RSTSDC() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x10000000) >> 28
}
func (o *SYSCON_Type) SetRSTCON0_RSTGPDMA(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSCON_Type) GetRSTCON0_RSTGPDMA() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x20000000) >> 29
}
func (o *SYSCON_Type) SetRSTCON0_RSTENET(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSCON_Type) GetRSTCON0_RSTENET() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x40000000) >> 30
}
func (o *SYSCON_Type) SetRSTCON0_RSTUSB(value uint32) {
	volatile.StoreUint32(&o.RSTCON0.Reg, volatile.LoadUint32(&o.RSTCON0.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSCON_Type) GetRSTCON0_RSTUSB() uint32 {
	return (volatile.LoadUint32(&o.RSTCON0.Reg) & 0x80000000) >> 31
}

// SYSCON.RSTCON1: Individual peripheral reset control bits
func (o *SYSCON_Type) SetRSTCON1_RSTIOCON(value uint32) {
	volatile.StoreUint32(&o.RSTCON1.Reg, volatile.LoadUint32(&o.RSTCON1.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetRSTCON1_RSTIOCON() uint32 {
	return volatile.LoadUint32(&o.RSTCON1.Reg) & 0x1
}
func (o *SYSCON_Type) SetRSTCON1_RSTDAC(value uint32) {
	volatile.StoreUint32(&o.RSTCON1.Reg, volatile.LoadUint32(&o.RSTCON1.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetRSTCON1_RSTDAC() uint32 {
	return (volatile.LoadUint32(&o.RSTCON1.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetRSTCON1_RSTCANACC(value uint32) {
	volatile.StoreUint32(&o.RSTCON1.Reg, volatile.LoadUint32(&o.RSTCON1.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetRSTCON1_RSTCANACC() uint32 {
	return (volatile.LoadUint32(&o.RSTCON1.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetRSTCON1_RSTCMP(value uint32) {
	volatile.StoreUint32(&o.RSTCON1.Reg, volatile.LoadUint32(&o.RSTCON1.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetRSTCON1_RSTCMP() uint32 {
	return (volatile.LoadUint32(&o.RSTCON1.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetRSTCON1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RSTCON1.Reg, volatile.LoadUint32(&o.RSTCON1.Reg)&^(0xfffffff0)|value<<4)
}
func (o *SYSCON_Type) GetRSTCON1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RSTCON1.Reg) & 0xfffffff0) >> 4
}

// SYSCON.EMCDLYCTL: Values for the 4 programmable delays associated with SDRAM operation.
func (o *SYSCON_Type) SetEMCDLYCTL_CMDDLY(value uint32) {
	volatile.StoreUint32(&o.EMCDLYCTL.Reg, volatile.LoadUint32(&o.EMCDLYCTL.Reg)&^(0x1f)|value)
}
func (o *SYSCON_Type) GetEMCDLYCTL_CMDDLY() uint32 {
	return volatile.LoadUint32(&o.EMCDLYCTL.Reg) & 0x1f
}
func (o *SYSCON_Type) SetEMCDLYCTL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EMCDLYCTL.Reg, volatile.LoadUint32(&o.EMCDLYCTL.Reg)&^(0xe0)|value<<5)
}
func (o *SYSCON_Type) GetEMCDLYCTL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EMCDLYCTL.Reg) & 0xe0) >> 5
}
func (o *SYSCON_Type) SetEMCDLYCTL_FBCLKDLY(value uint32) {
	volatile.StoreUint32(&o.EMCDLYCTL.Reg, volatile.LoadUint32(&o.EMCDLYCTL.Reg)&^(0x1f00)|value<<8)
}
func (o *SYSCON_Type) GetEMCDLYCTL_FBCLKDLY() uint32 {
	return (volatile.LoadUint32(&o.EMCDLYCTL.Reg) & 0x1f00) >> 8
}
func (o *SYSCON_Type) SetEMCDLYCTL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EMCDLYCTL.Reg, volatile.LoadUint32(&o.EMCDLYCTL.Reg)&^(0xe000)|value<<13)
}
func (o *SYSCON_Type) GetEMCDLYCTL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EMCDLYCTL.Reg) & 0xe000) >> 13
}
func (o *SYSCON_Type) SetEMCDLYCTL_CLKOUT0DLY(value uint32) {
	volatile.StoreUint32(&o.EMCDLYCTL.Reg, volatile.LoadUint32(&o.EMCDLYCTL.Reg)&^(0x1f0000)|value<<16)
}
func (o *SYSCON_Type) GetEMCDLYCTL_CLKOUT0DLY() uint32 {
	return (volatile.LoadUint32(&o.EMCDLYCTL.Reg) & 0x1f0000) >> 16
}
func (o *SYSCON_Type) SetEMCDLYCTL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EMCDLYCTL.Reg, volatile.LoadUint32(&o.EMCDLYCTL.Reg)&^(0xe00000)|value<<21)
}
func (o *SYSCON_Type) GetEMCDLYCTL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EMCDLYCTL.Reg) & 0xe00000) >> 21
}
func (o *SYSCON_Type) SetEMCDLYCTL_CLKOUT1DLY(value uint32) {
	volatile.StoreUint32(&o.EMCDLYCTL.Reg, volatile.LoadUint32(&o.EMCDLYCTL.Reg)&^(0x1f000000)|value<<24)
}
func (o *SYSCON_Type) GetEMCDLYCTL_CLKOUT1DLY() uint32 {
	return (volatile.LoadUint32(&o.EMCDLYCTL.Reg) & 0x1f000000) >> 24
}
func (o *SYSCON_Type) SetEMCDLYCTL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EMCDLYCTL.Reg, volatile.LoadUint32(&o.EMCDLYCTL.Reg)&^(0xe0000000)|value<<29)
}
func (o *SYSCON_Type) GetEMCDLYCTL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EMCDLYCTL.Reg) & 0xe0000000) >> 29
}

// SYSCON.EMCCAL: Controls the calibration counter for programmable delays and returns the result value.
func (o *SYSCON_Type) SetEMCCAL_CALVALUE(value uint32) {
	volatile.StoreUint32(&o.EMCCAL.Reg, volatile.LoadUint32(&o.EMCCAL.Reg)&^(0xff)|value)
}
func (o *SYSCON_Type) GetEMCCAL_CALVALUE() uint32 {
	return volatile.LoadUint32(&o.EMCCAL.Reg) & 0xff
}
func (o *SYSCON_Type) SetEMCCAL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EMCCAL.Reg, volatile.LoadUint32(&o.EMCCAL.Reg)&^(0x3f00)|value<<8)
}
func (o *SYSCON_Type) GetEMCCAL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EMCCAL.Reg) & 0x3f00) >> 8
}
func (o *SYSCON_Type) SetEMCCAL_START(value uint32) {
	volatile.StoreUint32(&o.EMCCAL.Reg, volatile.LoadUint32(&o.EMCCAL.Reg)&^(0x4000)|value<<14)
}
func (o *SYSCON_Type) GetEMCCAL_START() uint32 {
	return (volatile.LoadUint32(&o.EMCCAL.Reg) & 0x4000) >> 14
}
func (o *SYSCON_Type) SetEMCCAL_DONE(value uint32) {
	volatile.StoreUint32(&o.EMCCAL.Reg, volatile.LoadUint32(&o.EMCCAL.Reg)&^(0x8000)|value<<15)
}
func (o *SYSCON_Type) GetEMCCAL_DONE() uint32 {
	return (volatile.LoadUint32(&o.EMCCAL.Reg) & 0x8000) >> 15
}
func (o *SYSCON_Type) SetEMCCAL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EMCCAL.Reg, volatile.LoadUint32(&o.EMCCAL.Reg)&^(0xffff0000)|value<<16)
}
func (o *SYSCON_Type) GetEMCCAL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EMCCAL.Reg) & 0xffff0000) >> 16
}

// Constants for FLASHCTRL: EEPROM/flash
const (
	// FMSSTART: Signature start address register
	// Position of START field.
	FLASHCTRL_FMSSTART_START_Pos = 0x0
	// Bit mask of START field.
	FLASHCTRL_FMSSTART_START_Msk = 0x1ffff
	// Position of RESERVED field.
	FLASHCTRL_FMSSTART_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	FLASHCTRL_FMSSTART_RESERVED_Msk = 0xfffe0000

	// FMSSTOP: Signature stop-address register
	// Position of STOP field.
	FLASHCTRL_FMSSTOP_STOP_Pos = 0x0
	// Bit mask of STOP field.
	FLASHCTRL_FMSSTOP_STOP_Msk = 0x1ffff
	// Position of SIG_START field.
	FLASHCTRL_FMSSTOP_SIG_START_Pos = 0x11
	// Bit mask of SIG_START field.
	FLASHCTRL_FMSSTOP_SIG_START_Msk = 0x20000
	// Bit SIG_START.
	FLASHCTRL_FMSSTOP_SIG_START = 0x20000
	// Signature generation is stopped
	FLASHCTRL_FMSSTOP_SIG_START_STOP = 0x0
	// Initiate signature generation
	FLASHCTRL_FMSSTOP_SIG_START_START = 0x1
	// Position of RESERVED field.
	FLASHCTRL_FMSSTOP_RESERVED_Pos = 0x12
	// Bit mask of RESERVED field.
	FLASHCTRL_FMSSTOP_RESERVED_Msk = 0xfffc0000

	// FMSW0: 128-bit signature Word 0
	// Position of SW0_31_0 field.
	FLASHCTRL_FMSW0_SW0_31_0_Pos = 0x0
	// Bit mask of SW0_31_0 field.
	FLASHCTRL_FMSW0_SW0_31_0_Msk = 0xffffffff

	// FMSW1: 128-bit signature Word 1
	// Position of SW1_63_32 field.
	FLASHCTRL_FMSW1_SW1_63_32_Pos = 0x0
	// Bit mask of SW1_63_32 field.
	FLASHCTRL_FMSW1_SW1_63_32_Msk = 0xffffffff

	// FMSW2: 128-bit signature Word 2
	// Position of SW2_95_64 field.
	FLASHCTRL_FMSW2_SW2_95_64_Pos = 0x0
	// Bit mask of SW2_95_64 field.
	FLASHCTRL_FMSW2_SW2_95_64_Msk = 0xffffffff

	// FMSW3: 128-bit signature Word 3
	// Position of SW3_127_96 field.
	FLASHCTRL_FMSW3_SW3_127_96_Pos = 0x0
	// Bit mask of SW3_127_96 field.
	FLASHCTRL_FMSW3_SW3_127_96_Msk = 0xffffffff

	// EECMD: EEPROM command register
	// Position of CMD field.
	FLASHCTRL_EECMD_CMD_Pos = 0x0
	// Bit mask of CMD field.
	FLASHCTRL_EECMD_CMD_Msk = 0x7
	// Position of RDPREFETCH field.
	FLASHCTRL_EECMD_RDPREFETCH_Pos = 0x3
	// Bit mask of RDPREFETCH field.
	FLASHCTRL_EECMD_RDPREFETCH_Msk = 0x8
	// Bit RDPREFETCH.
	FLASHCTRL_EECMD_RDPREFETCH = 0x8
	// Position of RESERVED field.
	FLASHCTRL_EECMD_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	FLASHCTRL_EECMD_RESERVED_Msk = 0xfffffff0

	// EEADDR: EEPROM address register
	// Position of ADDR field.
	FLASHCTRL_EEADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	FLASHCTRL_EEADDR_ADDR_Msk = 0xfff
	// Position of RESERVED field.
	FLASHCTRL_EEADDR_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	FLASHCTRL_EEADDR_RESERVED_Msk = 0xfffff000

	// EEWDATA: EEPROM write data register
	// Position of WDATA field.
	FLASHCTRL_EEWDATA_WDATA_Pos = 0x0
	// Bit mask of WDATA field.
	FLASHCTRL_EEWDATA_WDATA_Msk = 0xffffffff

	// EERDATA: EEPROM read data register
	// Position of RDATA field.
	FLASHCTRL_EERDATA_RDATA_Pos = 0x0
	// Bit mask of RDATA field.
	FLASHCTRL_EERDATA_RDATA_Msk = 0xffffffff

	// EEWSTATE: EEPROM wait state register
	// Position of PHASE3 field.
	FLASHCTRL_EEWSTATE_PHASE3_Pos = 0x0
	// Bit mask of PHASE3 field.
	FLASHCTRL_EEWSTATE_PHASE3_Msk = 0xff
	// Position of PHASE2 field.
	FLASHCTRL_EEWSTATE_PHASE2_Pos = 0x8
	// Bit mask of PHASE2 field.
	FLASHCTRL_EEWSTATE_PHASE2_Msk = 0xff00
	// Position of PHASE1 field.
	FLASHCTRL_EEWSTATE_PHASE1_Pos = 0x10
	// Bit mask of PHASE1 field.
	FLASHCTRL_EEWSTATE_PHASE1_Msk = 0xff0000
	// Position of RESERVED field.
	FLASHCTRL_EEWSTATE_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	FLASHCTRL_EEWSTATE_RESERVED_Msk = 0xff000000

	// EECLKDIV: EEPROM clock divider register
	// Position of CLKDIV field.
	FLASHCTRL_EECLKDIV_CLKDIV_Pos = 0x0
	// Bit mask of CLKDIV field.
	FLASHCTRL_EECLKDIV_CLKDIV_Msk = 0xffff
	// Position of RESERVED field.
	FLASHCTRL_EECLKDIV_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	FLASHCTRL_EECLKDIV_RESERVED_Msk = 0xffff0000

	// EEPWRDWN: EEPROM power-down register
	// Position of PWRDWN field.
	FLASHCTRL_EEPWRDWN_PWRDWN_Pos = 0x0
	// Bit mask of PWRDWN field.
	FLASHCTRL_EEPWRDWN_PWRDWN_Msk = 0x1
	// Bit PWRDWN.
	FLASHCTRL_EEPWRDWN_PWRDWN = 0x1
	// Position of RESERVED field.
	FLASHCTRL_EEPWRDWN_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	FLASHCTRL_EEPWRDWN_RESERVED_Msk = 0xfffffffe

	// ENCLR: EEPROM interrupt enable clear
	// Position of RESERVED field.
	FLASHCTRL_ENCLR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	FLASHCTRL_ENCLR_RESERVED_Msk = 0x3ffffff
	// Position of RDWR_CLR_EN field.
	FLASHCTRL_ENCLR_RDWR_CLR_EN_Pos = 0x1a
	// Bit mask of RDWR_CLR_EN field.
	FLASHCTRL_ENCLR_RDWR_CLR_EN_Msk = 0x4000000
	// Bit RDWR_CLR_EN.
	FLASHCTRL_ENCLR_RDWR_CLR_EN = 0x4000000
	// Position of RESERVED field.
	FLASHCTRL_ENCLR_RESERVED_Pos = 0x1b
	// Bit mask of RESERVED field.
	FLASHCTRL_ENCLR_RESERVED_Msk = 0x8000000
	// Bit RESERVED.
	FLASHCTRL_ENCLR_RESERVED = 0x8000000
	// Position of PROG1_CLR_EN field.
	FLASHCTRL_ENCLR_PROG1_CLR_EN_Pos = 0x1c
	// Bit mask of PROG1_CLR_EN field.
	FLASHCTRL_ENCLR_PROG1_CLR_EN_Msk = 0x10000000
	// Bit PROG1_CLR_EN.
	FLASHCTRL_ENCLR_PROG1_CLR_EN = 0x10000000
	// Position of RESERVED field.
	FLASHCTRL_ENCLR_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	FLASHCTRL_ENCLR_RESERVED_Msk = 0xe0000000

	// ENSET: EEPROM interrupt enable set
	// Position of RESERVED field.
	FLASHCTRL_ENSET_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	FLASHCTRL_ENSET_RESERVED_Msk = 0x3ffffff
	// Position of RDWR_SET_EN field.
	FLASHCTRL_ENSET_RDWR_SET_EN_Pos = 0x1a
	// Bit mask of RDWR_SET_EN field.
	FLASHCTRL_ENSET_RDWR_SET_EN_Msk = 0x4000000
	// Bit RDWR_SET_EN.
	FLASHCTRL_ENSET_RDWR_SET_EN = 0x4000000
	// Position of RESERVED field.
	FLASHCTRL_ENSET_RESERVED_Pos = 0x1b
	// Bit mask of RESERVED field.
	FLASHCTRL_ENSET_RESERVED_Msk = 0x8000000
	// Bit RESERVED.
	FLASHCTRL_ENSET_RESERVED = 0x8000000
	// Position of PROG1_SET_EN field.
	FLASHCTRL_ENSET_PROG1_SET_EN_Pos = 0x1c
	// Bit mask of PROG1_SET_EN field.
	FLASHCTRL_ENSET_PROG1_SET_EN_Msk = 0x10000000
	// Bit PROG1_SET_EN.
	FLASHCTRL_ENSET_PROG1_SET_EN = 0x10000000
	// Position of RESERVED field.
	FLASHCTRL_ENSET_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	FLASHCTRL_ENSET_RESERVED_Msk = 0xe0000000

	// STAT: Signature generation status register
	// Position of RESERVED field.
	FLASHCTRL_STAT_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	FLASHCTRL_STAT_RESERVED_Msk = 0x3
	// Position of SIG_DONE field.
	FLASHCTRL_STAT_SIG_DONE_Pos = 0x2
	// Bit mask of SIG_DONE field.
	FLASHCTRL_STAT_SIG_DONE_Msk = 0x4
	// Bit SIG_DONE.
	FLASHCTRL_STAT_SIG_DONE = 0x4
	// Position of RESERVED field.
	FLASHCTRL_STAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	FLASHCTRL_STAT_RESERVED_Msk = 0x3fffff8
	// Position of END_OF_RDWR field.
	FLASHCTRL_STAT_END_OF_RDWR_Pos = 0x1a
	// Bit mask of END_OF_RDWR field.
	FLASHCTRL_STAT_END_OF_RDWR_Msk = 0x4000000
	// Bit END_OF_RDWR.
	FLASHCTRL_STAT_END_OF_RDWR = 0x4000000
	// Position of RESERVED field.
	FLASHCTRL_STAT_RESERVED_Pos = 0x1b
	// Bit mask of RESERVED field.
	FLASHCTRL_STAT_RESERVED_Msk = 0x8000000
	// Bit RESERVED.
	FLASHCTRL_STAT_RESERVED = 0x8000000
	// Position of END_OF_PROG1 field.
	FLASHCTRL_STAT_END_OF_PROG1_Pos = 0x1c
	// Bit mask of END_OF_PROG1 field.
	FLASHCTRL_STAT_END_OF_PROG1_Msk = 0x10000000
	// Bit END_OF_PROG1.
	FLASHCTRL_STAT_END_OF_PROG1 = 0x10000000
	// Position of RESERVED field.
	FLASHCTRL_STAT_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	FLASHCTRL_STAT_RESERVED_Msk = 0xe0000000

	// INTEN: EEPROM interrupt enable
	// Position of RESERVED field.
	FLASHCTRL_INTEN_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	FLASHCTRL_INTEN_RESERVED_Msk = 0x3ffffff
	// Position of EE_RW_DONE field.
	FLASHCTRL_INTEN_EE_RW_DONE_Pos = 0x1a
	// Bit mask of EE_RW_DONE field.
	FLASHCTRL_INTEN_EE_RW_DONE_Msk = 0x4000000
	// Bit EE_RW_DONE.
	FLASHCTRL_INTEN_EE_RW_DONE = 0x4000000
	// Position of RESERVED field.
	FLASHCTRL_INTEN_RESERVED_Pos = 0x1b
	// Bit mask of RESERVED field.
	FLASHCTRL_INTEN_RESERVED_Msk = 0x8000000
	// Bit RESERVED.
	FLASHCTRL_INTEN_RESERVED = 0x8000000
	// Position of EE_PROG_DONE field.
	FLASHCTRL_INTEN_EE_PROG_DONE_Pos = 0x1c
	// Bit mask of EE_PROG_DONE field.
	FLASHCTRL_INTEN_EE_PROG_DONE_Msk = 0x10000000
	// Bit EE_PROG_DONE.
	FLASHCTRL_INTEN_EE_PROG_DONE = 0x10000000
	// Position of RESERVED field.
	FLASHCTRL_INTEN_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	FLASHCTRL_INTEN_RESERVED_Msk = 0xe0000000

	// STATCLR: Signature generation status clear register
	// Position of RESERVED field.
	FLASHCTRL_STATCLR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	FLASHCTRL_STATCLR_RESERVED_Msk = 0x3
	// Position of SIG_DONE_CLR field.
	FLASHCTRL_STATCLR_SIG_DONE_CLR_Pos = 0x2
	// Bit mask of SIG_DONE_CLR field.
	FLASHCTRL_STATCLR_SIG_DONE_CLR_Msk = 0x4
	// Bit SIG_DONE_CLR.
	FLASHCTRL_STATCLR_SIG_DONE_CLR = 0x4
	// Position of RESERVED field.
	FLASHCTRL_STATCLR_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	FLASHCTRL_STATCLR_RESERVED_Msk = 0x3fffff8
	// Position of RDWR_CLR_ST field.
	FLASHCTRL_STATCLR_RDWR_CLR_ST_Pos = 0x1a
	// Bit mask of RDWR_CLR_ST field.
	FLASHCTRL_STATCLR_RDWR_CLR_ST_Msk = 0x4000000
	// Bit RDWR_CLR_ST.
	FLASHCTRL_STATCLR_RDWR_CLR_ST = 0x4000000
	// Position of RESERVED field.
	FLASHCTRL_STATCLR_RESERVED_Pos = 0x1b
	// Bit mask of RESERVED field.
	FLASHCTRL_STATCLR_RESERVED_Msk = 0x8000000
	// Bit RESERVED.
	FLASHCTRL_STATCLR_RESERVED = 0x8000000
	// Position of PROG1_CLR_ST field.
	FLASHCTRL_STATCLR_PROG1_CLR_ST_Pos = 0x1c
	// Bit mask of PROG1_CLR_ST field.
	FLASHCTRL_STATCLR_PROG1_CLR_ST_Msk = 0x10000000
	// Bit PROG1_CLR_ST.
	FLASHCTRL_STATCLR_PROG1_CLR_ST = 0x10000000
	// Position of RESERVED field.
	FLASHCTRL_STATCLR_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	FLASHCTRL_STATCLR_RESERVED_Msk = 0xe0000000
)

// Constants for GPDMA: General Purpose DMA controller Modification
const (
	// INTSTAT: DMA Interrupt Status Register
	// Position of INTSTAT0 field.
	GPDMA_INTSTAT_INTSTAT0_Pos = 0x0
	// Bit mask of INTSTAT0 field.
	GPDMA_INTSTAT_INTSTAT0_Msk = 0x1
	// Bit INTSTAT0.
	GPDMA_INTSTAT_INTSTAT0 = 0x1
	// Position of INTSTAT1 field.
	GPDMA_INTSTAT_INTSTAT1_Pos = 0x1
	// Bit mask of INTSTAT1 field.
	GPDMA_INTSTAT_INTSTAT1_Msk = 0x2
	// Bit INTSTAT1.
	GPDMA_INTSTAT_INTSTAT1 = 0x2
	// Position of INTSTAT2 field.
	GPDMA_INTSTAT_INTSTAT2_Pos = 0x2
	// Bit mask of INTSTAT2 field.
	GPDMA_INTSTAT_INTSTAT2_Msk = 0x4
	// Bit INTSTAT2.
	GPDMA_INTSTAT_INTSTAT2 = 0x4
	// Position of INTSTAT3 field.
	GPDMA_INTSTAT_INTSTAT3_Pos = 0x3
	// Bit mask of INTSTAT3 field.
	GPDMA_INTSTAT_INTSTAT3_Msk = 0x8
	// Bit INTSTAT3.
	GPDMA_INTSTAT_INTSTAT3 = 0x8
	// Position of INTSTAT4 field.
	GPDMA_INTSTAT_INTSTAT4_Pos = 0x4
	// Bit mask of INTSTAT4 field.
	GPDMA_INTSTAT_INTSTAT4_Msk = 0x10
	// Bit INTSTAT4.
	GPDMA_INTSTAT_INTSTAT4 = 0x10
	// Position of INTSTAT5 field.
	GPDMA_INTSTAT_INTSTAT5_Pos = 0x5
	// Bit mask of INTSTAT5 field.
	GPDMA_INTSTAT_INTSTAT5_Msk = 0x20
	// Bit INTSTAT5.
	GPDMA_INTSTAT_INTSTAT5 = 0x20
	// Position of INTSTAT6 field.
	GPDMA_INTSTAT_INTSTAT6_Pos = 0x6
	// Bit mask of INTSTAT6 field.
	GPDMA_INTSTAT_INTSTAT6_Msk = 0x40
	// Bit INTSTAT6.
	GPDMA_INTSTAT_INTSTAT6 = 0x40
	// Position of INTSTAT7 field.
	GPDMA_INTSTAT_INTSTAT7_Pos = 0x7
	// Bit mask of INTSTAT7 field.
	GPDMA_INTSTAT_INTSTAT7_Msk = 0x80
	// Bit INTSTAT7.
	GPDMA_INTSTAT_INTSTAT7 = 0x80
	// Position of RESERVED field.
	GPDMA_INTSTAT_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GPDMA_INTSTAT_RESERVED_Msk = 0xffffff00

	// INTTCSTAT: DMA Interrupt Terminal Count Request Status Register
	// Position of INTTCSTAT0 field.
	GPDMA_INTTCSTAT_INTTCSTAT0_Pos = 0x0
	// Bit mask of INTTCSTAT0 field.
	GPDMA_INTTCSTAT_INTTCSTAT0_Msk = 0x1
	// Bit INTTCSTAT0.
	GPDMA_INTTCSTAT_INTTCSTAT0 = 0x1
	// Position of INTTCSTAT1 field.
	GPDMA_INTTCSTAT_INTTCSTAT1_Pos = 0x1
	// Bit mask of INTTCSTAT1 field.
	GPDMA_INTTCSTAT_INTTCSTAT1_Msk = 0x2
	// Bit INTTCSTAT1.
	GPDMA_INTTCSTAT_INTTCSTAT1 = 0x2
	// Position of INTTCSTAT2 field.
	GPDMA_INTTCSTAT_INTTCSTAT2_Pos = 0x2
	// Bit mask of INTTCSTAT2 field.
	GPDMA_INTTCSTAT_INTTCSTAT2_Msk = 0x4
	// Bit INTTCSTAT2.
	GPDMA_INTTCSTAT_INTTCSTAT2 = 0x4
	// Position of INTTCSTAT3 field.
	GPDMA_INTTCSTAT_INTTCSTAT3_Pos = 0x3
	// Bit mask of INTTCSTAT3 field.
	GPDMA_INTTCSTAT_INTTCSTAT3_Msk = 0x8
	// Bit INTTCSTAT3.
	GPDMA_INTTCSTAT_INTTCSTAT3 = 0x8
	// Position of INTTCSTAT4 field.
	GPDMA_INTTCSTAT_INTTCSTAT4_Pos = 0x4
	// Bit mask of INTTCSTAT4 field.
	GPDMA_INTTCSTAT_INTTCSTAT4_Msk = 0x10
	// Bit INTTCSTAT4.
	GPDMA_INTTCSTAT_INTTCSTAT4 = 0x10
	// Position of INTTCSTAT5 field.
	GPDMA_INTTCSTAT_INTTCSTAT5_Pos = 0x5
	// Bit mask of INTTCSTAT5 field.
	GPDMA_INTTCSTAT_INTTCSTAT5_Msk = 0x20
	// Bit INTTCSTAT5.
	GPDMA_INTTCSTAT_INTTCSTAT5 = 0x20
	// Position of INTTCSTAT6 field.
	GPDMA_INTTCSTAT_INTTCSTAT6_Pos = 0x6
	// Bit mask of INTTCSTAT6 field.
	GPDMA_INTTCSTAT_INTTCSTAT6_Msk = 0x40
	// Bit INTTCSTAT6.
	GPDMA_INTTCSTAT_INTTCSTAT6 = 0x40
	// Position of INTTCSTAT7 field.
	GPDMA_INTTCSTAT_INTTCSTAT7_Pos = 0x7
	// Bit mask of INTTCSTAT7 field.
	GPDMA_INTTCSTAT_INTTCSTAT7_Msk = 0x80
	// Bit INTTCSTAT7.
	GPDMA_INTTCSTAT_INTTCSTAT7 = 0x80
	// Position of RESERVED field.
	GPDMA_INTTCSTAT_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GPDMA_INTTCSTAT_RESERVED_Msk = 0xffffff00

	// INTTCCLEAR: DMA Interrupt Terminal Count Request Clear Register
	// Position of INTTCCLEAR0 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR0_Pos = 0x0
	// Bit mask of INTTCCLEAR0 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR0_Msk = 0x1
	// Bit INTTCCLEAR0.
	GPDMA_INTTCCLEAR_INTTCCLEAR0 = 0x1
	// Position of INTTCCLEAR1 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR1_Pos = 0x1
	// Bit mask of INTTCCLEAR1 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR1_Msk = 0x2
	// Bit INTTCCLEAR1.
	GPDMA_INTTCCLEAR_INTTCCLEAR1 = 0x2
	// Position of INTTCCLEAR2 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR2_Pos = 0x2
	// Bit mask of INTTCCLEAR2 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR2_Msk = 0x4
	// Bit INTTCCLEAR2.
	GPDMA_INTTCCLEAR_INTTCCLEAR2 = 0x4
	// Position of INTTCCLEAR3 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR3_Pos = 0x3
	// Bit mask of INTTCCLEAR3 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR3_Msk = 0x8
	// Bit INTTCCLEAR3.
	GPDMA_INTTCCLEAR_INTTCCLEAR3 = 0x8
	// Position of INTTCCLEAR4 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR4_Pos = 0x4
	// Bit mask of INTTCCLEAR4 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR4_Msk = 0x10
	// Bit INTTCCLEAR4.
	GPDMA_INTTCCLEAR_INTTCCLEAR4 = 0x10
	// Position of INTTCCLEAR5 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR5_Pos = 0x5
	// Bit mask of INTTCCLEAR5 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR5_Msk = 0x20
	// Bit INTTCCLEAR5.
	GPDMA_INTTCCLEAR_INTTCCLEAR5 = 0x20
	// Position of INTTCCLEAR6 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR6_Pos = 0x6
	// Bit mask of INTTCCLEAR6 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR6_Msk = 0x40
	// Bit INTTCCLEAR6.
	GPDMA_INTTCCLEAR_INTTCCLEAR6 = 0x40
	// Position of INTTCCLEAR7 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR7_Pos = 0x7
	// Bit mask of INTTCCLEAR7 field.
	GPDMA_INTTCCLEAR_INTTCCLEAR7_Msk = 0x80
	// Bit INTTCCLEAR7.
	GPDMA_INTTCCLEAR_INTTCCLEAR7 = 0x80
	// Position of RESERVED field.
	GPDMA_INTTCCLEAR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GPDMA_INTTCCLEAR_RESERVED_Msk = 0xffffff00

	// INTERRSTAT: DMA Interrupt Error Status Register
	// Position of INTERRSTAT0 field.
	GPDMA_INTERRSTAT_INTERRSTAT0_Pos = 0x0
	// Bit mask of INTERRSTAT0 field.
	GPDMA_INTERRSTAT_INTERRSTAT0_Msk = 0x1
	// Bit INTERRSTAT0.
	GPDMA_INTERRSTAT_INTERRSTAT0 = 0x1
	// Position of INTERRSTAT1 field.
	GPDMA_INTERRSTAT_INTERRSTAT1_Pos = 0x1
	// Bit mask of INTERRSTAT1 field.
	GPDMA_INTERRSTAT_INTERRSTAT1_Msk = 0x2
	// Bit INTERRSTAT1.
	GPDMA_INTERRSTAT_INTERRSTAT1 = 0x2
	// Position of INTERRSTAT2 field.
	GPDMA_INTERRSTAT_INTERRSTAT2_Pos = 0x2
	// Bit mask of INTERRSTAT2 field.
	GPDMA_INTERRSTAT_INTERRSTAT2_Msk = 0x4
	// Bit INTERRSTAT2.
	GPDMA_INTERRSTAT_INTERRSTAT2 = 0x4
	// Position of INTERRSTAT3 field.
	GPDMA_INTERRSTAT_INTERRSTAT3_Pos = 0x3
	// Bit mask of INTERRSTAT3 field.
	GPDMA_INTERRSTAT_INTERRSTAT3_Msk = 0x8
	// Bit INTERRSTAT3.
	GPDMA_INTERRSTAT_INTERRSTAT3 = 0x8
	// Position of INTERRSTAT4 field.
	GPDMA_INTERRSTAT_INTERRSTAT4_Pos = 0x4
	// Bit mask of INTERRSTAT4 field.
	GPDMA_INTERRSTAT_INTERRSTAT4_Msk = 0x10
	// Bit INTERRSTAT4.
	GPDMA_INTERRSTAT_INTERRSTAT4 = 0x10
	// Position of INTERRSTAT5 field.
	GPDMA_INTERRSTAT_INTERRSTAT5_Pos = 0x5
	// Bit mask of INTERRSTAT5 field.
	GPDMA_INTERRSTAT_INTERRSTAT5_Msk = 0x20
	// Bit INTERRSTAT5.
	GPDMA_INTERRSTAT_INTERRSTAT5 = 0x20
	// Position of INTERRSTAT6 field.
	GPDMA_INTERRSTAT_INTERRSTAT6_Pos = 0x6
	// Bit mask of INTERRSTAT6 field.
	GPDMA_INTERRSTAT_INTERRSTAT6_Msk = 0x40
	// Bit INTERRSTAT6.
	GPDMA_INTERRSTAT_INTERRSTAT6 = 0x40
	// Position of INTERRSTAT7 field.
	GPDMA_INTERRSTAT_INTERRSTAT7_Pos = 0x7
	// Bit mask of INTERRSTAT7 field.
	GPDMA_INTERRSTAT_INTERRSTAT7_Msk = 0x80
	// Bit INTERRSTAT7.
	GPDMA_INTERRSTAT_INTERRSTAT7 = 0x80
	// Position of RESERVED field.
	GPDMA_INTERRSTAT_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GPDMA_INTERRSTAT_RESERVED_Msk = 0xffffff00

	// INTERRCLR: DMA Interrupt Error Clear Register
	// Position of INTERRCLR0 field.
	GPDMA_INTERRCLR_INTERRCLR0_Pos = 0x0
	// Bit mask of INTERRCLR0 field.
	GPDMA_INTERRCLR_INTERRCLR0_Msk = 0x1
	// Bit INTERRCLR0.
	GPDMA_INTERRCLR_INTERRCLR0 = 0x1
	// Position of INTERRCLR1 field.
	GPDMA_INTERRCLR_INTERRCLR1_Pos = 0x1
	// Bit mask of INTERRCLR1 field.
	GPDMA_INTERRCLR_INTERRCLR1_Msk = 0x2
	// Bit INTERRCLR1.
	GPDMA_INTERRCLR_INTERRCLR1 = 0x2
	// Position of INTERRCLR2 field.
	GPDMA_INTERRCLR_INTERRCLR2_Pos = 0x2
	// Bit mask of INTERRCLR2 field.
	GPDMA_INTERRCLR_INTERRCLR2_Msk = 0x4
	// Bit INTERRCLR2.
	GPDMA_INTERRCLR_INTERRCLR2 = 0x4
	// Position of INTERRCLR3 field.
	GPDMA_INTERRCLR_INTERRCLR3_Pos = 0x3
	// Bit mask of INTERRCLR3 field.
	GPDMA_INTERRCLR_INTERRCLR3_Msk = 0x8
	// Bit INTERRCLR3.
	GPDMA_INTERRCLR_INTERRCLR3 = 0x8
	// Position of INTERRCLR4 field.
	GPDMA_INTERRCLR_INTERRCLR4_Pos = 0x4
	// Bit mask of INTERRCLR4 field.
	GPDMA_INTERRCLR_INTERRCLR4_Msk = 0x10
	// Bit INTERRCLR4.
	GPDMA_INTERRCLR_INTERRCLR4 = 0x10
	// Position of INTERRCLR5 field.
	GPDMA_INTERRCLR_INTERRCLR5_Pos = 0x5
	// Bit mask of INTERRCLR5 field.
	GPDMA_INTERRCLR_INTERRCLR5_Msk = 0x20
	// Bit INTERRCLR5.
	GPDMA_INTERRCLR_INTERRCLR5 = 0x20
	// Position of INTERRCLR6 field.
	GPDMA_INTERRCLR_INTERRCLR6_Pos = 0x6
	// Bit mask of INTERRCLR6 field.
	GPDMA_INTERRCLR_INTERRCLR6_Msk = 0x40
	// Bit INTERRCLR6.
	GPDMA_INTERRCLR_INTERRCLR6 = 0x40
	// Position of INTERRCLR7 field.
	GPDMA_INTERRCLR_INTERRCLR7_Pos = 0x7
	// Bit mask of INTERRCLR7 field.
	GPDMA_INTERRCLR_INTERRCLR7_Msk = 0x80
	// Bit INTERRCLR7.
	GPDMA_INTERRCLR_INTERRCLR7 = 0x80
	// Position of RESERVED field.
	GPDMA_INTERRCLR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GPDMA_INTERRCLR_RESERVED_Msk = 0xffffff00

	// RAWINTTCSTAT: DMA Raw Interrupt Terminal Count Status Register
	// Position of RAWINTTCSTAT0 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT0_Pos = 0x0
	// Bit mask of RAWINTTCSTAT0 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT0_Msk = 0x1
	// Bit RAWINTTCSTAT0.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT0 = 0x1
	// Position of RAWINTTCSTAT1 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT1_Pos = 0x1
	// Bit mask of RAWINTTCSTAT1 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT1_Msk = 0x2
	// Bit RAWINTTCSTAT1.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT1 = 0x2
	// Position of RAWINTTCSTAT2 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT2_Pos = 0x2
	// Bit mask of RAWINTTCSTAT2 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT2_Msk = 0x4
	// Bit RAWINTTCSTAT2.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT2 = 0x4
	// Position of RAWINTTCSTAT3 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT3_Pos = 0x3
	// Bit mask of RAWINTTCSTAT3 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT3_Msk = 0x8
	// Bit RAWINTTCSTAT3.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT3 = 0x8
	// Position of RAWINTTCSTAT4 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT4_Pos = 0x4
	// Bit mask of RAWINTTCSTAT4 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT4_Msk = 0x10
	// Bit RAWINTTCSTAT4.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT4 = 0x10
	// Position of RAWINTTCSTAT5 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT5_Pos = 0x5
	// Bit mask of RAWINTTCSTAT5 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT5_Msk = 0x20
	// Bit RAWINTTCSTAT5.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT5 = 0x20
	// Position of RAWINTTCSTAT6 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT6_Pos = 0x6
	// Bit mask of RAWINTTCSTAT6 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT6_Msk = 0x40
	// Bit RAWINTTCSTAT6.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT6 = 0x40
	// Position of RAWINTTCSTAT7 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT7_Pos = 0x7
	// Bit mask of RAWINTTCSTAT7 field.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT7_Msk = 0x80
	// Bit RAWINTTCSTAT7.
	GPDMA_RAWINTTCSTAT_RAWINTTCSTAT7 = 0x80
	// Position of RESERVED field.
	GPDMA_RAWINTTCSTAT_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GPDMA_RAWINTTCSTAT_RESERVED_Msk = 0xffffff00

	// RAWINTERRSTAT: DMA Raw Error Interrupt Status Register
	// Position of RAWINTERRSTAT0 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT0_Pos = 0x0
	// Bit mask of RAWINTERRSTAT0 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT0_Msk = 0x1
	// Bit RAWINTERRSTAT0.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT0 = 0x1
	// Position of RAWINTERRSTAT1 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT1_Pos = 0x1
	// Bit mask of RAWINTERRSTAT1 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT1_Msk = 0x2
	// Bit RAWINTERRSTAT1.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT1 = 0x2
	// Position of RAWINTERRSTAT2 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT2_Pos = 0x2
	// Bit mask of RAWINTERRSTAT2 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT2_Msk = 0x4
	// Bit RAWINTERRSTAT2.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT2 = 0x4
	// Position of RAWINTERRSTAT3 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT3_Pos = 0x3
	// Bit mask of RAWINTERRSTAT3 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT3_Msk = 0x8
	// Bit RAWINTERRSTAT3.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT3 = 0x8
	// Position of RAWINTERRSTAT4 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT4_Pos = 0x4
	// Bit mask of RAWINTERRSTAT4 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT4_Msk = 0x10
	// Bit RAWINTERRSTAT4.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT4 = 0x10
	// Position of RAWINTERRSTAT5 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT5_Pos = 0x5
	// Bit mask of RAWINTERRSTAT5 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT5_Msk = 0x20
	// Bit RAWINTERRSTAT5.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT5 = 0x20
	// Position of RAWINTERRSTAT6 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT6_Pos = 0x6
	// Bit mask of RAWINTERRSTAT6 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT6_Msk = 0x40
	// Bit RAWINTERRSTAT6.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT6 = 0x40
	// Position of RAWINTERRSTAT7 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT7_Pos = 0x7
	// Bit mask of RAWINTERRSTAT7 field.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT7_Msk = 0x80
	// Bit RAWINTERRSTAT7.
	GPDMA_RAWINTERRSTAT_RAWINTERRSTAT7 = 0x80
	// Position of RESERVED field.
	GPDMA_RAWINTERRSTAT_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GPDMA_RAWINTERRSTAT_RESERVED_Msk = 0xffffff00

	// ENBLDCHNS: DMA Enabled Channel Register
	// Position of ENABLEDCHANNELS0 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS0_Pos = 0x0
	// Bit mask of ENABLEDCHANNELS0 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS0_Msk = 0x1
	// Bit ENABLEDCHANNELS0.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS0 = 0x1
	// Position of ENABLEDCHANNELS1 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS1_Pos = 0x1
	// Bit mask of ENABLEDCHANNELS1 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS1_Msk = 0x2
	// Bit ENABLEDCHANNELS1.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS1 = 0x2
	// Position of ENABLEDCHANNELS2 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS2_Pos = 0x2
	// Bit mask of ENABLEDCHANNELS2 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS2_Msk = 0x4
	// Bit ENABLEDCHANNELS2.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS2 = 0x4
	// Position of ENABLEDCHANNELS3 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS3_Pos = 0x3
	// Bit mask of ENABLEDCHANNELS3 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS3_Msk = 0x8
	// Bit ENABLEDCHANNELS3.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS3 = 0x8
	// Position of ENABLEDCHANNELS4 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS4_Pos = 0x4
	// Bit mask of ENABLEDCHANNELS4 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS4_Msk = 0x10
	// Bit ENABLEDCHANNELS4.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS4 = 0x10
	// Position of ENABLEDCHANNELS5 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS5_Pos = 0x5
	// Bit mask of ENABLEDCHANNELS5 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS5_Msk = 0x20
	// Bit ENABLEDCHANNELS5.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS5 = 0x20
	// Position of ENABLEDCHANNELS6 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS6_Pos = 0x6
	// Bit mask of ENABLEDCHANNELS6 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS6_Msk = 0x40
	// Bit ENABLEDCHANNELS6.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS6 = 0x40
	// Position of ENABLEDCHANNELS7 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS7_Pos = 0x7
	// Bit mask of ENABLEDCHANNELS7 field.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS7_Msk = 0x80
	// Bit ENABLEDCHANNELS7.
	GPDMA_ENBLDCHNS_ENABLEDCHANNELS7 = 0x80
	// Position of RESERVED field.
	GPDMA_ENBLDCHNS_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	GPDMA_ENBLDCHNS_RESERVED_Msk = 0xffffff00

	// SOFTBREQ: DMA Software Burst Request Register
	// Position of SOFTBREQ0 field.
	GPDMA_SOFTBREQ_SOFTBREQ0_Pos = 0x0
	// Bit mask of SOFTBREQ0 field.
	GPDMA_SOFTBREQ_SOFTBREQ0_Msk = 0x1
	// Bit SOFTBREQ0.
	GPDMA_SOFTBREQ_SOFTBREQ0 = 0x1
	// Position of SOFTBREQ1 field.
	GPDMA_SOFTBREQ_SOFTBREQ1_Pos = 0x1
	// Bit mask of SOFTBREQ1 field.
	GPDMA_SOFTBREQ_SOFTBREQ1_Msk = 0x2
	// Bit SOFTBREQ1.
	GPDMA_SOFTBREQ_SOFTBREQ1 = 0x2
	// Position of SOFTBREQ2 field.
	GPDMA_SOFTBREQ_SOFTBREQ2_Pos = 0x2
	// Bit mask of SOFTBREQ2 field.
	GPDMA_SOFTBREQ_SOFTBREQ2_Msk = 0x4
	// Bit SOFTBREQ2.
	GPDMA_SOFTBREQ_SOFTBREQ2 = 0x4
	// Position of SOFTBREQ3 field.
	GPDMA_SOFTBREQ_SOFTBREQ3_Pos = 0x3
	// Bit mask of SOFTBREQ3 field.
	GPDMA_SOFTBREQ_SOFTBREQ3_Msk = 0x8
	// Bit SOFTBREQ3.
	GPDMA_SOFTBREQ_SOFTBREQ3 = 0x8
	// Position of SOFTBREQ4 field.
	GPDMA_SOFTBREQ_SOFTBREQ4_Pos = 0x4
	// Bit mask of SOFTBREQ4 field.
	GPDMA_SOFTBREQ_SOFTBREQ4_Msk = 0x10
	// Bit SOFTBREQ4.
	GPDMA_SOFTBREQ_SOFTBREQ4 = 0x10
	// Position of SOFTBREQ5 field.
	GPDMA_SOFTBREQ_SOFTBREQ5_Pos = 0x5
	// Bit mask of SOFTBREQ5 field.
	GPDMA_SOFTBREQ_SOFTBREQ5_Msk = 0x20
	// Bit SOFTBREQ5.
	GPDMA_SOFTBREQ_SOFTBREQ5 = 0x20
	// Position of SOFTBREQ6 field.
	GPDMA_SOFTBREQ_SOFTBREQ6_Pos = 0x6
	// Bit mask of SOFTBREQ6 field.
	GPDMA_SOFTBREQ_SOFTBREQ6_Msk = 0x40
	// Bit SOFTBREQ6.
	GPDMA_SOFTBREQ_SOFTBREQ6 = 0x40
	// Position of SOFTBREQ7 field.
	GPDMA_SOFTBREQ_SOFTBREQ7_Pos = 0x7
	// Bit mask of SOFTBREQ7 field.
	GPDMA_SOFTBREQ_SOFTBREQ7_Msk = 0x80
	// Bit SOFTBREQ7.
	GPDMA_SOFTBREQ_SOFTBREQ7 = 0x80
	// Position of SOFTBREQ8 field.
	GPDMA_SOFTBREQ_SOFTBREQ8_Pos = 0x8
	// Bit mask of SOFTBREQ8 field.
	GPDMA_SOFTBREQ_SOFTBREQ8_Msk = 0x100
	// Bit SOFTBREQ8.
	GPDMA_SOFTBREQ_SOFTBREQ8 = 0x100
	// Position of SOFTBREQ9 field.
	GPDMA_SOFTBREQ_SOFTBREQ9_Pos = 0x9
	// Bit mask of SOFTBREQ9 field.
	GPDMA_SOFTBREQ_SOFTBREQ9_Msk = 0x200
	// Bit SOFTBREQ9.
	GPDMA_SOFTBREQ_SOFTBREQ9 = 0x200
	// Position of SOFTBREQ10 field.
	GPDMA_SOFTBREQ_SOFTBREQ10_Pos = 0xa
	// Bit mask of SOFTBREQ10 field.
	GPDMA_SOFTBREQ_SOFTBREQ10_Msk = 0x400
	// Bit SOFTBREQ10.
	GPDMA_SOFTBREQ_SOFTBREQ10 = 0x400
	// Position of SOFTBREQ11 field.
	GPDMA_SOFTBREQ_SOFTBREQ11_Pos = 0xb
	// Bit mask of SOFTBREQ11 field.
	GPDMA_SOFTBREQ_SOFTBREQ11_Msk = 0x800
	// Bit SOFTBREQ11.
	GPDMA_SOFTBREQ_SOFTBREQ11 = 0x800
	// Position of SOFTBREQ12 field.
	GPDMA_SOFTBREQ_SOFTBREQ12_Pos = 0xc
	// Bit mask of SOFTBREQ12 field.
	GPDMA_SOFTBREQ_SOFTBREQ12_Msk = 0x1000
	// Bit SOFTBREQ12.
	GPDMA_SOFTBREQ_SOFTBREQ12 = 0x1000
	// Position of SOFTBREQ13 field.
	GPDMA_SOFTBREQ_SOFTBREQ13_Pos = 0xd
	// Bit mask of SOFTBREQ13 field.
	GPDMA_SOFTBREQ_SOFTBREQ13_Msk = 0x2000
	// Bit SOFTBREQ13.
	GPDMA_SOFTBREQ_SOFTBREQ13 = 0x2000
	// Position of SOFTBREQ14 field.
	GPDMA_SOFTBREQ_SOFTBREQ14_Pos = 0xe
	// Bit mask of SOFTBREQ14 field.
	GPDMA_SOFTBREQ_SOFTBREQ14_Msk = 0x4000
	// Bit SOFTBREQ14.
	GPDMA_SOFTBREQ_SOFTBREQ14 = 0x4000
	// Position of SOFTBREQ15 field.
	GPDMA_SOFTBREQ_SOFTBREQ15_Pos = 0xf
	// Bit mask of SOFTBREQ15 field.
	GPDMA_SOFTBREQ_SOFTBREQ15_Msk = 0x8000
	// Bit SOFTBREQ15.
	GPDMA_SOFTBREQ_SOFTBREQ15 = 0x8000
	// Position of RESERVED field.
	GPDMA_SOFTBREQ_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	GPDMA_SOFTBREQ_RESERVED_Msk = 0xffff0000

	// SOFTSREQ: DMA Software Single Request Register
	// Position of SOFTSREQ0 field.
	GPDMA_SOFTSREQ_SOFTSREQ0_Pos = 0x0
	// Bit mask of SOFTSREQ0 field.
	GPDMA_SOFTSREQ_SOFTSREQ0_Msk = 0x1
	// Bit SOFTSREQ0.
	GPDMA_SOFTSREQ_SOFTSREQ0 = 0x1
	// Position of SOFTSREQ1 field.
	GPDMA_SOFTSREQ_SOFTSREQ1_Pos = 0x1
	// Bit mask of SOFTSREQ1 field.
	GPDMA_SOFTSREQ_SOFTSREQ1_Msk = 0x2
	// Bit SOFTSREQ1.
	GPDMA_SOFTSREQ_SOFTSREQ1 = 0x2
	// Position of SOFTSREQ2 field.
	GPDMA_SOFTSREQ_SOFTSREQ2_Pos = 0x2
	// Bit mask of SOFTSREQ2 field.
	GPDMA_SOFTSREQ_SOFTSREQ2_Msk = 0x4
	// Bit SOFTSREQ2.
	GPDMA_SOFTSREQ_SOFTSREQ2 = 0x4
	// Position of SOFTSREQ3 field.
	GPDMA_SOFTSREQ_SOFTSREQ3_Pos = 0x3
	// Bit mask of SOFTSREQ3 field.
	GPDMA_SOFTSREQ_SOFTSREQ3_Msk = 0x8
	// Bit SOFTSREQ3.
	GPDMA_SOFTSREQ_SOFTSREQ3 = 0x8
	// Position of SOFTSREQ4 field.
	GPDMA_SOFTSREQ_SOFTSREQ4_Pos = 0x4
	// Bit mask of SOFTSREQ4 field.
	GPDMA_SOFTSREQ_SOFTSREQ4_Msk = 0x10
	// Bit SOFTSREQ4.
	GPDMA_SOFTSREQ_SOFTSREQ4 = 0x10
	// Position of SOFTSREQ5 field.
	GPDMA_SOFTSREQ_SOFTSREQ5_Pos = 0x5
	// Bit mask of SOFTSREQ5 field.
	GPDMA_SOFTSREQ_SOFTSREQ5_Msk = 0x20
	// Bit SOFTSREQ5.
	GPDMA_SOFTSREQ_SOFTSREQ5 = 0x20
	// Position of SOFTSREQ6 field.
	GPDMA_SOFTSREQ_SOFTSREQ6_Pos = 0x6
	// Bit mask of SOFTSREQ6 field.
	GPDMA_SOFTSREQ_SOFTSREQ6_Msk = 0x40
	// Bit SOFTSREQ6.
	GPDMA_SOFTSREQ_SOFTSREQ6 = 0x40
	// Position of SOFTSREQ7 field.
	GPDMA_SOFTSREQ_SOFTSREQ7_Pos = 0x7
	// Bit mask of SOFTSREQ7 field.
	GPDMA_SOFTSREQ_SOFTSREQ7_Msk = 0x80
	// Bit SOFTSREQ7.
	GPDMA_SOFTSREQ_SOFTSREQ7 = 0x80
	// Position of SOFTSREQ8 field.
	GPDMA_SOFTSREQ_SOFTSREQ8_Pos = 0x8
	// Bit mask of SOFTSREQ8 field.
	GPDMA_SOFTSREQ_SOFTSREQ8_Msk = 0x100
	// Bit SOFTSREQ8.
	GPDMA_SOFTSREQ_SOFTSREQ8 = 0x100
	// Position of SOFTSREQ9 field.
	GPDMA_SOFTSREQ_SOFTSREQ9_Pos = 0x9
	// Bit mask of SOFTSREQ9 field.
	GPDMA_SOFTSREQ_SOFTSREQ9_Msk = 0x200
	// Bit SOFTSREQ9.
	GPDMA_SOFTSREQ_SOFTSREQ9 = 0x200
	// Position of SOFTSREQ10 field.
	GPDMA_SOFTSREQ_SOFTSREQ10_Pos = 0xa
	// Bit mask of SOFTSREQ10 field.
	GPDMA_SOFTSREQ_SOFTSREQ10_Msk = 0x400
	// Bit SOFTSREQ10.
	GPDMA_SOFTSREQ_SOFTSREQ10 = 0x400
	// Position of SOFTSREQ11 field.
	GPDMA_SOFTSREQ_SOFTSREQ11_Pos = 0xb
	// Bit mask of SOFTSREQ11 field.
	GPDMA_SOFTSREQ_SOFTSREQ11_Msk = 0x800
	// Bit SOFTSREQ11.
	GPDMA_SOFTSREQ_SOFTSREQ11 = 0x800
	// Position of SOFTSREQ12 field.
	GPDMA_SOFTSREQ_SOFTSREQ12_Pos = 0xc
	// Bit mask of SOFTSREQ12 field.
	GPDMA_SOFTSREQ_SOFTSREQ12_Msk = 0x1000
	// Bit SOFTSREQ12.
	GPDMA_SOFTSREQ_SOFTSREQ12 = 0x1000
	// Position of SOFTSREQ13 field.
	GPDMA_SOFTSREQ_SOFTSREQ13_Pos = 0xd
	// Bit mask of SOFTSREQ13 field.
	GPDMA_SOFTSREQ_SOFTSREQ13_Msk = 0x2000
	// Bit SOFTSREQ13.
	GPDMA_SOFTSREQ_SOFTSREQ13 = 0x2000
	// Position of SOFTSREQ14 field.
	GPDMA_SOFTSREQ_SOFTSREQ14_Pos = 0xe
	// Bit mask of SOFTSREQ14 field.
	GPDMA_SOFTSREQ_SOFTSREQ14_Msk = 0x4000
	// Bit SOFTSREQ14.
	GPDMA_SOFTSREQ_SOFTSREQ14 = 0x4000
	// Position of SOFTSREQ15 field.
	GPDMA_SOFTSREQ_SOFTSREQ15_Pos = 0xf
	// Bit mask of SOFTSREQ15 field.
	GPDMA_SOFTSREQ_SOFTSREQ15_Msk = 0x8000
	// Bit SOFTSREQ15.
	GPDMA_SOFTSREQ_SOFTSREQ15 = 0x8000
	// Position of RESERVED field.
	GPDMA_SOFTSREQ_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	GPDMA_SOFTSREQ_RESERVED_Msk = 0xffff0000

	// SOFTLBREQ: DMA Software Last Burst Request Register
	// Position of SOFTLBREQ0 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ0_Pos = 0x0
	// Bit mask of SOFTLBREQ0 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ0_Msk = 0x1
	// Bit SOFTLBREQ0.
	GPDMA_SOFTLBREQ_SOFTLBREQ0 = 0x1
	// Position of SOFTLBREQ1 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ1_Pos = 0x1
	// Bit mask of SOFTLBREQ1 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ1_Msk = 0x2
	// Bit SOFTLBREQ1.
	GPDMA_SOFTLBREQ_SOFTLBREQ1 = 0x2
	// Position of SOFTLBREQ2 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ2_Pos = 0x2
	// Bit mask of SOFTLBREQ2 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ2_Msk = 0x4
	// Bit SOFTLBREQ2.
	GPDMA_SOFTLBREQ_SOFTLBREQ2 = 0x4
	// Position of SOFTLBREQ3 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ3_Pos = 0x3
	// Bit mask of SOFTLBREQ3 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ3_Msk = 0x8
	// Bit SOFTLBREQ3.
	GPDMA_SOFTLBREQ_SOFTLBREQ3 = 0x8
	// Position of SOFTLBREQ4 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ4_Pos = 0x4
	// Bit mask of SOFTLBREQ4 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ4_Msk = 0x10
	// Bit SOFTLBREQ4.
	GPDMA_SOFTLBREQ_SOFTLBREQ4 = 0x10
	// Position of SOFTLBREQ5 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ5_Pos = 0x5
	// Bit mask of SOFTLBREQ5 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ5_Msk = 0x20
	// Bit SOFTLBREQ5.
	GPDMA_SOFTLBREQ_SOFTLBREQ5 = 0x20
	// Position of SOFTLBREQ6 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ6_Pos = 0x6
	// Bit mask of SOFTLBREQ6 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ6_Msk = 0x40
	// Bit SOFTLBREQ6.
	GPDMA_SOFTLBREQ_SOFTLBREQ6 = 0x40
	// Position of SOFTLBREQ7 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ7_Pos = 0x7
	// Bit mask of SOFTLBREQ7 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ7_Msk = 0x80
	// Bit SOFTLBREQ7.
	GPDMA_SOFTLBREQ_SOFTLBREQ7 = 0x80
	// Position of SOFTLBREQ8 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ8_Pos = 0x8
	// Bit mask of SOFTLBREQ8 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ8_Msk = 0x100
	// Bit SOFTLBREQ8.
	GPDMA_SOFTLBREQ_SOFTLBREQ8 = 0x100
	// Position of SOFTLBREQ9 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ9_Pos = 0x9
	// Bit mask of SOFTLBREQ9 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ9_Msk = 0x200
	// Bit SOFTLBREQ9.
	GPDMA_SOFTLBREQ_SOFTLBREQ9 = 0x200
	// Position of SOFTLBREQ10 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ10_Pos = 0xa
	// Bit mask of SOFTLBREQ10 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ10_Msk = 0x400
	// Bit SOFTLBREQ10.
	GPDMA_SOFTLBREQ_SOFTLBREQ10 = 0x400
	// Position of SOFTLBREQ11 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ11_Pos = 0xb
	// Bit mask of SOFTLBREQ11 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ11_Msk = 0x800
	// Bit SOFTLBREQ11.
	GPDMA_SOFTLBREQ_SOFTLBREQ11 = 0x800
	// Position of SOFTLBREQ12 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ12_Pos = 0xc
	// Bit mask of SOFTLBREQ12 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ12_Msk = 0x1000
	// Bit SOFTLBREQ12.
	GPDMA_SOFTLBREQ_SOFTLBREQ12 = 0x1000
	// Position of SOFTLBREQ13 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ13_Pos = 0xd
	// Bit mask of SOFTLBREQ13 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ13_Msk = 0x2000
	// Bit SOFTLBREQ13.
	GPDMA_SOFTLBREQ_SOFTLBREQ13 = 0x2000
	// Position of SOFTLBREQ14 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ14_Pos = 0xe
	// Bit mask of SOFTLBREQ14 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ14_Msk = 0x4000
	// Bit SOFTLBREQ14.
	GPDMA_SOFTLBREQ_SOFTLBREQ14 = 0x4000
	// Position of SOFTLBREQ15 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ15_Pos = 0xf
	// Bit mask of SOFTLBREQ15 field.
	GPDMA_SOFTLBREQ_SOFTLBREQ15_Msk = 0x8000
	// Bit SOFTLBREQ15.
	GPDMA_SOFTLBREQ_SOFTLBREQ15 = 0x8000
	// Position of RESERVED field.
	GPDMA_SOFTLBREQ_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	GPDMA_SOFTLBREQ_RESERVED_Msk = 0xffff0000

	// SOFTLSREQ: DMA Software Last Single Request Register
	// Position of SOFTLSREQ0 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ0_Pos = 0x0
	// Bit mask of SOFTLSREQ0 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ0_Msk = 0x1
	// Bit SOFTLSREQ0.
	GPDMA_SOFTLSREQ_SOFTLSREQ0 = 0x1
	// Position of SOFTLSREQ1 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ1_Pos = 0x1
	// Bit mask of SOFTLSREQ1 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ1_Msk = 0x2
	// Bit SOFTLSREQ1.
	GPDMA_SOFTLSREQ_SOFTLSREQ1 = 0x2
	// Position of SOFTLSREQ2 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ2_Pos = 0x2
	// Bit mask of SOFTLSREQ2 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ2_Msk = 0x4
	// Bit SOFTLSREQ2.
	GPDMA_SOFTLSREQ_SOFTLSREQ2 = 0x4
	// Position of SOFTLSREQ3 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ3_Pos = 0x3
	// Bit mask of SOFTLSREQ3 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ3_Msk = 0x8
	// Bit SOFTLSREQ3.
	GPDMA_SOFTLSREQ_SOFTLSREQ3 = 0x8
	// Position of SOFTLSREQ4 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ4_Pos = 0x4
	// Bit mask of SOFTLSREQ4 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ4_Msk = 0x10
	// Bit SOFTLSREQ4.
	GPDMA_SOFTLSREQ_SOFTLSREQ4 = 0x10
	// Position of SOFTLSREQ5 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ5_Pos = 0x5
	// Bit mask of SOFTLSREQ5 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ5_Msk = 0x20
	// Bit SOFTLSREQ5.
	GPDMA_SOFTLSREQ_SOFTLSREQ5 = 0x20
	// Position of SOFTLSREQ6 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ6_Pos = 0x6
	// Bit mask of SOFTLSREQ6 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ6_Msk = 0x40
	// Bit SOFTLSREQ6.
	GPDMA_SOFTLSREQ_SOFTLSREQ6 = 0x40
	// Position of SOFTLSREQ7 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ7_Pos = 0x7
	// Bit mask of SOFTLSREQ7 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ7_Msk = 0x80
	// Bit SOFTLSREQ7.
	GPDMA_SOFTLSREQ_SOFTLSREQ7 = 0x80
	// Position of SOFTLSREQ8 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ8_Pos = 0x8
	// Bit mask of SOFTLSREQ8 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ8_Msk = 0x100
	// Bit SOFTLSREQ8.
	GPDMA_SOFTLSREQ_SOFTLSREQ8 = 0x100
	// Position of SOFTLSREQ9 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ9_Pos = 0x9
	// Bit mask of SOFTLSREQ9 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ9_Msk = 0x200
	// Bit SOFTLSREQ9.
	GPDMA_SOFTLSREQ_SOFTLSREQ9 = 0x200
	// Position of SOFTLSREQ10 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ10_Pos = 0xa
	// Bit mask of SOFTLSREQ10 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ10_Msk = 0x400
	// Bit SOFTLSREQ10.
	GPDMA_SOFTLSREQ_SOFTLSREQ10 = 0x400
	// Position of SOFTLSREQ11 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ11_Pos = 0xb
	// Bit mask of SOFTLSREQ11 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ11_Msk = 0x800
	// Bit SOFTLSREQ11.
	GPDMA_SOFTLSREQ_SOFTLSREQ11 = 0x800
	// Position of SOFTLSREQ12 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ12_Pos = 0xc
	// Bit mask of SOFTLSREQ12 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ12_Msk = 0x1000
	// Bit SOFTLSREQ12.
	GPDMA_SOFTLSREQ_SOFTLSREQ12 = 0x1000
	// Position of SOFTLSREQ13 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ13_Pos = 0xd
	// Bit mask of SOFTLSREQ13 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ13_Msk = 0x2000
	// Bit SOFTLSREQ13.
	GPDMA_SOFTLSREQ_SOFTLSREQ13 = 0x2000
	// Position of SOFTLSREQ14 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ14_Pos = 0xe
	// Bit mask of SOFTLSREQ14 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ14_Msk = 0x4000
	// Bit SOFTLSREQ14.
	GPDMA_SOFTLSREQ_SOFTLSREQ14 = 0x4000
	// Position of SOFTLSREQ15 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ15_Pos = 0xf
	// Bit mask of SOFTLSREQ15 field.
	GPDMA_SOFTLSREQ_SOFTLSREQ15_Msk = 0x8000
	// Bit SOFTLSREQ15.
	GPDMA_SOFTLSREQ_SOFTLSREQ15 = 0x8000
	// Position of RESERVED field.
	GPDMA_SOFTLSREQ_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	GPDMA_SOFTLSREQ_RESERVED_Msk = 0xffff0000

	// CONFIG: DMA Configuration Register
	// Position of E field.
	GPDMA_CONFIG_E_Pos = 0x0
	// Bit mask of E field.
	GPDMA_CONFIG_E_Msk = 0x1
	// Bit E.
	GPDMA_CONFIG_E = 0x1
	// Position of M field.
	GPDMA_CONFIG_M_Pos = 0x1
	// Bit mask of M field.
	GPDMA_CONFIG_M_Msk = 0x2
	// Bit M.
	GPDMA_CONFIG_M = 0x2
	// Position of RESERVED field.
	GPDMA_CONFIG_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	GPDMA_CONFIG_RESERVED_Msk = 0xfffffffc

	// SYNC: DMA Synchronization Register
	// Position of DMACSYNC0 field.
	GPDMA_SYNC_DMACSYNC0_Pos = 0x0
	// Bit mask of DMACSYNC0 field.
	GPDMA_SYNC_DMACSYNC0_Msk = 0x1
	// Bit DMACSYNC0.
	GPDMA_SYNC_DMACSYNC0 = 0x1
	// Position of DMACSYNC1 field.
	GPDMA_SYNC_DMACSYNC1_Pos = 0x1
	// Bit mask of DMACSYNC1 field.
	GPDMA_SYNC_DMACSYNC1_Msk = 0x2
	// Bit DMACSYNC1.
	GPDMA_SYNC_DMACSYNC1 = 0x2
	// Position of DMACSYNC2 field.
	GPDMA_SYNC_DMACSYNC2_Pos = 0x2
	// Bit mask of DMACSYNC2 field.
	GPDMA_SYNC_DMACSYNC2_Msk = 0x4
	// Bit DMACSYNC2.
	GPDMA_SYNC_DMACSYNC2 = 0x4
	// Position of DMACSYNC3 field.
	GPDMA_SYNC_DMACSYNC3_Pos = 0x3
	// Bit mask of DMACSYNC3 field.
	GPDMA_SYNC_DMACSYNC3_Msk = 0x8
	// Bit DMACSYNC3.
	GPDMA_SYNC_DMACSYNC3 = 0x8
	// Position of DMACSYNC4 field.
	GPDMA_SYNC_DMACSYNC4_Pos = 0x4
	// Bit mask of DMACSYNC4 field.
	GPDMA_SYNC_DMACSYNC4_Msk = 0x10
	// Bit DMACSYNC4.
	GPDMA_SYNC_DMACSYNC4 = 0x10
	// Position of DMACSYNC5 field.
	GPDMA_SYNC_DMACSYNC5_Pos = 0x5
	// Bit mask of DMACSYNC5 field.
	GPDMA_SYNC_DMACSYNC5_Msk = 0x20
	// Bit DMACSYNC5.
	GPDMA_SYNC_DMACSYNC5 = 0x20
	// Position of DMACSYNC6 field.
	GPDMA_SYNC_DMACSYNC6_Pos = 0x6
	// Bit mask of DMACSYNC6 field.
	GPDMA_SYNC_DMACSYNC6_Msk = 0x40
	// Bit DMACSYNC6.
	GPDMA_SYNC_DMACSYNC6 = 0x40
	// Position of DMACSYNC7 field.
	GPDMA_SYNC_DMACSYNC7_Pos = 0x7
	// Bit mask of DMACSYNC7 field.
	GPDMA_SYNC_DMACSYNC7_Msk = 0x80
	// Bit DMACSYNC7.
	GPDMA_SYNC_DMACSYNC7 = 0x80
	// Position of DMACSYNC8 field.
	GPDMA_SYNC_DMACSYNC8_Pos = 0x8
	// Bit mask of DMACSYNC8 field.
	GPDMA_SYNC_DMACSYNC8_Msk = 0x100
	// Bit DMACSYNC8.
	GPDMA_SYNC_DMACSYNC8 = 0x100
	// Position of DMACSYNC9 field.
	GPDMA_SYNC_DMACSYNC9_Pos = 0x9
	// Bit mask of DMACSYNC9 field.
	GPDMA_SYNC_DMACSYNC9_Msk = 0x200
	// Bit DMACSYNC9.
	GPDMA_SYNC_DMACSYNC9 = 0x200
	// Position of DMACSYNC10 field.
	GPDMA_SYNC_DMACSYNC10_Pos = 0xa
	// Bit mask of DMACSYNC10 field.
	GPDMA_SYNC_DMACSYNC10_Msk = 0x400
	// Bit DMACSYNC10.
	GPDMA_SYNC_DMACSYNC10 = 0x400
	// Position of DMACSYNC11 field.
	GPDMA_SYNC_DMACSYNC11_Pos = 0xb
	// Bit mask of DMACSYNC11 field.
	GPDMA_SYNC_DMACSYNC11_Msk = 0x800
	// Bit DMACSYNC11.
	GPDMA_SYNC_DMACSYNC11 = 0x800
	// Position of DMACSYNC12 field.
	GPDMA_SYNC_DMACSYNC12_Pos = 0xc
	// Bit mask of DMACSYNC12 field.
	GPDMA_SYNC_DMACSYNC12_Msk = 0x1000
	// Bit DMACSYNC12.
	GPDMA_SYNC_DMACSYNC12 = 0x1000
	// Position of DMACSYNC13 field.
	GPDMA_SYNC_DMACSYNC13_Pos = 0xd
	// Bit mask of DMACSYNC13 field.
	GPDMA_SYNC_DMACSYNC13_Msk = 0x2000
	// Bit DMACSYNC13.
	GPDMA_SYNC_DMACSYNC13 = 0x2000
	// Position of DMACSYNC14 field.
	GPDMA_SYNC_DMACSYNC14_Pos = 0xe
	// Bit mask of DMACSYNC14 field.
	GPDMA_SYNC_DMACSYNC14_Msk = 0x4000
	// Bit DMACSYNC14.
	GPDMA_SYNC_DMACSYNC14 = 0x4000
	// Position of DMACSYNC15 field.
	GPDMA_SYNC_DMACSYNC15_Pos = 0xf
	// Bit mask of DMACSYNC15 field.
	GPDMA_SYNC_DMACSYNC15_Msk = 0x8000
	// Bit DMACSYNC15.
	GPDMA_SYNC_DMACSYNC15 = 0x8000
	// Position of RESERVED field.
	GPDMA_SYNC_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	GPDMA_SYNC_RESERVED_Msk = 0xffff0000

	// SRCADDR0: DMA Channel 0 Source Address Register
	// Position of SRCADDR field.
	GPDMA_SRCADDR_SRCADDR_Pos = 0x0
	// Bit mask of SRCADDR field.
	GPDMA_SRCADDR_SRCADDR_Msk = 0xffffffff

	// DESTADDR0: DMA Channel 0 Destination Address Register
	// Position of DESTADDR field.
	GPDMA_DESTADDR_DESTADDR_Pos = 0x0
	// Bit mask of DESTADDR field.
	GPDMA_DESTADDR_DESTADDR_Msk = 0xffffffff

	// LLI0: DMA Channel 0 Linked List Item Register
	// Position of RESERVED field.
	GPDMA_LLI_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	GPDMA_LLI_RESERVED_Msk = 0x3
	// Position of LLI field.
	GPDMA_LLI_LLI_Pos = 0x2
	// Bit mask of LLI field.
	GPDMA_LLI_LLI_Msk = 0xfffffffc

	// CONTROL0: DMA Channel 0 Control Register
	// Position of TRANSFERSIZE field.
	GPDMA_CONTROL_TRANSFERSIZE_Pos = 0x0
	// Bit mask of TRANSFERSIZE field.
	GPDMA_CONTROL_TRANSFERSIZE_Msk = 0xfff
	// Position of SBSIZE field.
	GPDMA_CONTROL_SBSIZE_Pos = 0xc
	// Bit mask of SBSIZE field.
	GPDMA_CONTROL_SBSIZE_Msk = 0x7000
	// Position of DBSIZE field.
	GPDMA_CONTROL_DBSIZE_Pos = 0xf
	// Bit mask of DBSIZE field.
	GPDMA_CONTROL_DBSIZE_Msk = 0x38000
	// Position of SWIDTH field.
	GPDMA_CONTROL_SWIDTH_Pos = 0x12
	// Bit mask of SWIDTH field.
	GPDMA_CONTROL_SWIDTH_Msk = 0x1c0000
	// Position of DWIDTH field.
	GPDMA_CONTROL_DWIDTH_Pos = 0x15
	// Bit mask of DWIDTH field.
	GPDMA_CONTROL_DWIDTH_Msk = 0xe00000
	// Position of RESERVED field.
	GPDMA_CONTROL_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	GPDMA_CONTROL_RESERVED_Msk = 0x3000000
	// Position of SI field.
	GPDMA_CONTROL_SI_Pos = 0x1a
	// Bit mask of SI field.
	GPDMA_CONTROL_SI_Msk = 0x4000000
	// Bit SI.
	GPDMA_CONTROL_SI = 0x4000000
	// Position of DI field.
	GPDMA_CONTROL_DI_Pos = 0x1b
	// Bit mask of DI field.
	GPDMA_CONTROL_DI_Msk = 0x8000000
	// Bit DI.
	GPDMA_CONTROL_DI = 0x8000000
	// Position of PROT1 field.
	GPDMA_CONTROL_PROT1_Pos = 0x1c
	// Bit mask of PROT1 field.
	GPDMA_CONTROL_PROT1_Msk = 0x10000000
	// Bit PROT1.
	GPDMA_CONTROL_PROT1 = 0x10000000
	// Position of PROT2 field.
	GPDMA_CONTROL_PROT2_Pos = 0x1d
	// Bit mask of PROT2 field.
	GPDMA_CONTROL_PROT2_Msk = 0x20000000
	// Bit PROT2.
	GPDMA_CONTROL_PROT2 = 0x20000000
	// Position of PROT3 field.
	GPDMA_CONTROL_PROT3_Pos = 0x1e
	// Bit mask of PROT3 field.
	GPDMA_CONTROL_PROT3_Msk = 0x40000000
	// Bit PROT3.
	GPDMA_CONTROL_PROT3 = 0x40000000
	// Position of I field.
	GPDMA_CONTROL_I_Pos = 0x1f
	// Bit mask of I field.
	GPDMA_CONTROL_I_Msk = 0x80000000
	// Bit I.
	GPDMA_CONTROL_I = 0x80000000

	// CONFIG0: DMA Channel 0 Configuration Register[1]
	// Position of E field.
	GPDMA_CONFIG_E_Pos = 0x0
	// Bit mask of E field.
	GPDMA_CONFIG_E_Msk = 0x1
	// Bit E.
	GPDMA_CONFIG_E = 0x1
	// Position of SRCPERIPHERAL field.
	GPDMA_CONFIG_SRCPERIPHERAL_Pos = 0x1
	// Bit mask of SRCPERIPHERAL field.
	GPDMA_CONFIG_SRCPERIPHERAL_Msk = 0x3e
	// Position of DESTPERIPHERAL field.
	GPDMA_CONFIG_DESTPERIPHERAL_Pos = 0x6
	// Bit mask of DESTPERIPHERAL field.
	GPDMA_CONFIG_DESTPERIPHERAL_Msk = 0x7c0
	// Position of TRANSFERTYPE field.
	GPDMA_CONFIG_TRANSFERTYPE_Pos = 0xb
	// Bit mask of TRANSFERTYPE field.
	GPDMA_CONFIG_TRANSFERTYPE_Msk = 0x3800
	// Position of IE field.
	GPDMA_CONFIG_IE_Pos = 0xe
	// Bit mask of IE field.
	GPDMA_CONFIG_IE_Msk = 0x4000
	// Bit IE.
	GPDMA_CONFIG_IE = 0x4000
	// Position of ITC field.
	GPDMA_CONFIG_ITC_Pos = 0xf
	// Bit mask of ITC field.
	GPDMA_CONFIG_ITC_Msk = 0x8000
	// Bit ITC.
	GPDMA_CONFIG_ITC = 0x8000
	// Position of L field.
	GPDMA_CONFIG_L_Pos = 0x10
	// Bit mask of L field.
	GPDMA_CONFIG_L_Msk = 0x10000
	// Bit L.
	GPDMA_CONFIG_L = 0x10000
	// Position of A field.
	GPDMA_CONFIG_A_Pos = 0x11
	// Bit mask of A field.
	GPDMA_CONFIG_A_Msk = 0x20000
	// Bit A.
	GPDMA_CONFIG_A = 0x20000
	// Position of H field.
	GPDMA_CONFIG_H_Pos = 0x12
	// Bit mask of H field.
	GPDMA_CONFIG_H_Msk = 0x40000
	// Bit H.
	GPDMA_CONFIG_H = 0x40000
	// Position of RESERVED field.
	GPDMA_CONFIG_RESERVED_Pos = 0x13
	// Bit mask of RESERVED field.
	GPDMA_CONFIG_RESERVED_Msk = 0xfff80000
)

// Constants for ETHERNET: Ethernet
const (
	// MAC1: MAC configuration register 1.
	// Position of RXENABLE field.
	ETHERNET_MAC1_RXENABLE_Pos = 0x0
	// Bit mask of RXENABLE field.
	ETHERNET_MAC1_RXENABLE_Msk = 0x1
	// Bit RXENABLE.
	ETHERNET_MAC1_RXENABLE = 0x1
	// Position of PARF field.
	ETHERNET_MAC1_PARF_Pos = 0x1
	// Bit mask of PARF field.
	ETHERNET_MAC1_PARF_Msk = 0x2
	// Bit PARF.
	ETHERNET_MAC1_PARF = 0x2
	// Position of RXFLOWCTRL field.
	ETHERNET_MAC1_RXFLOWCTRL_Pos = 0x2
	// Bit mask of RXFLOWCTRL field.
	ETHERNET_MAC1_RXFLOWCTRL_Msk = 0x4
	// Bit RXFLOWCTRL.
	ETHERNET_MAC1_RXFLOWCTRL = 0x4
	// Position of TXFLOWCTRL field.
	ETHERNET_MAC1_TXFLOWCTRL_Pos = 0x3
	// Bit mask of TXFLOWCTRL field.
	ETHERNET_MAC1_TXFLOWCTRL_Msk = 0x8
	// Bit TXFLOWCTRL.
	ETHERNET_MAC1_TXFLOWCTRL = 0x8
	// Position of LOOPBACK field.
	ETHERNET_MAC1_LOOPBACK_Pos = 0x4
	// Bit mask of LOOPBACK field.
	ETHERNET_MAC1_LOOPBACK_Msk = 0x10
	// Bit LOOPBACK.
	ETHERNET_MAC1_LOOPBACK = 0x10
	// Position of RESERVED field.
	ETHERNET_MAC1_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	ETHERNET_MAC1_RESERVED_Msk = 0xe0
	// Position of RESETTX field.
	ETHERNET_MAC1_RESETTX_Pos = 0x8
	// Bit mask of RESETTX field.
	ETHERNET_MAC1_RESETTX_Msk = 0x100
	// Bit RESETTX.
	ETHERNET_MAC1_RESETTX = 0x100
	// Position of RESETMCSTX field.
	ETHERNET_MAC1_RESETMCSTX_Pos = 0x9
	// Bit mask of RESETMCSTX field.
	ETHERNET_MAC1_RESETMCSTX_Msk = 0x200
	// Bit RESETMCSTX.
	ETHERNET_MAC1_RESETMCSTX = 0x200
	// Position of RESETRX field.
	ETHERNET_MAC1_RESETRX_Pos = 0xa
	// Bit mask of RESETRX field.
	ETHERNET_MAC1_RESETRX_Msk = 0x400
	// Bit RESETRX.
	ETHERNET_MAC1_RESETRX = 0x400
	// Position of RESETMCSRX field.
	ETHERNET_MAC1_RESETMCSRX_Pos = 0xb
	// Bit mask of RESETMCSRX field.
	ETHERNET_MAC1_RESETMCSRX_Msk = 0x800
	// Bit RESETMCSRX.
	ETHERNET_MAC1_RESETMCSRX = 0x800
	// Position of RESERVED field.
	ETHERNET_MAC1_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	ETHERNET_MAC1_RESERVED_Msk = 0x3000
	// Position of SIMRESET field.
	ETHERNET_MAC1_SIMRESET_Pos = 0xe
	// Bit mask of SIMRESET field.
	ETHERNET_MAC1_SIMRESET_Msk = 0x4000
	// Bit SIMRESET.
	ETHERNET_MAC1_SIMRESET = 0x4000
	// Position of SOFTRESET field.
	ETHERNET_MAC1_SOFTRESET_Pos = 0xf
	// Bit mask of SOFTRESET field.
	ETHERNET_MAC1_SOFTRESET_Msk = 0x8000
	// Bit SOFTRESET.
	ETHERNET_MAC1_SOFTRESET = 0x8000
	// Position of RESERVED field.
	ETHERNET_MAC1_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	ETHERNET_MAC1_RESERVED_Msk = 0xffff0000

	// MAC2: MAC configuration register 2.
	// Position of FULLDUPLEX field.
	ETHERNET_MAC2_FULLDUPLEX_Pos = 0x0
	// Bit mask of FULLDUPLEX field.
	ETHERNET_MAC2_FULLDUPLEX_Msk = 0x1
	// Bit FULLDUPLEX.
	ETHERNET_MAC2_FULLDUPLEX = 0x1
	// Position of FLC field.
	ETHERNET_MAC2_FLC_Pos = 0x1
	// Bit mask of FLC field.
	ETHERNET_MAC2_FLC_Msk = 0x2
	// Bit FLC.
	ETHERNET_MAC2_FLC = 0x2
	// Position of HFEN field.
	ETHERNET_MAC2_HFEN_Pos = 0x2
	// Bit mask of HFEN field.
	ETHERNET_MAC2_HFEN_Msk = 0x4
	// Bit HFEN.
	ETHERNET_MAC2_HFEN = 0x4
	// Position of DELAYEDCRC field.
	ETHERNET_MAC2_DELAYEDCRC_Pos = 0x3
	// Bit mask of DELAYEDCRC field.
	ETHERNET_MAC2_DELAYEDCRC_Msk = 0x8
	// Bit DELAYEDCRC.
	ETHERNET_MAC2_DELAYEDCRC = 0x8
	// Position of CRCEN field.
	ETHERNET_MAC2_CRCEN_Pos = 0x4
	// Bit mask of CRCEN field.
	ETHERNET_MAC2_CRCEN_Msk = 0x10
	// Bit CRCEN.
	ETHERNET_MAC2_CRCEN = 0x10
	// Position of PADCRCEN field.
	ETHERNET_MAC2_PADCRCEN_Pos = 0x5
	// Bit mask of PADCRCEN field.
	ETHERNET_MAC2_PADCRCEN_Msk = 0x20
	// Bit PADCRCEN.
	ETHERNET_MAC2_PADCRCEN = 0x20
	// Position of VLANPADEN field.
	ETHERNET_MAC2_VLANPADEN_Pos = 0x6
	// Bit mask of VLANPADEN field.
	ETHERNET_MAC2_VLANPADEN_Msk = 0x40
	// Bit VLANPADEN.
	ETHERNET_MAC2_VLANPADEN = 0x40
	// Position of AUTODETPADEN field.
	ETHERNET_MAC2_AUTODETPADEN_Pos = 0x7
	// Bit mask of AUTODETPADEN field.
	ETHERNET_MAC2_AUTODETPADEN_Msk = 0x80
	// Bit AUTODETPADEN.
	ETHERNET_MAC2_AUTODETPADEN = 0x80
	// Position of PPENF field.
	ETHERNET_MAC2_PPENF_Pos = 0x8
	// Bit mask of PPENF field.
	ETHERNET_MAC2_PPENF_Msk = 0x100
	// Bit PPENF.
	ETHERNET_MAC2_PPENF = 0x100
	// Position of LPENF field.
	ETHERNET_MAC2_LPENF_Pos = 0x9
	// Bit mask of LPENF field.
	ETHERNET_MAC2_LPENF_Msk = 0x200
	// Bit LPENF.
	ETHERNET_MAC2_LPENF = 0x200
	// Position of RESERVED field.
	ETHERNET_MAC2_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	ETHERNET_MAC2_RESERVED_Msk = 0xc00
	// Position of NOBACKOFF field.
	ETHERNET_MAC2_NOBACKOFF_Pos = 0xc
	// Bit mask of NOBACKOFF field.
	ETHERNET_MAC2_NOBACKOFF_Msk = 0x1000
	// Bit NOBACKOFF.
	ETHERNET_MAC2_NOBACKOFF = 0x1000
	// Position of BP_NOBACKOFF field.
	ETHERNET_MAC2_BP_NOBACKOFF_Pos = 0xd
	// Bit mask of BP_NOBACKOFF field.
	ETHERNET_MAC2_BP_NOBACKOFF_Msk = 0x2000
	// Bit BP_NOBACKOFF.
	ETHERNET_MAC2_BP_NOBACKOFF = 0x2000
	// Position of EXCESSDEFER field.
	ETHERNET_MAC2_EXCESSDEFER_Pos = 0xe
	// Bit mask of EXCESSDEFER field.
	ETHERNET_MAC2_EXCESSDEFER_Msk = 0x4000
	// Bit EXCESSDEFER.
	ETHERNET_MAC2_EXCESSDEFER = 0x4000
	// Position of RESERVED field.
	ETHERNET_MAC2_RESERVED_Pos = 0xf
	// Bit mask of RESERVED field.
	ETHERNET_MAC2_RESERVED_Msk = 0xffff8000

	// IPGT: Back-to-Back Inter-Packet-Gap register.
	// Position of BTOBINTEGAP field.
	ETHERNET_IPGT_BTOBINTEGAP_Pos = 0x0
	// Bit mask of BTOBINTEGAP field.
	ETHERNET_IPGT_BTOBINTEGAP_Msk = 0x7f
	// Position of RESERVED field.
	ETHERNET_IPGT_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	ETHERNET_IPGT_RESERVED_Msk = 0xffffff80

	// IPGR: Non Back-to-Back Inter-Packet-Gap register.
	// Position of NBTOBINTEGAP2 field.
	ETHERNET_IPGR_NBTOBINTEGAP2_Pos = 0x0
	// Bit mask of NBTOBINTEGAP2 field.
	ETHERNET_IPGR_NBTOBINTEGAP2_Msk = 0x7f
	// Position of RESERVED field.
	ETHERNET_IPGR_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	ETHERNET_IPGR_RESERVED_Msk = 0x80
	// Bit RESERVED.
	ETHERNET_IPGR_RESERVED = 0x80
	// Position of NBTOBINTEGAP1 field.
	ETHERNET_IPGR_NBTOBINTEGAP1_Pos = 0x8
	// Bit mask of NBTOBINTEGAP1 field.
	ETHERNET_IPGR_NBTOBINTEGAP1_Msk = 0x7f00
	// Position of RESERVED field.
	ETHERNET_IPGR_RESERVED_Pos = 0xf
	// Bit mask of RESERVED field.
	ETHERNET_IPGR_RESERVED_Msk = 0xffff8000

	// CLRT: Collision window / Retry register.
	// Position of RETRANSMAX field.
	ETHERNET_CLRT_RETRANSMAX_Pos = 0x0
	// Bit mask of RETRANSMAX field.
	ETHERNET_CLRT_RETRANSMAX_Msk = 0xf
	// Position of RESERVED field.
	ETHERNET_CLRT_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	ETHERNET_CLRT_RESERVED_Msk = 0xf0
	// Position of COLLWIN field.
	ETHERNET_CLRT_COLLWIN_Pos = 0x8
	// Bit mask of COLLWIN field.
	ETHERNET_CLRT_COLLWIN_Msk = 0x3f00
	// Position of RESERVED field.
	ETHERNET_CLRT_RESERVED_Pos = 0xe
	// Bit mask of RESERVED field.
	ETHERNET_CLRT_RESERVED_Msk = 0xffffc000

	// MAXF: Maximum Frame register.
	// Position of MAXFLEN field.
	ETHERNET_MAXF_MAXFLEN_Pos = 0x0
	// Bit mask of MAXFLEN field.
	ETHERNET_MAXF_MAXFLEN_Msk = 0xffff
	// Position of RESERVED field.
	ETHERNET_MAXF_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	ETHERNET_MAXF_RESERVED_Msk = 0xffff0000

	// SUPP: PHY Support register.
	// Position of RESERVED field.
	ETHERNET_SUPP_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	ETHERNET_SUPP_RESERVED_Msk = 0xff
	// Position of SPEED field.
	ETHERNET_SUPP_SPEED_Pos = 0x8
	// Bit mask of SPEED field.
	ETHERNET_SUPP_SPEED_Msk = 0x100
	// Bit SPEED.
	ETHERNET_SUPP_SPEED = 0x100
	// Position of RESERVED field.
	ETHERNET_SUPP_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	ETHERNET_SUPP_RESERVED_Msk = 0xfffffe00

	// TEST: Test register.
	// Position of SCPQ field.
	ETHERNET_TEST_SCPQ_Pos = 0x0
	// Bit mask of SCPQ field.
	ETHERNET_TEST_SCPQ_Msk = 0x1
	// Bit SCPQ.
	ETHERNET_TEST_SCPQ = 0x1
	// Position of TESTPAUSE field.
	ETHERNET_TEST_TESTPAUSE_Pos = 0x1
	// Bit mask of TESTPAUSE field.
	ETHERNET_TEST_TESTPAUSE_Msk = 0x2
	// Bit TESTPAUSE.
	ETHERNET_TEST_TESTPAUSE = 0x2
	// Position of TESTBP field.
	ETHERNET_TEST_TESTBP_Pos = 0x2
	// Bit mask of TESTBP field.
	ETHERNET_TEST_TESTBP_Msk = 0x4
	// Bit TESTBP.
	ETHERNET_TEST_TESTBP = 0x4
	// Position of RESERVED field.
	ETHERNET_TEST_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	ETHERNET_TEST_RESERVED_Msk = 0xfffffff8

	// MCFG: MII Mgmt Configuration register.
	// Position of SCANINC field.
	ETHERNET_MCFG_SCANINC_Pos = 0x0
	// Bit mask of SCANINC field.
	ETHERNET_MCFG_SCANINC_Msk = 0x1
	// Bit SCANINC.
	ETHERNET_MCFG_SCANINC = 0x1
	// Position of SUPPPREAMBLE field.
	ETHERNET_MCFG_SUPPPREAMBLE_Pos = 0x1
	// Bit mask of SUPPPREAMBLE field.
	ETHERNET_MCFG_SUPPPREAMBLE_Msk = 0x2
	// Bit SUPPPREAMBLE.
	ETHERNET_MCFG_SUPPPREAMBLE = 0x2
	// Position of CLOCKSEL field.
	ETHERNET_MCFG_CLOCKSEL_Pos = 0x2
	// Bit mask of CLOCKSEL field.
	ETHERNET_MCFG_CLOCKSEL_Msk = 0x3c
	// Position of RESERVED field.
	ETHERNET_MCFG_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	ETHERNET_MCFG_RESERVED_Msk = 0x7fc0
	// Position of RESETMIIMGMT field.
	ETHERNET_MCFG_RESETMIIMGMT_Pos = 0xf
	// Bit mask of RESETMIIMGMT field.
	ETHERNET_MCFG_RESETMIIMGMT_Msk = 0x8000
	// Bit RESETMIIMGMT.
	ETHERNET_MCFG_RESETMIIMGMT = 0x8000
	// Position of RESERVED field.
	ETHERNET_MCFG_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	ETHERNET_MCFG_RESERVED_Msk = 0xffff0000

	// MCMD: MII Mgmt Command register.
	// Position of READ field.
	ETHERNET_MCMD_READ_Pos = 0x0
	// Bit mask of READ field.
	ETHERNET_MCMD_READ_Msk = 0x1
	// Bit READ.
	ETHERNET_MCMD_READ = 0x1
	// Position of SCAN field.
	ETHERNET_MCMD_SCAN_Pos = 0x1
	// Bit mask of SCAN field.
	ETHERNET_MCMD_SCAN_Msk = 0x2
	// Bit SCAN.
	ETHERNET_MCMD_SCAN = 0x2
	// Position of RESERVED field.
	ETHERNET_MCMD_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	ETHERNET_MCMD_RESERVED_Msk = 0xfffffffc

	// MADR: MII Mgmt Address register.
	// Position of REGADDR field.
	ETHERNET_MADR_REGADDR_Pos = 0x0
	// Bit mask of REGADDR field.
	ETHERNET_MADR_REGADDR_Msk = 0x1f
	// Position of RESERVED field.
	ETHERNET_MADR_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	ETHERNET_MADR_RESERVED_Msk = 0xe0
	// Position of PHYADDR field.
	ETHERNET_MADR_PHYADDR_Pos = 0x8
	// Bit mask of PHYADDR field.
	ETHERNET_MADR_PHYADDR_Msk = 0x1f00
	// Position of RESERVED field.
	ETHERNET_MADR_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	ETHERNET_MADR_RESERVED_Msk = 0xffffe000

	// MWTD: MII Mgmt Write Data register.
	// Position of WRITEDATA field.
	ETHERNET_MWTD_WRITEDATA_Pos = 0x0
	// Bit mask of WRITEDATA field.
	ETHERNET_MWTD_WRITEDATA_Msk = 0xffff
	// Position of RESERVED field.
	ETHERNET_MWTD_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	ETHERNET_MWTD_RESERVED_Msk = 0xffff0000

	// MRDD: MII Mgmt Read Data register.
	// Position of READDATA field.
	ETHERNET_MRDD_READDATA_Pos = 0x0
	// Bit mask of READDATA field.
	ETHERNET_MRDD_READDATA_Msk = 0xffff
	// Position of RESERVED field.
	ETHERNET_MRDD_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	ETHERNET_MRDD_RESERVED_Msk = 0xffff0000

	// MIND: MII Mgmt Indicators register.
	// Position of BUSY field.
	ETHERNET_MIND_BUSY_Pos = 0x0
	// Bit mask of BUSY field.
	ETHERNET_MIND_BUSY_Msk = 0x1
	// Bit BUSY.
	ETHERNET_MIND_BUSY = 0x1
	// Position of SCANNING field.
	ETHERNET_MIND_SCANNING_Pos = 0x1
	// Bit mask of SCANNING field.
	ETHERNET_MIND_SCANNING_Msk = 0x2
	// Bit SCANNING.
	ETHERNET_MIND_SCANNING = 0x2
	// Position of NOTVALID field.
	ETHERNET_MIND_NOTVALID_Pos = 0x2
	// Bit mask of NOTVALID field.
	ETHERNET_MIND_NOTVALID_Msk = 0x4
	// Bit NOTVALID.
	ETHERNET_MIND_NOTVALID = 0x4
	// Position of MIILINKFAIL field.
	ETHERNET_MIND_MIILINKFAIL_Pos = 0x3
	// Bit mask of MIILINKFAIL field.
	ETHERNET_MIND_MIILINKFAIL_Msk = 0x8
	// Bit MIILINKFAIL.
	ETHERNET_MIND_MIILINKFAIL = 0x8
	// Position of RESERVED field.
	ETHERNET_MIND_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	ETHERNET_MIND_RESERVED_Msk = 0xfffffff0

	// SA0: Station Address 0 register.
	// Position of SADDR2 field.
	ETHERNET_SA0_SADDR2_Pos = 0x0
	// Bit mask of SADDR2 field.
	ETHERNET_SA0_SADDR2_Msk = 0xff
	// Position of SADDR1 field.
	ETHERNET_SA0_SADDR1_Pos = 0x8
	// Bit mask of SADDR1 field.
	ETHERNET_SA0_SADDR1_Msk = 0xff00
	// Position of RESERVED field.
	ETHERNET_SA0_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	ETHERNET_SA0_RESERVED_Msk = 0xffff0000

	// SA1: Station Address 1 register.
	// Position of SADDR4 field.
	ETHERNET_SA1_SADDR4_Pos = 0x0
	// Bit mask of SADDR4 field.
	ETHERNET_SA1_SADDR4_Msk = 0xff
	// Position of SADDR3 field.
	ETHERNET_SA1_SADDR3_Pos = 0x8
	// Bit mask of SADDR3 field.
	ETHERNET_SA1_SADDR3_Msk = 0xff00
	// Position of RESERVED field.
	ETHERNET_SA1_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	ETHERNET_SA1_RESERVED_Msk = 0xffff0000

	// SA2: Station Address 2 register.
	// Position of SADDR6 field.
	ETHERNET_SA2_SADDR6_Pos = 0x0
	// Bit mask of SADDR6 field.
	ETHERNET_SA2_SADDR6_Msk = 0xff
	// Position of SADDR5 field.
	ETHERNET_SA2_SADDR5_Pos = 0x8
	// Bit mask of SADDR5 field.
	ETHERNET_SA2_SADDR5_Msk = 0xff00
	// Position of RESERVED field.
	ETHERNET_SA2_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	ETHERNET_SA2_RESERVED_Msk = 0xffff0000

	// COMMAND: Command register.
	// Position of RXENABLE field.
	ETHERNET_COMMAND_RXENABLE_Pos = 0x0
	// Bit mask of RXENABLE field.
	ETHERNET_COMMAND_RXENABLE_Msk = 0x1
	// Bit RXENABLE.
	ETHERNET_COMMAND_RXENABLE = 0x1
	// Position of TXENABLE field.
	ETHERNET_COMMAND_TXENABLE_Pos = 0x1
	// Bit mask of TXENABLE field.
	ETHERNET_COMMAND_TXENABLE_Msk = 0x2
	// Bit TXENABLE.
	ETHERNET_COMMAND_TXENABLE = 0x2
	// Position of RESERVED field.
	ETHERNET_COMMAND_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	ETHERNET_COMMAND_RESERVED_Msk = 0x4
	// Bit RESERVED.
	ETHERNET_COMMAND_RESERVED = 0x4
	// Position of REGRESET field.
	ETHERNET_COMMAND_REGRESET_Pos = 0x3
	// Bit mask of REGRESET field.
	ETHERNET_COMMAND_REGRESET_Msk = 0x8
	// Bit REGRESET.
	ETHERNET_COMMAND_REGRESET = 0x8
	// Position of TXRESET field.
	ETHERNET_COMMAND_TXRESET_Pos = 0x4
	// Bit mask of TXRESET field.
	ETHERNET_COMMAND_TXRESET_Msk = 0x10
	// Bit TXRESET.
	ETHERNET_COMMAND_TXRESET = 0x10
	// Position of RXRESET field.
	ETHERNET_COMMAND_RXRESET_Pos = 0x5
	// Bit mask of RXRESET field.
	ETHERNET_COMMAND_RXRESET_Msk = 0x20
	// Bit RXRESET.
	ETHERNET_COMMAND_RXRESET = 0x20
	// Position of PASSRUNTFRAME field.
	ETHERNET_COMMAND_PASSRUNTFRAME_Pos = 0x6
	// Bit mask of PASSRUNTFRAME field.
	ETHERNET_COMMAND_PASSRUNTFRAME_Msk = 0x40
	// Bit PASSRUNTFRAME.
	ETHERNET_COMMAND_PASSRUNTFRAME = 0x40
	// Position of PASSRXFILTER field.
	ETHERNET_COMMAND_PASSRXFILTER_Pos = 0x7
	// Bit mask of PASSRXFILTER field.
	ETHERNET_COMMAND_PASSRXFILTER_Msk = 0x80
	// Bit PASSRXFILTER.
	ETHERNET_COMMAND_PASSRXFILTER = 0x80
	// Position of TXFLOWCONTROL field.
	ETHERNET_COMMAND_TXFLOWCONTROL_Pos = 0x8
	// Bit mask of TXFLOWCONTROL field.
	ETHERNET_COMMAND_TXFLOWCONTROL_Msk = 0x100
	// Bit TXFLOWCONTROL.
	ETHERNET_COMMAND_TXFLOWCONTROL = 0x100
	// Position of RMII field.
	ETHERNET_COMMAND_RMII_Pos = 0x9
	// Bit mask of RMII field.
	ETHERNET_COMMAND_RMII_Msk = 0x200
	// Bit RMII.
	ETHERNET_COMMAND_RMII = 0x200
	// Position of FULLDUPLEX field.
	ETHERNET_COMMAND_FULLDUPLEX_Pos = 0xa
	// Bit mask of FULLDUPLEX field.
	ETHERNET_COMMAND_FULLDUPLEX_Msk = 0x400
	// Bit FULLDUPLEX.
	ETHERNET_COMMAND_FULLDUPLEX = 0x400
	// Position of RESERVED field.
	ETHERNET_COMMAND_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	ETHERNET_COMMAND_RESERVED_Msk = 0xfffff800

	// STATUS: Status register.
	// Position of RXSTATUS field.
	ETHERNET_STATUS_RXSTATUS_Pos = 0x0
	// Bit mask of RXSTATUS field.
	ETHERNET_STATUS_RXSTATUS_Msk = 0x1
	// Bit RXSTATUS.
	ETHERNET_STATUS_RXSTATUS = 0x1
	// Position of TXSTATUS field.
	ETHERNET_STATUS_TXSTATUS_Pos = 0x1
	// Bit mask of TXSTATUS field.
	ETHERNET_STATUS_TXSTATUS_Msk = 0x2
	// Bit TXSTATUS.
	ETHERNET_STATUS_TXSTATUS = 0x2
	// Position of RESERVED field.
	ETHERNET_STATUS_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	ETHERNET_STATUS_RESERVED_Msk = 0xfffffffc

	// RXDESCRIPTOR: Receive descriptor base address register.
	// Position of RESERVED field.
	ETHERNET_RXDESCRIPTOR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	ETHERNET_RXDESCRIPTOR_RESERVED_Msk = 0x3
	// Position of RXDESCRIPTOR field.
	ETHERNET_RXDESCRIPTOR_RXDESCRIPTOR_Pos = 0x2
	// Bit mask of RXDESCRIPTOR field.
	ETHERNET_RXDESCRIPTOR_RXDESCRIPTOR_Msk = 0xfffffffc

	// RXSTATUS: Receive status base address register.
	// Position of RESERVED field.
	ETHERNET_RXSTATUS_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	ETHERNET_RXSTATUS_RESERVED_Msk = 0x7
	// Position of RXSTATUS field.
	ETHERNET_RXSTATUS_RXSTATUS_Pos = 0x3
	// Bit mask of RXSTATUS field.
	ETHERNET_RXSTATUS_RXSTATUS_Msk = 0xfffffff8

	// RXDESCRIPTORNUMBER: Receive number of descriptors register.
	// Position of RXDESCRIPTORN field.
	ETHERNET_RXDESCRIPTORNUMBER_RXDESCRIPTORN_Pos = 0x0
	// Bit mask of RXDESCRIPTORN field.
	ETHERNET_RXDESCRIPTORNUMBER_RXDESCRIPTORN_Msk = 0xffff
	// Position of RESERVED field.
	ETHERNET_RXDESCRIPTORNUMBER_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	ETHERNET_RXDESCRIPTORNUMBER_RESERVED_Msk = 0xffff0000

	// RXPRODUCEINDEX: Receive produce index register.
	// Position of RXPRODUCEIX field.
	ETHERNET_RXPRODUCEINDEX_RXPRODUCEIX_Pos = 0x0
	// Bit mask of RXPRODUCEIX field.
	ETHERNET_RXPRODUCEINDEX_RXPRODUCEIX_Msk = 0xffff
	// Position of RESERVED field.
	ETHERNET_RXPRODUCEINDEX_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	ETHERNET_RXPRODUCEINDEX_RESERVED_Msk = 0xffff0000

	// RXCONSUMEINDEX: Receive consume index register.
	// Position of RXCONSUMEIX field.
	ETHERNET_RXCONSUMEINDEX_RXCONSUMEIX_Pos = 0x0
	// Bit mask of RXCONSUMEIX field.
	ETHERNET_RXCONSUMEINDEX_RXCONSUMEIX_Msk = 0xffff
	// Position of RESERVED field.
	ETHERNET_RXCONSUMEINDEX_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	ETHERNET_RXCONSUMEINDEX_RESERVED_Msk = 0xffff0000

	// TXDESCRIPTOR: Transmit descriptor base address register.
	// Position of RESERVED field.
	ETHERNET_TXDESCRIPTOR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	ETHERNET_TXDESCRIPTOR_RESERVED_Msk = 0x3
	// Position of TXD field.
	ETHERNET_TXDESCRIPTOR_TXD_Pos = 0x2
	// Bit mask of TXD field.
	ETHERNET_TXDESCRIPTOR_TXD_Msk = 0xfffffffc

	// TXSTATUS: Transmit status base address register.
	// Position of RESERVED field.
	ETHERNET_TXSTATUS_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	ETHERNET_TXSTATUS_RESERVED_Msk = 0x3
	// Position of TXSTAT field.
	ETHERNET_TXSTATUS_TXSTAT_Pos = 0x2
	// Bit mask of TXSTAT field.
	ETHERNET_TXSTATUS_TXSTAT_Msk = 0xfffffffc

	// TXDESCRIPTORNUMBER: Transmit number of descriptors register.
	// Position of TXDN field.
	ETHERNET_TXDESCRIPTORNUMBER_TXDN_Pos = 0x0
	// Bit mask of TXDN field.
	ETHERNET_TXDESCRIPTORNUMBER_TXDN_Msk = 0xffff
	// Position of RESERVED field.
	ETHERNET_TXDESCRIPTORNUMBER_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	ETHERNET_TXDESCRIPTORNUMBER_RESERVED_Msk = 0xffff0000

	// TXPRODUCEINDEX: Transmit produce index register.
	// Position of TXPI field.
	ETHERNET_TXPRODUCEINDEX_TXPI_Pos = 0x0
	// Bit mask of TXPI field.
	ETHERNET_TXPRODUCEINDEX_TXPI_Msk = 0xffff
	// Position of RESERVED field.
	ETHERNET_TXPRODUCEINDEX_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	ETHERNET_TXPRODUCEINDEX_RESERVED_Msk = 0xffff0000

	// TXCONSUMEINDEX: Transmit consume index register.
	// Position of TXCI field.
	ETHERNET_TXCONSUMEINDEX_TXCI_Pos = 0x0
	// Bit mask of TXCI field.
	ETHERNET_TXCONSUMEINDEX_TXCI_Msk = 0xffff
	// Position of RESERVED field.
	ETHERNET_TXCONSUMEINDEX_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	ETHERNET_TXCONSUMEINDEX_RESERVED_Msk = 0xffff0000

	// TSV0: Transmit status vector 0 register.
	// Position of CRCERR field.
	ETHERNET_TSV0_CRCERR_Pos = 0x0
	// Bit mask of CRCERR field.
	ETHERNET_TSV0_CRCERR_Msk = 0x1
	// Bit CRCERR.
	ETHERNET_TSV0_CRCERR = 0x1
	// Position of LCE field.
	ETHERNET_TSV0_LCE_Pos = 0x1
	// Bit mask of LCE field.
	ETHERNET_TSV0_LCE_Msk = 0x2
	// Bit LCE.
	ETHERNET_TSV0_LCE = 0x2
	// Position of LOR field.
	ETHERNET_TSV0_LOR_Pos = 0x2
	// Bit mask of LOR field.
	ETHERNET_TSV0_LOR_Msk = 0x4
	// Bit LOR.
	ETHERNET_TSV0_LOR = 0x4
	// Position of DONE field.
	ETHERNET_TSV0_DONE_Pos = 0x3
	// Bit mask of DONE field.
	ETHERNET_TSV0_DONE_Msk = 0x8
	// Bit DONE.
	ETHERNET_TSV0_DONE = 0x8
	// Position of MULTICAST field.
	ETHERNET_TSV0_MULTICAST_Pos = 0x4
	// Bit mask of MULTICAST field.
	ETHERNET_TSV0_MULTICAST_Msk = 0x10
	// Bit MULTICAST.
	ETHERNET_TSV0_MULTICAST = 0x10
	// Position of BROADCAST field.
	ETHERNET_TSV0_BROADCAST_Pos = 0x5
	// Bit mask of BROADCAST field.
	ETHERNET_TSV0_BROADCAST_Msk = 0x20
	// Bit BROADCAST.
	ETHERNET_TSV0_BROADCAST = 0x20
	// Position of PACKETDEFER field.
	ETHERNET_TSV0_PACKETDEFER_Pos = 0x6
	// Bit mask of PACKETDEFER field.
	ETHERNET_TSV0_PACKETDEFER_Msk = 0x40
	// Bit PACKETDEFER.
	ETHERNET_TSV0_PACKETDEFER = 0x40
	// Position of EXDF field.
	ETHERNET_TSV0_EXDF_Pos = 0x7
	// Bit mask of EXDF field.
	ETHERNET_TSV0_EXDF_Msk = 0x80
	// Bit EXDF.
	ETHERNET_TSV0_EXDF = 0x80
	// Position of EXCOL field.
	ETHERNET_TSV0_EXCOL_Pos = 0x8
	// Bit mask of EXCOL field.
	ETHERNET_TSV0_EXCOL_Msk = 0x100
	// Bit EXCOL.
	ETHERNET_TSV0_EXCOL = 0x100
	// Position of LCOL field.
	ETHERNET_TSV0_LCOL_Pos = 0x9
	// Bit mask of LCOL field.
	ETHERNET_TSV0_LCOL_Msk = 0x200
	// Bit LCOL.
	ETHERNET_TSV0_LCOL = 0x200
	// Position of GIANT field.
	ETHERNET_TSV0_GIANT_Pos = 0xa
	// Bit mask of GIANT field.
	ETHERNET_TSV0_GIANT_Msk = 0x400
	// Bit GIANT.
	ETHERNET_TSV0_GIANT = 0x400
	// Position of UNDERRUN field.
	ETHERNET_TSV0_UNDERRUN_Pos = 0xb
	// Bit mask of UNDERRUN field.
	ETHERNET_TSV0_UNDERRUN_Msk = 0x800
	// Bit UNDERRUN.
	ETHERNET_TSV0_UNDERRUN = 0x800
	// Position of TOTALBYTES field.
	ETHERNET_TSV0_TOTALBYTES_Pos = 0xc
	// Bit mask of TOTALBYTES field.
	ETHERNET_TSV0_TOTALBYTES_Msk = 0xffff000
	// Position of CONTROLFRAME field.
	ETHERNET_TSV0_CONTROLFRAME_Pos = 0x1c
	// Bit mask of CONTROLFRAME field.
	ETHERNET_TSV0_CONTROLFRAME_Msk = 0x10000000
	// Bit CONTROLFRAME.
	ETHERNET_TSV0_CONTROLFRAME = 0x10000000
	// Position of PAUSE field.
	ETHERNET_TSV0_PAUSE_Pos = 0x1d
	// Bit mask of PAUSE field.
	ETHERNET_TSV0_PAUSE_Msk = 0x20000000
	// Bit PAUSE.
	ETHERNET_TSV0_PAUSE = 0x20000000
	// Position of BACKPRESSURE field.
	ETHERNET_TSV0_BACKPRESSURE_Pos = 0x1e
	// Bit mask of BACKPRESSURE field.
	ETHERNET_TSV0_BACKPRESSURE_Msk = 0x40000000
	// Bit BACKPRESSURE.
	ETHERNET_TSV0_BACKPRESSURE = 0x40000000
	// Position of VLAN field.
	ETHERNET_TSV0_VLAN_Pos = 0x1f
	// Bit mask of VLAN field.
	ETHERNET_TSV0_VLAN_Msk = 0x80000000
	// Bit VLAN.
	ETHERNET_TSV0_VLAN = 0x80000000

	// TSV1: Transmit status vector 1 register.
	// Position of TBC field.
	ETHERNET_TSV1_TBC_Pos = 0x0
	// Bit mask of TBC field.
	ETHERNET_TSV1_TBC_Msk = 0xffff
	// Position of TCC field.
	ETHERNET_TSV1_TCC_Pos = 0x10
	// Bit mask of TCC field.
	ETHERNET_TSV1_TCC_Msk = 0xf0000
	// Position of RESERVED field.
	ETHERNET_TSV1_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	ETHERNET_TSV1_RESERVED_Msk = 0xfff00000

	// RSV: Receive status vector register.
	// Position of RBC field.
	ETHERNET_RSV_RBC_Pos = 0x0
	// Bit mask of RBC field.
	ETHERNET_RSV_RBC_Msk = 0xffff
	// Position of PPI field.
	ETHERNET_RSV_PPI_Pos = 0x10
	// Bit mask of PPI field.
	ETHERNET_RSV_PPI_Msk = 0x10000
	// Bit PPI.
	ETHERNET_RSV_PPI = 0x10000
	// Position of RXDVSEEN field.
	ETHERNET_RSV_RXDVSEEN_Pos = 0x11
	// Bit mask of RXDVSEEN field.
	ETHERNET_RSV_RXDVSEEN_Msk = 0x20000
	// Bit RXDVSEEN.
	ETHERNET_RSV_RXDVSEEN = 0x20000
	// Position of CESEEN field.
	ETHERNET_RSV_CESEEN_Pos = 0x12
	// Bit mask of CESEEN field.
	ETHERNET_RSV_CESEEN_Msk = 0x40000
	// Bit CESEEN.
	ETHERNET_RSV_CESEEN = 0x40000
	// Position of RCV field.
	ETHERNET_RSV_RCV_Pos = 0x13
	// Bit mask of RCV field.
	ETHERNET_RSV_RCV_Msk = 0x80000
	// Bit RCV.
	ETHERNET_RSV_RCV = 0x80000
	// Position of CRCERR field.
	ETHERNET_RSV_CRCERR_Pos = 0x14
	// Bit mask of CRCERR field.
	ETHERNET_RSV_CRCERR_Msk = 0x100000
	// Bit CRCERR.
	ETHERNET_RSV_CRCERR = 0x100000
	// Position of LCERR field.
	ETHERNET_RSV_LCERR_Pos = 0x15
	// Bit mask of LCERR field.
	ETHERNET_RSV_LCERR_Msk = 0x200000
	// Bit LCERR.
	ETHERNET_RSV_LCERR = 0x200000
	// Position of LOR field.
	ETHERNET_RSV_LOR_Pos = 0x16
	// Bit mask of LOR field.
	ETHERNET_RSV_LOR_Msk = 0x400000
	// Bit LOR.
	ETHERNET_RSV_LOR = 0x400000
	// Position of ROK field.
	ETHERNET_RSV_ROK_Pos = 0x17
	// Bit mask of ROK field.
	ETHERNET_RSV_ROK_Msk = 0x800000
	// Bit ROK.
	ETHERNET_RSV_ROK = 0x800000
	// Position of MULTICAST field.
	ETHERNET_RSV_MULTICAST_Pos = 0x18
	// Bit mask of MULTICAST field.
	ETHERNET_RSV_MULTICAST_Msk = 0x1000000
	// Bit MULTICAST.
	ETHERNET_RSV_MULTICAST = 0x1000000
	// Position of BROADCAST field.
	ETHERNET_RSV_BROADCAST_Pos = 0x19
	// Bit mask of BROADCAST field.
	ETHERNET_RSV_BROADCAST_Msk = 0x2000000
	// Bit BROADCAST.
	ETHERNET_RSV_BROADCAST = 0x2000000
	// Position of DRIBBLENIBBLE field.
	ETHERNET_RSV_DRIBBLENIBBLE_Pos = 0x1a
	// Bit mask of DRIBBLENIBBLE field.
	ETHERNET_RSV_DRIBBLENIBBLE_Msk = 0x4000000
	// Bit DRIBBLENIBBLE.
	ETHERNET_RSV_DRIBBLENIBBLE = 0x4000000
	// Position of CONTROLFRAME field.
	ETHERNET_RSV_CONTROLFRAME_Pos = 0x1b
	// Bit mask of CONTROLFRAME field.
	ETHERNET_RSV_CONTROLFRAME_Msk = 0x8000000
	// Bit CONTROLFRAME.
	ETHERNET_RSV_CONTROLFRAME = 0x8000000
	// Position of PAUSE field.
	ETHERNET_RSV_PAUSE_Pos = 0x1c
	// Bit mask of PAUSE field.
	ETHERNET_RSV_PAUSE_Msk = 0x10000000
	// Bit PAUSE.
	ETHERNET_RSV_PAUSE = 0x10000000
	// Position of UO field.
	ETHERNET_RSV_UO_Pos = 0x1d
	// Bit mask of UO field.
	ETHERNET_RSV_UO_Msk = 0x20000000
	// Bit UO.
	ETHERNET_RSV_UO = 0x20000000
	// Position of VLAN field.
	ETHERNET_RSV_VLAN_Pos = 0x1e
	// Bit mask of VLAN field.
	ETHERNET_RSV_VLAN_Msk = 0x40000000
	// Bit VLAN.
	ETHERNET_RSV_VLAN = 0x40000000
	// Position of RESERVED field.
	ETHERNET_RSV_RESERVED_Pos = 0x1f
	// Bit mask of RESERVED field.
	ETHERNET_RSV_RESERVED_Msk = 0x80000000
	// Bit RESERVED.
	ETHERNET_RSV_RESERVED = 0x80000000

	// FLOWCONTROLCOUNTER: Flow control counter register.
	// Position of MC field.
	ETHERNET_FLOWCONTROLCOUNTER_MC_Pos = 0x0
	// Bit mask of MC field.
	ETHERNET_FLOWCONTROLCOUNTER_MC_Msk = 0xffff
	// Position of PT field.
	ETHERNET_FLOWCONTROLCOUNTER_PT_Pos = 0x10
	// Bit mask of PT field.
	ETHERNET_FLOWCONTROLCOUNTER_PT_Msk = 0xffff0000

	// FLOWCONTROLSTATUS: Flow control status register.
	// Position of MCC field.
	ETHERNET_FLOWCONTROLSTATUS_MCC_Pos = 0x0
	// Bit mask of MCC field.
	ETHERNET_FLOWCONTROLSTATUS_MCC_Msk = 0xffff
	// Position of RESERVED field.
	ETHERNET_FLOWCONTROLSTATUS_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	ETHERNET_FLOWCONTROLSTATUS_RESERVED_Msk = 0xffff0000

	// RXFILTERCTRL: Receive filter control register.
	// Position of AUE field.
	ETHERNET_RXFILTERCTRL_AUE_Pos = 0x0
	// Bit mask of AUE field.
	ETHERNET_RXFILTERCTRL_AUE_Msk = 0x1
	// Bit AUE.
	ETHERNET_RXFILTERCTRL_AUE = 0x1
	// Position of ABE field.
	ETHERNET_RXFILTERCTRL_ABE_Pos = 0x1
	// Bit mask of ABE field.
	ETHERNET_RXFILTERCTRL_ABE_Msk = 0x2
	// Bit ABE.
	ETHERNET_RXFILTERCTRL_ABE = 0x2
	// Position of AME field.
	ETHERNET_RXFILTERCTRL_AME_Pos = 0x2
	// Bit mask of AME field.
	ETHERNET_RXFILTERCTRL_AME_Msk = 0x4
	// Bit AME.
	ETHERNET_RXFILTERCTRL_AME = 0x4
	// Position of AUHE field.
	ETHERNET_RXFILTERCTRL_AUHE_Pos = 0x3
	// Bit mask of AUHE field.
	ETHERNET_RXFILTERCTRL_AUHE_Msk = 0x8
	// Bit AUHE.
	ETHERNET_RXFILTERCTRL_AUHE = 0x8
	// Position of AMHE field.
	ETHERNET_RXFILTERCTRL_AMHE_Pos = 0x4
	// Bit mask of AMHE field.
	ETHERNET_RXFILTERCTRL_AMHE_Msk = 0x10
	// Bit AMHE.
	ETHERNET_RXFILTERCTRL_AMHE = 0x10
	// Position of APE field.
	ETHERNET_RXFILTERCTRL_APE_Pos = 0x5
	// Bit mask of APE field.
	ETHERNET_RXFILTERCTRL_APE_Msk = 0x20
	// Bit APE.
	ETHERNET_RXFILTERCTRL_APE = 0x20
	// Position of RESERVED field.
	ETHERNET_RXFILTERCTRL_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	ETHERNET_RXFILTERCTRL_RESERVED_Msk = 0xfc0
	// Position of MPEW field.
	ETHERNET_RXFILTERCTRL_MPEW_Pos = 0xc
	// Bit mask of MPEW field.
	ETHERNET_RXFILTERCTRL_MPEW_Msk = 0x1000
	// Bit MPEW.
	ETHERNET_RXFILTERCTRL_MPEW = 0x1000
	// Position of RFEW field.
	ETHERNET_RXFILTERCTRL_RFEW_Pos = 0xd
	// Bit mask of RFEW field.
	ETHERNET_RXFILTERCTRL_RFEW_Msk = 0x2000
	// Bit RFEW.
	ETHERNET_RXFILTERCTRL_RFEW = 0x2000
	// Position of RESERVED field.
	ETHERNET_RXFILTERCTRL_RESERVED_Pos = 0xe
	// Bit mask of RESERVED field.
	ETHERNET_RXFILTERCTRL_RESERVED_Msk = 0xffffc000

	// RXFILTERWOLSTATUS: Receive filter WoL status register.
	// Position of AUW field.
	ETHERNET_RXFILTERWOLSTATUS_AUW_Pos = 0x0
	// Bit mask of AUW field.
	ETHERNET_RXFILTERWOLSTATUS_AUW_Msk = 0x1
	// Bit AUW.
	ETHERNET_RXFILTERWOLSTATUS_AUW = 0x1
	// Position of ABW field.
	ETHERNET_RXFILTERWOLSTATUS_ABW_Pos = 0x1
	// Bit mask of ABW field.
	ETHERNET_RXFILTERWOLSTATUS_ABW_Msk = 0x2
	// Bit ABW.
	ETHERNET_RXFILTERWOLSTATUS_ABW = 0x2
	// Position of AMW field.
	ETHERNET_RXFILTERWOLSTATUS_AMW_Pos = 0x2
	// Bit mask of AMW field.
	ETHERNET_RXFILTERWOLSTATUS_AMW_Msk = 0x4
	// Bit AMW.
	ETHERNET_RXFILTERWOLSTATUS_AMW = 0x4
	// Position of AUHW field.
	ETHERNET_RXFILTERWOLSTATUS_AUHW_Pos = 0x3
	// Bit mask of AUHW field.
	ETHERNET_RXFILTERWOLSTATUS_AUHW_Msk = 0x8
	// Bit AUHW.
	ETHERNET_RXFILTERWOLSTATUS_AUHW = 0x8
	// Position of AMHW field.
	ETHERNET_RXFILTERWOLSTATUS_AMHW_Pos = 0x4
	// Bit mask of AMHW field.
	ETHERNET_RXFILTERWOLSTATUS_AMHW_Msk = 0x10
	// Bit AMHW.
	ETHERNET_RXFILTERWOLSTATUS_AMHW = 0x10
	// Position of APW field.
	ETHERNET_RXFILTERWOLSTATUS_APW_Pos = 0x5
	// Bit mask of APW field.
	ETHERNET_RXFILTERWOLSTATUS_APW_Msk = 0x20
	// Bit APW.
	ETHERNET_RXFILTERWOLSTATUS_APW = 0x20
	// Position of RESERVED field.
	ETHERNET_RXFILTERWOLSTATUS_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	ETHERNET_RXFILTERWOLSTATUS_RESERVED_Msk = 0x40
	// Bit RESERVED.
	ETHERNET_RXFILTERWOLSTATUS_RESERVED = 0x40
	// Position of RFW field.
	ETHERNET_RXFILTERWOLSTATUS_RFW_Pos = 0x7
	// Bit mask of RFW field.
	ETHERNET_RXFILTERWOLSTATUS_RFW_Msk = 0x80
	// Bit RFW.
	ETHERNET_RXFILTERWOLSTATUS_RFW = 0x80
	// Position of MPW field.
	ETHERNET_RXFILTERWOLSTATUS_MPW_Pos = 0x8
	// Bit mask of MPW field.
	ETHERNET_RXFILTERWOLSTATUS_MPW_Msk = 0x100
	// Bit MPW.
	ETHERNET_RXFILTERWOLSTATUS_MPW = 0x100
	// Position of RESERVED field.
	ETHERNET_RXFILTERWOLSTATUS_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	ETHERNET_RXFILTERWOLSTATUS_RESERVED_Msk = 0xfffffe00

	// RXFILTERWOLCLEAR: Receive filter WoL clear register.
	// Position of AUWCLR field.
	ETHERNET_RXFILTERWOLCLEAR_AUWCLR_Pos = 0x0
	// Bit mask of AUWCLR field.
	ETHERNET_RXFILTERWOLCLEAR_AUWCLR_Msk = 0x1
	// Bit AUWCLR.
	ETHERNET_RXFILTERWOLCLEAR_AUWCLR = 0x1
	// Position of ABWCLR field.
	ETHERNET_RXFILTERWOLCLEAR_ABWCLR_Pos = 0x1
	// Bit mask of ABWCLR field.
	ETHERNET_RXFILTERWOLCLEAR_ABWCLR_Msk = 0x2
	// Bit ABWCLR.
	ETHERNET_RXFILTERWOLCLEAR_ABWCLR = 0x2
	// Position of AMWCLR field.
	ETHERNET_RXFILTERWOLCLEAR_AMWCLR_Pos = 0x2
	// Bit mask of AMWCLR field.
	ETHERNET_RXFILTERWOLCLEAR_AMWCLR_Msk = 0x4
	// Bit AMWCLR.
	ETHERNET_RXFILTERWOLCLEAR_AMWCLR = 0x4
	// Position of AUHWCLR field.
	ETHERNET_RXFILTERWOLCLEAR_AUHWCLR_Pos = 0x3
	// Bit mask of AUHWCLR field.
	ETHERNET_RXFILTERWOLCLEAR_AUHWCLR_Msk = 0x8
	// Bit AUHWCLR.
	ETHERNET_RXFILTERWOLCLEAR_AUHWCLR = 0x8
	// Position of AMHWCLR field.
	ETHERNET_RXFILTERWOLCLEAR_AMHWCLR_Pos = 0x4
	// Bit mask of AMHWCLR field.
	ETHERNET_RXFILTERWOLCLEAR_AMHWCLR_Msk = 0x10
	// Bit AMHWCLR.
	ETHERNET_RXFILTERWOLCLEAR_AMHWCLR = 0x10
	// Position of APWCLR field.
	ETHERNET_RXFILTERWOLCLEAR_APWCLR_Pos = 0x5
	// Bit mask of APWCLR field.
	ETHERNET_RXFILTERWOLCLEAR_APWCLR_Msk = 0x20
	// Bit APWCLR.
	ETHERNET_RXFILTERWOLCLEAR_APWCLR = 0x20
	// Position of RESERVED field.
	ETHERNET_RXFILTERWOLCLEAR_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	ETHERNET_RXFILTERWOLCLEAR_RESERVED_Msk = 0x40
	// Bit RESERVED.
	ETHERNET_RXFILTERWOLCLEAR_RESERVED = 0x40
	// Position of RFWCLR field.
	ETHERNET_RXFILTERWOLCLEAR_RFWCLR_Pos = 0x7
	// Bit mask of RFWCLR field.
	ETHERNET_RXFILTERWOLCLEAR_RFWCLR_Msk = 0x80
	// Bit RFWCLR.
	ETHERNET_RXFILTERWOLCLEAR_RFWCLR = 0x80
	// Position of MPWCLR field.
	ETHERNET_RXFILTERWOLCLEAR_MPWCLR_Pos = 0x8
	// Bit mask of MPWCLR field.
	ETHERNET_RXFILTERWOLCLEAR_MPWCLR_Msk = 0x100
	// Bit MPWCLR.
	ETHERNET_RXFILTERWOLCLEAR_MPWCLR = 0x100
	// Position of RESERVED field.
	ETHERNET_RXFILTERWOLCLEAR_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	ETHERNET_RXFILTERWOLCLEAR_RESERVED_Msk = 0xfffffe00

	// HASHFILTERL: Hash filter table LSBs register.
	// Position of HFL field.
	ETHERNET_HASHFILTERL_HFL_Pos = 0x0
	// Bit mask of HFL field.
	ETHERNET_HASHFILTERL_HFL_Msk = 0xffffffff

	// HASHFILTERH: Hash filter table MSBs register.
	// Position of HFH field.
	ETHERNET_HASHFILTERH_HFH_Pos = 0x0
	// Bit mask of HFH field.
	ETHERNET_HASHFILTERH_HFH_Msk = 0xffffffff

	// INTSTATUS: Interrupt status register.
	// Position of RXOVERRUNINT field.
	ETHERNET_INTSTATUS_RXOVERRUNINT_Pos = 0x0
	// Bit mask of RXOVERRUNINT field.
	ETHERNET_INTSTATUS_RXOVERRUNINT_Msk = 0x1
	// Bit RXOVERRUNINT.
	ETHERNET_INTSTATUS_RXOVERRUNINT = 0x1
	// Position of RXERRORINT field.
	ETHERNET_INTSTATUS_RXERRORINT_Pos = 0x1
	// Bit mask of RXERRORINT field.
	ETHERNET_INTSTATUS_RXERRORINT_Msk = 0x2
	// Bit RXERRORINT.
	ETHERNET_INTSTATUS_RXERRORINT = 0x2
	// Position of RXFINISHEDINT field.
	ETHERNET_INTSTATUS_RXFINISHEDINT_Pos = 0x2
	// Bit mask of RXFINISHEDINT field.
	ETHERNET_INTSTATUS_RXFINISHEDINT_Msk = 0x4
	// Bit RXFINISHEDINT.
	ETHERNET_INTSTATUS_RXFINISHEDINT = 0x4
	// Position of RXDONEINT field.
	ETHERNET_INTSTATUS_RXDONEINT_Pos = 0x3
	// Bit mask of RXDONEINT field.
	ETHERNET_INTSTATUS_RXDONEINT_Msk = 0x8
	// Bit RXDONEINT.
	ETHERNET_INTSTATUS_RXDONEINT = 0x8
	// Position of TXUNDERRUNINT field.
	ETHERNET_INTSTATUS_TXUNDERRUNINT_Pos = 0x4
	// Bit mask of TXUNDERRUNINT field.
	ETHERNET_INTSTATUS_TXUNDERRUNINT_Msk = 0x10
	// Bit TXUNDERRUNINT.
	ETHERNET_INTSTATUS_TXUNDERRUNINT = 0x10
	// Position of TXERRORINT field.
	ETHERNET_INTSTATUS_TXERRORINT_Pos = 0x5
	// Bit mask of TXERRORINT field.
	ETHERNET_INTSTATUS_TXERRORINT_Msk = 0x20
	// Bit TXERRORINT.
	ETHERNET_INTSTATUS_TXERRORINT = 0x20
	// Position of TXFINISHEDINT field.
	ETHERNET_INTSTATUS_TXFINISHEDINT_Pos = 0x6
	// Bit mask of TXFINISHEDINT field.
	ETHERNET_INTSTATUS_TXFINISHEDINT_Msk = 0x40
	// Bit TXFINISHEDINT.
	ETHERNET_INTSTATUS_TXFINISHEDINT = 0x40
	// Position of TXDONEINT field.
	ETHERNET_INTSTATUS_TXDONEINT_Pos = 0x7
	// Bit mask of TXDONEINT field.
	ETHERNET_INTSTATUS_TXDONEINT_Msk = 0x80
	// Bit TXDONEINT.
	ETHERNET_INTSTATUS_TXDONEINT = 0x80
	// Position of RESERVED field.
	ETHERNET_INTSTATUS_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	ETHERNET_INTSTATUS_RESERVED_Msk = 0xf00
	// Position of SOFTINT field.
	ETHERNET_INTSTATUS_SOFTINT_Pos = 0xc
	// Bit mask of SOFTINT field.
	ETHERNET_INTSTATUS_SOFTINT_Msk = 0x1000
	// Bit SOFTINT.
	ETHERNET_INTSTATUS_SOFTINT = 0x1000
	// Position of WAKEUPINT field.
	ETHERNET_INTSTATUS_WAKEUPINT_Pos = 0xd
	// Bit mask of WAKEUPINT field.
	ETHERNET_INTSTATUS_WAKEUPINT_Msk = 0x2000
	// Bit WAKEUPINT.
	ETHERNET_INTSTATUS_WAKEUPINT = 0x2000
	// Position of RESERVED field.
	ETHERNET_INTSTATUS_RESERVED_Pos = 0xe
	// Bit mask of RESERVED field.
	ETHERNET_INTSTATUS_RESERVED_Msk = 0xffffc000

	// INTENABLE: Interrupt enable register.
	// Position of RXOVERRUNINTEN field.
	ETHERNET_INTENABLE_RXOVERRUNINTEN_Pos = 0x0
	// Bit mask of RXOVERRUNINTEN field.
	ETHERNET_INTENABLE_RXOVERRUNINTEN_Msk = 0x1
	// Bit RXOVERRUNINTEN.
	ETHERNET_INTENABLE_RXOVERRUNINTEN = 0x1
	// Position of RXERRORINTEN field.
	ETHERNET_INTENABLE_RXERRORINTEN_Pos = 0x1
	// Bit mask of RXERRORINTEN field.
	ETHERNET_INTENABLE_RXERRORINTEN_Msk = 0x2
	// Bit RXERRORINTEN.
	ETHERNET_INTENABLE_RXERRORINTEN = 0x2
	// Position of RXFINISHEDINTEN field.
	ETHERNET_INTENABLE_RXFINISHEDINTEN_Pos = 0x2
	// Bit mask of RXFINISHEDINTEN field.
	ETHERNET_INTENABLE_RXFINISHEDINTEN_Msk = 0x4
	// Bit RXFINISHEDINTEN.
	ETHERNET_INTENABLE_RXFINISHEDINTEN = 0x4
	// Position of RXDONEINTEN field.
	ETHERNET_INTENABLE_RXDONEINTEN_Pos = 0x3
	// Bit mask of RXDONEINTEN field.
	ETHERNET_INTENABLE_RXDONEINTEN_Msk = 0x8
	// Bit RXDONEINTEN.
	ETHERNET_INTENABLE_RXDONEINTEN = 0x8
	// Position of TXUNDERRUNINTEN field.
	ETHERNET_INTENABLE_TXUNDERRUNINTEN_Pos = 0x4
	// Bit mask of TXUNDERRUNINTEN field.
	ETHERNET_INTENABLE_TXUNDERRUNINTEN_Msk = 0x10
	// Bit TXUNDERRUNINTEN.
	ETHERNET_INTENABLE_TXUNDERRUNINTEN = 0x10
	// Position of TXERRORINTEN field.
	ETHERNET_INTENABLE_TXERRORINTEN_Pos = 0x5
	// Bit mask of TXERRORINTEN field.
	ETHERNET_INTENABLE_TXERRORINTEN_Msk = 0x20
	// Bit TXERRORINTEN.
	ETHERNET_INTENABLE_TXERRORINTEN = 0x20
	// Position of TXFINISHEDINTEN field.
	ETHERNET_INTENABLE_TXFINISHEDINTEN_Pos = 0x6
	// Bit mask of TXFINISHEDINTEN field.
	ETHERNET_INTENABLE_TXFINISHEDINTEN_Msk = 0x40
	// Bit TXFINISHEDINTEN.
	ETHERNET_INTENABLE_TXFINISHEDINTEN = 0x40
	// Position of TXDONEINTEN field.
	ETHERNET_INTENABLE_TXDONEINTEN_Pos = 0x7
	// Bit mask of TXDONEINTEN field.
	ETHERNET_INTENABLE_TXDONEINTEN_Msk = 0x80
	// Bit TXDONEINTEN.
	ETHERNET_INTENABLE_TXDONEINTEN = 0x80
	// Position of RESERVED field.
	ETHERNET_INTENABLE_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	ETHERNET_INTENABLE_RESERVED_Msk = 0xf00
	// Position of SOFTINTEN field.
	ETHERNET_INTENABLE_SOFTINTEN_Pos = 0xc
	// Bit mask of SOFTINTEN field.
	ETHERNET_INTENABLE_SOFTINTEN_Msk = 0x1000
	// Bit SOFTINTEN.
	ETHERNET_INTENABLE_SOFTINTEN = 0x1000
	// Position of WAKEUPINTEN field.
	ETHERNET_INTENABLE_WAKEUPINTEN_Pos = 0xd
	// Bit mask of WAKEUPINTEN field.
	ETHERNET_INTENABLE_WAKEUPINTEN_Msk = 0x2000
	// Bit WAKEUPINTEN.
	ETHERNET_INTENABLE_WAKEUPINTEN = 0x2000
	// Position of RESERVED field.
	ETHERNET_INTENABLE_RESERVED_Pos = 0xe
	// Bit mask of RESERVED field.
	ETHERNET_INTENABLE_RESERVED_Msk = 0xffffc000

	// INTCLEAR: Interrupt clear register.
	// Position of RXOVERRUNINTCLR field.
	ETHERNET_INTCLEAR_RXOVERRUNINTCLR_Pos = 0x0
	// Bit mask of RXOVERRUNINTCLR field.
	ETHERNET_INTCLEAR_RXOVERRUNINTCLR_Msk = 0x1
	// Bit RXOVERRUNINTCLR.
	ETHERNET_INTCLEAR_RXOVERRUNINTCLR = 0x1
	// Position of RXERRORINTCLR field.
	ETHERNET_INTCLEAR_RXERRORINTCLR_Pos = 0x1
	// Bit mask of RXERRORINTCLR field.
	ETHERNET_INTCLEAR_RXERRORINTCLR_Msk = 0x2
	// Bit RXERRORINTCLR.
	ETHERNET_INTCLEAR_RXERRORINTCLR = 0x2
	// Position of RXFINISHEDINTCLR field.
	ETHERNET_INTCLEAR_RXFINISHEDINTCLR_Pos = 0x2
	// Bit mask of RXFINISHEDINTCLR field.
	ETHERNET_INTCLEAR_RXFINISHEDINTCLR_Msk = 0x4
	// Bit RXFINISHEDINTCLR.
	ETHERNET_INTCLEAR_RXFINISHEDINTCLR = 0x4
	// Position of RXDONEINTCLR field.
	ETHERNET_INTCLEAR_RXDONEINTCLR_Pos = 0x3
	// Bit mask of RXDONEINTCLR field.
	ETHERNET_INTCLEAR_RXDONEINTCLR_Msk = 0x8
	// Bit RXDONEINTCLR.
	ETHERNET_INTCLEAR_RXDONEINTCLR = 0x8
	// Position of TXUNDERRUNINTCLR field.
	ETHERNET_INTCLEAR_TXUNDERRUNINTCLR_Pos = 0x4
	// Bit mask of TXUNDERRUNINTCLR field.
	ETHERNET_INTCLEAR_TXUNDERRUNINTCLR_Msk = 0x10
	// Bit TXUNDERRUNINTCLR.
	ETHERNET_INTCLEAR_TXUNDERRUNINTCLR = 0x10
	// Position of TXERRORINTCLR field.
	ETHERNET_INTCLEAR_TXERRORINTCLR_Pos = 0x5
	// Bit mask of TXERRORINTCLR field.
	ETHERNET_INTCLEAR_TXERRORINTCLR_Msk = 0x20
	// Bit TXERRORINTCLR.
	ETHERNET_INTCLEAR_TXERRORINTCLR = 0x20
	// Position of TXFINISHEDINTCLR field.
	ETHERNET_INTCLEAR_TXFINISHEDINTCLR_Pos = 0x6
	// Bit mask of TXFINISHEDINTCLR field.
	ETHERNET_INTCLEAR_TXFINISHEDINTCLR_Msk = 0x40
	// Bit TXFINISHEDINTCLR.
	ETHERNET_INTCLEAR_TXFINISHEDINTCLR = 0x40
	// Position of TXDONEINTCLR field.
	ETHERNET_INTCLEAR_TXDONEINTCLR_Pos = 0x7
	// Bit mask of TXDONEINTCLR field.
	ETHERNET_INTCLEAR_TXDONEINTCLR_Msk = 0x80
	// Bit TXDONEINTCLR.
	ETHERNET_INTCLEAR_TXDONEINTCLR = 0x80
	// Position of RESERVED field.
	ETHERNET_INTCLEAR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	ETHERNET_INTCLEAR_RESERVED_Msk = 0xf00
	// Position of SOFTINTCLR field.
	ETHERNET_INTCLEAR_SOFTINTCLR_Pos = 0xc
	// Bit mask of SOFTINTCLR field.
	ETHERNET_INTCLEAR_SOFTINTCLR_Msk = 0x1000
	// Bit SOFTINTCLR.
	ETHERNET_INTCLEAR_SOFTINTCLR = 0x1000
	// Position of WAKEUPINTCLR field.
	ETHERNET_INTCLEAR_WAKEUPINTCLR_Pos = 0xd
	// Bit mask of WAKEUPINTCLR field.
	ETHERNET_INTCLEAR_WAKEUPINTCLR_Msk = 0x2000
	// Bit WAKEUPINTCLR.
	ETHERNET_INTCLEAR_WAKEUPINTCLR = 0x2000
	// Position of RESERVED field.
	ETHERNET_INTCLEAR_RESERVED_Pos = 0xe
	// Bit mask of RESERVED field.
	ETHERNET_INTCLEAR_RESERVED_Msk = 0xffffc000

	// INTSET: Interrupt set register.
	// Position of RXOVERRUNINTSET field.
	ETHERNET_INTSET_RXOVERRUNINTSET_Pos = 0x0
	// Bit mask of RXOVERRUNINTSET field.
	ETHERNET_INTSET_RXOVERRUNINTSET_Msk = 0x1
	// Bit RXOVERRUNINTSET.
	ETHERNET_INTSET_RXOVERRUNINTSET = 0x1
	// Position of RXERRORINTSET field.
	ETHERNET_INTSET_RXERRORINTSET_Pos = 0x1
	// Bit mask of RXERRORINTSET field.
	ETHERNET_INTSET_RXERRORINTSET_Msk = 0x2
	// Bit RXERRORINTSET.
	ETHERNET_INTSET_RXERRORINTSET = 0x2
	// Position of RXFINISHEDINTSET field.
	ETHERNET_INTSET_RXFINISHEDINTSET_Pos = 0x2
	// Bit mask of RXFINISHEDINTSET field.
	ETHERNET_INTSET_RXFINISHEDINTSET_Msk = 0x4
	// Bit RXFINISHEDINTSET.
	ETHERNET_INTSET_RXFINISHEDINTSET = 0x4
	// Position of RXDONEINTSET field.
	ETHERNET_INTSET_RXDONEINTSET_Pos = 0x3
	// Bit mask of RXDONEINTSET field.
	ETHERNET_INTSET_RXDONEINTSET_Msk = 0x8
	// Bit RXDONEINTSET.
	ETHERNET_INTSET_RXDONEINTSET = 0x8
	// Position of TXUNDERRUNINTSET field.
	ETHERNET_INTSET_TXUNDERRUNINTSET_Pos = 0x4
	// Bit mask of TXUNDERRUNINTSET field.
	ETHERNET_INTSET_TXUNDERRUNINTSET_Msk = 0x10
	// Bit TXUNDERRUNINTSET.
	ETHERNET_INTSET_TXUNDERRUNINTSET = 0x10
	// Position of TXERRORINTSET field.
	ETHERNET_INTSET_TXERRORINTSET_Pos = 0x5
	// Bit mask of TXERRORINTSET field.
	ETHERNET_INTSET_TXERRORINTSET_Msk = 0x20
	// Bit TXERRORINTSET.
	ETHERNET_INTSET_TXERRORINTSET = 0x20
	// Position of TXFINISHEDINTSET field.
	ETHERNET_INTSET_TXFINISHEDINTSET_Pos = 0x6
	// Bit mask of TXFINISHEDINTSET field.
	ETHERNET_INTSET_TXFINISHEDINTSET_Msk = 0x40
	// Bit TXFINISHEDINTSET.
	ETHERNET_INTSET_TXFINISHEDINTSET = 0x40
	// Position of TXDONEINTSET field.
	ETHERNET_INTSET_TXDONEINTSET_Pos = 0x7
	// Bit mask of TXDONEINTSET field.
	ETHERNET_INTSET_TXDONEINTSET_Msk = 0x80
	// Bit TXDONEINTSET.
	ETHERNET_INTSET_TXDONEINTSET = 0x80
	// Position of RESERVED field.
	ETHERNET_INTSET_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	ETHERNET_INTSET_RESERVED_Msk = 0xf00
	// Position of SOFTINTSET field.
	ETHERNET_INTSET_SOFTINTSET_Pos = 0xc
	// Bit mask of SOFTINTSET field.
	ETHERNET_INTSET_SOFTINTSET_Msk = 0x1000
	// Bit SOFTINTSET.
	ETHERNET_INTSET_SOFTINTSET = 0x1000
	// Position of WAKEUPINTSET field.
	ETHERNET_INTSET_WAKEUPINTSET_Pos = 0xd
	// Bit mask of WAKEUPINTSET field.
	ETHERNET_INTSET_WAKEUPINTSET_Msk = 0x2000
	// Bit WAKEUPINTSET.
	ETHERNET_INTSET_WAKEUPINTSET = 0x2000
	// Position of RESERVED field.
	ETHERNET_INTSET_RESERVED_Pos = 0xe
	// Bit mask of RESERVED field.
	ETHERNET_INTSET_RESERVED_Msk = 0xffffc000

	// POWERDOWN: Power-down register.
	// Position of RESERVED field.
	ETHERNET_POWERDOWN_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	ETHERNET_POWERDOWN_RESERVED_Msk = 0x7fffffff
	// Position of PD field.
	ETHERNET_POWERDOWN_PD_Pos = 0x1f
	// Bit mask of PD field.
	ETHERNET_POWERDOWN_PD_Msk = 0x80000000
	// Bit PD.
	ETHERNET_POWERDOWN_PD = 0x80000000
)

// Constants for LCD: LCD controller Modification
const (
	// TIMH: Horizontal Timing Control register
	// Position of RESERVED field.
	LCD_TIMH_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	LCD_TIMH_RESERVED_Msk = 0x3
	// Position of PPL field.
	LCD_TIMH_PPL_Pos = 0x2
	// Bit mask of PPL field.
	LCD_TIMH_PPL_Msk = 0xfc
	// Position of HSW field.
	LCD_TIMH_HSW_Pos = 0x8
	// Bit mask of HSW field.
	LCD_TIMH_HSW_Msk = 0xff00
	// Position of HFP field.
	LCD_TIMH_HFP_Pos = 0x10
	// Bit mask of HFP field.
	LCD_TIMH_HFP_Msk = 0xff0000
	// Position of HBP field.
	LCD_TIMH_HBP_Pos = 0x18
	// Bit mask of HBP field.
	LCD_TIMH_HBP_Msk = 0xff000000

	// TIMV: Vertical Timing Control register
	// Position of LPP field.
	LCD_TIMV_LPP_Pos = 0x0
	// Bit mask of LPP field.
	LCD_TIMV_LPP_Msk = 0x3ff
	// Position of VSW field.
	LCD_TIMV_VSW_Pos = 0xa
	// Bit mask of VSW field.
	LCD_TIMV_VSW_Msk = 0xfc00
	// Position of VFP field.
	LCD_TIMV_VFP_Pos = 0x10
	// Bit mask of VFP field.
	LCD_TIMV_VFP_Msk = 0xff0000
	// Position of VBP field.
	LCD_TIMV_VBP_Pos = 0x18
	// Bit mask of VBP field.
	LCD_TIMV_VBP_Msk = 0xff000000

	// POL: Clock and Signal Polarity Control register
	// Position of PCD_LO field.
	LCD_POL_PCD_LO_Pos = 0x0
	// Bit mask of PCD_LO field.
	LCD_POL_PCD_LO_Msk = 0x1f
	// Position of CLKSEL field.
	LCD_POL_CLKSEL_Pos = 0x5
	// Bit mask of CLKSEL field.
	LCD_POL_CLKSEL_Msk = 0x20
	// Bit CLKSEL.
	LCD_POL_CLKSEL = 0x20
	// Position of ACB field.
	LCD_POL_ACB_Pos = 0x6
	// Bit mask of ACB field.
	LCD_POL_ACB_Msk = 0x7c0
	// Position of IVS field.
	LCD_POL_IVS_Pos = 0xb
	// Bit mask of IVS field.
	LCD_POL_IVS_Msk = 0x800
	// Bit IVS.
	LCD_POL_IVS = 0x800
	// Position of IHS field.
	LCD_POL_IHS_Pos = 0xc
	// Bit mask of IHS field.
	LCD_POL_IHS_Msk = 0x1000
	// Bit IHS.
	LCD_POL_IHS = 0x1000
	// Position of IPC field.
	LCD_POL_IPC_Pos = 0xd
	// Bit mask of IPC field.
	LCD_POL_IPC_Msk = 0x2000
	// Bit IPC.
	LCD_POL_IPC = 0x2000
	// Position of IOE field.
	LCD_POL_IOE_Pos = 0xe
	// Bit mask of IOE field.
	LCD_POL_IOE_Msk = 0x4000
	// Bit IOE.
	LCD_POL_IOE = 0x4000
	// Position of RESERVED field.
	LCD_POL_RESERVED_Pos = 0xf
	// Bit mask of RESERVED field.
	LCD_POL_RESERVED_Msk = 0x8000
	// Bit RESERVED.
	LCD_POL_RESERVED = 0x8000
	// Position of CPL field.
	LCD_POL_CPL_Pos = 0x10
	// Bit mask of CPL field.
	LCD_POL_CPL_Msk = 0x3ff0000
	// Position of BCD field.
	LCD_POL_BCD_Pos = 0x1a
	// Bit mask of BCD field.
	LCD_POL_BCD_Msk = 0x4000000
	// Bit BCD.
	LCD_POL_BCD = 0x4000000
	// Position of PCD_HI field.
	LCD_POL_PCD_HI_Pos = 0x1b
	// Bit mask of PCD_HI field.
	LCD_POL_PCD_HI_Msk = 0xf8000000

	// LE: Line End Control register
	// Position of LED field.
	LCD_LE_LED_Pos = 0x0
	// Bit mask of LED field.
	LCD_LE_LED_Msk = 0x7f
	// Position of RESERVED field.
	LCD_LE_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	LCD_LE_RESERVED_Msk = 0xff80
	// Position of LEE field.
	LCD_LE_LEE_Pos = 0x10
	// Bit mask of LEE field.
	LCD_LE_LEE_Msk = 0x10000
	// Bit LEE.
	LCD_LE_LEE = 0x10000
	// Position of RESERVED field.
	LCD_LE_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	LCD_LE_RESERVED_Msk = 0xfffe0000

	// UPBASE: Upper Panel Frame Base Address register
	// Position of RESERVED field.
	LCD_UPBASE_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	LCD_UPBASE_RESERVED_Msk = 0x7
	// Position of LCDUPBASE field.
	LCD_UPBASE_LCDUPBASE_Pos = 0x3
	// Bit mask of LCDUPBASE field.
	LCD_UPBASE_LCDUPBASE_Msk = 0xfffffff8

	// LPBASE: Lower Panel Frame Base Address register
	// Position of RESERVED field.
	LCD_LPBASE_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	LCD_LPBASE_RESERVED_Msk = 0x7
	// Position of LCDLPBASE field.
	LCD_LPBASE_LCDLPBASE_Pos = 0x3
	// Bit mask of LCDLPBASE field.
	LCD_LPBASE_LCDLPBASE_Msk = 0xfffffff8

	// CTRL: LCD Control register
	// Position of LCDEN field.
	LCD_CTRL_LCDEN_Pos = 0x0
	// Bit mask of LCDEN field.
	LCD_CTRL_LCDEN_Msk = 0x1
	// Bit LCDEN.
	LCD_CTRL_LCDEN = 0x1
	// Position of LCDBPP field.
	LCD_CTRL_LCDBPP_Pos = 0x1
	// Bit mask of LCDBPP field.
	LCD_CTRL_LCDBPP_Msk = 0xe
	// Position of LCDBW field.
	LCD_CTRL_LCDBW_Pos = 0x4
	// Bit mask of LCDBW field.
	LCD_CTRL_LCDBW_Msk = 0x10
	// Bit LCDBW.
	LCD_CTRL_LCDBW = 0x10
	// Position of LCDTFT field.
	LCD_CTRL_LCDTFT_Pos = 0x5
	// Bit mask of LCDTFT field.
	LCD_CTRL_LCDTFT_Msk = 0x20
	// Bit LCDTFT.
	LCD_CTRL_LCDTFT = 0x20
	// Position of LCDMONO8 field.
	LCD_CTRL_LCDMONO8_Pos = 0x6
	// Bit mask of LCDMONO8 field.
	LCD_CTRL_LCDMONO8_Msk = 0x40
	// Bit LCDMONO8.
	LCD_CTRL_LCDMONO8 = 0x40
	// Position of LCDDUAL field.
	LCD_CTRL_LCDDUAL_Pos = 0x7
	// Bit mask of LCDDUAL field.
	LCD_CTRL_LCDDUAL_Msk = 0x80
	// Bit LCDDUAL.
	LCD_CTRL_LCDDUAL = 0x80
	// Position of BGR field.
	LCD_CTRL_BGR_Pos = 0x8
	// Bit mask of BGR field.
	LCD_CTRL_BGR_Msk = 0x100
	// Bit BGR.
	LCD_CTRL_BGR = 0x100
	// Position of BEBO field.
	LCD_CTRL_BEBO_Pos = 0x9
	// Bit mask of BEBO field.
	LCD_CTRL_BEBO_Msk = 0x200
	// Bit BEBO.
	LCD_CTRL_BEBO = 0x200
	// Position of BEPO field.
	LCD_CTRL_BEPO_Pos = 0xa
	// Bit mask of BEPO field.
	LCD_CTRL_BEPO_Msk = 0x400
	// Bit BEPO.
	LCD_CTRL_BEPO = 0x400
	// Position of LCDPWR field.
	LCD_CTRL_LCDPWR_Pos = 0xb
	// Bit mask of LCDPWR field.
	LCD_CTRL_LCDPWR_Msk = 0x800
	// Bit LCDPWR.
	LCD_CTRL_LCDPWR = 0x800
	// Position of LCDVCOMP field.
	LCD_CTRL_LCDVCOMP_Pos = 0xc
	// Bit mask of LCDVCOMP field.
	LCD_CTRL_LCDVCOMP_Msk = 0x3000
	// Position of RESERVED field.
	LCD_CTRL_RESERVED_Pos = 0xe
	// Bit mask of RESERVED field.
	LCD_CTRL_RESERVED_Msk = 0xc000
	// Position of WATERMARK field.
	LCD_CTRL_WATERMARK_Pos = 0x10
	// Bit mask of WATERMARK field.
	LCD_CTRL_WATERMARK_Msk = 0x10000
	// Bit WATERMARK.
	LCD_CTRL_WATERMARK = 0x10000
	// Position of RESERVED field.
	LCD_CTRL_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	LCD_CTRL_RESERVED_Msk = 0xfffe0000

	// INTMSK: Interrupt Mask register
	// Position of RESERVED field.
	LCD_INTMSK_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	LCD_INTMSK_RESERVED_Msk = 0x1
	// Bit RESERVED.
	LCD_INTMSK_RESERVED = 0x1
	// Position of FUFIM field.
	LCD_INTMSK_FUFIM_Pos = 0x1
	// Bit mask of FUFIM field.
	LCD_INTMSK_FUFIM_Msk = 0x2
	// Bit FUFIM.
	LCD_INTMSK_FUFIM = 0x2
	// Position of LNBUIM field.
	LCD_INTMSK_LNBUIM_Pos = 0x2
	// Bit mask of LNBUIM field.
	LCD_INTMSK_LNBUIM_Msk = 0x4
	// Bit LNBUIM.
	LCD_INTMSK_LNBUIM = 0x4
	// Position of VCOMPIM field.
	LCD_INTMSK_VCOMPIM_Pos = 0x3
	// Bit mask of VCOMPIM field.
	LCD_INTMSK_VCOMPIM_Msk = 0x8
	// Bit VCOMPIM.
	LCD_INTMSK_VCOMPIM = 0x8
	// Position of BERIM field.
	LCD_INTMSK_BERIM_Pos = 0x4
	// Bit mask of BERIM field.
	LCD_INTMSK_BERIM_Msk = 0x10
	// Bit BERIM.
	LCD_INTMSK_BERIM = 0x10
	// Position of RESERVED field.
	LCD_INTMSK_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	LCD_INTMSK_RESERVED_Msk = 0xffffffe0

	// INTRAW: Raw Interrupt Status register
	// Position of RESERVED field.
	LCD_INTRAW_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	LCD_INTRAW_RESERVED_Msk = 0x1
	// Bit RESERVED.
	LCD_INTRAW_RESERVED = 0x1
	// Position of FUFRIS field.
	LCD_INTRAW_FUFRIS_Pos = 0x1
	// Bit mask of FUFRIS field.
	LCD_INTRAW_FUFRIS_Msk = 0x2
	// Bit FUFRIS.
	LCD_INTRAW_FUFRIS = 0x2
	// Position of LNBURIS field.
	LCD_INTRAW_LNBURIS_Pos = 0x2
	// Bit mask of LNBURIS field.
	LCD_INTRAW_LNBURIS_Msk = 0x4
	// Bit LNBURIS.
	LCD_INTRAW_LNBURIS = 0x4
	// Position of VCOMPRIS field.
	LCD_INTRAW_VCOMPRIS_Pos = 0x3
	// Bit mask of VCOMPRIS field.
	LCD_INTRAW_VCOMPRIS_Msk = 0x8
	// Bit VCOMPRIS.
	LCD_INTRAW_VCOMPRIS = 0x8
	// Position of BERRAW field.
	LCD_INTRAW_BERRAW_Pos = 0x4
	// Bit mask of BERRAW field.
	LCD_INTRAW_BERRAW_Msk = 0x10
	// Bit BERRAW.
	LCD_INTRAW_BERRAW = 0x10
	// Position of RESERVED field.
	LCD_INTRAW_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	LCD_INTRAW_RESERVED_Msk = 0xffffffe0

	// INTSTAT: Masked Interrupt Status register
	// Position of RESERVED field.
	LCD_INTSTAT_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	LCD_INTSTAT_RESERVED_Msk = 0x1
	// Bit RESERVED.
	LCD_INTSTAT_RESERVED = 0x1
	// Position of FUFMIS field.
	LCD_INTSTAT_FUFMIS_Pos = 0x1
	// Bit mask of FUFMIS field.
	LCD_INTSTAT_FUFMIS_Msk = 0x2
	// Bit FUFMIS.
	LCD_INTSTAT_FUFMIS = 0x2
	// Position of LNBUMIS field.
	LCD_INTSTAT_LNBUMIS_Pos = 0x2
	// Bit mask of LNBUMIS field.
	LCD_INTSTAT_LNBUMIS_Msk = 0x4
	// Bit LNBUMIS.
	LCD_INTSTAT_LNBUMIS = 0x4
	// Position of VCOMPMIS field.
	LCD_INTSTAT_VCOMPMIS_Pos = 0x3
	// Bit mask of VCOMPMIS field.
	LCD_INTSTAT_VCOMPMIS_Msk = 0x8
	// Bit VCOMPMIS.
	LCD_INTSTAT_VCOMPMIS = 0x8
	// Position of BERMIS field.
	LCD_INTSTAT_BERMIS_Pos = 0x4
	// Bit mask of BERMIS field.
	LCD_INTSTAT_BERMIS_Msk = 0x10
	// Bit BERMIS.
	LCD_INTSTAT_BERMIS = 0x10
	// Position of RESERVED field.
	LCD_INTSTAT_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	LCD_INTSTAT_RESERVED_Msk = 0xffffffe0

	// INTCLR: Interrupt Clear register
	// Position of RESERVED field.
	LCD_INTCLR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	LCD_INTCLR_RESERVED_Msk = 0x1
	// Bit RESERVED.
	LCD_INTCLR_RESERVED = 0x1
	// Position of FUFIC field.
	LCD_INTCLR_FUFIC_Pos = 0x1
	// Bit mask of FUFIC field.
	LCD_INTCLR_FUFIC_Msk = 0x2
	// Bit FUFIC.
	LCD_INTCLR_FUFIC = 0x2
	// Position of LNBUIC field.
	LCD_INTCLR_LNBUIC_Pos = 0x2
	// Bit mask of LNBUIC field.
	LCD_INTCLR_LNBUIC_Msk = 0x4
	// Bit LNBUIC.
	LCD_INTCLR_LNBUIC = 0x4
	// Position of VCOMPIC field.
	LCD_INTCLR_VCOMPIC_Pos = 0x3
	// Bit mask of VCOMPIC field.
	LCD_INTCLR_VCOMPIC_Msk = 0x8
	// Bit VCOMPIC.
	LCD_INTCLR_VCOMPIC = 0x8
	// Position of BERIC field.
	LCD_INTCLR_BERIC_Pos = 0x4
	// Bit mask of BERIC field.
	LCD_INTCLR_BERIC_Msk = 0x10
	// Bit BERIC.
	LCD_INTCLR_BERIC = 0x10
	// Position of RESERVED field.
	LCD_INTCLR_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	LCD_INTCLR_RESERVED_Msk = 0xffffffe0

	// UPCURR: Upper Panel Current Address Value register
	// Position of LCDUPCURR field.
	LCD_UPCURR_LCDUPCURR_Pos = 0x0
	// Bit mask of LCDUPCURR field.
	LCD_UPCURR_LCDUPCURR_Msk = 0xffffffff

	// LPCURR: Lower Panel Current Address Value register
	// Position of LCDLPCURR field.
	LCD_LPCURR_LCDLPCURR_Pos = 0x0
	// Bit mask of LCDLPCURR field.
	LCD_LPCURR_LCDLPCURR_Msk = 0xffffffff

	// PAL: 256x16-bit Color Palette registers
	// Position of R04_0 field.
	LCD_PAL_R04_0_Pos = 0x0
	// Bit mask of R04_0 field.
	LCD_PAL_R04_0_Msk = 0x1f
	// Position of G04_0 field.
	LCD_PAL_G04_0_Pos = 0x5
	// Bit mask of G04_0 field.
	LCD_PAL_G04_0_Msk = 0x3e0
	// Position of B04_0 field.
	LCD_PAL_B04_0_Pos = 0xa
	// Bit mask of B04_0 field.
	LCD_PAL_B04_0_Msk = 0x7c00
	// Position of I0 field.
	LCD_PAL_I0_Pos = 0xf
	// Bit mask of I0 field.
	LCD_PAL_I0_Msk = 0x8000
	// Bit I0.
	LCD_PAL_I0 = 0x8000
	// Position of R14_0 field.
	LCD_PAL_R14_0_Pos = 0x10
	// Bit mask of R14_0 field.
	LCD_PAL_R14_0_Msk = 0x1f0000
	// Position of G14_0 field.
	LCD_PAL_G14_0_Pos = 0x15
	// Bit mask of G14_0 field.
	LCD_PAL_G14_0_Msk = 0x3e00000
	// Position of B14_0 field.
	LCD_PAL_B14_0_Pos = 0x1a
	// Bit mask of B14_0 field.
	LCD_PAL_B14_0_Msk = 0x7c000000
	// Position of I1 field.
	LCD_PAL_I1_Pos = 0x1f
	// Bit mask of I1 field.
	LCD_PAL_I1_Msk = 0x80000000
	// Bit I1.
	LCD_PAL_I1 = 0x80000000

	// CRSR_IMG: Cursor Image registers
	// Position of CRSR_IMG field.
	LCD_CRSR_IMG_CRSR_IMG_Pos = 0x0
	// Bit mask of CRSR_IMG field.
	LCD_CRSR_IMG_CRSR_IMG_Msk = 0xffffffff

	// CRSR_CTRL: Cursor Control register
	// Position of CRSRON field.
	LCD_CRSR_CTRL_CRSRON_Pos = 0x0
	// Bit mask of CRSRON field.
	LCD_CRSR_CTRL_CRSRON_Msk = 0x1
	// Bit CRSRON.
	LCD_CRSR_CTRL_CRSRON = 0x1
	// Position of RESERVED field.
	LCD_CRSR_CTRL_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	LCD_CRSR_CTRL_RESERVED_Msk = 0xe
	// Position of CRSRNUM1_0 field.
	LCD_CRSR_CTRL_CRSRNUM1_0_Pos = 0x4
	// Bit mask of CRSRNUM1_0 field.
	LCD_CRSR_CTRL_CRSRNUM1_0_Msk = 0x30
	// Position of RESERVED field.
	LCD_CRSR_CTRL_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	LCD_CRSR_CTRL_RESERVED_Msk = 0xffffffc0

	// CRSR_CFG: Cursor Configuration register
	// Position of CRSRSIZE field.
	LCD_CRSR_CFG_CRSRSIZE_Pos = 0x0
	// Bit mask of CRSRSIZE field.
	LCD_CRSR_CFG_CRSRSIZE_Msk = 0x1
	// Bit CRSRSIZE.
	LCD_CRSR_CFG_CRSRSIZE = 0x1
	// Position of FRAMESYNC field.
	LCD_CRSR_CFG_FRAMESYNC_Pos = 0x1
	// Bit mask of FRAMESYNC field.
	LCD_CRSR_CFG_FRAMESYNC_Msk = 0x2
	// Bit FRAMESYNC.
	LCD_CRSR_CFG_FRAMESYNC = 0x2
	// Position of RESERVED field.
	LCD_CRSR_CFG_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	LCD_CRSR_CFG_RESERVED_Msk = 0xfffffffc

	// CRSR_PAL0: Cursor Palette register 0
	// Position of RED field.
	LCD_CRSR_PAL0_RED_Pos = 0x0
	// Bit mask of RED field.
	LCD_CRSR_PAL0_RED_Msk = 0xff
	// Position of GREEN field.
	LCD_CRSR_PAL0_GREEN_Pos = 0x8
	// Bit mask of GREEN field.
	LCD_CRSR_PAL0_GREEN_Msk = 0xff00
	// Position of BLUE field.
	LCD_CRSR_PAL0_BLUE_Pos = 0x10
	// Bit mask of BLUE field.
	LCD_CRSR_PAL0_BLUE_Msk = 0xff0000
	// Position of RESERVED field.
	LCD_CRSR_PAL0_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	LCD_CRSR_PAL0_RESERVED_Msk = 0xff000000

	// CRSR_PAL1: Cursor Palette register 1
	// Position of RED field.
	LCD_CRSR_PAL1_RED_Pos = 0x0
	// Bit mask of RED field.
	LCD_CRSR_PAL1_RED_Msk = 0xff
	// Position of GREEN field.
	LCD_CRSR_PAL1_GREEN_Pos = 0x8
	// Bit mask of GREEN field.
	LCD_CRSR_PAL1_GREEN_Msk = 0xff00
	// Position of BLUE field.
	LCD_CRSR_PAL1_BLUE_Pos = 0x10
	// Bit mask of BLUE field.
	LCD_CRSR_PAL1_BLUE_Msk = 0xff0000
	// Position of RESERVED field.
	LCD_CRSR_PAL1_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	LCD_CRSR_PAL1_RESERVED_Msk = 0xff000000

	// CRSR_XY: Cursor XY Position register
	// Position of CRSRX field.
	LCD_CRSR_XY_CRSRX_Pos = 0x0
	// Bit mask of CRSRX field.
	LCD_CRSR_XY_CRSRX_Msk = 0x3ff
	// Position of RESERVED field.
	LCD_CRSR_XY_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	LCD_CRSR_XY_RESERVED_Msk = 0xfc00
	// Position of CRSRY field.
	LCD_CRSR_XY_CRSRY_Pos = 0x10
	// Bit mask of CRSRY field.
	LCD_CRSR_XY_CRSRY_Msk = 0x3ff0000
	// Position of RESERVED field.
	LCD_CRSR_XY_RESERVED_Pos = 0x1a
	// Bit mask of RESERVED field.
	LCD_CRSR_XY_RESERVED_Msk = 0xfc000000

	// CRSR_CLIP: Cursor Clip Position register
	// Position of CRSRCLIPX field.
	LCD_CRSR_CLIP_CRSRCLIPX_Pos = 0x0
	// Bit mask of CRSRCLIPX field.
	LCD_CRSR_CLIP_CRSRCLIPX_Msk = 0x3f
	// Position of RESERVED field.
	LCD_CRSR_CLIP_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	LCD_CRSR_CLIP_RESERVED_Msk = 0xc0
	// Position of CRSRCLIPY field.
	LCD_CRSR_CLIP_CRSRCLIPY_Pos = 0x8
	// Bit mask of CRSRCLIPY field.
	LCD_CRSR_CLIP_CRSRCLIPY_Msk = 0x3f00
	// Position of RESERVED field.
	LCD_CRSR_CLIP_RESERVED_Pos = 0xe
	// Bit mask of RESERVED field.
	LCD_CRSR_CLIP_RESERVED_Msk = 0xffffc000

	// CRSR_INTMSK: Cursor Interrupt Mask register
	// Position of CRSRIM field.
	LCD_CRSR_INTMSK_CRSRIM_Pos = 0x0
	// Bit mask of CRSRIM field.
	LCD_CRSR_INTMSK_CRSRIM_Msk = 0x1
	// Bit CRSRIM.
	LCD_CRSR_INTMSK_CRSRIM = 0x1
	// Position of RESERVED field.
	LCD_CRSR_INTMSK_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	LCD_CRSR_INTMSK_RESERVED_Msk = 0xfffffffe

	// CRSR_INTCLR: Cursor Interrupt Clear register
	// Position of CRSRIC field.
	LCD_CRSR_INTCLR_CRSRIC_Pos = 0x0
	// Bit mask of CRSRIC field.
	LCD_CRSR_INTCLR_CRSRIC_Msk = 0x1
	// Bit CRSRIC.
	LCD_CRSR_INTCLR_CRSRIC = 0x1
	// Position of RESERVED field.
	LCD_CRSR_INTCLR_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	LCD_CRSR_INTCLR_RESERVED_Msk = 0xfffffffe

	// CRSR_INTRAW: Cursor Raw Interrupt Status register
	// Position of CRSRRIS field.
	LCD_CRSR_INTRAW_CRSRRIS_Pos = 0x0
	// Bit mask of CRSRRIS field.
	LCD_CRSR_INTRAW_CRSRRIS_Msk = 0x1
	// Bit CRSRRIS.
	LCD_CRSR_INTRAW_CRSRRIS = 0x1
	// Position of RESERVED field.
	LCD_CRSR_INTRAW_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	LCD_CRSR_INTRAW_RESERVED_Msk = 0xfffffffe

	// CRSR_INTSTAT: Cursor Masked Interrupt Status register
	// Position of CRSRMIS field.
	LCD_CRSR_INTSTAT_CRSRMIS_Pos = 0x0
	// Bit mask of CRSRMIS field.
	LCD_CRSR_INTSTAT_CRSRMIS_Msk = 0x1
	// Bit CRSRMIS.
	LCD_CRSR_INTSTAT_CRSRMIS = 0x1
	// Position of RESERVED field.
	LCD_CRSR_INTSTAT_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	LCD_CRSR_INTSTAT_RESERVED_Msk = 0xfffffffe
)

// Constants for USB: USB device controller
const (
	// RXPLEN: USB Receive Packet Length
	// Position of PKT_LNGTH field.
	USB_RXPLEN_PKT_LNGTH_Pos = 0x0
	// Bit mask of PKT_LNGTH field.
	USB_RXPLEN_PKT_LNGTH_Msk = 0x3ff
	// Position of DV field.
	USB_RXPLEN_DV_Pos = 0xa
	// Bit mask of DV field.
	USB_RXPLEN_DV_Msk = 0x400
	// Bit DV.
	USB_RXPLEN_DV = 0x400
	// Data is invalid.
	USB_RXPLEN_DV_DATA_IS_INVALID_ = 0x0
	// Data is valid.
	USB_RXPLEN_DV_DATA_IS_VALID_ = 0x1
	// Position of PKT_RDY field.
	USB_RXPLEN_PKT_RDY_Pos = 0xb
	// Bit mask of PKT_RDY field.
	USB_RXPLEN_PKT_RDY_Msk = 0x800
	// Bit PKT_RDY.
	USB_RXPLEN_PKT_RDY = 0x800
	// Position of RESERVED field.
	USB_RXPLEN_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	USB_RXPLEN_RESERVED_Msk = 0xfffff000

	// INTST: OTG Interrupt Status
	// Position of TMR field.
	USB_INTST_TMR_Pos = 0x0
	// Bit mask of TMR field.
	USB_INTST_TMR_Msk = 0x1
	// Bit TMR.
	USB_INTST_TMR = 0x1
	// Position of REMOVE_PU field.
	USB_INTST_REMOVE_PU_Pos = 0x1
	// Bit mask of REMOVE_PU field.
	USB_INTST_REMOVE_PU_Msk = 0x2
	// Bit REMOVE_PU.
	USB_INTST_REMOVE_PU = 0x2
	// Position of HNP_FAILURE field.
	USB_INTST_HNP_FAILURE_Pos = 0x2
	// Bit mask of HNP_FAILURE field.
	USB_INTST_HNP_FAILURE_Msk = 0x4
	// Bit HNP_FAILURE.
	USB_INTST_HNP_FAILURE = 0x4
	// Position of HNP_SUCCESS field.
	USB_INTST_HNP_SUCCESS_Pos = 0x3
	// Bit mask of HNP_SUCCESS field.
	USB_INTST_HNP_SUCCESS_Msk = 0x8
	// Bit HNP_SUCCESS.
	USB_INTST_HNP_SUCCESS = 0x8
	// Position of RESERVED field.
	USB_INTST_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USB_INTST_RESERVED_Msk = 0xfffffff0

	// INTEN: OTG Interrupt Enable
	// Position of TMR_EN field.
	USB_INTEN_TMR_EN_Pos = 0x0
	// Bit mask of TMR_EN field.
	USB_INTEN_TMR_EN_Msk = 0x1
	// Bit TMR_EN.
	USB_INTEN_TMR_EN = 0x1
	// Position of REMOVE_PU_EN field.
	USB_INTEN_REMOVE_PU_EN_Pos = 0x1
	// Bit mask of REMOVE_PU_EN field.
	USB_INTEN_REMOVE_PU_EN_Msk = 0x2
	// Bit REMOVE_PU_EN.
	USB_INTEN_REMOVE_PU_EN = 0x2
	// Position of HNP_FAILURE_EN field.
	USB_INTEN_HNP_FAILURE_EN_Pos = 0x2
	// Bit mask of HNP_FAILURE_EN field.
	USB_INTEN_HNP_FAILURE_EN_Msk = 0x4
	// Bit HNP_FAILURE_EN.
	USB_INTEN_HNP_FAILURE_EN = 0x4
	// Position of HNP_SUCCES_EN field.
	USB_INTEN_HNP_SUCCES_EN_Pos = 0x3
	// Bit mask of HNP_SUCCES_EN field.
	USB_INTEN_HNP_SUCCES_EN_Msk = 0x8
	// Bit HNP_SUCCES_EN.
	USB_INTEN_HNP_SUCCES_EN = 0x8
	// Position of RESERVED field.
	USB_INTEN_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USB_INTEN_RESERVED_Msk = 0xfffffff0

	// INTSET: OTG Interrupt Set
	// Position of TMR_SET field.
	USB_INTSET_TMR_SET_Pos = 0x0
	// Bit mask of TMR_SET field.
	USB_INTSET_TMR_SET_Msk = 0x1
	// Bit TMR_SET.
	USB_INTSET_TMR_SET = 0x1
	// Position of REMOVE_PU_SET field.
	USB_INTSET_REMOVE_PU_SET_Pos = 0x1
	// Bit mask of REMOVE_PU_SET field.
	USB_INTSET_REMOVE_PU_SET_Msk = 0x2
	// Bit REMOVE_PU_SET.
	USB_INTSET_REMOVE_PU_SET = 0x2
	// Position of HNP_FAILURE_SET field.
	USB_INTSET_HNP_FAILURE_SET_Pos = 0x2
	// Bit mask of HNP_FAILURE_SET field.
	USB_INTSET_HNP_FAILURE_SET_Msk = 0x4
	// Bit HNP_FAILURE_SET.
	USB_INTSET_HNP_FAILURE_SET = 0x4
	// Position of HNP_SUCCES_SET field.
	USB_INTSET_HNP_SUCCES_SET_Pos = 0x3
	// Bit mask of HNP_SUCCES_SET field.
	USB_INTSET_HNP_SUCCES_SET_Msk = 0x8
	// Bit HNP_SUCCES_SET.
	USB_INTSET_HNP_SUCCES_SET = 0x8
	// Position of RESERVED field.
	USB_INTSET_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USB_INTSET_RESERVED_Msk = 0xfffffff0

	// INCLR: OTG Interrupt Clear
	// Position of TMR_CLR field.
	USB_INCLR_TMR_CLR_Pos = 0x0
	// Bit mask of TMR_CLR field.
	USB_INCLR_TMR_CLR_Msk = 0x1
	// Bit TMR_CLR.
	USB_INCLR_TMR_CLR = 0x1
	// Position of REMOVE_PU_CLR field.
	USB_INCLR_REMOVE_PU_CLR_Pos = 0x1
	// Bit mask of REMOVE_PU_CLR field.
	USB_INCLR_REMOVE_PU_CLR_Msk = 0x2
	// Bit REMOVE_PU_CLR.
	USB_INCLR_REMOVE_PU_CLR = 0x2
	// Position of HNP_FAILURE_CLR field.
	USB_INCLR_HNP_FAILURE_CLR_Pos = 0x2
	// Bit mask of HNP_FAILURE_CLR field.
	USB_INCLR_HNP_FAILURE_CLR_Msk = 0x4
	// Bit HNP_FAILURE_CLR.
	USB_INCLR_HNP_FAILURE_CLR = 0x4
	// Position of HNP_SUCCES_CLR field.
	USB_INCLR_HNP_SUCCES_CLR_Pos = 0x3
	// Bit mask of HNP_SUCCES_CLR field.
	USB_INCLR_HNP_SUCCES_CLR_Msk = 0x8
	// Bit HNP_SUCCES_CLR.
	USB_INCLR_HNP_SUCCES_CLR = 0x8
	// Position of RESERVED field.
	USB_INCLR_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	USB_INCLR_RESERVED_Msk = 0xfffffff0

	// PORTSEL: USB Port Select. The USBPortSel register is identical to the OTGStCtrl register (see Section 15.8.6). In device-only operations only bits 0 and 1 of this register are used to control the routing of USB pins to Port 1 or Port 2.
	// Position of PORTSEL field.
	USB_PORTSEL_PORTSEL_Pos = 0x0
	// Bit mask of PORTSEL field.
	USB_PORTSEL_PORTSEL_Msk = 0x3
	// The USB device controller signals are mapped to the U1 port: USB_CONNECT1, USB_UP_LED1, USB_D+1, USB_D-1.
	USB_PORTSEL_PORTSEL_PORTU1 = 0x0
	// The USB device controller signals are mapped to the U2 port: USB_CONNECT2, USB_UP_LED2, USB_D+2, USB_D-2.
	USB_PORTSEL_PORTSEL_PORTU2 = 0x3
	// Position of TMR_SCALE field.
	USB_PORTSEL_TMR_SCALE_Pos = 0x2
	// Bit mask of TMR_SCALE field.
	USB_PORTSEL_TMR_SCALE_Msk = 0xc
	// Position of TMR_MODE field.
	USB_PORTSEL_TMR_MODE_Pos = 0x4
	// Bit mask of TMR_MODE field.
	USB_PORTSEL_TMR_MODE_Msk = 0x10
	// Bit TMR_MODE.
	USB_PORTSEL_TMR_MODE = 0x10
	// Position of TMR_EN field.
	USB_PORTSEL_TMR_EN_Pos = 0x5
	// Bit mask of TMR_EN field.
	USB_PORTSEL_TMR_EN_Msk = 0x20
	// Bit TMR_EN.
	USB_PORTSEL_TMR_EN = 0x20
	// Position of TMR_RST field.
	USB_PORTSEL_TMR_RST_Pos = 0x6
	// Bit mask of TMR_RST field.
	USB_PORTSEL_TMR_RST_Msk = 0x40
	// Bit TMR_RST.
	USB_PORTSEL_TMR_RST = 0x40
	// Position of RESERVED field.
	USB_PORTSEL_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	USB_PORTSEL_RESERVED_Msk = 0x80
	// Bit RESERVED.
	USB_PORTSEL_RESERVED = 0x80
	// Position of B_HNP_TRACK field.
	USB_PORTSEL_B_HNP_TRACK_Pos = 0x8
	// Bit mask of B_HNP_TRACK field.
	USB_PORTSEL_B_HNP_TRACK_Msk = 0x100
	// Bit B_HNP_TRACK.
	USB_PORTSEL_B_HNP_TRACK = 0x100
	// Position of A_HNP_TRACK field.
	USB_PORTSEL_A_HNP_TRACK_Pos = 0x9
	// Bit mask of A_HNP_TRACK field.
	USB_PORTSEL_A_HNP_TRACK_Msk = 0x200
	// Bit A_HNP_TRACK.
	USB_PORTSEL_A_HNP_TRACK = 0x200
	// Position of PU_REMOVED field.
	USB_PORTSEL_PU_REMOVED_Pos = 0xa
	// Bit mask of PU_REMOVED field.
	USB_PORTSEL_PU_REMOVED_Msk = 0x400
	// Bit PU_REMOVED.
	USB_PORTSEL_PU_REMOVED = 0x400
	// Position of RESERVED field.
	USB_PORTSEL_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	USB_PORTSEL_RESERVED_Msk = 0xf800
	// Position of TMR_CNT field.
	USB_PORTSEL_TMR_CNT_Pos = 0x10
	// Bit mask of TMR_CNT field.
	USB_PORTSEL_TMR_CNT_Msk = 0xffff0000
	// Position of RESERVED field.
	USB_PORTSEL_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	USB_PORTSEL_RESERVED_Msk = 0xfffffffc

	// TMR: OTG Timer
	// Position of TIMEOUT_CNT field.
	USB_TMR_TIMEOUT_CNT_Pos = 0x0
	// Bit mask of TIMEOUT_CNT field.
	USB_TMR_TIMEOUT_CNT_Msk = 0xffff
	// Position of RESERVED field.
	USB_TMR_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	USB_TMR_RESERVED_Msk = 0xffff0000

	// DEVINTST: USB Device Interrupt Status
	// Position of FRAME field.
	USB_DEVINTST_FRAME_Pos = 0x0
	// Bit mask of FRAME field.
	USB_DEVINTST_FRAME_Msk = 0x1
	// Bit FRAME.
	USB_DEVINTST_FRAME = 0x1
	// Position of EP_FAST field.
	USB_DEVINTST_EP_FAST_Pos = 0x1
	// Bit mask of EP_FAST field.
	USB_DEVINTST_EP_FAST_Msk = 0x2
	// Bit EP_FAST.
	USB_DEVINTST_EP_FAST = 0x2
	// Position of EP_SLOW field.
	USB_DEVINTST_EP_SLOW_Pos = 0x2
	// Bit mask of EP_SLOW field.
	USB_DEVINTST_EP_SLOW_Msk = 0x4
	// Bit EP_SLOW.
	USB_DEVINTST_EP_SLOW = 0x4
	// Position of DEV_STAT field.
	USB_DEVINTST_DEV_STAT_Pos = 0x3
	// Bit mask of DEV_STAT field.
	USB_DEVINTST_DEV_STAT_Msk = 0x8
	// Bit DEV_STAT.
	USB_DEVINTST_DEV_STAT = 0x8
	// Position of CCEMPTY field.
	USB_DEVINTST_CCEMPTY_Pos = 0x4
	// Bit mask of CCEMPTY field.
	USB_DEVINTST_CCEMPTY_Msk = 0x10
	// Bit CCEMPTY.
	USB_DEVINTST_CCEMPTY = 0x10
	// Position of CDFULL field.
	USB_DEVINTST_CDFULL_Pos = 0x5
	// Bit mask of CDFULL field.
	USB_DEVINTST_CDFULL_Msk = 0x20
	// Bit CDFULL.
	USB_DEVINTST_CDFULL = 0x20
	// Position of RxENDPKT field.
	USB_DEVINTST_RxENDPKT_Pos = 0x6
	// Bit mask of RxENDPKT field.
	USB_DEVINTST_RxENDPKT_Msk = 0x40
	// Bit RxENDPKT.
	USB_DEVINTST_RxENDPKT = 0x40
	// Position of TxENDPKT field.
	USB_DEVINTST_TxENDPKT_Pos = 0x7
	// Bit mask of TxENDPKT field.
	USB_DEVINTST_TxENDPKT_Msk = 0x80
	// Bit TxENDPKT.
	USB_DEVINTST_TxENDPKT = 0x80
	// Position of EP_RLZED field.
	USB_DEVINTST_EP_RLZED_Pos = 0x8
	// Bit mask of EP_RLZED field.
	USB_DEVINTST_EP_RLZED_Msk = 0x100
	// Bit EP_RLZED.
	USB_DEVINTST_EP_RLZED = 0x100
	// Position of ERR_INT field.
	USB_DEVINTST_ERR_INT_Pos = 0x9
	// Bit mask of ERR_INT field.
	USB_DEVINTST_ERR_INT_Msk = 0x200
	// Bit ERR_INT.
	USB_DEVINTST_ERR_INT = 0x200
	// Position of RESERVED field.
	USB_DEVINTST_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	USB_DEVINTST_RESERVED_Msk = 0xfffffc00

	// DEVINTEN: USB Device Interrupt Enable
	// Position of FRAMEEN field.
	USB_DEVINTEN_FRAMEEN_Pos = 0x0
	// Bit mask of FRAMEEN field.
	USB_DEVINTEN_FRAMEEN_Msk = 0x1
	// Bit FRAMEEN.
	USB_DEVINTEN_FRAMEEN = 0x1
	// Position of EP_FASTEN field.
	USB_DEVINTEN_EP_FASTEN_Pos = 0x1
	// Bit mask of EP_FASTEN field.
	USB_DEVINTEN_EP_FASTEN_Msk = 0x2
	// Bit EP_FASTEN.
	USB_DEVINTEN_EP_FASTEN = 0x2
	// Position of EP_SLOWEN field.
	USB_DEVINTEN_EP_SLOWEN_Pos = 0x2
	// Bit mask of EP_SLOWEN field.
	USB_DEVINTEN_EP_SLOWEN_Msk = 0x4
	// Bit EP_SLOWEN.
	USB_DEVINTEN_EP_SLOWEN = 0x4
	// Position of DEV_STATEN field.
	USB_DEVINTEN_DEV_STATEN_Pos = 0x3
	// Bit mask of DEV_STATEN field.
	USB_DEVINTEN_DEV_STATEN_Msk = 0x8
	// Bit DEV_STATEN.
	USB_DEVINTEN_DEV_STATEN = 0x8
	// Position of CCEMPTYEN field.
	USB_DEVINTEN_CCEMPTYEN_Pos = 0x4
	// Bit mask of CCEMPTYEN field.
	USB_DEVINTEN_CCEMPTYEN_Msk = 0x10
	// Bit CCEMPTYEN.
	USB_DEVINTEN_CCEMPTYEN = 0x10
	// Position of CDFULLEN field.
	USB_DEVINTEN_CDFULLEN_Pos = 0x5
	// Bit mask of CDFULLEN field.
	USB_DEVINTEN_CDFULLEN_Msk = 0x20
	// Bit CDFULLEN.
	USB_DEVINTEN_CDFULLEN = 0x20
	// Position of RxENDPKTEN field.
	USB_DEVINTEN_RxENDPKTEN_Pos = 0x6
	// Bit mask of RxENDPKTEN field.
	USB_DEVINTEN_RxENDPKTEN_Msk = 0x40
	// Bit RxENDPKTEN.
	USB_DEVINTEN_RxENDPKTEN = 0x40
	// Position of TxENDPKTEN field.
	USB_DEVINTEN_TxENDPKTEN_Pos = 0x7
	// Bit mask of TxENDPKTEN field.
	USB_DEVINTEN_TxENDPKTEN_Msk = 0x80
	// Bit TxENDPKTEN.
	USB_DEVINTEN_TxENDPKTEN = 0x80
	// Position of EP_RLZEDEN field.
	USB_DEVINTEN_EP_RLZEDEN_Pos = 0x8
	// Bit mask of EP_RLZEDEN field.
	USB_DEVINTEN_EP_RLZEDEN_Msk = 0x100
	// Bit EP_RLZEDEN.
	USB_DEVINTEN_EP_RLZEDEN = 0x100
	// Position of ERR_INTEN field.
	USB_DEVINTEN_ERR_INTEN_Pos = 0x9
	// Bit mask of ERR_INTEN field.
	USB_DEVINTEN_ERR_INTEN_Msk = 0x200
	// Bit ERR_INTEN.
	USB_DEVINTEN_ERR_INTEN = 0x200
	// Position of RESERVED field.
	USB_DEVINTEN_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	USB_DEVINTEN_RESERVED_Msk = 0xfffffc00

	// DEVINTCLR: USB Device Interrupt Clear
	// Position of FRAMECLR field.
	USB_DEVINTCLR_FRAMECLR_Pos = 0x0
	// Bit mask of FRAMECLR field.
	USB_DEVINTCLR_FRAMECLR_Msk = 0x1
	// Bit FRAMECLR.
	USB_DEVINTCLR_FRAMECLR = 0x1
	// Position of EP_FASTCLR field.
	USB_DEVINTCLR_EP_FASTCLR_Pos = 0x1
	// Bit mask of EP_FASTCLR field.
	USB_DEVINTCLR_EP_FASTCLR_Msk = 0x2
	// Bit EP_FASTCLR.
	USB_DEVINTCLR_EP_FASTCLR = 0x2
	// Position of EP_SLOWCLR field.
	USB_DEVINTCLR_EP_SLOWCLR_Pos = 0x2
	// Bit mask of EP_SLOWCLR field.
	USB_DEVINTCLR_EP_SLOWCLR_Msk = 0x4
	// Bit EP_SLOWCLR.
	USB_DEVINTCLR_EP_SLOWCLR = 0x4
	// Position of DEV_STATCLR field.
	USB_DEVINTCLR_DEV_STATCLR_Pos = 0x3
	// Bit mask of DEV_STATCLR field.
	USB_DEVINTCLR_DEV_STATCLR_Msk = 0x8
	// Bit DEV_STATCLR.
	USB_DEVINTCLR_DEV_STATCLR = 0x8
	// Position of CCEMPTYCLR field.
	USB_DEVINTCLR_CCEMPTYCLR_Pos = 0x4
	// Bit mask of CCEMPTYCLR field.
	USB_DEVINTCLR_CCEMPTYCLR_Msk = 0x10
	// Bit CCEMPTYCLR.
	USB_DEVINTCLR_CCEMPTYCLR = 0x10
	// Position of CDFULLCLR field.
	USB_DEVINTCLR_CDFULLCLR_Pos = 0x5
	// Bit mask of CDFULLCLR field.
	USB_DEVINTCLR_CDFULLCLR_Msk = 0x20
	// Bit CDFULLCLR.
	USB_DEVINTCLR_CDFULLCLR = 0x20
	// Position of RxENDPKTCLR field.
	USB_DEVINTCLR_RxENDPKTCLR_Pos = 0x6
	// Bit mask of RxENDPKTCLR field.
	USB_DEVINTCLR_RxENDPKTCLR_Msk = 0x40
	// Bit RxENDPKTCLR.
	USB_DEVINTCLR_RxENDPKTCLR = 0x40
	// Position of TxENDPKTCLR field.
	USB_DEVINTCLR_TxENDPKTCLR_Pos = 0x7
	// Bit mask of TxENDPKTCLR field.
	USB_DEVINTCLR_TxENDPKTCLR_Msk = 0x80
	// Bit TxENDPKTCLR.
	USB_DEVINTCLR_TxENDPKTCLR = 0x80
	// Position of EP_RLZEDCLR field.
	USB_DEVINTCLR_EP_RLZEDCLR_Pos = 0x8
	// Bit mask of EP_RLZEDCLR field.
	USB_DEVINTCLR_EP_RLZEDCLR_Msk = 0x100
	// Bit EP_RLZEDCLR.
	USB_DEVINTCLR_EP_RLZEDCLR = 0x100
	// Position of ERR_INTCLR field.
	USB_DEVINTCLR_ERR_INTCLR_Pos = 0x9
	// Bit mask of ERR_INTCLR field.
	USB_DEVINTCLR_ERR_INTCLR_Msk = 0x200
	// Bit ERR_INTCLR.
	USB_DEVINTCLR_ERR_INTCLR = 0x200
	// Position of RESERVED field.
	USB_DEVINTCLR_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	USB_DEVINTCLR_RESERVED_Msk = 0xfffffc00

	// DEVINTSET: USB Device Interrupt Set
	// Position of FRAMESET field.
	USB_DEVINTSET_FRAMESET_Pos = 0x0
	// Bit mask of FRAMESET field.
	USB_DEVINTSET_FRAMESET_Msk = 0x1
	// Bit FRAMESET.
	USB_DEVINTSET_FRAMESET = 0x1
	// Position of EP_FASTSET field.
	USB_DEVINTSET_EP_FASTSET_Pos = 0x1
	// Bit mask of EP_FASTSET field.
	USB_DEVINTSET_EP_FASTSET_Msk = 0x2
	// Bit EP_FASTSET.
	USB_DEVINTSET_EP_FASTSET = 0x2
	// Position of EP_SLOWSET field.
	USB_DEVINTSET_EP_SLOWSET_Pos = 0x2
	// Bit mask of EP_SLOWSET field.
	USB_DEVINTSET_EP_SLOWSET_Msk = 0x4
	// Bit EP_SLOWSET.
	USB_DEVINTSET_EP_SLOWSET = 0x4
	// Position of DEV_STATSET field.
	USB_DEVINTSET_DEV_STATSET_Pos = 0x3
	// Bit mask of DEV_STATSET field.
	USB_DEVINTSET_DEV_STATSET_Msk = 0x8
	// Bit DEV_STATSET.
	USB_DEVINTSET_DEV_STATSET = 0x8
	// Position of CCEMPTYSET field.
	USB_DEVINTSET_CCEMPTYSET_Pos = 0x4
	// Bit mask of CCEMPTYSET field.
	USB_DEVINTSET_CCEMPTYSET_Msk = 0x10
	// Bit CCEMPTYSET.
	USB_DEVINTSET_CCEMPTYSET = 0x10
	// Position of CDFULLSET field.
	USB_DEVINTSET_CDFULLSET_Pos = 0x5
	// Bit mask of CDFULLSET field.
	USB_DEVINTSET_CDFULLSET_Msk = 0x20
	// Bit CDFULLSET.
	USB_DEVINTSET_CDFULLSET = 0x20
	// Position of RxENDPKTSET field.
	USB_DEVINTSET_RxENDPKTSET_Pos = 0x6
	// Bit mask of RxENDPKTSET field.
	USB_DEVINTSET_RxENDPKTSET_Msk = 0x40
	// Bit RxENDPKTSET.
	USB_DEVINTSET_RxENDPKTSET = 0x40
	// Position of TxENDPKTSET field.
	USB_DEVINTSET_TxENDPKTSET_Pos = 0x7
	// Bit mask of TxENDPKTSET field.
	USB_DEVINTSET_TxENDPKTSET_Msk = 0x80
	// Bit TxENDPKTSET.
	USB_DEVINTSET_TxENDPKTSET = 0x80
	// Position of EP_RLZEDSET field.
	USB_DEVINTSET_EP_RLZEDSET_Pos = 0x8
	// Bit mask of EP_RLZEDSET field.
	USB_DEVINTSET_EP_RLZEDSET_Msk = 0x100
	// Bit EP_RLZEDSET.
	USB_DEVINTSET_EP_RLZEDSET = 0x100
	// Position of ERR_INTSET field.
	USB_DEVINTSET_ERR_INTSET_Pos = 0x9
	// Bit mask of ERR_INTSET field.
	USB_DEVINTSET_ERR_INTSET_Msk = 0x200
	// Bit ERR_INTSET.
	USB_DEVINTSET_ERR_INTSET = 0x200
	// Position of RESERVED field.
	USB_DEVINTSET_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	USB_DEVINTSET_RESERVED_Msk = 0xfffffc00

	// CMDCODE: USB Command Code
	// Position of RESERVED field.
	USB_CMDCODE_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	USB_CMDCODE_RESERVED_Msk = 0xff
	// Position of CMD_PHASE field.
	USB_CMDCODE_CMD_PHASE_Pos = 0x8
	// Bit mask of CMD_PHASE field.
	USB_CMDCODE_CMD_PHASE_Msk = 0xff00
	// Read
	USB_CMDCODE_CMD_PHASE_READ = 0x2
	// Write
	USB_CMDCODE_CMD_PHASE_WRITE = 0x1
	// Command
	USB_CMDCODE_CMD_PHASE_COMMAND = 0x5
	// Position of CMD_CODE_WDATA field.
	USB_CMDCODE_CMD_CODE_WDATA_Pos = 0x10
	// Bit mask of CMD_CODE_WDATA field.
	USB_CMDCODE_CMD_CODE_WDATA_Msk = 0xff0000
	// Position of RESERVED field.
	USB_CMDCODE_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	USB_CMDCODE_RESERVED_Msk = 0xff000000

	// CMDDATA: USB Command Data
	// Position of CMD_RDATA field.
	USB_CMDDATA_CMD_RDATA_Pos = 0x0
	// Bit mask of CMD_RDATA field.
	USB_CMDDATA_CMD_RDATA_Msk = 0xff
	// Position of RESERVED field.
	USB_CMDDATA_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	USB_CMDDATA_RESERVED_Msk = 0xffffff00

	// RXDATA: USB Receive Data
	// Position of RX_DATA field.
	USB_RXDATA_RX_DATA_Pos = 0x0
	// Bit mask of RX_DATA field.
	USB_RXDATA_RX_DATA_Msk = 0xffffffff

	// TXDATA: USB Transmit Data
	// Position of TX_DATA field.
	USB_TXDATA_TX_DATA_Pos = 0x0
	// Bit mask of TX_DATA field.
	USB_TXDATA_TX_DATA_Msk = 0xffffffff

	// TXPLEN: USB Transmit Packet Length
	// Position of PKT_LNGTH field.
	USB_TXPLEN_PKT_LNGTH_Pos = 0x0
	// Bit mask of PKT_LNGTH field.
	USB_TXPLEN_PKT_LNGTH_Msk = 0x3ff
	// Position of RESERVED field.
	USB_TXPLEN_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	USB_TXPLEN_RESERVED_Msk = 0xfffffc00

	// CTRL: USB Control
	// Position of RD_EN field.
	USB_CTRL_RD_EN_Pos = 0x0
	// Bit mask of RD_EN field.
	USB_CTRL_RD_EN_Msk = 0x1
	// Bit RD_EN.
	USB_CTRL_RD_EN = 0x1
	// Disabled.
	USB_CTRL_RD_EN_DISABLED_ = 0x0
	// Enabled.
	USB_CTRL_RD_EN_ENABLED_ = 0x1
	// Position of WR_EN field.
	USB_CTRL_WR_EN_Pos = 0x1
	// Bit mask of WR_EN field.
	USB_CTRL_WR_EN_Msk = 0x2
	// Bit WR_EN.
	USB_CTRL_WR_EN = 0x2
	// Disabled.
	USB_CTRL_WR_EN_DISABLED_ = 0x0
	// Enabled.
	USB_CTRL_WR_EN_ENABLED_ = 0x1
	// Position of LOG_ENDPOINT field.
	USB_CTRL_LOG_ENDPOINT_Pos = 0x2
	// Bit mask of LOG_ENDPOINT field.
	USB_CTRL_LOG_ENDPOINT_Msk = 0x3c
	// Position of RESERVED field.
	USB_CTRL_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	USB_CTRL_RESERVED_Msk = 0xffffffc0

	// DEVINTPRI: USB Device Interrupt Priority
	// Position of FRAME field.
	USB_DEVINTPRI_FRAME_Pos = 0x0
	// Bit mask of FRAME field.
	USB_DEVINTPRI_FRAME_Msk = 0x1
	// Bit FRAME.
	USB_DEVINTPRI_FRAME = 0x1
	// FRAME interrupt is routed to USB_INT_REQ_LP.
	USB_DEVINTPRI_FRAME_LP = 0x0
	// FRAME interrupt is routed to USB_INT_REQ_HP.
	USB_DEVINTPRI_FRAME_HP = 0x1
	// Position of EP_FAST field.
	USB_DEVINTPRI_EP_FAST_Pos = 0x1
	// Bit mask of EP_FAST field.
	USB_DEVINTPRI_EP_FAST_Msk = 0x2
	// Bit EP_FAST.
	USB_DEVINTPRI_EP_FAST = 0x2
	// EP_FAST interrupt is routed to USB_INT_REQ_LP.
	USB_DEVINTPRI_EP_FAST_LP = 0x0
	// EP_FAST interrupt is routed to USB_INT_REQ_HP.
	USB_DEVINTPRI_EP_FAST_HP = 0x1
	// Position of RESERVED field.
	USB_DEVINTPRI_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	USB_DEVINTPRI_RESERVED_Msk = 0xfffffffc

	// EPINTST: USB Endpoint Interrupt Status
	// Position of EPST0 field.
	USB_EPINTST_EPST0_Pos = 0x0
	// Bit mask of EPST0 field.
	USB_EPINTST_EPST0_Msk = 0x1
	// Bit EPST0.
	USB_EPINTST_EPST0 = 0x1
	// Position of EPST1 field.
	USB_EPINTST_EPST1_Pos = 0x1
	// Bit mask of EPST1 field.
	USB_EPINTST_EPST1_Msk = 0x2
	// Bit EPST1.
	USB_EPINTST_EPST1 = 0x2
	// Position of EPST2 field.
	USB_EPINTST_EPST2_Pos = 0x2
	// Bit mask of EPST2 field.
	USB_EPINTST_EPST2_Msk = 0x4
	// Bit EPST2.
	USB_EPINTST_EPST2 = 0x4
	// Position of EPST3 field.
	USB_EPINTST_EPST3_Pos = 0x3
	// Bit mask of EPST3 field.
	USB_EPINTST_EPST3_Msk = 0x8
	// Bit EPST3.
	USB_EPINTST_EPST3 = 0x8
	// Position of EPST4 field.
	USB_EPINTST_EPST4_Pos = 0x4
	// Bit mask of EPST4 field.
	USB_EPINTST_EPST4_Msk = 0x10
	// Bit EPST4.
	USB_EPINTST_EPST4 = 0x10
	// Position of EPST5 field.
	USB_EPINTST_EPST5_Pos = 0x5
	// Bit mask of EPST5 field.
	USB_EPINTST_EPST5_Msk = 0x20
	// Bit EPST5.
	USB_EPINTST_EPST5 = 0x20
	// Position of EPST6 field.
	USB_EPINTST_EPST6_Pos = 0x6
	// Bit mask of EPST6 field.
	USB_EPINTST_EPST6_Msk = 0x40
	// Bit EPST6.
	USB_EPINTST_EPST6 = 0x40
	// Position of EPST7 field.
	USB_EPINTST_EPST7_Pos = 0x7
	// Bit mask of EPST7 field.
	USB_EPINTST_EPST7_Msk = 0x80
	// Bit EPST7.
	USB_EPINTST_EPST7 = 0x80
	// Position of EPST8 field.
	USB_EPINTST_EPST8_Pos = 0x8
	// Bit mask of EPST8 field.
	USB_EPINTST_EPST8_Msk = 0x100
	// Bit EPST8.
	USB_EPINTST_EPST8 = 0x100
	// Position of EPST9 field.
	USB_EPINTST_EPST9_Pos = 0x9
	// Bit mask of EPST9 field.
	USB_EPINTST_EPST9_Msk = 0x200
	// Bit EPST9.
	USB_EPINTST_EPST9 = 0x200
	// Position of EPST10 field.
	USB_EPINTST_EPST10_Pos = 0xa
	// Bit mask of EPST10 field.
	USB_EPINTST_EPST10_Msk = 0x400
	// Bit EPST10.
	USB_EPINTST_EPST10 = 0x400
	// Position of EPST11 field.
	USB_EPINTST_EPST11_Pos = 0xb
	// Bit mask of EPST11 field.
	USB_EPINTST_EPST11_Msk = 0x800
	// Bit EPST11.
	USB_EPINTST_EPST11 = 0x800
	// Position of EPST12 field.
	USB_EPINTST_EPST12_Pos = 0xc
	// Bit mask of EPST12 field.
	USB_EPINTST_EPST12_Msk = 0x1000
	// Bit EPST12.
	USB_EPINTST_EPST12 = 0x1000
	// Position of EPST13 field.
	USB_EPINTST_EPST13_Pos = 0xd
	// Bit mask of EPST13 field.
	USB_EPINTST_EPST13_Msk = 0x2000
	// Bit EPST13.
	USB_EPINTST_EPST13 = 0x2000
	// Position of EPST14 field.
	USB_EPINTST_EPST14_Pos = 0xe
	// Bit mask of EPST14 field.
	USB_EPINTST_EPST14_Msk = 0x4000
	// Bit EPST14.
	USB_EPINTST_EPST14 = 0x4000
	// Position of EPST15 field.
	USB_EPINTST_EPST15_Pos = 0xf
	// Bit mask of EPST15 field.
	USB_EPINTST_EPST15_Msk = 0x8000
	// Bit EPST15.
	USB_EPINTST_EPST15 = 0x8000
	// Position of EPST16 field.
	USB_EPINTST_EPST16_Pos = 0x10
	// Bit mask of EPST16 field.
	USB_EPINTST_EPST16_Msk = 0x10000
	// Bit EPST16.
	USB_EPINTST_EPST16 = 0x10000
	// Position of EPST17 field.
	USB_EPINTST_EPST17_Pos = 0x11
	// Bit mask of EPST17 field.
	USB_EPINTST_EPST17_Msk = 0x20000
	// Bit EPST17.
	USB_EPINTST_EPST17 = 0x20000
	// Position of EPST18 field.
	USB_EPINTST_EPST18_Pos = 0x12
	// Bit mask of EPST18 field.
	USB_EPINTST_EPST18_Msk = 0x40000
	// Bit EPST18.
	USB_EPINTST_EPST18 = 0x40000
	// Position of EPST19 field.
	USB_EPINTST_EPST19_Pos = 0x13
	// Bit mask of EPST19 field.
	USB_EPINTST_EPST19_Msk = 0x80000
	// Bit EPST19.
	USB_EPINTST_EPST19 = 0x80000
	// Position of EPST20 field.
	USB_EPINTST_EPST20_Pos = 0x14
	// Bit mask of EPST20 field.
	USB_EPINTST_EPST20_Msk = 0x100000
	// Bit EPST20.
	USB_EPINTST_EPST20 = 0x100000
	// Position of EPST21 field.
	USB_EPINTST_EPST21_Pos = 0x15
	// Bit mask of EPST21 field.
	USB_EPINTST_EPST21_Msk = 0x200000
	// Bit EPST21.
	USB_EPINTST_EPST21 = 0x200000
	// Position of EPST22 field.
	USB_EPINTST_EPST22_Pos = 0x16
	// Bit mask of EPST22 field.
	USB_EPINTST_EPST22_Msk = 0x400000
	// Bit EPST22.
	USB_EPINTST_EPST22 = 0x400000
	// Position of EPST23 field.
	USB_EPINTST_EPST23_Pos = 0x17
	// Bit mask of EPST23 field.
	USB_EPINTST_EPST23_Msk = 0x800000
	// Bit EPST23.
	USB_EPINTST_EPST23 = 0x800000
	// Position of EPST24 field.
	USB_EPINTST_EPST24_Pos = 0x18
	// Bit mask of EPST24 field.
	USB_EPINTST_EPST24_Msk = 0x1000000
	// Bit EPST24.
	USB_EPINTST_EPST24 = 0x1000000
	// Position of EPST25 field.
	USB_EPINTST_EPST25_Pos = 0x19
	// Bit mask of EPST25 field.
	USB_EPINTST_EPST25_Msk = 0x2000000
	// Bit EPST25.
	USB_EPINTST_EPST25 = 0x2000000
	// Position of EPST26 field.
	USB_EPINTST_EPST26_Pos = 0x1a
	// Bit mask of EPST26 field.
	USB_EPINTST_EPST26_Msk = 0x4000000
	// Bit EPST26.
	USB_EPINTST_EPST26 = 0x4000000
	// Position of EPST27 field.
	USB_EPINTST_EPST27_Pos = 0x1b
	// Bit mask of EPST27 field.
	USB_EPINTST_EPST27_Msk = 0x8000000
	// Bit EPST27.
	USB_EPINTST_EPST27 = 0x8000000
	// Position of EPST28 field.
	USB_EPINTST_EPST28_Pos = 0x1c
	// Bit mask of EPST28 field.
	USB_EPINTST_EPST28_Msk = 0x10000000
	// Bit EPST28.
	USB_EPINTST_EPST28 = 0x10000000
	// Position of EPST29 field.
	USB_EPINTST_EPST29_Pos = 0x1d
	// Bit mask of EPST29 field.
	USB_EPINTST_EPST29_Msk = 0x20000000
	// Bit EPST29.
	USB_EPINTST_EPST29 = 0x20000000
	// Position of EPST30 field.
	USB_EPINTST_EPST30_Pos = 0x1e
	// Bit mask of EPST30 field.
	USB_EPINTST_EPST30_Msk = 0x40000000
	// Bit EPST30.
	USB_EPINTST_EPST30 = 0x40000000
	// Position of EPST31 field.
	USB_EPINTST_EPST31_Pos = 0x1f
	// Bit mask of EPST31 field.
	USB_EPINTST_EPST31_Msk = 0x80000000
	// Bit EPST31.
	USB_EPINTST_EPST31 = 0x80000000

	// EPINTEN: USB Endpoint Interrupt Enable
	// Position of EPEN0 field.
	USB_EPINTEN_EPEN0_Pos = 0x0
	// Bit mask of EPEN0 field.
	USB_EPINTEN_EPEN0_Msk = 0x1
	// Bit EPEN0.
	USB_EPINTEN_EPEN0 = 0x1
	// Position of EPEN1 field.
	USB_EPINTEN_EPEN1_Pos = 0x1
	// Bit mask of EPEN1 field.
	USB_EPINTEN_EPEN1_Msk = 0x2
	// Bit EPEN1.
	USB_EPINTEN_EPEN1 = 0x2
	// Position of EPEN2 field.
	USB_EPINTEN_EPEN2_Pos = 0x2
	// Bit mask of EPEN2 field.
	USB_EPINTEN_EPEN2_Msk = 0x4
	// Bit EPEN2.
	USB_EPINTEN_EPEN2 = 0x4
	// Position of EPEN3 field.
	USB_EPINTEN_EPEN3_Pos = 0x3
	// Bit mask of EPEN3 field.
	USB_EPINTEN_EPEN3_Msk = 0x8
	// Bit EPEN3.
	USB_EPINTEN_EPEN3 = 0x8
	// Position of EPEN4 field.
	USB_EPINTEN_EPEN4_Pos = 0x4
	// Bit mask of EPEN4 field.
	USB_EPINTEN_EPEN4_Msk = 0x10
	// Bit EPEN4.
	USB_EPINTEN_EPEN4 = 0x10
	// Position of EPEN5 field.
	USB_EPINTEN_EPEN5_Pos = 0x5
	// Bit mask of EPEN5 field.
	USB_EPINTEN_EPEN5_Msk = 0x20
	// Bit EPEN5.
	USB_EPINTEN_EPEN5 = 0x20
	// Position of EPEN6 field.
	USB_EPINTEN_EPEN6_Pos = 0x6
	// Bit mask of EPEN6 field.
	USB_EPINTEN_EPEN6_Msk = 0x40
	// Bit EPEN6.
	USB_EPINTEN_EPEN6 = 0x40
	// Position of EPEN7 field.
	USB_EPINTEN_EPEN7_Pos = 0x7
	// Bit mask of EPEN7 field.
	USB_EPINTEN_EPEN7_Msk = 0x80
	// Bit EPEN7.
	USB_EPINTEN_EPEN7 = 0x80
	// Position of EPEN8 field.
	USB_EPINTEN_EPEN8_Pos = 0x8
	// Bit mask of EPEN8 field.
	USB_EPINTEN_EPEN8_Msk = 0x100
	// Bit EPEN8.
	USB_EPINTEN_EPEN8 = 0x100
	// Position of EPEN9 field.
	USB_EPINTEN_EPEN9_Pos = 0x9
	// Bit mask of EPEN9 field.
	USB_EPINTEN_EPEN9_Msk = 0x200
	// Bit EPEN9.
	USB_EPINTEN_EPEN9 = 0x200
	// Position of EPEN10 field.
	USB_EPINTEN_EPEN10_Pos = 0xa
	// Bit mask of EPEN10 field.
	USB_EPINTEN_EPEN10_Msk = 0x400
	// Bit EPEN10.
	USB_EPINTEN_EPEN10 = 0x400
	// Position of EPEN11 field.
	USB_EPINTEN_EPEN11_Pos = 0xb
	// Bit mask of EPEN11 field.
	USB_EPINTEN_EPEN11_Msk = 0x800
	// Bit EPEN11.
	USB_EPINTEN_EPEN11 = 0x800
	// Position of EPEN12 field.
	USB_EPINTEN_EPEN12_Pos = 0xc
	// Bit mask of EPEN12 field.
	USB_EPINTEN_EPEN12_Msk = 0x1000
	// Bit EPEN12.
	USB_EPINTEN_EPEN12 = 0x1000
	// Position of EPEN13 field.
	USB_EPINTEN_EPEN13_Pos = 0xd
	// Bit mask of EPEN13 field.
	USB_EPINTEN_EPEN13_Msk = 0x2000
	// Bit EPEN13.
	USB_EPINTEN_EPEN13 = 0x2000
	// Position of EPEN14 field.
	USB_EPINTEN_EPEN14_Pos = 0xe
	// Bit mask of EPEN14 field.
	USB_EPINTEN_EPEN14_Msk = 0x4000
	// Bit EPEN14.
	USB_EPINTEN_EPEN14 = 0x4000
	// Position of EPEN15 field.
	USB_EPINTEN_EPEN15_Pos = 0xf
	// Bit mask of EPEN15 field.
	USB_EPINTEN_EPEN15_Msk = 0x8000
	// Bit EPEN15.
	USB_EPINTEN_EPEN15 = 0x8000
	// Position of EPEN16 field.
	USB_EPINTEN_EPEN16_Pos = 0x10
	// Bit mask of EPEN16 field.
	USB_EPINTEN_EPEN16_Msk = 0x10000
	// Bit EPEN16.
	USB_EPINTEN_EPEN16 = 0x10000
	// Position of EPEN17 field.
	USB_EPINTEN_EPEN17_Pos = 0x11
	// Bit mask of EPEN17 field.
	USB_EPINTEN_EPEN17_Msk = 0x20000
	// Bit EPEN17.
	USB_EPINTEN_EPEN17 = 0x20000
	// Position of EPEN18 field.
	USB_EPINTEN_EPEN18_Pos = 0x12
	// Bit mask of EPEN18 field.
	USB_EPINTEN_EPEN18_Msk = 0x40000
	// Bit EPEN18.
	USB_EPINTEN_EPEN18 = 0x40000
	// Position of EPEN19 field.
	USB_EPINTEN_EPEN19_Pos = 0x13
	// Bit mask of EPEN19 field.
	USB_EPINTEN_EPEN19_Msk = 0x80000
	// Bit EPEN19.
	USB_EPINTEN_EPEN19 = 0x80000
	// Position of EPEN20 field.
	USB_EPINTEN_EPEN20_Pos = 0x14
	// Bit mask of EPEN20 field.
	USB_EPINTEN_EPEN20_Msk = 0x100000
	// Bit EPEN20.
	USB_EPINTEN_EPEN20 = 0x100000
	// Position of EPEN21 field.
	USB_EPINTEN_EPEN21_Pos = 0x15
	// Bit mask of EPEN21 field.
	USB_EPINTEN_EPEN21_Msk = 0x200000
	// Bit EPEN21.
	USB_EPINTEN_EPEN21 = 0x200000
	// Position of EPEN22 field.
	USB_EPINTEN_EPEN22_Pos = 0x16
	// Bit mask of EPEN22 field.
	USB_EPINTEN_EPEN22_Msk = 0x400000
	// Bit EPEN22.
	USB_EPINTEN_EPEN22 = 0x400000
	// Position of EPEN23 field.
	USB_EPINTEN_EPEN23_Pos = 0x17
	// Bit mask of EPEN23 field.
	USB_EPINTEN_EPEN23_Msk = 0x800000
	// Bit EPEN23.
	USB_EPINTEN_EPEN23 = 0x800000
	// Position of EPEN24 field.
	USB_EPINTEN_EPEN24_Pos = 0x18
	// Bit mask of EPEN24 field.
	USB_EPINTEN_EPEN24_Msk = 0x1000000
	// Bit EPEN24.
	USB_EPINTEN_EPEN24 = 0x1000000
	// Position of EPEN25 field.
	USB_EPINTEN_EPEN25_Pos = 0x19
	// Bit mask of EPEN25 field.
	USB_EPINTEN_EPEN25_Msk = 0x2000000
	// Bit EPEN25.
	USB_EPINTEN_EPEN25 = 0x2000000
	// Position of EPEN26 field.
	USB_EPINTEN_EPEN26_Pos = 0x1a
	// Bit mask of EPEN26 field.
	USB_EPINTEN_EPEN26_Msk = 0x4000000
	// Bit EPEN26.
	USB_EPINTEN_EPEN26 = 0x4000000
	// Position of EPEN27 field.
	USB_EPINTEN_EPEN27_Pos = 0x1b
	// Bit mask of EPEN27 field.
	USB_EPINTEN_EPEN27_Msk = 0x8000000
	// Bit EPEN27.
	USB_EPINTEN_EPEN27 = 0x8000000
	// Position of EPEN28 field.
	USB_EPINTEN_EPEN28_Pos = 0x1c
	// Bit mask of EPEN28 field.
	USB_EPINTEN_EPEN28_Msk = 0x10000000
	// Bit EPEN28.
	USB_EPINTEN_EPEN28 = 0x10000000
	// Position of EPEN29 field.
	USB_EPINTEN_EPEN29_Pos = 0x1d
	// Bit mask of EPEN29 field.
	USB_EPINTEN_EPEN29_Msk = 0x20000000
	// Bit EPEN29.
	USB_EPINTEN_EPEN29 = 0x20000000
	// Position of EPEN30 field.
	USB_EPINTEN_EPEN30_Pos = 0x1e
	// Bit mask of EPEN30 field.
	USB_EPINTEN_EPEN30_Msk = 0x40000000
	// Bit EPEN30.
	USB_EPINTEN_EPEN30 = 0x40000000
	// Position of EPEN31 field.
	USB_EPINTEN_EPEN31_Pos = 0x1f
	// Bit mask of EPEN31 field.
	USB_EPINTEN_EPEN31_Msk = 0x80000000
	// Bit EPEN31.
	USB_EPINTEN_EPEN31 = 0x80000000

	// EPINTCLR: USB Endpoint Interrupt Clear
	// Position of EPCLR0 field.
	USB_EPINTCLR_EPCLR0_Pos = 0x0
	// Bit mask of EPCLR0 field.
	USB_EPINTCLR_EPCLR0_Msk = 0x1
	// Bit EPCLR0.
	USB_EPINTCLR_EPCLR0 = 0x1
	// Position of EPCLR1 field.
	USB_EPINTCLR_EPCLR1_Pos = 0x1
	// Bit mask of EPCLR1 field.
	USB_EPINTCLR_EPCLR1_Msk = 0x2
	// Bit EPCLR1.
	USB_EPINTCLR_EPCLR1 = 0x2
	// Position of EPCLR2 field.
	USB_EPINTCLR_EPCLR2_Pos = 0x2
	// Bit mask of EPCLR2 field.
	USB_EPINTCLR_EPCLR2_Msk = 0x4
	// Bit EPCLR2.
	USB_EPINTCLR_EPCLR2 = 0x4
	// Position of EPCLR3 field.
	USB_EPINTCLR_EPCLR3_Pos = 0x3
	// Bit mask of EPCLR3 field.
	USB_EPINTCLR_EPCLR3_Msk = 0x8
	// Bit EPCLR3.
	USB_EPINTCLR_EPCLR3 = 0x8
	// Position of EPCLR4 field.
	USB_EPINTCLR_EPCLR4_Pos = 0x4
	// Bit mask of EPCLR4 field.
	USB_EPINTCLR_EPCLR4_Msk = 0x10
	// Bit EPCLR4.
	USB_EPINTCLR_EPCLR4 = 0x10
	// Position of EPCLR5 field.
	USB_EPINTCLR_EPCLR5_Pos = 0x5
	// Bit mask of EPCLR5 field.
	USB_EPINTCLR_EPCLR5_Msk = 0x20
	// Bit EPCLR5.
	USB_EPINTCLR_EPCLR5 = 0x20
	// Position of EPCLR6 field.
	USB_EPINTCLR_EPCLR6_Pos = 0x6
	// Bit mask of EPCLR6 field.
	USB_EPINTCLR_EPCLR6_Msk = 0x40
	// Bit EPCLR6.
	USB_EPINTCLR_EPCLR6 = 0x40
	// Position of EPCLR7 field.
	USB_EPINTCLR_EPCLR7_Pos = 0x7
	// Bit mask of EPCLR7 field.
	USB_EPINTCLR_EPCLR7_Msk = 0x80
	// Bit EPCLR7.
	USB_EPINTCLR_EPCLR7 = 0x80
	// Position of EPCLR8 field.
	USB_EPINTCLR_EPCLR8_Pos = 0x8
	// Bit mask of EPCLR8 field.
	USB_EPINTCLR_EPCLR8_Msk = 0x100
	// Bit EPCLR8.
	USB_EPINTCLR_EPCLR8 = 0x100
	// Position of EPCLR9 field.
	USB_EPINTCLR_EPCLR9_Pos = 0x9
	// Bit mask of EPCLR9 field.
	USB_EPINTCLR_EPCLR9_Msk = 0x200
	// Bit EPCLR9.
	USB_EPINTCLR_EPCLR9 = 0x200
	// Position of EPCLR10 field.
	USB_EPINTCLR_EPCLR10_Pos = 0xa
	// Bit mask of EPCLR10 field.
	USB_EPINTCLR_EPCLR10_Msk = 0x400
	// Bit EPCLR10.
	USB_EPINTCLR_EPCLR10 = 0x400
	// Position of EPCLR11 field.
	USB_EPINTCLR_EPCLR11_Pos = 0xb
	// Bit mask of EPCLR11 field.
	USB_EPINTCLR_EPCLR11_Msk = 0x800
	// Bit EPCLR11.
	USB_EPINTCLR_EPCLR11 = 0x800
	// Position of EPCLR12 field.
	USB_EPINTCLR_EPCLR12_Pos = 0xc
	// Bit mask of EPCLR12 field.
	USB_EPINTCLR_EPCLR12_Msk = 0x1000
	// Bit EPCLR12.
	USB_EPINTCLR_EPCLR12 = 0x1000
	// Position of EPCLR13 field.
	USB_EPINTCLR_EPCLR13_Pos = 0xd
	// Bit mask of EPCLR13 field.
	USB_EPINTCLR_EPCLR13_Msk = 0x2000
	// Bit EPCLR13.
	USB_EPINTCLR_EPCLR13 = 0x2000
	// Position of EPCLR14 field.
	USB_EPINTCLR_EPCLR14_Pos = 0xe
	// Bit mask of EPCLR14 field.
	USB_EPINTCLR_EPCLR14_Msk = 0x4000
	// Bit EPCLR14.
	USB_EPINTCLR_EPCLR14 = 0x4000
	// Position of EPCLR15 field.
	USB_EPINTCLR_EPCLR15_Pos = 0xf
	// Bit mask of EPCLR15 field.
	USB_EPINTCLR_EPCLR15_Msk = 0x8000
	// Bit EPCLR15.
	USB_EPINTCLR_EPCLR15 = 0x8000
	// Position of EPCLR16 field.
	USB_EPINTCLR_EPCLR16_Pos = 0x10
	// Bit mask of EPCLR16 field.
	USB_EPINTCLR_EPCLR16_Msk = 0x10000
	// Bit EPCLR16.
	USB_EPINTCLR_EPCLR16 = 0x10000
	// Position of EPCLR17 field.
	USB_EPINTCLR_EPCLR17_Pos = 0x11
	// Bit mask of EPCLR17 field.
	USB_EPINTCLR_EPCLR17_Msk = 0x20000
	// Bit EPCLR17.
	USB_EPINTCLR_EPCLR17 = 0x20000
	// Position of EPCLR18 field.
	USB_EPINTCLR_EPCLR18_Pos = 0x12
	// Bit mask of EPCLR18 field.
	USB_EPINTCLR_EPCLR18_Msk = 0x40000
	// Bit EPCLR18.
	USB_EPINTCLR_EPCLR18 = 0x40000
	// Position of EPCLR19 field.
	USB_EPINTCLR_EPCLR19_Pos = 0x13
	// Bit mask of EPCLR19 field.
	USB_EPINTCLR_EPCLR19_Msk = 0x80000
	// Bit EPCLR19.
	USB_EPINTCLR_EPCLR19 = 0x80000
	// Position of EPCLR20 field.
	USB_EPINTCLR_EPCLR20_Pos = 0x14
	// Bit mask of EPCLR20 field.
	USB_EPINTCLR_EPCLR20_Msk = 0x100000
	// Bit EPCLR20.
	USB_EPINTCLR_EPCLR20 = 0x100000
	// Position of EPCLR21 field.
	USB_EPINTCLR_EPCLR21_Pos = 0x15
	// Bit mask of EPCLR21 field.
	USB_EPINTCLR_EPCLR21_Msk = 0x200000
	// Bit EPCLR21.
	USB_EPINTCLR_EPCLR21 = 0x200000
	// Position of EPCLR22 field.
	USB_EPINTCLR_EPCLR22_Pos = 0x16
	// Bit mask of EPCLR22 field.
	USB_EPINTCLR_EPCLR22_Msk = 0x400000
	// Bit EPCLR22.
	USB_EPINTCLR_EPCLR22 = 0x400000
	// Position of EPCLR23 field.
	USB_EPINTCLR_EPCLR23_Pos = 0x17
	// Bit mask of EPCLR23 field.
	USB_EPINTCLR_EPCLR23_Msk = 0x800000
	// Bit EPCLR23.
	USB_EPINTCLR_EPCLR23 = 0x800000
	// Position of EPCLR24 field.
	USB_EPINTCLR_EPCLR24_Pos = 0x18
	// Bit mask of EPCLR24 field.
	USB_EPINTCLR_EPCLR24_Msk = 0x1000000
	// Bit EPCLR24.
	USB_EPINTCLR_EPCLR24 = 0x1000000
	// Position of EPCLR25 field.
	USB_EPINTCLR_EPCLR25_Pos = 0x19
	// Bit mask of EPCLR25 field.
	USB_EPINTCLR_EPCLR25_Msk = 0x2000000
	// Bit EPCLR25.
	USB_EPINTCLR_EPCLR25 = 0x2000000
	// Position of EPCLR26 field.
	USB_EPINTCLR_EPCLR26_Pos = 0x1a
	// Bit mask of EPCLR26 field.
	USB_EPINTCLR_EPCLR26_Msk = 0x4000000
	// Bit EPCLR26.
	USB_EPINTCLR_EPCLR26 = 0x4000000
	// Position of EPCLR27 field.
	USB_EPINTCLR_EPCLR27_Pos = 0x1b
	// Bit mask of EPCLR27 field.
	USB_EPINTCLR_EPCLR27_Msk = 0x8000000
	// Bit EPCLR27.
	USB_EPINTCLR_EPCLR27 = 0x8000000
	// Position of EPCLR28 field.
	USB_EPINTCLR_EPCLR28_Pos = 0x1c
	// Bit mask of EPCLR28 field.
	USB_EPINTCLR_EPCLR28_Msk = 0x10000000
	// Bit EPCLR28.
	USB_EPINTCLR_EPCLR28 = 0x10000000
	// Position of EPCLR29 field.
	USB_EPINTCLR_EPCLR29_Pos = 0x1d
	// Bit mask of EPCLR29 field.
	USB_EPINTCLR_EPCLR29_Msk = 0x20000000
	// Bit EPCLR29.
	USB_EPINTCLR_EPCLR29 = 0x20000000
	// Position of EPCLR30 field.
	USB_EPINTCLR_EPCLR30_Pos = 0x1e
	// Bit mask of EPCLR30 field.
	USB_EPINTCLR_EPCLR30_Msk = 0x40000000
	// Bit EPCLR30.
	USB_EPINTCLR_EPCLR30 = 0x40000000
	// Position of EPCLR31 field.
	USB_EPINTCLR_EPCLR31_Pos = 0x1f
	// Bit mask of EPCLR31 field.
	USB_EPINTCLR_EPCLR31_Msk = 0x80000000
	// Bit EPCLR31.
	USB_EPINTCLR_EPCLR31 = 0x80000000

	// EPINTSET: USB Endpoint Interrupt Set
	// Position of EPSET0 field.
	USB_EPINTSET_EPSET0_Pos = 0x0
	// Bit mask of EPSET0 field.
	USB_EPINTSET_EPSET0_Msk = 0x1
	// Bit EPSET0.
	USB_EPINTSET_EPSET0 = 0x1
	// Position of EPSET1 field.
	USB_EPINTSET_EPSET1_Pos = 0x1
	// Bit mask of EPSET1 field.
	USB_EPINTSET_EPSET1_Msk = 0x2
	// Bit EPSET1.
	USB_EPINTSET_EPSET1 = 0x2
	// Position of EPSET2 field.
	USB_EPINTSET_EPSET2_Pos = 0x2
	// Bit mask of EPSET2 field.
	USB_EPINTSET_EPSET2_Msk = 0x4
	// Bit EPSET2.
	USB_EPINTSET_EPSET2 = 0x4
	// Position of EPSET3 field.
	USB_EPINTSET_EPSET3_Pos = 0x3
	// Bit mask of EPSET3 field.
	USB_EPINTSET_EPSET3_Msk = 0x8
	// Bit EPSET3.
	USB_EPINTSET_EPSET3 = 0x8
	// Position of EPSET4 field.
	USB_EPINTSET_EPSET4_Pos = 0x4
	// Bit mask of EPSET4 field.
	USB_EPINTSET_EPSET4_Msk = 0x10
	// Bit EPSET4.
	USB_EPINTSET_EPSET4 = 0x10
	// Position of EPSET5 field.
	USB_EPINTSET_EPSET5_Pos = 0x5
	// Bit mask of EPSET5 field.
	USB_EPINTSET_EPSET5_Msk = 0x20
	// Bit EPSET5.
	USB_EPINTSET_EPSET5 = 0x20
	// Position of EPSET6 field.
	USB_EPINTSET_EPSET6_Pos = 0x6
	// Bit mask of EPSET6 field.
	USB_EPINTSET_EPSET6_Msk = 0x40
	// Bit EPSET6.
	USB_EPINTSET_EPSET6 = 0x40
	// Position of EPSET7 field.
	USB_EPINTSET_EPSET7_Pos = 0x7
	// Bit mask of EPSET7 field.
	USB_EPINTSET_EPSET7_Msk = 0x80
	// Bit EPSET7.
	USB_EPINTSET_EPSET7 = 0x80
	// Position of EPSET8 field.
	USB_EPINTSET_EPSET8_Pos = 0x8
	// Bit mask of EPSET8 field.
	USB_EPINTSET_EPSET8_Msk = 0x100
	// Bit EPSET8.
	USB_EPINTSET_EPSET8 = 0x100
	// Position of EPSET9 field.
	USB_EPINTSET_EPSET9_Pos = 0x9
	// Bit mask of EPSET9 field.
	USB_EPINTSET_EPSET9_Msk = 0x200
	// Bit EPSET9.
	USB_EPINTSET_EPSET9 = 0x200
	// Position of EPSET10 field.
	USB_EPINTSET_EPSET10_Pos = 0xa
	// Bit mask of EPSET10 field.
	USB_EPINTSET_EPSET10_Msk = 0x400
	// Bit EPSET10.
	USB_EPINTSET_EPSET10 = 0x400
	// Position of EPSET11 field.
	USB_EPINTSET_EPSET11_Pos = 0xb
	// Bit mask of EPSET11 field.
	USB_EPINTSET_EPSET11_Msk = 0x800
	// Bit EPSET11.
	USB_EPINTSET_EPSET11 = 0x800
	// Position of EPSET12 field.
	USB_EPINTSET_EPSET12_Pos = 0xc
	// Bit mask of EPSET12 field.
	USB_EPINTSET_EPSET12_Msk = 0x1000
	// Bit EPSET12.
	USB_EPINTSET_EPSET12 = 0x1000
	// Position of EPSET13 field.
	USB_EPINTSET_EPSET13_Pos = 0xd
	// Bit mask of EPSET13 field.
	USB_EPINTSET_EPSET13_Msk = 0x2000
	// Bit EPSET13.
	USB_EPINTSET_EPSET13 = 0x2000
	// Position of EPSET14 field.
	USB_EPINTSET_EPSET14_Pos = 0xe
	// Bit mask of EPSET14 field.
	USB_EPINTSET_EPSET14_Msk = 0x4000
	// Bit EPSET14.
	USB_EPINTSET_EPSET14 = 0x4000
	// Position of EPSET15 field.
	USB_EPINTSET_EPSET15_Pos = 0xf
	// Bit mask of EPSET15 field.
	USB_EPINTSET_EPSET15_Msk = 0x8000
	// Bit EPSET15.
	USB_EPINTSET_EPSET15 = 0x8000
	// Position of EPSET16 field.
	USB_EPINTSET_EPSET16_Pos = 0x10
	// Bit mask of EPSET16 field.
	USB_EPINTSET_EPSET16_Msk = 0x10000
	// Bit EPSET16.
	USB_EPINTSET_EPSET16 = 0x10000
	// Position of EPSET17 field.
	USB_EPINTSET_EPSET17_Pos = 0x11
	// Bit mask of EPSET17 field.
	USB_EPINTSET_EPSET17_Msk = 0x20000
	// Bit EPSET17.
	USB_EPINTSET_EPSET17 = 0x20000
	// Position of EPSET18 field.
	USB_EPINTSET_EPSET18_Pos = 0x12
	// Bit mask of EPSET18 field.
	USB_EPINTSET_EPSET18_Msk = 0x40000
	// Bit EPSET18.
	USB_EPINTSET_EPSET18 = 0x40000
	// Position of EPSET19 field.
	USB_EPINTSET_EPSET19_Pos = 0x13
	// Bit mask of EPSET19 field.
	USB_EPINTSET_EPSET19_Msk = 0x80000
	// Bit EPSET19.
	USB_EPINTSET_EPSET19 = 0x80000
	// Position of EPSET20 field.
	USB_EPINTSET_EPSET20_Pos = 0x14
	// Bit mask of EPSET20 field.
	USB_EPINTSET_EPSET20_Msk = 0x100000
	// Bit EPSET20.
	USB_EPINTSET_EPSET20 = 0x100000
	// Position of EPSET21 field.
	USB_EPINTSET_EPSET21_Pos = 0x15
	// Bit mask of EPSET21 field.
	USB_EPINTSET_EPSET21_Msk = 0x200000
	// Bit EPSET21.
	USB_EPINTSET_EPSET21 = 0x200000
	// Position of EPSET22 field.
	USB_EPINTSET_EPSET22_Pos = 0x16
	// Bit mask of EPSET22 field.
	USB_EPINTSET_EPSET22_Msk = 0x400000
	// Bit EPSET22.
	USB_EPINTSET_EPSET22 = 0x400000
	// Position of EPSET23 field.
	USB_EPINTSET_EPSET23_Pos = 0x17
	// Bit mask of EPSET23 field.
	USB_EPINTSET_EPSET23_Msk = 0x800000
	// Bit EPSET23.
	USB_EPINTSET_EPSET23 = 0x800000
	// Position of EPSET24 field.
	USB_EPINTSET_EPSET24_Pos = 0x18
	// Bit mask of EPSET24 field.
	USB_EPINTSET_EPSET24_Msk = 0x1000000
	// Bit EPSET24.
	USB_EPINTSET_EPSET24 = 0x1000000
	// Position of EPSET25 field.
	USB_EPINTSET_EPSET25_Pos = 0x19
	// Bit mask of EPSET25 field.
	USB_EPINTSET_EPSET25_Msk = 0x2000000
	// Bit EPSET25.
	USB_EPINTSET_EPSET25 = 0x2000000
	// Position of EPSET26 field.
	USB_EPINTSET_EPSET26_Pos = 0x1a
	// Bit mask of EPSET26 field.
	USB_EPINTSET_EPSET26_Msk = 0x4000000
	// Bit EPSET26.
	USB_EPINTSET_EPSET26 = 0x4000000
	// Position of EPSET27 field.
	USB_EPINTSET_EPSET27_Pos = 0x1b
	// Bit mask of EPSET27 field.
	USB_EPINTSET_EPSET27_Msk = 0x8000000
	// Bit EPSET27.
	USB_EPINTSET_EPSET27 = 0x8000000
	// Position of EPSET28 field.
	USB_EPINTSET_EPSET28_Pos = 0x1c
	// Bit mask of EPSET28 field.
	USB_EPINTSET_EPSET28_Msk = 0x10000000
	// Bit EPSET28.
	USB_EPINTSET_EPSET28 = 0x10000000
	// Position of EPSET29 field.
	USB_EPINTSET_EPSET29_Pos = 0x1d
	// Bit mask of EPSET29 field.
	USB_EPINTSET_EPSET29_Msk = 0x20000000
	// Bit EPSET29.
	USB_EPINTSET_EPSET29 = 0x20000000
	// Position of EPSET30 field.
	USB_EPINTSET_EPSET30_Pos = 0x1e
	// Bit mask of EPSET30 field.
	USB_EPINTSET_EPSET30_Msk = 0x40000000
	// Bit EPSET30.
	USB_EPINTSET_EPSET30 = 0x40000000
	// Position of EPSET31 field.
	USB_EPINTSET_EPSET31_Pos = 0x1f
	// Bit mask of EPSET31 field.
	USB_EPINTSET_EPSET31_Msk = 0x80000000
	// Bit EPSET31.
	USB_EPINTSET_EPSET31 = 0x80000000

	// EPINTPRI: USB Endpoint Priority
	// Position of EPPRI0 field.
	USB_EPINTPRI_EPPRI0_Pos = 0x0
	// Bit mask of EPPRI0 field.
	USB_EPINTPRI_EPPRI0_Msk = 0x1
	// Bit EPPRI0.
	USB_EPINTPRI_EPPRI0 = 0x1
	// Position of EPPRI1 field.
	USB_EPINTPRI_EPPRI1_Pos = 0x1
	// Bit mask of EPPRI1 field.
	USB_EPINTPRI_EPPRI1_Msk = 0x2
	// Bit EPPRI1.
	USB_EPINTPRI_EPPRI1 = 0x2
	// Position of EPPRI2 field.
	USB_EPINTPRI_EPPRI2_Pos = 0x2
	// Bit mask of EPPRI2 field.
	USB_EPINTPRI_EPPRI2_Msk = 0x4
	// Bit EPPRI2.
	USB_EPINTPRI_EPPRI2 = 0x4
	// Position of EPPRI3 field.
	USB_EPINTPRI_EPPRI3_Pos = 0x3
	// Bit mask of EPPRI3 field.
	USB_EPINTPRI_EPPRI3_Msk = 0x8
	// Bit EPPRI3.
	USB_EPINTPRI_EPPRI3 = 0x8
	// Position of EPPRI4 field.
	USB_EPINTPRI_EPPRI4_Pos = 0x4
	// Bit mask of EPPRI4 field.
	USB_EPINTPRI_EPPRI4_Msk = 0x10
	// Bit EPPRI4.
	USB_EPINTPRI_EPPRI4 = 0x10
	// Position of EPPRI5 field.
	USB_EPINTPRI_EPPRI5_Pos = 0x5
	// Bit mask of EPPRI5 field.
	USB_EPINTPRI_EPPRI5_Msk = 0x20
	// Bit EPPRI5.
	USB_EPINTPRI_EPPRI5 = 0x20
	// Position of EPPRI6 field.
	USB_EPINTPRI_EPPRI6_Pos = 0x6
	// Bit mask of EPPRI6 field.
	USB_EPINTPRI_EPPRI6_Msk = 0x40
	// Bit EPPRI6.
	USB_EPINTPRI_EPPRI6 = 0x40
	// Position of EPPRI7 field.
	USB_EPINTPRI_EPPRI7_Pos = 0x7
	// Bit mask of EPPRI7 field.
	USB_EPINTPRI_EPPRI7_Msk = 0x80
	// Bit EPPRI7.
	USB_EPINTPRI_EPPRI7 = 0x80
	// Position of EPPRI8 field.
	USB_EPINTPRI_EPPRI8_Pos = 0x8
	// Bit mask of EPPRI8 field.
	USB_EPINTPRI_EPPRI8_Msk = 0x100
	// Bit EPPRI8.
	USB_EPINTPRI_EPPRI8 = 0x100
	// Position of EPPRI9 field.
	USB_EPINTPRI_EPPRI9_Pos = 0x9
	// Bit mask of EPPRI9 field.
	USB_EPINTPRI_EPPRI9_Msk = 0x200
	// Bit EPPRI9.
	USB_EPINTPRI_EPPRI9 = 0x200
	// Position of EPPRI10 field.
	USB_EPINTPRI_EPPRI10_Pos = 0xa
	// Bit mask of EPPRI10 field.
	USB_EPINTPRI_EPPRI10_Msk = 0x400
	// Bit EPPRI10.
	USB_EPINTPRI_EPPRI10 = 0x400
	// Position of EPPRI11 field.
	USB_EPINTPRI_EPPRI11_Pos = 0xb
	// Bit mask of EPPRI11 field.
	USB_EPINTPRI_EPPRI11_Msk = 0x800
	// Bit EPPRI11.
	USB_EPINTPRI_EPPRI11 = 0x800
	// Position of EPPRI12 field.
	USB_EPINTPRI_EPPRI12_Pos = 0xc
	// Bit mask of EPPRI12 field.
	USB_EPINTPRI_EPPRI12_Msk = 0x1000
	// Bit EPPRI12.
	USB_EPINTPRI_EPPRI12 = 0x1000
	// Position of EPPRI13 field.
	USB_EPINTPRI_EPPRI13_Pos = 0xd
	// Bit mask of EPPRI13 field.
	USB_EPINTPRI_EPPRI13_Msk = 0x2000
	// Bit EPPRI13.
	USB_EPINTPRI_EPPRI13 = 0x2000
	// Position of EPPRI14 field.
	USB_EPINTPRI_EPPRI14_Pos = 0xe
	// Bit mask of EPPRI14 field.
	USB_EPINTPRI_EPPRI14_Msk = 0x4000
	// Bit EPPRI14.
	USB_EPINTPRI_EPPRI14 = 0x4000
	// Position of EPPRI15 field.
	USB_EPINTPRI_EPPRI15_Pos = 0xf
	// Bit mask of EPPRI15 field.
	USB_EPINTPRI_EPPRI15_Msk = 0x8000
	// Bit EPPRI15.
	USB_EPINTPRI_EPPRI15 = 0x8000
	// Position of EPPRI16 field.
	USB_EPINTPRI_EPPRI16_Pos = 0x10
	// Bit mask of EPPRI16 field.
	USB_EPINTPRI_EPPRI16_Msk = 0x10000
	// Bit EPPRI16.
	USB_EPINTPRI_EPPRI16 = 0x10000
	// Position of EPPRI17 field.
	USB_EPINTPRI_EPPRI17_Pos = 0x11
	// Bit mask of EPPRI17 field.
	USB_EPINTPRI_EPPRI17_Msk = 0x20000
	// Bit EPPRI17.
	USB_EPINTPRI_EPPRI17 = 0x20000
	// Position of EPPRI18 field.
	USB_EPINTPRI_EPPRI18_Pos = 0x12
	// Bit mask of EPPRI18 field.
	USB_EPINTPRI_EPPRI18_Msk = 0x40000
	// Bit EPPRI18.
	USB_EPINTPRI_EPPRI18 = 0x40000
	// Position of EPPRI19 field.
	USB_EPINTPRI_EPPRI19_Pos = 0x13
	// Bit mask of EPPRI19 field.
	USB_EPINTPRI_EPPRI19_Msk = 0x80000
	// Bit EPPRI19.
	USB_EPINTPRI_EPPRI19 = 0x80000
	// Position of EPPRI20 field.
	USB_EPINTPRI_EPPRI20_Pos = 0x14
	// Bit mask of EPPRI20 field.
	USB_EPINTPRI_EPPRI20_Msk = 0x100000
	// Bit EPPRI20.
	USB_EPINTPRI_EPPRI20 = 0x100000
	// Position of EPPRI21 field.
	USB_EPINTPRI_EPPRI21_Pos = 0x15
	// Bit mask of EPPRI21 field.
	USB_EPINTPRI_EPPRI21_Msk = 0x200000
	// Bit EPPRI21.
	USB_EPINTPRI_EPPRI21 = 0x200000
	// Position of EPPRI22 field.
	USB_EPINTPRI_EPPRI22_Pos = 0x16
	// Bit mask of EPPRI22 field.
	USB_EPINTPRI_EPPRI22_Msk = 0x400000
	// Bit EPPRI22.
	USB_EPINTPRI_EPPRI22 = 0x400000
	// Position of EPPRI23 field.
	USB_EPINTPRI_EPPRI23_Pos = 0x17
	// Bit mask of EPPRI23 field.
	USB_EPINTPRI_EPPRI23_Msk = 0x800000
	// Bit EPPRI23.
	USB_EPINTPRI_EPPRI23 = 0x800000
	// Position of EPPRI24 field.
	USB_EPINTPRI_EPPRI24_Pos = 0x18
	// Bit mask of EPPRI24 field.
	USB_EPINTPRI_EPPRI24_Msk = 0x1000000
	// Bit EPPRI24.
	USB_EPINTPRI_EPPRI24 = 0x1000000
	// Position of EPPRI25 field.
	USB_EPINTPRI_EPPRI25_Pos = 0x19
	// Bit mask of EPPRI25 field.
	USB_EPINTPRI_EPPRI25_Msk = 0x2000000
	// Bit EPPRI25.
	USB_EPINTPRI_EPPRI25 = 0x2000000
	// Position of EPPRI26 field.
	USB_EPINTPRI_EPPRI26_Pos = 0x1a
	// Bit mask of EPPRI26 field.
	USB_EPINTPRI_EPPRI26_Msk = 0x4000000
	// Bit EPPRI26.
	USB_EPINTPRI_EPPRI26 = 0x4000000
	// Position of EPPRI27 field.
	USB_EPINTPRI_EPPRI27_Pos = 0x1b
	// Bit mask of EPPRI27 field.
	USB_EPINTPRI_EPPRI27_Msk = 0x8000000
	// Bit EPPRI27.
	USB_EPINTPRI_EPPRI27 = 0x8000000
	// Position of EPPRI28 field.
	USB_EPINTPRI_EPPRI28_Pos = 0x1c
	// Bit mask of EPPRI28 field.
	USB_EPINTPRI_EPPRI28_Msk = 0x10000000
	// Bit EPPRI28.
	USB_EPINTPRI_EPPRI28 = 0x10000000
	// Position of EPPRI29 field.
	USB_EPINTPRI_EPPRI29_Pos = 0x1d
	// Bit mask of EPPRI29 field.
	USB_EPINTPRI_EPPRI29_Msk = 0x20000000
	// Bit EPPRI29.
	USB_EPINTPRI_EPPRI29 = 0x20000000
	// Position of EPPRI30 field.
	USB_EPINTPRI_EPPRI30_Pos = 0x1e
	// Bit mask of EPPRI30 field.
	USB_EPINTPRI_EPPRI30_Msk = 0x40000000
	// Bit EPPRI30.
	USB_EPINTPRI_EPPRI30 = 0x40000000
	// Position of EPPRI31 field.
	USB_EPINTPRI_EPPRI31_Pos = 0x1f
	// Bit mask of EPPRI31 field.
	USB_EPINTPRI_EPPRI31_Msk = 0x80000000
	// Bit EPPRI31.
	USB_EPINTPRI_EPPRI31 = 0x80000000

	// REEP: USB Realize Endpoint
	// Position of EPR0 field.
	USB_REEP_EPR0_Pos = 0x0
	// Bit mask of EPR0 field.
	USB_REEP_EPR0_Msk = 0x1
	// Bit EPR0.
	USB_REEP_EPR0 = 0x1
	// Position of EPR1 field.
	USB_REEP_EPR1_Pos = 0x1
	// Bit mask of EPR1 field.
	USB_REEP_EPR1_Msk = 0x2
	// Bit EPR1.
	USB_REEP_EPR1 = 0x2
	// Position of EPR2 field.
	USB_REEP_EPR2_Pos = 0x2
	// Bit mask of EPR2 field.
	USB_REEP_EPR2_Msk = 0x4
	// Bit EPR2.
	USB_REEP_EPR2 = 0x4
	// Position of EPR3 field.
	USB_REEP_EPR3_Pos = 0x3
	// Bit mask of EPR3 field.
	USB_REEP_EPR3_Msk = 0x8
	// Bit EPR3.
	USB_REEP_EPR3 = 0x8
	// Position of EPR4 field.
	USB_REEP_EPR4_Pos = 0x4
	// Bit mask of EPR4 field.
	USB_REEP_EPR4_Msk = 0x10
	// Bit EPR4.
	USB_REEP_EPR4 = 0x10
	// Position of EPR5 field.
	USB_REEP_EPR5_Pos = 0x5
	// Bit mask of EPR5 field.
	USB_REEP_EPR5_Msk = 0x20
	// Bit EPR5.
	USB_REEP_EPR5 = 0x20
	// Position of EPR6 field.
	USB_REEP_EPR6_Pos = 0x6
	// Bit mask of EPR6 field.
	USB_REEP_EPR6_Msk = 0x40
	// Bit EPR6.
	USB_REEP_EPR6 = 0x40
	// Position of EPR7 field.
	USB_REEP_EPR7_Pos = 0x7
	// Bit mask of EPR7 field.
	USB_REEP_EPR7_Msk = 0x80
	// Bit EPR7.
	USB_REEP_EPR7 = 0x80
	// Position of EPR8 field.
	USB_REEP_EPR8_Pos = 0x8
	// Bit mask of EPR8 field.
	USB_REEP_EPR8_Msk = 0x100
	// Bit EPR8.
	USB_REEP_EPR8 = 0x100
	// Position of EPR9 field.
	USB_REEP_EPR9_Pos = 0x9
	// Bit mask of EPR9 field.
	USB_REEP_EPR9_Msk = 0x200
	// Bit EPR9.
	USB_REEP_EPR9 = 0x200
	// Position of EPR10 field.
	USB_REEP_EPR10_Pos = 0xa
	// Bit mask of EPR10 field.
	USB_REEP_EPR10_Msk = 0x400
	// Bit EPR10.
	USB_REEP_EPR10 = 0x400
	// Position of EPR11 field.
	USB_REEP_EPR11_Pos = 0xb
	// Bit mask of EPR11 field.
	USB_REEP_EPR11_Msk = 0x800
	// Bit EPR11.
	USB_REEP_EPR11 = 0x800
	// Position of EPR12 field.
	USB_REEP_EPR12_Pos = 0xc
	// Bit mask of EPR12 field.
	USB_REEP_EPR12_Msk = 0x1000
	// Bit EPR12.
	USB_REEP_EPR12 = 0x1000
	// Position of EPR13 field.
	USB_REEP_EPR13_Pos = 0xd
	// Bit mask of EPR13 field.
	USB_REEP_EPR13_Msk = 0x2000
	// Bit EPR13.
	USB_REEP_EPR13 = 0x2000
	// Position of EPR14 field.
	USB_REEP_EPR14_Pos = 0xe
	// Bit mask of EPR14 field.
	USB_REEP_EPR14_Msk = 0x4000
	// Bit EPR14.
	USB_REEP_EPR14 = 0x4000
	// Position of EPR15 field.
	USB_REEP_EPR15_Pos = 0xf
	// Bit mask of EPR15 field.
	USB_REEP_EPR15_Msk = 0x8000
	// Bit EPR15.
	USB_REEP_EPR15 = 0x8000
	// Position of EPR16 field.
	USB_REEP_EPR16_Pos = 0x10
	// Bit mask of EPR16 field.
	USB_REEP_EPR16_Msk = 0x10000
	// Bit EPR16.
	USB_REEP_EPR16 = 0x10000
	// Position of EPR17 field.
	USB_REEP_EPR17_Pos = 0x11
	// Bit mask of EPR17 field.
	USB_REEP_EPR17_Msk = 0x20000
	// Bit EPR17.
	USB_REEP_EPR17 = 0x20000
	// Position of EPR18 field.
	USB_REEP_EPR18_Pos = 0x12
	// Bit mask of EPR18 field.
	USB_REEP_EPR18_Msk = 0x40000
	// Bit EPR18.
	USB_REEP_EPR18 = 0x40000
	// Position of EPR19 field.
	USB_REEP_EPR19_Pos = 0x13
	// Bit mask of EPR19 field.
	USB_REEP_EPR19_Msk = 0x80000
	// Bit EPR19.
	USB_REEP_EPR19 = 0x80000
	// Position of EPR20 field.
	USB_REEP_EPR20_Pos = 0x14
	// Bit mask of EPR20 field.
	USB_REEP_EPR20_Msk = 0x100000
	// Bit EPR20.
	USB_REEP_EPR20 = 0x100000
	// Position of EPR21 field.
	USB_REEP_EPR21_Pos = 0x15
	// Bit mask of EPR21 field.
	USB_REEP_EPR21_Msk = 0x200000
	// Bit EPR21.
	USB_REEP_EPR21 = 0x200000
	// Position of EPR22 field.
	USB_REEP_EPR22_Pos = 0x16
	// Bit mask of EPR22 field.
	USB_REEP_EPR22_Msk = 0x400000
	// Bit EPR22.
	USB_REEP_EPR22 = 0x400000
	// Position of EPR23 field.
	USB_REEP_EPR23_Pos = 0x17
	// Bit mask of EPR23 field.
	USB_REEP_EPR23_Msk = 0x800000
	// Bit EPR23.
	USB_REEP_EPR23 = 0x800000
	// Position of EPR24 field.
	USB_REEP_EPR24_Pos = 0x18
	// Bit mask of EPR24 field.
	USB_REEP_EPR24_Msk = 0x1000000
	// Bit EPR24.
	USB_REEP_EPR24 = 0x1000000
	// Position of EPR25 field.
	USB_REEP_EPR25_Pos = 0x19
	// Bit mask of EPR25 field.
	USB_REEP_EPR25_Msk = 0x2000000
	// Bit EPR25.
	USB_REEP_EPR25 = 0x2000000
	// Position of EPR26 field.
	USB_REEP_EPR26_Pos = 0x1a
	// Bit mask of EPR26 field.
	USB_REEP_EPR26_Msk = 0x4000000
	// Bit EPR26.
	USB_REEP_EPR26 = 0x4000000
	// Position of EPR27 field.
	USB_REEP_EPR27_Pos = 0x1b
	// Bit mask of EPR27 field.
	USB_REEP_EPR27_Msk = 0x8000000
	// Bit EPR27.
	USB_REEP_EPR27 = 0x8000000
	// Position of EPR28 field.
	USB_REEP_EPR28_Pos = 0x1c
	// Bit mask of EPR28 field.
	USB_REEP_EPR28_Msk = 0x10000000
	// Bit EPR28.
	USB_REEP_EPR28 = 0x10000000
	// Position of EPR29 field.
	USB_REEP_EPR29_Pos = 0x1d
	// Bit mask of EPR29 field.
	USB_REEP_EPR29_Msk = 0x20000000
	// Bit EPR29.
	USB_REEP_EPR29 = 0x20000000
	// Position of EPR30 field.
	USB_REEP_EPR30_Pos = 0x1e
	// Bit mask of EPR30 field.
	USB_REEP_EPR30_Msk = 0x40000000
	// Bit EPR30.
	USB_REEP_EPR30 = 0x40000000
	// Position of EPR31 field.
	USB_REEP_EPR31_Pos = 0x1f
	// Bit mask of EPR31 field.
	USB_REEP_EPR31_Msk = 0x80000000
	// Bit EPR31.
	USB_REEP_EPR31 = 0x80000000

	// EPIN: USB Endpoint Index
	// Position of PHY_EP field.
	USB_EPIN_PHY_EP_Pos = 0x0
	// Bit mask of PHY_EP field.
	USB_EPIN_PHY_EP_Msk = 0x1f
	// Position of RESERVED field.
	USB_EPIN_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	USB_EPIN_RESERVED_Msk = 0xffffffe0

	// MAXPSIZE: USB MaxPacketSize
	// Position of MPS field.
	USB_MAXPSIZE_MPS_Pos = 0x0
	// Bit mask of MPS field.
	USB_MAXPSIZE_MPS_Msk = 0x3ff
	// Position of RESERVED field.
	USB_MAXPSIZE_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	USB_MAXPSIZE_RESERVED_Msk = 0xfffffc00

	// DMARST: USB DMA Request Status
	// Position of EPRST0 field.
	USB_DMARST_EPRST0_Pos = 0x0
	// Bit mask of EPRST0 field.
	USB_DMARST_EPRST0_Msk = 0x1
	// Bit EPRST0.
	USB_DMARST_EPRST0 = 0x1
	// Position of EPRST1 field.
	USB_DMARST_EPRST1_Pos = 0x1
	// Bit mask of EPRST1 field.
	USB_DMARST_EPRST1_Msk = 0x2
	// Bit EPRST1.
	USB_DMARST_EPRST1 = 0x2
	// Position of EPRST2 field.
	USB_DMARST_EPRST2_Pos = 0x2
	// Bit mask of EPRST2 field.
	USB_DMARST_EPRST2_Msk = 0x4
	// Bit EPRST2.
	USB_DMARST_EPRST2 = 0x4
	// Position of EPRST3 field.
	USB_DMARST_EPRST3_Pos = 0x3
	// Bit mask of EPRST3 field.
	USB_DMARST_EPRST3_Msk = 0x8
	// Bit EPRST3.
	USB_DMARST_EPRST3 = 0x8
	// Position of EPRST4 field.
	USB_DMARST_EPRST4_Pos = 0x4
	// Bit mask of EPRST4 field.
	USB_DMARST_EPRST4_Msk = 0x10
	// Bit EPRST4.
	USB_DMARST_EPRST4 = 0x10
	// Position of EPRST5 field.
	USB_DMARST_EPRST5_Pos = 0x5
	// Bit mask of EPRST5 field.
	USB_DMARST_EPRST5_Msk = 0x20
	// Bit EPRST5.
	USB_DMARST_EPRST5 = 0x20
	// Position of EPRST6 field.
	USB_DMARST_EPRST6_Pos = 0x6
	// Bit mask of EPRST6 field.
	USB_DMARST_EPRST6_Msk = 0x40
	// Bit EPRST6.
	USB_DMARST_EPRST6 = 0x40
	// Position of EPRST7 field.
	USB_DMARST_EPRST7_Pos = 0x7
	// Bit mask of EPRST7 field.
	USB_DMARST_EPRST7_Msk = 0x80
	// Bit EPRST7.
	USB_DMARST_EPRST7 = 0x80
	// Position of EPRST8 field.
	USB_DMARST_EPRST8_Pos = 0x8
	// Bit mask of EPRST8 field.
	USB_DMARST_EPRST8_Msk = 0x100
	// Bit EPRST8.
	USB_DMARST_EPRST8 = 0x100
	// Position of EPRST9 field.
	USB_DMARST_EPRST9_Pos = 0x9
	// Bit mask of EPRST9 field.
	USB_DMARST_EPRST9_Msk = 0x200
	// Bit EPRST9.
	USB_DMARST_EPRST9 = 0x200
	// Position of EPRST10 field.
	USB_DMARST_EPRST10_Pos = 0xa
	// Bit mask of EPRST10 field.
	USB_DMARST_EPRST10_Msk = 0x400
	// Bit EPRST10.
	USB_DMARST_EPRST10 = 0x400
	// Position of EPRST11 field.
	USB_DMARST_EPRST11_Pos = 0xb
	// Bit mask of EPRST11 field.
	USB_DMARST_EPRST11_Msk = 0x800
	// Bit EPRST11.
	USB_DMARST_EPRST11 = 0x800
	// Position of EPRST12 field.
	USB_DMARST_EPRST12_Pos = 0xc
	// Bit mask of EPRST12 field.
	USB_DMARST_EPRST12_Msk = 0x1000
	// Bit EPRST12.
	USB_DMARST_EPRST12 = 0x1000
	// Position of EPRST13 field.
	USB_DMARST_EPRST13_Pos = 0xd
	// Bit mask of EPRST13 field.
	USB_DMARST_EPRST13_Msk = 0x2000
	// Bit EPRST13.
	USB_DMARST_EPRST13 = 0x2000
	// Position of EPRST14 field.
	USB_DMARST_EPRST14_Pos = 0xe
	// Bit mask of EPRST14 field.
	USB_DMARST_EPRST14_Msk = 0x4000
	// Bit EPRST14.
	USB_DMARST_EPRST14 = 0x4000
	// Position of EPRST15 field.
	USB_DMARST_EPRST15_Pos = 0xf
	// Bit mask of EPRST15 field.
	USB_DMARST_EPRST15_Msk = 0x8000
	// Bit EPRST15.
	USB_DMARST_EPRST15 = 0x8000
	// Position of EPRST16 field.
	USB_DMARST_EPRST16_Pos = 0x10
	// Bit mask of EPRST16 field.
	USB_DMARST_EPRST16_Msk = 0x10000
	// Bit EPRST16.
	USB_DMARST_EPRST16 = 0x10000
	// Position of EPRST17 field.
	USB_DMARST_EPRST17_Pos = 0x11
	// Bit mask of EPRST17 field.
	USB_DMARST_EPRST17_Msk = 0x20000
	// Bit EPRST17.
	USB_DMARST_EPRST17 = 0x20000
	// Position of EPRST18 field.
	USB_DMARST_EPRST18_Pos = 0x12
	// Bit mask of EPRST18 field.
	USB_DMARST_EPRST18_Msk = 0x40000
	// Bit EPRST18.
	USB_DMARST_EPRST18 = 0x40000
	// Position of EPRST19 field.
	USB_DMARST_EPRST19_Pos = 0x13
	// Bit mask of EPRST19 field.
	USB_DMARST_EPRST19_Msk = 0x80000
	// Bit EPRST19.
	USB_DMARST_EPRST19 = 0x80000
	// Position of EPRST20 field.
	USB_DMARST_EPRST20_Pos = 0x14
	// Bit mask of EPRST20 field.
	USB_DMARST_EPRST20_Msk = 0x100000
	// Bit EPRST20.
	USB_DMARST_EPRST20 = 0x100000
	// Position of EPRST21 field.
	USB_DMARST_EPRST21_Pos = 0x15
	// Bit mask of EPRST21 field.
	USB_DMARST_EPRST21_Msk = 0x200000
	// Bit EPRST21.
	USB_DMARST_EPRST21 = 0x200000
	// Position of EPRST22 field.
	USB_DMARST_EPRST22_Pos = 0x16
	// Bit mask of EPRST22 field.
	USB_DMARST_EPRST22_Msk = 0x400000
	// Bit EPRST22.
	USB_DMARST_EPRST22 = 0x400000
	// Position of EPRST23 field.
	USB_DMARST_EPRST23_Pos = 0x17
	// Bit mask of EPRST23 field.
	USB_DMARST_EPRST23_Msk = 0x800000
	// Bit EPRST23.
	USB_DMARST_EPRST23 = 0x800000
	// Position of EPRST24 field.
	USB_DMARST_EPRST24_Pos = 0x18
	// Bit mask of EPRST24 field.
	USB_DMARST_EPRST24_Msk = 0x1000000
	// Bit EPRST24.
	USB_DMARST_EPRST24 = 0x1000000
	// Position of EPRST25 field.
	USB_DMARST_EPRST25_Pos = 0x19
	// Bit mask of EPRST25 field.
	USB_DMARST_EPRST25_Msk = 0x2000000
	// Bit EPRST25.
	USB_DMARST_EPRST25 = 0x2000000
	// Position of EPRST26 field.
	USB_DMARST_EPRST26_Pos = 0x1a
	// Bit mask of EPRST26 field.
	USB_DMARST_EPRST26_Msk = 0x4000000
	// Bit EPRST26.
	USB_DMARST_EPRST26 = 0x4000000
	// Position of EPRST27 field.
	USB_DMARST_EPRST27_Pos = 0x1b
	// Bit mask of EPRST27 field.
	USB_DMARST_EPRST27_Msk = 0x8000000
	// Bit EPRST27.
	USB_DMARST_EPRST27 = 0x8000000
	// Position of EPRST28 field.
	USB_DMARST_EPRST28_Pos = 0x1c
	// Bit mask of EPRST28 field.
	USB_DMARST_EPRST28_Msk = 0x10000000
	// Bit EPRST28.
	USB_DMARST_EPRST28 = 0x10000000
	// Position of EPRST29 field.
	USB_DMARST_EPRST29_Pos = 0x1d
	// Bit mask of EPRST29 field.
	USB_DMARST_EPRST29_Msk = 0x20000000
	// Bit EPRST29.
	USB_DMARST_EPRST29 = 0x20000000
	// Position of EPRST30 field.
	USB_DMARST_EPRST30_Pos = 0x1e
	// Bit mask of EPRST30 field.
	USB_DMARST_EPRST30_Msk = 0x40000000
	// Bit EPRST30.
	USB_DMARST_EPRST30 = 0x40000000
	// Position of EPRST31 field.
	USB_DMARST_EPRST31_Pos = 0x1f
	// Bit mask of EPRST31 field.
	USB_DMARST_EPRST31_Msk = 0x80000000
	// Bit EPRST31.
	USB_DMARST_EPRST31 = 0x80000000

	// DMARCLR: USB DMA Request Clear
	// Position of EPRCLR0 field.
	USB_DMARCLR_EPRCLR0_Pos = 0x0
	// Bit mask of EPRCLR0 field.
	USB_DMARCLR_EPRCLR0_Msk = 0x1
	// Bit EPRCLR0.
	USB_DMARCLR_EPRCLR0 = 0x1
	// Position of EPRCLR1 field.
	USB_DMARCLR_EPRCLR1_Pos = 0x1
	// Bit mask of EPRCLR1 field.
	USB_DMARCLR_EPRCLR1_Msk = 0x2
	// Bit EPRCLR1.
	USB_DMARCLR_EPRCLR1 = 0x2
	// Position of EPRCLR2 field.
	USB_DMARCLR_EPRCLR2_Pos = 0x2
	// Bit mask of EPRCLR2 field.
	USB_DMARCLR_EPRCLR2_Msk = 0x4
	// Bit EPRCLR2.
	USB_DMARCLR_EPRCLR2 = 0x4
	// Position of EPRCLR3 field.
	USB_DMARCLR_EPRCLR3_Pos = 0x3
	// Bit mask of EPRCLR3 field.
	USB_DMARCLR_EPRCLR3_Msk = 0x8
	// Bit EPRCLR3.
	USB_DMARCLR_EPRCLR3 = 0x8
	// Position of EPRCLR4 field.
	USB_DMARCLR_EPRCLR4_Pos = 0x4
	// Bit mask of EPRCLR4 field.
	USB_DMARCLR_EPRCLR4_Msk = 0x10
	// Bit EPRCLR4.
	USB_DMARCLR_EPRCLR4 = 0x10
	// Position of EPRCLR5 field.
	USB_DMARCLR_EPRCLR5_Pos = 0x5
	// Bit mask of EPRCLR5 field.
	USB_DMARCLR_EPRCLR5_Msk = 0x20
	// Bit EPRCLR5.
	USB_DMARCLR_EPRCLR5 = 0x20
	// Position of EPRCLR6 field.
	USB_DMARCLR_EPRCLR6_Pos = 0x6
	// Bit mask of EPRCLR6 field.
	USB_DMARCLR_EPRCLR6_Msk = 0x40
	// Bit EPRCLR6.
	USB_DMARCLR_EPRCLR6 = 0x40
	// Position of EPRCLR7 field.
	USB_DMARCLR_EPRCLR7_Pos = 0x7
	// Bit mask of EPRCLR7 field.
	USB_DMARCLR_EPRCLR7_Msk = 0x80
	// Bit EPRCLR7.
	USB_DMARCLR_EPRCLR7 = 0x80
	// Position of EPRCLR8 field.
	USB_DMARCLR_EPRCLR8_Pos = 0x8
	// Bit mask of EPRCLR8 field.
	USB_DMARCLR_EPRCLR8_Msk = 0x100
	// Bit EPRCLR8.
	USB_DMARCLR_EPRCLR8 = 0x100
	// Position of EPRCLR9 field.
	USB_DMARCLR_EPRCLR9_Pos = 0x9
	// Bit mask of EPRCLR9 field.
	USB_DMARCLR_EPRCLR9_Msk = 0x200
	// Bit EPRCLR9.
	USB_DMARCLR_EPRCLR9 = 0x200
	// Position of EPRCLR10 field.
	USB_DMARCLR_EPRCLR10_Pos = 0xa
	// Bit mask of EPRCLR10 field.
	USB_DMARCLR_EPRCLR10_Msk = 0x400
	// Bit EPRCLR10.
	USB_DMARCLR_EPRCLR10 = 0x400
	// Position of EPRCLR11 field.
	USB_DMARCLR_EPRCLR11_Pos = 0xb
	// Bit mask of EPRCLR11 field.
	USB_DMARCLR_EPRCLR11_Msk = 0x800
	// Bit EPRCLR11.
	USB_DMARCLR_EPRCLR11 = 0x800
	// Position of EPRCLR12 field.
	USB_DMARCLR_EPRCLR12_Pos = 0xc
	// Bit mask of EPRCLR12 field.
	USB_DMARCLR_EPRCLR12_Msk = 0x1000
	// Bit EPRCLR12.
	USB_DMARCLR_EPRCLR12 = 0x1000
	// Position of EPRCLR13 field.
	USB_DMARCLR_EPRCLR13_Pos = 0xd
	// Bit mask of EPRCLR13 field.
	USB_DMARCLR_EPRCLR13_Msk = 0x2000
	// Bit EPRCLR13.
	USB_DMARCLR_EPRCLR13 = 0x2000
	// Position of EPRCLR14 field.
	USB_DMARCLR_EPRCLR14_Pos = 0xe
	// Bit mask of EPRCLR14 field.
	USB_DMARCLR_EPRCLR14_Msk = 0x4000
	// Bit EPRCLR14.
	USB_DMARCLR_EPRCLR14 = 0x4000
	// Position of EPRCLR15 field.
	USB_DMARCLR_EPRCLR15_Pos = 0xf
	// Bit mask of EPRCLR15 field.
	USB_DMARCLR_EPRCLR15_Msk = 0x8000
	// Bit EPRCLR15.
	USB_DMARCLR_EPRCLR15 = 0x8000
	// Position of EPRCLR16 field.
	USB_DMARCLR_EPRCLR16_Pos = 0x10
	// Bit mask of EPRCLR16 field.
	USB_DMARCLR_EPRCLR16_Msk = 0x10000
	// Bit EPRCLR16.
	USB_DMARCLR_EPRCLR16 = 0x10000
	// Position of EPRCLR17 field.
	USB_DMARCLR_EPRCLR17_Pos = 0x11
	// Bit mask of EPRCLR17 field.
	USB_DMARCLR_EPRCLR17_Msk = 0x20000
	// Bit EPRCLR17.
	USB_DMARCLR_EPRCLR17 = 0x20000
	// Position of EPRCLR18 field.
	USB_DMARCLR_EPRCLR18_Pos = 0x12
	// Bit mask of EPRCLR18 field.
	USB_DMARCLR_EPRCLR18_Msk = 0x40000
	// Bit EPRCLR18.
	USB_DMARCLR_EPRCLR18 = 0x40000
	// Position of EPRCLR19 field.
	USB_DMARCLR_EPRCLR19_Pos = 0x13
	// Bit mask of EPRCLR19 field.
	USB_DMARCLR_EPRCLR19_Msk = 0x80000
	// Bit EPRCLR19.
	USB_DMARCLR_EPRCLR19 = 0x80000
	// Position of EPRCLR20 field.
	USB_DMARCLR_EPRCLR20_Pos = 0x14
	// Bit mask of EPRCLR20 field.
	USB_DMARCLR_EPRCLR20_Msk = 0x100000
	// Bit EPRCLR20.
	USB_DMARCLR_EPRCLR20 = 0x100000
	// Position of EPRCLR21 field.
	USB_DMARCLR_EPRCLR21_Pos = 0x15
	// Bit mask of EPRCLR21 field.
	USB_DMARCLR_EPRCLR21_Msk = 0x200000
	// Bit EPRCLR21.
	USB_DMARCLR_EPRCLR21 = 0x200000
	// Position of EPRCLR22 field.
	USB_DMARCLR_EPRCLR22_Pos = 0x16
	// Bit mask of EPRCLR22 field.
	USB_DMARCLR_EPRCLR22_Msk = 0x400000
	// Bit EPRCLR22.
	USB_DMARCLR_EPRCLR22 = 0x400000
	// Position of EPRCLR23 field.
	USB_DMARCLR_EPRCLR23_Pos = 0x17
	// Bit mask of EPRCLR23 field.
	USB_DMARCLR_EPRCLR23_Msk = 0x800000
	// Bit EPRCLR23.
	USB_DMARCLR_EPRCLR23 = 0x800000
	// Position of EPRCLR24 field.
	USB_DMARCLR_EPRCLR24_Pos = 0x18
	// Bit mask of EPRCLR24 field.
	USB_DMARCLR_EPRCLR24_Msk = 0x1000000
	// Bit EPRCLR24.
	USB_DMARCLR_EPRCLR24 = 0x1000000
	// Position of EPRCLR25 field.
	USB_DMARCLR_EPRCLR25_Pos = 0x19
	// Bit mask of EPRCLR25 field.
	USB_DMARCLR_EPRCLR25_Msk = 0x2000000
	// Bit EPRCLR25.
	USB_DMARCLR_EPRCLR25 = 0x2000000
	// Position of EPRCLR26 field.
	USB_DMARCLR_EPRCLR26_Pos = 0x1a
	// Bit mask of EPRCLR26 field.
	USB_DMARCLR_EPRCLR26_Msk = 0x4000000
	// Bit EPRCLR26.
	USB_DMARCLR_EPRCLR26 = 0x4000000
	// Position of EPRCLR27 field.
	USB_DMARCLR_EPRCLR27_Pos = 0x1b
	// Bit mask of EPRCLR27 field.
	USB_DMARCLR_EPRCLR27_Msk = 0x8000000
	// Bit EPRCLR27.
	USB_DMARCLR_EPRCLR27 = 0x8000000
	// Position of EPRCLR28 field.
	USB_DMARCLR_EPRCLR28_Pos = 0x1c
	// Bit mask of EPRCLR28 field.
	USB_DMARCLR_EPRCLR28_Msk = 0x10000000
	// Bit EPRCLR28.
	USB_DMARCLR_EPRCLR28 = 0x10000000
	// Position of EPRCLR29 field.
	USB_DMARCLR_EPRCLR29_Pos = 0x1d
	// Bit mask of EPRCLR29 field.
	USB_DMARCLR_EPRCLR29_Msk = 0x20000000
	// Bit EPRCLR29.
	USB_DMARCLR_EPRCLR29 = 0x20000000
	// Position of EPRCLR30 field.
	USB_DMARCLR_EPRCLR30_Pos = 0x1e
	// Bit mask of EPRCLR30 field.
	USB_DMARCLR_EPRCLR30_Msk = 0x40000000
	// Bit EPRCLR30.
	USB_DMARCLR_EPRCLR30 = 0x40000000
	// Position of EPRCLR31 field.
	USB_DMARCLR_EPRCLR31_Pos = 0x1f
	// Bit mask of EPRCLR31 field.
	USB_DMARCLR_EPRCLR31_Msk = 0x80000000
	// Bit EPRCLR31.
	USB_DMARCLR_EPRCLR31 = 0x80000000

	// DMARSET: USB DMA Request Set
	// Position of EPRSET0 field.
	USB_DMARSET_EPRSET0_Pos = 0x0
	// Bit mask of EPRSET0 field.
	USB_DMARSET_EPRSET0_Msk = 0x1
	// Bit EPRSET0.
	USB_DMARSET_EPRSET0 = 0x1
	// Position of EPRSET1 field.
	USB_DMARSET_EPRSET1_Pos = 0x1
	// Bit mask of EPRSET1 field.
	USB_DMARSET_EPRSET1_Msk = 0x2
	// Bit EPRSET1.
	USB_DMARSET_EPRSET1 = 0x2
	// Position of EPRSET2 field.
	USB_DMARSET_EPRSET2_Pos = 0x2
	// Bit mask of EPRSET2 field.
	USB_DMARSET_EPRSET2_Msk = 0x4
	// Bit EPRSET2.
	USB_DMARSET_EPRSET2 = 0x4
	// Position of EPRSET3 field.
	USB_DMARSET_EPRSET3_Pos = 0x3
	// Bit mask of EPRSET3 field.
	USB_DMARSET_EPRSET3_Msk = 0x8
	// Bit EPRSET3.
	USB_DMARSET_EPRSET3 = 0x8
	// Position of EPRSET4 field.
	USB_DMARSET_EPRSET4_Pos = 0x4
	// Bit mask of EPRSET4 field.
	USB_DMARSET_EPRSET4_Msk = 0x10
	// Bit EPRSET4.
	USB_DMARSET_EPRSET4 = 0x10
	// Position of EPRSET5 field.
	USB_DMARSET_EPRSET5_Pos = 0x5
	// Bit mask of EPRSET5 field.
	USB_DMARSET_EPRSET5_Msk = 0x20
	// Bit EPRSET5.
	USB_DMARSET_EPRSET5 = 0x20
	// Position of EPRSET6 field.
	USB_DMARSET_EPRSET6_Pos = 0x6
	// Bit mask of EPRSET6 field.
	USB_DMARSET_EPRSET6_Msk = 0x40
	// Bit EPRSET6.
	USB_DMARSET_EPRSET6 = 0x40
	// Position of EPRSET7 field.
	USB_DMARSET_EPRSET7_Pos = 0x7
	// Bit mask of EPRSET7 field.
	USB_DMARSET_EPRSET7_Msk = 0x80
	// Bit EPRSET7.
	USB_DMARSET_EPRSET7 = 0x80
	// Position of EPRSET8 field.
	USB_DMARSET_EPRSET8_Pos = 0x8
	// Bit mask of EPRSET8 field.
	USB_DMARSET_EPRSET8_Msk = 0x100
	// Bit EPRSET8.
	USB_DMARSET_EPRSET8 = 0x100
	// Position of EPRSET9 field.
	USB_DMARSET_EPRSET9_Pos = 0x9
	// Bit mask of EPRSET9 field.
	USB_DMARSET_EPRSET9_Msk = 0x200
	// Bit EPRSET9.
	USB_DMARSET_EPRSET9 = 0x200
	// Position of EPRSET10 field.
	USB_DMARSET_EPRSET10_Pos = 0xa
	// Bit mask of EPRSET10 field.
	USB_DMARSET_EPRSET10_Msk = 0x400
	// Bit EPRSET10.
	USB_DMARSET_EPRSET10 = 0x400
	// Position of EPRSET11 field.
	USB_DMARSET_EPRSET11_Pos = 0xb
	// Bit mask of EPRSET11 field.
	USB_DMARSET_EPRSET11_Msk = 0x800
	// Bit EPRSET11.
	USB_DMARSET_EPRSET11 = 0x800
	// Position of EPRSET12 field.
	USB_DMARSET_EPRSET12_Pos = 0xc
	// Bit mask of EPRSET12 field.
	USB_DMARSET_EPRSET12_Msk = 0x1000
	// Bit EPRSET12.
	USB_DMARSET_EPRSET12 = 0x1000
	// Position of EPRSET13 field.
	USB_DMARSET_EPRSET13_Pos = 0xd
	// Bit mask of EPRSET13 field.
	USB_DMARSET_EPRSET13_Msk = 0x2000
	// Bit EPRSET13.
	USB_DMARSET_EPRSET13 = 0x2000
	// Position of EPRSET14 field.
	USB_DMARSET_EPRSET14_Pos = 0xe
	// Bit mask of EPRSET14 field.
	USB_DMARSET_EPRSET14_Msk = 0x4000
	// Bit EPRSET14.
	USB_DMARSET_EPRSET14 = 0x4000
	// Position of EPRSET15 field.
	USB_DMARSET_EPRSET15_Pos = 0xf
	// Bit mask of EPRSET15 field.
	USB_DMARSET_EPRSET15_Msk = 0x8000
	// Bit EPRSET15.
	USB_DMARSET_EPRSET15 = 0x8000
	// Position of EPRSET16 field.
	USB_DMARSET_EPRSET16_Pos = 0x10
	// Bit mask of EPRSET16 field.
	USB_DMARSET_EPRSET16_Msk = 0x10000
	// Bit EPRSET16.
	USB_DMARSET_EPRSET16 = 0x10000
	// Position of EPRSET17 field.
	USB_DMARSET_EPRSET17_Pos = 0x11
	// Bit mask of EPRSET17 field.
	USB_DMARSET_EPRSET17_Msk = 0x20000
	// Bit EPRSET17.
	USB_DMARSET_EPRSET17 = 0x20000
	// Position of EPRSET18 field.
	USB_DMARSET_EPRSET18_Pos = 0x12
	// Bit mask of EPRSET18 field.
	USB_DMARSET_EPRSET18_Msk = 0x40000
	// Bit EPRSET18.
	USB_DMARSET_EPRSET18 = 0x40000
	// Position of EPRSET19 field.
	USB_DMARSET_EPRSET19_Pos = 0x13
	// Bit mask of EPRSET19 field.
	USB_DMARSET_EPRSET19_Msk = 0x80000
	// Bit EPRSET19.
	USB_DMARSET_EPRSET19 = 0x80000
	// Position of EPRSET20 field.
	USB_DMARSET_EPRSET20_Pos = 0x14
	// Bit mask of EPRSET20 field.
	USB_DMARSET_EPRSET20_Msk = 0x100000
	// Bit EPRSET20.
	USB_DMARSET_EPRSET20 = 0x100000
	// Position of EPRSET21 field.
	USB_DMARSET_EPRSET21_Pos = 0x15
	// Bit mask of EPRSET21 field.
	USB_DMARSET_EPRSET21_Msk = 0x200000
	// Bit EPRSET21.
	USB_DMARSET_EPRSET21 = 0x200000
	// Position of EPRSET22 field.
	USB_DMARSET_EPRSET22_Pos = 0x16
	// Bit mask of EPRSET22 field.
	USB_DMARSET_EPRSET22_Msk = 0x400000
	// Bit EPRSET22.
	USB_DMARSET_EPRSET22 = 0x400000
	// Position of EPRSET23 field.
	USB_DMARSET_EPRSET23_Pos = 0x17
	// Bit mask of EPRSET23 field.
	USB_DMARSET_EPRSET23_Msk = 0x800000
	// Bit EPRSET23.
	USB_DMARSET_EPRSET23 = 0x800000
	// Position of EPRSET24 field.
	USB_DMARSET_EPRSET24_Pos = 0x18
	// Bit mask of EPRSET24 field.
	USB_DMARSET_EPRSET24_Msk = 0x1000000
	// Bit EPRSET24.
	USB_DMARSET_EPRSET24 = 0x1000000
	// Position of EPRSET25 field.
	USB_DMARSET_EPRSET25_Pos = 0x19
	// Bit mask of EPRSET25 field.
	USB_DMARSET_EPRSET25_Msk = 0x2000000
	// Bit EPRSET25.
	USB_DMARSET_EPRSET25 = 0x2000000
	// Position of EPRSET26 field.
	USB_DMARSET_EPRSET26_Pos = 0x1a
	// Bit mask of EPRSET26 field.
	USB_DMARSET_EPRSET26_Msk = 0x4000000
	// Bit EPRSET26.
	USB_DMARSET_EPRSET26 = 0x4000000
	// Position of EPRSET27 field.
	USB_DMARSET_EPRSET27_Pos = 0x1b
	// Bit mask of EPRSET27 field.
	USB_DMARSET_EPRSET27_Msk = 0x8000000
	// Bit EPRSET27.
	USB_DMARSET_EPRSET27 = 0x8000000
	// Position of EPRSET28 field.
	USB_DMARSET_EPRSET28_Pos = 0x1c
	// Bit mask of EPRSET28 field.
	USB_DMARSET_EPRSET28_Msk = 0x10000000
	// Bit EPRSET28.
	USB_DMARSET_EPRSET28 = 0x10000000
	// Position of EPRSET29 field.
	USB_DMARSET_EPRSET29_Pos = 0x1d
	// Bit mask of EPRSET29 field.
	USB_DMARSET_EPRSET29_Msk = 0x20000000
	// Bit EPRSET29.
	USB_DMARSET_EPRSET29 = 0x20000000
	// Position of EPRSET30 field.
	USB_DMARSET_EPRSET30_Pos = 0x1e
	// Bit mask of EPRSET30 field.
	USB_DMARSET_EPRSET30_Msk = 0x40000000
	// Bit EPRSET30.
	USB_DMARSET_EPRSET30 = 0x40000000
	// Position of EPRSET31 field.
	USB_DMARSET_EPRSET31_Pos = 0x1f
	// Bit mask of EPRSET31 field.
	USB_DMARSET_EPRSET31_Msk = 0x80000000
	// Bit EPRSET31.
	USB_DMARSET_EPRSET31 = 0x80000000

	// UDCAH: USB UDCA Head
	// Position of RESERVED field.
	USB_UDCAH_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	USB_UDCAH_RESERVED_Msk = 0x7f
	// Position of UDCA_ADDR field.
	USB_UDCAH_UDCA_ADDR_Pos = 0x7
	// Bit mask of UDCA_ADDR field.
	USB_UDCAH_UDCA_ADDR_Msk = 0xffffff80

	// EPDMAST: USB Endpoint DMA Status
	// Position of EP_DMA_ST0 field.
	USB_EPDMAST_EP_DMA_ST0_Pos = 0x0
	// Bit mask of EP_DMA_ST0 field.
	USB_EPDMAST_EP_DMA_ST0_Msk = 0x1
	// Bit EP_DMA_ST0.
	USB_EPDMAST_EP_DMA_ST0 = 0x1
	// Position of EP_DMA_ST1 field.
	USB_EPDMAST_EP_DMA_ST1_Pos = 0x1
	// Bit mask of EP_DMA_ST1 field.
	USB_EPDMAST_EP_DMA_ST1_Msk = 0x2
	// Bit EP_DMA_ST1.
	USB_EPDMAST_EP_DMA_ST1 = 0x2
	// Position of EP_DMA_ST2 field.
	USB_EPDMAST_EP_DMA_ST2_Pos = 0x2
	// Bit mask of EP_DMA_ST2 field.
	USB_EPDMAST_EP_DMA_ST2_Msk = 0x4
	// Bit EP_DMA_ST2.
	USB_EPDMAST_EP_DMA_ST2 = 0x4
	// Position of EP_DMA_ST3 field.
	USB_EPDMAST_EP_DMA_ST3_Pos = 0x3
	// Bit mask of EP_DMA_ST3 field.
	USB_EPDMAST_EP_DMA_ST3_Msk = 0x8
	// Bit EP_DMA_ST3.
	USB_EPDMAST_EP_DMA_ST3 = 0x8
	// Position of EP_DMA_ST4 field.
	USB_EPDMAST_EP_DMA_ST4_Pos = 0x4
	// Bit mask of EP_DMA_ST4 field.
	USB_EPDMAST_EP_DMA_ST4_Msk = 0x10
	// Bit EP_DMA_ST4.
	USB_EPDMAST_EP_DMA_ST4 = 0x10
	// Position of EP_DMA_ST5 field.
	USB_EPDMAST_EP_DMA_ST5_Pos = 0x5
	// Bit mask of EP_DMA_ST5 field.
	USB_EPDMAST_EP_DMA_ST5_Msk = 0x20
	// Bit EP_DMA_ST5.
	USB_EPDMAST_EP_DMA_ST5 = 0x20
	// Position of EP_DMA_ST6 field.
	USB_EPDMAST_EP_DMA_ST6_Pos = 0x6
	// Bit mask of EP_DMA_ST6 field.
	USB_EPDMAST_EP_DMA_ST6_Msk = 0x40
	// Bit EP_DMA_ST6.
	USB_EPDMAST_EP_DMA_ST6 = 0x40
	// Position of EP_DMA_ST7 field.
	USB_EPDMAST_EP_DMA_ST7_Pos = 0x7
	// Bit mask of EP_DMA_ST7 field.
	USB_EPDMAST_EP_DMA_ST7_Msk = 0x80
	// Bit EP_DMA_ST7.
	USB_EPDMAST_EP_DMA_ST7 = 0x80
	// Position of EP_DMA_ST8 field.
	USB_EPDMAST_EP_DMA_ST8_Pos = 0x8
	// Bit mask of EP_DMA_ST8 field.
	USB_EPDMAST_EP_DMA_ST8_Msk = 0x100
	// Bit EP_DMA_ST8.
	USB_EPDMAST_EP_DMA_ST8 = 0x100
	// Position of EP_DMA_ST9 field.
	USB_EPDMAST_EP_DMA_ST9_Pos = 0x9
	// Bit mask of EP_DMA_ST9 field.
	USB_EPDMAST_EP_DMA_ST9_Msk = 0x200
	// Bit EP_DMA_ST9.
	USB_EPDMAST_EP_DMA_ST9 = 0x200
	// Position of EP_DMA_ST10 field.
	USB_EPDMAST_EP_DMA_ST10_Pos = 0xa
	// Bit mask of EP_DMA_ST10 field.
	USB_EPDMAST_EP_DMA_ST10_Msk = 0x400
	// Bit EP_DMA_ST10.
	USB_EPDMAST_EP_DMA_ST10 = 0x400
	// Position of EP_DMA_ST11 field.
	USB_EPDMAST_EP_DMA_ST11_Pos = 0xb
	// Bit mask of EP_DMA_ST11 field.
	USB_EPDMAST_EP_DMA_ST11_Msk = 0x800
	// Bit EP_DMA_ST11.
	USB_EPDMAST_EP_DMA_ST11 = 0x800
	// Position of EP_DMA_ST12 field.
	USB_EPDMAST_EP_DMA_ST12_Pos = 0xc
	// Bit mask of EP_DMA_ST12 field.
	USB_EPDMAST_EP_DMA_ST12_Msk = 0x1000
	// Bit EP_DMA_ST12.
	USB_EPDMAST_EP_DMA_ST12 = 0x1000
	// Position of EP_DMA_ST13 field.
	USB_EPDMAST_EP_DMA_ST13_Pos = 0xd
	// Bit mask of EP_DMA_ST13 field.
	USB_EPDMAST_EP_DMA_ST13_Msk = 0x2000
	// Bit EP_DMA_ST13.
	USB_EPDMAST_EP_DMA_ST13 = 0x2000
	// Position of EP_DMA_ST14 field.
	USB_EPDMAST_EP_DMA_ST14_Pos = 0xe
	// Bit mask of EP_DMA_ST14 field.
	USB_EPDMAST_EP_DMA_ST14_Msk = 0x4000
	// Bit EP_DMA_ST14.
	USB_EPDMAST_EP_DMA_ST14 = 0x4000
	// Position of EP_DMA_ST15 field.
	USB_EPDMAST_EP_DMA_ST15_Pos = 0xf
	// Bit mask of EP_DMA_ST15 field.
	USB_EPDMAST_EP_DMA_ST15_Msk = 0x8000
	// Bit EP_DMA_ST15.
	USB_EPDMAST_EP_DMA_ST15 = 0x8000
	// Position of EP_DMA_ST16 field.
	USB_EPDMAST_EP_DMA_ST16_Pos = 0x10
	// Bit mask of EP_DMA_ST16 field.
	USB_EPDMAST_EP_DMA_ST16_Msk = 0x10000
	// Bit EP_DMA_ST16.
	USB_EPDMAST_EP_DMA_ST16 = 0x10000
	// Position of EP_DMA_ST17 field.
	USB_EPDMAST_EP_DMA_ST17_Pos = 0x11
	// Bit mask of EP_DMA_ST17 field.
	USB_EPDMAST_EP_DMA_ST17_Msk = 0x20000
	// Bit EP_DMA_ST17.
	USB_EPDMAST_EP_DMA_ST17 = 0x20000
	// Position of EP_DMA_ST18 field.
	USB_EPDMAST_EP_DMA_ST18_Pos = 0x12
	// Bit mask of EP_DMA_ST18 field.
	USB_EPDMAST_EP_DMA_ST18_Msk = 0x40000
	// Bit EP_DMA_ST18.
	USB_EPDMAST_EP_DMA_ST18 = 0x40000
	// Position of EP_DMA_ST19 field.
	USB_EPDMAST_EP_DMA_ST19_Pos = 0x13
	// Bit mask of EP_DMA_ST19 field.
	USB_EPDMAST_EP_DMA_ST19_Msk = 0x80000
	// Bit EP_DMA_ST19.
	USB_EPDMAST_EP_DMA_ST19 = 0x80000
	// Position of EP_DMA_ST20 field.
	USB_EPDMAST_EP_DMA_ST20_Pos = 0x14
	// Bit mask of EP_DMA_ST20 field.
	USB_EPDMAST_EP_DMA_ST20_Msk = 0x100000
	// Bit EP_DMA_ST20.
	USB_EPDMAST_EP_DMA_ST20 = 0x100000
	// Position of EP_DMA_ST21 field.
	USB_EPDMAST_EP_DMA_ST21_Pos = 0x15
	// Bit mask of EP_DMA_ST21 field.
	USB_EPDMAST_EP_DMA_ST21_Msk = 0x200000
	// Bit EP_DMA_ST21.
	USB_EPDMAST_EP_DMA_ST21 = 0x200000
	// Position of EP_DMA_ST22 field.
	USB_EPDMAST_EP_DMA_ST22_Pos = 0x16
	// Bit mask of EP_DMA_ST22 field.
	USB_EPDMAST_EP_DMA_ST22_Msk = 0x400000
	// Bit EP_DMA_ST22.
	USB_EPDMAST_EP_DMA_ST22 = 0x400000
	// Position of EP_DMA_ST23 field.
	USB_EPDMAST_EP_DMA_ST23_Pos = 0x17
	// Bit mask of EP_DMA_ST23 field.
	USB_EPDMAST_EP_DMA_ST23_Msk = 0x800000
	// Bit EP_DMA_ST23.
	USB_EPDMAST_EP_DMA_ST23 = 0x800000
	// Position of EP_DMA_ST24 field.
	USB_EPDMAST_EP_DMA_ST24_Pos = 0x18
	// Bit mask of EP_DMA_ST24 field.
	USB_EPDMAST_EP_DMA_ST24_Msk = 0x1000000
	// Bit EP_DMA_ST24.
	USB_EPDMAST_EP_DMA_ST24 = 0x1000000
	// Position of EP_DMA_ST25 field.
	USB_EPDMAST_EP_DMA_ST25_Pos = 0x19
	// Bit mask of EP_DMA_ST25 field.
	USB_EPDMAST_EP_DMA_ST25_Msk = 0x2000000
	// Bit EP_DMA_ST25.
	USB_EPDMAST_EP_DMA_ST25 = 0x2000000
	// Position of EP_DMA_ST26 field.
	USB_EPDMAST_EP_DMA_ST26_Pos = 0x1a
	// Bit mask of EP_DMA_ST26 field.
	USB_EPDMAST_EP_DMA_ST26_Msk = 0x4000000
	// Bit EP_DMA_ST26.
	USB_EPDMAST_EP_DMA_ST26 = 0x4000000
	// Position of EP_DMA_ST27 field.
	USB_EPDMAST_EP_DMA_ST27_Pos = 0x1b
	// Bit mask of EP_DMA_ST27 field.
	USB_EPDMAST_EP_DMA_ST27_Msk = 0x8000000
	// Bit EP_DMA_ST27.
	USB_EPDMAST_EP_DMA_ST27 = 0x8000000
	// Position of EP_DMA_ST28 field.
	USB_EPDMAST_EP_DMA_ST28_Pos = 0x1c
	// Bit mask of EP_DMA_ST28 field.
	USB_EPDMAST_EP_DMA_ST28_Msk = 0x10000000
	// Bit EP_DMA_ST28.
	USB_EPDMAST_EP_DMA_ST28 = 0x10000000
	// Position of EP_DMA_ST29 field.
	USB_EPDMAST_EP_DMA_ST29_Pos = 0x1d
	// Bit mask of EP_DMA_ST29 field.
	USB_EPDMAST_EP_DMA_ST29_Msk = 0x20000000
	// Bit EP_DMA_ST29.
	USB_EPDMAST_EP_DMA_ST29 = 0x20000000
	// Position of EP_DMA_ST30 field.
	USB_EPDMAST_EP_DMA_ST30_Pos = 0x1e
	// Bit mask of EP_DMA_ST30 field.
	USB_EPDMAST_EP_DMA_ST30_Msk = 0x40000000
	// Bit EP_DMA_ST30.
	USB_EPDMAST_EP_DMA_ST30 = 0x40000000
	// Position of EP_DMA_ST31 field.
	USB_EPDMAST_EP_DMA_ST31_Pos = 0x1f
	// Bit mask of EP_DMA_ST31 field.
	USB_EPDMAST_EP_DMA_ST31_Msk = 0x80000000
	// Bit EP_DMA_ST31.
	USB_EPDMAST_EP_DMA_ST31 = 0x80000000

	// EPDMAEN: USB Endpoint DMA Enable
	// Position of EP_DMA_EN0 field.
	USB_EPDMAEN_EP_DMA_EN0_Pos = 0x0
	// Bit mask of EP_DMA_EN0 field.
	USB_EPDMAEN_EP_DMA_EN0_Msk = 0x1
	// Bit EP_DMA_EN0.
	USB_EPDMAEN_EP_DMA_EN0 = 0x1
	// Position of EP_DMA_EN1 field.
	USB_EPDMAEN_EP_DMA_EN1_Pos = 0x1
	// Bit mask of EP_DMA_EN1 field.
	USB_EPDMAEN_EP_DMA_EN1_Msk = 0x2
	// Bit EP_DMA_EN1.
	USB_EPDMAEN_EP_DMA_EN1 = 0x2
	// Position of EP_DMA_EN field.
	USB_EPDMAEN_EP_DMA_EN_Pos = 0x2
	// Bit mask of EP_DMA_EN field.
	USB_EPDMAEN_EP_DMA_EN_Msk = 0xfffffffc

	// EPDMADIS: USB Endpoint DMA Disable
	// Position of EP_DMA_DIS0 field.
	USB_EPDMADIS_EP_DMA_DIS0_Pos = 0x0
	// Bit mask of EP_DMA_DIS0 field.
	USB_EPDMADIS_EP_DMA_DIS0_Msk = 0x1
	// Bit EP_DMA_DIS0.
	USB_EPDMADIS_EP_DMA_DIS0 = 0x1
	// Position of EP_DMA_DIS1 field.
	USB_EPDMADIS_EP_DMA_DIS1_Pos = 0x1
	// Bit mask of EP_DMA_DIS1 field.
	USB_EPDMADIS_EP_DMA_DIS1_Msk = 0x2
	// Bit EP_DMA_DIS1.
	USB_EPDMADIS_EP_DMA_DIS1 = 0x2
	// Position of EP_DMA_DIS2 field.
	USB_EPDMADIS_EP_DMA_DIS2_Pos = 0x2
	// Bit mask of EP_DMA_DIS2 field.
	USB_EPDMADIS_EP_DMA_DIS2_Msk = 0x4
	// Bit EP_DMA_DIS2.
	USB_EPDMADIS_EP_DMA_DIS2 = 0x4
	// Position of EP_DMA_DIS3 field.
	USB_EPDMADIS_EP_DMA_DIS3_Pos = 0x3
	// Bit mask of EP_DMA_DIS3 field.
	USB_EPDMADIS_EP_DMA_DIS3_Msk = 0x8
	// Bit EP_DMA_DIS3.
	USB_EPDMADIS_EP_DMA_DIS3 = 0x8
	// Position of EP_DMA_DIS4 field.
	USB_EPDMADIS_EP_DMA_DIS4_Pos = 0x4
	// Bit mask of EP_DMA_DIS4 field.
	USB_EPDMADIS_EP_DMA_DIS4_Msk = 0x10
	// Bit EP_DMA_DIS4.
	USB_EPDMADIS_EP_DMA_DIS4 = 0x10
	// Position of EP_DMA_DIS5 field.
	USB_EPDMADIS_EP_DMA_DIS5_Pos = 0x5
	// Bit mask of EP_DMA_DIS5 field.
	USB_EPDMADIS_EP_DMA_DIS5_Msk = 0x20
	// Bit EP_DMA_DIS5.
	USB_EPDMADIS_EP_DMA_DIS5 = 0x20
	// Position of EP_DMA_DIS6 field.
	USB_EPDMADIS_EP_DMA_DIS6_Pos = 0x6
	// Bit mask of EP_DMA_DIS6 field.
	USB_EPDMADIS_EP_DMA_DIS6_Msk = 0x40
	// Bit EP_DMA_DIS6.
	USB_EPDMADIS_EP_DMA_DIS6 = 0x40
	// Position of EP_DMA_DIS7 field.
	USB_EPDMADIS_EP_DMA_DIS7_Pos = 0x7
	// Bit mask of EP_DMA_DIS7 field.
	USB_EPDMADIS_EP_DMA_DIS7_Msk = 0x80
	// Bit EP_DMA_DIS7.
	USB_EPDMADIS_EP_DMA_DIS7 = 0x80
	// Position of EP_DMA_DIS8 field.
	USB_EPDMADIS_EP_DMA_DIS8_Pos = 0x8
	// Bit mask of EP_DMA_DIS8 field.
	USB_EPDMADIS_EP_DMA_DIS8_Msk = 0x100
	// Bit EP_DMA_DIS8.
	USB_EPDMADIS_EP_DMA_DIS8 = 0x100
	// Position of EP_DMA_DIS9 field.
	USB_EPDMADIS_EP_DMA_DIS9_Pos = 0x9
	// Bit mask of EP_DMA_DIS9 field.
	USB_EPDMADIS_EP_DMA_DIS9_Msk = 0x200
	// Bit EP_DMA_DIS9.
	USB_EPDMADIS_EP_DMA_DIS9 = 0x200
	// Position of EP_DMA_DIS10 field.
	USB_EPDMADIS_EP_DMA_DIS10_Pos = 0xa
	// Bit mask of EP_DMA_DIS10 field.
	USB_EPDMADIS_EP_DMA_DIS10_Msk = 0x400
	// Bit EP_DMA_DIS10.
	USB_EPDMADIS_EP_DMA_DIS10 = 0x400
	// Position of EP_DMA_DIS11 field.
	USB_EPDMADIS_EP_DMA_DIS11_Pos = 0xb
	// Bit mask of EP_DMA_DIS11 field.
	USB_EPDMADIS_EP_DMA_DIS11_Msk = 0x800
	// Bit EP_DMA_DIS11.
	USB_EPDMADIS_EP_DMA_DIS11 = 0x800
	// Position of EP_DMA_DIS12 field.
	USB_EPDMADIS_EP_DMA_DIS12_Pos = 0xc
	// Bit mask of EP_DMA_DIS12 field.
	USB_EPDMADIS_EP_DMA_DIS12_Msk = 0x1000
	// Bit EP_DMA_DIS12.
	USB_EPDMADIS_EP_DMA_DIS12 = 0x1000
	// Position of EP_DMA_DIS13 field.
	USB_EPDMADIS_EP_DMA_DIS13_Pos = 0xd
	// Bit mask of EP_DMA_DIS13 field.
	USB_EPDMADIS_EP_DMA_DIS13_Msk = 0x2000
	// Bit EP_DMA_DIS13.
	USB_EPDMADIS_EP_DMA_DIS13 = 0x2000
	// Position of EP_DMA_DIS14 field.
	USB_EPDMADIS_EP_DMA_DIS14_Pos = 0xe
	// Bit mask of EP_DMA_DIS14 field.
	USB_EPDMADIS_EP_DMA_DIS14_Msk = 0x4000
	// Bit EP_DMA_DIS14.
	USB_EPDMADIS_EP_DMA_DIS14 = 0x4000
	// Position of EP_DMA_DIS15 field.
	USB_EPDMADIS_EP_DMA_DIS15_Pos = 0xf
	// Bit mask of EP_DMA_DIS15 field.
	USB_EPDMADIS_EP_DMA_DIS15_Msk = 0x8000
	// Bit EP_DMA_DIS15.
	USB_EPDMADIS_EP_DMA_DIS15 = 0x8000
	// Position of EP_DMA_DIS16 field.
	USB_EPDMADIS_EP_DMA_DIS16_Pos = 0x10
	// Bit mask of EP_DMA_DIS16 field.
	USB_EPDMADIS_EP_DMA_DIS16_Msk = 0x10000
	// Bit EP_DMA_DIS16.
	USB_EPDMADIS_EP_DMA_DIS16 = 0x10000
	// Position of EP_DMA_DIS17 field.
	USB_EPDMADIS_EP_DMA_DIS17_Pos = 0x11
	// Bit mask of EP_DMA_DIS17 field.
	USB_EPDMADIS_EP_DMA_DIS17_Msk = 0x20000
	// Bit EP_DMA_DIS17.
	USB_EPDMADIS_EP_DMA_DIS17 = 0x20000
	// Position of EP_DMA_DIS18 field.
	USB_EPDMADIS_EP_DMA_DIS18_Pos = 0x12
	// Bit mask of EP_DMA_DIS18 field.
	USB_EPDMADIS_EP_DMA_DIS18_Msk = 0x40000
	// Bit EP_DMA_DIS18.
	USB_EPDMADIS_EP_DMA_DIS18 = 0x40000
	// Position of EP_DMA_DIS19 field.
	USB_EPDMADIS_EP_DMA_DIS19_Pos = 0x13
	// Bit mask of EP_DMA_DIS19 field.
	USB_EPDMADIS_EP_DMA_DIS19_Msk = 0x80000
	// Bit EP_DMA_DIS19.
	USB_EPDMADIS_EP_DMA_DIS19 = 0x80000
	// Position of EP_DMA_DIS20 field.
	USB_EPDMADIS_EP_DMA_DIS20_Pos = 0x14
	// Bit mask of EP_DMA_DIS20 field.
	USB_EPDMADIS_EP_DMA_DIS20_Msk = 0x100000
	// Bit EP_DMA_DIS20.
	USB_EPDMADIS_EP_DMA_DIS20 = 0x100000
	// Position of EP_DMA_DIS21 field.
	USB_EPDMADIS_EP_DMA_DIS21_Pos = 0x15
	// Bit mask of EP_DMA_DIS21 field.
	USB_EPDMADIS_EP_DMA_DIS21_Msk = 0x200000
	// Bit EP_DMA_DIS21.
	USB_EPDMADIS_EP_DMA_DIS21 = 0x200000
	// Position of EP_DMA_DIS22 field.
	USB_EPDMADIS_EP_DMA_DIS22_Pos = 0x16
	// Bit mask of EP_DMA_DIS22 field.
	USB_EPDMADIS_EP_DMA_DIS22_Msk = 0x400000
	// Bit EP_DMA_DIS22.
	USB_EPDMADIS_EP_DMA_DIS22 = 0x400000
	// Position of EP_DMA_DIS23 field.
	USB_EPDMADIS_EP_DMA_DIS23_Pos = 0x17
	// Bit mask of EP_DMA_DIS23 field.
	USB_EPDMADIS_EP_DMA_DIS23_Msk = 0x800000
	// Bit EP_DMA_DIS23.
	USB_EPDMADIS_EP_DMA_DIS23 = 0x800000
	// Position of EP_DMA_DIS24 field.
	USB_EPDMADIS_EP_DMA_DIS24_Pos = 0x18
	// Bit mask of EP_DMA_DIS24 field.
	USB_EPDMADIS_EP_DMA_DIS24_Msk = 0x1000000
	// Bit EP_DMA_DIS24.
	USB_EPDMADIS_EP_DMA_DIS24 = 0x1000000
	// Position of EP_DMA_DIS25 field.
	USB_EPDMADIS_EP_DMA_DIS25_Pos = 0x19
	// Bit mask of EP_DMA_DIS25 field.
	USB_EPDMADIS_EP_DMA_DIS25_Msk = 0x2000000
	// Bit EP_DMA_DIS25.
	USB_EPDMADIS_EP_DMA_DIS25 = 0x2000000
	// Position of EP_DMA_DIS26 field.
	USB_EPDMADIS_EP_DMA_DIS26_Pos = 0x1a
	// Bit mask of EP_DMA_DIS26 field.
	USB_EPDMADIS_EP_DMA_DIS26_Msk = 0x4000000
	// Bit EP_DMA_DIS26.
	USB_EPDMADIS_EP_DMA_DIS26 = 0x4000000
	// Position of EP_DMA_DIS27 field.
	USB_EPDMADIS_EP_DMA_DIS27_Pos = 0x1b
	// Bit mask of EP_DMA_DIS27 field.
	USB_EPDMADIS_EP_DMA_DIS27_Msk = 0x8000000
	// Bit EP_DMA_DIS27.
	USB_EPDMADIS_EP_DMA_DIS27 = 0x8000000
	// Position of EP_DMA_DIS28 field.
	USB_EPDMADIS_EP_DMA_DIS28_Pos = 0x1c
	// Bit mask of EP_DMA_DIS28 field.
	USB_EPDMADIS_EP_DMA_DIS28_Msk = 0x10000000
	// Bit EP_DMA_DIS28.
	USB_EPDMADIS_EP_DMA_DIS28 = 0x10000000
	// Position of EP_DMA_DIS29 field.
	USB_EPDMADIS_EP_DMA_DIS29_Pos = 0x1d
	// Bit mask of EP_DMA_DIS29 field.
	USB_EPDMADIS_EP_DMA_DIS29_Msk = 0x20000000
	// Bit EP_DMA_DIS29.
	USB_EPDMADIS_EP_DMA_DIS29 = 0x20000000
	// Position of EP_DMA_DIS30 field.
	USB_EPDMADIS_EP_DMA_DIS30_Pos = 0x1e
	// Bit mask of EP_DMA_DIS30 field.
	USB_EPDMADIS_EP_DMA_DIS30_Msk = 0x40000000
	// Bit EP_DMA_DIS30.
	USB_EPDMADIS_EP_DMA_DIS30 = 0x40000000
	// Position of EP_DMA_DIS31 field.
	USB_EPDMADIS_EP_DMA_DIS31_Pos = 0x1f
	// Bit mask of EP_DMA_DIS31 field.
	USB_EPDMADIS_EP_DMA_DIS31_Msk = 0x80000000
	// Bit EP_DMA_DIS31.
	USB_EPDMADIS_EP_DMA_DIS31 = 0x80000000

	// DMAINTST: USB DMA Interrupt Status
	// Position of EOT field.
	USB_DMAINTST_EOT_Pos = 0x0
	// Bit mask of EOT field.
	USB_DMAINTST_EOT_Msk = 0x1
	// Bit EOT.
	USB_DMAINTST_EOT = 0x1
	// All bits in the USBEoTIntSt register are 0.
	USB_DMAINTST_EOT_ALL_BITS_IN_THE_USBE = 0x0
	// At least one bit in the USBEoTIntSt is set.
	USB_DMAINTST_EOT_AT_LEAST_ONE_BIT_IN_ = 0x1
	// Position of NDDR field.
	USB_DMAINTST_NDDR_Pos = 0x1
	// Bit mask of NDDR field.
	USB_DMAINTST_NDDR_Msk = 0x2
	// Bit NDDR.
	USB_DMAINTST_NDDR = 0x2
	// All bits in the USBNDDRIntSt register are 0.
	USB_DMAINTST_NDDR_ALL_BITS_IN_THE_USBN = 0x0
	// At least one bit in the USBNDDRIntSt is set.
	USB_DMAINTST_NDDR_AT_LEAST_ONE_BIT_IN_ = 0x1
	// Position of ERR field.
	USB_DMAINTST_ERR_Pos = 0x2
	// Bit mask of ERR field.
	USB_DMAINTST_ERR_Msk = 0x4
	// Bit ERR.
	USB_DMAINTST_ERR = 0x4
	// All bits in the USBSysErrIntSt register are 0.
	USB_DMAINTST_ERR_ALL_BITS_IN_THE_USBS = 0x0
	// At least one bit in the USBSysErrIntSt is set.
	USB_DMAINTST_ERR_AT_LEAST_ONE_BIT_IN_ = 0x1
	// Position of RESERVED field.
	USB_DMAINTST_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	USB_DMAINTST_RESERVED_Msk = 0xfffffff8

	// DMAINTEN: USB DMA Interrupt Enable
	// Position of EOT field.
	USB_DMAINTEN_EOT_Pos = 0x0
	// Bit mask of EOT field.
	USB_DMAINTEN_EOT_Msk = 0x1
	// Bit EOT.
	USB_DMAINTEN_EOT = 0x1
	// Disabled.
	USB_DMAINTEN_EOT_DISABLED_ = 0x0
	// Enabled.
	USB_DMAINTEN_EOT_ENABLED_ = 0x1
	// Position of NDDR field.
	USB_DMAINTEN_NDDR_Pos = 0x1
	// Bit mask of NDDR field.
	USB_DMAINTEN_NDDR_Msk = 0x2
	// Bit NDDR.
	USB_DMAINTEN_NDDR = 0x2
	// Disabled.
	USB_DMAINTEN_NDDR_DISABLED_ = 0x0
	// Enabled.
	USB_DMAINTEN_NDDR_ENABLED_ = 0x1
	// Position of ERR field.
	USB_DMAINTEN_ERR_Pos = 0x2
	// Bit mask of ERR field.
	USB_DMAINTEN_ERR_Msk = 0x4
	// Bit ERR.
	USB_DMAINTEN_ERR = 0x4
	// Disabled.
	USB_DMAINTEN_ERR_DISABLED_ = 0x0
	// Enabled.
	USB_DMAINTEN_ERR_ENABLED_ = 0x1
	// Position of RESERVED field.
	USB_DMAINTEN_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	USB_DMAINTEN_RESERVED_Msk = 0xfffffff8

	// EOTINTST: USB End of Transfer Interrupt Status
	// Position of EPTXINTST0 field.
	USB_EOTINTST_EPTXINTST0_Pos = 0x0
	// Bit mask of EPTXINTST0 field.
	USB_EOTINTST_EPTXINTST0_Msk = 0x1
	// Bit EPTXINTST0.
	USB_EOTINTST_EPTXINTST0 = 0x1
	// Position of EPTXINTST1 field.
	USB_EOTINTST_EPTXINTST1_Pos = 0x1
	// Bit mask of EPTXINTST1 field.
	USB_EOTINTST_EPTXINTST1_Msk = 0x2
	// Bit EPTXINTST1.
	USB_EOTINTST_EPTXINTST1 = 0x2
	// Position of EPTXINTST2 field.
	USB_EOTINTST_EPTXINTST2_Pos = 0x2
	// Bit mask of EPTXINTST2 field.
	USB_EOTINTST_EPTXINTST2_Msk = 0x4
	// Bit EPTXINTST2.
	USB_EOTINTST_EPTXINTST2 = 0x4
	// Position of EPTXINTST3 field.
	USB_EOTINTST_EPTXINTST3_Pos = 0x3
	// Bit mask of EPTXINTST3 field.
	USB_EOTINTST_EPTXINTST3_Msk = 0x8
	// Bit EPTXINTST3.
	USB_EOTINTST_EPTXINTST3 = 0x8
	// Position of EPTXINTST4 field.
	USB_EOTINTST_EPTXINTST4_Pos = 0x4
	// Bit mask of EPTXINTST4 field.
	USB_EOTINTST_EPTXINTST4_Msk = 0x10
	// Bit EPTXINTST4.
	USB_EOTINTST_EPTXINTST4 = 0x10
	// Position of EPTXINTST5 field.
	USB_EOTINTST_EPTXINTST5_Pos = 0x5
	// Bit mask of EPTXINTST5 field.
	USB_EOTINTST_EPTXINTST5_Msk = 0x20
	// Bit EPTXINTST5.
	USB_EOTINTST_EPTXINTST5 = 0x20
	// Position of EPTXINTST6 field.
	USB_EOTINTST_EPTXINTST6_Pos = 0x6
	// Bit mask of EPTXINTST6 field.
	USB_EOTINTST_EPTXINTST6_Msk = 0x40
	// Bit EPTXINTST6.
	USB_EOTINTST_EPTXINTST6 = 0x40
	// Position of EPTXINTST7 field.
	USB_EOTINTST_EPTXINTST7_Pos = 0x7
	// Bit mask of EPTXINTST7 field.
	USB_EOTINTST_EPTXINTST7_Msk = 0x80
	// Bit EPTXINTST7.
	USB_EOTINTST_EPTXINTST7 = 0x80
	// Position of EPTXINTST8 field.
	USB_EOTINTST_EPTXINTST8_Pos = 0x8
	// Bit mask of EPTXINTST8 field.
	USB_EOTINTST_EPTXINTST8_Msk = 0x100
	// Bit EPTXINTST8.
	USB_EOTINTST_EPTXINTST8 = 0x100
	// Position of EPTXINTST9 field.
	USB_EOTINTST_EPTXINTST9_Pos = 0x9
	// Bit mask of EPTXINTST9 field.
	USB_EOTINTST_EPTXINTST9_Msk = 0x200
	// Bit EPTXINTST9.
	USB_EOTINTST_EPTXINTST9 = 0x200
	// Position of EPTXINTST10 field.
	USB_EOTINTST_EPTXINTST10_Pos = 0xa
	// Bit mask of EPTXINTST10 field.
	USB_EOTINTST_EPTXINTST10_Msk = 0x400
	// Bit EPTXINTST10.
	USB_EOTINTST_EPTXINTST10 = 0x400
	// Position of EPTXINTST11 field.
	USB_EOTINTST_EPTXINTST11_Pos = 0xb
	// Bit mask of EPTXINTST11 field.
	USB_EOTINTST_EPTXINTST11_Msk = 0x800
	// Bit EPTXINTST11.
	USB_EOTINTST_EPTXINTST11 = 0x800
	// Position of EPTXINTST12 field.
	USB_EOTINTST_EPTXINTST12_Pos = 0xc
	// Bit mask of EPTXINTST12 field.
	USB_EOTINTST_EPTXINTST12_Msk = 0x1000
	// Bit EPTXINTST12.
	USB_EOTINTST_EPTXINTST12 = 0x1000
	// Position of EPTXINTST13 field.
	USB_EOTINTST_EPTXINTST13_Pos = 0xd
	// Bit mask of EPTXINTST13 field.
	USB_EOTINTST_EPTXINTST13_Msk = 0x2000
	// Bit EPTXINTST13.
	USB_EOTINTST_EPTXINTST13 = 0x2000
	// Position of EPTXINTST14 field.
	USB_EOTINTST_EPTXINTST14_Pos = 0xe
	// Bit mask of EPTXINTST14 field.
	USB_EOTINTST_EPTXINTST14_Msk = 0x4000
	// Bit EPTXINTST14.
	USB_EOTINTST_EPTXINTST14 = 0x4000
	// Position of EPTXINTST15 field.
	USB_EOTINTST_EPTXINTST15_Pos = 0xf
	// Bit mask of EPTXINTST15 field.
	USB_EOTINTST_EPTXINTST15_Msk = 0x8000
	// Bit EPTXINTST15.
	USB_EOTINTST_EPTXINTST15 = 0x8000
	// Position of EPTXINTST16 field.
	USB_EOTINTST_EPTXINTST16_Pos = 0x10
	// Bit mask of EPTXINTST16 field.
	USB_EOTINTST_EPTXINTST16_Msk = 0x10000
	// Bit EPTXINTST16.
	USB_EOTINTST_EPTXINTST16 = 0x10000
	// Position of EPTXINTST17 field.
	USB_EOTINTST_EPTXINTST17_Pos = 0x11
	// Bit mask of EPTXINTST17 field.
	USB_EOTINTST_EPTXINTST17_Msk = 0x20000
	// Bit EPTXINTST17.
	USB_EOTINTST_EPTXINTST17 = 0x20000
	// Position of EPTXINTST18 field.
	USB_EOTINTST_EPTXINTST18_Pos = 0x12
	// Bit mask of EPTXINTST18 field.
	USB_EOTINTST_EPTXINTST18_Msk = 0x40000
	// Bit EPTXINTST18.
	USB_EOTINTST_EPTXINTST18 = 0x40000
	// Position of EPTXINTST19 field.
	USB_EOTINTST_EPTXINTST19_Pos = 0x13
	// Bit mask of EPTXINTST19 field.
	USB_EOTINTST_EPTXINTST19_Msk = 0x80000
	// Bit EPTXINTST19.
	USB_EOTINTST_EPTXINTST19 = 0x80000
	// Position of EPTXINTST20 field.
	USB_EOTINTST_EPTXINTST20_Pos = 0x14
	// Bit mask of EPTXINTST20 field.
	USB_EOTINTST_EPTXINTST20_Msk = 0x100000
	// Bit EPTXINTST20.
	USB_EOTINTST_EPTXINTST20 = 0x100000
	// Position of EPTXINTST21 field.
	USB_EOTINTST_EPTXINTST21_Pos = 0x15
	// Bit mask of EPTXINTST21 field.
	USB_EOTINTST_EPTXINTST21_Msk = 0x200000
	// Bit EPTXINTST21.
	USB_EOTINTST_EPTXINTST21 = 0x200000
	// Position of EPTXINTST22 field.
	USB_EOTINTST_EPTXINTST22_Pos = 0x16
	// Bit mask of EPTXINTST22 field.
	USB_EOTINTST_EPTXINTST22_Msk = 0x400000
	// Bit EPTXINTST22.
	USB_EOTINTST_EPTXINTST22 = 0x400000
	// Position of EPTXINTST23 field.
	USB_EOTINTST_EPTXINTST23_Pos = 0x17
	// Bit mask of EPTXINTST23 field.
	USB_EOTINTST_EPTXINTST23_Msk = 0x800000
	// Bit EPTXINTST23.
	USB_EOTINTST_EPTXINTST23 = 0x800000
	// Position of EPTXINTST24 field.
	USB_EOTINTST_EPTXINTST24_Pos = 0x18
	// Bit mask of EPTXINTST24 field.
	USB_EOTINTST_EPTXINTST24_Msk = 0x1000000
	// Bit EPTXINTST24.
	USB_EOTINTST_EPTXINTST24 = 0x1000000
	// Position of EPTXINTST25 field.
	USB_EOTINTST_EPTXINTST25_Pos = 0x19
	// Bit mask of EPTXINTST25 field.
	USB_EOTINTST_EPTXINTST25_Msk = 0x2000000
	// Bit EPTXINTST25.
	USB_EOTINTST_EPTXINTST25 = 0x2000000
	// Position of EPTXINTST26 field.
	USB_EOTINTST_EPTXINTST26_Pos = 0x1a
	// Bit mask of EPTXINTST26 field.
	USB_EOTINTST_EPTXINTST26_Msk = 0x4000000
	// Bit EPTXINTST26.
	USB_EOTINTST_EPTXINTST26 = 0x4000000
	// Position of EPTXINTST27 field.
	USB_EOTINTST_EPTXINTST27_Pos = 0x1b
	// Bit mask of EPTXINTST27 field.
	USB_EOTINTST_EPTXINTST27_Msk = 0x8000000
	// Bit EPTXINTST27.
	USB_EOTINTST_EPTXINTST27 = 0x8000000
	// Position of EPTXINTST28 field.
	USB_EOTINTST_EPTXINTST28_Pos = 0x1c
	// Bit mask of EPTXINTST28 field.
	USB_EOTINTST_EPTXINTST28_Msk = 0x10000000
	// Bit EPTXINTST28.
	USB_EOTINTST_EPTXINTST28 = 0x10000000
	// Position of EPTXINTST29 field.
	USB_EOTINTST_EPTXINTST29_Pos = 0x1d
	// Bit mask of EPTXINTST29 field.
	USB_EOTINTST_EPTXINTST29_Msk = 0x20000000
	// Bit EPTXINTST29.
	USB_EOTINTST_EPTXINTST29 = 0x20000000
	// Position of EPTXINTST30 field.
	USB_EOTINTST_EPTXINTST30_Pos = 0x1e
	// Bit mask of EPTXINTST30 field.
	USB_EOTINTST_EPTXINTST30_Msk = 0x40000000
	// Bit EPTXINTST30.
	USB_EOTINTST_EPTXINTST30 = 0x40000000
	// Position of EPTXINTST31 field.
	USB_EOTINTST_EPTXINTST31_Pos = 0x1f
	// Bit mask of EPTXINTST31 field.
	USB_EOTINTST_EPTXINTST31_Msk = 0x80000000
	// Bit EPTXINTST31.
	USB_EOTINTST_EPTXINTST31 = 0x80000000

	// EOTINTCLR: USB End of Transfer Interrupt Clear
	// Position of EPTXINTCLR0 field.
	USB_EOTINTCLR_EPTXINTCLR0_Pos = 0x0
	// Bit mask of EPTXINTCLR0 field.
	USB_EOTINTCLR_EPTXINTCLR0_Msk = 0x1
	// Bit EPTXINTCLR0.
	USB_EOTINTCLR_EPTXINTCLR0 = 0x1
	// Position of EPTXINTCLR1 field.
	USB_EOTINTCLR_EPTXINTCLR1_Pos = 0x1
	// Bit mask of EPTXINTCLR1 field.
	USB_EOTINTCLR_EPTXINTCLR1_Msk = 0x2
	// Bit EPTXINTCLR1.
	USB_EOTINTCLR_EPTXINTCLR1 = 0x2
	// Position of EPTXINTCLR2 field.
	USB_EOTINTCLR_EPTXINTCLR2_Pos = 0x2
	// Bit mask of EPTXINTCLR2 field.
	USB_EOTINTCLR_EPTXINTCLR2_Msk = 0x4
	// Bit EPTXINTCLR2.
	USB_EOTINTCLR_EPTXINTCLR2 = 0x4
	// Position of EPTXINTCLR3 field.
	USB_EOTINTCLR_EPTXINTCLR3_Pos = 0x3
	// Bit mask of EPTXINTCLR3 field.
	USB_EOTINTCLR_EPTXINTCLR3_Msk = 0x8
	// Bit EPTXINTCLR3.
	USB_EOTINTCLR_EPTXINTCLR3 = 0x8
	// Position of EPTXINTCLR4 field.
	USB_EOTINTCLR_EPTXINTCLR4_Pos = 0x4
	// Bit mask of EPTXINTCLR4 field.
	USB_EOTINTCLR_EPTXINTCLR4_Msk = 0x10
	// Bit EPTXINTCLR4.
	USB_EOTINTCLR_EPTXINTCLR4 = 0x10
	// Position of EPTXINTCLR5 field.
	USB_EOTINTCLR_EPTXINTCLR5_Pos = 0x5
	// Bit mask of EPTXINTCLR5 field.
	USB_EOTINTCLR_EPTXINTCLR5_Msk = 0x20
	// Bit EPTXINTCLR5.
	USB_EOTINTCLR_EPTXINTCLR5 = 0x20
	// Position of EPTXINTCLR6 field.
	USB_EOTINTCLR_EPTXINTCLR6_Pos = 0x6
	// Bit mask of EPTXINTCLR6 field.
	USB_EOTINTCLR_EPTXINTCLR6_Msk = 0x40
	// Bit EPTXINTCLR6.
	USB_EOTINTCLR_EPTXINTCLR6 = 0x40
	// Position of EPTXINTCLR7 field.
	USB_EOTINTCLR_EPTXINTCLR7_Pos = 0x7
	// Bit mask of EPTXINTCLR7 field.
	USB_EOTINTCLR_EPTXINTCLR7_Msk = 0x80
	// Bit EPTXINTCLR7.
	USB_EOTINTCLR_EPTXINTCLR7 = 0x80
	// Position of EPTXINTCLR8 field.
	USB_EOTINTCLR_EPTXINTCLR8_Pos = 0x8
	// Bit mask of EPTXINTCLR8 field.
	USB_EOTINTCLR_EPTXINTCLR8_Msk = 0x100
	// Bit EPTXINTCLR8.
	USB_EOTINTCLR_EPTXINTCLR8 = 0x100
	// Position of EPTXINTCLR9 field.
	USB_EOTINTCLR_EPTXINTCLR9_Pos = 0x9
	// Bit mask of EPTXINTCLR9 field.
	USB_EOTINTCLR_EPTXINTCLR9_Msk = 0x200
	// Bit EPTXINTCLR9.
	USB_EOTINTCLR_EPTXINTCLR9 = 0x200
	// Position of EPTXINTCLR10 field.
	USB_EOTINTCLR_EPTXINTCLR10_Pos = 0xa
	// Bit mask of EPTXINTCLR10 field.
	USB_EOTINTCLR_EPTXINTCLR10_Msk = 0x400
	// Bit EPTXINTCLR10.
	USB_EOTINTCLR_EPTXINTCLR10 = 0x400
	// Position of EPTXINTCLR11 field.
	USB_EOTINTCLR_EPTXINTCLR11_Pos = 0xb
	// Bit mask of EPTXINTCLR11 field.
	USB_EOTINTCLR_EPTXINTCLR11_Msk = 0x800
	// Bit EPTXINTCLR11.
	USB_EOTINTCLR_EPTXINTCLR11 = 0x800
	// Position of EPTXINTCLR12 field.
	USB_EOTINTCLR_EPTXINTCLR12_Pos = 0xc
	// Bit mask of EPTXINTCLR12 field.
	USB_EOTINTCLR_EPTXINTCLR12_Msk = 0x1000
	// Bit EPTXINTCLR12.
	USB_EOTINTCLR_EPTXINTCLR12 = 0x1000
	// Position of EPTXINTCLR13 field.
	USB_EOTINTCLR_EPTXINTCLR13_Pos = 0xd
	// Bit mask of EPTXINTCLR13 field.
	USB_EOTINTCLR_EPTXINTCLR13_Msk = 0x2000
	// Bit EPTXINTCLR13.
	USB_EOTINTCLR_EPTXINTCLR13 = 0x2000
	// Position of EPTXINTCLR14 field.
	USB_EOTINTCLR_EPTXINTCLR14_Pos = 0xe
	// Bit mask of EPTXINTCLR14 field.
	USB_EOTINTCLR_EPTXINTCLR14_Msk = 0x4000
	// Bit EPTXINTCLR14.
	USB_EOTINTCLR_EPTXINTCLR14 = 0x4000
	// Position of EPTXINTCLR15 field.
	USB_EOTINTCLR_EPTXINTCLR15_Pos = 0xf
	// Bit mask of EPTXINTCLR15 field.
	USB_EOTINTCLR_EPTXINTCLR15_Msk = 0x8000
	// Bit EPTXINTCLR15.
	USB_EOTINTCLR_EPTXINTCLR15 = 0x8000
	// Position of EPTXINTCLR16 field.
	USB_EOTINTCLR_EPTXINTCLR16_Pos = 0x10
	// Bit mask of EPTXINTCLR16 field.
	USB_EOTINTCLR_EPTXINTCLR16_Msk = 0x10000
	// Bit EPTXINTCLR16.
	USB_EOTINTCLR_EPTXINTCLR16 = 0x10000
	// Position of EPTXINTCLR17 field.
	USB_EOTINTCLR_EPTXINTCLR17_Pos = 0x11
	// Bit mask of EPTXINTCLR17 field.
	USB_EOTINTCLR_EPTXINTCLR17_Msk = 0x20000
	// Bit EPTXINTCLR17.
	USB_EOTINTCLR_EPTXINTCLR17 = 0x20000
	// Position of EPTXINTCLR18 field.
	USB_EOTINTCLR_EPTXINTCLR18_Pos = 0x12
	// Bit mask of EPTXINTCLR18 field.
	USB_EOTINTCLR_EPTXINTCLR18_Msk = 0x40000
	// Bit EPTXINTCLR18.
	USB_EOTINTCLR_EPTXINTCLR18 = 0x40000
	// Position of EPTXINTCLR19 field.
	USB_EOTINTCLR_EPTXINTCLR19_Pos = 0x13
	// Bit mask of EPTXINTCLR19 field.
	USB_EOTINTCLR_EPTXINTCLR19_Msk = 0x80000
	// Bit EPTXINTCLR19.
	USB_EOTINTCLR_EPTXINTCLR19 = 0x80000
	// Position of EPTXINTCLR20 field.
	USB_EOTINTCLR_EPTXINTCLR20_Pos = 0x14
	// Bit mask of EPTXINTCLR20 field.
	USB_EOTINTCLR_EPTXINTCLR20_Msk = 0x100000
	// Bit EPTXINTCLR20.
	USB_EOTINTCLR_EPTXINTCLR20 = 0x100000
	// Position of EPTXINTCLR21 field.
	USB_EOTINTCLR_EPTXINTCLR21_Pos = 0x15
	// Bit mask of EPTXINTCLR21 field.
	USB_EOTINTCLR_EPTXINTCLR21_Msk = 0x200000
	// Bit EPTXINTCLR21.
	USB_EOTINTCLR_EPTXINTCLR21 = 0x200000
	// Position of EPTXINTCLR22 field.
	USB_EOTINTCLR_EPTXINTCLR22_Pos = 0x16
	// Bit mask of EPTXINTCLR22 field.
	USB_EOTINTCLR_EPTXINTCLR22_Msk = 0x400000
	// Bit EPTXINTCLR22.
	USB_EOTINTCLR_EPTXINTCLR22 = 0x400000
	// Position of EPTXINTCLR23 field.
	USB_EOTINTCLR_EPTXINTCLR23_Pos = 0x17
	// Bit mask of EPTXINTCLR23 field.
	USB_EOTINTCLR_EPTXINTCLR23_Msk = 0x800000
	// Bit EPTXINTCLR23.
	USB_EOTINTCLR_EPTXINTCLR23 = 0x800000
	// Position of EPTXINTCLR24 field.
	USB_EOTINTCLR_EPTXINTCLR24_Pos = 0x18
	// Bit mask of EPTXINTCLR24 field.
	USB_EOTINTCLR_EPTXINTCLR24_Msk = 0x1000000
	// Bit EPTXINTCLR24.
	USB_EOTINTCLR_EPTXINTCLR24 = 0x1000000
	// Position of EPTXINTCLR25 field.
	USB_EOTINTCLR_EPTXINTCLR25_Pos = 0x19
	// Bit mask of EPTXINTCLR25 field.
	USB_EOTINTCLR_EPTXINTCLR25_Msk = 0x2000000
	// Bit EPTXINTCLR25.
	USB_EOTINTCLR_EPTXINTCLR25 = 0x2000000
	// Position of EPTXINTCLR26 field.
	USB_EOTINTCLR_EPTXINTCLR26_Pos = 0x1a
	// Bit mask of EPTXINTCLR26 field.
	USB_EOTINTCLR_EPTXINTCLR26_Msk = 0x4000000
	// Bit EPTXINTCLR26.
	USB_EOTINTCLR_EPTXINTCLR26 = 0x4000000
	// Position of EPTXINTCLR27 field.
	USB_EOTINTCLR_EPTXINTCLR27_Pos = 0x1b
	// Bit mask of EPTXINTCLR27 field.
	USB_EOTINTCLR_EPTXINTCLR27_Msk = 0x8000000
	// Bit EPTXINTCLR27.
	USB_EOTINTCLR_EPTXINTCLR27 = 0x8000000
	// Position of EPTXINTCLR28 field.
	USB_EOTINTCLR_EPTXINTCLR28_Pos = 0x1c
	// Bit mask of EPTXINTCLR28 field.
	USB_EOTINTCLR_EPTXINTCLR28_Msk = 0x10000000
	// Bit EPTXINTCLR28.
	USB_EOTINTCLR_EPTXINTCLR28 = 0x10000000
	// Position of EPTXINTCLR29 field.
	USB_EOTINTCLR_EPTXINTCLR29_Pos = 0x1d
	// Bit mask of EPTXINTCLR29 field.
	USB_EOTINTCLR_EPTXINTCLR29_Msk = 0x20000000
	// Bit EPTXINTCLR29.
	USB_EOTINTCLR_EPTXINTCLR29 = 0x20000000
	// Position of EPTXINTCLR30 field.
	USB_EOTINTCLR_EPTXINTCLR30_Pos = 0x1e
	// Bit mask of EPTXINTCLR30 field.
	USB_EOTINTCLR_EPTXINTCLR30_Msk = 0x40000000
	// Bit EPTXINTCLR30.
	USB_EOTINTCLR_EPTXINTCLR30 = 0x40000000
	// Position of EPTXINTCLR31 field.
	USB_EOTINTCLR_EPTXINTCLR31_Pos = 0x1f
	// Bit mask of EPTXINTCLR31 field.
	USB_EOTINTCLR_EPTXINTCLR31_Msk = 0x80000000
	// Bit EPTXINTCLR31.
	USB_EOTINTCLR_EPTXINTCLR31 = 0x80000000

	// EOTINTSET: USB End of Transfer Interrupt Set
	// Position of EPTXINTSET0 field.
	USB_EOTINTSET_EPTXINTSET0_Pos = 0x0
	// Bit mask of EPTXINTSET0 field.
	USB_EOTINTSET_EPTXINTSET0_Msk = 0x1
	// Bit EPTXINTSET0.
	USB_EOTINTSET_EPTXINTSET0 = 0x1
	// Position of EPTXINTSET1 field.
	USB_EOTINTSET_EPTXINTSET1_Pos = 0x1
	// Bit mask of EPTXINTSET1 field.
	USB_EOTINTSET_EPTXINTSET1_Msk = 0x2
	// Bit EPTXINTSET1.
	USB_EOTINTSET_EPTXINTSET1 = 0x2
	// Position of EPTXINTSET2 field.
	USB_EOTINTSET_EPTXINTSET2_Pos = 0x2
	// Bit mask of EPTXINTSET2 field.
	USB_EOTINTSET_EPTXINTSET2_Msk = 0x4
	// Bit EPTXINTSET2.
	USB_EOTINTSET_EPTXINTSET2 = 0x4
	// Position of EPTXINTSET3 field.
	USB_EOTINTSET_EPTXINTSET3_Pos = 0x3
	// Bit mask of EPTXINTSET3 field.
	USB_EOTINTSET_EPTXINTSET3_Msk = 0x8
	// Bit EPTXINTSET3.
	USB_EOTINTSET_EPTXINTSET3 = 0x8
	// Position of EPTXINTSET4 field.
	USB_EOTINTSET_EPTXINTSET4_Pos = 0x4
	// Bit mask of EPTXINTSET4 field.
	USB_EOTINTSET_EPTXINTSET4_Msk = 0x10
	// Bit EPTXINTSET4.
	USB_EOTINTSET_EPTXINTSET4 = 0x10
	// Position of EPTXINTSET5 field.
	USB_EOTINTSET_EPTXINTSET5_Pos = 0x5
	// Bit mask of EPTXINTSET5 field.
	USB_EOTINTSET_EPTXINTSET5_Msk = 0x20
	// Bit EPTXINTSET5.
	USB_EOTINTSET_EPTXINTSET5 = 0x20
	// Position of EPTXINTSET6 field.
	USB_EOTINTSET_EPTXINTSET6_Pos = 0x6
	// Bit mask of EPTXINTSET6 field.
	USB_EOTINTSET_EPTXINTSET6_Msk = 0x40
	// Bit EPTXINTSET6.
	USB_EOTINTSET_EPTXINTSET6 = 0x40
	// Position of EPTXINTSET7 field.
	USB_EOTINTSET_EPTXINTSET7_Pos = 0x7
	// Bit mask of EPTXINTSET7 field.
	USB_EOTINTSET_EPTXINTSET7_Msk = 0x80
	// Bit EPTXINTSET7.
	USB_EOTINTSET_EPTXINTSET7 = 0x80
	// Position of EPTXINTSET8 field.
	USB_EOTINTSET_EPTXINTSET8_Pos = 0x8
	// Bit mask of EPTXINTSET8 field.
	USB_EOTINTSET_EPTXINTSET8_Msk = 0x100
	// Bit EPTXINTSET8.
	USB_EOTINTSET_EPTXINTSET8 = 0x100
	// Position of EPTXINTSET9 field.
	USB_EOTINTSET_EPTXINTSET9_Pos = 0x9
	// Bit mask of EPTXINTSET9 field.
	USB_EOTINTSET_EPTXINTSET9_Msk = 0x200
	// Bit EPTXINTSET9.
	USB_EOTINTSET_EPTXINTSET9 = 0x200
	// Position of EPTXINTSET10 field.
	USB_EOTINTSET_EPTXINTSET10_Pos = 0xa
	// Bit mask of EPTXINTSET10 field.
	USB_EOTINTSET_EPTXINTSET10_Msk = 0x400
	// Bit EPTXINTSET10.
	USB_EOTINTSET_EPTXINTSET10 = 0x400
	// Position of EPTXINTSET11 field.
	USB_EOTINTSET_EPTXINTSET11_Pos = 0xb
	// Bit mask of EPTXINTSET11 field.
	USB_EOTINTSET_EPTXINTSET11_Msk = 0x800
	// Bit EPTXINTSET11.
	USB_EOTINTSET_EPTXINTSET11 = 0x800
	// Position of EPTXINTSET12 field.
	USB_EOTINTSET_EPTXINTSET12_Pos = 0xc
	// Bit mask of EPTXINTSET12 field.
	USB_EOTINTSET_EPTXINTSET12_Msk = 0x1000
	// Bit EPTXINTSET12.
	USB_EOTINTSET_EPTXINTSET12 = 0x1000
	// Position of EPTXINTSET13 field.
	USB_EOTINTSET_EPTXINTSET13_Pos = 0xd
	// Bit mask of EPTXINTSET13 field.
	USB_EOTINTSET_EPTXINTSET13_Msk = 0x2000
	// Bit EPTXINTSET13.
	USB_EOTINTSET_EPTXINTSET13 = 0x2000
	// Position of EPTXINTSET14 field.
	USB_EOTINTSET_EPTXINTSET14_Pos = 0xe
	// Bit mask of EPTXINTSET14 field.
	USB_EOTINTSET_EPTXINTSET14_Msk = 0x4000
	// Bit EPTXINTSET14.
	USB_EOTINTSET_EPTXINTSET14 = 0x4000
	// Position of EPTXINTSET15 field.
	USB_EOTINTSET_EPTXINTSET15_Pos = 0xf
	// Bit mask of EPTXINTSET15 field.
	USB_EOTINTSET_EPTXINTSET15_Msk = 0x8000
	// Bit EPTXINTSET15.
	USB_EOTINTSET_EPTXINTSET15 = 0x8000
	// Position of EPTXINTSET16 field.
	USB_EOTINTSET_EPTXINTSET16_Pos = 0x10
	// Bit mask of EPTXINTSET16 field.
	USB_EOTINTSET_EPTXINTSET16_Msk = 0x10000
	// Bit EPTXINTSET16.
	USB_EOTINTSET_EPTXINTSET16 = 0x10000
	// Position of EPTXINTSET17 field.
	USB_EOTINTSET_EPTXINTSET17_Pos = 0x11
	// Bit mask of EPTXINTSET17 field.
	USB_EOTINTSET_EPTXINTSET17_Msk = 0x20000
	// Bit EPTXINTSET17.
	USB_EOTINTSET_EPTXINTSET17 = 0x20000
	// Position of EPTXINTSET18 field.
	USB_EOTINTSET_EPTXINTSET18_Pos = 0x12
	// Bit mask of EPTXINTSET18 field.
	USB_EOTINTSET_EPTXINTSET18_Msk = 0x40000
	// Bit EPTXINTSET18.
	USB_EOTINTSET_EPTXINTSET18 = 0x40000
	// Position of EPTXINTSET19 field.
	USB_EOTINTSET_EPTXINTSET19_Pos = 0x13
	// Bit mask of EPTXINTSET19 field.
	USB_EOTINTSET_EPTXINTSET19_Msk = 0x80000
	// Bit EPTXINTSET19.
	USB_EOTINTSET_EPTXINTSET19 = 0x80000
	// Position of EPTXINTSET20 field.
	USB_EOTINTSET_EPTXINTSET20_Pos = 0x14
	// Bit mask of EPTXINTSET20 field.
	USB_EOTINTSET_EPTXINTSET20_Msk = 0x100000
	// Bit EPTXINTSET20.
	USB_EOTINTSET_EPTXINTSET20 = 0x100000
	// Position of EPTXINTSET21 field.
	USB_EOTINTSET_EPTXINTSET21_Pos = 0x15
	// Bit mask of EPTXINTSET21 field.
	USB_EOTINTSET_EPTXINTSET21_Msk = 0x200000
	// Bit EPTXINTSET21.
	USB_EOTINTSET_EPTXINTSET21 = 0x200000
	// Position of EPTXINTSET22 field.
	USB_EOTINTSET_EPTXINTSET22_Pos = 0x16
	// Bit mask of EPTXINTSET22 field.
	USB_EOTINTSET_EPTXINTSET22_Msk = 0x400000
	// Bit EPTXINTSET22.
	USB_EOTINTSET_EPTXINTSET22 = 0x400000
	// Position of EPTXINTSET23 field.
	USB_EOTINTSET_EPTXINTSET23_Pos = 0x17
	// Bit mask of EPTXINTSET23 field.
	USB_EOTINTSET_EPTXINTSET23_Msk = 0x800000
	// Bit EPTXINTSET23.
	USB_EOTINTSET_EPTXINTSET23 = 0x800000
	// Position of EPTXINTSET24 field.
	USB_EOTINTSET_EPTXINTSET24_Pos = 0x18
	// Bit mask of EPTXINTSET24 field.
	USB_EOTINTSET_EPTXINTSET24_Msk = 0x1000000
	// Bit EPTXINTSET24.
	USB_EOTINTSET_EPTXINTSET24 = 0x1000000
	// Position of EPTXINTSET25 field.
	USB_EOTINTSET_EPTXINTSET25_Pos = 0x19
	// Bit mask of EPTXINTSET25 field.
	USB_EOTINTSET_EPTXINTSET25_Msk = 0x2000000
	// Bit EPTXINTSET25.
	USB_EOTINTSET_EPTXINTSET25 = 0x2000000
	// Position of EPTXINTSET26 field.
	USB_EOTINTSET_EPTXINTSET26_Pos = 0x1a
	// Bit mask of EPTXINTSET26 field.
	USB_EOTINTSET_EPTXINTSET26_Msk = 0x4000000
	// Bit EPTXINTSET26.
	USB_EOTINTSET_EPTXINTSET26 = 0x4000000
	// Position of EPTXINTSET27 field.
	USB_EOTINTSET_EPTXINTSET27_Pos = 0x1b
	// Bit mask of EPTXINTSET27 field.
	USB_EOTINTSET_EPTXINTSET27_Msk = 0x8000000
	// Bit EPTXINTSET27.
	USB_EOTINTSET_EPTXINTSET27 = 0x8000000
	// Position of EPTXINTSET28 field.
	USB_EOTINTSET_EPTXINTSET28_Pos = 0x1c
	// Bit mask of EPTXINTSET28 field.
	USB_EOTINTSET_EPTXINTSET28_Msk = 0x10000000
	// Bit EPTXINTSET28.
	USB_EOTINTSET_EPTXINTSET28 = 0x10000000
	// Position of EPTXINTSET29 field.
	USB_EOTINTSET_EPTXINTSET29_Pos = 0x1d
	// Bit mask of EPTXINTSET29 field.
	USB_EOTINTSET_EPTXINTSET29_Msk = 0x20000000
	// Bit EPTXINTSET29.
	USB_EOTINTSET_EPTXINTSET29 = 0x20000000
	// Position of EPTXINTSET30 field.
	USB_EOTINTSET_EPTXINTSET30_Pos = 0x1e
	// Bit mask of EPTXINTSET30 field.
	USB_EOTINTSET_EPTXINTSET30_Msk = 0x40000000
	// Bit EPTXINTSET30.
	USB_EOTINTSET_EPTXINTSET30 = 0x40000000
	// Position of EPTXINTSET31 field.
	USB_EOTINTSET_EPTXINTSET31_Pos = 0x1f
	// Bit mask of EPTXINTSET31 field.
	USB_EOTINTSET_EPTXINTSET31_Msk = 0x80000000
	// Bit EPTXINTSET31.
	USB_EOTINTSET_EPTXINTSET31 = 0x80000000

	// NDDRINTST: USB New DD Request Interrupt Status
	// Position of EPNDDINTST0 field.
	USB_NDDRINTST_EPNDDINTST0_Pos = 0x0
	// Bit mask of EPNDDINTST0 field.
	USB_NDDRINTST_EPNDDINTST0_Msk = 0x1
	// Bit EPNDDINTST0.
	USB_NDDRINTST_EPNDDINTST0 = 0x1
	// Position of EPNDDINTST1 field.
	USB_NDDRINTST_EPNDDINTST1_Pos = 0x1
	// Bit mask of EPNDDINTST1 field.
	USB_NDDRINTST_EPNDDINTST1_Msk = 0x2
	// Bit EPNDDINTST1.
	USB_NDDRINTST_EPNDDINTST1 = 0x2
	// Position of EPNDDINTST2 field.
	USB_NDDRINTST_EPNDDINTST2_Pos = 0x2
	// Bit mask of EPNDDINTST2 field.
	USB_NDDRINTST_EPNDDINTST2_Msk = 0x4
	// Bit EPNDDINTST2.
	USB_NDDRINTST_EPNDDINTST2 = 0x4
	// Position of EPNDDINTST3 field.
	USB_NDDRINTST_EPNDDINTST3_Pos = 0x3
	// Bit mask of EPNDDINTST3 field.
	USB_NDDRINTST_EPNDDINTST3_Msk = 0x8
	// Bit EPNDDINTST3.
	USB_NDDRINTST_EPNDDINTST3 = 0x8
	// Position of EPNDDINTST4 field.
	USB_NDDRINTST_EPNDDINTST4_Pos = 0x4
	// Bit mask of EPNDDINTST4 field.
	USB_NDDRINTST_EPNDDINTST4_Msk = 0x10
	// Bit EPNDDINTST4.
	USB_NDDRINTST_EPNDDINTST4 = 0x10
	// Position of EPNDDINTST5 field.
	USB_NDDRINTST_EPNDDINTST5_Pos = 0x5
	// Bit mask of EPNDDINTST5 field.
	USB_NDDRINTST_EPNDDINTST5_Msk = 0x20
	// Bit EPNDDINTST5.
	USB_NDDRINTST_EPNDDINTST5 = 0x20
	// Position of EPNDDINTST6 field.
	USB_NDDRINTST_EPNDDINTST6_Pos = 0x6
	// Bit mask of EPNDDINTST6 field.
	USB_NDDRINTST_EPNDDINTST6_Msk = 0x40
	// Bit EPNDDINTST6.
	USB_NDDRINTST_EPNDDINTST6 = 0x40
	// Position of EPNDDINTST7 field.
	USB_NDDRINTST_EPNDDINTST7_Pos = 0x7
	// Bit mask of EPNDDINTST7 field.
	USB_NDDRINTST_EPNDDINTST7_Msk = 0x80
	// Bit EPNDDINTST7.
	USB_NDDRINTST_EPNDDINTST7 = 0x80
	// Position of EPNDDINTST8 field.
	USB_NDDRINTST_EPNDDINTST8_Pos = 0x8
	// Bit mask of EPNDDINTST8 field.
	USB_NDDRINTST_EPNDDINTST8_Msk = 0x100
	// Bit EPNDDINTST8.
	USB_NDDRINTST_EPNDDINTST8 = 0x100
	// Position of EPNDDINTST9 field.
	USB_NDDRINTST_EPNDDINTST9_Pos = 0x9
	// Bit mask of EPNDDINTST9 field.
	USB_NDDRINTST_EPNDDINTST9_Msk = 0x200
	// Bit EPNDDINTST9.
	USB_NDDRINTST_EPNDDINTST9 = 0x200
	// Position of EPNDDINTST10 field.
	USB_NDDRINTST_EPNDDINTST10_Pos = 0xa
	// Bit mask of EPNDDINTST10 field.
	USB_NDDRINTST_EPNDDINTST10_Msk = 0x400
	// Bit EPNDDINTST10.
	USB_NDDRINTST_EPNDDINTST10 = 0x400
	// Position of EPNDDINTST11 field.
	USB_NDDRINTST_EPNDDINTST11_Pos = 0xb
	// Bit mask of EPNDDINTST11 field.
	USB_NDDRINTST_EPNDDINTST11_Msk = 0x800
	// Bit EPNDDINTST11.
	USB_NDDRINTST_EPNDDINTST11 = 0x800
	// Position of EPNDDINTST12 field.
	USB_NDDRINTST_EPNDDINTST12_Pos = 0xc
	// Bit mask of EPNDDINTST12 field.
	USB_NDDRINTST_EPNDDINTST12_Msk = 0x1000
	// Bit EPNDDINTST12.
	USB_NDDRINTST_EPNDDINTST12 = 0x1000
	// Position of EPNDDINTST13 field.
	USB_NDDRINTST_EPNDDINTST13_Pos = 0xd
	// Bit mask of EPNDDINTST13 field.
	USB_NDDRINTST_EPNDDINTST13_Msk = 0x2000
	// Bit EPNDDINTST13.
	USB_NDDRINTST_EPNDDINTST13 = 0x2000
	// Position of EPNDDINTST14 field.
	USB_NDDRINTST_EPNDDINTST14_Pos = 0xe
	// Bit mask of EPNDDINTST14 field.
	USB_NDDRINTST_EPNDDINTST14_Msk = 0x4000
	// Bit EPNDDINTST14.
	USB_NDDRINTST_EPNDDINTST14 = 0x4000
	// Position of EPNDDINTST15 field.
	USB_NDDRINTST_EPNDDINTST15_Pos = 0xf
	// Bit mask of EPNDDINTST15 field.
	USB_NDDRINTST_EPNDDINTST15_Msk = 0x8000
	// Bit EPNDDINTST15.
	USB_NDDRINTST_EPNDDINTST15 = 0x8000
	// Position of EPNDDINTST16 field.
	USB_NDDRINTST_EPNDDINTST16_Pos = 0x10
	// Bit mask of EPNDDINTST16 field.
	USB_NDDRINTST_EPNDDINTST16_Msk = 0x10000
	// Bit EPNDDINTST16.
	USB_NDDRINTST_EPNDDINTST16 = 0x10000
	// Position of EPNDDINTST17 field.
	USB_NDDRINTST_EPNDDINTST17_Pos = 0x11
	// Bit mask of EPNDDINTST17 field.
	USB_NDDRINTST_EPNDDINTST17_Msk = 0x20000
	// Bit EPNDDINTST17.
	USB_NDDRINTST_EPNDDINTST17 = 0x20000
	// Position of EPNDDINTST18 field.
	USB_NDDRINTST_EPNDDINTST18_Pos = 0x12
	// Bit mask of EPNDDINTST18 field.
	USB_NDDRINTST_EPNDDINTST18_Msk = 0x40000
	// Bit EPNDDINTST18.
	USB_NDDRINTST_EPNDDINTST18 = 0x40000
	// Position of EPNDDINTST19 field.
	USB_NDDRINTST_EPNDDINTST19_Pos = 0x13
	// Bit mask of EPNDDINTST19 field.
	USB_NDDRINTST_EPNDDINTST19_Msk = 0x80000
	// Bit EPNDDINTST19.
	USB_NDDRINTST_EPNDDINTST19 = 0x80000
	// Position of EPNDDINTST20 field.
	USB_NDDRINTST_EPNDDINTST20_Pos = 0x14
	// Bit mask of EPNDDINTST20 field.
	USB_NDDRINTST_EPNDDINTST20_Msk = 0x100000
	// Bit EPNDDINTST20.
	USB_NDDRINTST_EPNDDINTST20 = 0x100000
	// Position of EPNDDINTST21 field.
	USB_NDDRINTST_EPNDDINTST21_Pos = 0x15
	// Bit mask of EPNDDINTST21 field.
	USB_NDDRINTST_EPNDDINTST21_Msk = 0x200000
	// Bit EPNDDINTST21.
	USB_NDDRINTST_EPNDDINTST21 = 0x200000
	// Position of EPNDDINTST22 field.
	USB_NDDRINTST_EPNDDINTST22_Pos = 0x16
	// Bit mask of EPNDDINTST22 field.
	USB_NDDRINTST_EPNDDINTST22_Msk = 0x400000
	// Bit EPNDDINTST22.
	USB_NDDRINTST_EPNDDINTST22 = 0x400000
	// Position of EPNDDINTST23 field.
	USB_NDDRINTST_EPNDDINTST23_Pos = 0x17
	// Bit mask of EPNDDINTST23 field.
	USB_NDDRINTST_EPNDDINTST23_Msk = 0x800000
	// Bit EPNDDINTST23.
	USB_NDDRINTST_EPNDDINTST23 = 0x800000
	// Position of EPNDDINTST24 field.
	USB_NDDRINTST_EPNDDINTST24_Pos = 0x18
	// Bit mask of EPNDDINTST24 field.
	USB_NDDRINTST_EPNDDINTST24_Msk = 0x1000000
	// Bit EPNDDINTST24.
	USB_NDDRINTST_EPNDDINTST24 = 0x1000000
	// Position of EPNDDINTST25 field.
	USB_NDDRINTST_EPNDDINTST25_Pos = 0x19
	// Bit mask of EPNDDINTST25 field.
	USB_NDDRINTST_EPNDDINTST25_Msk = 0x2000000
	// Bit EPNDDINTST25.
	USB_NDDRINTST_EPNDDINTST25 = 0x2000000
	// Position of EPNDDINTST26 field.
	USB_NDDRINTST_EPNDDINTST26_Pos = 0x1a
	// Bit mask of EPNDDINTST26 field.
	USB_NDDRINTST_EPNDDINTST26_Msk = 0x4000000
	// Bit EPNDDINTST26.
	USB_NDDRINTST_EPNDDINTST26 = 0x4000000
	// Position of EPNDDINTST27 field.
	USB_NDDRINTST_EPNDDINTST27_Pos = 0x1b
	// Bit mask of EPNDDINTST27 field.
	USB_NDDRINTST_EPNDDINTST27_Msk = 0x8000000
	// Bit EPNDDINTST27.
	USB_NDDRINTST_EPNDDINTST27 = 0x8000000
	// Position of EPNDDINTST28 field.
	USB_NDDRINTST_EPNDDINTST28_Pos = 0x1c
	// Bit mask of EPNDDINTST28 field.
	USB_NDDRINTST_EPNDDINTST28_Msk = 0x10000000
	// Bit EPNDDINTST28.
	USB_NDDRINTST_EPNDDINTST28 = 0x10000000
	// Position of EPNDDINTST29 field.
	USB_NDDRINTST_EPNDDINTST29_Pos = 0x1d
	// Bit mask of EPNDDINTST29 field.
	USB_NDDRINTST_EPNDDINTST29_Msk = 0x20000000
	// Bit EPNDDINTST29.
	USB_NDDRINTST_EPNDDINTST29 = 0x20000000
	// Position of EPNDDINTST30 field.
	USB_NDDRINTST_EPNDDINTST30_Pos = 0x1e
	// Bit mask of EPNDDINTST30 field.
	USB_NDDRINTST_EPNDDINTST30_Msk = 0x40000000
	// Bit EPNDDINTST30.
	USB_NDDRINTST_EPNDDINTST30 = 0x40000000
	// Position of EPNDDINTST31 field.
	USB_NDDRINTST_EPNDDINTST31_Pos = 0x1f
	// Bit mask of EPNDDINTST31 field.
	USB_NDDRINTST_EPNDDINTST31_Msk = 0x80000000
	// Bit EPNDDINTST31.
	USB_NDDRINTST_EPNDDINTST31 = 0x80000000

	// NDDRINTCLR: USB New DD Request Interrupt Clear
	// Position of EPNDDINTCLR0 field.
	USB_NDDRINTCLR_EPNDDINTCLR0_Pos = 0x0
	// Bit mask of EPNDDINTCLR0 field.
	USB_NDDRINTCLR_EPNDDINTCLR0_Msk = 0x1
	// Bit EPNDDINTCLR0.
	USB_NDDRINTCLR_EPNDDINTCLR0 = 0x1
	// Position of EPNDDINTCLR1 field.
	USB_NDDRINTCLR_EPNDDINTCLR1_Pos = 0x1
	// Bit mask of EPNDDINTCLR1 field.
	USB_NDDRINTCLR_EPNDDINTCLR1_Msk = 0x2
	// Bit EPNDDINTCLR1.
	USB_NDDRINTCLR_EPNDDINTCLR1 = 0x2
	// Position of EPNDDINTCLR2 field.
	USB_NDDRINTCLR_EPNDDINTCLR2_Pos = 0x2
	// Bit mask of EPNDDINTCLR2 field.
	USB_NDDRINTCLR_EPNDDINTCLR2_Msk = 0x4
	// Bit EPNDDINTCLR2.
	USB_NDDRINTCLR_EPNDDINTCLR2 = 0x4
	// Position of EPNDDINTCLR3 field.
	USB_NDDRINTCLR_EPNDDINTCLR3_Pos = 0x3
	// Bit mask of EPNDDINTCLR3 field.
	USB_NDDRINTCLR_EPNDDINTCLR3_Msk = 0x8
	// Bit EPNDDINTCLR3.
	USB_NDDRINTCLR_EPNDDINTCLR3 = 0x8
	// Position of EPNDDINTCLR4 field.
	USB_NDDRINTCLR_EPNDDINTCLR4_Pos = 0x4
	// Bit mask of EPNDDINTCLR4 field.
	USB_NDDRINTCLR_EPNDDINTCLR4_Msk = 0x10
	// Bit EPNDDINTCLR4.
	USB_NDDRINTCLR_EPNDDINTCLR4 = 0x10
	// Position of EPNDDINTCLR5 field.
	USB_NDDRINTCLR_EPNDDINTCLR5_Pos = 0x5
	// Bit mask of EPNDDINTCLR5 field.
	USB_NDDRINTCLR_EPNDDINTCLR5_Msk = 0x20
	// Bit EPNDDINTCLR5.
	USB_NDDRINTCLR_EPNDDINTCLR5 = 0x20
	// Position of EPNDDINTCLR6 field.
	USB_NDDRINTCLR_EPNDDINTCLR6_Pos = 0x6
	// Bit mask of EPNDDINTCLR6 field.
	USB_NDDRINTCLR_EPNDDINTCLR6_Msk = 0x40
	// Bit EPNDDINTCLR6.
	USB_NDDRINTCLR_EPNDDINTCLR6 = 0x40
	// Position of EPNDDINTCLR7 field.
	USB_NDDRINTCLR_EPNDDINTCLR7_Pos = 0x7
	// Bit mask of EPNDDINTCLR7 field.
	USB_NDDRINTCLR_EPNDDINTCLR7_Msk = 0x80
	// Bit EPNDDINTCLR7.
	USB_NDDRINTCLR_EPNDDINTCLR7 = 0x80
	// Position of EPNDDINTCLR8 field.
	USB_NDDRINTCLR_EPNDDINTCLR8_Pos = 0x8
	// Bit mask of EPNDDINTCLR8 field.
	USB_NDDRINTCLR_EPNDDINTCLR8_Msk = 0x100
	// Bit EPNDDINTCLR8.
	USB_NDDRINTCLR_EPNDDINTCLR8 = 0x100
	// Position of EPNDDINTCLR9 field.
	USB_NDDRINTCLR_EPNDDINTCLR9_Pos = 0x9
	// Bit mask of EPNDDINTCLR9 field.
	USB_NDDRINTCLR_EPNDDINTCLR9_Msk = 0x200
	// Bit EPNDDINTCLR9.
	USB_NDDRINTCLR_EPNDDINTCLR9 = 0x200
	// Position of EPNDDINTCLR10 field.
	USB_NDDRINTCLR_EPNDDINTCLR10_Pos = 0xa
	// Bit mask of EPNDDINTCLR10 field.
	USB_NDDRINTCLR_EPNDDINTCLR10_Msk = 0x400
	// Bit EPNDDINTCLR10.
	USB_NDDRINTCLR_EPNDDINTCLR10 = 0x400
	// Position of EPNDDINTCLR11 field.
	USB_NDDRINTCLR_EPNDDINTCLR11_Pos = 0xb
	// Bit mask of EPNDDINTCLR11 field.
	USB_NDDRINTCLR_EPNDDINTCLR11_Msk = 0x800
	// Bit EPNDDINTCLR11.
	USB_NDDRINTCLR_EPNDDINTCLR11 = 0x800
	// Position of EPNDDINTCLR12 field.
	USB_NDDRINTCLR_EPNDDINTCLR12_Pos = 0xc
	// Bit mask of EPNDDINTCLR12 field.
	USB_NDDRINTCLR_EPNDDINTCLR12_Msk = 0x1000
	// Bit EPNDDINTCLR12.
	USB_NDDRINTCLR_EPNDDINTCLR12 = 0x1000
	// Position of EPNDDINTCLR13 field.
	USB_NDDRINTCLR_EPNDDINTCLR13_Pos = 0xd
	// Bit mask of EPNDDINTCLR13 field.
	USB_NDDRINTCLR_EPNDDINTCLR13_Msk = 0x2000
	// Bit EPNDDINTCLR13.
	USB_NDDRINTCLR_EPNDDINTCLR13 = 0x2000
	// Position of EPNDDINTCLR14 field.
	USB_NDDRINTCLR_EPNDDINTCLR14_Pos = 0xe
	// Bit mask of EPNDDINTCLR14 field.
	USB_NDDRINTCLR_EPNDDINTCLR14_Msk = 0x4000
	// Bit EPNDDINTCLR14.
	USB_NDDRINTCLR_EPNDDINTCLR14 = 0x4000
	// Position of EPNDDINTCLR15 field.
	USB_NDDRINTCLR_EPNDDINTCLR15_Pos = 0xf
	// Bit mask of EPNDDINTCLR15 field.
	USB_NDDRINTCLR_EPNDDINTCLR15_Msk = 0x8000
	// Bit EPNDDINTCLR15.
	USB_NDDRINTCLR_EPNDDINTCLR15 = 0x8000
	// Position of EPNDDINTCLR16 field.
	USB_NDDRINTCLR_EPNDDINTCLR16_Pos = 0x10
	// Bit mask of EPNDDINTCLR16 field.
	USB_NDDRINTCLR_EPNDDINTCLR16_Msk = 0x10000
	// Bit EPNDDINTCLR16.
	USB_NDDRINTCLR_EPNDDINTCLR16 = 0x10000
	// Position of EPNDDINTCLR17 field.
	USB_NDDRINTCLR_EPNDDINTCLR17_Pos = 0x11
	// Bit mask of EPNDDINTCLR17 field.
	USB_NDDRINTCLR_EPNDDINTCLR17_Msk = 0x20000
	// Bit EPNDDINTCLR17.
	USB_NDDRINTCLR_EPNDDINTCLR17 = 0x20000
	// Position of EPNDDINTCLR18 field.
	USB_NDDRINTCLR_EPNDDINTCLR18_Pos = 0x12
	// Bit mask of EPNDDINTCLR18 field.
	USB_NDDRINTCLR_EPNDDINTCLR18_Msk = 0x40000
	// Bit EPNDDINTCLR18.
	USB_NDDRINTCLR_EPNDDINTCLR18 = 0x40000
	// Position of EPNDDINTCLR19 field.
	USB_NDDRINTCLR_EPNDDINTCLR19_Pos = 0x13
	// Bit mask of EPNDDINTCLR19 field.
	USB_NDDRINTCLR_EPNDDINTCLR19_Msk = 0x80000
	// Bit EPNDDINTCLR19.
	USB_NDDRINTCLR_EPNDDINTCLR19 = 0x80000
	// Position of EPNDDINTCLR20 field.
	USB_NDDRINTCLR_EPNDDINTCLR20_Pos = 0x14
	// Bit mask of EPNDDINTCLR20 field.
	USB_NDDRINTCLR_EPNDDINTCLR20_Msk = 0x100000
	// Bit EPNDDINTCLR20.
	USB_NDDRINTCLR_EPNDDINTCLR20 = 0x100000
	// Position of EPNDDINTCLR21 field.
	USB_NDDRINTCLR_EPNDDINTCLR21_Pos = 0x15
	// Bit mask of EPNDDINTCLR21 field.
	USB_NDDRINTCLR_EPNDDINTCLR21_Msk = 0x200000
	// Bit EPNDDINTCLR21.
	USB_NDDRINTCLR_EPNDDINTCLR21 = 0x200000
	// Position of EPNDDINTCLR22 field.
	USB_NDDRINTCLR_EPNDDINTCLR22_Pos = 0x16
	// Bit mask of EPNDDINTCLR22 field.
	USB_NDDRINTCLR_EPNDDINTCLR22_Msk = 0x400000
	// Bit EPNDDINTCLR22.
	USB_NDDRINTCLR_EPNDDINTCLR22 = 0x400000
	// Position of EPNDDINTCLR23 field.
	USB_NDDRINTCLR_EPNDDINTCLR23_Pos = 0x17
	// Bit mask of EPNDDINTCLR23 field.
	USB_NDDRINTCLR_EPNDDINTCLR23_Msk = 0x800000
	// Bit EPNDDINTCLR23.
	USB_NDDRINTCLR_EPNDDINTCLR23 = 0x800000
	// Position of EPNDDINTCLR24 field.
	USB_NDDRINTCLR_EPNDDINTCLR24_Pos = 0x18
	// Bit mask of EPNDDINTCLR24 field.
	USB_NDDRINTCLR_EPNDDINTCLR24_Msk = 0x1000000
	// Bit EPNDDINTCLR24.
	USB_NDDRINTCLR_EPNDDINTCLR24 = 0x1000000
	// Position of EPNDDINTCLR25 field.
	USB_NDDRINTCLR_EPNDDINTCLR25_Pos = 0x19
	// Bit mask of EPNDDINTCLR25 field.
	USB_NDDRINTCLR_EPNDDINTCLR25_Msk = 0x2000000
	// Bit EPNDDINTCLR25.
	USB_NDDRINTCLR_EPNDDINTCLR25 = 0x2000000
	// Position of EPNDDINTCLR26 field.
	USB_NDDRINTCLR_EPNDDINTCLR26_Pos = 0x1a
	// Bit mask of EPNDDINTCLR26 field.
	USB_NDDRINTCLR_EPNDDINTCLR26_Msk = 0x4000000
	// Bit EPNDDINTCLR26.
	USB_NDDRINTCLR_EPNDDINTCLR26 = 0x4000000
	// Position of EPNDDINTCLR27 field.
	USB_NDDRINTCLR_EPNDDINTCLR27_Pos = 0x1b
	// Bit mask of EPNDDINTCLR27 field.
	USB_NDDRINTCLR_EPNDDINTCLR27_Msk = 0x8000000
	// Bit EPNDDINTCLR27.
	USB_NDDRINTCLR_EPNDDINTCLR27 = 0x8000000
	// Position of EPNDDINTCLR28 field.
	USB_NDDRINTCLR_EPNDDINTCLR28_Pos = 0x1c
	// Bit mask of EPNDDINTCLR28 field.
	USB_NDDRINTCLR_EPNDDINTCLR28_Msk = 0x10000000
	// Bit EPNDDINTCLR28.
	USB_NDDRINTCLR_EPNDDINTCLR28 = 0x10000000
	// Position of EPNDDINTCLR29 field.
	USB_NDDRINTCLR_EPNDDINTCLR29_Pos = 0x1d
	// Bit mask of EPNDDINTCLR29 field.
	USB_NDDRINTCLR_EPNDDINTCLR29_Msk = 0x20000000
	// Bit EPNDDINTCLR29.
	USB_NDDRINTCLR_EPNDDINTCLR29 = 0x20000000
	// Position of EPNDDINTCLR30 field.
	USB_NDDRINTCLR_EPNDDINTCLR30_Pos = 0x1e
	// Bit mask of EPNDDINTCLR30 field.
	USB_NDDRINTCLR_EPNDDINTCLR30_Msk = 0x40000000
	// Bit EPNDDINTCLR30.
	USB_NDDRINTCLR_EPNDDINTCLR30 = 0x40000000
	// Position of EPNDDINTCLR31 field.
	USB_NDDRINTCLR_EPNDDINTCLR31_Pos = 0x1f
	// Bit mask of EPNDDINTCLR31 field.
	USB_NDDRINTCLR_EPNDDINTCLR31_Msk = 0x80000000
	// Bit EPNDDINTCLR31.
	USB_NDDRINTCLR_EPNDDINTCLR31 = 0x80000000

	// NDDRINTSET: USB New DD Request Interrupt Set
	// Position of EPNDDINTSET0 field.
	USB_NDDRINTSET_EPNDDINTSET0_Pos = 0x0
	// Bit mask of EPNDDINTSET0 field.
	USB_NDDRINTSET_EPNDDINTSET0_Msk = 0x1
	// Bit EPNDDINTSET0.
	USB_NDDRINTSET_EPNDDINTSET0 = 0x1
	// Position of EPNDDINTSET1 field.
	USB_NDDRINTSET_EPNDDINTSET1_Pos = 0x1
	// Bit mask of EPNDDINTSET1 field.
	USB_NDDRINTSET_EPNDDINTSET1_Msk = 0x2
	// Bit EPNDDINTSET1.
	USB_NDDRINTSET_EPNDDINTSET1 = 0x2
	// Position of EPNDDINTSET2 field.
	USB_NDDRINTSET_EPNDDINTSET2_Pos = 0x2
	// Bit mask of EPNDDINTSET2 field.
	USB_NDDRINTSET_EPNDDINTSET2_Msk = 0x4
	// Bit EPNDDINTSET2.
	USB_NDDRINTSET_EPNDDINTSET2 = 0x4
	// Position of EPNDDINTSET3 field.
	USB_NDDRINTSET_EPNDDINTSET3_Pos = 0x3
	// Bit mask of EPNDDINTSET3 field.
	USB_NDDRINTSET_EPNDDINTSET3_Msk = 0x8
	// Bit EPNDDINTSET3.
	USB_NDDRINTSET_EPNDDINTSET3 = 0x8
	// Position of EPNDDINTSET4 field.
	USB_NDDRINTSET_EPNDDINTSET4_Pos = 0x4
	// Bit mask of EPNDDINTSET4 field.
	USB_NDDRINTSET_EPNDDINTSET4_Msk = 0x10
	// Bit EPNDDINTSET4.
	USB_NDDRINTSET_EPNDDINTSET4 = 0x10
	// Position of EPNDDINTSET5 field.
	USB_NDDRINTSET_EPNDDINTSET5_Pos = 0x5
	// Bit mask of EPNDDINTSET5 field.
	USB_NDDRINTSET_EPNDDINTSET5_Msk = 0x20
	// Bit EPNDDINTSET5.
	USB_NDDRINTSET_EPNDDINTSET5 = 0x20
	// Position of EPNDDINTSET6 field.
	USB_NDDRINTSET_EPNDDINTSET6_Pos = 0x6
	// Bit mask of EPNDDINTSET6 field.
	USB_NDDRINTSET_EPNDDINTSET6_Msk = 0x40
	// Bit EPNDDINTSET6.
	USB_NDDRINTSET_EPNDDINTSET6 = 0x40
	// Position of EPNDDINTSET7 field.
	USB_NDDRINTSET_EPNDDINTSET7_Pos = 0x7
	// Bit mask of EPNDDINTSET7 field.
	USB_NDDRINTSET_EPNDDINTSET7_Msk = 0x80
	// Bit EPNDDINTSET7.
	USB_NDDRINTSET_EPNDDINTSET7 = 0x80
	// Position of EPNDDINTSET8 field.
	USB_NDDRINTSET_EPNDDINTSET8_Pos = 0x8
	// Bit mask of EPNDDINTSET8 field.
	USB_NDDRINTSET_EPNDDINTSET8_Msk = 0x100
	// Bit EPNDDINTSET8.
	USB_NDDRINTSET_EPNDDINTSET8 = 0x100
	// Position of EPNDDINTSET9 field.
	USB_NDDRINTSET_EPNDDINTSET9_Pos = 0x9
	// Bit mask of EPNDDINTSET9 field.
	USB_NDDRINTSET_EPNDDINTSET9_Msk = 0x200
	// Bit EPNDDINTSET9.
	USB_NDDRINTSET_EPNDDINTSET9 = 0x200
	// Position of EPNDDINTSET10 field.
	USB_NDDRINTSET_EPNDDINTSET10_Pos = 0xa
	// Bit mask of EPNDDINTSET10 field.
	USB_NDDRINTSET_EPNDDINTSET10_Msk = 0x400
	// Bit EPNDDINTSET10.
	USB_NDDRINTSET_EPNDDINTSET10 = 0x400
	// Position of EPNDDINTSET11 field.
	USB_NDDRINTSET_EPNDDINTSET11_Pos = 0xb
	// Bit mask of EPNDDINTSET11 field.
	USB_NDDRINTSET_EPNDDINTSET11_Msk = 0x800
	// Bit EPNDDINTSET11.
	USB_NDDRINTSET_EPNDDINTSET11 = 0x800
	// Position of EPNDDINTSET12 field.
	USB_NDDRINTSET_EPNDDINTSET12_Pos = 0xc
	// Bit mask of EPNDDINTSET12 field.
	USB_NDDRINTSET_EPNDDINTSET12_Msk = 0x1000
	// Bit EPNDDINTSET12.
	USB_NDDRINTSET_EPNDDINTSET12 = 0x1000
	// Position of EPNDDINTSET13 field.
	USB_NDDRINTSET_EPNDDINTSET13_Pos = 0xd
	// Bit mask of EPNDDINTSET13 field.
	USB_NDDRINTSET_EPNDDINTSET13_Msk = 0x2000
	// Bit EPNDDINTSET13.
	USB_NDDRINTSET_EPNDDINTSET13 = 0x2000
	// Position of EPNDDINTSET14 field.
	USB_NDDRINTSET_EPNDDINTSET14_Pos = 0xe
	// Bit mask of EPNDDINTSET14 field.
	USB_NDDRINTSET_EPNDDINTSET14_Msk = 0x4000
	// Bit EPNDDINTSET14.
	USB_NDDRINTSET_EPNDDINTSET14 = 0x4000
	// Position of EPNDDINTSET15 field.
	USB_NDDRINTSET_EPNDDINTSET15_Pos = 0xf
	// Bit mask of EPNDDINTSET15 field.
	USB_NDDRINTSET_EPNDDINTSET15_Msk = 0x8000
	// Bit EPNDDINTSET15.
	USB_NDDRINTSET_EPNDDINTSET15 = 0x8000
	// Position of EPNDDINTSET16 field.
	USB_NDDRINTSET_EPNDDINTSET16_Pos = 0x10
	// Bit mask of EPNDDINTSET16 field.
	USB_NDDRINTSET_EPNDDINTSET16_Msk = 0x10000
	// Bit EPNDDINTSET16.
	USB_NDDRINTSET_EPNDDINTSET16 = 0x10000
	// Position of EPNDDINTSET17 field.
	USB_NDDRINTSET_EPNDDINTSET17_Pos = 0x11
	// Bit mask of EPNDDINTSET17 field.
	USB_NDDRINTSET_EPNDDINTSET17_Msk = 0x20000
	// Bit EPNDDINTSET17.
	USB_NDDRINTSET_EPNDDINTSET17 = 0x20000
	// Position of EPNDDINTSET18 field.
	USB_NDDRINTSET_EPNDDINTSET18_Pos = 0x12
	// Bit mask of EPNDDINTSET18 field.
	USB_NDDRINTSET_EPNDDINTSET18_Msk = 0x40000
	// Bit EPNDDINTSET18.
	USB_NDDRINTSET_EPNDDINTSET18 = 0x40000
	// Position of EPNDDINTSET19 field.
	USB_NDDRINTSET_EPNDDINTSET19_Pos = 0x13
	// Bit mask of EPNDDINTSET19 field.
	USB_NDDRINTSET_EPNDDINTSET19_Msk = 0x80000
	// Bit EPNDDINTSET19.
	USB_NDDRINTSET_EPNDDINTSET19 = 0x80000
	// Position of EPNDDINTSET20 field.
	USB_NDDRINTSET_EPNDDINTSET20_Pos = 0x14
	// Bit mask of EPNDDINTSET20 field.
	USB_NDDRINTSET_EPNDDINTSET20_Msk = 0x100000
	// Bit EPNDDINTSET20.
	USB_NDDRINTSET_EPNDDINTSET20 = 0x100000
	// Position of EPNDDINTSET21 field.
	USB_NDDRINTSET_EPNDDINTSET21_Pos = 0x15
	// Bit mask of EPNDDINTSET21 field.
	USB_NDDRINTSET_EPNDDINTSET21_Msk = 0x200000
	// Bit EPNDDINTSET21.
	USB_NDDRINTSET_EPNDDINTSET21 = 0x200000
	// Position of EPNDDINTSET22 field.
	USB_NDDRINTSET_EPNDDINTSET22_Pos = 0x16
	// Bit mask of EPNDDINTSET22 field.
	USB_NDDRINTSET_EPNDDINTSET22_Msk = 0x400000
	// Bit EPNDDINTSET22.
	USB_NDDRINTSET_EPNDDINTSET22 = 0x400000
	// Position of EPNDDINTSET23 field.
	USB_NDDRINTSET_EPNDDINTSET23_Pos = 0x17
	// Bit mask of EPNDDINTSET23 field.
	USB_NDDRINTSET_EPNDDINTSET23_Msk = 0x800000
	// Bit EPNDDINTSET23.
	USB_NDDRINTSET_EPNDDINTSET23 = 0x800000
	// Position of EPNDDINTSET24 field.
	USB_NDDRINTSET_EPNDDINTSET24_Pos = 0x18
	// Bit mask of EPNDDINTSET24 field.
	USB_NDDRINTSET_EPNDDINTSET24_Msk = 0x1000000
	// Bit EPNDDINTSET24.
	USB_NDDRINTSET_EPNDDINTSET24 = 0x1000000
	// Position of EPNDDINTSET25 field.
	USB_NDDRINTSET_EPNDDINTSET25_Pos = 0x19
	// Bit mask of EPNDDINTSET25 field.
	USB_NDDRINTSET_EPNDDINTSET25_Msk = 0x2000000
	// Bit EPNDDINTSET25.
	USB_NDDRINTSET_EPNDDINTSET25 = 0x2000000
	// Position of EPNDDINTSET26 field.
	USB_NDDRINTSET_EPNDDINTSET26_Pos = 0x1a
	// Bit mask of EPNDDINTSET26 field.
	USB_NDDRINTSET_EPNDDINTSET26_Msk = 0x4000000
	// Bit EPNDDINTSET26.
	USB_NDDRINTSET_EPNDDINTSET26 = 0x4000000
	// Position of EPNDDINTSET27 field.
	USB_NDDRINTSET_EPNDDINTSET27_Pos = 0x1b
	// Bit mask of EPNDDINTSET27 field.
	USB_NDDRINTSET_EPNDDINTSET27_Msk = 0x8000000
	// Bit EPNDDINTSET27.
	USB_NDDRINTSET_EPNDDINTSET27 = 0x8000000
	// Position of EPNDDINTSET28 field.
	USB_NDDRINTSET_EPNDDINTSET28_Pos = 0x1c
	// Bit mask of EPNDDINTSET28 field.
	USB_NDDRINTSET_EPNDDINTSET28_Msk = 0x10000000
	// Bit EPNDDINTSET28.
	USB_NDDRINTSET_EPNDDINTSET28 = 0x10000000
	// Position of EPNDDINTSET29 field.
	USB_NDDRINTSET_EPNDDINTSET29_Pos = 0x1d
	// Bit mask of EPNDDINTSET29 field.
	USB_NDDRINTSET_EPNDDINTSET29_Msk = 0x20000000
	// Bit EPNDDINTSET29.
	USB_NDDRINTSET_EPNDDINTSET29 = 0x20000000
	// Position of EPNDDINTSET30 field.
	USB_NDDRINTSET_EPNDDINTSET30_Pos = 0x1e
	// Bit mask of EPNDDINTSET30 field.
	USB_NDDRINTSET_EPNDDINTSET30_Msk = 0x40000000
	// Bit EPNDDINTSET30.
	USB_NDDRINTSET_EPNDDINTSET30 = 0x40000000
	// Position of EPNDDINTSET31 field.
	USB_NDDRINTSET_EPNDDINTSET31_Pos = 0x1f
	// Bit mask of EPNDDINTSET31 field.
	USB_NDDRINTSET_EPNDDINTSET31_Msk = 0x80000000
	// Bit EPNDDINTSET31.
	USB_NDDRINTSET_EPNDDINTSET31 = 0x80000000

	// SYSERRINTST: USB System Error Interrupt Status
	// Position of EPERRINTST0 field.
	USB_SYSERRINTST_EPERRINTST0_Pos = 0x0
	// Bit mask of EPERRINTST0 field.
	USB_SYSERRINTST_EPERRINTST0_Msk = 0x1
	// Bit EPERRINTST0.
	USB_SYSERRINTST_EPERRINTST0 = 0x1
	// Position of EPERRINTST1 field.
	USB_SYSERRINTST_EPERRINTST1_Pos = 0x1
	// Bit mask of EPERRINTST1 field.
	USB_SYSERRINTST_EPERRINTST1_Msk = 0x2
	// Bit EPERRINTST1.
	USB_SYSERRINTST_EPERRINTST1 = 0x2
	// Position of EPERRINTST2 field.
	USB_SYSERRINTST_EPERRINTST2_Pos = 0x2
	// Bit mask of EPERRINTST2 field.
	USB_SYSERRINTST_EPERRINTST2_Msk = 0x4
	// Bit EPERRINTST2.
	USB_SYSERRINTST_EPERRINTST2 = 0x4
	// Position of EPERRINTST3 field.
	USB_SYSERRINTST_EPERRINTST3_Pos = 0x3
	// Bit mask of EPERRINTST3 field.
	USB_SYSERRINTST_EPERRINTST3_Msk = 0x8
	// Bit EPERRINTST3.
	USB_SYSERRINTST_EPERRINTST3 = 0x8
	// Position of EPERRINTST4 field.
	USB_SYSERRINTST_EPERRINTST4_Pos = 0x4
	// Bit mask of EPERRINTST4 field.
	USB_SYSERRINTST_EPERRINTST4_Msk = 0x10
	// Bit EPERRINTST4.
	USB_SYSERRINTST_EPERRINTST4 = 0x10
	// Position of EPERRINTST5 field.
	USB_SYSERRINTST_EPERRINTST5_Pos = 0x5
	// Bit mask of EPERRINTST5 field.
	USB_SYSERRINTST_EPERRINTST5_Msk = 0x20
	// Bit EPERRINTST5.
	USB_SYSERRINTST_EPERRINTST5 = 0x20
	// Position of EPERRINTST6 field.
	USB_SYSERRINTST_EPERRINTST6_Pos = 0x6
	// Bit mask of EPERRINTST6 field.
	USB_SYSERRINTST_EPERRINTST6_Msk = 0x40
	// Bit EPERRINTST6.
	USB_SYSERRINTST_EPERRINTST6 = 0x40
	// Position of EPERRINTST7 field.
	USB_SYSERRINTST_EPERRINTST7_Pos = 0x7
	// Bit mask of EPERRINTST7 field.
	USB_SYSERRINTST_EPERRINTST7_Msk = 0x80
	// Bit EPERRINTST7.
	USB_SYSERRINTST_EPERRINTST7 = 0x80
	// Position of EPERRINTST8 field.
	USB_SYSERRINTST_EPERRINTST8_Pos = 0x8
	// Bit mask of EPERRINTST8 field.
	USB_SYSERRINTST_EPERRINTST8_Msk = 0x100
	// Bit EPERRINTST8.
	USB_SYSERRINTST_EPERRINTST8 = 0x100
	// Position of EPERRINTST9 field.
	USB_SYSERRINTST_EPERRINTST9_Pos = 0x9
	// Bit mask of EPERRINTST9 field.
	USB_SYSERRINTST_EPERRINTST9_Msk = 0x200
	// Bit EPERRINTST9.
	USB_SYSERRINTST_EPERRINTST9 = 0x200
	// Position of EPERRINTST10 field.
	USB_SYSERRINTST_EPERRINTST10_Pos = 0xa
	// Bit mask of EPERRINTST10 field.
	USB_SYSERRINTST_EPERRINTST10_Msk = 0x400
	// Bit EPERRINTST10.
	USB_SYSERRINTST_EPERRINTST10 = 0x400
	// Position of EPERRINTST11 field.
	USB_SYSERRINTST_EPERRINTST11_Pos = 0xb
	// Bit mask of EPERRINTST11 field.
	USB_SYSERRINTST_EPERRINTST11_Msk = 0x800
	// Bit EPERRINTST11.
	USB_SYSERRINTST_EPERRINTST11 = 0x800
	// Position of EPERRINTST12 field.
	USB_SYSERRINTST_EPERRINTST12_Pos = 0xc
	// Bit mask of EPERRINTST12 field.
	USB_SYSERRINTST_EPERRINTST12_Msk = 0x1000
	// Bit EPERRINTST12.
	USB_SYSERRINTST_EPERRINTST12 = 0x1000
	// Position of EPERRINTST13 field.
	USB_SYSERRINTST_EPERRINTST13_Pos = 0xd
	// Bit mask of EPERRINTST13 field.
	USB_SYSERRINTST_EPERRINTST13_Msk = 0x2000
	// Bit EPERRINTST13.
	USB_SYSERRINTST_EPERRINTST13 = 0x2000
	// Position of EPERRINTST14 field.
	USB_SYSERRINTST_EPERRINTST14_Pos = 0xe
	// Bit mask of EPERRINTST14 field.
	USB_SYSERRINTST_EPERRINTST14_Msk = 0x4000
	// Bit EPERRINTST14.
	USB_SYSERRINTST_EPERRINTST14 = 0x4000
	// Position of EPERRINTST15 field.
	USB_SYSERRINTST_EPERRINTST15_Pos = 0xf
	// Bit mask of EPERRINTST15 field.
	USB_SYSERRINTST_EPERRINTST15_Msk = 0x8000
	// Bit EPERRINTST15.
	USB_SYSERRINTST_EPERRINTST15 = 0x8000
	// Position of EPERRINTST16 field.
	USB_SYSERRINTST_EPERRINTST16_Pos = 0x10
	// Bit mask of EPERRINTST16 field.
	USB_SYSERRINTST_EPERRINTST16_Msk = 0x10000
	// Bit EPERRINTST16.
	USB_SYSERRINTST_EPERRINTST16 = 0x10000
	// Position of EPERRINTST17 field.
	USB_SYSERRINTST_EPERRINTST17_Pos = 0x11
	// Bit mask of EPERRINTST17 field.
	USB_SYSERRINTST_EPERRINTST17_Msk = 0x20000
	// Bit EPERRINTST17.
	USB_SYSERRINTST_EPERRINTST17 = 0x20000
	// Position of EPERRINTST18 field.
	USB_SYSERRINTST_EPERRINTST18_Pos = 0x12
	// Bit mask of EPERRINTST18 field.
	USB_SYSERRINTST_EPERRINTST18_Msk = 0x40000
	// Bit EPERRINTST18.
	USB_SYSERRINTST_EPERRINTST18 = 0x40000
	// Position of EPERRINTST19 field.
	USB_SYSERRINTST_EPERRINTST19_Pos = 0x13
	// Bit mask of EPERRINTST19 field.
	USB_SYSERRINTST_EPERRINTST19_Msk = 0x80000
	// Bit EPERRINTST19.
	USB_SYSERRINTST_EPERRINTST19 = 0x80000
	// Position of EPERRINTST20 field.
	USB_SYSERRINTST_EPERRINTST20_Pos = 0x14
	// Bit mask of EPERRINTST20 field.
	USB_SYSERRINTST_EPERRINTST20_Msk = 0x100000
	// Bit EPERRINTST20.
	USB_SYSERRINTST_EPERRINTST20 = 0x100000
	// Position of EPERRINTST21 field.
	USB_SYSERRINTST_EPERRINTST21_Pos = 0x15
	// Bit mask of EPERRINTST21 field.
	USB_SYSERRINTST_EPERRINTST21_Msk = 0x200000
	// Bit EPERRINTST21.
	USB_SYSERRINTST_EPERRINTST21 = 0x200000
	// Position of EPERRINTST22 field.
	USB_SYSERRINTST_EPERRINTST22_Pos = 0x16
	// Bit mask of EPERRINTST22 field.
	USB_SYSERRINTST_EPERRINTST22_Msk = 0x400000
	// Bit EPERRINTST22.
	USB_SYSERRINTST_EPERRINTST22 = 0x400000
	// Position of EPERRINTST23 field.
	USB_SYSERRINTST_EPERRINTST23_Pos = 0x17
	// Bit mask of EPERRINTST23 field.
	USB_SYSERRINTST_EPERRINTST23_Msk = 0x800000
	// Bit EPERRINTST23.
	USB_SYSERRINTST_EPERRINTST23 = 0x800000
	// Position of EPERRINTST24 field.
	USB_SYSERRINTST_EPERRINTST24_Pos = 0x18
	// Bit mask of EPERRINTST24 field.
	USB_SYSERRINTST_EPERRINTST24_Msk = 0x1000000
	// Bit EPERRINTST24.
	USB_SYSERRINTST_EPERRINTST24 = 0x1000000
	// Position of EPERRINTST25 field.
	USB_SYSERRINTST_EPERRINTST25_Pos = 0x19
	// Bit mask of EPERRINTST25 field.
	USB_SYSERRINTST_EPERRINTST25_Msk = 0x2000000
	// Bit EPERRINTST25.
	USB_SYSERRINTST_EPERRINTST25 = 0x2000000
	// Position of EPERRINTST26 field.
	USB_SYSERRINTST_EPERRINTST26_Pos = 0x1a
	// Bit mask of EPERRINTST26 field.
	USB_SYSERRINTST_EPERRINTST26_Msk = 0x4000000
	// Bit EPERRINTST26.
	USB_SYSERRINTST_EPERRINTST26 = 0x4000000
	// Position of EPERRINTST27 field.
	USB_SYSERRINTST_EPERRINTST27_Pos = 0x1b
	// Bit mask of EPERRINTST27 field.
	USB_SYSERRINTST_EPERRINTST27_Msk = 0x8000000
	// Bit EPERRINTST27.
	USB_SYSERRINTST_EPERRINTST27 = 0x8000000
	// Position of EPERRINTST28 field.
	USB_SYSERRINTST_EPERRINTST28_Pos = 0x1c
	// Bit mask of EPERRINTST28 field.
	USB_SYSERRINTST_EPERRINTST28_Msk = 0x10000000
	// Bit EPERRINTST28.
	USB_SYSERRINTST_EPERRINTST28 = 0x10000000
	// Position of EPERRINTST29 field.
	USB_SYSERRINTST_EPERRINTST29_Pos = 0x1d
	// Bit mask of EPERRINTST29 field.
	USB_SYSERRINTST_EPERRINTST29_Msk = 0x20000000
	// Bit EPERRINTST29.
	USB_SYSERRINTST_EPERRINTST29 = 0x20000000
	// Position of EPERRINTST30 field.
	USB_SYSERRINTST_EPERRINTST30_Pos = 0x1e
	// Bit mask of EPERRINTST30 field.
	USB_SYSERRINTST_EPERRINTST30_Msk = 0x40000000
	// Bit EPERRINTST30.
	USB_SYSERRINTST_EPERRINTST30 = 0x40000000
	// Position of EPERRINTST31 field.
	USB_SYSERRINTST_EPERRINTST31_Pos = 0x1f
	// Bit mask of EPERRINTST31 field.
	USB_SYSERRINTST_EPERRINTST31_Msk = 0x80000000
	// Bit EPERRINTST31.
	USB_SYSERRINTST_EPERRINTST31 = 0x80000000

	// SYSERRINTCLR: USB System Error Interrupt Clear
	// Position of EPERRINTCLR0 field.
	USB_SYSERRINTCLR_EPERRINTCLR0_Pos = 0x0
	// Bit mask of EPERRINTCLR0 field.
	USB_SYSERRINTCLR_EPERRINTCLR0_Msk = 0x1
	// Bit EPERRINTCLR0.
	USB_SYSERRINTCLR_EPERRINTCLR0 = 0x1
	// Position of EPERRINTCLR1 field.
	USB_SYSERRINTCLR_EPERRINTCLR1_Pos = 0x1
	// Bit mask of EPERRINTCLR1 field.
	USB_SYSERRINTCLR_EPERRINTCLR1_Msk = 0x2
	// Bit EPERRINTCLR1.
	USB_SYSERRINTCLR_EPERRINTCLR1 = 0x2
	// Position of EPERRINTCLR2 field.
	USB_SYSERRINTCLR_EPERRINTCLR2_Pos = 0x2
	// Bit mask of EPERRINTCLR2 field.
	USB_SYSERRINTCLR_EPERRINTCLR2_Msk = 0x4
	// Bit EPERRINTCLR2.
	USB_SYSERRINTCLR_EPERRINTCLR2 = 0x4
	// Position of EPERRINTCLR3 field.
	USB_SYSERRINTCLR_EPERRINTCLR3_Pos = 0x3
	// Bit mask of EPERRINTCLR3 field.
	USB_SYSERRINTCLR_EPERRINTCLR3_Msk = 0x8
	// Bit EPERRINTCLR3.
	USB_SYSERRINTCLR_EPERRINTCLR3 = 0x8
	// Position of EPERRINTCLR4 field.
	USB_SYSERRINTCLR_EPERRINTCLR4_Pos = 0x4
	// Bit mask of EPERRINTCLR4 field.
	USB_SYSERRINTCLR_EPERRINTCLR4_Msk = 0x10
	// Bit EPERRINTCLR4.
	USB_SYSERRINTCLR_EPERRINTCLR4 = 0x10
	// Position of EPERRINTCLR5 field.
	USB_SYSERRINTCLR_EPERRINTCLR5_Pos = 0x5
	// Bit mask of EPERRINTCLR5 field.
	USB_SYSERRINTCLR_EPERRINTCLR5_Msk = 0x20
	// Bit EPERRINTCLR5.
	USB_SYSERRINTCLR_EPERRINTCLR5 = 0x20
	// Position of EPERRINTCLR6 field.
	USB_SYSERRINTCLR_EPERRINTCLR6_Pos = 0x6
	// Bit mask of EPERRINTCLR6 field.
	USB_SYSERRINTCLR_EPERRINTCLR6_Msk = 0x40
	// Bit EPERRINTCLR6.
	USB_SYSERRINTCLR_EPERRINTCLR6 = 0x40
	// Position of EPERRINTCLR7 field.
	USB_SYSERRINTCLR_EPERRINTCLR7_Pos = 0x7
	// Bit mask of EPERRINTCLR7 field.
	USB_SYSERRINTCLR_EPERRINTCLR7_Msk = 0x80
	// Bit EPERRINTCLR7.
	USB_SYSERRINTCLR_EPERRINTCLR7 = 0x80
	// Position of EPERRINTCLR8 field.
	USB_SYSERRINTCLR_EPERRINTCLR8_Pos = 0x8
	// Bit mask of EPERRINTCLR8 field.
	USB_SYSERRINTCLR_EPERRINTCLR8_Msk = 0x100
	// Bit EPERRINTCLR8.
	USB_SYSERRINTCLR_EPERRINTCLR8 = 0x100
	// Position of EPERRINTCLR9 field.
	USB_SYSERRINTCLR_EPERRINTCLR9_Pos = 0x9
	// Bit mask of EPERRINTCLR9 field.
	USB_SYSERRINTCLR_EPERRINTCLR9_Msk = 0x200
	// Bit EPERRINTCLR9.
	USB_SYSERRINTCLR_EPERRINTCLR9 = 0x200
	// Position of EPERRINTCLR10 field.
	USB_SYSERRINTCLR_EPERRINTCLR10_Pos = 0xa
	// Bit mask of EPERRINTCLR10 field.
	USB_SYSERRINTCLR_EPERRINTCLR10_Msk = 0x400
	// Bit EPERRINTCLR10.
	USB_SYSERRINTCLR_EPERRINTCLR10 = 0x400
	// Position of EPERRINTCLR11 field.
	USB_SYSERRINTCLR_EPERRINTCLR11_Pos = 0xb
	// Bit mask of EPERRINTCLR11 field.
	USB_SYSERRINTCLR_EPERRINTCLR11_Msk = 0x800
	// Bit EPERRINTCLR11.
	USB_SYSERRINTCLR_EPERRINTCLR11 = 0x800
	// Position of EPERRINTCLR12 field.
	USB_SYSERRINTCLR_EPERRINTCLR12_Pos = 0xc
	// Bit mask of EPERRINTCLR12 field.
	USB_SYSERRINTCLR_EPERRINTCLR12_Msk = 0x1000
	// Bit EPERRINTCLR12.
	USB_SYSERRINTCLR_EPERRINTCLR12 = 0x1000
	// Position of EPERRINTCLR13 field.
	USB_SYSERRINTCLR_EPERRINTCLR13_Pos = 0xd
	// Bit mask of EPERRINTCLR13 field.
	USB_SYSERRINTCLR_EPERRINTCLR13_Msk = 0x2000
	// Bit EPERRINTCLR13.
	USB_SYSERRINTCLR_EPERRINTCLR13 = 0x2000
	// Position of EPERRINTCLR14 field.
	USB_SYSERRINTCLR_EPERRINTCLR14_Pos = 0xe
	// Bit mask of EPERRINTCLR14 field.
	USB_SYSERRINTCLR_EPERRINTCLR14_Msk = 0x4000
	// Bit EPERRINTCLR14.
	USB_SYSERRINTCLR_EPERRINTCLR14 = 0x4000
	// Position of EPERRINTCLR15 field.
	USB_SYSERRINTCLR_EPERRINTCLR15_Pos = 0xf
	// Bit mask of EPERRINTCLR15 field.
	USB_SYSERRINTCLR_EPERRINTCLR15_Msk = 0x8000
	// Bit EPERRINTCLR15.
	USB_SYSERRINTCLR_EPERRINTCLR15 = 0x8000
	// Position of EPERRINTCLR16 field.
	USB_SYSERRINTCLR_EPERRINTCLR16_Pos = 0x10
	// Bit mask of EPERRINTCLR16 field.
	USB_SYSERRINTCLR_EPERRINTCLR16_Msk = 0x10000
	// Bit EPERRINTCLR16.
	USB_SYSERRINTCLR_EPERRINTCLR16 = 0x10000
	// Position of EPERRINTCLR17 field.
	USB_SYSERRINTCLR_EPERRINTCLR17_Pos = 0x11
	// Bit mask of EPERRINTCLR17 field.
	USB_SYSERRINTCLR_EPERRINTCLR17_Msk = 0x20000
	// Bit EPERRINTCLR17.
	USB_SYSERRINTCLR_EPERRINTCLR17 = 0x20000
	// Position of EPERRINTCLR18 field.
	USB_SYSERRINTCLR_EPERRINTCLR18_Pos = 0x12
	// Bit mask of EPERRINTCLR18 field.
	USB_SYSERRINTCLR_EPERRINTCLR18_Msk = 0x40000
	// Bit EPERRINTCLR18.
	USB_SYSERRINTCLR_EPERRINTCLR18 = 0x40000
	// Position of EPERRINTCLR19 field.
	USB_SYSERRINTCLR_EPERRINTCLR19_Pos = 0x13
	// Bit mask of EPERRINTCLR19 field.
	USB_SYSERRINTCLR_EPERRINTCLR19_Msk = 0x80000
	// Bit EPERRINTCLR19.
	USB_SYSERRINTCLR_EPERRINTCLR19 = 0x80000
	// Position of EPERRINTCLR20 field.
	USB_SYSERRINTCLR_EPERRINTCLR20_Pos = 0x14
	// Bit mask of EPERRINTCLR20 field.
	USB_SYSERRINTCLR_EPERRINTCLR20_Msk = 0x100000
	// Bit EPERRINTCLR20.
	USB_SYSERRINTCLR_EPERRINTCLR20 = 0x100000
	// Position of EPERRINTCLR21 field.
	USB_SYSERRINTCLR_EPERRINTCLR21_Pos = 0x15
	// Bit mask of EPERRINTCLR21 field.
	USB_SYSERRINTCLR_EPERRINTCLR21_Msk = 0x200000
	// Bit EPERRINTCLR21.
	USB_SYSERRINTCLR_EPERRINTCLR21 = 0x200000
	// Position of EPERRINTCLR22 field.
	USB_SYSERRINTCLR_EPERRINTCLR22_Pos = 0x16
	// Bit mask of EPERRINTCLR22 field.
	USB_SYSERRINTCLR_EPERRINTCLR22_Msk = 0x400000
	// Bit EPERRINTCLR22.
	USB_SYSERRINTCLR_EPERRINTCLR22 = 0x400000
	// Position of EPERRINTCLR23 field.
	USB_SYSERRINTCLR_EPERRINTCLR23_Pos = 0x17
	// Bit mask of EPERRINTCLR23 field.
	USB_SYSERRINTCLR_EPERRINTCLR23_Msk = 0x800000
	// Bit EPERRINTCLR23.
	USB_SYSERRINTCLR_EPERRINTCLR23 = 0x800000
	// Position of EPERRINTCLR24 field.
	USB_SYSERRINTCLR_EPERRINTCLR24_Pos = 0x18
	// Bit mask of EPERRINTCLR24 field.
	USB_SYSERRINTCLR_EPERRINTCLR24_Msk = 0x1000000
	// Bit EPERRINTCLR24.
	USB_SYSERRINTCLR_EPERRINTCLR24 = 0x1000000
	// Position of EPERRINTCLR25 field.
	USB_SYSERRINTCLR_EPERRINTCLR25_Pos = 0x19
	// Bit mask of EPERRINTCLR25 field.
	USB_SYSERRINTCLR_EPERRINTCLR25_Msk = 0x2000000
	// Bit EPERRINTCLR25.
	USB_SYSERRINTCLR_EPERRINTCLR25 = 0x2000000
	// Position of EPERRINTCLR26 field.
	USB_SYSERRINTCLR_EPERRINTCLR26_Pos = 0x1a
	// Bit mask of EPERRINTCLR26 field.
	USB_SYSERRINTCLR_EPERRINTCLR26_Msk = 0x4000000
	// Bit EPERRINTCLR26.
	USB_SYSERRINTCLR_EPERRINTCLR26 = 0x4000000
	// Position of EPERRINTCLR27 field.
	USB_SYSERRINTCLR_EPERRINTCLR27_Pos = 0x1b
	// Bit mask of EPERRINTCLR27 field.
	USB_SYSERRINTCLR_EPERRINTCLR27_Msk = 0x8000000
	// Bit EPERRINTCLR27.
	USB_SYSERRINTCLR_EPERRINTCLR27 = 0x8000000
	// Position of EPERRINTCLR28 field.
	USB_SYSERRINTCLR_EPERRINTCLR28_Pos = 0x1c
	// Bit mask of EPERRINTCLR28 field.
	USB_SYSERRINTCLR_EPERRINTCLR28_Msk = 0x10000000
	// Bit EPERRINTCLR28.
	USB_SYSERRINTCLR_EPERRINTCLR28 = 0x10000000
	// Position of EPERRINTCLR29 field.
	USB_SYSERRINTCLR_EPERRINTCLR29_Pos = 0x1d
	// Bit mask of EPERRINTCLR29 field.
	USB_SYSERRINTCLR_EPERRINTCLR29_Msk = 0x20000000
	// Bit EPERRINTCLR29.
	USB_SYSERRINTCLR_EPERRINTCLR29 = 0x20000000
	// Position of EPERRINTCLR30 field.
	USB_SYSERRINTCLR_EPERRINTCLR30_Pos = 0x1e
	// Bit mask of EPERRINTCLR30 field.
	USB_SYSERRINTCLR_EPERRINTCLR30_Msk = 0x40000000
	// Bit EPERRINTCLR30.
	USB_SYSERRINTCLR_EPERRINTCLR30 = 0x40000000
	// Position of EPERRINTCLR31 field.
	USB_SYSERRINTCLR_EPERRINTCLR31_Pos = 0x1f
	// Bit mask of EPERRINTCLR31 field.
	USB_SYSERRINTCLR_EPERRINTCLR31_Msk = 0x80000000
	// Bit EPERRINTCLR31.
	USB_SYSERRINTCLR_EPERRINTCLR31 = 0x80000000

	// SYSERRINTSET: USB System Error Interrupt Set
	// Position of EPERRINTSET0 field.
	USB_SYSERRINTSET_EPERRINTSET0_Pos = 0x0
	// Bit mask of EPERRINTSET0 field.
	USB_SYSERRINTSET_EPERRINTSET0_Msk = 0x1
	// Bit EPERRINTSET0.
	USB_SYSERRINTSET_EPERRINTSET0 = 0x1
	// Position of EPERRINTSET1 field.
	USB_SYSERRINTSET_EPERRINTSET1_Pos = 0x1
	// Bit mask of EPERRINTSET1 field.
	USB_SYSERRINTSET_EPERRINTSET1_Msk = 0x2
	// Bit EPERRINTSET1.
	USB_SYSERRINTSET_EPERRINTSET1 = 0x2
	// Position of EPERRINTSET2 field.
	USB_SYSERRINTSET_EPERRINTSET2_Pos = 0x2
	// Bit mask of EPERRINTSET2 field.
	USB_SYSERRINTSET_EPERRINTSET2_Msk = 0x4
	// Bit EPERRINTSET2.
	USB_SYSERRINTSET_EPERRINTSET2 = 0x4
	// Position of EPERRINTSET3 field.
	USB_SYSERRINTSET_EPERRINTSET3_Pos = 0x3
	// Bit mask of EPERRINTSET3 field.
	USB_SYSERRINTSET_EPERRINTSET3_Msk = 0x8
	// Bit EPERRINTSET3.
	USB_SYSERRINTSET_EPERRINTSET3 = 0x8
	// Position of EPERRINTSET4 field.
	USB_SYSERRINTSET_EPERRINTSET4_Pos = 0x4
	// Bit mask of EPERRINTSET4 field.
	USB_SYSERRINTSET_EPERRINTSET4_Msk = 0x10
	// Bit EPERRINTSET4.
	USB_SYSERRINTSET_EPERRINTSET4 = 0x10
	// Position of EPERRINTSET5 field.
	USB_SYSERRINTSET_EPERRINTSET5_Pos = 0x5
	// Bit mask of EPERRINTSET5 field.
	USB_SYSERRINTSET_EPERRINTSET5_Msk = 0x20
	// Bit EPERRINTSET5.
	USB_SYSERRINTSET_EPERRINTSET5 = 0x20
	// Position of EPERRINTSET6 field.
	USB_SYSERRINTSET_EPERRINTSET6_Pos = 0x6
	// Bit mask of EPERRINTSET6 field.
	USB_SYSERRINTSET_EPERRINTSET6_Msk = 0x40
	// Bit EPERRINTSET6.
	USB_SYSERRINTSET_EPERRINTSET6 = 0x40
	// Position of EPERRINTSET7 field.
	USB_SYSERRINTSET_EPERRINTSET7_Pos = 0x7
	// Bit mask of EPERRINTSET7 field.
	USB_SYSERRINTSET_EPERRINTSET7_Msk = 0x80
	// Bit EPERRINTSET7.
	USB_SYSERRINTSET_EPERRINTSET7 = 0x80
	// Position of EPERRINTSET8 field.
	USB_SYSERRINTSET_EPERRINTSET8_Pos = 0x8
	// Bit mask of EPERRINTSET8 field.
	USB_SYSERRINTSET_EPERRINTSET8_Msk = 0x100
	// Bit EPERRINTSET8.
	USB_SYSERRINTSET_EPERRINTSET8 = 0x100
	// Position of EPERRINTSET9 field.
	USB_SYSERRINTSET_EPERRINTSET9_Pos = 0x9
	// Bit mask of EPERRINTSET9 field.
	USB_SYSERRINTSET_EPERRINTSET9_Msk = 0x200
	// Bit EPERRINTSET9.
	USB_SYSERRINTSET_EPERRINTSET9 = 0x200
	// Position of EPERRINTSET10 field.
	USB_SYSERRINTSET_EPERRINTSET10_Pos = 0xa
	// Bit mask of EPERRINTSET10 field.
	USB_SYSERRINTSET_EPERRINTSET10_Msk = 0x400
	// Bit EPERRINTSET10.
	USB_SYSERRINTSET_EPERRINTSET10 = 0x400
	// Position of EPERRINTSET11 field.
	USB_SYSERRINTSET_EPERRINTSET11_Pos = 0xb
	// Bit mask of EPERRINTSET11 field.
	USB_SYSERRINTSET_EPERRINTSET11_Msk = 0x800
	// Bit EPERRINTSET11.
	USB_SYSERRINTSET_EPERRINTSET11 = 0x800
	// Position of EPERRINTSET12 field.
	USB_SYSERRINTSET_EPERRINTSET12_Pos = 0xc
	// Bit mask of EPERRINTSET12 field.
	USB_SYSERRINTSET_EPERRINTSET12_Msk = 0x1000
	// Bit EPERRINTSET12.
	USB_SYSERRINTSET_EPERRINTSET12 = 0x1000
	// Position of EPERRINTSET13 field.
	USB_SYSERRINTSET_EPERRINTSET13_Pos = 0xd
	// Bit mask of EPERRINTSET13 field.
	USB_SYSERRINTSET_EPERRINTSET13_Msk = 0x2000
	// Bit EPERRINTSET13.
	USB_SYSERRINTSET_EPERRINTSET13 = 0x2000
	// Position of EPERRINTSET14 field.
	USB_SYSERRINTSET_EPERRINTSET14_Pos = 0xe
	// Bit mask of EPERRINTSET14 field.
	USB_SYSERRINTSET_EPERRINTSET14_Msk = 0x4000
	// Bit EPERRINTSET14.
	USB_SYSERRINTSET_EPERRINTSET14 = 0x4000
	// Position of EPERRINTSET15 field.
	USB_SYSERRINTSET_EPERRINTSET15_Pos = 0xf
	// Bit mask of EPERRINTSET15 field.
	USB_SYSERRINTSET_EPERRINTSET15_Msk = 0x8000
	// Bit EPERRINTSET15.
	USB_SYSERRINTSET_EPERRINTSET15 = 0x8000
	// Position of EPERRINTSET16 field.
	USB_SYSERRINTSET_EPERRINTSET16_Pos = 0x10
	// Bit mask of EPERRINTSET16 field.
	USB_SYSERRINTSET_EPERRINTSET16_Msk = 0x10000
	// Bit EPERRINTSET16.
	USB_SYSERRINTSET_EPERRINTSET16 = 0x10000
	// Position of EPERRINTSET17 field.
	USB_SYSERRINTSET_EPERRINTSET17_Pos = 0x11
	// Bit mask of EPERRINTSET17 field.
	USB_SYSERRINTSET_EPERRINTSET17_Msk = 0x20000
	// Bit EPERRINTSET17.
	USB_SYSERRINTSET_EPERRINTSET17 = 0x20000
	// Position of EPERRINTSET18 field.
	USB_SYSERRINTSET_EPERRINTSET18_Pos = 0x12
	// Bit mask of EPERRINTSET18 field.
	USB_SYSERRINTSET_EPERRINTSET18_Msk = 0x40000
	// Bit EPERRINTSET18.
	USB_SYSERRINTSET_EPERRINTSET18 = 0x40000
	// Position of EPERRINTSET19 field.
	USB_SYSERRINTSET_EPERRINTSET19_Pos = 0x13
	// Bit mask of EPERRINTSET19 field.
	USB_SYSERRINTSET_EPERRINTSET19_Msk = 0x80000
	// Bit EPERRINTSET19.
	USB_SYSERRINTSET_EPERRINTSET19 = 0x80000
	// Position of EPERRINTSET20 field.
	USB_SYSERRINTSET_EPERRINTSET20_Pos = 0x14
	// Bit mask of EPERRINTSET20 field.
	USB_SYSERRINTSET_EPERRINTSET20_Msk = 0x100000
	// Bit EPERRINTSET20.
	USB_SYSERRINTSET_EPERRINTSET20 = 0x100000
	// Position of EPERRINTSET21 field.
	USB_SYSERRINTSET_EPERRINTSET21_Pos = 0x15
	// Bit mask of EPERRINTSET21 field.
	USB_SYSERRINTSET_EPERRINTSET21_Msk = 0x200000
	// Bit EPERRINTSET21.
	USB_SYSERRINTSET_EPERRINTSET21 = 0x200000
	// Position of EPERRINTSET22 field.
	USB_SYSERRINTSET_EPERRINTSET22_Pos = 0x16
	// Bit mask of EPERRINTSET22 field.
	USB_SYSERRINTSET_EPERRINTSET22_Msk = 0x400000
	// Bit EPERRINTSET22.
	USB_SYSERRINTSET_EPERRINTSET22 = 0x400000
	// Position of EPERRINTSET23 field.
	USB_SYSERRINTSET_EPERRINTSET23_Pos = 0x17
	// Bit mask of EPERRINTSET23 field.
	USB_SYSERRINTSET_EPERRINTSET23_Msk = 0x800000
	// Bit EPERRINTSET23.
	USB_SYSERRINTSET_EPERRINTSET23 = 0x800000
	// Position of EPERRINTSET24 field.
	USB_SYSERRINTSET_EPERRINTSET24_Pos = 0x18
	// Bit mask of EPERRINTSET24 field.
	USB_SYSERRINTSET_EPERRINTSET24_Msk = 0x1000000
	// Bit EPERRINTSET24.
	USB_SYSERRINTSET_EPERRINTSET24 = 0x1000000
	// Position of EPERRINTSET25 field.
	USB_SYSERRINTSET_EPERRINTSET25_Pos = 0x19
	// Bit mask of EPERRINTSET25 field.
	USB_SYSERRINTSET_EPERRINTSET25_Msk = 0x2000000
	// Bit EPERRINTSET25.
	USB_SYSERRINTSET_EPERRINTSET25 = 0x2000000
	// Position of EPERRINTSET26 field.
	USB_SYSERRINTSET_EPERRINTSET26_Pos = 0x1a
	// Bit mask of EPERRINTSET26 field.
	USB_SYSERRINTSET_EPERRINTSET26_Msk = 0x4000000
	// Bit EPERRINTSET26.
	USB_SYSERRINTSET_EPERRINTSET26 = 0x4000000
	// Position of EPERRINTSET27 field.
	USB_SYSERRINTSET_EPERRINTSET27_Pos = 0x1b
	// Bit mask of EPERRINTSET27 field.
	USB_SYSERRINTSET_EPERRINTSET27_Msk = 0x8000000
	// Bit EPERRINTSET27.
	USB_SYSERRINTSET_EPERRINTSET27 = 0x8000000
	// Position of EPERRINTSET28 field.
	USB_SYSERRINTSET_EPERRINTSET28_Pos = 0x1c
	// Bit mask of EPERRINTSET28 field.
	USB_SYSERRINTSET_EPERRINTSET28_Msk = 0x10000000
	// Bit EPERRINTSET28.
	USB_SYSERRINTSET_EPERRINTSET28 = 0x10000000
	// Position of EPERRINTSET29 field.
	USB_SYSERRINTSET_EPERRINTSET29_Pos = 0x1d
	// Bit mask of EPERRINTSET29 field.
	USB_SYSERRINTSET_EPERRINTSET29_Msk = 0x20000000
	// Bit EPERRINTSET29.
	USB_SYSERRINTSET_EPERRINTSET29 = 0x20000000
	// Position of EPERRINTSET30 field.
	USB_SYSERRINTSET_EPERRINTSET30_Pos = 0x1e
	// Bit mask of EPERRINTSET30 field.
	USB_SYSERRINTSET_EPERRINTSET30_Msk = 0x40000000
	// Bit EPERRINTSET30.
	USB_SYSERRINTSET_EPERRINTSET30 = 0x40000000
	// Position of EPERRINTSET31 field.
	USB_SYSERRINTSET_EPERRINTSET31_Pos = 0x1f
	// Bit mask of EPERRINTSET31 field.
	USB_SYSERRINTSET_EPERRINTSET31_Msk = 0x80000000
	// Bit EPERRINTSET31.
	USB_SYSERRINTSET_EPERRINTSET31 = 0x80000000

	// I2C_RX: I2C Receive
	// Position of RX_DATA field.
	USB_I2C_RX_RX_DATA_Pos = 0x0
	// Bit mask of RX_DATA field.
	USB_I2C_RX_RX_DATA_Msk = 0xff
	// Position of RESERVED field.
	USB_I2C_RX_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	USB_I2C_RX_RESERVED_Msk = 0xffffff00

	// I2C_TX: I2C Transmit
	// Position of TXDATA field.
	USB_I2C_TX_TXDATA_Pos = 0x0
	// Bit mask of TXDATA field.
	USB_I2C_TX_TXDATA_Msk = 0xff
	// Position of START field.
	USB_I2C_TX_START_Pos = 0x8
	// Bit mask of START field.
	USB_I2C_TX_START_Msk = 0x100
	// Bit START.
	USB_I2C_TX_START = 0x100
	// Position of STOP field.
	USB_I2C_TX_STOP_Pos = 0x9
	// Bit mask of STOP field.
	USB_I2C_TX_STOP_Msk = 0x200
	// Bit STOP.
	USB_I2C_TX_STOP = 0x200
	// Position of RESERVED field.
	USB_I2C_TX_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	USB_I2C_TX_RESERVED_Msk = 0xfffffc00

	// I2C_STS: I2C Status
	// Position of TDI field.
	USB_I2C_STS_TDI_Pos = 0x0
	// Bit mask of TDI field.
	USB_I2C_STS_TDI_Msk = 0x1
	// Bit TDI.
	USB_I2C_STS_TDI = 0x1
	// Transaction has not completed.
	USB_I2C_STS_TDI_TRANSACTION_HAS_NOT_ = 0x0
	// Transaction completed.
	USB_I2C_STS_TDI_TRANSACTION_COMPLETE = 0x1
	// Position of AFI field.
	USB_I2C_STS_AFI_Pos = 0x1
	// Bit mask of AFI field.
	USB_I2C_STS_AFI_Msk = 0x2
	// Bit AFI.
	USB_I2C_STS_AFI = 0x2
	// No arbitration failure on last transmission.
	USB_I2C_STS_AFI_NO_ARBITRATION_FAILU = 0x0
	// Arbitration failure occurred on last transmission.
	USB_I2C_STS_AFI_ARBITRATION_FAILURE_ = 0x1
	// Position of NAI field.
	USB_I2C_STS_NAI_Pos = 0x2
	// Bit mask of NAI field.
	USB_I2C_STS_NAI_Msk = 0x4
	// Bit NAI.
	USB_I2C_STS_NAI = 0x4
	// Last transmission received an acknowledge.
	USB_I2C_STS_NAI_LAST_TRANSMISSION_RE = 0x0
	// Last transmission did not receive an acknowledge.
	USB_I2C_STS_NAI_LAST_TRANSMISSION_DI = 0x1
	// Position of DRMI field.
	USB_I2C_STS_DRMI_Pos = 0x3
	// Bit mask of DRMI field.
	USB_I2C_STS_DRMI_Msk = 0x8
	// Bit DRMI.
	USB_I2C_STS_DRMI = 0x8
	// Master transmitter does not need data.
	USB_I2C_STS_DRMI_MASTER_TRANSMITTER_D = 0x0
	// Master transmitter needs data.
	USB_I2C_STS_DRMI_MASTER_TRANSMITTER_N = 0x1
	// Position of DRSI field.
	USB_I2C_STS_DRSI_Pos = 0x4
	// Bit mask of DRSI field.
	USB_I2C_STS_DRSI_Msk = 0x10
	// Bit DRSI.
	USB_I2C_STS_DRSI = 0x10
	// Slave transmitter does not need data.
	USB_I2C_STS_DRSI_SLAVE_TRANSMITTER_DO = 0x0
	// Slave transmitter needs data.
	USB_I2C_STS_DRSI_SLAVE_TRANSMITTER_NE = 0x1
	// Position of Active field.
	USB_I2C_STS_Active_Pos = 0x5
	// Bit mask of Active field.
	USB_I2C_STS_Active_Msk = 0x20
	// Bit Active.
	USB_I2C_STS_Active = 0x20
	// Position of SCL field.
	USB_I2C_STS_SCL_Pos = 0x6
	// Bit mask of SCL field.
	USB_I2C_STS_SCL_Msk = 0x40
	// Bit SCL.
	USB_I2C_STS_SCL = 0x40
	// Position of SDA field.
	USB_I2C_STS_SDA_Pos = 0x7
	// Bit mask of SDA field.
	USB_I2C_STS_SDA_Msk = 0x80
	// Bit SDA.
	USB_I2C_STS_SDA = 0x80
	// Position of RFF field.
	USB_I2C_STS_RFF_Pos = 0x8
	// Bit mask of RFF field.
	USB_I2C_STS_RFF_Msk = 0x100
	// Bit RFF.
	USB_I2C_STS_RFF = 0x100
	// RX FIFO is not full
	USB_I2C_STS_RFF_RX_FIFO_IS_NOT_FULL = 0x0
	// RX FIFO is full
	USB_I2C_STS_RFF_RX_FIFO_IS_FULL = 0x1
	// Position of RFE field.
	USB_I2C_STS_RFE_Pos = 0x9
	// Bit mask of RFE field.
	USB_I2C_STS_RFE_Msk = 0x200
	// Bit RFE.
	USB_I2C_STS_RFE = 0x200
	// RX FIFO contains data.
	USB_I2C_STS_RFE_RX_FIFO_CONTAINS_DAT = 0x0
	// RX FIFO is empty
	USB_I2C_STS_RFE_RX_FIFO_IS_EMPTY = 0x1
	// Position of TFF field.
	USB_I2C_STS_TFF_Pos = 0xa
	// Bit mask of TFF field.
	USB_I2C_STS_TFF_Msk = 0x400
	// Bit TFF.
	USB_I2C_STS_TFF = 0x400
	// TX FIFO is not full.
	USB_I2C_STS_TFF_TX_FIFO_IS_NOT_FULL_ = 0x0
	// TX FIFO is full
	USB_I2C_STS_TFF_TX_FIFO_IS_FULL = 0x1
	// Position of TFE field.
	USB_I2C_STS_TFE_Pos = 0xb
	// Bit mask of TFE field.
	USB_I2C_STS_TFE_Msk = 0x800
	// Bit TFE.
	USB_I2C_STS_TFE = 0x800
	// TX FIFO contains valid data.
	USB_I2C_STS_TFE_TX_FIFO_CONTAINS_VAL = 0x0
	// TX FIFO is empty
	USB_I2C_STS_TFE_TX_FIFO_IS_EMPTY = 0x1
	// Position of RESERVED field.
	USB_I2C_STS_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	USB_I2C_STS_RESERVED_Msk = 0xfffff000

	// I2C_CTL: I2C Control
	// Position of TDIE field.
	USB_I2C_CTL_TDIE_Pos = 0x0
	// Bit mask of TDIE field.
	USB_I2C_CTL_TDIE_Msk = 0x1
	// Bit TDIE.
	USB_I2C_CTL_TDIE = 0x1
	// Disable the TDI interrupt.
	USB_I2C_CTL_TDIE_DISABLE_THE_TDI_INTE = 0x0
	// Enable the TDI interrupt.
	USB_I2C_CTL_TDIE_ENABLE_THE_TDI_INTER = 0x1
	// Position of AFIE field.
	USB_I2C_CTL_AFIE_Pos = 0x1
	// Bit mask of AFIE field.
	USB_I2C_CTL_AFIE_Msk = 0x2
	// Bit AFIE.
	USB_I2C_CTL_AFIE = 0x2
	// Disable the AFI.
	USB_I2C_CTL_AFIE_DISABLE_THE_AFI_ = 0x0
	// Enable the AFI.
	USB_I2C_CTL_AFIE_ENABLE_THE_AFI_ = 0x1
	// Position of NAIE field.
	USB_I2C_CTL_NAIE_Pos = 0x2
	// Bit mask of NAIE field.
	USB_I2C_CTL_NAIE_Msk = 0x4
	// Bit NAIE.
	USB_I2C_CTL_NAIE = 0x4
	// Disable the NAI.
	USB_I2C_CTL_NAIE_DISABLE_THE_NAI_ = 0x0
	// Enable the NAI.
	USB_I2C_CTL_NAIE_ENABLE_THE_NAI_ = 0x1
	// Position of DRMIE field.
	USB_I2C_CTL_DRMIE_Pos = 0x3
	// Bit mask of DRMIE field.
	USB_I2C_CTL_DRMIE_Msk = 0x8
	// Bit DRMIE.
	USB_I2C_CTL_DRMIE = 0x8
	// Disable the DRMI interrupt.
	USB_I2C_CTL_DRMIE_DISABLE_THE_DRMI_INT = 0x0
	// Enable the DRMI interrupt.
	USB_I2C_CTL_DRMIE_ENABLE_THE_DRMI_INTE = 0x1
	// Position of DRSIE field.
	USB_I2C_CTL_DRSIE_Pos = 0x4
	// Bit mask of DRSIE field.
	USB_I2C_CTL_DRSIE_Msk = 0x10
	// Bit DRSIE.
	USB_I2C_CTL_DRSIE = 0x10
	// Disable the DRSI interrupt.
	USB_I2C_CTL_DRSIE_DISABLE_THE_DRSI_INT = 0x0
	// Enable the DRSI interrupt.
	USB_I2C_CTL_DRSIE_ENABLE_THE_DRSI_INTE = 0x1
	// Position of REFIE field.
	USB_I2C_CTL_REFIE_Pos = 0x5
	// Bit mask of REFIE field.
	USB_I2C_CTL_REFIE_Msk = 0x20
	// Bit REFIE.
	USB_I2C_CTL_REFIE = 0x20
	// Disable the RFFI.
	USB_I2C_CTL_REFIE_DISABLE_THE_RFFI_ = 0x0
	// Enable the RFFI.
	USB_I2C_CTL_REFIE_ENABLE_THE_RFFI_ = 0x1
	// Position of RFDAIE field.
	USB_I2C_CTL_RFDAIE_Pos = 0x6
	// Bit mask of RFDAIE field.
	USB_I2C_CTL_RFDAIE_Msk = 0x40
	// Bit RFDAIE.
	USB_I2C_CTL_RFDAIE = 0x40
	// Disable the DAI.
	USB_I2C_CTL_RFDAIE_DISABLE_THE_DAI_ = 0x0
	// Enable the DAI.
	USB_I2C_CTL_RFDAIE_ENABLE_THE_DAI_ = 0x1
	// Position of TFFIE field.
	USB_I2C_CTL_TFFIE_Pos = 0x7
	// Bit mask of TFFIE field.
	USB_I2C_CTL_TFFIE_Msk = 0x80
	// Bit TFFIE.
	USB_I2C_CTL_TFFIE = 0x80
	// Disable the TFFI.
	USB_I2C_CTL_TFFIE_DISABLE_THE_TFFI_ = 0x0
	// Enable the TFFI.
	USB_I2C_CTL_TFFIE_ENABLE_THE_TFFI_ = 0x1
	// Position of SRST field.
	USB_I2C_CTL_SRST_Pos = 0x8
	// Bit mask of SRST field.
	USB_I2C_CTL_SRST_Msk = 0x100
	// Bit SRST.
	USB_I2C_CTL_SRST = 0x100
	// See the text.
	USB_I2C_CTL_SRST_SEE_THE_TEXT_ = 0x0
	// Reset the I2C to idle state. Self clearing.
	USB_I2C_CTL_SRST_RESET_THE_I2C_TO_IDL = 0x1
	// Position of RESERVED field.
	USB_I2C_CTL_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	USB_I2C_CTL_RESERVED_Msk = 0xfffffe00

	// I2C_CLKHI: I2C Clock High
	// Position of CDHI field.
	USB_I2C_CLKHI_CDHI_Pos = 0x0
	// Bit mask of CDHI field.
	USB_I2C_CLKHI_CDHI_Msk = 0xff
	// Position of RESERVED field.
	USB_I2C_CLKHI_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	USB_I2C_CLKHI_RESERVED_Msk = 0xffffff00

	// I2C_CLKLO: I2C Clock Low
	// Position of CDLO field.
	USB_I2C_CLKLO_CDLO_Pos = 0x0
	// Bit mask of CDLO field.
	USB_I2C_CLKLO_CDLO_Msk = 0xff
	// Position of RESERVED field.
	USB_I2C_CLKLO_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	USB_I2C_CLKLO_RESERVED_Msk = 0xffffff00

	// CLKCTRL: OTG clock controller
	// Position of HOST_CLK_EN field.
	USB_CLKCTRL_HOST_CLK_EN_Pos = 0x0
	// Bit mask of HOST_CLK_EN field.
	USB_CLKCTRL_HOST_CLK_EN_Msk = 0x1
	// Bit HOST_CLK_EN.
	USB_CLKCTRL_HOST_CLK_EN = 0x1
	// Disable the Host clock.
	USB_CLKCTRL_HOST_CLK_EN_DISABLE_THE_HOST_CLO = 0x0
	// Enable the Host clock.
	USB_CLKCTRL_HOST_CLK_EN_ENABLE_THE_HOST_CLOC = 0x1
	// Position of DEV_CLK_EN field.
	USB_CLKCTRL_DEV_CLK_EN_Pos = 0x1
	// Bit mask of DEV_CLK_EN field.
	USB_CLKCTRL_DEV_CLK_EN_Msk = 0x2
	// Bit DEV_CLK_EN.
	USB_CLKCTRL_DEV_CLK_EN = 0x2
	// Disable the Device clock.
	USB_CLKCTRL_DEV_CLK_EN_DISABLE_THE_DEVICE_C = 0x0
	// Enable the Device clock.
	USB_CLKCTRL_DEV_CLK_EN_ENABLE_THE_DEVICE_CL = 0x1
	// Position of I2C_CLK_EN field.
	USB_CLKCTRL_I2C_CLK_EN_Pos = 0x2
	// Bit mask of I2C_CLK_EN field.
	USB_CLKCTRL_I2C_CLK_EN_Msk = 0x4
	// Bit I2C_CLK_EN.
	USB_CLKCTRL_I2C_CLK_EN = 0x4
	// Disable the I2C clock.
	USB_CLKCTRL_I2C_CLK_EN_DISABLE_THE_I2C_CLOC = 0x0
	// Enable the I2C clock.
	USB_CLKCTRL_I2C_CLK_EN_ENABLE_THE_I2C_CLOCK = 0x1
	// Position of OTG_CLK_EN field.
	USB_CLKCTRL_OTG_CLK_EN_Pos = 0x3
	// Bit mask of OTG_CLK_EN field.
	USB_CLKCTRL_OTG_CLK_EN_Msk = 0x8
	// Bit OTG_CLK_EN.
	USB_CLKCTRL_OTG_CLK_EN = 0x8
	// Disable the OTG clock.
	USB_CLKCTRL_OTG_CLK_EN_DISABLE_THE_OTG_CLOC = 0x0
	// Enable the OTG clock.
	USB_CLKCTRL_OTG_CLK_EN_ENABLE_THE_OTG_CLOCK = 0x1
	// Position of AHB_CLK_EN field.
	USB_CLKCTRL_AHB_CLK_EN_Pos = 0x4
	// Bit mask of AHB_CLK_EN field.
	USB_CLKCTRL_AHB_CLK_EN_Msk = 0x10
	// Bit AHB_CLK_EN.
	USB_CLKCTRL_AHB_CLK_EN = 0x10
	// Disable the AHB clock.
	USB_CLKCTRL_AHB_CLK_EN_DISABLE_THE_AHB_CLOC = 0x0
	// Enable the AHB clock.
	USB_CLKCTRL_AHB_CLK_EN_ENABLE_THE_AHB_CLOCK = 0x1
	// Position of RESERVED field.
	USB_CLKCTRL_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	USB_CLKCTRL_RESERVED_Msk = 0xffffffe0

	// OTGClkSt: OTG clock status
	// Position of HOST_CLK_ON field.
	USB_OTGClkSt_HOST_CLK_ON_Pos = 0x0
	// Bit mask of HOST_CLK_ON field.
	USB_OTGClkSt_HOST_CLK_ON_Msk = 0x1
	// Bit HOST_CLK_ON.
	USB_OTGClkSt_HOST_CLK_ON = 0x1
	// Host clock is not available.
	USB_OTGClkSt_HOST_CLK_ON_HOST_CLOCK_IS_NOT_AV = 0x0
	// Host clock is available.
	USB_OTGClkSt_HOST_CLK_ON_HOST_CLOCK_IS_AVAILA = 0x1
	// Position of DEV_CLK_ON field.
	USB_OTGClkSt_DEV_CLK_ON_Pos = 0x1
	// Bit mask of DEV_CLK_ON field.
	USB_OTGClkSt_DEV_CLK_ON_Msk = 0x2
	// Bit DEV_CLK_ON.
	USB_OTGClkSt_DEV_CLK_ON = 0x2
	// Device clock is not available.
	USB_OTGClkSt_DEV_CLK_ON_DEVICE_CLOCK_IS_NOT_ = 0x0
	// Device clock is available.
	USB_OTGClkSt_DEV_CLK_ON_DEVICE_CLOCK_IS_AVAI = 0x1
	// Position of I2C_CLK_ON field.
	USB_OTGClkSt_I2C_CLK_ON_Pos = 0x2
	// Bit mask of I2C_CLK_ON field.
	USB_OTGClkSt_I2C_CLK_ON_Msk = 0x4
	// Bit I2C_CLK_ON.
	USB_OTGClkSt_I2C_CLK_ON = 0x4
	// I2C clock is not available.
	USB_OTGClkSt_I2C_CLK_ON_I2C_CLOCK_IS_NOT_AVA = 0x0
	// I2C clock is available.
	USB_OTGClkSt_I2C_CLK_ON_I2C_CLOCK_IS_AVAILAB = 0x1
	// Position of OTG_CLK_ON field.
	USB_OTGClkSt_OTG_CLK_ON_Pos = 0x3
	// Bit mask of OTG_CLK_ON field.
	USB_OTGClkSt_OTG_CLK_ON_Msk = 0x8
	// Bit OTG_CLK_ON.
	USB_OTGClkSt_OTG_CLK_ON = 0x8
	// OTG clock is not available.
	USB_OTGClkSt_OTG_CLK_ON_OTG_CLOCK_IS_NOT_AVA = 0x0
	// OTG clock is available.
	USB_OTGClkSt_OTG_CLK_ON_OTG_CLOCK_IS_AVAILAB = 0x1
	// Position of AHB_CLK_ON field.
	USB_OTGClkSt_AHB_CLK_ON_Pos = 0x4
	// Bit mask of AHB_CLK_ON field.
	USB_OTGClkSt_AHB_CLK_ON_Msk = 0x10
	// Bit AHB_CLK_ON.
	USB_OTGClkSt_AHB_CLK_ON = 0x10
	// AHB clock is not available.
	USB_OTGClkSt_AHB_CLK_ON_AHB_CLOCK_IS_NOT_AVA = 0x0
	// AHB clock is available.
	USB_OTGClkSt_AHB_CLK_ON_AHB_CLOCK_IS_AVAILAB = 0x1
	// Position of RESERVED field.
	USB_OTGClkSt_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	USB_OTGClkSt_RESERVED_Msk = 0xffffffe0
)

// Constants for CRC: CRC engine
const (
	// MODE: CRC mode register
	// Position of CRC_POLY field.
	CRC_MODE_CRC_POLY_Pos = 0x0
	// Bit mask of CRC_POLY field.
	CRC_MODE_CRC_POLY_Msk = 0x3
	// CRC-CCITT polynomial
	CRC_MODE_CRC_POLY_CRC_CCITT_POLYNOMIAL = 0x0
	// CRC-16 polynomial
	CRC_MODE_CRC_POLY_CRC_16_POLYNOMIAL = 0x1
	// CRC-32 polynomial
	CRC_MODE_CRC_POLY_CRC_32_POLYNOMIAL = 0x2
	// Position of BIT_RVS_WR field.
	CRC_MODE_BIT_RVS_WR_Pos = 0x2
	// Bit mask of BIT_RVS_WR field.
	CRC_MODE_BIT_RVS_WR_Msk = 0x4
	// Bit BIT_RVS_WR.
	CRC_MODE_BIT_RVS_WR = 0x4
	// No bit order reverse for CRC_WR_DATA (per byte)
	CRC_MODE_BIT_RVS_WR_NO_BIT_ORDER_REVERSE = 0x0
	// Bit order reverse for CRC_WR_DATA (per byte)
	CRC_MODE_BIT_RVS_WR_BIT_ORDER_REVERSE_FO = 0x1
	// Position of CMPL_WR field.
	CRC_MODE_CMPL_WR_Pos = 0x3
	// Bit mask of CMPL_WR field.
	CRC_MODE_CMPL_WR_Msk = 0x8
	// Bit CMPL_WR.
	CRC_MODE_CMPL_WR = 0x8
	// No one's complement for CRC_WR_DATA
	CRC_MODE_CMPL_WR_NO_ONES_COMPLEMENT_ = 0x0
	// One's complement for CRC_WR_DATA
	CRC_MODE_CMPL_WR_ONES_COMPLEMENT_FOR = 0x1
	// Position of BIT_RVS_SUM field.
	CRC_MODE_BIT_RVS_SUM_Pos = 0x4
	// Bit mask of BIT_RVS_SUM field.
	CRC_MODE_BIT_RVS_SUM_Msk = 0x10
	// Bit BIT_RVS_SUM.
	CRC_MODE_BIT_RVS_SUM = 0x10
	// No bit order reverse for CRC_SUM
	CRC_MODE_BIT_RVS_SUM_NO_BIT_ORDER_REVERSE = 0x0
	// Bit order reverse for CRC_SUM
	CRC_MODE_BIT_RVS_SUM_BIT_ORDER_REVERSE_FO = 0x1
	// Position of CMPL_SUM field.
	CRC_MODE_CMPL_SUM_Pos = 0x5
	// Bit mask of CMPL_SUM field.
	CRC_MODE_CMPL_SUM_Msk = 0x20
	// Bit CMPL_SUM.
	CRC_MODE_CMPL_SUM = 0x20
	// No one's complement for CRC_SUM
	CRC_MODE_CMPL_SUM_NO_ONES_COMPLEMENT_ = 0x0
	// One's complement for CRC_SUM
	CRC_MODE_CMPL_SUM_ONES_COMPLEMENT_FOR = 0x1
	// Position of Reserved field.
	CRC_MODE_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	CRC_MODE_Reserved_Msk = 0xffffffc0

	// SEED: CRC seed register
	// Position of CRC_SEED field.
	CRC_SEED_CRC_SEED_Pos = 0x0
	// Bit mask of CRC_SEED field.
	CRC_SEED_CRC_SEED_Msk = 0xffffffff

	// SUM: CRC checksum register
	// Position of CRC_SUM field.
	CRC_SUM_CRC_SUM_Pos = 0x0
	// Bit mask of CRC_SUM field.
	CRC_SUM_CRC_SUM_Msk = 0xffffffff

	// DATA: CRC data register
	// Position of CRC_WR_DATA field.
	CRC_DATA_CRC_WR_DATA_Pos = 0x0
	// Bit mask of CRC_WR_DATA field.
	CRC_DATA_CRC_WR_DATA_Msk = 0xffffffff
)

// Constants for GPIO: GPIO
const (
	// DIR0: GPIO Port Direction control register.
	// Position of PDIR0 field.
	GPIO_DIR_PDIR0_Pos = 0x0
	// Bit mask of PDIR0 field.
	GPIO_DIR_PDIR0_Msk = 0x1
	// Bit PDIR0.
	GPIO_DIR_PDIR0 = 0x1
	// Position of PDIR1 field.
	GPIO_DIR_PDIR1_Pos = 0x1
	// Bit mask of PDIR1 field.
	GPIO_DIR_PDIR1_Msk = 0x2
	// Bit PDIR1.
	GPIO_DIR_PDIR1 = 0x2
	// Position of PDIR2 field.
	GPIO_DIR_PDIR2_Pos = 0x2
	// Bit mask of PDIR2 field.
	GPIO_DIR_PDIR2_Msk = 0x4
	// Bit PDIR2.
	GPIO_DIR_PDIR2 = 0x4
	// Position of PDIR3 field.
	GPIO_DIR_PDIR3_Pos = 0x3
	// Bit mask of PDIR3 field.
	GPIO_DIR_PDIR3_Msk = 0x8
	// Bit PDIR3.
	GPIO_DIR_PDIR3 = 0x8
	// Position of PDIR4 field.
	GPIO_DIR_PDIR4_Pos = 0x4
	// Bit mask of PDIR4 field.
	GPIO_DIR_PDIR4_Msk = 0x10
	// Bit PDIR4.
	GPIO_DIR_PDIR4 = 0x10
	// Position of PDIR5 field.
	GPIO_DIR_PDIR5_Pos = 0x5
	// Bit mask of PDIR5 field.
	GPIO_DIR_PDIR5_Msk = 0x20
	// Bit PDIR5.
	GPIO_DIR_PDIR5 = 0x20
	// Position of PDIR6 field.
	GPIO_DIR_PDIR6_Pos = 0x6
	// Bit mask of PDIR6 field.
	GPIO_DIR_PDIR6_Msk = 0x40
	// Bit PDIR6.
	GPIO_DIR_PDIR6 = 0x40
	// Position of PDIR7 field.
	GPIO_DIR_PDIR7_Pos = 0x7
	// Bit mask of PDIR7 field.
	GPIO_DIR_PDIR7_Msk = 0x80
	// Bit PDIR7.
	GPIO_DIR_PDIR7 = 0x80
	// Position of PDIR8 field.
	GPIO_DIR_PDIR8_Pos = 0x8
	// Bit mask of PDIR8 field.
	GPIO_DIR_PDIR8_Msk = 0x100
	// Bit PDIR8.
	GPIO_DIR_PDIR8 = 0x100
	// Position of PDIR9 field.
	GPIO_DIR_PDIR9_Pos = 0x9
	// Bit mask of PDIR9 field.
	GPIO_DIR_PDIR9_Msk = 0x200
	// Bit PDIR9.
	GPIO_DIR_PDIR9 = 0x200
	// Position of PDIR10 field.
	GPIO_DIR_PDIR10_Pos = 0xa
	// Bit mask of PDIR10 field.
	GPIO_DIR_PDIR10_Msk = 0x400
	// Bit PDIR10.
	GPIO_DIR_PDIR10 = 0x400
	// Position of PDIR11 field.
	GPIO_DIR_PDIR11_Pos = 0xb
	// Bit mask of PDIR11 field.
	GPIO_DIR_PDIR11_Msk = 0x800
	// Bit PDIR11.
	GPIO_DIR_PDIR11 = 0x800
	// Position of PDIR12 field.
	GPIO_DIR_PDIR12_Pos = 0xc
	// Bit mask of PDIR12 field.
	GPIO_DIR_PDIR12_Msk = 0x1000
	// Bit PDIR12.
	GPIO_DIR_PDIR12 = 0x1000
	// Position of PDIR13 field.
	GPIO_DIR_PDIR13_Pos = 0xd
	// Bit mask of PDIR13 field.
	GPIO_DIR_PDIR13_Msk = 0x2000
	// Bit PDIR13.
	GPIO_DIR_PDIR13 = 0x2000
	// Position of PDIR14 field.
	GPIO_DIR_PDIR14_Pos = 0xe
	// Bit mask of PDIR14 field.
	GPIO_DIR_PDIR14_Msk = 0x4000
	// Bit PDIR14.
	GPIO_DIR_PDIR14 = 0x4000
	// Position of PDIR15 field.
	GPIO_DIR_PDIR15_Pos = 0xf
	// Bit mask of PDIR15 field.
	GPIO_DIR_PDIR15_Msk = 0x8000
	// Bit PDIR15.
	GPIO_DIR_PDIR15 = 0x8000
	// Position of PDIR16 field.
	GPIO_DIR_PDIR16_Pos = 0x10
	// Bit mask of PDIR16 field.
	GPIO_DIR_PDIR16_Msk = 0x10000
	// Bit PDIR16.
	GPIO_DIR_PDIR16 = 0x10000
	// Position of PDIR17 field.
	GPIO_DIR_PDIR17_Pos = 0x11
	// Bit mask of PDIR17 field.
	GPIO_DIR_PDIR17_Msk = 0x20000
	// Bit PDIR17.
	GPIO_DIR_PDIR17 = 0x20000
	// Position of PDIR18 field.
	GPIO_DIR_PDIR18_Pos = 0x12
	// Bit mask of PDIR18 field.
	GPIO_DIR_PDIR18_Msk = 0x40000
	// Bit PDIR18.
	GPIO_DIR_PDIR18 = 0x40000
	// Position of PDIR19 field.
	GPIO_DIR_PDIR19_Pos = 0x13
	// Bit mask of PDIR19 field.
	GPIO_DIR_PDIR19_Msk = 0x80000
	// Bit PDIR19.
	GPIO_DIR_PDIR19 = 0x80000
	// Position of PDIR20 field.
	GPIO_DIR_PDIR20_Pos = 0x14
	// Bit mask of PDIR20 field.
	GPIO_DIR_PDIR20_Msk = 0x100000
	// Bit PDIR20.
	GPIO_DIR_PDIR20 = 0x100000
	// Position of PDIR21 field.
	GPIO_DIR_PDIR21_Pos = 0x15
	// Bit mask of PDIR21 field.
	GPIO_DIR_PDIR21_Msk = 0x200000
	// Bit PDIR21.
	GPIO_DIR_PDIR21 = 0x200000
	// Position of PDIR22 field.
	GPIO_DIR_PDIR22_Pos = 0x16
	// Bit mask of PDIR22 field.
	GPIO_DIR_PDIR22_Msk = 0x400000
	// Bit PDIR22.
	GPIO_DIR_PDIR22 = 0x400000
	// Position of PDIR23 field.
	GPIO_DIR_PDIR23_Pos = 0x17
	// Bit mask of PDIR23 field.
	GPIO_DIR_PDIR23_Msk = 0x800000
	// Bit PDIR23.
	GPIO_DIR_PDIR23 = 0x800000
	// Position of PDIR24 field.
	GPIO_DIR_PDIR24_Pos = 0x18
	// Bit mask of PDIR24 field.
	GPIO_DIR_PDIR24_Msk = 0x1000000
	// Bit PDIR24.
	GPIO_DIR_PDIR24 = 0x1000000
	// Position of PDIR25 field.
	GPIO_DIR_PDIR25_Pos = 0x19
	// Bit mask of PDIR25 field.
	GPIO_DIR_PDIR25_Msk = 0x2000000
	// Bit PDIR25.
	GPIO_DIR_PDIR25 = 0x2000000
	// Position of PDIR26 field.
	GPIO_DIR_PDIR26_Pos = 0x1a
	// Bit mask of PDIR26 field.
	GPIO_DIR_PDIR26_Msk = 0x4000000
	// Bit PDIR26.
	GPIO_DIR_PDIR26 = 0x4000000
	// Position of PDIR27 field.
	GPIO_DIR_PDIR27_Pos = 0x1b
	// Bit mask of PDIR27 field.
	GPIO_DIR_PDIR27_Msk = 0x8000000
	// Bit PDIR27.
	GPIO_DIR_PDIR27 = 0x8000000
	// Position of PDIR28 field.
	GPIO_DIR_PDIR28_Pos = 0x1c
	// Bit mask of PDIR28 field.
	GPIO_DIR_PDIR28_Msk = 0x10000000
	// Bit PDIR28.
	GPIO_DIR_PDIR28 = 0x10000000
	// Position of PDIR29 field.
	GPIO_DIR_PDIR29_Pos = 0x1d
	// Bit mask of PDIR29 field.
	GPIO_DIR_PDIR29_Msk = 0x20000000
	// Bit PDIR29.
	GPIO_DIR_PDIR29 = 0x20000000
	// Position of PDIR30 field.
	GPIO_DIR_PDIR30_Pos = 0x1e
	// Bit mask of PDIR30 field.
	GPIO_DIR_PDIR30_Msk = 0x40000000
	// Bit PDIR30.
	GPIO_DIR_PDIR30 = 0x40000000
	// Position of PDIR31 field.
	GPIO_DIR_PDIR31_Pos = 0x1f
	// Bit mask of PDIR31 field.
	GPIO_DIR_PDIR31_Msk = 0x80000000
	// Bit PDIR31.
	GPIO_DIR_PDIR31 = 0x80000000

	// MASK0: Mask register for Port.
	// Position of PMASK0 field.
	GPIO_MASK_PMASK0_Pos = 0x0
	// Bit mask of PMASK0 field.
	GPIO_MASK_PMASK0_Msk = 0x1
	// Bit PMASK0.
	GPIO_MASK_PMASK0 = 0x1
	// Position of PMASK1 field.
	GPIO_MASK_PMASK1_Pos = 0x1
	// Bit mask of PMASK1 field.
	GPIO_MASK_PMASK1_Msk = 0x2
	// Bit PMASK1.
	GPIO_MASK_PMASK1 = 0x2
	// Position of PMASK2 field.
	GPIO_MASK_PMASK2_Pos = 0x2
	// Bit mask of PMASK2 field.
	GPIO_MASK_PMASK2_Msk = 0x4
	// Bit PMASK2.
	GPIO_MASK_PMASK2 = 0x4
	// Position of PMASK3 field.
	GPIO_MASK_PMASK3_Pos = 0x3
	// Bit mask of PMASK3 field.
	GPIO_MASK_PMASK3_Msk = 0x8
	// Bit PMASK3.
	GPIO_MASK_PMASK3 = 0x8
	// Position of PMASK4 field.
	GPIO_MASK_PMASK4_Pos = 0x4
	// Bit mask of PMASK4 field.
	GPIO_MASK_PMASK4_Msk = 0x10
	// Bit PMASK4.
	GPIO_MASK_PMASK4 = 0x10
	// Position of PMASK5 field.
	GPIO_MASK_PMASK5_Pos = 0x5
	// Bit mask of PMASK5 field.
	GPIO_MASK_PMASK5_Msk = 0x20
	// Bit PMASK5.
	GPIO_MASK_PMASK5 = 0x20
	// Position of PMASK6 field.
	GPIO_MASK_PMASK6_Pos = 0x6
	// Bit mask of PMASK6 field.
	GPIO_MASK_PMASK6_Msk = 0x40
	// Bit PMASK6.
	GPIO_MASK_PMASK6 = 0x40
	// Position of PMASK7 field.
	GPIO_MASK_PMASK7_Pos = 0x7
	// Bit mask of PMASK7 field.
	GPIO_MASK_PMASK7_Msk = 0x80
	// Bit PMASK7.
	GPIO_MASK_PMASK7 = 0x80
	// Position of PMASK8 field.
	GPIO_MASK_PMASK8_Pos = 0x8
	// Bit mask of PMASK8 field.
	GPIO_MASK_PMASK8_Msk = 0x100
	// Bit PMASK8.
	GPIO_MASK_PMASK8 = 0x100
	// Position of PMASK9 field.
	GPIO_MASK_PMASK9_Pos = 0x9
	// Bit mask of PMASK9 field.
	GPIO_MASK_PMASK9_Msk = 0x200
	// Bit PMASK9.
	GPIO_MASK_PMASK9 = 0x200
	// Position of PMASK10 field.
	GPIO_MASK_PMASK10_Pos = 0xa
	// Bit mask of PMASK10 field.
	GPIO_MASK_PMASK10_Msk = 0x400
	// Bit PMASK10.
	GPIO_MASK_PMASK10 = 0x400
	// Position of PMASK11 field.
	GPIO_MASK_PMASK11_Pos = 0xb
	// Bit mask of PMASK11 field.
	GPIO_MASK_PMASK11_Msk = 0x800
	// Bit PMASK11.
	GPIO_MASK_PMASK11 = 0x800
	// Position of PMASK12 field.
	GPIO_MASK_PMASK12_Pos = 0xc
	// Bit mask of PMASK12 field.
	GPIO_MASK_PMASK12_Msk = 0x1000
	// Bit PMASK12.
	GPIO_MASK_PMASK12 = 0x1000
	// Position of PMASK13 field.
	GPIO_MASK_PMASK13_Pos = 0xd
	// Bit mask of PMASK13 field.
	GPIO_MASK_PMASK13_Msk = 0x2000
	// Bit PMASK13.
	GPIO_MASK_PMASK13 = 0x2000
	// Position of PMASK14 field.
	GPIO_MASK_PMASK14_Pos = 0xe
	// Bit mask of PMASK14 field.
	GPIO_MASK_PMASK14_Msk = 0x4000
	// Bit PMASK14.
	GPIO_MASK_PMASK14 = 0x4000
	// Position of PMASK15 field.
	GPIO_MASK_PMASK15_Pos = 0xf
	// Bit mask of PMASK15 field.
	GPIO_MASK_PMASK15_Msk = 0x8000
	// Bit PMASK15.
	GPIO_MASK_PMASK15 = 0x8000
	// Position of PMASK16 field.
	GPIO_MASK_PMASK16_Pos = 0x10
	// Bit mask of PMASK16 field.
	GPIO_MASK_PMASK16_Msk = 0x10000
	// Bit PMASK16.
	GPIO_MASK_PMASK16 = 0x10000
	// Position of PMASK17 field.
	GPIO_MASK_PMASK17_Pos = 0x11
	// Bit mask of PMASK17 field.
	GPIO_MASK_PMASK17_Msk = 0x20000
	// Bit PMASK17.
	GPIO_MASK_PMASK17 = 0x20000
	// Position of PMASK18 field.
	GPIO_MASK_PMASK18_Pos = 0x12
	// Bit mask of PMASK18 field.
	GPIO_MASK_PMASK18_Msk = 0x40000
	// Bit PMASK18.
	GPIO_MASK_PMASK18 = 0x40000
	// Position of PMASK19 field.
	GPIO_MASK_PMASK19_Pos = 0x13
	// Bit mask of PMASK19 field.
	GPIO_MASK_PMASK19_Msk = 0x80000
	// Bit PMASK19.
	GPIO_MASK_PMASK19 = 0x80000
	// Position of PMASK20 field.
	GPIO_MASK_PMASK20_Pos = 0x14
	// Bit mask of PMASK20 field.
	GPIO_MASK_PMASK20_Msk = 0x100000
	// Bit PMASK20.
	GPIO_MASK_PMASK20 = 0x100000
	// Position of PMASK21 field.
	GPIO_MASK_PMASK21_Pos = 0x15
	// Bit mask of PMASK21 field.
	GPIO_MASK_PMASK21_Msk = 0x200000
	// Bit PMASK21.
	GPIO_MASK_PMASK21 = 0x200000
	// Position of PMASK22 field.
	GPIO_MASK_PMASK22_Pos = 0x16
	// Bit mask of PMASK22 field.
	GPIO_MASK_PMASK22_Msk = 0x400000
	// Bit PMASK22.
	GPIO_MASK_PMASK22 = 0x400000
	// Position of PMASK23 field.
	GPIO_MASK_PMASK23_Pos = 0x17
	// Bit mask of PMASK23 field.
	GPIO_MASK_PMASK23_Msk = 0x800000
	// Bit PMASK23.
	GPIO_MASK_PMASK23 = 0x800000
	// Position of PMASK24 field.
	GPIO_MASK_PMASK24_Pos = 0x18
	// Bit mask of PMASK24 field.
	GPIO_MASK_PMASK24_Msk = 0x1000000
	// Bit PMASK24.
	GPIO_MASK_PMASK24 = 0x1000000
	// Position of PMASK25 field.
	GPIO_MASK_PMASK25_Pos = 0x19
	// Bit mask of PMASK25 field.
	GPIO_MASK_PMASK25_Msk = 0x2000000
	// Bit PMASK25.
	GPIO_MASK_PMASK25 = 0x2000000
	// Position of PMASK26 field.
	GPIO_MASK_PMASK26_Pos = 0x1a
	// Bit mask of PMASK26 field.
	GPIO_MASK_PMASK26_Msk = 0x4000000
	// Bit PMASK26.
	GPIO_MASK_PMASK26 = 0x4000000
	// Position of PMASK27 field.
	GPIO_MASK_PMASK27_Pos = 0x1b
	// Bit mask of PMASK27 field.
	GPIO_MASK_PMASK27_Msk = 0x8000000
	// Bit PMASK27.
	GPIO_MASK_PMASK27 = 0x8000000
	// Position of PMASK28 field.
	GPIO_MASK_PMASK28_Pos = 0x1c
	// Bit mask of PMASK28 field.
	GPIO_MASK_PMASK28_Msk = 0x10000000
	// Bit PMASK28.
	GPIO_MASK_PMASK28 = 0x10000000
	// Position of PMASK29 field.
	GPIO_MASK_PMASK29_Pos = 0x1d
	// Bit mask of PMASK29 field.
	GPIO_MASK_PMASK29_Msk = 0x20000000
	// Bit PMASK29.
	GPIO_MASK_PMASK29 = 0x20000000
	// Position of PMASK30 field.
	GPIO_MASK_PMASK30_Pos = 0x1e
	// Bit mask of PMASK30 field.
	GPIO_MASK_PMASK30_Msk = 0x40000000
	// Bit PMASK30.
	GPIO_MASK_PMASK30 = 0x40000000
	// Position of PMASK31 field.
	GPIO_MASK_PMASK31_Pos = 0x1f
	// Bit mask of PMASK31 field.
	GPIO_MASK_PMASK31_Msk = 0x80000000
	// Bit PMASK31.
	GPIO_MASK_PMASK31 = 0x80000000

	// PIN0: Port Pin value register using MASK.
	// Position of VAL0 field.
	GPIO_PIN_VAL0_Pos = 0x0
	// Bit mask of VAL0 field.
	GPIO_PIN_VAL0_Msk = 0x1
	// Bit VAL0.
	GPIO_PIN_VAL0 = 0x1
	// Position of VAL1 field.
	GPIO_PIN_VAL1_Pos = 0x1
	// Bit mask of VAL1 field.
	GPIO_PIN_VAL1_Msk = 0x2
	// Bit VAL1.
	GPIO_PIN_VAL1 = 0x2
	// Position of VAL2 field.
	GPIO_PIN_VAL2_Pos = 0x2
	// Bit mask of VAL2 field.
	GPIO_PIN_VAL2_Msk = 0x4
	// Bit VAL2.
	GPIO_PIN_VAL2 = 0x4
	// Position of VAL3 field.
	GPIO_PIN_VAL3_Pos = 0x3
	// Bit mask of VAL3 field.
	GPIO_PIN_VAL3_Msk = 0x8
	// Bit VAL3.
	GPIO_PIN_VAL3 = 0x8
	// Position of VAL4 field.
	GPIO_PIN_VAL4_Pos = 0x4
	// Bit mask of VAL4 field.
	GPIO_PIN_VAL4_Msk = 0x10
	// Bit VAL4.
	GPIO_PIN_VAL4 = 0x10
	// Position of VAL5 field.
	GPIO_PIN_VAL5_Pos = 0x5
	// Bit mask of VAL5 field.
	GPIO_PIN_VAL5_Msk = 0x20
	// Bit VAL5.
	GPIO_PIN_VAL5 = 0x20
	// Position of VAL6 field.
	GPIO_PIN_VAL6_Pos = 0x6
	// Bit mask of VAL6 field.
	GPIO_PIN_VAL6_Msk = 0x40
	// Bit VAL6.
	GPIO_PIN_VAL6 = 0x40
	// Position of VAL7 field.
	GPIO_PIN_VAL7_Pos = 0x7
	// Bit mask of VAL7 field.
	GPIO_PIN_VAL7_Msk = 0x80
	// Bit VAL7.
	GPIO_PIN_VAL7 = 0x80
	// Position of VAL8 field.
	GPIO_PIN_VAL8_Pos = 0x8
	// Bit mask of VAL8 field.
	GPIO_PIN_VAL8_Msk = 0x100
	// Bit VAL8.
	GPIO_PIN_VAL8 = 0x100
	// Position of VAL9 field.
	GPIO_PIN_VAL9_Pos = 0x9
	// Bit mask of VAL9 field.
	GPIO_PIN_VAL9_Msk = 0x200
	// Bit VAL9.
	GPIO_PIN_VAL9 = 0x200
	// Position of VAL10 field.
	GPIO_PIN_VAL10_Pos = 0xa
	// Bit mask of VAL10 field.
	GPIO_PIN_VAL10_Msk = 0x400
	// Bit VAL10.
	GPIO_PIN_VAL10 = 0x400
	// Position of VAL11 field.
	GPIO_PIN_VAL11_Pos = 0xb
	// Bit mask of VAL11 field.
	GPIO_PIN_VAL11_Msk = 0x800
	// Bit VAL11.
	GPIO_PIN_VAL11 = 0x800
	// Position of VAL12 field.
	GPIO_PIN_VAL12_Pos = 0xc
	// Bit mask of VAL12 field.
	GPIO_PIN_VAL12_Msk = 0x1000
	// Bit VAL12.
	GPIO_PIN_VAL12 = 0x1000
	// Position of VAL13 field.
	GPIO_PIN_VAL13_Pos = 0xd
	// Bit mask of VAL13 field.
	GPIO_PIN_VAL13_Msk = 0x2000
	// Bit VAL13.
	GPIO_PIN_VAL13 = 0x2000
	// Position of VAL14 field.
	GPIO_PIN_VAL14_Pos = 0xe
	// Bit mask of VAL14 field.
	GPIO_PIN_VAL14_Msk = 0x4000
	// Bit VAL14.
	GPIO_PIN_VAL14 = 0x4000
	// Position of VAL15 field.
	GPIO_PIN_VAL15_Pos = 0xf
	// Bit mask of VAL15 field.
	GPIO_PIN_VAL15_Msk = 0x8000
	// Bit VAL15.
	GPIO_PIN_VAL15 = 0x8000
	// Position of VAL16 field.
	GPIO_PIN_VAL16_Pos = 0x10
	// Bit mask of VAL16 field.
	GPIO_PIN_VAL16_Msk = 0x10000
	// Bit VAL16.
	GPIO_PIN_VAL16 = 0x10000
	// Position of VAL17 field.
	GPIO_PIN_VAL17_Pos = 0x11
	// Bit mask of VAL17 field.
	GPIO_PIN_VAL17_Msk = 0x20000
	// Bit VAL17.
	GPIO_PIN_VAL17 = 0x20000
	// Position of VAL18 field.
	GPIO_PIN_VAL18_Pos = 0x12
	// Bit mask of VAL18 field.
	GPIO_PIN_VAL18_Msk = 0x40000
	// Bit VAL18.
	GPIO_PIN_VAL18 = 0x40000
	// Position of VAL19 field.
	GPIO_PIN_VAL19_Pos = 0x13
	// Bit mask of VAL19 field.
	GPIO_PIN_VAL19_Msk = 0x80000
	// Bit VAL19.
	GPIO_PIN_VAL19 = 0x80000
	// Position of VAL20 field.
	GPIO_PIN_VAL20_Pos = 0x14
	// Bit mask of VAL20 field.
	GPIO_PIN_VAL20_Msk = 0x100000
	// Bit VAL20.
	GPIO_PIN_VAL20 = 0x100000
	// Position of VAL21 field.
	GPIO_PIN_VAL21_Pos = 0x15
	// Bit mask of VAL21 field.
	GPIO_PIN_VAL21_Msk = 0x200000
	// Bit VAL21.
	GPIO_PIN_VAL21 = 0x200000
	// Position of VAL22 field.
	GPIO_PIN_VAL22_Pos = 0x16
	// Bit mask of VAL22 field.
	GPIO_PIN_VAL22_Msk = 0x400000
	// Bit VAL22.
	GPIO_PIN_VAL22 = 0x400000
	// Position of VAL23 field.
	GPIO_PIN_VAL23_Pos = 0x17
	// Bit mask of VAL23 field.
	GPIO_PIN_VAL23_Msk = 0x800000
	// Bit VAL23.
	GPIO_PIN_VAL23 = 0x800000
	// Position of VAL24 field.
	GPIO_PIN_VAL24_Pos = 0x18
	// Bit mask of VAL24 field.
	GPIO_PIN_VAL24_Msk = 0x1000000
	// Bit VAL24.
	GPIO_PIN_VAL24 = 0x1000000
	// Position of VAL25 field.
	GPIO_PIN_VAL25_Pos = 0x19
	// Bit mask of VAL25 field.
	GPIO_PIN_VAL25_Msk = 0x2000000
	// Bit VAL25.
	GPIO_PIN_VAL25 = 0x2000000
	// Position of VAL26 field.
	GPIO_PIN_VAL26_Pos = 0x1a
	// Bit mask of VAL26 field.
	GPIO_PIN_VAL26_Msk = 0x4000000
	// Bit VAL26.
	GPIO_PIN_VAL26 = 0x4000000
	// Position of VAL27 field.
	GPIO_PIN_VAL27_Pos = 0x1b
	// Bit mask of VAL27 field.
	GPIO_PIN_VAL27_Msk = 0x8000000
	// Bit VAL27.
	GPIO_PIN_VAL27 = 0x8000000
	// Position of VAL28 field.
	GPIO_PIN_VAL28_Pos = 0x1c
	// Bit mask of VAL28 field.
	GPIO_PIN_VAL28_Msk = 0x10000000
	// Bit VAL28.
	GPIO_PIN_VAL28 = 0x10000000
	// Position of VAL29 field.
	GPIO_PIN_VAL29_Pos = 0x1d
	// Bit mask of VAL29 field.
	GPIO_PIN_VAL29_Msk = 0x20000000
	// Bit VAL29.
	GPIO_PIN_VAL29 = 0x20000000
	// Position of VAL30 field.
	GPIO_PIN_VAL30_Pos = 0x1e
	// Bit mask of VAL30 field.
	GPIO_PIN_VAL30_Msk = 0x40000000
	// Bit VAL30.
	GPIO_PIN_VAL30 = 0x40000000
	// Position of VAL31 field.
	GPIO_PIN_VAL31_Pos = 0x1f
	// Bit mask of VAL31 field.
	GPIO_PIN_VAL31_Msk = 0x80000000
	// Bit VAL31.
	GPIO_PIN_VAL31 = 0x80000000

	// SET0: Port Output Set register using MASK.
	// Position of PSET0 field.
	GPIO_SET_PSET0_Pos = 0x0
	// Bit mask of PSET0 field.
	GPIO_SET_PSET0_Msk = 0x1
	// Bit PSET0.
	GPIO_SET_PSET0 = 0x1
	// Position of PSET1 field.
	GPIO_SET_PSET1_Pos = 0x1
	// Bit mask of PSET1 field.
	GPIO_SET_PSET1_Msk = 0x2
	// Bit PSET1.
	GPIO_SET_PSET1 = 0x2
	// Position of PSET2 field.
	GPIO_SET_PSET2_Pos = 0x2
	// Bit mask of PSET2 field.
	GPIO_SET_PSET2_Msk = 0x4
	// Bit PSET2.
	GPIO_SET_PSET2 = 0x4
	// Position of PSET3 field.
	GPIO_SET_PSET3_Pos = 0x3
	// Bit mask of PSET3 field.
	GPIO_SET_PSET3_Msk = 0x8
	// Bit PSET3.
	GPIO_SET_PSET3 = 0x8
	// Position of PSET4 field.
	GPIO_SET_PSET4_Pos = 0x4
	// Bit mask of PSET4 field.
	GPIO_SET_PSET4_Msk = 0x10
	// Bit PSET4.
	GPIO_SET_PSET4 = 0x10
	// Position of PSET5 field.
	GPIO_SET_PSET5_Pos = 0x5
	// Bit mask of PSET5 field.
	GPIO_SET_PSET5_Msk = 0x20
	// Bit PSET5.
	GPIO_SET_PSET5 = 0x20
	// Position of PSET6 field.
	GPIO_SET_PSET6_Pos = 0x6
	// Bit mask of PSET6 field.
	GPIO_SET_PSET6_Msk = 0x40
	// Bit PSET6.
	GPIO_SET_PSET6 = 0x40
	// Position of PSET7 field.
	GPIO_SET_PSET7_Pos = 0x7
	// Bit mask of PSET7 field.
	GPIO_SET_PSET7_Msk = 0x80
	// Bit PSET7.
	GPIO_SET_PSET7 = 0x80
	// Position of PSET8 field.
	GPIO_SET_PSET8_Pos = 0x8
	// Bit mask of PSET8 field.
	GPIO_SET_PSET8_Msk = 0x100
	// Bit PSET8.
	GPIO_SET_PSET8 = 0x100
	// Position of PSET9 field.
	GPIO_SET_PSET9_Pos = 0x9
	// Bit mask of PSET9 field.
	GPIO_SET_PSET9_Msk = 0x200
	// Bit PSET9.
	GPIO_SET_PSET9 = 0x200
	// Position of PSET10 field.
	GPIO_SET_PSET10_Pos = 0xa
	// Bit mask of PSET10 field.
	GPIO_SET_PSET10_Msk = 0x400
	// Bit PSET10.
	GPIO_SET_PSET10 = 0x400
	// Position of PSET11 field.
	GPIO_SET_PSET11_Pos = 0xb
	// Bit mask of PSET11 field.
	GPIO_SET_PSET11_Msk = 0x800
	// Bit PSET11.
	GPIO_SET_PSET11 = 0x800
	// Position of PSET12 field.
	GPIO_SET_PSET12_Pos = 0xc
	// Bit mask of PSET12 field.
	GPIO_SET_PSET12_Msk = 0x1000
	// Bit PSET12.
	GPIO_SET_PSET12 = 0x1000
	// Position of PSET13 field.
	GPIO_SET_PSET13_Pos = 0xd
	// Bit mask of PSET13 field.
	GPIO_SET_PSET13_Msk = 0x2000
	// Bit PSET13.
	GPIO_SET_PSET13 = 0x2000
	// Position of PSET14 field.
	GPIO_SET_PSET14_Pos = 0xe
	// Bit mask of PSET14 field.
	GPIO_SET_PSET14_Msk = 0x4000
	// Bit PSET14.
	GPIO_SET_PSET14 = 0x4000
	// Position of PSET15 field.
	GPIO_SET_PSET15_Pos = 0xf
	// Bit mask of PSET15 field.
	GPIO_SET_PSET15_Msk = 0x8000
	// Bit PSET15.
	GPIO_SET_PSET15 = 0x8000
	// Position of PSET16 field.
	GPIO_SET_PSET16_Pos = 0x10
	// Bit mask of PSET16 field.
	GPIO_SET_PSET16_Msk = 0x10000
	// Bit PSET16.
	GPIO_SET_PSET16 = 0x10000
	// Position of PSET17 field.
	GPIO_SET_PSET17_Pos = 0x11
	// Bit mask of PSET17 field.
	GPIO_SET_PSET17_Msk = 0x20000
	// Bit PSET17.
	GPIO_SET_PSET17 = 0x20000
	// Position of PSET18 field.
	GPIO_SET_PSET18_Pos = 0x12
	// Bit mask of PSET18 field.
	GPIO_SET_PSET18_Msk = 0x40000
	// Bit PSET18.
	GPIO_SET_PSET18 = 0x40000
	// Position of PSET19 field.
	GPIO_SET_PSET19_Pos = 0x13
	// Bit mask of PSET19 field.
	GPIO_SET_PSET19_Msk = 0x80000
	// Bit PSET19.
	GPIO_SET_PSET19 = 0x80000
	// Position of PSET20 field.
	GPIO_SET_PSET20_Pos = 0x14
	// Bit mask of PSET20 field.
	GPIO_SET_PSET20_Msk = 0x100000
	// Bit PSET20.
	GPIO_SET_PSET20 = 0x100000
	// Position of PSET21 field.
	GPIO_SET_PSET21_Pos = 0x15
	// Bit mask of PSET21 field.
	GPIO_SET_PSET21_Msk = 0x200000
	// Bit PSET21.
	GPIO_SET_PSET21 = 0x200000
	// Position of PSET22 field.
	GPIO_SET_PSET22_Pos = 0x16
	// Bit mask of PSET22 field.
	GPIO_SET_PSET22_Msk = 0x400000
	// Bit PSET22.
	GPIO_SET_PSET22 = 0x400000
	// Position of PSET23 field.
	GPIO_SET_PSET23_Pos = 0x17
	// Bit mask of PSET23 field.
	GPIO_SET_PSET23_Msk = 0x800000
	// Bit PSET23.
	GPIO_SET_PSET23 = 0x800000
	// Position of PSET24 field.
	GPIO_SET_PSET24_Pos = 0x18
	// Bit mask of PSET24 field.
	GPIO_SET_PSET24_Msk = 0x1000000
	// Bit PSET24.
	GPIO_SET_PSET24 = 0x1000000
	// Position of PSET25 field.
	GPIO_SET_PSET25_Pos = 0x19
	// Bit mask of PSET25 field.
	GPIO_SET_PSET25_Msk = 0x2000000
	// Bit PSET25.
	GPIO_SET_PSET25 = 0x2000000
	// Position of PSET26 field.
	GPIO_SET_PSET26_Pos = 0x1a
	// Bit mask of PSET26 field.
	GPIO_SET_PSET26_Msk = 0x4000000
	// Bit PSET26.
	GPIO_SET_PSET26 = 0x4000000
	// Position of PSET27 field.
	GPIO_SET_PSET27_Pos = 0x1b
	// Bit mask of PSET27 field.
	GPIO_SET_PSET27_Msk = 0x8000000
	// Bit PSET27.
	GPIO_SET_PSET27 = 0x8000000
	// Position of PSET28 field.
	GPIO_SET_PSET28_Pos = 0x1c
	// Bit mask of PSET28 field.
	GPIO_SET_PSET28_Msk = 0x10000000
	// Bit PSET28.
	GPIO_SET_PSET28 = 0x10000000
	// Position of PSET29 field.
	GPIO_SET_PSET29_Pos = 0x1d
	// Bit mask of PSET29 field.
	GPIO_SET_PSET29_Msk = 0x20000000
	// Bit PSET29.
	GPIO_SET_PSET29 = 0x20000000
	// Position of PSET30 field.
	GPIO_SET_PSET30_Pos = 0x1e
	// Bit mask of PSET30 field.
	GPIO_SET_PSET30_Msk = 0x40000000
	// Bit PSET30.
	GPIO_SET_PSET30 = 0x40000000
	// Position of PSET31 field.
	GPIO_SET_PSET31_Pos = 0x1f
	// Bit mask of PSET31 field.
	GPIO_SET_PSET31_Msk = 0x80000000
	// Bit PSET31.
	GPIO_SET_PSET31 = 0x80000000

	// CLR0: Port Output Clear register using MASK.
	// Position of PCLR0 field.
	GPIO_CLR_PCLR0_Pos = 0x0
	// Bit mask of PCLR0 field.
	GPIO_CLR_PCLR0_Msk = 0x1
	// Bit PCLR0.
	GPIO_CLR_PCLR0 = 0x1
	// Position of PCLR1 field.
	GPIO_CLR_PCLR1_Pos = 0x1
	// Bit mask of PCLR1 field.
	GPIO_CLR_PCLR1_Msk = 0x2
	// Bit PCLR1.
	GPIO_CLR_PCLR1 = 0x2
	// Position of PCLR2 field.
	GPIO_CLR_PCLR2_Pos = 0x2
	// Bit mask of PCLR2 field.
	GPIO_CLR_PCLR2_Msk = 0x4
	// Bit PCLR2.
	GPIO_CLR_PCLR2 = 0x4
	// Position of PCLR3 field.
	GPIO_CLR_PCLR3_Pos = 0x3
	// Bit mask of PCLR3 field.
	GPIO_CLR_PCLR3_Msk = 0x8
	// Bit PCLR3.
	GPIO_CLR_PCLR3 = 0x8
	// Position of PCLR4 field.
	GPIO_CLR_PCLR4_Pos = 0x4
	// Bit mask of PCLR4 field.
	GPIO_CLR_PCLR4_Msk = 0x10
	// Bit PCLR4.
	GPIO_CLR_PCLR4 = 0x10
	// Position of PCLR5 field.
	GPIO_CLR_PCLR5_Pos = 0x5
	// Bit mask of PCLR5 field.
	GPIO_CLR_PCLR5_Msk = 0x20
	// Bit PCLR5.
	GPIO_CLR_PCLR5 = 0x20
	// Position of PCLR6 field.
	GPIO_CLR_PCLR6_Pos = 0x6
	// Bit mask of PCLR6 field.
	GPIO_CLR_PCLR6_Msk = 0x40
	// Bit PCLR6.
	GPIO_CLR_PCLR6 = 0x40
	// Position of PCLR7 field.
	GPIO_CLR_PCLR7_Pos = 0x7
	// Bit mask of PCLR7 field.
	GPIO_CLR_PCLR7_Msk = 0x80
	// Bit PCLR7.
	GPIO_CLR_PCLR7 = 0x80
	// Position of PCLR8 field.
	GPIO_CLR_PCLR8_Pos = 0x8
	// Bit mask of PCLR8 field.
	GPIO_CLR_PCLR8_Msk = 0x100
	// Bit PCLR8.
	GPIO_CLR_PCLR8 = 0x100
	// Position of PCLR9 field.
	GPIO_CLR_PCLR9_Pos = 0x9
	// Bit mask of PCLR9 field.
	GPIO_CLR_PCLR9_Msk = 0x200
	// Bit PCLR9.
	GPIO_CLR_PCLR9 = 0x200
	// Position of PCLR10 field.
	GPIO_CLR_PCLR10_Pos = 0xa
	// Bit mask of PCLR10 field.
	GPIO_CLR_PCLR10_Msk = 0x400
	// Bit PCLR10.
	GPIO_CLR_PCLR10 = 0x400
	// Position of PCLR11 field.
	GPIO_CLR_PCLR11_Pos = 0xb
	// Bit mask of PCLR11 field.
	GPIO_CLR_PCLR11_Msk = 0x800
	// Bit PCLR11.
	GPIO_CLR_PCLR11 = 0x800
	// Position of PCLR12 field.
	GPIO_CLR_PCLR12_Pos = 0xc
	// Bit mask of PCLR12 field.
	GPIO_CLR_PCLR12_Msk = 0x1000
	// Bit PCLR12.
	GPIO_CLR_PCLR12 = 0x1000
	// Position of PCLR13 field.
	GPIO_CLR_PCLR13_Pos = 0xd
	// Bit mask of PCLR13 field.
	GPIO_CLR_PCLR13_Msk = 0x2000
	// Bit PCLR13.
	GPIO_CLR_PCLR13 = 0x2000
	// Position of PCLR14 field.
	GPIO_CLR_PCLR14_Pos = 0xe
	// Bit mask of PCLR14 field.
	GPIO_CLR_PCLR14_Msk = 0x4000
	// Bit PCLR14.
	GPIO_CLR_PCLR14 = 0x4000
	// Position of PCLR15 field.
	GPIO_CLR_PCLR15_Pos = 0xf
	// Bit mask of PCLR15 field.
	GPIO_CLR_PCLR15_Msk = 0x8000
	// Bit PCLR15.
	GPIO_CLR_PCLR15 = 0x8000
	// Position of PCLR16 field.
	GPIO_CLR_PCLR16_Pos = 0x10
	// Bit mask of PCLR16 field.
	GPIO_CLR_PCLR16_Msk = 0x10000
	// Bit PCLR16.
	GPIO_CLR_PCLR16 = 0x10000
	// Position of PCLR17 field.
	GPIO_CLR_PCLR17_Pos = 0x11
	// Bit mask of PCLR17 field.
	GPIO_CLR_PCLR17_Msk = 0x20000
	// Bit PCLR17.
	GPIO_CLR_PCLR17 = 0x20000
	// Position of PCLR18 field.
	GPIO_CLR_PCLR18_Pos = 0x12
	// Bit mask of PCLR18 field.
	GPIO_CLR_PCLR18_Msk = 0x40000
	// Bit PCLR18.
	GPIO_CLR_PCLR18 = 0x40000
	// Position of PCLR19 field.
	GPIO_CLR_PCLR19_Pos = 0x13
	// Bit mask of PCLR19 field.
	GPIO_CLR_PCLR19_Msk = 0x80000
	// Bit PCLR19.
	GPIO_CLR_PCLR19 = 0x80000
	// Position of PCLR20 field.
	GPIO_CLR_PCLR20_Pos = 0x14
	// Bit mask of PCLR20 field.
	GPIO_CLR_PCLR20_Msk = 0x100000
	// Bit PCLR20.
	GPIO_CLR_PCLR20 = 0x100000
	// Position of PCLR21 field.
	GPIO_CLR_PCLR21_Pos = 0x15
	// Bit mask of PCLR21 field.
	GPIO_CLR_PCLR21_Msk = 0x200000
	// Bit PCLR21.
	GPIO_CLR_PCLR21 = 0x200000
	// Position of PCLR22 field.
	GPIO_CLR_PCLR22_Pos = 0x16
	// Bit mask of PCLR22 field.
	GPIO_CLR_PCLR22_Msk = 0x400000
	// Bit PCLR22.
	GPIO_CLR_PCLR22 = 0x400000
	// Position of PCLR23 field.
	GPIO_CLR_PCLR23_Pos = 0x17
	// Bit mask of PCLR23 field.
	GPIO_CLR_PCLR23_Msk = 0x800000
	// Bit PCLR23.
	GPIO_CLR_PCLR23 = 0x800000
	// Position of PCLR24 field.
	GPIO_CLR_PCLR24_Pos = 0x18
	// Bit mask of PCLR24 field.
	GPIO_CLR_PCLR24_Msk = 0x1000000
	// Bit PCLR24.
	GPIO_CLR_PCLR24 = 0x1000000
	// Position of PCLR25 field.
	GPIO_CLR_PCLR25_Pos = 0x19
	// Bit mask of PCLR25 field.
	GPIO_CLR_PCLR25_Msk = 0x2000000
	// Bit PCLR25.
	GPIO_CLR_PCLR25 = 0x2000000
	// Position of PCLR26 field.
	GPIO_CLR_PCLR26_Pos = 0x1a
	// Bit mask of PCLR26 field.
	GPIO_CLR_PCLR26_Msk = 0x4000000
	// Bit PCLR26.
	GPIO_CLR_PCLR26 = 0x4000000
	// Position of PCLR27 field.
	GPIO_CLR_PCLR27_Pos = 0x1b
	// Bit mask of PCLR27 field.
	GPIO_CLR_PCLR27_Msk = 0x8000000
	// Bit PCLR27.
	GPIO_CLR_PCLR27 = 0x8000000
	// Position of PCLR28 field.
	GPIO_CLR_PCLR28_Pos = 0x1c
	// Bit mask of PCLR28 field.
	GPIO_CLR_PCLR28_Msk = 0x10000000
	// Bit PCLR28.
	GPIO_CLR_PCLR28 = 0x10000000
	// Position of PCLR29 field.
	GPIO_CLR_PCLR29_Pos = 0x1d
	// Bit mask of PCLR29 field.
	GPIO_CLR_PCLR29_Msk = 0x20000000
	// Bit PCLR29.
	GPIO_CLR_PCLR29 = 0x20000000
	// Position of PCLR30 field.
	GPIO_CLR_PCLR30_Pos = 0x1e
	// Bit mask of PCLR30 field.
	GPIO_CLR_PCLR30_Msk = 0x40000000
	// Bit PCLR30.
	GPIO_CLR_PCLR30 = 0x40000000
	// Position of PCLR31 field.
	GPIO_CLR_PCLR31_Pos = 0x1f
	// Bit mask of PCLR31 field.
	GPIO_CLR_PCLR31_Msk = 0x80000000
	// Bit PCLR31.
	GPIO_CLR_PCLR31 = 0x80000000
)

// Constants for EMC: External Memory Controller (EMC)
const (
	// CONTROL: Controls operation of the memory controller.
	// Position of E field.
	EMC_CONTROL_E_Pos = 0x0
	// Bit mask of E field.
	EMC_CONTROL_E_Msk = 0x1
	// Bit E.
	EMC_CONTROL_E = 0x1
	// Disabled
	EMC_CONTROL_E_DISABLED = 0x0
	// Enabled (POR and warm reset value).
	EMC_CONTROL_E_ENABLED = 0x1
	// Position of M field.
	EMC_CONTROL_M_Pos = 0x1
	// Bit mask of M field.
	EMC_CONTROL_M_Msk = 0x2
	// Bit M.
	EMC_CONTROL_M = 0x2
	// Normal memory map.
	EMC_CONTROL_M_NORMAL = 0x0
	// Reset memory map. Static memory EMC_CS1 is mirrored onto EMC_CS0 and EMC_DYCS0 (POR reset value).
	EMC_CONTROL_M_RESET = 0x1
	// Position of L field.
	EMC_CONTROL_L_Pos = 0x2
	// Bit mask of L field.
	EMC_CONTROL_L_Msk = 0x4
	// Bit L.
	EMC_CONTROL_L = 0x4
	// Normal mode (warm reset value).
	EMC_CONTROL_L_WARMRESET = 0x0
	// Low-power mode. Entering low-power mode reduces memory controller power consumption. Dynamic memory is refreshed as necessary. The memory controller returns to normal functional mode by clearing the low-power mode bit (L), or by POR. This bit must only be modified when the EMC is in idle state.[1]
	EMC_CONTROL_L_LOWPOWER = 0x1
	// Position of RESERVED field.
	EMC_CONTROL_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	EMC_CONTROL_RESERVED_Msk = 0xfffffff8

	// STATUS: Provides EMC status information.
	// Position of B field.
	EMC_STATUS_B_Pos = 0x0
	// Bit mask of B field.
	EMC_STATUS_B_Msk = 0x1
	// Bit B.
	EMC_STATUS_B = 0x1
	// EMC is idle (warm reset value).
	EMC_STATUS_B_IDLE = 0x0
	// EMC is busy performing memory transactions, commands, auto-refresh cycles, or is in self-refresh mode (POR reset value).
	EMC_STATUS_B_BUSY = 0x1
	// Position of S field.
	EMC_STATUS_S_Pos = 0x1
	// Bit mask of S field.
	EMC_STATUS_S_Msk = 0x2
	// Bit S.
	EMC_STATUS_S = 0x2
	// Write buffers empty (POR reset value)
	EMC_STATUS_S_EMPTY = 0x0
	// Write buffers contain data.
	EMC_STATUS_S_DATA = 0x1
	// Position of SA field.
	EMC_STATUS_SA_Pos = 0x2
	// Bit mask of SA field.
	EMC_STATUS_SA_Msk = 0x4
	// Bit SA.
	EMC_STATUS_SA = 0x4
	// Normal mode
	EMC_STATUS_SA_NORMAL = 0x0
	// Self-refresh mode (POR reset value).
	EMC_STATUS_SA_SELFREFRESH = 0x1
	// Position of RESERVED field.
	EMC_STATUS_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	EMC_STATUS_RESERVED_Msk = 0xfffffff8

	// CONFIG: Configures operation of the memory controller
	// Position of EM field.
	EMC_CONFIG_EM_Pos = 0x0
	// Bit mask of EM field.
	EMC_CONFIG_EM_Msk = 0x1
	// Bit EM.
	EMC_CONFIG_EM = 0x1
	// Little-endian mode (POR reset value).
	EMC_CONFIG_EM_LITTLEENDIAN = 0x0
	// Big-endian mode.
	EMC_CONFIG_EM_BIGENDIAN = 0x1
	// Position of RESERVED field.
	EMC_CONFIG_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	EMC_CONFIG_RESERVED_Msk = 0xfe
	// Position of CLKR field.
	EMC_CONFIG_CLKR_Pos = 0x8
	// Bit mask of CLKR field.
	EMC_CONFIG_CLKR_Msk = 0x100
	// Bit CLKR.
	EMC_CONFIG_CLKR = 0x100
	// 1:1(POR reset value)
	EMC_CONFIG_CLKR_PORRESET = 0x0
	// 1:2 (this option is not available on the LPC178x/177x)
	EMC_CONFIG_CLKR_DONOTUSE = 0x1
	// Position of RESERVED field.
	EMC_CONFIG_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	EMC_CONFIG_RESERVED_Msk = 0xfffffe00

	// DYNAMICCONTROL: Controls dynamic memory operation.
	// Position of CE field.
	EMC_DYNAMICCONTROL_CE_Pos = 0x0
	// Bit mask of CE field.
	EMC_DYNAMICCONTROL_CE_Msk = 0x1
	// Bit CE.
	EMC_DYNAMICCONTROL_CE = 0x1
	// Clock enable of idle devices are deasserted to save power (POR reset value).
	EMC_DYNAMICCONTROL_CE_POWERSAVE = 0x0
	// All clock enables are driven HIGH continuously.[1]
	EMC_DYNAMICCONTROL_CE_HIGH = 0x1
	// Position of CS field.
	EMC_DYNAMICCONTROL_CS_Pos = 0x1
	// Bit mask of CS field.
	EMC_DYNAMICCONTROL_CS_Msk = 0x2
	// Bit CS.
	EMC_DYNAMICCONTROL_CS = 0x2
	// CLKOUT stops when all SDRAMs are idle and during self-refresh mode.
	EMC_DYNAMICCONTROL_CS_STOP = 0x0
	// CLKOUT runs continuously (POR reset value).
	EMC_DYNAMICCONTROL_CS_RUN = 0x1
	// Position of SR field.
	EMC_DYNAMICCONTROL_SR_Pos = 0x2
	// Bit mask of SR field.
	EMC_DYNAMICCONTROL_SR_Msk = 0x4
	// Bit SR.
	EMC_DYNAMICCONTROL_SR = 0x4
	// Normal mode.
	EMC_DYNAMICCONTROL_SR_NORMAL_MODE_ = 0x0
	// Enter self-refresh mode (POR reset value).
	EMC_DYNAMICCONTROL_SR_ENTER_SELF_REFRESH_M = 0x1
	// Position of RESERVED field.
	EMC_DYNAMICCONTROL_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	EMC_DYNAMICCONTROL_RESERVED_Msk = 0x18
	// Position of MMC field.
	EMC_DYNAMICCONTROL_MMC_Pos = 0x5
	// Bit mask of MMC field.
	EMC_DYNAMICCONTROL_MMC_Msk = 0x20
	// Bit MMC.
	EMC_DYNAMICCONTROL_MMC = 0x20
	// CLKOUT enabled (POR reset value).
	EMC_DYNAMICCONTROL_MMC_CLKOUT_ENABLED_POR_ = 0x0
	// CLKOUT disabled.[3]
	EMC_DYNAMICCONTROL_MMC_CLKOUT_DISABLED = 0x1
	// Position of RESERVED field.
	EMC_DYNAMICCONTROL_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	EMC_DYNAMICCONTROL_RESERVED_Msk = 0x40
	// Bit RESERVED.
	EMC_DYNAMICCONTROL_RESERVED = 0x40
	// Position of I field.
	EMC_DYNAMICCONTROL_I_Pos = 0x7
	// Bit mask of I field.
	EMC_DYNAMICCONTROL_I_Msk = 0x180
	// Issue SDRAM NORMAL operation command (POR reset value).
	EMC_DYNAMICCONTROL_I_NORMAL = 0x0
	// Issue SDRAM MODE command.
	EMC_DYNAMICCONTROL_I_MODE = 0x1
	// Issue SDRAM PALL (precharge all) command.
	EMC_DYNAMICCONTROL_I_PALL = 0x2
	// Issue SDRAM NOP (no operation) command)
	EMC_DYNAMICCONTROL_I_NOP = 0x3
	// Position of RESERVED field.
	EMC_DYNAMICCONTROL_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	EMC_DYNAMICCONTROL_RESERVED_Msk = 0x3e00
	// Position of RESERVED field.
	EMC_DYNAMICCONTROL_RESERVED_Pos = 0xe
	// Bit mask of RESERVED field.
	EMC_DYNAMICCONTROL_RESERVED_Msk = 0xffffc000

	// DYNAMICREFRESH: Configures dynamic memory refresh.
	// Position of REFRESH field.
	EMC_DYNAMICREFRESH_REFRESH_Pos = 0x0
	// Bit mask of REFRESH field.
	EMC_DYNAMICREFRESH_REFRESH_Msk = 0x7ff
	// Position of RESERVED field.
	EMC_DYNAMICREFRESH_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	EMC_DYNAMICREFRESH_RESERVED_Msk = 0xfffff800

	// DYNAMICREADCONFIG: Configures dynamic memory read strategy.
	// Position of RD field.
	EMC_DYNAMICREADCONFIG_RD_Pos = 0x0
	// Bit mask of RD field.
	EMC_DYNAMICREADCONFIG_RD_Msk = 0x3
	// Clock out delayed strategy, using CLKOUT (command not delayed, clock out delayed). POR reset value.
	EMC_DYNAMICREADCONFIG_RD_CLOCK_OUT_DELAYED_ST = 0x0
	// Position of RESERVED field.
	EMC_DYNAMICREADCONFIG_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	EMC_DYNAMICREADCONFIG_RESERVED_Msk = 0xfffffffc

	// DYNAMICRP: Precharge command period.
	// Position of TRP field.
	EMC_DYNAMICRP_TRP_Pos = 0x0
	// Bit mask of TRP field.
	EMC_DYNAMICRP_TRP_Msk = 0xf
	// Position of RESERVED field.
	EMC_DYNAMICRP_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	EMC_DYNAMICRP_RESERVED_Msk = 0xfffffff0

	// DYNAMICRAS: Active to precharge command period.
	// Position of TRAS field.
	EMC_DYNAMICRAS_TRAS_Pos = 0x0
	// Bit mask of TRAS field.
	EMC_DYNAMICRAS_TRAS_Msk = 0xf
	// Position of RESERVED field.
	EMC_DYNAMICRAS_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	EMC_DYNAMICRAS_RESERVED_Msk = 0xfffffff0

	// DYNAMICSREX: Self-refresh exit time.
	// Position of TSREX field.
	EMC_DYNAMICSREX_TSREX_Pos = 0x0
	// Bit mask of TSREX field.
	EMC_DYNAMICSREX_TSREX_Msk = 0xf
	// Position of RESERVED field.
	EMC_DYNAMICSREX_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	EMC_DYNAMICSREX_RESERVED_Msk = 0xfffffff0

	// DYNAMICAPR: Last-data-out to active command time.
	// Position of TAPR field.
	EMC_DYNAMICAPR_TAPR_Pos = 0x0
	// Bit mask of TAPR field.
	EMC_DYNAMICAPR_TAPR_Msk = 0xf
	// Position of RESERVED field.
	EMC_DYNAMICAPR_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	EMC_DYNAMICAPR_RESERVED_Msk = 0xfffffff0

	// DYNAMICDAL: Data-in to active command time.
	// Position of TDAL field.
	EMC_DYNAMICDAL_TDAL_Pos = 0x0
	// Bit mask of TDAL field.
	EMC_DYNAMICDAL_TDAL_Msk = 0xf
	// Position of RESERVED field.
	EMC_DYNAMICDAL_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	EMC_DYNAMICDAL_RESERVED_Msk = 0xfffffff0

	// DYNAMICWR: Write recovery time.
	// Position of TWR field.
	EMC_DYNAMICWR_TWR_Pos = 0x0
	// Bit mask of TWR field.
	EMC_DYNAMICWR_TWR_Msk = 0xf
	// Position of RESERVED field.
	EMC_DYNAMICWR_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	EMC_DYNAMICWR_RESERVED_Msk = 0xfffffff0

	// DYNAMICRC: Selects the active to active command period.
	// Position of TRC field.
	EMC_DYNAMICRC_TRC_Pos = 0x0
	// Bit mask of TRC field.
	EMC_DYNAMICRC_TRC_Msk = 0x1f
	// Position of RESERVED field.
	EMC_DYNAMICRC_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	EMC_DYNAMICRC_RESERVED_Msk = 0xffffffe0

	// DYNAMICRFC: Selects the auto-refresh period.
	// Position of TRFC field.
	EMC_DYNAMICRFC_TRFC_Pos = 0x0
	// Bit mask of TRFC field.
	EMC_DYNAMICRFC_TRFC_Msk = 0x1f
	// Position of RESERVED field.
	EMC_DYNAMICRFC_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	EMC_DYNAMICRFC_RESERVED_Msk = 0xffffffe0

	// DYNAMICXSR: Time for exit self-refresh to active command.
	// Position of TXSR field.
	EMC_DYNAMICXSR_TXSR_Pos = 0x0
	// Bit mask of TXSR field.
	EMC_DYNAMICXSR_TXSR_Msk = 0x1f
	// Position of RESERVED field.
	EMC_DYNAMICXSR_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	EMC_DYNAMICXSR_RESERVED_Msk = 0xffffffe0

	// DYNAMICRRD: Latency for active bank A to active bank B.
	// Position of TRRD field.
	EMC_DYNAMICRRD_TRRD_Pos = 0x0
	// Bit mask of TRRD field.
	EMC_DYNAMICRRD_TRRD_Msk = 0xf
	// Position of RESERVED field.
	EMC_DYNAMICRRD_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	EMC_DYNAMICRRD_RESERVED_Msk = 0xfffffff0

	// DYNAMICMRD: Time for load mode register to active command.
	// Position of TMRD field.
	EMC_DYNAMICMRD_TMRD_Pos = 0x0
	// Bit mask of TMRD field.
	EMC_DYNAMICMRD_TMRD_Msk = 0xf
	// Position of RESERVED field.
	EMC_DYNAMICMRD_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	EMC_DYNAMICMRD_RESERVED_Msk = 0xfffffff0

	// STATICEXTENDEDWAIT: Time for long static memory read and write transfers.
	// Position of EXTENDEDWAIT field.
	EMC_STATICEXTENDEDWAIT_EXTENDEDWAIT_Pos = 0x0
	// Bit mask of EXTENDEDWAIT field.
	EMC_STATICEXTENDEDWAIT_EXTENDEDWAIT_Msk = 0x3ff
	// Position of RESERVED field.
	EMC_STATICEXTENDEDWAIT_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	EMC_STATICEXTENDEDWAIT_RESERVED_Msk = 0xfffffc00

	// DYNAMICCONFIG0: Configuration information for EMC_DYCS0.
	// Position of RESERVED field.
	EMC_DYNAMICCONFIG_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	EMC_DYNAMICCONFIG_RESERVED_Msk = 0x7
	// Position of MD field.
	EMC_DYNAMICCONFIG_MD_Pos = 0x3
	// Bit mask of MD field.
	EMC_DYNAMICCONFIG_MD_Msk = 0x18
	// SDRAM (POR reset value).
	EMC_DYNAMICCONFIG_MD_SDRAM_POR_RESET_VAL = 0x0
	// Low-power SDRAM.
	EMC_DYNAMICCONFIG_MD_LOW_POWER_SDRAM_ = 0x1
	// Position of RESERVED field.
	EMC_DYNAMICCONFIG_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	EMC_DYNAMICCONFIG_RESERVED_Msk = 0x60
	// Position of AM0 field.
	EMC_DYNAMICCONFIG_AM0_Pos = 0x7
	// Bit mask of AM0 field.
	EMC_DYNAMICCONFIG_AM0_Msk = 0x1f80
	// Position of RESERVED field.
	EMC_DYNAMICCONFIG_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	EMC_DYNAMICCONFIG_RESERVED_Msk = 0x2000
	// Bit RESERVED.
	EMC_DYNAMICCONFIG_RESERVED = 0x2000
	// Position of AM1 field.
	EMC_DYNAMICCONFIG_AM1_Pos = 0xe
	// Bit mask of AM1 field.
	EMC_DYNAMICCONFIG_AM1_Msk = 0x4000
	// Bit AM1.
	EMC_DYNAMICCONFIG_AM1 = 0x4000
	// Position of RESERVED field.
	EMC_DYNAMICCONFIG_RESERVED_Pos = 0xf
	// Bit mask of RESERVED field.
	EMC_DYNAMICCONFIG_RESERVED_Msk = 0x78000
	// Position of B field.
	EMC_DYNAMICCONFIG_B_Pos = 0x13
	// Bit mask of B field.
	EMC_DYNAMICCONFIG_B_Msk = 0x80000
	// Bit B.
	EMC_DYNAMICCONFIG_B = 0x80000
	// Buffer disabled for accesses to this chip select (POR reset value).
	EMC_DYNAMICCONFIG_B_BUFFER_DISABLED_FOR_ = 0x0
	// Buffer enabled for accesses to this chip select.[2]
	EMC_DYNAMICCONFIG_B_BUFFER_ENABLED_FOR_A = 0x1
	// Position of P field.
	EMC_DYNAMICCONFIG_P_Pos = 0x14
	// Bit mask of P field.
	EMC_DYNAMICCONFIG_P_Msk = 0x100000
	// Bit P.
	EMC_DYNAMICCONFIG_P = 0x100000
	// Writes not protected (POR reset value).
	EMC_DYNAMICCONFIG_P_WRITES_NOT_PROTECTED = 0x0
	// Writes protected.
	EMC_DYNAMICCONFIG_P_WRITES_PROTECTED_ = 0x1
	// Position of RESERVED field.
	EMC_DYNAMICCONFIG_RESERVED_Pos = 0x15
	// Bit mask of RESERVED field.
	EMC_DYNAMICCONFIG_RESERVED_Msk = 0xffe00000

	// DYNAMICRASCAS0: RAS and CAS latencies for EMC_DYCS0.
	// Position of RAS field.
	EMC_DYNAMICRASCAS_RAS_Pos = 0x0
	// Bit mask of RAS field.
	EMC_DYNAMICRASCAS_RAS_Msk = 0x3
	// Reserved.
	EMC_DYNAMICRASCAS_RAS_RESERVED_ = 0x0
	// One CCLK cycle.
	EMC_DYNAMICRASCAS_RAS_ONE_CCLK_CYCLE_ = 0x1
	// Two CCLK cycles.
	EMC_DYNAMICRASCAS_RAS_TWO_CCLK_CYCLES_ = 0x2
	// Three CCLK cycles (POR reset value).
	EMC_DYNAMICRASCAS_RAS_THREE_CCLK_CYCLES_P = 0x3
	// Position of RESERVED field.
	EMC_DYNAMICRASCAS_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	EMC_DYNAMICRASCAS_RESERVED_Msk = 0xfc
	// Position of CAS field.
	EMC_DYNAMICRASCAS_CAS_Pos = 0x8
	// Bit mask of CAS field.
	EMC_DYNAMICRASCAS_CAS_Msk = 0x300
	// Reserved.
	EMC_DYNAMICRASCAS_CAS_RESERVED_ = 0x0
	// One CCLK cycle.
	EMC_DYNAMICRASCAS_CAS_ONE_CCLK_CYCLE_ = 0x1
	// Two CCLK cycles.
	EMC_DYNAMICRASCAS_CAS_TWO_CCLK_CYCLES_ = 0x2
	// Three CCLK cycles (POR reset value).
	EMC_DYNAMICRASCAS_CAS_THREE_CCLK_CYCLES_P = 0x3
	// Position of RESERVED field.
	EMC_DYNAMICRASCAS_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	EMC_DYNAMICRASCAS_RESERVED_Msk = 0xfffffc00

	// STATICCONFIG0: Configuration for EMC_CS0.
	// Position of MW field.
	EMC_STATICCONFIG_MW_Pos = 0x0
	// Bit mask of MW field.
	EMC_STATICCONFIG_MW_Msk = 0x3
	// 8 bit (POR reset value).
	EMC_STATICCONFIG_MW_8_BIT_POR_RESET_VAL = 0x0
	// 16 bit.
	EMC_STATICCONFIG_MW_16_BIT_ = 0x1
	// 32 bit.
	EMC_STATICCONFIG_MW_32_BIT_ = 0x2
	// Reserved.
	EMC_STATICCONFIG_MW_RESERVED_ = 0x3
	// Position of RESERVED field.
	EMC_STATICCONFIG_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	EMC_STATICCONFIG_RESERVED_Msk = 0x4
	// Bit RESERVED.
	EMC_STATICCONFIG_RESERVED = 0x4
	// Position of PM field.
	EMC_STATICCONFIG_PM_Pos = 0x3
	// Bit mask of PM field.
	EMC_STATICCONFIG_PM_Msk = 0x8
	// Bit PM.
	EMC_STATICCONFIG_PM = 0x8
	// Disabled (POR reset value).
	EMC_STATICCONFIG_PM_DISABLED_POR_RESET_ = 0x0
	// Asynchronous page mode enabled (page length four).
	EMC_STATICCONFIG_PM_ASYNCHRONOUS_PAGE_MO = 0x1
	// Position of RESERVED field.
	EMC_STATICCONFIG_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	EMC_STATICCONFIG_RESERVED_Msk = 0x30
	// Position of PC field.
	EMC_STATICCONFIG_PC_Pos = 0x6
	// Bit mask of PC field.
	EMC_STATICCONFIG_PC_Msk = 0x40
	// Bit PC.
	EMC_STATICCONFIG_PC = 0x40
	// Active LOW chip select.
	EMC_STATICCONFIG_PC_ACTIVE_LOW_CHIP_SELE = 0x0
	// Active HIGH chip select.
	EMC_STATICCONFIG_PC_ACTIVE_HIGH_CHIP_SEL = 0x1
	// Position of PB field.
	EMC_STATICCONFIG_PB_Pos = 0x7
	// Bit mask of PB field.
	EMC_STATICCONFIG_PB_Msk = 0x80
	// Bit PB.
	EMC_STATICCONFIG_PB = 0x80
	// For reads all the bits in BLS3:0 are HIGH. For writes the respective active bits in BLS3:0 are LOW (POR reset value).
	EMC_STATICCONFIG_PB_BLSHIGH = 0x0
	// For reads the respective active bits in BLS3:0 are LOW. For writes the respective active bits in BLS3:0 are LOW.
	EMC_STATICCONFIG_PB_BLSLOW = 0x1
	// Position of EW field.
	EMC_STATICCONFIG_EW_Pos = 0x8
	// Bit mask of EW field.
	EMC_STATICCONFIG_EW_Msk = 0x100
	// Bit EW.
	EMC_STATICCONFIG_EW = 0x100
	// Extended wait disabled (POR reset value).
	EMC_STATICCONFIG_EW_EXTENDED_WAIT_DISABL = 0x0
	// Extended wait enabled.
	EMC_STATICCONFIG_EW_EXTENDED_WAIT_ENABLE = 0x1
	// Position of RESERVED field.
	EMC_STATICCONFIG_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	EMC_STATICCONFIG_RESERVED_Msk = 0x7fe00
	// Position of B field.
	EMC_STATICCONFIG_B_Pos = 0x13
	// Bit mask of B field.
	EMC_STATICCONFIG_B_Msk = 0x80000
	// Bit B.
	EMC_STATICCONFIG_B = 0x80000
	// Buffer disabled (POR reset value).
	EMC_STATICCONFIG_B_BUFFER_DISABLED_POR = 0x0
	// Buffer enabled.
	EMC_STATICCONFIG_B_BUFFER_ENABLED_ = 0x1
	// Position of P field.
	EMC_STATICCONFIG_P_Pos = 0x14
	// Bit mask of P field.
	EMC_STATICCONFIG_P_Msk = 0x100000
	// Bit P.
	EMC_STATICCONFIG_P = 0x100000
	// Writes not protected (POR reset value).
	EMC_STATICCONFIG_P_WRITES_NOT_PROTECTED = 0x0
	// Write protected.
	EMC_STATICCONFIG_P_WRITE_PROTECTED_ = 0x1
	// Position of RESERVED field.
	EMC_STATICCONFIG_RESERVED_Pos = 0x15
	// Bit mask of RESERVED field.
	EMC_STATICCONFIG_RESERVED_Msk = 0xffe00000

	// STATICWAITWEN0: Delay from EMC_CS0 to write enable.
	// Position of WAITWEN field.
	EMC_STATICWAITWEN_WAITWEN_Pos = 0x0
	// Bit mask of WAITWEN field.
	EMC_STATICWAITWEN_WAITWEN_Msk = 0xf
	// Position of RESERVED field.
	EMC_STATICWAITWEN_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	EMC_STATICWAITWEN_RESERVED_Msk = 0xfffffff0

	// STATICWAITOEN0: Delay from EMC_CS0 or address change, whichever is later, to output enable.
	// Position of WAITOEN field.
	EMC_STATICWAITOEN_WAITOEN_Pos = 0x0
	// Bit mask of WAITOEN field.
	EMC_STATICWAITOEN_WAITOEN_Msk = 0xf
	// Position of RESERVED field.
	EMC_STATICWAITOEN_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	EMC_STATICWAITOEN_RESERVED_Msk = 0xfffffff0

	// STATICWAITRD0: Delay from EMC_CS0 to a read access.
	// Position of WAITRD field.
	EMC_STATICWAITRD_WAITRD_Pos = 0x0
	// Bit mask of WAITRD field.
	EMC_STATICWAITRD_WAITRD_Msk = 0x1f
	// Position of RESERVED field.
	EMC_STATICWAITRD_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	EMC_STATICWAITRD_RESERVED_Msk = 0xffffffe0

	// STATICWAITPAGE0: Delay for asynchronous page mode sequential accesses for EMC_CS0.
	// Position of WAITPAGE field.
	EMC_STATICWAITPAGE_WAITPAGE_Pos = 0x0
	// Bit mask of WAITPAGE field.
	EMC_STATICWAITPAGE_WAITPAGE_Msk = 0x1f
	// Position of RESERVED field.
	EMC_STATICWAITPAGE_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	EMC_STATICWAITPAGE_RESERVED_Msk = 0xffffffe0

	// STATICWAITWR0: Delay from EMC_CS0 to a write access.
	// Position of WAITWR field.
	EMC_STATICWAITWR_WAITWR_Pos = 0x0
	// Bit mask of WAITWR field.
	EMC_STATICWAITWR_WAITWR_Msk = 0x1f
	// Position of RESERVED field.
	EMC_STATICWAITWR_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	EMC_STATICWAITWR_RESERVED_Msk = 0xffffffe0

	// STATICWAITTURN0: Number of bus turnaround cycles EMC_CS0.
	// Position of WAITTURN field.
	EMC_STATICWAITTURN_WAITTURN_Pos = 0x0
	// Bit mask of WAITTURN field.
	EMC_STATICWAITTURN_WAITTURN_Msk = 0xf
	// Position of RESERVED field.
	EMC_STATICWAITTURN_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	EMC_STATICWAITTURN_RESERVED_Msk = 0xfffffff0
)

// Constants for WWDT: Windowed Watchdog Timer (WWDT)
const (
	// MOD: Watchdog mode register. This register determines the basic mode and status of the Watchdog Timer.
	// Position of WDEN field.
	WWDT_MOD_WDEN_Pos = 0x0
	// Bit mask of WDEN field.
	WWDT_MOD_WDEN_Msk = 0x1
	// Bit WDEN.
	WWDT_MOD_WDEN = 0x1
	// The watchdog timer is stopped.
	WWDT_MOD_WDEN_STOP = 0x0
	// The watchdog timer is running.
	WWDT_MOD_WDEN_RUN = 0x1
	// Position of WDRESET field.
	WWDT_MOD_WDRESET_Pos = 0x1
	// Bit mask of WDRESET field.
	WWDT_MOD_WDRESET_Msk = 0x2
	// Bit WDRESET.
	WWDT_MOD_WDRESET = 0x2
	// A watchdog timeout will not cause a chip reset.
	WWDT_MOD_WDRESET_NORESET = 0x0
	// A watchdog timeout will cause a chip reset.
	WWDT_MOD_WDRESET_RESET = 0x1
	// Position of WDTOF field.
	WWDT_MOD_WDTOF_Pos = 0x2
	// Bit mask of WDTOF field.
	WWDT_MOD_WDTOF_Msk = 0x4
	// Bit WDTOF.
	WWDT_MOD_WDTOF = 0x4
	// Position of WDINT field.
	WWDT_MOD_WDINT_Pos = 0x3
	// Bit mask of WDINT field.
	WWDT_MOD_WDINT_Msk = 0x8
	// Bit WDINT.
	WWDT_MOD_WDINT = 0x8
	// Position of WDPROTECT field.
	WWDT_MOD_WDPROTECT_Pos = 0x4
	// Bit mask of WDPROTECT field.
	WWDT_MOD_WDPROTECT_Msk = 0x10
	// Bit WDPROTECT.
	WWDT_MOD_WDPROTECT = 0x10
	// The watchdog reload value (WDTC) can be changed at any time.
	WWDT_MOD_WDPROTECT_CHANGE = 0x0
	// The watchdog reload value (WDTC) can be changed only after the counter is below the value of WDWARNINT and WDWINDOW. Note: this mode is intended for use only when WDRESET =1.
	WWDT_MOD_WDPROTECT_CHANGE_W_CNT = 0x1
	// Position of RESERVED field.
	WWDT_MOD_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	WWDT_MOD_RESERVED_Msk = 0xe0

	// TC: Watchdog timer constant register. The value in this register determines the time-out value.
	// Position of Count field.
	WWDT_TC_Count_Pos = 0x0
	// Bit mask of Count field.
	WWDT_TC_Count_Msk = 0xffffff
	// Position of RESERVED field.
	WWDT_TC_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	WWDT_TC_RESERVED_Msk = 0xff000000

	// FEED: Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in WDTC.
	// Position of Feed field.
	WWDT_FEED_Feed_Pos = 0x0
	// Bit mask of Feed field.
	WWDT_FEED_Feed_Msk = 0xff

	// TV: Watchdog timer value register. This register reads out the current value of the Watchdog timer.
	// Position of Count field.
	WWDT_TV_Count_Pos = 0x0
	// Bit mask of Count field.
	WWDT_TV_Count_Msk = 0xffffff
	// Position of RESERVED field.
	WWDT_TV_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	WWDT_TV_RESERVED_Msk = 0xff000000

	// WARNINT: Watchdog Warning Interrupt compare value.
	// Position of WARNINT field.
	WWDT_WARNINT_WARNINT_Pos = 0x0
	// Bit mask of WARNINT field.
	WWDT_WARNINT_WARNINT_Msk = 0x3ff
	// Position of RESERVED field.
	WWDT_WARNINT_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	WWDT_WARNINT_RESERVED_Msk = 0xfffffc00

	// WINDOW: Watchdog Window compare value.
	// Position of WINDOW field.
	WWDT_WINDOW_WINDOW_Pos = 0x0
	// Bit mask of WINDOW field.
	WWDT_WINDOW_WINDOW_Msk = 0xffffff
	// Position of RESERVED field.
	WWDT_WINDOW_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	WWDT_WINDOW_RESERVED_Msk = 0xff000000
)

// Constants for TIMER0: Timer0/1/2/3
const (
	// IR: Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending.
	// Position of MR0INT field.
	TIMER0_IR_MR0INT_Pos = 0x0
	// Bit mask of MR0INT field.
	TIMER0_IR_MR0INT_Msk = 0x1
	// Bit MR0INT.
	TIMER0_IR_MR0INT = 0x1
	// Position of MR1INT field.
	TIMER0_IR_MR1INT_Pos = 0x1
	// Bit mask of MR1INT field.
	TIMER0_IR_MR1INT_Msk = 0x2
	// Bit MR1INT.
	TIMER0_IR_MR1INT = 0x2
	// Position of MR2INT field.
	TIMER0_IR_MR2INT_Pos = 0x2
	// Bit mask of MR2INT field.
	TIMER0_IR_MR2INT_Msk = 0x4
	// Bit MR2INT.
	TIMER0_IR_MR2INT = 0x4
	// Position of MR3INT field.
	TIMER0_IR_MR3INT_Pos = 0x3
	// Bit mask of MR3INT field.
	TIMER0_IR_MR3INT_Msk = 0x8
	// Bit MR3INT.
	TIMER0_IR_MR3INT = 0x8
	// Position of CR0INT field.
	TIMER0_IR_CR0INT_Pos = 0x4
	// Bit mask of CR0INT field.
	TIMER0_IR_CR0INT_Msk = 0x10
	// Bit CR0INT.
	TIMER0_IR_CR0INT = 0x10
	// Position of CR1INT field.
	TIMER0_IR_CR1INT_Pos = 0x5
	// Bit mask of CR1INT field.
	TIMER0_IR_CR1INT_Msk = 0x20
	// Bit CR1INT.
	TIMER0_IR_CR1INT = 0x20
	// Position of RESERVED field.
	TIMER0_IR_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	TIMER0_IR_RESERVED_Msk = 0xffffffc0

	// TCR: Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR.
	// Position of CEN field.
	TIMER0_TCR_CEN_Pos = 0x0
	// Bit mask of CEN field.
	TIMER0_TCR_CEN_Msk = 0x1
	// Bit CEN.
	TIMER0_TCR_CEN = 0x1
	// Position of CRST field.
	TIMER0_TCR_CRST_Pos = 0x1
	// Bit mask of CRST field.
	TIMER0_TCR_CRST_Msk = 0x2
	// Bit CRST.
	TIMER0_TCR_CRST = 0x2
	// Position of RESERVED field.
	TIMER0_TCR_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	TIMER0_TCR_RESERVED_Msk = 0xfffffffc

	// TC: Timer Counter. The 32 bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR.
	// Position of TC field.
	TIMER0_TC_TC_Pos = 0x0
	// Bit mask of TC field.
	TIMER0_TC_TC_Msk = 0xffffffff

	// PR: Prescale Register. When the Prescale Counter (PC) is equal to this value, the next clock increments the TC and clears the PC.
	// Position of PM field.
	TIMER0_PR_PM_Pos = 0x0
	// Bit mask of PM field.
	TIMER0_PR_PM_Msk = 0xffffffff

	// PC: Prescale Counter. The 32 bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface.
	// Position of PC field.
	TIMER0_PC_PC_Pos = 0x0
	// Bit mask of PC field.
	TIMER0_PC_PC_Msk = 0xffffffff

	// MCR: Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs.
	// Position of MR0I field.
	TIMER0_MCR_MR0I_Pos = 0x0
	// Bit mask of MR0I field.
	TIMER0_MCR_MR0I_Msk = 0x1
	// Bit MR0I.
	TIMER0_MCR_MR0I = 0x1
	// Interrupt is generated when MR0 matches the value in the TC.
	TIMER0_MCR_MR0I_INTERRUPT_IS_GENERAT = 0x1
	// Interrupt is disabled
	TIMER0_MCR_MR0I_INTERRUPT_IS_DISABLE = 0x0
	// Position of MR0R field.
	TIMER0_MCR_MR0R_Pos = 0x1
	// Bit mask of MR0R field.
	TIMER0_MCR_MR0R_Msk = 0x2
	// Bit MR0R.
	TIMER0_MCR_MR0R = 0x2
	// TC will be reset if MR0 matches it.
	TIMER0_MCR_MR0R_TC_WILL_BE_RESET_IF_ = 0x1
	// Feature disabled.
	TIMER0_MCR_MR0R_FEATURE_DISABLED_ = 0x0
	// Position of MR0S field.
	TIMER0_MCR_MR0S_Pos = 0x2
	// Bit mask of MR0S field.
	TIMER0_MCR_MR0S_Msk = 0x4
	// Bit MR0S.
	TIMER0_MCR_MR0S = 0x4
	// TC and PC will be stopped and TCR[0] will be set to 0 if MR0 matches the TC.
	TIMER0_MCR_MR0S_TC_AND_PC_WILL_BE_ST = 0x1
	// Feature disabled.
	TIMER0_MCR_MR0S_FEATURE_DISABLED_ = 0x0
	// Position of MR1I field.
	TIMER0_MCR_MR1I_Pos = 0x3
	// Bit mask of MR1I field.
	TIMER0_MCR_MR1I_Msk = 0x8
	// Bit MR1I.
	TIMER0_MCR_MR1I = 0x8
	// Interrupt is generated when MR1 matches the value in the TC.
	TIMER0_MCR_MR1I_INTERRUPT_IS_GENERAT = 0x1
	// Interrupt is disabled.
	TIMER0_MCR_MR1I_INTERRUPT_IS_DISABLE = 0x0
	// Position of MR1R field.
	TIMER0_MCR_MR1R_Pos = 0x4
	// Bit mask of MR1R field.
	TIMER0_MCR_MR1R_Msk = 0x10
	// Bit MR1R.
	TIMER0_MCR_MR1R = 0x10
	// TC will be reset if MR1 matches it.
	TIMER0_MCR_MR1R_TC_WILL_BE_RESET_IF_ = 0x1
	// Feature disabled.
	TIMER0_MCR_MR1R_FEATURE_DISABLED_ = 0x0
	// Position of MR1S field.
	TIMER0_MCR_MR1S_Pos = 0x5
	// Bit mask of MR1S field.
	TIMER0_MCR_MR1S_Msk = 0x20
	// Bit MR1S.
	TIMER0_MCR_MR1S = 0x20
	// TC and PC will be stopped and TCR[0] will be set to 0 if MR1 matches the TC.
	TIMER0_MCR_MR1S_TC_AND_PC_WILL_BE_ST = 0x1
	// Feature disabled.
	TIMER0_MCR_MR1S_FEATURE_DISABLED_ = 0x0
	// Position of MR2I field.
	TIMER0_MCR_MR2I_Pos = 0x6
	// Bit mask of MR2I field.
	TIMER0_MCR_MR2I_Msk = 0x40
	// Bit MR2I.
	TIMER0_MCR_MR2I = 0x40
	// Interrupt is generated when MR2 matches the value in the TC.
	TIMER0_MCR_MR2I_INTERRUPT_IS_GENERAT = 0x1
	// Interrupt is disabled
	TIMER0_MCR_MR2I_INTERRUPT_IS_DISABLE = 0x0
	// Position of MR2R field.
	TIMER0_MCR_MR2R_Pos = 0x7
	// Bit mask of MR2R field.
	TIMER0_MCR_MR2R_Msk = 0x80
	// Bit MR2R.
	TIMER0_MCR_MR2R = 0x80
	// TC will be reset if MR2 matches it.
	TIMER0_MCR_MR2R_TC_WILL_BE_RESET_IF_ = 0x1
	// Feature disabled.
	TIMER0_MCR_MR2R_FEATURE_DISABLED_ = 0x0
	// Position of MR2S field.
	TIMER0_MCR_MR2S_Pos = 0x8
	// Bit mask of MR2S field.
	TIMER0_MCR_MR2S_Msk = 0x100
	// Bit MR2S.
	TIMER0_MCR_MR2S = 0x100
	// TC and PC will be stopped and TCR[0] will be set to 0 if MR2 matches the TC
	TIMER0_MCR_MR2S_TC_AND_PC_WILL_BE_ST = 0x1
	// Feature disabled.
	TIMER0_MCR_MR2S_FEATURE_DISABLED_ = 0x0
	// Position of MR3I field.
	TIMER0_MCR_MR3I_Pos = 0x9
	// Bit mask of MR3I field.
	TIMER0_MCR_MR3I_Msk = 0x200
	// Bit MR3I.
	TIMER0_MCR_MR3I = 0x200
	// Interrupt is generated when MR3 matches the value in the TC.
	TIMER0_MCR_MR3I_INTERRUPT_IS_GENERAT = 0x1
	// This interrupt is disabled
	TIMER0_MCR_MR3I_THIS_INTERRUPT_IS_DI = 0x0
	// Position of MR3R field.
	TIMER0_MCR_MR3R_Pos = 0xa
	// Bit mask of MR3R field.
	TIMER0_MCR_MR3R_Msk = 0x400
	// Bit MR3R.
	TIMER0_MCR_MR3R = 0x400
	// TC will be reset if MR3 matches it.
	TIMER0_MCR_MR3R_TC_WILL_BE_RESET_IF_ = 0x1
	// Feature disabled.
	TIMER0_MCR_MR3R_FEATURE_DISABLED_ = 0x0
	// Position of MR3S field.
	TIMER0_MCR_MR3S_Pos = 0xb
	// Bit mask of MR3S field.
	TIMER0_MCR_MR3S_Msk = 0x800
	// Bit MR3S.
	TIMER0_MCR_MR3S = 0x800
	// TC and PC will be stopped and TCR[0] will be set to 0 if MR3 matches the TC.
	TIMER0_MCR_MR3S_TC_AND_PC_WILL_BE_ST = 0x1
	// Feature disabled.
	TIMER0_MCR_MR3S_FEATURE_DISABLED_ = 0x0
	// Position of RESERVED field.
	TIMER0_MCR_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	TIMER0_MCR_RESERVED_Msk = 0xfffff000

	// MR: Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
	// Position of MATCH field.
	TIMER0_MR_MATCH_Pos = 0x0
	// Bit mask of MATCH field.
	TIMER0_MR_MATCH_Msk = 0xffffffff

	// CCR: Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place.
	// Position of CAP0RE field.
	TIMER0_CCR_CAP0RE_Pos = 0x0
	// Bit mask of CAP0RE field.
	TIMER0_CCR_CAP0RE_Msk = 0x1
	// Bit CAP0RE.
	TIMER0_CCR_CAP0RE = 0x1
	// A sequence of 0 then 1 on CAPn.0 will cause CR0 to be loaded with the contents of TC.
	TIMER0_CCR_CAP0RE_ENABLE = 0x1
	// This feature is disabled.
	TIMER0_CCR_CAP0RE_DISABLE = 0x0
	// Position of CAP0FE field.
	TIMER0_CCR_CAP0FE_Pos = 0x1
	// Bit mask of CAP0FE field.
	TIMER0_CCR_CAP0FE_Msk = 0x2
	// Bit CAP0FE.
	TIMER0_CCR_CAP0FE = 0x2
	// A sequence of 1 then 0 on CAPn.0 will cause CR0 to be loaded with the contents of TC.
	TIMER0_CCR_CAP0FE_ENABLE = 0x1
	// This feature is disabled.
	TIMER0_CCR_CAP0FE_DISABLE = 0x0
	// Position of CAP0I field.
	TIMER0_CCR_CAP0I_Pos = 0x2
	// Bit mask of CAP0I field.
	TIMER0_CCR_CAP0I_Msk = 0x4
	// Bit CAP0I.
	TIMER0_CCR_CAP0I = 0x4
	// A CR0 load due to a CAPn.0 event will generate an interrupt.
	TIMER0_CCR_CAP0I_ENABLE = 0x1
	// This feature is disabled.
	TIMER0_CCR_CAP0I_DISABLE = 0x0
	// Position of CAP1RE field.
	TIMER0_CCR_CAP1RE_Pos = 0x3
	// Bit mask of CAP1RE field.
	TIMER0_CCR_CAP1RE_Msk = 0x8
	// Bit CAP1RE.
	TIMER0_CCR_CAP1RE = 0x8
	// A sequence of 0 then 1 on CAPn.1 will cause CR1 to be loaded with the contents of TC.
	TIMER0_CCR_CAP1RE_ENABLE = 0x1
	// This feature is disabled.
	TIMER0_CCR_CAP1RE_DISABLE = 0x0
	// Position of CAP1FE field.
	TIMER0_CCR_CAP1FE_Pos = 0x4
	// Bit mask of CAP1FE field.
	TIMER0_CCR_CAP1FE_Msk = 0x10
	// Bit CAP1FE.
	TIMER0_CCR_CAP1FE = 0x10
	// A sequence of 1 then 0 on CAPn.1 will cause CR1 to be loaded with the contents of TC.
	TIMER0_CCR_CAP1FE_ENABLE = 0x1
	// This feature is disabled.
	TIMER0_CCR_CAP1FE_DISABLE = 0x0
	// Position of CAP1I field.
	TIMER0_CCR_CAP1I_Pos = 0x5
	// Bit mask of CAP1I field.
	TIMER0_CCR_CAP1I_Msk = 0x20
	// Bit CAP1I.
	TIMER0_CCR_CAP1I = 0x20
	// A CR1 load due to a CAPn.1 event will generate an interrupt.
	TIMER0_CCR_CAP1I_ENABLE = 0x1
	// This feature is disabled.
	TIMER0_CCR_CAP1I_DISABLE = 0x0
	// Position of RESERVED field.
	TIMER0_CCR_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	TIMER0_CCR_RESERVED_Msk = 0xffffffc0

	// CR: Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CAPn.0 input.
	// Position of CAP field.
	TIMER0_CR_CAP_Pos = 0x0
	// Bit mask of CAP field.
	TIMER0_CR_CAP_Msk = 0xffffffff

	// EMR: External Match Register. The EMR controls the external match pins.
	// Position of EM0 field.
	TIMER0_EMR_EM0_Pos = 0x0
	// Bit mask of EM0 field.
	TIMER0_EMR_EM0_Msk = 0x1
	// Bit EM0.
	TIMER0_EMR_EM0 = 0x1
	// Position of EM1 field.
	TIMER0_EMR_EM1_Pos = 0x1
	// Bit mask of EM1 field.
	TIMER0_EMR_EM1_Msk = 0x2
	// Bit EM1.
	TIMER0_EMR_EM1 = 0x2
	// Position of EM2 field.
	TIMER0_EMR_EM2_Pos = 0x2
	// Bit mask of EM2 field.
	TIMER0_EMR_EM2_Msk = 0x4
	// Bit EM2.
	TIMER0_EMR_EM2 = 0x4
	// Position of EM3 field.
	TIMER0_EMR_EM3_Pos = 0x3
	// Bit mask of EM3 field.
	TIMER0_EMR_EM3_Msk = 0x8
	// Bit EM3.
	TIMER0_EMR_EM3 = 0x8
	// Position of EMC0 field.
	TIMER0_EMR_EMC0_Pos = 0x4
	// Bit mask of EMC0 field.
	TIMER0_EMR_EMC0_Msk = 0x30
	// Do Nothing.
	TIMER0_EMR_EMC0_DO_NOTHING_ = 0x0
	// Clear the corresponding External Match bit/output to 0 (MATn.m pin is LOW if pinned out).
	TIMER0_EMR_EMC0_CLEAR_THE_CORRESPOND = 0x1
	// Set the corresponding External Match bit/output to 1 (MATn.m pin is HIGH if pinned out).
	TIMER0_EMR_EMC0_SET_THE_CORRESPONDIN = 0x2
	// Toggle the corresponding External Match bit/output.
	TIMER0_EMR_EMC0_TOGGLE_THE_CORRESPON = 0x3
	// Position of EMC1 field.
	TIMER0_EMR_EMC1_Pos = 0x6
	// Bit mask of EMC1 field.
	TIMER0_EMR_EMC1_Msk = 0xc0
	// Do Nothing.
	TIMER0_EMR_EMC1_DO_NOTHING_ = 0x0
	// Clear the corresponding External Match bit/output to 0 (MATn.m pin is LOW if pinned out).
	TIMER0_EMR_EMC1_CLEAR_THE_CORRESPOND = 0x1
	// Set the corresponding External Match bit/output to 1 (MATn.m pin is HIGH if pinned out).
	TIMER0_EMR_EMC1_SET_THE_CORRESPONDIN = 0x2
	// Toggle the corresponding External Match bit/output.
	TIMER0_EMR_EMC1_TOGGLE_THE_CORRESPON = 0x3
	// Position of EMC2 field.
	TIMER0_EMR_EMC2_Pos = 0x8
	// Bit mask of EMC2 field.
	TIMER0_EMR_EMC2_Msk = 0x300
	// Do Nothing.
	TIMER0_EMR_EMC2_DO_NOTHING_ = 0x0
	// Clear the corresponding External Match bit/output to 0 (MATn.m pin is LOW if pinned out).
	TIMER0_EMR_EMC2_CLEAR_THE_CORRESPOND = 0x1
	// Set the corresponding External Match bit/output to 1 (MATn.m pin is HIGH if pinned out).
	TIMER0_EMR_EMC2_SET_THE_CORRESPONDIN = 0x2
	// Toggle the corresponding External Match bit/output.
	TIMER0_EMR_EMC2_TOGGLE_THE_CORRESPON = 0x3
	// Position of EMC3 field.
	TIMER0_EMR_EMC3_Pos = 0xa
	// Bit mask of EMC3 field.
	TIMER0_EMR_EMC3_Msk = 0xc00
	// Do Nothing.
	TIMER0_EMR_EMC3_DO_NOTHING_ = 0x0
	// Clear the corresponding External Match bit/output to 0 (MATn.m pin is LOW if pinned out).
	TIMER0_EMR_EMC3_CLEAR_THE_CORRESPOND = 0x1
	// Set the corresponding External Match bit/output to 1 (MATn.m pin is HIGH if pinned out).
	TIMER0_EMR_EMC3_SET_THE_CORRESPONDIN = 0x2
	// Toggle the corresponding External Match bit/output.
	TIMER0_EMR_EMC3_TOGGLE_THE_CORRESPON = 0x3
	// Position of RESERVED field.
	TIMER0_EMR_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	TIMER0_EMR_RESERVED_Msk = 0xfffff000

	// CTCR: Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.
	// Position of CTMODE field.
	TIMER0_CTCR_CTMODE_Pos = 0x0
	// Bit mask of CTMODE field.
	TIMER0_CTCR_CTMODE_Msk = 0x3
	// Timer Mode: every rising PCLK edge
	TIMER0_CTCR_CTMODE_TIMER_MODE_EVERY_RI = 0x0
	// Counter Mode: TC is incremented on rising edges on the CAP input selected by bits 3:2.
	TIMER0_CTCR_CTMODE_RISING = 0x1
	// Counter Mode: TC is incremented on falling edges on the CAP input selected by bits 3:2.
	TIMER0_CTCR_CTMODE_FALLING = 0x2
	// Counter Mode: TC is incremented on both edges on the CAP input selected by bits 3:2.
	TIMER0_CTCR_CTMODE_DUALEDGE = 0x3
	// Position of CINSEL field.
	TIMER0_CTCR_CINSEL_Pos = 0x2
	// Bit mask of CINSEL field.
	TIMER0_CTCR_CINSEL_Msk = 0xc
	// CAPn.0 for TIMERn
	TIMER0_CTCR_CINSEL_CAPN_0_FOR_TIMERN = 0x0
	// CAPn.1 for TIMERn
	TIMER0_CTCR_CINSEL_CAPN_1_FOR_TIMERN = 0x1
	// Position of RESERVED field.
	TIMER0_CTCR_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	TIMER0_CTCR_RESERVED_Msk = 0xfffffff0
)

// Constants for UART0: UART0/2/3
const (
	// RBR: Receiver Buffer Register. Contains the next received character to be read (DLAB =0).
	// Position of RBR field.
	UART0_RBR_RBR_Pos = 0x0
	// Bit mask of RBR field.
	UART0_RBR_RBR_Msk = 0xff
	// Position of RESERVED field.
	UART0_RBR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART0_RBR_RESERVED_Msk = 0xffffff00

	// THR: Transmit Holding Regiter. The next character to be transmitted is written here (DLAB =0).
	// Position of THR field.
	UART0_THR_THR_Pos = 0x0
	// Bit mask of THR field.
	UART0_THR_THR_Msk = 0xff
	// Position of RESERVED field.
	UART0_THR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART0_THR_RESERVED_Msk = 0xffffff00

	// DLL: Divisor Latch LSB. Least significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider (DLAB =1).
	// Position of DLLSB field.
	UART0_DLL_DLLSB_Pos = 0x0
	// Bit mask of DLLSB field.
	UART0_DLL_DLLSB_Msk = 0xff
	// Position of RESERVED field.
	UART0_DLL_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART0_DLL_RESERVED_Msk = 0xffffff00

	// DLM: Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider (DLAB =1).
	// Position of DLMSB field.
	UART0_DLM_DLMSB_Pos = 0x0
	// Bit mask of DLMSB field.
	UART0_DLM_DLMSB_Msk = 0xff
	// Position of RESERVED field.
	UART0_DLM_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART0_DLM_RESERVED_Msk = 0xffffff00

	// IER: Interrupt Enable Register. Contains individual interrupt enable bits for the 7 potential UART interrupts (DLAB =0).
	// Position of RBRIE field.
	UART0_IER_RBRIE_Pos = 0x0
	// Bit mask of RBRIE field.
	UART0_IER_RBRIE_Msk = 0x1
	// Bit RBRIE.
	UART0_IER_RBRIE = 0x1
	// Disable the RDA interrupts.
	UART0_IER_RBRIE_DISABLE_THE_RDA_INTE = 0x0
	// Enable the RDA interrupts.
	UART0_IER_RBRIE_ENABLE_THE_RDA_INTER = 0x1
	// Position of THREIE field.
	UART0_IER_THREIE_Pos = 0x1
	// Bit mask of THREIE field.
	UART0_IER_THREIE_Msk = 0x2
	// Bit THREIE.
	UART0_IER_THREIE = 0x2
	// Disable the THRE interrupts.
	UART0_IER_THREIE_DISABLE_THE_THRE_INT = 0x0
	// Enable the THRE interrupts.
	UART0_IER_THREIE_ENABLE_THE_THRE_INTE = 0x1
	// Position of RXIE field.
	UART0_IER_RXIE_Pos = 0x2
	// Bit mask of RXIE field.
	UART0_IER_RXIE_Msk = 0x4
	// Bit RXIE.
	UART0_IER_RXIE = 0x4
	// Disable the RX line status interrupts.
	UART0_IER_RXIE_DISABLE_THE_RX_LINE_ = 0x0
	// Enable the RX line status interrupts.
	UART0_IER_RXIE_ENABLE_THE_RX_LINE_S = 0x1
	// Position of RESERVED field.
	UART0_IER_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	UART0_IER_RESERVED_Msk = 0xf8
	// Position of ABEOINTEN field.
	UART0_IER_ABEOINTEN_Pos = 0x8
	// Bit mask of ABEOINTEN field.
	UART0_IER_ABEOINTEN_Msk = 0x100
	// Bit ABEOINTEN.
	UART0_IER_ABEOINTEN = 0x100
	// Disable end of auto-baud Interrupt.
	UART0_IER_ABEOINTEN_DISABLE_END_OF_AUTO_ = 0x0
	// Enable end of auto-baud Interrupt.
	UART0_IER_ABEOINTEN_ENABLE_END_OF_AUTO_B = 0x1
	// Position of ABTOINTEN field.
	UART0_IER_ABTOINTEN_Pos = 0x9
	// Bit mask of ABTOINTEN field.
	UART0_IER_ABTOINTEN_Msk = 0x200
	// Bit ABTOINTEN.
	UART0_IER_ABTOINTEN = 0x200
	// Disable auto-baud time-out Interrupt.
	UART0_IER_ABTOINTEN_DISABLE_AUTO_BAUD_TI = 0x0
	// Enable auto-baud time-out Interrupt.
	UART0_IER_ABTOINTEN_ENABLE_AUTO_BAUD_TIM = 0x1
	// Position of RESERVED field.
	UART0_IER_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	UART0_IER_RESERVED_Msk = 0xfffffc00

	// IIR: Interrupt ID Register. Identifies which interrupt(s) are pending.
	// Position of INTSTATUS field.
	UART0_IIR_INTSTATUS_Pos = 0x0
	// Bit mask of INTSTATUS field.
	UART0_IIR_INTSTATUS_Msk = 0x1
	// Bit INTSTATUS.
	UART0_IIR_INTSTATUS = 0x1
	// At least one interrupt is pending.
	UART0_IIR_INTSTATUS_AT_LEAST_ONE_INTERRU = 0x0
	// No interrupt is pending.
	UART0_IIR_INTSTATUS_NO_INTERRUPT_IS_PEND = 0x1
	// Position of INTID field.
	UART0_IIR_INTID_Pos = 0x1
	// Bit mask of INTID field.
	UART0_IIR_INTID_Msk = 0xe
	// 1 - Receive Line Status (RLS).
	UART0_IIR_INTID_1_RECEIVE_LINE_S = 0x3
	// 2a - Receive Data Available (RDA).
	UART0_IIR_INTID_2A__RECEIVE_DATA_AV = 0x2
	// 2b - Character Time-out Indicator (CTI).
	UART0_IIR_INTID_2B__CHARACTER_TIME_ = 0x6
	// 3 - THRE Interrupt
	UART0_IIR_INTID_3_THRE_INTERRUPT = 0x1
	// Position of RESERVED field.
	UART0_IIR_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	UART0_IIR_RESERVED_Msk = 0x30
	// Position of FIFOENABLE field.
	UART0_IIR_FIFOENABLE_Pos = 0x6
	// Bit mask of FIFOENABLE field.
	UART0_IIR_FIFOENABLE_Msk = 0xc0
	// Position of ABEOINT field.
	UART0_IIR_ABEOINT_Pos = 0x8
	// Bit mask of ABEOINT field.
	UART0_IIR_ABEOINT_Msk = 0x100
	// Bit ABEOINT.
	UART0_IIR_ABEOINT = 0x100
	// Position of ABTOINT field.
	UART0_IIR_ABTOINT_Pos = 0x9
	// Bit mask of ABTOINT field.
	UART0_IIR_ABTOINT_Msk = 0x200
	// Bit ABTOINT.
	UART0_IIR_ABTOINT = 0x200
	// Position of RESERVED field.
	UART0_IIR_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	UART0_IIR_RESERVED_Msk = 0xfffffc00

	// FCR: FIFO Control Register. Controls UART FIFO usage and modes.
	// Position of FIFOEN field.
	UART0_FCR_FIFOEN_Pos = 0x0
	// Bit mask of FIFOEN field.
	UART0_FCR_FIFOEN_Msk = 0x1
	// Bit FIFOEN.
	UART0_FCR_FIFOEN = 0x1
	// UARTn FIFOs are disabled. Must not be used in the application.
	UART0_FCR_FIFOEN_UARTN_FIFOS_ARE_DISA = 0x0
	// Active high enable for both UARTn Rx and TX FIFOs and UnFCR[7:1] access. This bit must be set for proper UART operation. Any transition on this bit will automatically clear the related UART FIFOs.
	UART0_FCR_FIFOEN_ACTIVE_HIGH_ENABLE_F = 0x1
	// Position of RXFIFORES field.
	UART0_FCR_RXFIFORES_Pos = 0x1
	// Bit mask of RXFIFORES field.
	UART0_FCR_RXFIFORES_Msk = 0x2
	// Bit RXFIFORES.
	UART0_FCR_RXFIFORES = 0x2
	// No impact on either of UARTn FIFOs.
	UART0_FCR_RXFIFORES_NO_IMPACT_ON_EITHER_ = 0x0
	// Writing a logic 1 to UnFCR[1] will clear all bytes in UARTn Rx FIFO, reset the pointer logic. This bit is self-clearing.
	UART0_FCR_RXFIFORES_WRITING_A_LOGIC_1_TO = 0x1
	// Position of TXFIFORES field.
	UART0_FCR_TXFIFORES_Pos = 0x2
	// Bit mask of TXFIFORES field.
	UART0_FCR_TXFIFORES_Msk = 0x4
	// Bit TXFIFORES.
	UART0_FCR_TXFIFORES = 0x4
	// No impact on either of UARTn FIFOs.
	UART0_FCR_TXFIFORES_NO_IMPACT_ON_EITHER_ = 0x0
	// Writing a logic 1 to UnFCR[2] will clear all bytes in UARTn TX FIFO, reset the pointer logic. This bit is self-clearing.
	UART0_FCR_TXFIFORES_WRITING_A_LOGIC_1_TO = 0x1
	// Position of DMAMODE field.
	UART0_FCR_DMAMODE_Pos = 0x3
	// Bit mask of DMAMODE field.
	UART0_FCR_DMAMODE_Msk = 0x8
	// Bit DMAMODE.
	UART0_FCR_DMAMODE = 0x8
	// Position of RESERVED field.
	UART0_FCR_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	UART0_FCR_RESERVED_Msk = 0x30
	// Position of RXTRIGLVL field.
	UART0_FCR_RXTRIGLVL_Pos = 0x6
	// Bit mask of RXTRIGLVL field.
	UART0_FCR_RXTRIGLVL_Msk = 0xc0
	// Trigger level 0 (1 character or 0x01).
	UART0_FCR_RXTRIGLVL_TRIGGER_LEVEL_0_1_C = 0x0
	// Trigger level 1 (4 characters or 0x04).
	UART0_FCR_RXTRIGLVL_TRIGGER_LEVEL_1_4_C = 0x1
	// Trigger level 2 (8 characters or 0x08).
	UART0_FCR_RXTRIGLVL_TRIGGER_LEVEL_2_8_C = 0x2
	// Trigger level 3 (14 characters or 0x0E).
	UART0_FCR_RXTRIGLVL_TRIGGER_LEVEL_3_14_ = 0x3
	// Position of RESERVED field.
	UART0_FCR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART0_FCR_RESERVED_Msk = 0xffffff00

	// LCR: Line Control Register. Contains controls for frame formatting and break generation.
	// Position of WLS field.
	UART0_LCR_WLS_Pos = 0x0
	// Bit mask of WLS field.
	UART0_LCR_WLS_Msk = 0x3
	// 5-bit character length
	UART0_LCR_WLS_5_BIT_CHARACTER_LENG = 0x0
	// 6-bit character length
	UART0_LCR_WLS_6_BIT_CHARACTER_LENG = 0x1
	// 7-bit character length
	UART0_LCR_WLS_7_BIT_CHARACTER_LENG = 0x2
	// 8-bit character length
	UART0_LCR_WLS_8_BIT_CHARACTER_LENG = 0x3
	// Position of SBS field.
	UART0_LCR_SBS_Pos = 0x2
	// Bit mask of SBS field.
	UART0_LCR_SBS_Msk = 0x4
	// Bit SBS.
	UART0_LCR_SBS = 0x4
	// 1 stop bit.
	UART0_LCR_SBS_1_STOP_BIT_ = 0x0
	// 2 stop bits (1.5 if UnLCR[1:0]=00).
	UART0_LCR_SBS_2_STOP_BITS_1_5_IF_ = 0x1
	// Position of PE field.
	UART0_LCR_PE_Pos = 0x3
	// Bit mask of PE field.
	UART0_LCR_PE_Msk = 0x8
	// Bit PE.
	UART0_LCR_PE = 0x8
	// Disable parity generation and checking.
	UART0_LCR_PE_DISABLE_PARITY_GENER = 0x0
	// Enable parity generation and checking.
	UART0_LCR_PE_ENABLE_PARITY_GENERA = 0x1
	// Position of PS field.
	UART0_LCR_PS_Pos = 0x4
	// Bit mask of PS field.
	UART0_LCR_PS_Msk = 0x30
	// Odd parity. Number of 1s in the transmitted character and the attached parity bit will be odd.
	UART0_LCR_PS_ODD_PARITY_NUMBER_O = 0x0
	// Even Parity. Number of 1s in the transmitted character and the attached parity bit will be even.
	UART0_LCR_PS_EVEN_PARITY_NUMBER_ = 0x1
	// Forced 1 stick parity.
	UART0_LCR_PS_FORCED_1_STICK_PARIT = 0x2
	// Forced 0 stick parity.
	UART0_LCR_PS_FORCED_0_STICK_PARIT = 0x3
	// Position of BC field.
	UART0_LCR_BC_Pos = 0x6
	// Bit mask of BC field.
	UART0_LCR_BC_Msk = 0x40
	// Bit BC.
	UART0_LCR_BC = 0x40
	// Disable break transmission.
	UART0_LCR_BC_DISABLE_BREAK_TRANSM = 0x0
	// Enable break transmission. Output pin UARTn TXD is forced to logic 0 when UnLCR[6] is active high.
	UART0_LCR_BC_ENABLE_BREAK_TRANSMI = 0x1
	// Position of DLAB field.
	UART0_LCR_DLAB_Pos = 0x7
	// Bit mask of DLAB field.
	UART0_LCR_DLAB_Msk = 0x80
	// Bit DLAB.
	UART0_LCR_DLAB = 0x80
	// Disable access to Divisor Latches.
	UART0_LCR_DLAB_DISABLE_ACCESS_TO_DI = 0x0
	// Enable access to Divisor Latches.
	UART0_LCR_DLAB_ENABLE_ACCESS_TO_DIV = 0x1
	// Position of RESERVED field.
	UART0_LCR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART0_LCR_RESERVED_Msk = 0xffffff00

	// LSR: Line Status Register. Contains flags for transmit and receive status, including line errors.
	// Position of RDR field.
	UART0_LSR_RDR_Pos = 0x0
	// Bit mask of RDR field.
	UART0_LSR_RDR_Msk = 0x1
	// Bit RDR.
	UART0_LSR_RDR = 0x1
	// The UARTn receiver FIFO is empty.
	UART0_LSR_RDR_EMPTY = 0x0
	// The UARTn receiver FIFO is not empty.
	UART0_LSR_RDR_NOTEMPTY = 0x1
	// Position of OE field.
	UART0_LSR_OE_Pos = 0x1
	// Bit mask of OE field.
	UART0_LSR_OE_Msk = 0x2
	// Bit OE.
	UART0_LSR_OE = 0x2
	// Overrun error status is inactive.
	UART0_LSR_OE_INACTIVE = 0x0
	// Overrun error status is active.
	UART0_LSR_OE_ACTIVE = 0x1
	// Position of PE field.
	UART0_LSR_PE_Pos = 0x2
	// Bit mask of PE field.
	UART0_LSR_PE_Msk = 0x4
	// Bit PE.
	UART0_LSR_PE = 0x4
	// Parity error status is inactive.
	UART0_LSR_PE_INACTIVE = 0x0
	// Parity error status is active.
	UART0_LSR_PE_ACTIVE = 0x1
	// Position of FE field.
	UART0_LSR_FE_Pos = 0x3
	// Bit mask of FE field.
	UART0_LSR_FE_Msk = 0x8
	// Bit FE.
	UART0_LSR_FE = 0x8
	// Framing error status is inactive.
	UART0_LSR_FE_INACTIVE = 0x0
	// Framing error status is active.
	UART0_LSR_FE_ACTIVE = 0x1
	// Position of BI field.
	UART0_LSR_BI_Pos = 0x4
	// Bit mask of BI field.
	UART0_LSR_BI_Msk = 0x10
	// Bit BI.
	UART0_LSR_BI = 0x10
	// Break interrupt status is inactive.
	UART0_LSR_BI_INACTIVE = 0x0
	// Break interrupt status is active.
	UART0_LSR_BI_ACTIVE = 0x1
	// Position of THRE field.
	UART0_LSR_THRE_Pos = 0x5
	// Bit mask of THRE field.
	UART0_LSR_THRE_Msk = 0x20
	// Bit THRE.
	UART0_LSR_THRE = 0x20
	// UnTHR contains valid data.
	UART0_LSR_THRE_VALIDDATA = 0x0
	// UnTHR is empty.
	UART0_LSR_THRE_EMPTY = 0x1
	// Position of TEMT field.
	UART0_LSR_TEMT_Pos = 0x6
	// Bit mask of TEMT field.
	UART0_LSR_TEMT_Msk = 0x40
	// Bit TEMT.
	UART0_LSR_TEMT = 0x40
	// UnTHR and/or the UnTSR contains valid data.
	UART0_LSR_TEMT_VALIDDATA = 0x0
	// UnTHR and the UnTSR are empty.
	UART0_LSR_TEMT_EMPTY = 0x1
	// Position of RXFE field.
	UART0_LSR_RXFE_Pos = 0x7
	// Bit mask of RXFE field.
	UART0_LSR_RXFE_Msk = 0x80
	// Bit RXFE.
	UART0_LSR_RXFE = 0x80
	// UnRBR contains no UARTn RX errors or UnFCR[0]=0.
	UART0_LSR_RXFE_NOERROR = 0x0
	// UARTn RBR contains at least one UARTn RX error.
	UART0_LSR_RXFE_ERRORS = 0x1
	// Position of RESERVED field.
	UART0_LSR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART0_LSR_RESERVED_Msk = 0xffffff00

	// SCR: Scratch Pad Register. 8-bit temporary storage for software.
	// Position of PAD field.
	UART0_SCR_PAD_Pos = 0x0
	// Bit mask of PAD field.
	UART0_SCR_PAD_Msk = 0xff
	// Position of RESERVED field.
	UART0_SCR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART0_SCR_RESERVED_Msk = 0xffffff00

	// ACR: Auto-baud Control Register. Contains controls for the auto-baud feature.
	// Position of START field.
	UART0_ACR_START_Pos = 0x0
	// Bit mask of START field.
	UART0_ACR_START_Msk = 0x1
	// Bit START.
	UART0_ACR_START = 0x1
	// Auto-baud stop (auto-baud is not running).
	UART0_ACR_START_AUTO_BAUD_STOP_AUTO = 0x0
	// Auto-baud start (auto-baud is running). Auto-baud run bit. This bit is automatically cleared after auto-baud completion.
	UART0_ACR_START_AUTO_BAUD_START_AUT = 0x1
	// Position of MODE field.
	UART0_ACR_MODE_Pos = 0x1
	// Bit mask of MODE field.
	UART0_ACR_MODE_Msk = 0x2
	// Bit MODE.
	UART0_ACR_MODE = 0x2
	// Mode 0.
	UART0_ACR_MODE_MODE_0_ = 0x0
	// Mode 1.
	UART0_ACR_MODE_MODE_1_ = 0x1
	// Position of AUTORESTART field.
	UART0_ACR_AUTORESTART_Pos = 0x2
	// Bit mask of AUTORESTART field.
	UART0_ACR_AUTORESTART_Msk = 0x4
	// Bit AUTORESTART.
	UART0_ACR_AUTORESTART = 0x4
	// No restart.
	UART0_ACR_AUTORESTART_NO_RESTART_ = 0x0
	// Restart in case of time-out (counter restarts at next UARTn Rx falling edge)
	UART0_ACR_AUTORESTART_RESTART_IN_CASE_OF_T = 0x1
	// Position of RESERVED field.
	UART0_ACR_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	UART0_ACR_RESERVED_Msk = 0xf8
	// Position of ABEOINTCLR field.
	UART0_ACR_ABEOINTCLR_Pos = 0x8
	// Bit mask of ABEOINTCLR field.
	UART0_ACR_ABEOINTCLR_Msk = 0x100
	// Bit ABEOINTCLR.
	UART0_ACR_ABEOINTCLR = 0x100
	// No impact.
	UART0_ACR_ABEOINTCLR_NO_IMPACT_ = 0x0
	// Clear the corresponding interrupt in the IIR.
	UART0_ACR_ABEOINTCLR_CLEAR_THE_CORRESPOND = 0x1
	// Position of ABTOINTCLR field.
	UART0_ACR_ABTOINTCLR_Pos = 0x9
	// Bit mask of ABTOINTCLR field.
	UART0_ACR_ABTOINTCLR_Msk = 0x200
	// Bit ABTOINTCLR.
	UART0_ACR_ABTOINTCLR = 0x200
	// No impact.
	UART0_ACR_ABTOINTCLR_NO_IMPACT_ = 0x0
	// Clear the corresponding interrupt in the IIR.
	UART0_ACR_ABTOINTCLR_CLEAR_THE_CORRESPOND = 0x1
	// Position of RESERVED field.
	UART0_ACR_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	UART0_ACR_RESERVED_Msk = 0xfffffc00

	// FDR: Fractional Divider Register. Generates a clock input for the baud rate divider.
	// Position of DIVADDVAL field.
	UART0_FDR_DIVADDVAL_Pos = 0x0
	// Bit mask of DIVADDVAL field.
	UART0_FDR_DIVADDVAL_Msk = 0xf
	// Position of MULVAL field.
	UART0_FDR_MULVAL_Pos = 0x4
	// Bit mask of MULVAL field.
	UART0_FDR_MULVAL_Msk = 0xf0
	// Position of RESERVED field.
	UART0_FDR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART0_FDR_RESERVED_Msk = 0xffffff00

	// TER: Transmit Enable Register. Turns off UART transmitter for use with software flow control.
	// Position of RESERVED field.
	UART0_TER_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	UART0_TER_RESERVED_Msk = 0x7f
	// Position of TXEN field.
	UART0_TER_TXEN_Pos = 0x7
	// Bit mask of TXEN field.
	UART0_TER_TXEN_Msk = 0x80
	// Bit TXEN.
	UART0_TER_TXEN = 0x80
	// Position of RESERVED field.
	UART0_TER_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART0_TER_RESERVED_Msk = 0xffffff00

	// RS485CTRL: RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes.
	// Position of NMMEN field.
	UART0_RS485CTRL_NMMEN_Pos = 0x0
	// Bit mask of NMMEN field.
	UART0_RS485CTRL_NMMEN_Msk = 0x1
	// Bit NMMEN.
	UART0_RS485CTRL_NMMEN = 0x1
	// RS-485/EIA-485 Normal Multidrop Mode (NMM) is disabled.
	UART0_RS485CTRL_NMMEN_DISABLED = 0x0
	// RS-485/EIA-485 Normal Multidrop Mode (NMM) is enabled. In this mode, an address is detected when a received byte has the parity bit = 1, generating a received data interrupt. See Section 18.6.16 RS-485/EIA-485 modes of operation.
	UART0_RS485CTRL_NMMEN_ENABLED = 0x1
	// Position of RXDIS field.
	UART0_RS485CTRL_RXDIS_Pos = 0x1
	// Bit mask of RXDIS field.
	UART0_RS485CTRL_RXDIS_Msk = 0x2
	// Bit RXDIS.
	UART0_RS485CTRL_RXDIS = 0x2
	// The receiver is enabled.
	UART0_RS485CTRL_RXDIS_ENABLED = 0x0
	// The receiver is disabled.
	UART0_RS485CTRL_RXDIS_DISABLED = 0x1
	// Position of AADEN field.
	UART0_RS485CTRL_AADEN_Pos = 0x2
	// Bit mask of AADEN field.
	UART0_RS485CTRL_AADEN_Msk = 0x4
	// Bit AADEN.
	UART0_RS485CTRL_AADEN = 0x4
	// Auto Address Detect (AAD) is disabled.
	UART0_RS485CTRL_AADEN_DISABLED = 0x0
	// Auto Address Detect (AAD) is enabled.
	UART0_RS485CTRL_AADEN_ENABLED = 0x1
	// Position of RESERVED field.
	UART0_RS485CTRL_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	UART0_RS485CTRL_RESERVED_Msk = 0x8
	// Bit RESERVED.
	UART0_RS485CTRL_RESERVED = 0x8
	// Position of DCTRL field.
	UART0_RS485CTRL_DCTRL_Pos = 0x4
	// Bit mask of DCTRL field.
	UART0_RS485CTRL_DCTRL_Msk = 0x10
	// Bit DCTRL.
	UART0_RS485CTRL_DCTRL = 0x10
	// Disable Auto Direction Control.
	UART0_RS485CTRL_DCTRL_DISABLE_AUTO_DIRECTI = 0x0
	// Enable Auto Direction Control.
	UART0_RS485CTRL_DCTRL_ENABLE_AUTO_DIRECTIO = 0x1
	// Position of OINV field.
	UART0_RS485CTRL_OINV_Pos = 0x5
	// Bit mask of OINV field.
	UART0_RS485CTRL_OINV_Msk = 0x20
	// Bit OINV.
	UART0_RS485CTRL_OINV = 0x20
	// The direction control pin will be driven to logic 0 when the transmitter has data to be sent. It will be driven to logic 1 after the last bit of data has been transmitted.
	UART0_RS485CTRL_OINV_DIRLOW = 0x0
	// The direction control pin will be driven to logic 1 when the transmitter has data to be sent. It will be driven to logic 0 after the last bit of data has been transmitted.
	UART0_RS485CTRL_OINV_DIRHIGH = 0x1
	// Position of RESERVED field.
	UART0_RS485CTRL_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	UART0_RS485CTRL_RESERVED_Msk = 0xffffffc0

	// RS485ADRMATCH: RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode.
	// Position of ADRMATCH field.
	UART0_RS485ADRMATCH_ADRMATCH_Pos = 0x0
	// Bit mask of ADRMATCH field.
	UART0_RS485ADRMATCH_ADRMATCH_Msk = 0xff
	// Position of RESERVED field.
	UART0_RS485ADRMATCH_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART0_RS485ADRMATCH_RESERVED_Msk = 0xffffff00

	// RS485DLY: RS-485/EIA-485 direction control delay.
	// Position of DLY field.
	UART0_RS485DLY_DLY_Pos = 0x0
	// Bit mask of DLY field.
	UART0_RS485DLY_DLY_Msk = 0xff
	// Position of RESERVED field.
	UART0_RS485DLY_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART0_RS485DLY_RESERVED_Msk = 0xffffff00
)

// Constants for UART1: UART1
const (
	// RBR: DLAB =0 Receiver Buffer Register. Contains the next received character to be read.
	// Position of RBR field.
	UART1_RBR_RBR_Pos = 0x0
	// Bit mask of RBR field.
	UART1_RBR_RBR_Msk = 0xff
	// Position of RESERVED field.
	UART1_RBR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART1_RBR_RESERVED_Msk = 0xffffff00

	// THR: DLAB =0. Transmit Holding Register. The next character to be transmitted is written here.
	// Position of THR field.
	UART1_THR_THR_Pos = 0x0
	// Bit mask of THR field.
	UART1_THR_THR_Msk = 0xff
	// Position of RESERVED field.
	UART1_THR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART1_THR_RESERVED_Msk = 0xffffff00

	// DLL: DLAB =1. Divisor Latch LSB. Least significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider.
	// Position of DLLSB field.
	UART1_DLL_DLLSB_Pos = 0x0
	// Bit mask of DLLSB field.
	UART1_DLL_DLLSB_Msk = 0xff
	// Position of RESERVED field.
	UART1_DLL_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART1_DLL_RESERVED_Msk = 0xffffff00

	// DLM: DLAB =1. Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider.
	// Position of DLMSB field.
	UART1_DLM_DLMSB_Pos = 0x0
	// Bit mask of DLMSB field.
	UART1_DLM_DLMSB_Msk = 0xff
	// Position of RESERVED field.
	UART1_DLM_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART1_DLM_RESERVED_Msk = 0xffffff00

	// IER: DLAB =0. Interrupt Enable Register. Contains individual interrupt enable bits for the 7 potential UART1 interrupts.
	// Position of RBRIE field.
	UART1_IER_RBRIE_Pos = 0x0
	// Bit mask of RBRIE field.
	UART1_IER_RBRIE_Msk = 0x1
	// Bit RBRIE.
	UART1_IER_RBRIE = 0x1
	// Disable the RDA interrupts.
	UART1_IER_RBRIE_DISABLE_THE_RDA_INTE = 0x0
	// Enable the RDA interrupts.
	UART1_IER_RBRIE_ENABLE_THE_RDA_INTER = 0x1
	// Position of THREIE field.
	UART1_IER_THREIE_Pos = 0x1
	// Bit mask of THREIE field.
	UART1_IER_THREIE_Msk = 0x2
	// Bit THREIE.
	UART1_IER_THREIE = 0x2
	// Disable the THRE interrupts.
	UART1_IER_THREIE_DISABLE_THE_THRE_INT = 0x0
	// Enable the THRE interrupts.
	UART1_IER_THREIE_ENABLE_THE_THRE_INTE = 0x1
	// Position of RXIE field.
	UART1_IER_RXIE_Pos = 0x2
	// Bit mask of RXIE field.
	UART1_IER_RXIE_Msk = 0x4
	// Bit RXIE.
	UART1_IER_RXIE = 0x4
	// Disable the RX line status interrupts.
	UART1_IER_RXIE_DISABLE_THE_RX_LINE_ = 0x0
	// Enable the RX line status interrupts.
	UART1_IER_RXIE_ENABLE_THE_RX_LINE_S = 0x1
	// Position of MSIE field.
	UART1_IER_MSIE_Pos = 0x3
	// Bit mask of MSIE field.
	UART1_IER_MSIE_Msk = 0x8
	// Bit MSIE.
	UART1_IER_MSIE = 0x8
	// Disable the modem interrupt.
	UART1_IER_MSIE_DISABLE_THE_MODEM_IN = 0x0
	// Enable the modem interrupt.
	UART1_IER_MSIE_ENABLE_THE_MODEM_INT = 0x1
	// Position of RESERVED field.
	UART1_IER_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	UART1_IER_RESERVED_Msk = 0x70
	// Position of CTSIE field.
	UART1_IER_CTSIE_Pos = 0x7
	// Bit mask of CTSIE field.
	UART1_IER_CTSIE_Msk = 0x80
	// Bit CTSIE.
	UART1_IER_CTSIE = 0x80
	// Disable the CTS interrupt.
	UART1_IER_CTSIE_DISABLE_THE_CTS_INTE = 0x0
	// Enable the CTS interrupt.
	UART1_IER_CTSIE_ENABLE_THE_CTS_INTER = 0x1
	// Position of ABEOIE field.
	UART1_IER_ABEOIE_Pos = 0x8
	// Bit mask of ABEOIE field.
	UART1_IER_ABEOIE_Msk = 0x100
	// Bit ABEOIE.
	UART1_IER_ABEOIE = 0x100
	// Disable end of auto-baud Interrupt.
	UART1_IER_ABEOIE_DISABLE_END_OF_AUTO_ = 0x0
	// Enable end of auto-baud Interrupt.
	UART1_IER_ABEOIE_ENABLE_END_OF_AUTO_B = 0x1
	// Position of ABTOIE field.
	UART1_IER_ABTOIE_Pos = 0x9
	// Bit mask of ABTOIE field.
	UART1_IER_ABTOIE_Msk = 0x200
	// Bit ABTOIE.
	UART1_IER_ABTOIE = 0x200
	// Disable auto-baud time-out Interrupt.
	UART1_IER_ABTOIE_DISABLE_AUTO_BAUD_TI = 0x0
	// Enable auto-baud time-out Interrupt.
	UART1_IER_ABTOIE_ENABLE_AUTO_BAUD_TIM = 0x1
	// Position of RESERVED field.
	UART1_IER_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	UART1_IER_RESERVED_Msk = 0xfffffc00

	// IIR: Interrupt ID Register. Identifies which interrupt(s) are pending.
	// Position of INTSTATUS field.
	UART1_IIR_INTSTATUS_Pos = 0x0
	// Bit mask of INTSTATUS field.
	UART1_IIR_INTSTATUS_Msk = 0x1
	// Bit INTSTATUS.
	UART1_IIR_INTSTATUS = 0x1
	// At least one interrupt is pending.
	UART1_IIR_INTSTATUS_AT_LEAST_ONE_INTERRU = 0x0
	// No interrupt is pending.
	UART1_IIR_INTSTATUS_NO_INTERRUPT_IS_PEND = 0x1
	// Position of INTID field.
	UART1_IIR_INTID_Pos = 0x1
	// Bit mask of INTID field.
	UART1_IIR_INTID_Msk = 0xe
	// 1 - Receive Line Status (RLS).
	UART1_IIR_INTID_RLS = 0x3
	// 2a - Receive Data Available (RDA).
	UART1_IIR_INTID_RDA = 0x2
	// 2b - Character Time-out Indicator (CTI).
	UART1_IIR_INTID_CTI = 0x6
	// 3 - THRE Interrupt.
	UART1_IIR_INTID_THRE = 0x1
	// 4 - Modem Interrupt.
	UART1_IIR_INTID_MODEM = 0x0
	// Position of RESERVED field.
	UART1_IIR_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	UART1_IIR_RESERVED_Msk = 0x30
	// Position of FIFOENABLE field.
	UART1_IIR_FIFOENABLE_Pos = 0x6
	// Bit mask of FIFOENABLE field.
	UART1_IIR_FIFOENABLE_Msk = 0xc0
	// Position of ABEOINT field.
	UART1_IIR_ABEOINT_Pos = 0x8
	// Bit mask of ABEOINT field.
	UART1_IIR_ABEOINT_Msk = 0x100
	// Bit ABEOINT.
	UART1_IIR_ABEOINT = 0x100
	// Position of ABTOINT field.
	UART1_IIR_ABTOINT_Pos = 0x9
	// Bit mask of ABTOINT field.
	UART1_IIR_ABTOINT_Msk = 0x200
	// Bit ABTOINT.
	UART1_IIR_ABTOINT = 0x200
	// Position of RESERVED field.
	UART1_IIR_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	UART1_IIR_RESERVED_Msk = 0xfffffc00

	// FCR: FIFO Control Register. Controls UART1 FIFO usage and modes.
	// Position of FIFOEN field.
	UART1_FCR_FIFOEN_Pos = 0x0
	// Bit mask of FIFOEN field.
	UART1_FCR_FIFOEN_Msk = 0x1
	// Bit FIFOEN.
	UART1_FCR_FIFOEN = 0x1
	// Must not be used in the application.
	UART1_FCR_FIFOEN_MUST_NOT_BE_USED_IN_ = 0x0
	// Active high enable for both UART1 Rx and TX FIFOs and FCR[7:1] access. This bit must be set for proper UART1 operation. Any transition on this bit will automatically clear the UART1 FIFOs.
	UART1_FCR_FIFOEN_ACTIVE_HIGH_ENABLE_F = 0x1
	// Position of RXFIFORES field.
	UART1_FCR_RXFIFORES_Pos = 0x1
	// Bit mask of RXFIFORES field.
	UART1_FCR_RXFIFORES_Msk = 0x2
	// Bit RXFIFORES.
	UART1_FCR_RXFIFORES = 0x2
	// No impact on either of UART1 FIFOs.
	UART1_FCR_RXFIFORES_NO_IMPACT_ON_EITHER_ = 0x0
	// Writing a logic 1 to FCR[1] will clear all bytes in UART1 Rx FIFO, reset the pointer logic. This bit is self-clearing.
	UART1_FCR_RXFIFORES_WRITING_A_LOGIC_1_TO = 0x1
	// Position of TXFIFORES field.
	UART1_FCR_TXFIFORES_Pos = 0x2
	// Bit mask of TXFIFORES field.
	UART1_FCR_TXFIFORES_Msk = 0x4
	// Bit TXFIFORES.
	UART1_FCR_TXFIFORES = 0x4
	// No impact on either of UART1 FIFOs.
	UART1_FCR_TXFIFORES_NO_IMPACT_ON_EITHER_ = 0x0
	// Writing a logic 1 to FCR[2] will clear all bytes in UART1 TX FIFO, reset the pointer logic. This bit is self-clearing.
	UART1_FCR_TXFIFORES_WRITING_A_LOGIC_1_TO = 0x1
	// Position of DMAMODE field.
	UART1_FCR_DMAMODE_Pos = 0x3
	// Bit mask of DMAMODE field.
	UART1_FCR_DMAMODE_Msk = 0x8
	// Bit DMAMODE.
	UART1_FCR_DMAMODE = 0x8
	// Position of RESERVED field.
	UART1_FCR_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	UART1_FCR_RESERVED_Msk = 0x30
	// Position of RXTRIGLVL field.
	UART1_FCR_RXTRIGLVL_Pos = 0x6
	// Bit mask of RXTRIGLVL field.
	UART1_FCR_RXTRIGLVL_Msk = 0xc0
	// Trigger level 0 (1 character or 0x01).
	UART1_FCR_RXTRIGLVL_TRIGGER_LEVEL_0_1_C = 0x0
	// Trigger level 1 (4 characters or 0x04).
	UART1_FCR_RXTRIGLVL_TRIGGER_LEVEL_1_4_C = 0x1
	// Trigger level 2 (8 characters or 0x08).
	UART1_FCR_RXTRIGLVL_TRIGGER_LEVEL_2_8_C = 0x2
	// Trigger level 3 (14 characters or 0x0E).
	UART1_FCR_RXTRIGLVL_TRIGGER_LEVEL_3_14_ = 0x3
	// Position of RESERVED field.
	UART1_FCR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART1_FCR_RESERVED_Msk = 0xffffff00

	// LCR: Line Control Register. Contains controls for frame formatting and break generation.
	// Position of WLS field.
	UART1_LCR_WLS_Pos = 0x0
	// Bit mask of WLS field.
	UART1_LCR_WLS_Msk = 0x3
	// 5-bit character length.
	UART1_LCR_WLS_5_BIT_CHARACTER_LENG = 0x0
	// 6-bit character length.
	UART1_LCR_WLS_6_BIT_CHARACTER_LENG = 0x1
	// 7-bit character length.
	UART1_LCR_WLS_7_BIT_CHARACTER_LENG = 0x2
	// 8-bit character length.
	UART1_LCR_WLS_8_BIT_CHARACTER_LENG = 0x3
	// Position of SBS field.
	UART1_LCR_SBS_Pos = 0x2
	// Bit mask of SBS field.
	UART1_LCR_SBS_Msk = 0x4
	// Bit SBS.
	UART1_LCR_SBS = 0x4
	// 1 stop bit.
	UART1_LCR_SBS_1_STOP_BIT_ = 0x0
	// 2 stop bits (1.5 if LCR[1:0]=00).
	UART1_LCR_SBS_2_STOP_BITS_1_5_IF_ = 0x1
	// Position of PE field.
	UART1_LCR_PE_Pos = 0x3
	// Bit mask of PE field.
	UART1_LCR_PE_Msk = 0x8
	// Bit PE.
	UART1_LCR_PE = 0x8
	// Disable parity generation and checking.
	UART1_LCR_PE_DISABLE_PARITY_GENER = 0x0
	// Enable parity generation and checking.
	UART1_LCR_PE_ENABLE_PARITY_GENERA = 0x1
	// Position of PS field.
	UART1_LCR_PS_Pos = 0x4
	// Bit mask of PS field.
	UART1_LCR_PS_Msk = 0x30
	// Odd parity. Number of 1s in the transmitted character and the attached parity bit will be odd.
	UART1_LCR_PS_ODD_PARITY_NUMBER_O = 0x0
	// Even Parity. Number of 1s in the transmitted character and the attached parity bit will be even.
	UART1_LCR_PS_EVEN_PARITY_NUMBER_ = 0x1
	// Forced 1 stick parity.
	UART1_LCR_PS_FORCED1STICK_PAR = 0x2
	// Forced 0 stick parity.
	UART1_LCR_PS_FORCED0STICK_PAR = 0x3
	// Position of BC field.
	UART1_LCR_BC_Pos = 0x6
	// Bit mask of BC field.
	UART1_LCR_BC_Msk = 0x40
	// Bit BC.
	UART1_LCR_BC = 0x40
	// Disable break transmission.
	UART1_LCR_BC_DISABLE_BREAK_TRANSM = 0x0
	// Enable break transmission. Output pin UART1 TXD is forced to logic 0 when LCR[6] is active high.
	UART1_LCR_BC_ENABLE_BREAK_TRANSMI = 0x1
	// Position of DLAB field.
	UART1_LCR_DLAB_Pos = 0x7
	// Bit mask of DLAB field.
	UART1_LCR_DLAB_Msk = 0x80
	// Bit DLAB.
	UART1_LCR_DLAB = 0x80
	// Disable access to Divisor Latches.
	UART1_LCR_DLAB_DISABLE_ACCESS_TO_DI = 0x0
	// Enable access to Divisor Latches.
	UART1_LCR_DLAB_ENABLE_ACCESS_TO_DIV = 0x1
	// Position of RESERVED field.
	UART1_LCR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART1_LCR_RESERVED_Msk = 0xffffff00

	// MCR: Modem Control Register. Contains controls for flow control handshaking and loopback mode.
	// Position of DTRCTRL field.
	UART1_MCR_DTRCTRL_Pos = 0x0
	// Bit mask of DTRCTRL field.
	UART1_MCR_DTRCTRL_Msk = 0x1
	// Bit DTRCTRL.
	UART1_MCR_DTRCTRL = 0x1
	// Position of RTSCTRL field.
	UART1_MCR_RTSCTRL_Pos = 0x1
	// Bit mask of RTSCTRL field.
	UART1_MCR_RTSCTRL_Msk = 0x2
	// Bit RTSCTRL.
	UART1_MCR_RTSCTRL = 0x2
	// Position of RESERVED field.
	UART1_MCR_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	UART1_MCR_RESERVED_Msk = 0xc
	// Position of LMS field.
	UART1_MCR_LMS_Pos = 0x4
	// Bit mask of LMS field.
	UART1_MCR_LMS_Msk = 0x10
	// Bit LMS.
	UART1_MCR_LMS = 0x10
	// Disable modem loopback mode.
	UART1_MCR_LMS_DISABLE_MODEM_LOOPBA = 0x0
	// Enable modem loopback mode.
	UART1_MCR_LMS_ENABLE_MODEM_LOOPBAC = 0x1
	// Position of RESERVED field.
	UART1_MCR_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	UART1_MCR_RESERVED_Msk = 0x20
	// Bit RESERVED.
	UART1_MCR_RESERVED = 0x20
	// Position of RTSEN field.
	UART1_MCR_RTSEN_Pos = 0x6
	// Bit mask of RTSEN field.
	UART1_MCR_RTSEN_Msk = 0x40
	// Bit RTSEN.
	UART1_MCR_RTSEN = 0x40
	// Disable auto-rts flow control.
	UART1_MCR_RTSEN_DISABLE_AUTO_RTS_FLO = 0x0
	// Enable auto-rts flow control.
	UART1_MCR_RTSEN_ENABLE_AUTO_RTS_FLOW = 0x1
	// Position of CTSEN field.
	UART1_MCR_CTSEN_Pos = 0x7
	// Bit mask of CTSEN field.
	UART1_MCR_CTSEN_Msk = 0x80
	// Bit CTSEN.
	UART1_MCR_CTSEN = 0x80
	// Disable auto-cts flow control.
	UART1_MCR_CTSEN_DISABLE_AUTO_CTS_FLO = 0x0
	// Enable auto-cts flow control.
	UART1_MCR_CTSEN_ENABLE_AUTO_CTS_FLOW = 0x1
	// Position of RESERVED field.
	UART1_MCR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART1_MCR_RESERVED_Msk = 0xffffff00

	// LSR: Line Status Register. Contains flags for transmit and receive status, including line errors.
	// Position of RDR field.
	UART1_LSR_RDR_Pos = 0x0
	// Bit mask of RDR field.
	UART1_LSR_RDR_Msk = 0x1
	// Bit RDR.
	UART1_LSR_RDR = 0x1
	// The UART1 receiver FIFO is empty.
	UART1_LSR_RDR_EMPTY = 0x0
	// The UART1 receiver FIFO is not empty.
	UART1_LSR_RDR_NOTEMPTY = 0x1
	// Position of OE field.
	UART1_LSR_OE_Pos = 0x1
	// Bit mask of OE field.
	UART1_LSR_OE_Msk = 0x2
	// Bit OE.
	UART1_LSR_OE = 0x2
	// Overrun error status is inactive.
	UART1_LSR_OE_INACTIVE = 0x0
	// Overrun error status is active.
	UART1_LSR_OE_ACTIVE = 0x1
	// Position of PE field.
	UART1_LSR_PE_Pos = 0x2
	// Bit mask of PE field.
	UART1_LSR_PE_Msk = 0x4
	// Bit PE.
	UART1_LSR_PE = 0x4
	// Parity error status is inactive.
	UART1_LSR_PE_INACTIVE = 0x0
	// Parity error status is active.
	UART1_LSR_PE_ACTIVE = 0x1
	// Position of FE field.
	UART1_LSR_FE_Pos = 0x3
	// Bit mask of FE field.
	UART1_LSR_FE_Msk = 0x8
	// Bit FE.
	UART1_LSR_FE = 0x8
	// Framing error status is inactive.
	UART1_LSR_FE_INACTIVE = 0x0
	// Framing error status is active.
	UART1_LSR_FE_ACTIVE = 0x1
	// Position of BI field.
	UART1_LSR_BI_Pos = 0x4
	// Bit mask of BI field.
	UART1_LSR_BI_Msk = 0x10
	// Bit BI.
	UART1_LSR_BI = 0x10
	// Break interrupt status is inactive.
	UART1_LSR_BI_INACTIVE = 0x0
	// Break interrupt status is active.
	UART1_LSR_BI_ACTIVE = 0x1
	// Position of THRE field.
	UART1_LSR_THRE_Pos = 0x5
	// Bit mask of THRE field.
	UART1_LSR_THRE_Msk = 0x20
	// Bit THRE.
	UART1_LSR_THRE = 0x20
	// THR contains valid data.
	UART1_LSR_THRE_VALID = 0x0
	// THR is empty.
	UART1_LSR_THRE_THR_IS_EMPTY_ = 0x1
	// Position of TEMT field.
	UART1_LSR_TEMT_Pos = 0x6
	// Bit mask of TEMT field.
	UART1_LSR_TEMT_Msk = 0x40
	// Bit TEMT.
	UART1_LSR_TEMT = 0x40
	// THR and/or the TSR contains valid data.
	UART1_LSR_TEMT_VALID = 0x0
	// THR and the TSR are empty.
	UART1_LSR_TEMT_EMPTY = 0x1
	// Position of RXFE field.
	UART1_LSR_RXFE_Pos = 0x7
	// Bit mask of RXFE field.
	UART1_LSR_RXFE_Msk = 0x80
	// Bit RXFE.
	UART1_LSR_RXFE = 0x80
	// RBR contains no UART1 RX errors or FCR[0]=0.
	UART1_LSR_RXFE_NOERROR = 0x0
	// UART1 RBR contains at least one UART1 RX error.
	UART1_LSR_RXFE_ERRORS = 0x1
	// Position of RESERVED field.
	UART1_LSR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART1_LSR_RESERVED_Msk = 0xffffff00

	// MSR: Modem Status Register. Contains handshake signal status flags.
	// Position of DCTS field.
	UART1_MSR_DCTS_Pos = 0x0
	// Bit mask of DCTS field.
	UART1_MSR_DCTS_Msk = 0x1
	// Bit DCTS.
	UART1_MSR_DCTS = 0x1
	// No change detected on modem input, CTS.
	UART1_MSR_DCTS_NO_CHANGE_DETECTED_O = 0x0
	// State change detected on modem input, CTS.
	UART1_MSR_DCTS_STATE_CHANGE_DETECTE = 0x1
	// Position of DDSR field.
	UART1_MSR_DDSR_Pos = 0x1
	// Bit mask of DDSR field.
	UART1_MSR_DDSR_Msk = 0x2
	// Bit DDSR.
	UART1_MSR_DDSR = 0x2
	// No change detected on modem input, DSR.
	UART1_MSR_DDSR_NO_CHANGE_DETECTED_O = 0x0
	// State change detected on modem input, DSR.
	UART1_MSR_DDSR_STATE_CHANGE_DETECTE = 0x1
	// Position of TERI field.
	UART1_MSR_TERI_Pos = 0x2
	// Bit mask of TERI field.
	UART1_MSR_TERI_Msk = 0x4
	// Bit TERI.
	UART1_MSR_TERI = 0x4
	// No change detected on modem input, RI.
	UART1_MSR_TERI_NO_CHANGE_DETECTED_O = 0x0
	// Low-to-high transition detected on RI.
	UART1_MSR_TERI_LOW_TO_HIGH_TRANSITI = 0x1
	// Position of DDCD field.
	UART1_MSR_DDCD_Pos = 0x3
	// Bit mask of DDCD field.
	UART1_MSR_DDCD_Msk = 0x8
	// Bit DDCD.
	UART1_MSR_DDCD = 0x8
	// No change detected on modem input, DCD.
	UART1_MSR_DDCD_NO_CHANGE_DETECTED_O = 0x0
	// State change detected on modem input, DCD.
	UART1_MSR_DDCD_STATE_CHANGE_DETECTE = 0x1
	// Position of CTS field.
	UART1_MSR_CTS_Pos = 0x4
	// Bit mask of CTS field.
	UART1_MSR_CTS_Msk = 0x10
	// Bit CTS.
	UART1_MSR_CTS = 0x10
	// Position of DSR field.
	UART1_MSR_DSR_Pos = 0x5
	// Bit mask of DSR field.
	UART1_MSR_DSR_Msk = 0x20
	// Bit DSR.
	UART1_MSR_DSR = 0x20
	// Position of RI field.
	UART1_MSR_RI_Pos = 0x6
	// Bit mask of RI field.
	UART1_MSR_RI_Msk = 0x40
	// Bit RI.
	UART1_MSR_RI = 0x40
	// Position of DCD field.
	UART1_MSR_DCD_Pos = 0x7
	// Bit mask of DCD field.
	UART1_MSR_DCD_Msk = 0x80
	// Bit DCD.
	UART1_MSR_DCD = 0x80
	// Position of RESERVED field.
	UART1_MSR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART1_MSR_RESERVED_Msk = 0xffffff00

	// SCR: Scratch Pad Register. 8-bit temporary storage for software.
	// Position of Pad field.
	UART1_SCR_Pad_Pos = 0x0
	// Bit mask of Pad field.
	UART1_SCR_Pad_Msk = 0xff
	// Position of RESERVED field.
	UART1_SCR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART1_SCR_RESERVED_Msk = 0xffffff00

	// ACR: Auto-baud Control Register. Contains controls for the auto-baud feature.
	// Position of START field.
	UART1_ACR_START_Pos = 0x0
	// Bit mask of START field.
	UART1_ACR_START_Msk = 0x1
	// Bit START.
	UART1_ACR_START = 0x1
	// Auto-baud stop (auto-baud is not running).
	UART1_ACR_START_STOP = 0x0
	// Auto-baud start (auto-baud is running). Auto-baud run bit. This bit is automatically cleared after auto-baud completion.
	UART1_ACR_START_START = 0x1
	// Position of MODE field.
	UART1_ACR_MODE_Pos = 0x1
	// Bit mask of MODE field.
	UART1_ACR_MODE_Msk = 0x2
	// Bit MODE.
	UART1_ACR_MODE = 0x2
	// Mode 0.
	UART1_ACR_MODE_MODE_0_ = 0x0
	// Mode 1.
	UART1_ACR_MODE_MODE_1_ = 0x1
	// Position of AUTORESTART field.
	UART1_ACR_AUTORESTART_Pos = 0x2
	// Bit mask of AUTORESTART field.
	UART1_ACR_AUTORESTART_Msk = 0x4
	// Bit AUTORESTART.
	UART1_ACR_AUTORESTART = 0x4
	// No restart
	UART1_ACR_AUTORESTART_NO_RESTART = 0x0
	// Restart in case of time-out (counter restarts at next UART1 Rx falling edge)
	UART1_ACR_AUTORESTART_RESTART_IN_CASE_OF_T = 0x1
	// Position of RESERVED field.
	UART1_ACR_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	UART1_ACR_RESERVED_Msk = 0xf8
	// Position of ABEOINTCLR field.
	UART1_ACR_ABEOINTCLR_Pos = 0x8
	// Bit mask of ABEOINTCLR field.
	UART1_ACR_ABEOINTCLR_Msk = 0x100
	// Bit ABEOINTCLR.
	UART1_ACR_ABEOINTCLR = 0x100
	// Writing a 0 has no impact.
	UART1_ACR_ABEOINTCLR_WRITING_A_0_HAS_NO_I = 0x0
	// Writing a 1 will clear the corresponding interrupt in the IIR.
	UART1_ACR_ABEOINTCLR_WRITING_A_1_WILL_CLE = 0x1
	// Position of ABTOINTCLR field.
	UART1_ACR_ABTOINTCLR_Pos = 0x9
	// Bit mask of ABTOINTCLR field.
	UART1_ACR_ABTOINTCLR_Msk = 0x200
	// Bit ABTOINTCLR.
	UART1_ACR_ABTOINTCLR = 0x200
	// Writing a 0 has no impact.
	UART1_ACR_ABTOINTCLR_WRITING_A_0_HAS_NO_I = 0x0
	// Writing a 1 will clear the corresponding interrupt in the IIR.
	UART1_ACR_ABTOINTCLR_WRITING_A_1_WILL_CLE = 0x1
	// Position of RESERVED field.
	UART1_ACR_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	UART1_ACR_RESERVED_Msk = 0xfffffc00

	// FDR: Fractional Divider Register. Generates a clock input for the baud rate divider.
	// Position of DIVADDVAL field.
	UART1_FDR_DIVADDVAL_Pos = 0x0
	// Bit mask of DIVADDVAL field.
	UART1_FDR_DIVADDVAL_Msk = 0xf
	// Position of MULVAL field.
	UART1_FDR_MULVAL_Pos = 0x4
	// Bit mask of MULVAL field.
	UART1_FDR_MULVAL_Msk = 0xf0
	// Position of RESERVED field.
	UART1_FDR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART1_FDR_RESERVED_Msk = 0xffffff00

	// TER: Transmit Enable Register. Turns off UART transmitter for use with software flow control.
	// Position of RESERVED field.
	UART1_TER_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	UART1_TER_RESERVED_Msk = 0x7f
	// Position of TXEN field.
	UART1_TER_TXEN_Pos = 0x7
	// Bit mask of TXEN field.
	UART1_TER_TXEN_Msk = 0x80
	// Bit TXEN.
	UART1_TER_TXEN = 0x80
	// Position of RESERVED field.
	UART1_TER_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART1_TER_RESERVED_Msk = 0xffffff00

	// RS485CTRL: RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes.
	// Position of NMMEN field.
	UART1_RS485CTRL_NMMEN_Pos = 0x0
	// Bit mask of NMMEN field.
	UART1_RS485CTRL_NMMEN_Msk = 0x1
	// Bit NMMEN.
	UART1_RS485CTRL_NMMEN = 0x1
	// Disabled.
	UART1_RS485CTRL_NMMEN_DISABLED_ = 0x0
	// Enabled. In this mode, an address is detected when a received byte causes the UART to set the parity error and generate an interrupt.
	UART1_RS485CTRL_NMMEN_ENABLED_IN_THIS_MOD = 0x1
	// Position of RXDIS field.
	UART1_RS485CTRL_RXDIS_Pos = 0x1
	// Bit mask of RXDIS field.
	UART1_RS485CTRL_RXDIS_Msk = 0x2
	// Bit RXDIS.
	UART1_RS485CTRL_RXDIS = 0x2
	// Enabled.
	UART1_RS485CTRL_RXDIS_ENABLED_ = 0x0
	// Disabled.
	UART1_RS485CTRL_RXDIS_DISABLED_ = 0x1
	// Position of AADEN field.
	UART1_RS485CTRL_AADEN_Pos = 0x2
	// Bit mask of AADEN field.
	UART1_RS485CTRL_AADEN_Msk = 0x4
	// Bit AADEN.
	UART1_RS485CTRL_AADEN = 0x4
	// Disabled.
	UART1_RS485CTRL_AADEN_DISABLED_ = 0x0
	// Enabled.
	UART1_RS485CTRL_AADEN_ENABLED_ = 0x1
	// Position of SEL field.
	UART1_RS485CTRL_SEL_Pos = 0x3
	// Bit mask of SEL field.
	UART1_RS485CTRL_SEL_Msk = 0x8
	// Bit SEL.
	UART1_RS485CTRL_SEL = 0x8
	// RTS. If direction control is enabled (bit DCTRL = 1), pin RTS is used for direction control.
	UART1_RS485CTRL_SEL_RTS_IF_DIRECTION_CO = 0x0
	// DTR. If direction control is enabled (bit DCTRL = 1), pin DTR is used for direction control.
	UART1_RS485CTRL_SEL_DTR_IF_DIRECTION_CO = 0x1
	// Position of DCTRL field.
	UART1_RS485CTRL_DCTRL_Pos = 0x4
	// Bit mask of DCTRL field.
	UART1_RS485CTRL_DCTRL_Msk = 0x10
	// Bit DCTRL.
	UART1_RS485CTRL_DCTRL = 0x10
	// Disable Auto Direction Control.
	UART1_RS485CTRL_DCTRL_DISABLE_AUTO_DIRECTI = 0x0
	// Enable Auto Direction Control.
	UART1_RS485CTRL_DCTRL_ENABLE_AUTO_DIRECTIO = 0x1
	// Position of OINV field.
	UART1_RS485CTRL_OINV_Pos = 0x5
	// Bit mask of OINV field.
	UART1_RS485CTRL_OINV_Msk = 0x20
	// Bit OINV.
	UART1_RS485CTRL_OINV = 0x20
	// LOW. The direction control pin will be driven to logic 0 when the transmitter has data to be sent. It will be driven to logic 1 after the last bit of data has been transmitted.
	UART1_RS485CTRL_OINV_LOW_THE_DIRECTION_C = 0x0
	// HIGH. The direction control pin will be driven to logic 1 when the transmitter has data to be sent. It will be driven to logic 0 after the last bit of data has been transmitted.
	UART1_RS485CTRL_OINV_HIGH_THE_DIRECTION_ = 0x1
	// Position of RESERVED field.
	UART1_RS485CTRL_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	UART1_RS485CTRL_RESERVED_Msk = 0xffffffc0

	// RS485ADRMATCH: RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode.
	// Position of ADRMATCH field.
	UART1_RS485ADRMATCH_ADRMATCH_Pos = 0x0
	// Bit mask of ADRMATCH field.
	UART1_RS485ADRMATCH_ADRMATCH_Msk = 0xff
	// Position of RESERVED field.
	UART1_RS485ADRMATCH_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART1_RS485ADRMATCH_RESERVED_Msk = 0xffffff00

	// RS485DLY: RS-485/EIA-485 direction control delay.
	// Position of DLY field.
	UART1_RS485DLY_DLY_Pos = 0x0
	// Bit mask of DLY field.
	UART1_RS485DLY_DLY_Msk = 0xff
	// Position of RESERVED field.
	UART1_RS485DLY_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART1_RS485DLY_RESERVED_Msk = 0xffffff00
)

// Constants for PWM0: Pulse Width Modulators (PWM0/1)
const (
	// IR: Interrupt Register. The IR can be written to clear interrupts, or read to identify which PWM interrupt sources are pending.
	// Position of PWMMR0INT field.
	PWM_IR_PWMMR0INT_Pos = 0x0
	// Bit mask of PWMMR0INT field.
	PWM_IR_PWMMR0INT_Msk = 0x1
	// Bit PWMMR0INT.
	PWM_IR_PWMMR0INT = 0x1
	// Position of PWMMR1INT field.
	PWM_IR_PWMMR1INT_Pos = 0x1
	// Bit mask of PWMMR1INT field.
	PWM_IR_PWMMR1INT_Msk = 0x2
	// Bit PWMMR1INT.
	PWM_IR_PWMMR1INT = 0x2
	// Position of PWMMR2INT field.
	PWM_IR_PWMMR2INT_Pos = 0x2
	// Bit mask of PWMMR2INT field.
	PWM_IR_PWMMR2INT_Msk = 0x4
	// Bit PWMMR2INT.
	PWM_IR_PWMMR2INT = 0x4
	// Position of PWMMR3INT field.
	PWM_IR_PWMMR3INT_Pos = 0x3
	// Bit mask of PWMMR3INT field.
	PWM_IR_PWMMR3INT_Msk = 0x8
	// Bit PWMMR3INT.
	PWM_IR_PWMMR3INT = 0x8
	// Position of PWMCAP0INT field.
	PWM_IR_PWMCAP0INT_Pos = 0x4
	// Bit mask of PWMCAP0INT field.
	PWM_IR_PWMCAP0INT_Msk = 0x10
	// Bit PWMCAP0INT.
	PWM_IR_PWMCAP0INT = 0x10
	// Position of PWMCAP1INT field.
	PWM_IR_PWMCAP1INT_Pos = 0x5
	// Bit mask of PWMCAP1INT field.
	PWM_IR_PWMCAP1INT_Msk = 0x20
	// Bit PWMCAP1INT.
	PWM_IR_PWMCAP1INT = 0x20
	// Position of RESERVED field.
	PWM_IR_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	PWM_IR_RESERVED_Msk = 0xc0
	// Position of PWMMR4INT field.
	PWM_IR_PWMMR4INT_Pos = 0x8
	// Bit mask of PWMMR4INT field.
	PWM_IR_PWMMR4INT_Msk = 0x100
	// Bit PWMMR4INT.
	PWM_IR_PWMMR4INT = 0x100
	// Position of PWMMR5INT field.
	PWM_IR_PWMMR5INT_Pos = 0x9
	// Bit mask of PWMMR5INT field.
	PWM_IR_PWMMR5INT_Msk = 0x200
	// Bit PWMMR5INT.
	PWM_IR_PWMMR5INT = 0x200
	// Position of PWMMR6INT field.
	PWM_IR_PWMMR6INT_Pos = 0xa
	// Bit mask of PWMMR6INT field.
	PWM_IR_PWMMR6INT_Msk = 0x400
	// Bit PWMMR6INT.
	PWM_IR_PWMMR6INT = 0x400
	// Position of RESERVED field.
	PWM_IR_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	PWM_IR_RESERVED_Msk = 0xfffff800

	// TCR: Timer Control Register. The TCR is used to control the Timer Counter functions.
	// Position of CE field.
	PWM_TCR_CE_Pos = 0x0
	// Bit mask of CE field.
	PWM_TCR_CE_Msk = 0x1
	// Bit CE.
	PWM_TCR_CE = 0x1
	// The PWM Timer Counter and PWM Prescale Counter are enabled for counting.
	PWM_TCR_CE_THE_PWM_TIMER_COUNTE = 0x1
	// The counters are disabled.
	PWM_TCR_CE_THE_COUNTERS_ARE_DIS = 0x0
	// Position of CR field.
	PWM_TCR_CR_Pos = 0x1
	// Bit mask of CR field.
	PWM_TCR_CR_Msk = 0x2
	// Bit CR.
	PWM_TCR_CR = 0x2
	// The PWM Timer Counter and the PWM Prescale Counter are synchronously reset on the next positive edge of PCLK. The counters remain reset until this bit is returned to zero.
	PWM_TCR_CR_THE_PWM_TIMER_COUNTE = 0x1
	// Clear reset.
	PWM_TCR_CR_CLEAR_RESET_ = 0x0
	// Position of RESERVED field.
	PWM_TCR_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	PWM_TCR_RESERVED_Msk = 0x4
	// Bit RESERVED.
	PWM_TCR_RESERVED = 0x4
	// Position of PWMEN field.
	PWM_TCR_PWMEN_Pos = 0x3
	// Bit mask of PWMEN field.
	PWM_TCR_PWMEN_Msk = 0x8
	// Bit PWMEN.
	PWM_TCR_PWMEN = 0x8
	// PWM mode is enabled (counter resets to 1). PWM mode causes the shadow registers to operate in connection with the Match registers. A program write to a Match register will not have an effect on the Match result until the corresponding bit in PWMLER has been set, followed by the occurrence of a PWM Match 0 event. Note that the PWM Match register that determines the PWM rate (PWM Match Register 0 - MR0) must be set up prior to the PWM being enabled. Otherwise a Match event will not occur to cause shadow register contents to become effective.
	PWM_TCR_PWMEN_PWM_MODE_IS_ENABLED_ = 0x1
	// Timer mode is enabled (counter resets to 0).
	PWM_TCR_PWMEN_TIMER_MODE_IS_ENABLE = 0x0
	// Position of MDIS field.
	PWM_TCR_MDIS_Pos = 0x4
	// Bit mask of MDIS field.
	PWM_TCR_MDIS_Msk = 0x10
	// Bit MDIS.
	PWM_TCR_MDIS = 0x10
	// Master use. PWM0 is the master, and both PWMs are enabled for counting.
	PWM_TCR_MDIS_MASTER_USE_PWM0_IS_ = 0x1
	// Individual use. The PWMs are used independently, and the individual Counter Enable bits are used to control the PWMs.
	PWM_TCR_MDIS_INDIVIDUAL_USE_THE_ = 0x0
	// Position of RESERVED field.
	PWM_TCR_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	PWM_TCR_RESERVED_Msk = 0xffffffe0

	// TC: Timer Counter. The 32 bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR.
	// Position of TC field.
	PWM_TC_TC_Pos = 0x0
	// Bit mask of TC field.
	PWM_TC_TC_Msk = 0xffffffff

	// PR: Prescale Register. Determines how often the PWM counter is incremented.
	// Position of PM field.
	PWM_PR_PM_Pos = 0x0
	// Bit mask of PM field.
	PWM_PR_PM_Msk = 0xffffffff

	// PC: Prescale Counter. Prescaler for the main PWM counter.
	// Position of PC field.
	PWM_PC_PC_Pos = 0x0
	// Bit mask of PC field.
	PWM_PC_PC_Msk = 0xffffffff

	// MCR: Match Control Register. The MCR is used to control whether an interrupt is generated and if the PWM counter is reset when a Match occurs.
	// Position of PWMMR0I field.
	PWM_MCR_PWMMR0I_Pos = 0x0
	// Bit mask of PWMMR0I field.
	PWM_MCR_PWMMR0I_Msk = 0x1
	// Bit PWMMR0I.
	PWM_MCR_PWMMR0I = 0x1
	// Disabled.
	PWM_MCR_PWMMR0I_DISABLED_ = 0x0
	// Interrupt on PWMMR0: an interrupt is generated when PWMMR0 matches the value in the PWMTC.
	PWM_MCR_PWMMR0I_INTERRUPT_ON_PWMMR0 = 0x1
	// Position of PWMMR0R field.
	PWM_MCR_PWMMR0R_Pos = 0x1
	// Bit mask of PWMMR0R field.
	PWM_MCR_PWMMR0R_Msk = 0x2
	// Bit PWMMR0R.
	PWM_MCR_PWMMR0R = 0x2
	// Disabled.
	PWM_MCR_PWMMR0R_DISABLED_ = 0x0
	// Reset on PWMMR0: the PWMTC will be reset if PWMMR0 matches it.
	PWM_MCR_PWMMR0R_RESET_ON_PWMMR0_THE = 0x1
	// Position of PWMMR0S field.
	PWM_MCR_PWMMR0S_Pos = 0x2
	// Bit mask of PWMMR0S field.
	PWM_MCR_PWMMR0S_Msk = 0x4
	// Bit PWMMR0S.
	PWM_MCR_PWMMR0S = 0x4
	// Disabled
	PWM_MCR_PWMMR0S_DISABLED = 0x0
	// Stop on PWMMR0: the PWMTC and PWMPC will be stopped and PWMTCR bit 0 will be set to 0 if PWMMR0 matches the PWMTC.
	PWM_MCR_PWMMR0S_STOP_ON_PWMMR0_THE_ = 0x1
	// Position of PWMMR1I field.
	PWM_MCR_PWMMR1I_Pos = 0x3
	// Bit mask of PWMMR1I field.
	PWM_MCR_PWMMR1I_Msk = 0x8
	// Bit PWMMR1I.
	PWM_MCR_PWMMR1I = 0x8
	// Disabled.
	PWM_MCR_PWMMR1I_DISABLED_ = 0x0
	// Interrupt on PWMMR1: an interrupt is generated when PWMMR1 matches the value in the PWMTC.
	PWM_MCR_PWMMR1I_INTERRUPT_ON_PWMMR1 = 0x1
	// Position of PWMMR1R field.
	PWM_MCR_PWMMR1R_Pos = 0x4
	// Bit mask of PWMMR1R field.
	PWM_MCR_PWMMR1R_Msk = 0x10
	// Bit PWMMR1R.
	PWM_MCR_PWMMR1R = 0x10
	// Disabled.
	PWM_MCR_PWMMR1R_DISABLED_ = 0x0
	// Reset on PWMMR1: the PWMTC will be reset if PWMMR1 matches it.
	PWM_MCR_PWMMR1R_RESET_ON_PWMMR1_THE = 0x1
	// Position of PWMMR1S field.
	PWM_MCR_PWMMR1S_Pos = 0x5
	// Bit mask of PWMMR1S field.
	PWM_MCR_PWMMR1S_Msk = 0x20
	// Bit PWMMR1S.
	PWM_MCR_PWMMR1S = 0x20
	// Disabled
	PWM_MCR_PWMMR1S_DISABLED = 0x0
	// Stop on PWMMR1: the PWMTC and PWMPC will be stopped and PWMTCR bit 0 will be set to 0 if PWMMR1 matches the PWMTC.
	PWM_MCR_PWMMR1S_STOP_ON_PWMMR1_THE_ = 0x1
	// Position of PWMMR2I field.
	PWM_MCR_PWMMR2I_Pos = 0x6
	// Bit mask of PWMMR2I field.
	PWM_MCR_PWMMR2I_Msk = 0x40
	// Bit PWMMR2I.
	PWM_MCR_PWMMR2I = 0x40
	// Disabled.
	PWM_MCR_PWMMR2I_DISABLED_ = 0x0
	// Interrupt on PWMMR2: an interrupt is generated when PWMMR2 matches the value in the PWMTC.
	PWM_MCR_PWMMR2I_INTERRUPT_ON_PWMMR2 = 0x1
	// Position of PWMMR2R field.
	PWM_MCR_PWMMR2R_Pos = 0x7
	// Bit mask of PWMMR2R field.
	PWM_MCR_PWMMR2R_Msk = 0x80
	// Bit PWMMR2R.
	PWM_MCR_PWMMR2R = 0x80
	// Disabled.
	PWM_MCR_PWMMR2R_DISABLED_ = 0x0
	// Reset on PWMMR2: the PWMTC will be reset if PWMMR2 matches it.
	PWM_MCR_PWMMR2R_RESET_ON_PWMMR2_THE = 0x1
	// Position of PWMMR2S field.
	PWM_MCR_PWMMR2S_Pos = 0x8
	// Bit mask of PWMMR2S field.
	PWM_MCR_PWMMR2S_Msk = 0x100
	// Bit PWMMR2S.
	PWM_MCR_PWMMR2S = 0x100
	// Disabled
	PWM_MCR_PWMMR2S_DISABLED = 0x0
	// Stop on PWMMR2: the PWMTC and PWMPC will be stopped and PWMTCR bit 0 will be set to 0 if PWMMR0 matches the PWMTC.
	PWM_MCR_PWMMR2S_STOP_ON_PWMMR2_THE_ = 0x1
	// Position of PWMMR3I field.
	PWM_MCR_PWMMR3I_Pos = 0x9
	// Bit mask of PWMMR3I field.
	PWM_MCR_PWMMR3I_Msk = 0x200
	// Bit PWMMR3I.
	PWM_MCR_PWMMR3I = 0x200
	// Disabled.
	PWM_MCR_PWMMR3I_DISABLED_ = 0x0
	// Interrupt on PWMMR3: an interrupt is generated when PWMMR3 matches the value in the PWMTC.
	PWM_MCR_PWMMR3I_INTERRUPT_ON_PWMMR3 = 0x1
	// Position of PWMMR3R field.
	PWM_MCR_PWMMR3R_Pos = 0xa
	// Bit mask of PWMMR3R field.
	PWM_MCR_PWMMR3R_Msk = 0x400
	// Bit PWMMR3R.
	PWM_MCR_PWMMR3R = 0x400
	// Disabled.
	PWM_MCR_PWMMR3R_DISABLED_ = 0x0
	// Reset on PWMMR3: the PWMTC will be reset if PWMMR3 matches it.
	PWM_MCR_PWMMR3R_RESET_ON_PWMMR3_THE = 0x1
	// Position of PWMMR3S field.
	PWM_MCR_PWMMR3S_Pos = 0xb
	// Bit mask of PWMMR3S field.
	PWM_MCR_PWMMR3S_Msk = 0x800
	// Bit PWMMR3S.
	PWM_MCR_PWMMR3S = 0x800
	// Disabled
	PWM_MCR_PWMMR3S_DISABLED = 0x0
	// Stop on PWMMR3: the PWMTC and PWMPC will be stopped and PWMTCR bit 0 will be set to 0 if PWMMR0 matches the PWMTC.
	PWM_MCR_PWMMR3S_STOP_ON_PWMMR3_THE_ = 0x1
	// Position of PWMMR4I field.
	PWM_MCR_PWMMR4I_Pos = 0xc
	// Bit mask of PWMMR4I field.
	PWM_MCR_PWMMR4I_Msk = 0x1000
	// Bit PWMMR4I.
	PWM_MCR_PWMMR4I = 0x1000
	// Disabled.
	PWM_MCR_PWMMR4I_DISABLED_ = 0x0
	// Interrupt on PWMMR4: an interrupt is generated when PWMMR4 matches the value in the PWMTC.
	PWM_MCR_PWMMR4I_INTERRUPT_ON_PWMMR4 = 0x1
	// Position of PWMMR4R field.
	PWM_MCR_PWMMR4R_Pos = 0xd
	// Bit mask of PWMMR4R field.
	PWM_MCR_PWMMR4R_Msk = 0x2000
	// Bit PWMMR4R.
	PWM_MCR_PWMMR4R = 0x2000
	// Disabled.
	PWM_MCR_PWMMR4R_DISABLED_ = 0x0
	// Reset on PWMMR4: the PWMTC will be reset if PWMMR4 matches it.
	PWM_MCR_PWMMR4R_RESET_ON_PWMMR4_THE = 0x1
	// Position of PWMMR4S field.
	PWM_MCR_PWMMR4S_Pos = 0xe
	// Bit mask of PWMMR4S field.
	PWM_MCR_PWMMR4S_Msk = 0x4000
	// Bit PWMMR4S.
	PWM_MCR_PWMMR4S = 0x4000
	// Disabled
	PWM_MCR_PWMMR4S_DISABLED = 0x0
	// Stop on PWMMR4: the PWMTC and PWMPC will be stopped and PWMTCR bit 0 will be set to 0 if PWMMR4 matches the PWMTC.
	PWM_MCR_PWMMR4S_STOP_ON_PWMMR4_THE_ = 0x1
	// Position of PWMMR5I field.
	PWM_MCR_PWMMR5I_Pos = 0xf
	// Bit mask of PWMMR5I field.
	PWM_MCR_PWMMR5I_Msk = 0x8000
	// Bit PWMMR5I.
	PWM_MCR_PWMMR5I = 0x8000
	// Disabled.
	PWM_MCR_PWMMR5I_DISABLED_ = 0x0
	// Interrupt on PWMMR5: an interrupt is generated when PWMMR5 matches the value in the PWMTC.
	PWM_MCR_PWMMR5I_INTERRUPT_ON_PWMMR5 = 0x1
	// Position of PWMMR5R field.
	PWM_MCR_PWMMR5R_Pos = 0x10
	// Bit mask of PWMMR5R field.
	PWM_MCR_PWMMR5R_Msk = 0x10000
	// Bit PWMMR5R.
	PWM_MCR_PWMMR5R = 0x10000
	// Disabled.
	PWM_MCR_PWMMR5R_DISABLED_ = 0x0
	// Reset on PWMMR5: the PWMTC will be reset if PWMMR5 matches it.
	PWM_MCR_PWMMR5R_RESET_ON_PWMMR5_THE = 0x1
	// Position of PWMMR5S field.
	PWM_MCR_PWMMR5S_Pos = 0x11
	// Bit mask of PWMMR5S field.
	PWM_MCR_PWMMR5S_Msk = 0x20000
	// Bit PWMMR5S.
	PWM_MCR_PWMMR5S = 0x20000
	// Disabled
	PWM_MCR_PWMMR5S_DISABLED = 0x0
	// Stop on PWMMR5: the PWMTC and PWMPC will be stopped and PWMTCR bit 0 will be set to 0 if PWMMR5 matches the PWMTC.
	PWM_MCR_PWMMR5S_STOP_ON_PWMMR5_THE_ = 0x1
	// Position of PWMMR6I field.
	PWM_MCR_PWMMR6I_Pos = 0x12
	// Bit mask of PWMMR6I field.
	PWM_MCR_PWMMR6I_Msk = 0x40000
	// Bit PWMMR6I.
	PWM_MCR_PWMMR6I = 0x40000
	// Disabled.
	PWM_MCR_PWMMR6I_DISABLED_ = 0x0
	// Interrupt on PWMMR6: an interrupt is generated when PWMMR6 matches the value in the PWMTC.
	PWM_MCR_PWMMR6I_INTERRUPT_ON_PWMMR6 = 0x1
	// Position of PWMMR6R field.
	PWM_MCR_PWMMR6R_Pos = 0x13
	// Bit mask of PWMMR6R field.
	PWM_MCR_PWMMR6R_Msk = 0x80000
	// Bit PWMMR6R.
	PWM_MCR_PWMMR6R = 0x80000
	// Disabled.
	PWM_MCR_PWMMR6R_DISABLED_ = 0x0
	// Reset on PWMMR6: the PWMTC will be reset if PWMMR6 matches it.
	PWM_MCR_PWMMR6R_RESET_ON_PWMMR6_THE = 0x1
	// Position of PWMMR6S field.
	PWM_MCR_PWMMR6S_Pos = 0x14
	// Bit mask of PWMMR6S field.
	PWM_MCR_PWMMR6S_Msk = 0x100000
	// Bit PWMMR6S.
	PWM_MCR_PWMMR6S = 0x100000
	// Disabled
	PWM_MCR_PWMMR6S_DISABLED = 0x0
	// Stop on PWMMR6: the PWMTC and PWMPC will be stopped and PWMTCR bit 0 will be set to 0 if PWMMR6 matches the PWMTC.
	PWM_MCR_PWMMR6S_STOP_ON_PWMMR6_THE_ = 0x1
	// Position of RESERVED field.
	PWM_MCR_RESERVED_Pos = 0x15
	// Bit mask of RESERVED field.
	PWM_MCR_RESERVED_Msk = 0xffe00000

	// MR0: Match Register. Match registers are continuously compared to the PWM counter in order to control PWM output edges.
	// Position of MATCH field.
	PWM_MR_MATCH_Pos = 0x0
	// Bit mask of MATCH field.
	PWM_MR_MATCH_Msk = 0xffffffff

	// CCR: Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated for a capture event.
	// Position of CAP0_R field.
	PWM_CCR_CAP0_R_Pos = 0x0
	// Bit mask of CAP0_R field.
	PWM_CCR_CAP0_R_Msk = 0x1
	// Bit CAP0_R.
	PWM_CCR_CAP0_R = 0x1
	// Disabled. This feature is disabled.
	PWM_CCR_CAP0_R_DISABLED_THIS_FEATU = 0x0
	// Rising edge. A synchronously sampled rising edge on PWMn_CAP0 will cause CR0 to be loaded with the contents of the TC.
	PWM_CCR_CAP0_R_RISING_EDGE_A_SYNCH = 0x1
	// Position of CAP0_F field.
	PWM_CCR_CAP0_F_Pos = 0x1
	// Bit mask of CAP0_F field.
	PWM_CCR_CAP0_F_Msk = 0x2
	// Bit CAP0_F.
	PWM_CCR_CAP0_F = 0x2
	// Disabled. This feature is disabled.
	PWM_CCR_CAP0_F_DISABLED_THIS_FEATU = 0x0
	// Falling edge. A synchronously sampled falling edge on PWMn_CAP0 will cause CR0 to be loaded with the contents of TC.
	PWM_CCR_CAP0_F_FALLING_EDGE_A_SYNC = 0x1
	// Position of CAP0_I field.
	PWM_CCR_CAP0_I_Pos = 0x2
	// Bit mask of CAP0_I field.
	PWM_CCR_CAP0_I_Msk = 0x4
	// Bit CAP0_I.
	PWM_CCR_CAP0_I = 0x4
	// Disabled. This feature is disabled.
	PWM_CCR_CAP0_I_DISABLED_THIS_FEATU = 0x0
	// Interrupt. A CR0 load due to a PWMn_CAP0 event will generate an interrupt.
	PWM_CCR_CAP0_I_INTERRUPT_A_CR0_LOA = 0x1
	// Position of CAP1_R field.
	PWM_CCR_CAP1_R_Pos = 0x3
	// Bit mask of CAP1_R field.
	PWM_CCR_CAP1_R_Msk = 0x8
	// Bit CAP1_R.
	PWM_CCR_CAP1_R = 0x8
	// Disabled. This feature is disabled.
	PWM_CCR_CAP1_R_DISABLED_THIS_FEATU = 0x0
	// Rising edge. A synchronously sampled rising edge on PWMn_CAP1 will cause CR1 to be loaded with the contents of the TC.
	PWM_CCR_CAP1_R_RISING_EDGE_A_SYNCH = 0x1
	// Position of CAP1_F field.
	PWM_CCR_CAP1_F_Pos = 0x4
	// Bit mask of CAP1_F field.
	PWM_CCR_CAP1_F_Msk = 0x10
	// Bit CAP1_F.
	PWM_CCR_CAP1_F = 0x10
	// Disabled. This feature is disabled.
	PWM_CCR_CAP1_F_DISABLED_THIS_FEATU = 0x0
	// Falling edge. A synchronously sampled falling edge on PWMn_CAP1 will cause CR1 to be loaded with the contents of TC.
	PWM_CCR_CAP1_F_FALLING_EDGE_A_SYNC = 0x1
	// Position of CAP1_I field.
	PWM_CCR_CAP1_I_Pos = 0x5
	// Bit mask of CAP1_I field.
	PWM_CCR_CAP1_I_Msk = 0x20
	// Bit CAP1_I.
	PWM_CCR_CAP1_I = 0x20
	// Disabled. This feature is disabled.
	PWM_CCR_CAP1_I_DISABLED_THIS_FEATU = 0x0
	// Interrupt. A CR1 load due to a PWMn_CAP1 event will generate an interrupt.
	PWM_CCR_CAP1_I_INTERRUPT_A_CR1_LOA = 0x1
	// Position of RESERVED field.
	PWM_CCR_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	PWM_CCR_RESERVED_Msk = 0xffffffc0

	// CR: PWM Control Register. Enables PWM outputs and selects either single edge or double edge controlled PWM outputs.
	// Position of RESERVED field.
	PWM_CR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	PWM_CR_RESERVED_Msk = 0x3
	// Position of PWMSEL2 field.
	PWM_CR_PWMSEL2_Pos = 0x2
	// Bit mask of PWMSEL2 field.
	PWM_CR_PWMSEL2_Msk = 0x4
	// Bit PWMSEL2.
	PWM_CR_PWMSEL2 = 0x4
	// Single edge controlled mode is selected.
	PWM_CR_PWMSEL2_SINGLE_EDGE_CONTROLL = 0x0
	// Double edge controlled mode is selected.
	PWM_CR_PWMSEL2_DOUBLE_EDGE_CONTROLL = 0x1
	// Position of PWMSEL3 field.
	PWM_CR_PWMSEL3_Pos = 0x3
	// Bit mask of PWMSEL3 field.
	PWM_CR_PWMSEL3_Msk = 0x8
	// Bit PWMSEL3.
	PWM_CR_PWMSEL3 = 0x8
	// Single edge controlled mode is selected.
	PWM_CR_PWMSEL3_SINGLE_EDGE_CONTROLL = 0x0
	// Double edge controlled mode is selected.
	PWM_CR_PWMSEL3_DOUBLE_EDGE_CONTROLL = 0x1
	// Position of PWMSEL4 field.
	PWM_CR_PWMSEL4_Pos = 0x4
	// Bit mask of PWMSEL4 field.
	PWM_CR_PWMSEL4_Msk = 0x10
	// Bit PWMSEL4.
	PWM_CR_PWMSEL4 = 0x10
	// Single edge controlled mode is selected.
	PWM_CR_PWMSEL4_SINGLE_EDGE_CONTROLL = 0x0
	// Double edge controlled mode is selected.
	PWM_CR_PWMSEL4_DOUBLE_EDGE_CONTROLL = 0x1
	// Position of PWMSEL5 field.
	PWM_CR_PWMSEL5_Pos = 0x5
	// Bit mask of PWMSEL5 field.
	PWM_CR_PWMSEL5_Msk = 0x20
	// Bit PWMSEL5.
	PWM_CR_PWMSEL5 = 0x20
	// Single edge controlled mode is selected.
	PWM_CR_PWMSEL5_SINGLE_EDGE_CONTROLL = 0x0
	// Double edge controlled mode is selected.
	PWM_CR_PWMSEL5_DOUBLE_EDGE_CONTROLL = 0x1
	// Position of PWMSEL6 field.
	PWM_CR_PWMSEL6_Pos = 0x6
	// Bit mask of PWMSEL6 field.
	PWM_CR_PWMSEL6_Msk = 0x40
	// Bit PWMSEL6.
	PWM_CR_PWMSEL6 = 0x40
	// Single edge controlled mode is selected.
	PWM_CR_PWMSEL6_SINGLE_EDGE_CONTROLL = 0x0
	// Double edge controlled mode is selected.
	PWM_CR_PWMSEL6_DOUBLE_EDGE_CONTROLL = 0x1
	// Position of RESERVED field.
	PWM_CR_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	PWM_CR_RESERVED_Msk = 0x180
	// Position of PWMENA1 field.
	PWM_CR_PWMENA1_Pos = 0x9
	// Bit mask of PWMENA1 field.
	PWM_CR_PWMENA1_Msk = 0x200
	// Bit PWMENA1.
	PWM_CR_PWMENA1 = 0x200
	// The PWM output is disabled.
	PWM_CR_PWMENA1_THE_PWM_OUTPUT_IS_DI = 0x0
	// The PWM output is enabled.
	PWM_CR_PWMENA1_THE_PWM_OUTPUT_IS_EN = 0x1
	// Position of PWMENA2 field.
	PWM_CR_PWMENA2_Pos = 0xa
	// Bit mask of PWMENA2 field.
	PWM_CR_PWMENA2_Msk = 0x400
	// Bit PWMENA2.
	PWM_CR_PWMENA2 = 0x400
	// The PWM output is disabled.
	PWM_CR_PWMENA2_THE_PWM_OUTPUT_IS_DI = 0x0
	// The PWM output is enabled.
	PWM_CR_PWMENA2_THE_PWM_OUTPUT_IS_EN = 0x1
	// Position of PWMENA3 field.
	PWM_CR_PWMENA3_Pos = 0xb
	// Bit mask of PWMENA3 field.
	PWM_CR_PWMENA3_Msk = 0x800
	// Bit PWMENA3.
	PWM_CR_PWMENA3 = 0x800
	// The PWM output is disabled.
	PWM_CR_PWMENA3_THE_PWM_OUTPUT_IS_DI = 0x0
	// The PWM output is enabled.
	PWM_CR_PWMENA3_THE_PWM_OUTPUT_IS_EN = 0x1
	// Position of PWMENA4 field.
	PWM_CR_PWMENA4_Pos = 0xc
	// Bit mask of PWMENA4 field.
	PWM_CR_PWMENA4_Msk = 0x1000
	// Bit PWMENA4.
	PWM_CR_PWMENA4 = 0x1000
	// The PWM output is disabled.
	PWM_CR_PWMENA4_THE_PWM_OUTPUT_IS_DI = 0x0
	// The PWM output is enabled.
	PWM_CR_PWMENA4_THE_PWM_OUTPUT_IS_EN = 0x1
	// Position of PWMENA5 field.
	PWM_CR_PWMENA5_Pos = 0xd
	// Bit mask of PWMENA5 field.
	PWM_CR_PWMENA5_Msk = 0x2000
	// Bit PWMENA5.
	PWM_CR_PWMENA5 = 0x2000
	// The PWM output is disabled.
	PWM_CR_PWMENA5_THE_PWM_OUTPUT_IS_DI = 0x0
	// The PWM output is enabled.
	PWM_CR_PWMENA5_THE_PWM_OUTPUT_IS_EN = 0x1
	// Position of PWMENA6 field.
	PWM_CR_PWMENA6_Pos = 0xe
	// Bit mask of PWMENA6 field.
	PWM_CR_PWMENA6_Msk = 0x4000
	// Bit PWMENA6.
	PWM_CR_PWMENA6 = 0x4000
	// The PWM output is disabled.
	PWM_CR_PWMENA6_THE_PWM_OUTPUT_IS_DI = 0x0
	// The PWM output is enabled.
	PWM_CR_PWMENA6_THE_PWM_OUTPUT_IS_EN = 0x1
	// Position of RESERVED field.
	PWM_CR_RESERVED_Pos = 0xf
	// Bit mask of RESERVED field.
	PWM_CR_RESERVED_Msk = 0xffff8000

	// MR4: Match Register. Match registers are continuously compared to the PWM counter in order to control PWM output edges.
	// Position of MATCH field.
	PWM_MR4_MATCH_Pos = 0x0
	// Bit mask of MATCH field.
	PWM_MR4_MATCH_Msk = 0xffffffff

	// MR5: Match Register. Match registers are continuously compared to the PWM counter in order to control PWM output edges.
	// Position of MATCH field.
	PWM_MR5_MATCH_Pos = 0x0
	// Bit mask of MATCH field.
	PWM_MR5_MATCH_Msk = 0xffffffff

	// MR6: Match Register. Match registers are continuously compared to the PWM counter in order to control PWM output edges.
	// Position of MATCH field.
	PWM_MR6_MATCH_Pos = 0x0
	// Bit mask of MATCH field.
	PWM_MR6_MATCH_Msk = 0xffffffff

	// PCR: PWM Control Register. Enables PWM outputs and selects either single edge or double edge controlled PWM outputs.
	// Position of RESERVED field.
	PWM_PCR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	PWM_PCR_RESERVED_Msk = 0x3
	// Position of PWMSEL2 field.
	PWM_PCR_PWMSEL2_Pos = 0x2
	// Bit mask of PWMSEL2 field.
	PWM_PCR_PWMSEL2_Msk = 0x4
	// Bit PWMSEL2.
	PWM_PCR_PWMSEL2 = 0x4
	// Single edge controlled mode is selected.
	PWM_PCR_PWMSEL2_SINGLE_EDGE_CONTROLL = 0x0
	// Double edge controlled mode is selected.
	PWM_PCR_PWMSEL2_DOUBLE_EDGE_CONTROLL = 0x1
	// Position of PWMSEL3 field.
	PWM_PCR_PWMSEL3_Pos = 0x3
	// Bit mask of PWMSEL3 field.
	PWM_PCR_PWMSEL3_Msk = 0x8
	// Bit PWMSEL3.
	PWM_PCR_PWMSEL3 = 0x8
	// Single edge controlled mode is selected.
	PWM_PCR_PWMSEL3_SINGLE_EDGE_CONTROLL = 0x0
	// Double edge controlled mode is selected.
	PWM_PCR_PWMSEL3_DOUBLE_EDGE_CONTROLL = 0x1
	// Position of PWMSEL4 field.
	PWM_PCR_PWMSEL4_Pos = 0x4
	// Bit mask of PWMSEL4 field.
	PWM_PCR_PWMSEL4_Msk = 0x10
	// Bit PWMSEL4.
	PWM_PCR_PWMSEL4 = 0x10
	// Single edge controlled mode is selected.
	PWM_PCR_PWMSEL4_SINGLE_EDGE_CONTROLL = 0x0
	// Double edge controlled mode is selected.
	PWM_PCR_PWMSEL4_DOUBLE_EDGE_CONTROLL = 0x1
	// Position of PWMSEL5 field.
	PWM_PCR_PWMSEL5_Pos = 0x5
	// Bit mask of PWMSEL5 field.
	PWM_PCR_PWMSEL5_Msk = 0x20
	// Bit PWMSEL5.
	PWM_PCR_PWMSEL5 = 0x20
	// Single edge controlled mode is selected.
	PWM_PCR_PWMSEL5_SINGLE_EDGE_CONTROLL = 0x0
	// Double edge controlled mode is selected.
	PWM_PCR_PWMSEL5_DOUBLE_EDGE_CONTROLL = 0x1
	// Position of PWMSEL6 field.
	PWM_PCR_PWMSEL6_Pos = 0x6
	// Bit mask of PWMSEL6 field.
	PWM_PCR_PWMSEL6_Msk = 0x40
	// Bit PWMSEL6.
	PWM_PCR_PWMSEL6 = 0x40
	// Single edge controlled mode is selected.
	PWM_PCR_PWMSEL6_SINGLE_EDGE_CONTROLL = 0x0
	// Double edge controlled mode is selected.
	PWM_PCR_PWMSEL6_DOUBLE_EDGE_CONTROLL = 0x1
	// Position of RESERVED field.
	PWM_PCR_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	PWM_PCR_RESERVED_Msk = 0x180
	// Position of PWMENA1 field.
	PWM_PCR_PWMENA1_Pos = 0x9
	// Bit mask of PWMENA1 field.
	PWM_PCR_PWMENA1_Msk = 0x200
	// Bit PWMENA1.
	PWM_PCR_PWMENA1 = 0x200
	// The PWM output is disabled.
	PWM_PCR_PWMENA1_THE_PWM_OUTPUT_IS_DI = 0x0
	// The PWM output is enabled.
	PWM_PCR_PWMENA1_THE_PWM_OUTPUT_IS_EN = 0x1
	// Position of PWMENA2 field.
	PWM_PCR_PWMENA2_Pos = 0xa
	// Bit mask of PWMENA2 field.
	PWM_PCR_PWMENA2_Msk = 0x400
	// Bit PWMENA2.
	PWM_PCR_PWMENA2 = 0x400
	// The PWM output is disabled.
	PWM_PCR_PWMENA2_THE_PWM_OUTPUT_IS_DI = 0x0
	// The PWM output is enabled.
	PWM_PCR_PWMENA2_THE_PWM_OUTPUT_IS_EN = 0x1
	// Position of PWMENA3 field.
	PWM_PCR_PWMENA3_Pos = 0xb
	// Bit mask of PWMENA3 field.
	PWM_PCR_PWMENA3_Msk = 0x800
	// Bit PWMENA3.
	PWM_PCR_PWMENA3 = 0x800
	// The PWM output is disabled.
	PWM_PCR_PWMENA3_THE_PWM_OUTPUT_IS_DI = 0x0
	// The PWM output is enabled.
	PWM_PCR_PWMENA3_THE_PWM_OUTPUT_IS_EN = 0x1
	// Position of PWMENA4 field.
	PWM_PCR_PWMENA4_Pos = 0xc
	// Bit mask of PWMENA4 field.
	PWM_PCR_PWMENA4_Msk = 0x1000
	// Bit PWMENA4.
	PWM_PCR_PWMENA4 = 0x1000
	// The PWM output is disabled.
	PWM_PCR_PWMENA4_THE_PWM_OUTPUT_IS_DI = 0x0
	// The PWM output is enabled.
	PWM_PCR_PWMENA4_THE_PWM_OUTPUT_IS_EN = 0x1
	// Position of PWMENA5 field.
	PWM_PCR_PWMENA5_Pos = 0xd
	// Bit mask of PWMENA5 field.
	PWM_PCR_PWMENA5_Msk = 0x2000
	// Bit PWMENA5.
	PWM_PCR_PWMENA5 = 0x2000
	// The PWM output is disabled.
	PWM_PCR_PWMENA5_THE_PWM_OUTPUT_IS_DI = 0x0
	// The PWM output is enabled.
	PWM_PCR_PWMENA5_THE_PWM_OUTPUT_IS_EN = 0x1
	// Position of PWMENA6 field.
	PWM_PCR_PWMENA6_Pos = 0xe
	// Bit mask of PWMENA6 field.
	PWM_PCR_PWMENA6_Msk = 0x4000
	// Bit PWMENA6.
	PWM_PCR_PWMENA6 = 0x4000
	// The PWM output is disabled.
	PWM_PCR_PWMENA6_THE_PWM_OUTPUT_IS_DI = 0x0
	// The PWM output is enabled.
	PWM_PCR_PWMENA6_THE_PWM_OUTPUT_IS_EN = 0x1
	// Position of RESERVED field.
	PWM_PCR_RESERVED_Pos = 0xf
	// Bit mask of RESERVED field.
	PWM_PCR_RESERVED_Msk = 0xffff8000

	// LER: Load Enable Register. Enables use of updated PWM match values.
	// Position of MAT0LATCHEN field.
	PWM_LER_MAT0LATCHEN_Pos = 0x0
	// Bit mask of MAT0LATCHEN field.
	PWM_LER_MAT0LATCHEN_Msk = 0x1
	// Bit MAT0LATCHEN.
	PWM_LER_MAT0LATCHEN = 0x1
	// Position of MAT1LATCHEN field.
	PWM_LER_MAT1LATCHEN_Pos = 0x1
	// Bit mask of MAT1LATCHEN field.
	PWM_LER_MAT1LATCHEN_Msk = 0x2
	// Bit MAT1LATCHEN.
	PWM_LER_MAT1LATCHEN = 0x2
	// Position of MAT2LATCHEN field.
	PWM_LER_MAT2LATCHEN_Pos = 0x2
	// Bit mask of MAT2LATCHEN field.
	PWM_LER_MAT2LATCHEN_Msk = 0x4
	// Bit MAT2LATCHEN.
	PWM_LER_MAT2LATCHEN = 0x4
	// Position of MAT3LATCHEN field.
	PWM_LER_MAT3LATCHEN_Pos = 0x3
	// Bit mask of MAT3LATCHEN field.
	PWM_LER_MAT3LATCHEN_Msk = 0x8
	// Bit MAT3LATCHEN.
	PWM_LER_MAT3LATCHEN = 0x8
	// Position of MAT4LATCHEN field.
	PWM_LER_MAT4LATCHEN_Pos = 0x4
	// Bit mask of MAT4LATCHEN field.
	PWM_LER_MAT4LATCHEN_Msk = 0x10
	// Bit MAT4LATCHEN.
	PWM_LER_MAT4LATCHEN = 0x10
	// Position of MAT5LATCHEN field.
	PWM_LER_MAT5LATCHEN_Pos = 0x5
	// Bit mask of MAT5LATCHEN field.
	PWM_LER_MAT5LATCHEN_Msk = 0x20
	// Bit MAT5LATCHEN.
	PWM_LER_MAT5LATCHEN = 0x20
	// Position of MAT6LATCHEN field.
	PWM_LER_MAT6LATCHEN_Pos = 0x6
	// Bit mask of MAT6LATCHEN field.
	PWM_LER_MAT6LATCHEN_Msk = 0x40
	// Bit MAT6LATCHEN.
	PWM_LER_MAT6LATCHEN = 0x40
	// Position of RESERVED field.
	PWM_LER_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	PWM_LER_RESERVED_Msk = 0xffffff80

	// CTCR: Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.
	// Position of MOD field.
	PWM_CTCR_MOD_Pos = 0x0
	// Bit mask of MOD field.
	PWM_CTCR_MOD_Msk = 0x3
	// Timer Mode: the TC is incremented when the Prescale Counter matches the Prescale register.
	PWM_CTCR_MOD_TIMER_MODE_THE_TC_I = 0x0
	// Rising edge counter Mode: the TC is incremented on rising edges of the PWM_CAP input selected by bits 3:2.
	PWM_CTCR_MOD_RISING_EDGE_COUNTER_ = 0x1
	// Falling edge counter Mode: the TC is incremented on falling edges of the PWM_CAP input selected by bits 3:2.
	PWM_CTCR_MOD_FALLING_EDGE_COUNTER = 0x2
	// Dual edge counter Mode: the TC is incremented on both edges of the PWM_CAP input selected by bits 3:2.
	PWM_CTCR_MOD_DUAL_EDGE_COUNTER_MO = 0x3
	// Position of CIS field.
	PWM_CTCR_CIS_Pos = 0x2
	// Bit mask of CIS field.
	PWM_CTCR_CIS_Msk = 0xc
	// For PWM0: 00 = PWM0_CAP0 (Other combinations are reserved) For PWM1: 00 = PWM1_CAP0, 01 = PWM1_CAP1 (Other combinations are reserved)
	PWM_CTCR_CIS_FOR_PWM0_00_EQ_PWM0_ = 0x0
	// Position of RESERVED field.
	PWM_CTCR_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	PWM_CTCR_RESERVED_Msk = 0xfffffff0
)

// Constants for I2C0: I2C bus interface
const (
	// CONSET: I2C Control Set Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is set. Writing a zero has no effect on the corresponding bit in the I2C control register.
	// Position of RESERVED field.
	I2C_CONSET_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	I2C_CONSET_RESERVED_Msk = 0x3
	// Position of AA field.
	I2C_CONSET_AA_Pos = 0x2
	// Bit mask of AA field.
	I2C_CONSET_AA_Msk = 0x4
	// Bit AA.
	I2C_CONSET_AA = 0x4
	// Position of SI field.
	I2C_CONSET_SI_Pos = 0x3
	// Bit mask of SI field.
	I2C_CONSET_SI_Msk = 0x8
	// Bit SI.
	I2C_CONSET_SI = 0x8
	// Position of STO field.
	I2C_CONSET_STO_Pos = 0x4
	// Bit mask of STO field.
	I2C_CONSET_STO_Msk = 0x10
	// Bit STO.
	I2C_CONSET_STO = 0x10
	// Position of STA field.
	I2C_CONSET_STA_Pos = 0x5
	// Bit mask of STA field.
	I2C_CONSET_STA_Msk = 0x20
	// Bit STA.
	I2C_CONSET_STA = 0x20
	// Position of I2EN field.
	I2C_CONSET_I2EN_Pos = 0x6
	// Bit mask of I2EN field.
	I2C_CONSET_I2EN_Msk = 0x40
	// Bit I2EN.
	I2C_CONSET_I2EN = 0x40
	// Position of RESERVED field.
	I2C_CONSET_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	I2C_CONSET_RESERVED_Msk = 0xffffff80

	// STAT: I2C Status Register. During I2C operation, this register provides detailed status codes that allow software to determine the next action needed.
	// Position of RESERVED field.
	I2C_STAT_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	I2C_STAT_RESERVED_Msk = 0x7
	// Position of Status field.
	I2C_STAT_Status_Pos = 0x3
	// Bit mask of Status field.
	I2C_STAT_Status_Msk = 0xf8
	// Position of RESERVED field.
	I2C_STAT_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	I2C_STAT_RESERVED_Msk = 0xffffff00

	// DAT: I2C Data Register. During master or slave transmit mode, data to be transmitted is written to this register. During master or slave receive mode, data that has been received may be read from this register.
	// Position of Data field.
	I2C_DAT_Data_Pos = 0x0
	// Bit mask of Data field.
	I2C_DAT_Data_Msk = 0xff
	// Position of RESERVED field.
	I2C_DAT_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	I2C_DAT_RESERVED_Msk = 0xffffff00

	// ADR0: I2C Slave Address Register 0. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
	// Position of GC field.
	I2C_ADR0_GC_Pos = 0x0
	// Bit mask of GC field.
	I2C_ADR0_GC_Msk = 0x1
	// Bit GC.
	I2C_ADR0_GC = 0x1
	// Position of Address field.
	I2C_ADR0_Address_Pos = 0x1
	// Bit mask of Address field.
	I2C_ADR0_Address_Msk = 0xfe
	// Position of RESERVED field.
	I2C_ADR0_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	I2C_ADR0_RESERVED_Msk = 0xffffff00

	// SCLH: SCH Duty Cycle Register High Half Word. Determines the high time of the I2C clock.
	// Position of SCLH field.
	I2C_SCLH_SCLH_Pos = 0x0
	// Bit mask of SCLH field.
	I2C_SCLH_SCLH_Msk = 0xffff
	// Position of RESERVED field.
	I2C_SCLH_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	I2C_SCLH_RESERVED_Msk = 0xffff0000

	// SCLL: SCL Duty Cycle Register Low Half Word. Determines the low time of the I2C clock. SCLL and SCLH together determine the clock frequency generated by an I2C master and certain times used in slave mode.
	// Position of SCLL field.
	I2C_SCLL_SCLL_Pos = 0x0
	// Bit mask of SCLL field.
	I2C_SCLL_SCLL_Msk = 0xffff
	// Position of RESERVED field.
	I2C_SCLL_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	I2C_SCLL_RESERVED_Msk = 0xffff0000

	// CONCLR: I2C Control Clear Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is cleared. Writing a zero has no effect on the corresponding bit in the I2C control register.
	// Position of RESERVED field.
	I2C_CONCLR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	I2C_CONCLR_RESERVED_Msk = 0x3
	// Position of AAC field.
	I2C_CONCLR_AAC_Pos = 0x2
	// Bit mask of AAC field.
	I2C_CONCLR_AAC_Msk = 0x4
	// Bit AAC.
	I2C_CONCLR_AAC = 0x4
	// Position of SIC field.
	I2C_CONCLR_SIC_Pos = 0x3
	// Bit mask of SIC field.
	I2C_CONCLR_SIC_Msk = 0x8
	// Bit SIC.
	I2C_CONCLR_SIC = 0x8
	// Position of RESERVED field.
	I2C_CONCLR_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	I2C_CONCLR_RESERVED_Msk = 0x10
	// Bit RESERVED.
	I2C_CONCLR_RESERVED = 0x10
	// Position of STAC field.
	I2C_CONCLR_STAC_Pos = 0x5
	// Bit mask of STAC field.
	I2C_CONCLR_STAC_Msk = 0x20
	// Bit STAC.
	I2C_CONCLR_STAC = 0x20
	// Position of I2ENC field.
	I2C_CONCLR_I2ENC_Pos = 0x6
	// Bit mask of I2ENC field.
	I2C_CONCLR_I2ENC_Msk = 0x40
	// Bit I2ENC.
	I2C_CONCLR_I2ENC = 0x40
	// Position of RESERVED field.
	I2C_CONCLR_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	I2C_CONCLR_RESERVED_Msk = 0x80
	// Bit RESERVED.
	I2C_CONCLR_RESERVED = 0x80
	// Position of RESERVED field.
	I2C_CONCLR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	I2C_CONCLR_RESERVED_Msk = 0xffffff00

	// MMCTRL: Monitor mode control register.
	// Position of MM_ENA field.
	I2C_MMCTRL_MM_ENA_Pos = 0x0
	// Bit mask of MM_ENA field.
	I2C_MMCTRL_MM_ENA_Msk = 0x1
	// Bit MM_ENA.
	I2C_MMCTRL_MM_ENA = 0x1
	// Monitor mode disabled.
	I2C_MMCTRL_MM_ENA_MONITOR_MODE_DISABLE = 0x0
	// The I 2C module will enter monitor mode. In this mode the SDA output will be forced high. This will prevent the I2C module from outputting data of any kind (including ACK) onto the I2C data bus. Depending on the state of the ENA_SCL bit, the output may be also forced high, preventing the module from having control over the I2C clock line.
	I2C_MMCTRL_MM_ENA_THE_I_2C_MODULE_WILL = 0x1
	// Position of ENA_SCL field.
	I2C_MMCTRL_ENA_SCL_Pos = 0x1
	// Bit mask of ENA_SCL field.
	I2C_MMCTRL_ENA_SCL_Msk = 0x2
	// Bit ENA_SCL.
	I2C_MMCTRL_ENA_SCL = 0x2
	// When this bit is cleared to 0, the SCL output will be forced high when the module is in monitor mode. As described above, this will prevent the module from having any control over the I2C clock line.
	I2C_MMCTRL_ENA_SCL_WHEN_THIS_BIT_IS_CLE = 0x0
	// When this bit is set, the I2C module may exercise the same control over the clock line that it would in normal operation. This means that, acting as a slave peripheral, the I2C module can stretch the clock line (hold it low) until it has had time to respond to an I2C interrupt.[1]
	I2C_MMCTRL_ENA_SCL_WHEN_THIS_BIT_IS_SET = 0x1
	// Position of MATCH_ALL field.
	I2C_MMCTRL_MATCH_ALL_Pos = 0x2
	// Bit mask of MATCH_ALL field.
	I2C_MMCTRL_MATCH_ALL_Msk = 0x4
	// Bit MATCH_ALL.
	I2C_MMCTRL_MATCH_ALL = 0x4
	// When this bit is cleared, an interrupt will only be generated when a match occurs to one of the (up-to) four address registers described above. That is, the module will respond as a normal slave as far as address-recognition is concerned.
	I2C_MMCTRL_MATCH_ALL_WHEN_THIS_BIT_IS_CLE = 0x0
	// When this bit is set to 1 and the I2C is in monitor mode, an interrupt will be generated on ANY address received. This will enable the part to monitor all traffic on the bus.
	I2C_MMCTRL_MATCH_ALL_WHEN_THIS_BIT_IS_SET = 0x1
	// Position of RESERVED field.
	I2C_MMCTRL_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	I2C_MMCTRL_RESERVED_Msk = 0xfffffff8

	// ADR1: I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
	// Position of GC field.
	I2C_ADR_GC_Pos = 0x0
	// Bit mask of GC field.
	I2C_ADR_GC_Msk = 0x1
	// Bit GC.
	I2C_ADR_GC = 0x1
	// Position of Address field.
	I2C_ADR_Address_Pos = 0x1
	// Bit mask of Address field.
	I2C_ADR_Address_Msk = 0xfe
	// Position of RESERVED field.
	I2C_ADR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	I2C_ADR_RESERVED_Msk = 0xffffff00

	// DATA_BUFFER: Data buffer register. The contents of the 8 MSBs of the DAT shift register will be transferred to the DATA_BUFFER automatically after every nine bits (8 bits of data plus ACK or NACK) has been received on the bus.
	// Position of Data field.
	I2C_DATA_BUFFER_Data_Pos = 0x0
	// Bit mask of Data field.
	I2C_DATA_BUFFER_Data_Msk = 0xff
	// Position of RESERVED field.
	I2C_DATA_BUFFER_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	I2C_DATA_BUFFER_RESERVED_Msk = 0xffffff00

	// MASK: I2C Slave address mask register
	// Position of RESERVED field.
	I2C_MASK_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	I2C_MASK_RESERVED_Msk = 0x1
	// Bit RESERVED.
	I2C_MASK_RESERVED = 0x1
	// Position of MASK field.
	I2C_MASK_MASK_Pos = 0x1
	// Bit mask of MASK field.
	I2C_MASK_MASK_Msk = 0xfe
	// Position of RESERVED field.
	I2C_MASK_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	I2C_MASK_RESERVED_Msk = 0xffffff00
)

// Constants for COMPARATOR: Comparators
const (
	// CTRL: Comparator block control register
	// Position of CMP_PD_IREF field.
	COMPARATOR_CTRL_CMP_PD_IREF_Pos = 0x0
	// Bit mask of CMP_PD_IREF field.
	COMPARATOR_CTRL_CMP_PD_IREF_Msk = 0x3
	// The comparator current source is disabled.
	COMPARATOR_CTRL_CMP_PD_IREF_DISABLED = 0x0
	// The comparator current source is disabled in Deep Sleep and Power-down modes and restored automatically when exiting those modes.
	COMPARATOR_CTRL_CMP_PD_IREF_DIS_DEEPSLP_PWRDWN = 0x1
	// The comparator current source is disabled in Power-down mode and restored automatically when exiting Power-down.
	COMPARATOR_CTRL_CMP_PD_IREF_DIS_PWRDWN = 0x2
	// The comparator current source is powered up.
	COMPARATOR_CTRL_CMP_PD_IREF_ENABLED = 0x3
	// Position of CMP_PD_VBG field.
	COMPARATOR_CTRL_CMP_PD_VBG_Pos = 0x2
	// Bit mask of CMP_PD_VBG field.
	COMPARATOR_CTRL_CMP_PD_VBG_Msk = 0xc
	// The comparator bandgap reference is disabled.
	COMPARATOR_CTRL_CMP_PD_VBG_DISABLED = 0x0
	// The comparator bandgap reference is disabled in Deep Sleep and Power-down modes and restored automatically when exiting those modes.
	COMPARATOR_CTRL_CMP_PD_VBG_DIS_DEEPSLP_PWRDWN = 0x1
	// The comparator bandgap reference is disabled in Power-down mode and restored automatically when exiting Power-down.
	COMPARATOR_CTRL_CMP_PD_VBG_DIS_PWRDWN = 0x2
	// The comparator bandgap reference is powered up.
	COMPARATOR_CTRL_CMP_PD_VBG_ENABLED = 0x3
	// Position of CMP_VTEMP field.
	COMPARATOR_CTRL_CMP_VTEMP_Pos = 0x4
	// Bit mask of CMP_VTEMP field.
	COMPARATOR_CTRL_CMP_VTEMP_Msk = 0x30
	// The temperature sensor voltage reference is disabled.
	COMPARATOR_CTRL_CMP_VTEMP_DISABLED = 0x0
	// The temperature sensor voltage reference is disabled in Deep Sleep and Power-down modes and restored automatically when exiting those modes.
	COMPARATOR_CTRL_CMP_VTEMP_DIS_DEEPSLP_PWRDWN = 0x1
	// The temperature sensor voltage reference is disabled in Power-down mode and restored automatically when exiting Power-down.
	COMPARATOR_CTRL_CMP_VTEMP_DIS_PWRDWN = 0x2
	// The temperature sensor voltage reference is powered up.
	COMPARATOR_CTRL_CMP_VTEMP_ENABLED = 0x3
	// Position of CMP_TEMPSEN field.
	COMPARATOR_CTRL_CMP_TEMPSEN_Pos = 0x6
	// Bit mask of CMP_TEMPSEN field.
	COMPARATOR_CTRL_CMP_TEMPSEN_Msk = 0xc0
	// Temperature sensor is disabled.
	COMPARATOR_CTRL_CMP_TEMPSEN_DISABLED = 0x0
	// The temperature sensor is disabled in Deep Sleep and Power-down modes and restored automatically when exiting those modes.
	COMPARATOR_CTRL_CMP_TEMPSEN_DIS_DEEPSLP_PWRDWN = 0x1
	// The temperature sensor is disabled in Power-down mode and restored automatically when exiting Power-down.
	COMPARATOR_CTRL_CMP_TEMPSEN_DIS_PWRDWN = 0x2
	// Temperature sensor is enabled.
	COMPARATOR_CTRL_CMP_TEMPSEN_ENABLED = 0x3
	// Position of CMP_ROSCCTL field.
	COMPARATOR_CTRL_CMP_ROSCCTL_Pos = 0x8
	// Bit mask of CMP_ROSCCTL field.
	COMPARATOR_CTRL_CMP_ROSCCTL_Msk = 0x100
	// Bit CMP_ROSCCTL.
	COMPARATOR_CTRL_CMP_ROSCCTL = 0x100
	// The CMP_ROSC output is set by CMP1 and reset by CMP0.
	COMPARATOR_CTRL_CMP_ROSCCTL_CMP1 = 0x0
	// The CMP_ROSC output is set by CMP0 and reset by CMP1.
	COMPARATOR_CTRL_CMP_ROSCCTL_CMP0 = 0x1
	// Position of CMP_EXT_RESET field.
	COMPARATOR_CTRL_CMP_EXT_RESET_Pos = 0x9
	// Bit mask of CMP_EXT_RESET field.
	COMPARATOR_CTRL_CMP_EXT_RESET_Msk = 0x200
	// Bit CMP_EXT_RESET.
	COMPARATOR_CTRL_CMP_EXT_RESET = 0x200
	// The CMP_ROSC output is reset by the internal chip reset.
	COMPARATOR_CTRL_CMP_EXT_RESET_INTRESET = 0x0
	// The CMP_ROSC output is reset by the CMP_RESET input.
	COMPARATOR_CTRL_CMP_EXT_RESET_CMP_RESETIN = 0x1
	// Position of RESERVED field.
	COMPARATOR_CTRL_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	COMPARATOR_CTRL_RESERVED_Msk = 0xc00
	// Position of CMP_T0CAP2 field.
	COMPARATOR_CTRL_CMP_T0CAP2_Pos = 0xc
	// Bit mask of CMP_T0CAP2 field.
	COMPARATOR_CTRL_CMP_T0CAP2_Msk = 0x1000
	// Bit CMP_T0CAP2.
	COMPARATOR_CTRL_CMP_T0CAP2 = 0x1000
	// T0CAP2 is connected to comparator 0 level output.
	COMPARATOR_CTRL_CMP_T0CAP2_COMP0 = 0x0
	// T0CAP2 is connected to comparator 1 level output.
	COMPARATOR_CTRL_CMP_T0CAP2_COMP1 = 0x1
	// Position of CMP_T0CAP3 field.
	COMPARATOR_CTRL_CMP_T0CAP3_Pos = 0xd
	// Bit mask of CMP_T0CAP3 field.
	COMPARATOR_CTRL_CMP_T0CAP3_Msk = 0x2000
	// Bit CMP_T0CAP3.
	COMPARATOR_CTRL_CMP_T0CAP3 = 0x2000
	// T0CAP3 is connected to comparator 0 edge output.
	COMPARATOR_CTRL_CMP_T0CAP3_COMP0 = 0x0
	// T0CAP3 is connected to comparator 1 edge output.
	COMPARATOR_CTRL_CMP_T0CAP3_COMP1 = 0x1
	// Position of CMP_T1CAP2 field.
	COMPARATOR_CTRL_CMP_T1CAP2_Pos = 0xe
	// Bit mask of CMP_T1CAP2 field.
	COMPARATOR_CTRL_CMP_T1CAP2_Msk = 0x4000
	// Bit CMP_T1CAP2.
	COMPARATOR_CTRL_CMP_T1CAP2 = 0x4000
	// T1CAP2 is connected to comparator 1 edge output.
	COMPARATOR_CTRL_CMP_T1CAP2_COMP1 = 0x0
	// T1CAP2 is connected to comparator 0 level output.
	COMPARATOR_CTRL_CMP_T1CAP2_COMP0 = 0x1
	// Position of CMP_T1CAP3 field.
	COMPARATOR_CTRL_CMP_T1CAP3_Pos = 0xf
	// Bit mask of CMP_T1CAP3 field.
	COMPARATOR_CTRL_CMP_T1CAP3_Msk = 0x8000
	// Bit CMP_T1CAP3.
	COMPARATOR_CTRL_CMP_T1CAP3 = 0x8000
	// T1CAP3 is connected to comparator 1 level output.
	COMPARATOR_CTRL_CMP_T1CAP3_COMP1 = 0x0
	// T1CAP3 is connected to comparator 0 edge output.
	COMPARATOR_CTRL_CMP_T1CAP3_COMP0 = 0x1
	// Position of RESERVED field.
	COMPARATOR_CTRL_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	COMPARATOR_CTRL_RESERVED_Msk = 0xffff0000

	// CTRL0: Comparator 0 control register
	// Position of CMP0_EN field.
	COMPARATOR_CTRL0_CMP0_EN_Pos = 0x0
	// Bit mask of CMP0_EN field.
	COMPARATOR_CTRL0_CMP0_EN_Msk = 0x3
	// Comparator 0 disabled.
	COMPARATOR_CTRL0_CMP0_EN_DISABLED = 0x0
	// Comparator 0 is disabled in Deep Sleep and Power-down modes and re-enabled automatically when exiting those modes.
	COMPARATOR_CTRL0_CMP0_EN_DIS_DEEPSLP_PWRDWN = 0x1
	// Comparator 0 is disabled in Power-down mode and re-enabled automatically when exiting Power-down.
	COMPARATOR_CTRL0_CMP0_EN_DIS_PWRDWN = 0x2
	// Comparator 0 is enabled.
	COMPARATOR_CTRL0_CMP0_EN_ENABLED = 0x3
	// Position of CMP0_OE field.
	COMPARATOR_CTRL0_CMP0_OE_Pos = 0x2
	// Bit mask of CMP0_OE field.
	COMPARATOR_CTRL0_CMP0_OE_Msk = 0x4
	// Bit CMP0_OE.
	COMPARATOR_CTRL0_CMP0_OE = 0x4
	// Comparator 0 output is disabled.
	COMPARATOR_CTRL0_CMP0_OE_DISABLED = 0x0
	// Comparator 0 output is enabled.
	COMPARATOR_CTRL0_CMP0_OE_ENABLED = 0x1
	// Position of CMP0_STAT field.
	COMPARATOR_CTRL0_CMP0_STAT_Pos = 0x3
	// Bit mask of CMP0_STAT field.
	COMPARATOR_CTRL0_CMP0_STAT_Msk = 0x8
	// Bit CMP0_STAT.
	COMPARATOR_CTRL0_CMP0_STAT = 0x8
	// Position of CMP0_VM field.
	COMPARATOR_CTRL0_CMP0_VM_Pos = 0x4
	// Bit mask of CMP0_VM field.
	COMPARATOR_CTRL0_CMP0_VM_Msk = 0x70
	// Vref divider 0.
	COMPARATOR_CTRL0_CMP0_VM_VREF_DIVIDER_0_ = 0x0
	// CMP0_IN[0].
	COMPARATOR_CTRL0_CMP0_VM_CMP0_IN0 = 0x1
	// CMP0_IN[1].
	COMPARATOR_CTRL0_CMP0_VM_CMP0_IN1 = 0x2
	// CMP0_IN[2].
	COMPARATOR_CTRL0_CMP0_VM_CMP0_IN2 = 0x3
	// CMP0_IN[3].
	COMPARATOR_CTRL0_CMP0_VM_CMP0_IN3 = 0x4
	// CMP1_IN[0].
	COMPARATOR_CTRL0_CMP0_VM_CMP1_IN0 = 0x5
	// internal 0.9 V band gap reference.
	COMPARATOR_CTRL0_CMP0_VM_INTERNAL_0_9_V_BAND_ = 0x6
	// temperature sensor.
	COMPARATOR_CTRL0_CMP0_VM_TEMPERATURE_SENSOR_ = 0x7
	// Position of RESERVED field.
	COMPARATOR_CTRL0_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	COMPARATOR_CTRL0_RESERVED_Msk = 0x80
	// Bit RESERVED.
	COMPARATOR_CTRL0_RESERVED = 0x80
	// Position of CMP0_VP field.
	COMPARATOR_CTRL0_CMP0_VP_Pos = 0x8
	// Bit mask of CMP0_VP field.
	COMPARATOR_CTRL0_CMP0_VP_Msk = 0x700
	// Vref divider 0.
	COMPARATOR_CTRL0_CMP0_VP_VREF_DIVIDER_0_ = 0x0
	// CMP0_IN[0].
	COMPARATOR_CTRL0_CMP0_VP_CMP0_IN0 = 0x1
	// CMP0_IN[1].
	COMPARATOR_CTRL0_CMP0_VP_CMP0_IN1 = 0x2
	// CMP0_IN[2].
	COMPARATOR_CTRL0_CMP0_VP_CMP0_IN2 = 0x3
	// CMP0_IN[3].
	COMPARATOR_CTRL0_CMP0_VP_CMP0_IN3 = 0x4
	// CMP1_IN[0].
	COMPARATOR_CTRL0_CMP0_VP_CMP1_IN0 = 0x5
	// internal 0.9 V band gap reference.
	COMPARATOR_CTRL0_CMP0_VP_INTERNAL_0_9_V_BAND_ = 0x6
	// temperature sensor.
	COMPARATOR_CTRL0_CMP0_VP_TEMPERATURE_SENSOR_ = 0x7
	// Position of RESERVED field.
	COMPARATOR_CTRL0_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	COMPARATOR_CTRL0_RESERVED_Msk = 0x800
	// Bit RESERVED.
	COMPARATOR_CTRL0_RESERVED = 0x800
	// Position of CMP0_SYNC field.
	COMPARATOR_CTRL0_CMP0_SYNC_Pos = 0xc
	// Bit mask of CMP0_SYNC field.
	COMPARATOR_CTRL0_CMP0_SYNC_Msk = 0x1000
	// Bit CMP0_SYNC.
	COMPARATOR_CTRL0_CMP0_SYNC = 0x1000
	// The comparator 0 output is used directly.
	COMPARATOR_CTRL0_CMP0_SYNC_DIRECT = 0x0
	// The comparator 0 output is synchronized with the internal bus clock for output to other peripherals.
	COMPARATOR_CTRL0_CMP0_SYNC_SYNCH = 0x1
	// Position of CMP0_HYS field.
	COMPARATOR_CTRL0_CMP0_HYS_Pos = 0xd
	// Bit mask of CMP0_HYS field.
	COMPARATOR_CTRL0_CMP0_HYS_Msk = 0x6000
	// Hysteresis is turned off, comparator output will change as the input voltages cross.
	COMPARATOR_CTRL0_CMP0_HYS_HYSTERESISOFF = 0x0
	// Hysteresis = 5 mV.
	COMPARATOR_CTRL0_CMP0_HYS_HYSTERESIS_EQ_5_MV_ = 0x1
	// Hysteresis = 10 mV.
	COMPARATOR_CTRL0_CMP0_HYS_HYSTERESIS_EQ_10_MV_ = 0x2
	// Hysteresis = 15 mV.
	COMPARATOR_CTRL0_CMP0_HYS_HYSTERESIS_EQ_15_MV_ = 0x3
	// Position of CMP0_INTPOL field.
	COMPARATOR_CTRL0_CMP0_INTPOL_Pos = 0xf
	// Bit mask of CMP0_INTPOL field.
	COMPARATOR_CTRL0_CMP0_INTPOL_Msk = 0x8000
	// Bit CMP0_INTPOL.
	COMPARATOR_CTRL0_CMP0_INTPOL = 0x8000
	// The CMP0 output is used as-is for generating interrupts.
	COMPARATOR_CTRL0_CMP0_INTPOL_NOTINVERTED = 0x0
	// The CMP0 output is used inverted for generating interrupts.
	COMPARATOR_CTRL0_CMP0_INTPOL_INVERTED = 0x1
	// Position of CMP0_INTTYPE field.
	COMPARATOR_CTRL0_CMP0_INTTYPE_Pos = 0x10
	// Bit mask of CMP0_INTTYPE field.
	COMPARATOR_CTRL0_CMP0_INTTYPE_Msk = 0x10000
	// Bit CMP0_INTTYPE.
	COMPARATOR_CTRL0_CMP0_INTTYPE = 0x10000
	// Comparator 0 interrupt is edge triggered.
	COMPARATOR_CTRL0_CMP0_INTTYPE_EDGE = 0x0
	// Comparator 0 interrupt is level triggered.
	COMPARATOR_CTRL0_CMP0_INTTYPE_LEVEL = 0x1
	// Position of CMP0_INTEDGE field.
	COMPARATOR_CTRL0_CMP0_INTEDGE_Pos = 0x11
	// Bit mask of CMP0_INTEDGE field.
	COMPARATOR_CTRL0_CMP0_INTEDGE_Msk = 0x60000
	// Comparator 0 interrupt is active on falling edges.
	COMPARATOR_CTRL0_CMP0_INTEDGE_FALLING = 0x0
	// Comparator 0 interrupt is active on rising edges.
	COMPARATOR_CTRL0_CMP0_INTEDGE_RISING = 0x1
	// Comparator 0 Interrupt is active on both edges.
	COMPARATOR_CTRL0_CMP0_INTEDGE_DUALEDGE = 0x2
	// reserved.
	COMPARATOR_CTRL0_CMP0_INTEDGE_RESERVED_ = 0x3
	// Position of CMP0_INTFLAG field.
	COMPARATOR_CTRL0_CMP0_INTFLAG_Pos = 0x13
	// Bit mask of CMP0_INTFLAG field.
	COMPARATOR_CTRL0_CMP0_INTFLAG_Msk = 0x80000
	// Bit CMP0_INTFLAG.
	COMPARATOR_CTRL0_CMP0_INTFLAG = 0x80000
	// The Comparator 0 interrupt is not pending.
	COMPARATOR_CTRL0_CMP0_INTFLAG_NOTPENDING = 0x0
	// The Comparator 0 interrupt is pending. Writing a 1 to this bit clears the flag.
	COMPARATOR_CTRL0_CMP0_INTFLAG_PENDING = 0x1
	// Position of CMP0_VLADEN field.
	COMPARATOR_CTRL0_CMP0_VLADEN_Pos = 0x14
	// Bit mask of CMP0_VLADEN field.
	COMPARATOR_CTRL0_CMP0_VLADEN_Msk = 0x300000
	// The Comparator 0 voltage ladder is disabled.
	COMPARATOR_CTRL0_CMP0_VLADEN_DISABLED = 0x0
	// The Comparator 0 voltage ladder is disabled in Deep Sleep and Power-down modes and re-enabled automatically when exiting those modes.
	COMPARATOR_CTRL0_CMP0_VLADEN_DIS_DEEPSLP_PWRDWN = 0x1
	// The Comparator 0 voltage ladder is disabled in Power-down mode and re-enabled automatically when exiting Power-down.
	COMPARATOR_CTRL0_CMP0_VLADEN_DIS_PWRDWN = 0x2
	// The Comparator 0 voltage ladder is enabled.
	COMPARATOR_CTRL0_CMP0_VLADEN_ENABLED = 0x3
	// Position of CMP0_VLADREF field.
	COMPARATOR_CTRL0_CMP0_VLADREF_Pos = 0x16
	// Bit mask of CMP0_VLADREF field.
	COMPARATOR_CTRL0_CMP0_VLADREF_Msk = 0x400000
	// Bit CMP0_VLADREF.
	COMPARATOR_CTRL0_CMP0_VLADREF = 0x400000
	// VREF_CMP pin.
	COMPARATOR_CTRL0_CMP0_VLADREF_VREF_CMP_PIN_ = 0x0
	// VDDA pin.
	COMPARATOR_CTRL0_CMP0_VLADREF_VDDA_PIN_ = 0x1
	// Position of RESERVED field.
	COMPARATOR_CTRL0_RESERVED_Pos = 0x17
	// Bit mask of RESERVED field.
	COMPARATOR_CTRL0_RESERVED_Msk = 0x800000
	// Bit RESERVED.
	COMPARATOR_CTRL0_RESERVED = 0x800000
	// Position of CMP0_VSEL field.
	COMPARATOR_CTRL0_CMP0_VSEL_Pos = 0x18
	// Bit mask of CMP0_VSEL field.
	COMPARATOR_CTRL0_CMP0_VSEL_Msk = 0x1f000000
	// Position of RESERVED field.
	COMPARATOR_CTRL0_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	COMPARATOR_CTRL0_RESERVED_Msk = 0xe0000000

	// CTRL1: Comparator 1 control register
	// Position of CMP1_EN field.
	COMPARATOR_CTRL1_CMP1_EN_Pos = 0x0
	// Bit mask of CMP1_EN field.
	COMPARATOR_CTRL1_CMP1_EN_Msk = 0x3
	// Comparator 1 disabled.
	COMPARATOR_CTRL1_CMP1_EN_DISABLED = 0x0
	// Comparator 1 is disabled in Deep Sleep and Power-down modes and re-enabled automatically when exiting those modes.
	COMPARATOR_CTRL1_CMP1_EN_DIS_DEEPSLP_PWRDWN = 0x1
	// Comparator 1 is disabled in Power-down mode and re-enabled automatically when exiting Power-down.
	COMPARATOR_CTRL1_CMP1_EN_DIS_PWRDWN = 0x2
	// Comparator 1 is enabled.
	COMPARATOR_CTRL1_CMP1_EN_ENABLED = 0x3
	// Position of CMP1_OE field.
	COMPARATOR_CTRL1_CMP1_OE_Pos = 0x2
	// Bit mask of CMP1_OE field.
	COMPARATOR_CTRL1_CMP1_OE_Msk = 0x4
	// Bit CMP1_OE.
	COMPARATOR_CTRL1_CMP1_OE = 0x4
	// Comparator 1 output is disabled.
	COMPARATOR_CTRL1_CMP1_OE_DISABLED = 0x0
	// Comparator 1 output is enabled.
	COMPARATOR_CTRL1_CMP1_OE_ENABLED = 0x1
	// Position of CMP1_STAT field.
	COMPARATOR_CTRL1_CMP1_STAT_Pos = 0x3
	// Bit mask of CMP1_STAT field.
	COMPARATOR_CTRL1_CMP1_STAT_Msk = 0x8
	// Bit CMP1_STAT.
	COMPARATOR_CTRL1_CMP1_STAT = 0x8
	// Position of CMP1_VM field.
	COMPARATOR_CTRL1_CMP1_VM_Pos = 0x4
	// Bit mask of CMP1_VM field.
	COMPARATOR_CTRL1_CMP1_VM_Msk = 0x70
	// Vref divider 1.
	COMPARATOR_CTRL1_CMP1_VM_VREF_DIVIDER_1_ = 0x0
	// CMP1_IN[0].
	COMPARATOR_CTRL1_CMP1_VM_CMP1_IN0 = 0x1
	// CMP1_IN[1].
	COMPARATOR_CTRL1_CMP1_VM_CMP1_IN1 = 0x2
	// CMP1_IN[2].
	COMPARATOR_CTRL1_CMP1_VM_CMP1_IN2 = 0x3
	// CMP1_IN[3].
	COMPARATOR_CTRL1_CMP1_VM_CMP1_IN3 = 0x4
	// CMP0_IN[0].
	COMPARATOR_CTRL1_CMP1_VM_CMP0_IN0 = 0x5
	// internal 0.9 V band gap reference.
	COMPARATOR_CTRL1_CMP1_VM_INTERNAL_0_9_V_BAND_ = 0x6
	// temperature sensor.
	COMPARATOR_CTRL1_CMP1_VM_TEMPERATURE_SENSOR_ = 0x7
	// Position of RESERVED field.
	COMPARATOR_CTRL1_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	COMPARATOR_CTRL1_RESERVED_Msk = 0x80
	// Bit RESERVED.
	COMPARATOR_CTRL1_RESERVED = 0x80
	// Position of CMP1_VP field.
	COMPARATOR_CTRL1_CMP1_VP_Pos = 0x8
	// Bit mask of CMP1_VP field.
	COMPARATOR_CTRL1_CMP1_VP_Msk = 0x700
	// Vref divider 0.
	COMPARATOR_CTRL1_CMP1_VP_VREF_DIVIDER_0_ = 0x0
	// CMP1_IN[0].
	COMPARATOR_CTRL1_CMP1_VP_CMP1_IN0 = 0x1
	// CMP1_IN[1].
	COMPARATOR_CTRL1_CMP1_VP_CMP1_IN1 = 0x2
	// CMP1_IN[2].
	COMPARATOR_CTRL1_CMP1_VP_CMP1_IN2 = 0x3
	// CMP1_IN[3].
	COMPARATOR_CTRL1_CMP1_VP_CMP1_IN3 = 0x4
	// CMP0_IN[0].
	COMPARATOR_CTRL1_CMP1_VP_CMP0_IN0 = 0x5
	// internal 0.9 V band gap reference.
	COMPARATOR_CTRL1_CMP1_VP_INTERNAL_0_9_V_BAND_ = 0x6
	// temperature sensor.
	COMPARATOR_CTRL1_CMP1_VP_TEMPERATURE_SENSOR_ = 0x7
	// Position of RESERVED field.
	COMPARATOR_CTRL1_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	COMPARATOR_CTRL1_RESERVED_Msk = 0x800
	// Bit RESERVED.
	COMPARATOR_CTRL1_RESERVED = 0x800
	// Position of CMP1_SYNC field.
	COMPARATOR_CTRL1_CMP1_SYNC_Pos = 0xc
	// Bit mask of CMP1_SYNC field.
	COMPARATOR_CTRL1_CMP1_SYNC_Msk = 0x1000
	// Bit CMP1_SYNC.
	COMPARATOR_CTRL1_CMP1_SYNC = 0x1000
	// The comparator 1 output is used directly.
	COMPARATOR_CTRL1_CMP1_SYNC_DIRECT = 0x0
	// The comparator 1 output is synchronized with the internal bus clock for output to other peripherals.
	COMPARATOR_CTRL1_CMP1_SYNC_SYNCH = 0x1
	// Position of CMP1_HYS field.
	COMPARATOR_CTRL1_CMP1_HYS_Pos = 0xd
	// Bit mask of CMP1_HYS field.
	COMPARATOR_CTRL1_CMP1_HYS_Msk = 0x6000
	// Hysteresis is turned off, comparator output will change as the input voltages cross.
	COMPARATOR_CTRL1_CMP1_HYS_HYSTERESISOFF = 0x0
	// Hysteresis = 5 mV.
	COMPARATOR_CTRL1_CMP1_HYS_HYSTERESIS_EQ_5_MV_ = 0x1
	// Hysteresis = 10 mV.
	COMPARATOR_CTRL1_CMP1_HYS_HYSTERESIS_EQ_10_MV_ = 0x2
	// Hysteresis = 15 mV.
	COMPARATOR_CTRL1_CMP1_HYS_HYSTERESIS_EQ_15_MV_ = 0x3
	// Position of CMP1_INTPOL field.
	COMPARATOR_CTRL1_CMP1_INTPOL_Pos = 0xf
	// Bit mask of CMP1_INTPOL field.
	COMPARATOR_CTRL1_CMP1_INTPOL_Msk = 0x8000
	// Bit CMP1_INTPOL.
	COMPARATOR_CTRL1_CMP1_INTPOL = 0x8000
	// The CMP1 output is used as-is for generating interrupts.
	COMPARATOR_CTRL1_CMP1_INTPOL_NOTINVERTED = 0x0
	// The CMP1 output is used inverted for generating interrupts.
	COMPARATOR_CTRL1_CMP1_INTPOL_INVERTED = 0x1
	// Position of CMP1_INTTYPE field.
	COMPARATOR_CTRL1_CMP1_INTTYPE_Pos = 0x10
	// Bit mask of CMP1_INTTYPE field.
	COMPARATOR_CTRL1_CMP1_INTTYPE_Msk = 0x10000
	// Bit CMP1_INTTYPE.
	COMPARATOR_CTRL1_CMP1_INTTYPE = 0x10000
	// Comparator 1 interrupt is edge triggered.
	COMPARATOR_CTRL1_CMP1_INTTYPE_EDGE = 0x0
	// Comparator 1 interrupt is level triggered.
	COMPARATOR_CTRL1_CMP1_INTTYPE_LEVEL = 0x1
	// Position of CMP1_INTEDGE field.
	COMPARATOR_CTRL1_CMP1_INTEDGE_Pos = 0x11
	// Bit mask of CMP1_INTEDGE field.
	COMPARATOR_CTRL1_CMP1_INTEDGE_Msk = 0x60000
	// Comparator 1 interrupt is active on falling edges.
	COMPARATOR_CTRL1_CMP1_INTEDGE_FALLING = 0x0
	// Comparator 1 interrupt is active on rising edges.
	COMPARATOR_CTRL1_CMP1_INTEDGE_RISING = 0x1
	// Comparator 1 Interrupt is active on both edges.
	COMPARATOR_CTRL1_CMP1_INTEDGE_DUALEDGE = 0x2
	// reserved.
	COMPARATOR_CTRL1_CMP1_INTEDGE_RESERVED_ = 0x3
	// Position of CMP1_INTFLAG field.
	COMPARATOR_CTRL1_CMP1_INTFLAG_Pos = 0x13
	// Bit mask of CMP1_INTFLAG field.
	COMPARATOR_CTRL1_CMP1_INTFLAG_Msk = 0x80000
	// Bit CMP1_INTFLAG.
	COMPARATOR_CTRL1_CMP1_INTFLAG = 0x80000
	// The Comparator 1 interrupt is not pending.
	COMPARATOR_CTRL1_CMP1_INTFLAG_NOTPENDING = 0x0
	// The Comparator 1 interrupt is pending. Writing a 1 to this bit clears the flag.
	COMPARATOR_CTRL1_CMP1_INTFLAG_PENDING = 0x1
	// Position of CMP1_VLADEN field.
	COMPARATOR_CTRL1_CMP1_VLADEN_Pos = 0x14
	// Bit mask of CMP1_VLADEN field.
	COMPARATOR_CTRL1_CMP1_VLADEN_Msk = 0x300000
	// The Comparator 1 voltage ladder is disabled.
	COMPARATOR_CTRL1_CMP1_VLADEN_DISABLED = 0x0
	// The Comparator 1 voltage ladder is disabled in Deep Sleep and Power-down modes and re-enabled automatically when exiting those modes.
	COMPARATOR_CTRL1_CMP1_VLADEN_DIS_DEEPSLP_PWRDWN = 0x1
	// The Comparator 1 voltage ladder is disabled in Power-down mode and re-enabled automatically when exiting Power-down.
	COMPARATOR_CTRL1_CMP1_VLADEN_DIS_PWRDWN = 0x2
	// The Comparator 1 voltage ladder is enabled.
	COMPARATOR_CTRL1_CMP1_VLADEN_ENABLED = 0x3
	// Position of CMP1_VLADREF field.
	COMPARATOR_CTRL1_CMP1_VLADREF_Pos = 0x16
	// Bit mask of CMP1_VLADREF field.
	COMPARATOR_CTRL1_CMP1_VLADREF_Msk = 0x400000
	// Bit CMP1_VLADREF.
	COMPARATOR_CTRL1_CMP1_VLADREF = 0x400000
	// VREF_CMP pin.
	COMPARATOR_CTRL1_CMP1_VLADREF_VREF_CMP_PIN_ = 0x0
	// VDDA pin.
	COMPARATOR_CTRL1_CMP1_VLADREF_VDDA_PIN_ = 0x1
	// Position of RESERVED field.
	COMPARATOR_CTRL1_RESERVED_Pos = 0x17
	// Bit mask of RESERVED field.
	COMPARATOR_CTRL1_RESERVED_Msk = 0x800000
	// Bit RESERVED.
	COMPARATOR_CTRL1_RESERVED = 0x800000
	// Position of CMP1_VSel field.
	COMPARATOR_CTRL1_CMP1_VSel_Pos = 0x18
	// Bit mask of CMP1_VSel field.
	COMPARATOR_CTRL1_CMP1_VSel_Msk = 0x1f000000
	// Position of RESERVED field.
	COMPARATOR_CTRL1_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	COMPARATOR_CTRL1_RESERVED_Msk = 0xe0000000
)

// Constants for RTC: Real Time Clock (RTC)
const (
	// ILR: Interrupt Location Register
	// Position of RTCCIF field.
	RTC_ILR_RTCCIF_Pos = 0x0
	// Bit mask of RTCCIF field.
	RTC_ILR_RTCCIF_Msk = 0x1
	// Bit RTCCIF.
	RTC_ILR_RTCCIF = 0x1
	// Position of RTCALF field.
	RTC_ILR_RTCALF_Pos = 0x1
	// Bit mask of RTCALF field.
	RTC_ILR_RTCALF_Msk = 0x2
	// Bit RTCALF.
	RTC_ILR_RTCALF = 0x2
	// Position of RESERVED field.
	RTC_ILR_RESERVED_Pos = 0x15
	// Bit mask of RESERVED field.
	RTC_ILR_RESERVED_Msk = 0xffe00000

	// CCR: Clock Control Register
	// Position of CLKEN field.
	RTC_CCR_CLKEN_Pos = 0x0
	// Bit mask of CLKEN field.
	RTC_CCR_CLKEN_Msk = 0x1
	// Bit CLKEN.
	RTC_CCR_CLKEN = 0x1
	// Position of CTCRST field.
	RTC_CCR_CTCRST_Pos = 0x1
	// Bit mask of CTCRST field.
	RTC_CCR_CTCRST_Msk = 0x2
	// Bit CTCRST.
	RTC_CCR_CTCRST = 0x2
	// When one, the elements in the internal oscillator divider are reset, and remain reset until CCR[1] is changed to zero. This is the divider that generates the 1 Hz clock from the 32.768 kHz crystal. The state of the divider is not visible to software.
	RTC_CCR_CTCRST_RESET = 0x1
	// No effect.
	RTC_CCR_CTCRST_NO_EFFECT_ = 0x0
	// Position of RESERVED field.
	RTC_CCR_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	RTC_CCR_RESERVED_Msk = 0xc
	// Position of CCALEN field.
	RTC_CCR_CCALEN_Pos = 0x4
	// Bit mask of CCALEN field.
	RTC_CCR_CCALEN_Msk = 0x10
	// Bit CCALEN.
	RTC_CCR_CCALEN = 0x10
	// Position of RESERVED field.
	RTC_CCR_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	RTC_CCR_RESERVED_Msk = 0xffffffe0

	// CIIR: Counter Increment Interrupt Register
	// Position of IMSEC field.
	RTC_CIIR_IMSEC_Pos = 0x0
	// Bit mask of IMSEC field.
	RTC_CIIR_IMSEC_Msk = 0x1
	// Bit IMSEC.
	RTC_CIIR_IMSEC = 0x1
	// Position of IMMIN field.
	RTC_CIIR_IMMIN_Pos = 0x1
	// Bit mask of IMMIN field.
	RTC_CIIR_IMMIN_Msk = 0x2
	// Bit IMMIN.
	RTC_CIIR_IMMIN = 0x2
	// Position of IMHOUR field.
	RTC_CIIR_IMHOUR_Pos = 0x2
	// Bit mask of IMHOUR field.
	RTC_CIIR_IMHOUR_Msk = 0x4
	// Bit IMHOUR.
	RTC_CIIR_IMHOUR = 0x4
	// Position of IMDOM field.
	RTC_CIIR_IMDOM_Pos = 0x3
	// Bit mask of IMDOM field.
	RTC_CIIR_IMDOM_Msk = 0x8
	// Bit IMDOM.
	RTC_CIIR_IMDOM = 0x8
	// Position of IMDOW field.
	RTC_CIIR_IMDOW_Pos = 0x4
	// Bit mask of IMDOW field.
	RTC_CIIR_IMDOW_Msk = 0x10
	// Bit IMDOW.
	RTC_CIIR_IMDOW = 0x10
	// Position of IMDOY field.
	RTC_CIIR_IMDOY_Pos = 0x5
	// Bit mask of IMDOY field.
	RTC_CIIR_IMDOY_Msk = 0x20
	// Bit IMDOY.
	RTC_CIIR_IMDOY = 0x20
	// Position of IMMON field.
	RTC_CIIR_IMMON_Pos = 0x6
	// Bit mask of IMMON field.
	RTC_CIIR_IMMON_Msk = 0x40
	// Bit IMMON.
	RTC_CIIR_IMMON = 0x40
	// Position of IMYEAR field.
	RTC_CIIR_IMYEAR_Pos = 0x7
	// Bit mask of IMYEAR field.
	RTC_CIIR_IMYEAR_Msk = 0x80
	// Bit IMYEAR.
	RTC_CIIR_IMYEAR = 0x80
	// Position of RESERVED field.
	RTC_CIIR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	RTC_CIIR_RESERVED_Msk = 0xffffff00

	// AMR: Alarm Mask Register
	// Position of AMRSEC field.
	RTC_AMR_AMRSEC_Pos = 0x0
	// Bit mask of AMRSEC field.
	RTC_AMR_AMRSEC_Msk = 0x1
	// Bit AMRSEC.
	RTC_AMR_AMRSEC = 0x1
	// Position of AMRMIN field.
	RTC_AMR_AMRMIN_Pos = 0x1
	// Bit mask of AMRMIN field.
	RTC_AMR_AMRMIN_Msk = 0x2
	// Bit AMRMIN.
	RTC_AMR_AMRMIN = 0x2
	// Position of AMRHOUR field.
	RTC_AMR_AMRHOUR_Pos = 0x2
	// Bit mask of AMRHOUR field.
	RTC_AMR_AMRHOUR_Msk = 0x4
	// Bit AMRHOUR.
	RTC_AMR_AMRHOUR = 0x4
	// Position of AMRDOM field.
	RTC_AMR_AMRDOM_Pos = 0x3
	// Bit mask of AMRDOM field.
	RTC_AMR_AMRDOM_Msk = 0x8
	// Bit AMRDOM.
	RTC_AMR_AMRDOM = 0x8
	// Position of AMRDOW field.
	RTC_AMR_AMRDOW_Pos = 0x4
	// Bit mask of AMRDOW field.
	RTC_AMR_AMRDOW_Msk = 0x10
	// Bit AMRDOW.
	RTC_AMR_AMRDOW = 0x10
	// Position of AMRDOY field.
	RTC_AMR_AMRDOY_Pos = 0x5
	// Bit mask of AMRDOY field.
	RTC_AMR_AMRDOY_Msk = 0x20
	// Bit AMRDOY.
	RTC_AMR_AMRDOY = 0x20
	// Position of AMRMON field.
	RTC_AMR_AMRMON_Pos = 0x6
	// Bit mask of AMRMON field.
	RTC_AMR_AMRMON_Msk = 0x40
	// Bit AMRMON.
	RTC_AMR_AMRMON = 0x40
	// Position of AMRYEAR field.
	RTC_AMR_AMRYEAR_Pos = 0x7
	// Bit mask of AMRYEAR field.
	RTC_AMR_AMRYEAR_Msk = 0x80
	// Bit AMRYEAR.
	RTC_AMR_AMRYEAR = 0x80
	// Position of RESERVED field.
	RTC_AMR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	RTC_AMR_RESERVED_Msk = 0xffffff00

	// CTIME0: Consolidated Time Register 0
	// Position of SECONDS field.
	RTC_CTIME0_SECONDS_Pos = 0x0
	// Bit mask of SECONDS field.
	RTC_CTIME0_SECONDS_Msk = 0x3f
	// Position of RESERVED field.
	RTC_CTIME0_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	RTC_CTIME0_RESERVED_Msk = 0xc0
	// Position of MINUTES field.
	RTC_CTIME0_MINUTES_Pos = 0x8
	// Bit mask of MINUTES field.
	RTC_CTIME0_MINUTES_Msk = 0x3f00
	// Position of RESERVED field.
	RTC_CTIME0_RESERVED_Pos = 0xe
	// Bit mask of RESERVED field.
	RTC_CTIME0_RESERVED_Msk = 0xc000
	// Position of HOURS field.
	RTC_CTIME0_HOURS_Pos = 0x10
	// Bit mask of HOURS field.
	RTC_CTIME0_HOURS_Msk = 0x1f0000
	// Position of RESERVED field.
	RTC_CTIME0_RESERVED_Pos = 0x15
	// Bit mask of RESERVED field.
	RTC_CTIME0_RESERVED_Msk = 0xe00000
	// Position of DOW field.
	RTC_CTIME0_DOW_Pos = 0x18
	// Bit mask of DOW field.
	RTC_CTIME0_DOW_Msk = 0x7000000
	// Position of RESERVED field.
	RTC_CTIME0_RESERVED_Pos = 0x1b
	// Bit mask of RESERVED field.
	RTC_CTIME0_RESERVED_Msk = 0xf8000000

	// CTIME1: Consolidated Time Register 1
	// Position of DOM field.
	RTC_CTIME1_DOM_Pos = 0x0
	// Bit mask of DOM field.
	RTC_CTIME1_DOM_Msk = 0x1f
	// Position of RESERVED field.
	RTC_CTIME1_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	RTC_CTIME1_RESERVED_Msk = 0xe0
	// Position of MONTH field.
	RTC_CTIME1_MONTH_Pos = 0x8
	// Bit mask of MONTH field.
	RTC_CTIME1_MONTH_Msk = 0xf00
	// Position of RESERVED field.
	RTC_CTIME1_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	RTC_CTIME1_RESERVED_Msk = 0xf000
	// Position of YEAR field.
	RTC_CTIME1_YEAR_Pos = 0x10
	// Bit mask of YEAR field.
	RTC_CTIME1_YEAR_Msk = 0xfff0000
	// Position of RESERVED field.
	RTC_CTIME1_RESERVED_Pos = 0x1c
	// Bit mask of RESERVED field.
	RTC_CTIME1_RESERVED_Msk = 0xf0000000

	// CTIME2: Consolidated Time Register 2
	// Position of DOY field.
	RTC_CTIME2_DOY_Pos = 0x0
	// Bit mask of DOY field.
	RTC_CTIME2_DOY_Msk = 0xfff
	// Position of RESERVED field.
	RTC_CTIME2_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	RTC_CTIME2_RESERVED_Msk = 0xfffff000

	// SEC: Seconds Counter
	// Position of SECONDS field.
	RTC_SEC_SECONDS_Pos = 0x0
	// Bit mask of SECONDS field.
	RTC_SEC_SECONDS_Msk = 0x3f
	// Position of RESERVED field.
	RTC_SEC_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	RTC_SEC_RESERVED_Msk = 0xffffffc0

	// MIN: Minutes Register
	// Position of MINUTES field.
	RTC_MIN_MINUTES_Pos = 0x0
	// Bit mask of MINUTES field.
	RTC_MIN_MINUTES_Msk = 0x3f
	// Position of RESERVED field.
	RTC_MIN_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	RTC_MIN_RESERVED_Msk = 0xffffffc0

	// HRS: Hours Register
	// Position of HOURS field.
	RTC_HRS_HOURS_Pos = 0x0
	// Bit mask of HOURS field.
	RTC_HRS_HOURS_Msk = 0x1f
	// Position of RESERVED field.
	RTC_HRS_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	RTC_HRS_RESERVED_Msk = 0xffffffe0

	// DOM: Day of Month Register
	// Position of DOM field.
	RTC_DOM_DOM_Pos = 0x0
	// Bit mask of DOM field.
	RTC_DOM_DOM_Msk = 0x1f
	// Position of RESERVED field.
	RTC_DOM_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	RTC_DOM_RESERVED_Msk = 0xffffffe0

	// DOW: Day of Week Register
	// Position of DOW field.
	RTC_DOW_DOW_Pos = 0x0
	// Bit mask of DOW field.
	RTC_DOW_DOW_Msk = 0x7
	// Position of RESERVED field.
	RTC_DOW_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RTC_DOW_RESERVED_Msk = 0xfffffff8

	// DOY: Day of Year Register
	// Position of DOY field.
	RTC_DOY_DOY_Pos = 0x0
	// Bit mask of DOY field.
	RTC_DOY_DOY_Msk = 0x1ff
	// Position of RESERVED field.
	RTC_DOY_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	RTC_DOY_RESERVED_Msk = 0xfffffe00

	// MONTH: Months Register
	// Position of MONTH field.
	RTC_MONTH_MONTH_Pos = 0x0
	// Bit mask of MONTH field.
	RTC_MONTH_MONTH_Msk = 0xf
	// Position of RESERVED field.
	RTC_MONTH_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	RTC_MONTH_RESERVED_Msk = 0xfffffff0

	// YEAR: Years Register
	// Position of YEAR field.
	RTC_YEAR_YEAR_Pos = 0x0
	// Bit mask of YEAR field.
	RTC_YEAR_YEAR_Msk = 0xfff
	// Position of RESERVED field.
	RTC_YEAR_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	RTC_YEAR_RESERVED_Msk = 0xfffff000

	// CALIBRATION: Calibration Value Register
	// Position of CALVAL field.
	RTC_CALIBRATION_CALVAL_Pos = 0x0
	// Bit mask of CALVAL field.
	RTC_CALIBRATION_CALVAL_Msk = 0x1ffff
	// Position of CALDIR field.
	RTC_CALIBRATION_CALDIR_Pos = 0x11
	// Bit mask of CALDIR field.
	RTC_CALIBRATION_CALDIR_Msk = 0x20000
	// Bit CALDIR.
	RTC_CALIBRATION_CALDIR = 0x20000
	// Backward calibration. When CALVAL is equal to the calibration counter, the RTC timers will stop incrementing for 1 second.
	RTC_CALIBRATION_CALDIR_BACKWARD_CALIBRATION = 0x1
	// Forward calibration. When CALVAL is equal to the calibration counter, the RTC timers will jump by 2 seconds.
	RTC_CALIBRATION_CALDIR_FORWARD_CALIBRATION_ = 0x0

	// GPREG0: General Purpose Register 0
	// Position of GP field.
	RTC_GPREG_GP_Pos = 0x0
	// Bit mask of GP field.
	RTC_GPREG_GP_Msk = 0xffffffff

	// RTC_AUXEN: RTC Auxiliary Enable register
	// Position of RESERVED field.
	RTC_RTC_AUXEN_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RTC_RTC_AUXEN_RESERVED_Msk = 0xf
	// Position of RTC_OSCFEN field.
	RTC_RTC_AUXEN_RTC_OSCFEN_Pos = 0x4
	// Bit mask of RTC_OSCFEN field.
	RTC_RTC_AUXEN_RTC_OSCFEN_Msk = 0x10
	// Bit RTC_OSCFEN.
	RTC_RTC_AUXEN_RTC_OSCFEN = 0x10
	// Position of RESERVED field.
	RTC_RTC_AUXEN_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	RTC_RTC_AUXEN_RESERVED_Msk = 0xffffffe0

	// RTC_AUX: RTC Auxiliary control register
	// Position of RESERVED field.
	RTC_RTC_AUX_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	RTC_RTC_AUX_RESERVED_Msk = 0xf
	// Position of RTC_OSCF field.
	RTC_RTC_AUX_RTC_OSCF_Pos = 0x4
	// Bit mask of RTC_OSCF field.
	RTC_RTC_AUX_RTC_OSCF_Msk = 0x10
	// Bit RTC_OSCF.
	RTC_RTC_AUX_RTC_OSCF = 0x10
	// Position of RESERVED field.
	RTC_RTC_AUX_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	RTC_RTC_AUX_RESERVED_Msk = 0x20
	// Bit RESERVED.
	RTC_RTC_AUX_RESERVED = 0x20
	// Position of RTC_PDOUT field.
	RTC_RTC_AUX_RTC_PDOUT_Pos = 0x6
	// Bit mask of RTC_PDOUT field.
	RTC_RTC_AUX_RTC_PDOUT_Msk = 0x40
	// Bit RTC_PDOUT.
	RTC_RTC_AUX_RTC_PDOUT = 0x40
	// Position of RESERVED field.
	RTC_RTC_AUX_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	RTC_RTC_AUX_RESERVED_Msk = 0xffffff80

	// ASEC: Alarm value for Seconds
	// Position of SECONDS field.
	RTC_ASEC_SECONDS_Pos = 0x0
	// Bit mask of SECONDS field.
	RTC_ASEC_SECONDS_Msk = 0x3f
	// Position of RESERVED field.
	RTC_ASEC_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	RTC_ASEC_RESERVED_Msk = 0xffffffc0

	// AMIN: Alarm value for Minutes
	// Position of MINUTES field.
	RTC_AMIN_MINUTES_Pos = 0x0
	// Bit mask of MINUTES field.
	RTC_AMIN_MINUTES_Msk = 0x3f
	// Position of RESERVED field.
	RTC_AMIN_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	RTC_AMIN_RESERVED_Msk = 0xffffffc0

	// AHRS: Alarm value for Hours
	// Position of HOURS field.
	RTC_AHRS_HOURS_Pos = 0x0
	// Bit mask of HOURS field.
	RTC_AHRS_HOURS_Msk = 0x1f
	// Position of RESERVED field.
	RTC_AHRS_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	RTC_AHRS_RESERVED_Msk = 0xffffffe0

	// ADOM: Alarm value for Day of Month
	// Position of DOM field.
	RTC_ADOM_DOM_Pos = 0x0
	// Bit mask of DOM field.
	RTC_ADOM_DOM_Msk = 0x1f
	// Position of RESERVED field.
	RTC_ADOM_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	RTC_ADOM_RESERVED_Msk = 0xffffffe0

	// ADOW: Alarm value for Day of Week
	// Position of DOW field.
	RTC_ADOW_DOW_Pos = 0x0
	// Bit mask of DOW field.
	RTC_ADOW_DOW_Msk = 0x7
	// Position of RESERVED field.
	RTC_ADOW_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RTC_ADOW_RESERVED_Msk = 0xfffffff8

	// ADOY: Alarm value for Day of Year
	// Position of DOY field.
	RTC_ADOY_DOY_Pos = 0x0
	// Bit mask of DOY field.
	RTC_ADOY_DOY_Msk = 0x1ff
	// Position of RESERVED field.
	RTC_ADOY_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	RTC_ADOY_RESERVED_Msk = 0xfffffe00

	// AMON: Alarm value for Months
	// Position of MONTH field.
	RTC_AMON_MONTH_Pos = 0x0
	// Bit mask of MONTH field.
	RTC_AMON_MONTH_Msk = 0xf
	// Position of RESERVED field.
	RTC_AMON_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	RTC_AMON_RESERVED_Msk = 0xfffffff0

	// AYRS: Alarm value for Year
	// Position of YEAR field.
	RTC_AYRS_YEAR_Pos = 0x0
	// Bit mask of YEAR field.
	RTC_AYRS_YEAR_Msk = 0xfff
	// Position of RESERVED field.
	RTC_AYRS_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	RTC_AYRS_RESERVED_Msk = 0xfffff000

	// ERSTATUS: Event Monitor/Recorder Status register. Contains status flags for event channels and other Event Monitor/Recorder conditions.
	// Position of EV0 field.
	RTC_ERSTATUS_EV0_Pos = 0x0
	// Bit mask of EV0 field.
	RTC_ERSTATUS_EV0_Msk = 0x1
	// Bit EV0.
	RTC_ERSTATUS_EV0 = 0x1
	// No event change on channel 0.
	RTC_ERSTATUS_EV0_NO_EVENT_CHANGE_ON_C = 0x0
	// At least one event has occurred on channel 0.
	RTC_ERSTATUS_EV0_AT_LEAST_ONE_EVENT_H = 0x1
	// Position of EV1 field.
	RTC_ERSTATUS_EV1_Pos = 0x1
	// Bit mask of EV1 field.
	RTC_ERSTATUS_EV1_Msk = 0x2
	// Bit EV1.
	RTC_ERSTATUS_EV1 = 0x2
	// No event change on channel 1.
	RTC_ERSTATUS_EV1_NO_EVENT_CHANGE_ON_C = 0x0
	// At least one event has occurred on channel 1.
	RTC_ERSTATUS_EV1_AT_LEAST_ONE_EVENT_H = 0x1
	// Position of EV2 field.
	RTC_ERSTATUS_EV2_Pos = 0x2
	// Bit mask of EV2 field.
	RTC_ERSTATUS_EV2_Msk = 0x4
	// Bit EV2.
	RTC_ERSTATUS_EV2 = 0x4
	// No event change on channel 2.
	RTC_ERSTATUS_EV2_NO_EVENT_CHANGE_ON_C = 0x0
	// At least one event has occurred on channel 2.
	RTC_ERSTATUS_EV2_AT_LEAST_ONE_EVENT_H = 0x1
	// Position of GP_CLEARED field.
	RTC_ERSTATUS_GP_CLEARED_Pos = 0x3
	// Bit mask of GP_CLEARED field.
	RTC_ERSTATUS_GP_CLEARED_Msk = 0x8
	// Bit GP_CLEARED.
	RTC_ERSTATUS_GP_CLEARED = 0x8
	// General purpose registers have not been asynchronous cleared.
	RTC_ERSTATUS_GP_CLEARED_NOGPCLR = 0x0
	// General purpose registers have been asynchronous cleared.
	RTC_ERSTATUS_GP_CLEARED_GPCLR = 0x1
	// Position of RESERVED field.
	RTC_ERSTATUS_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	RTC_ERSTATUS_RESERVED_Msk = 0x7ffffff0
	// Position of WAKEUP field.
	RTC_ERSTATUS_WAKEUP_Pos = 0x1f
	// Bit mask of WAKEUP field.
	RTC_ERSTATUS_WAKEUP_Msk = 0x80000000
	// Bit WAKEUP.
	RTC_ERSTATUS_WAKEUP = 0x80000000
	// No interrupt/wakeup request is pending
	RTC_ERSTATUS_WAKEUP_NO_INTERRUPTWAKEUP_ = 0x0
	// An interrupt/wakeup request is pending.
	RTC_ERSTATUS_WAKEUP_INTWAKEUP_PEND = 0x1

	// ERCONTROL: Event Monitor/Recorder Control register. Contains bits that control actions for the event channels as well as for Event Monitor/Recorder setup.
	// Position of INTWAKE_EN0 field.
	RTC_ERCONTROL_INTWAKE_EN0_Pos = 0x0
	// Bit mask of INTWAKE_EN0 field.
	RTC_ERCONTROL_INTWAKE_EN0_Msk = 0x1
	// Bit INTWAKE_EN0.
	RTC_ERCONTROL_INTWAKE_EN0 = 0x1
	// No interrupt or wakeup will be generated by event channel 0.
	RTC_ERCONTROL_INTWAKE_EN0_NO_INTERRUPT_OR_WAKE = 0x0
	// An event in channel 0 will trigger an (RTC) interrupt and a wake-up request.
	RTC_ERCONTROL_INTWAKE_EN0_AN_EVENT_IN_CHANNEL_ = 0x1
	// Position of GPCLEAR_EN0 field.
	RTC_ERCONTROL_GPCLEAR_EN0_Pos = 0x1
	// Bit mask of GPCLEAR_EN0 field.
	RTC_ERCONTROL_GPCLEAR_EN0_Msk = 0x2
	// Bit GPCLEAR_EN0.
	RTC_ERCONTROL_GPCLEAR_EN0 = 0x2
	// Channel 0 has no influence on the general purpose registers.
	RTC_ERCONTROL_GPCLEAR_EN0_NOGPREG = 0x0
	// An event in channel 0 will clear the general purpose registers asynchronously.
	RTC_ERCONTROL_GPCLEAR_EN0_CLRGPREG = 0x1
	// Position of POL0 field.
	RTC_ERCONTROL_POL0_Pos = 0x2
	// Bit mask of POL0 field.
	RTC_ERCONTROL_POL0_Msk = 0x4
	// Bit POL0.
	RTC_ERCONTROL_POL0 = 0x4
	// A channel 0 event is defined as a negative edge on RTC_EV0.
	RTC_ERCONTROL_POL0_NEG = 0x0
	// A channel 0 event is defined as a positive edge on RTC_EV0.
	RTC_ERCONTROL_POL0_POS = 0x1
	// Position of EV0_INPUT_EN field.
	RTC_ERCONTROL_EV0_INPUT_EN_Pos = 0x3
	// Bit mask of EV0_INPUT_EN field.
	RTC_ERCONTROL_EV0_INPUT_EN_Msk = 0x8
	// Bit EV0_INPUT_EN.
	RTC_ERCONTROL_EV0_INPUT_EN = 0x8
	// Event 0 input is disabled and forced high internally.
	RTC_ERCONTROL_EV0_INPUT_EN_DISABLED = 0x0
	// Event 0 input is enabled.
	RTC_ERCONTROL_EV0_INPUT_EN_ENABLED = 0x1
	// Position of RESERVED field.
	RTC_ERCONTROL_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	RTC_ERCONTROL_RESERVED_Msk = 0x3f0
	// Position of INTWAKE_EN1 field.
	RTC_ERCONTROL_INTWAKE_EN1_Pos = 0xa
	// Bit mask of INTWAKE_EN1 field.
	RTC_ERCONTROL_INTWAKE_EN1_Msk = 0x400
	// Bit INTWAKE_EN1.
	RTC_ERCONTROL_INTWAKE_EN1 = 0x400
	// No interrupt or wakeup will be generated by event channel 1.
	RTC_ERCONTROL_INTWAKE_EN1_NO_INTERRUPT_OR_WAKE = 0x0
	// An event in channel 1 will trigger an (RTC) interrupt and a wake-up request.
	RTC_ERCONTROL_INTWAKE_EN1_WAKEUP = 0x1
	// Position of GPCLEAR_EN1 field.
	RTC_ERCONTROL_GPCLEAR_EN1_Pos = 0xb
	// Bit mask of GPCLEAR_EN1 field.
	RTC_ERCONTROL_GPCLEAR_EN1_Msk = 0x800
	// Bit GPCLEAR_EN1.
	RTC_ERCONTROL_GPCLEAR_EN1 = 0x800
	// Channel 1 has no influence on the general purpose registers.
	RTC_ERCONTROL_GPCLEAR_EN1_NOGPREG = 0x0
	// A n event in channel 1 will clear the general purpose registers asynchronously.
	RTC_ERCONTROL_GPCLEAR_EN1_CLRGPREG = 0x1
	// Position of POL1 field.
	RTC_ERCONTROL_POL1_Pos = 0xc
	// Bit mask of POL1 field.
	RTC_ERCONTROL_POL1_Msk = 0x1000
	// Bit POL1.
	RTC_ERCONTROL_POL1 = 0x1000
	// A channel 1 event is defined as a negative edge on RTC_EV1.
	RTC_ERCONTROL_POL1_NEG = 0x0
	// A channel 1 event is defined as a positive edge on RTC_EV1.
	RTC_ERCONTROL_POL1_POS = 0x1
	// Position of EV1_INPUT_EN field.
	RTC_ERCONTROL_EV1_INPUT_EN_Pos = 0xd
	// Bit mask of EV1_INPUT_EN field.
	RTC_ERCONTROL_EV1_INPUT_EN_Msk = 0x2000
	// Bit EV1_INPUT_EN.
	RTC_ERCONTROL_EV1_INPUT_EN = 0x2000
	// Event 1 input is disabled and forced high internally.
	RTC_ERCONTROL_EV1_INPUT_EN_DISABLED = 0x0
	// Event 1 input is enabled.
	RTC_ERCONTROL_EV1_INPUT_EN_ENABLED = 0x1
	// Position of RESERVED field.
	RTC_ERCONTROL_RESERVED_Pos = 0xe
	// Bit mask of RESERVED field.
	RTC_ERCONTROL_RESERVED_Msk = 0xfc000
	// Position of INTWAKE_EN2 field.
	RTC_ERCONTROL_INTWAKE_EN2_Pos = 0x14
	// Bit mask of INTWAKE_EN2 field.
	RTC_ERCONTROL_INTWAKE_EN2_Msk = 0x100000
	// Bit INTWAKE_EN2.
	RTC_ERCONTROL_INTWAKE_EN2 = 0x100000
	// No interrupt or wakeup will be generated by event channel 2.
	RTC_ERCONTROL_INTWAKE_EN2_NO_INTERRUPT_OR_WAKE = 0x0
	// An event in channel 2 will trigger an (RTC) interrupt and a wake-up request.
	RTC_ERCONTROL_INTWAKE_EN2_WAKEUP = 0x1
	// Position of GPCLEAR_EN2 field.
	RTC_ERCONTROL_GPCLEAR_EN2_Pos = 0x15
	// Bit mask of GPCLEAR_EN2 field.
	RTC_ERCONTROL_GPCLEAR_EN2_Msk = 0x200000
	// Bit GPCLEAR_EN2.
	RTC_ERCONTROL_GPCLEAR_EN2 = 0x200000
	// Channel 2 has no influence on the general purpose registers.
	RTC_ERCONTROL_GPCLEAR_EN2_NOGPREG = 0x0
	// An event in channel 2 will clear the general purpose registers asynchronously.
	RTC_ERCONTROL_GPCLEAR_EN2_CLRGPREG = 0x1
	// Position of POL2 field.
	RTC_ERCONTROL_POL2_Pos = 0x16
	// Bit mask of POL2 field.
	RTC_ERCONTROL_POL2_Msk = 0x400000
	// Bit POL2.
	RTC_ERCONTROL_POL2 = 0x400000
	// A channel 2 event is defined as a negative edge on RTC_EV2.
	RTC_ERCONTROL_POL2_NEG = 0x0
	// A channel 2 event is defined as a positive edge on RTC_EV2.
	RTC_ERCONTROL_POL2_POS = 0x1
	// Position of EV2_INPUT_EN field.
	RTC_ERCONTROL_EV2_INPUT_EN_Pos = 0x17
	// Bit mask of EV2_INPUT_EN field.
	RTC_ERCONTROL_EV2_INPUT_EN_Msk = 0x800000
	// Bit EV2_INPUT_EN.
	RTC_ERCONTROL_EV2_INPUT_EN = 0x800000
	// Event 2 input is disabled and forced high internally.
	RTC_ERCONTROL_EV2_INPUT_EN_DISABLED = 0x0
	// Event 2 input is enabled.
	RTC_ERCONTROL_EV2_INPUT_EN_ENABLED = 0x1
	// Position of RESERVED field.
	RTC_ERCONTROL_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	RTC_ERCONTROL_RESERVED_Msk = 0x3f000000
	// Position of ERMODE field.
	RTC_ERCONTROL_ERMODE_Pos = 0x1e
	// Bit mask of ERMODE field.
	RTC_ERCONTROL_ERMODE_Msk = 0xc0000000
	// Event Monitor/Recorder clocks are disabled. Operation of the Event Monitor/Recorder is disabled except for asynchronous clearing of GP registers if selected.
	RTC_ERCONTROL_ERMODE_DISABLED = 0x0
	// Enable Event Monitor/Recorder and select a 16 Hz sample clock for event input edge detection and glitch suppression. Pulses (in either direction) shorter than 62.5 ms to 125 ms will be filtered out.
	RTC_ERCONTROL_ERMODE_ENABLE_EVENT_MONITOR16HZ = 0x1
	// Enable Event Monitor/Recorder and select a 64 Hz sample clock for event input edge detection and glitch suppression. Pulses (in either direction) shorter than 15.6 ms to 31.2 ms will be filtered out.
	RTC_ERCONTROL_ERMODE_ENABLE_EVENT_MONITOR64HZ = 0x2
	// Enable Event Monitor/Recorder and select a 1 kHz sample clock for event input edge detection and glitch suppression. Pulses (in either direction) shorter than 1 ms to 2 ms will be filtered out.
	RTC_ERCONTROL_ERMODE_ENABLE_EVENT_MONITOR1KHZ = 0x3

	// ERCOUNTERS: Event Monitor/Recorder Counters register. Allows reading the counters associated with the event channels.
	// Position of COUNTER0 field.
	RTC_ERCOUNTERS_COUNTER0_Pos = 0x0
	// Bit mask of COUNTER0 field.
	RTC_ERCOUNTERS_COUNTER0_Msk = 0x7
	// Position of RESERVED field.
	RTC_ERCOUNTERS_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	RTC_ERCOUNTERS_RESERVED_Msk = 0xf8
	// Position of COUNTER1 field.
	RTC_ERCOUNTERS_COUNTER1_Pos = 0x8
	// Bit mask of COUNTER1 field.
	RTC_ERCOUNTERS_COUNTER1_Msk = 0x700
	// Position of RESERVED field.
	RTC_ERCOUNTERS_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	RTC_ERCOUNTERS_RESERVED_Msk = 0xf800
	// Position of COUNTER2 field.
	RTC_ERCOUNTERS_COUNTER2_Pos = 0x10
	// Bit mask of COUNTER2 field.
	RTC_ERCOUNTERS_COUNTER2_Msk = 0x70000
	// Position of RESERVED field.
	RTC_ERCOUNTERS_RESERVED_Pos = 0x13
	// Bit mask of RESERVED field.
	RTC_ERCOUNTERS_RESERVED_Msk = 0xfff80000

	// ERFIRSTSTAMP0: Event Monitor/Recorder First Stamp register for channel 0. Retains the time stamp for the first event on channel 0.
	// Position of SEC field.
	RTC_ERFIRSTSTAMP_SEC_Pos = 0x0
	// Bit mask of SEC field.
	RTC_ERFIRSTSTAMP_SEC_Msk = 0x3f
	// Position of MIN field.
	RTC_ERFIRSTSTAMP_MIN_Pos = 0x6
	// Bit mask of MIN field.
	RTC_ERFIRSTSTAMP_MIN_Msk = 0xfc0
	// Position of HOUR field.
	RTC_ERFIRSTSTAMP_HOUR_Pos = 0xc
	// Bit mask of HOUR field.
	RTC_ERFIRSTSTAMP_HOUR_Msk = 0x1f000
	// Position of DOY field.
	RTC_ERFIRSTSTAMP_DOY_Pos = 0x11
	// Bit mask of DOY field.
	RTC_ERFIRSTSTAMP_DOY_Msk = 0x3fe0000
	// Position of RESERVED field.
	RTC_ERFIRSTSTAMP_RESERVED_Pos = 0x1a
	// Bit mask of RESERVED field.
	RTC_ERFIRSTSTAMP_RESERVED_Msk = 0xfc000000

	// ERLASTSTAMP0: Event Monitor/Recorder Last Stamp register for channel 0. Retains the time stamp for the last (i.e. most recent) event on channel 0.
	// Position of SEC field.
	RTC_ERLASTSTAMP_SEC_Pos = 0x0
	// Bit mask of SEC field.
	RTC_ERLASTSTAMP_SEC_Msk = 0x3f
	// Position of MIN field.
	RTC_ERLASTSTAMP_MIN_Pos = 0x6
	// Bit mask of MIN field.
	RTC_ERLASTSTAMP_MIN_Msk = 0xfc0
	// Position of HOUR field.
	RTC_ERLASTSTAMP_HOUR_Pos = 0xc
	// Bit mask of HOUR field.
	RTC_ERLASTSTAMP_HOUR_Msk = 0x1f000
	// Position of DOY field.
	RTC_ERLASTSTAMP_DOY_Pos = 0x11
	// Bit mask of DOY field.
	RTC_ERLASTSTAMP_DOY_Msk = 0x3fe0000
	// Position of RESERVED field.
	RTC_ERLASTSTAMP_RESERVED_Pos = 0x1a
	// Bit mask of RESERVED field.
	RTC_ERLASTSTAMP_RESERVED_Msk = 0xfc000000
)

// Constants for GPIOINT: GPIO
const (
	// STATUS: GPIO overall Interrupt Status.
	// Position of P0Int field.
	GPIOINT_STATUS_P0Int_Pos = 0x0
	// Bit mask of P0Int field.
	GPIOINT_STATUS_P0Int_Msk = 0x1
	// Bit P0Int.
	GPIOINT_STATUS_P0Int = 0x1
	// No pending interrupts on Port 0.
	GPIOINT_STATUS_P0Int_NO_PENDING_INTERRUPT = 0x0
	// At least one pending interrupt on Port 0.
	GPIOINT_STATUS_P0Int_AT_LEAST_ONE_PENDING = 0x1
	// Position of RESERVED field.
	GPIOINT_STATUS_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	GPIOINT_STATUS_RESERVED_Msk = 0x2
	// Bit RESERVED.
	GPIOINT_STATUS_RESERVED = 0x2
	// Position of P2Int field.
	GPIOINT_STATUS_P2Int_Pos = 0x2
	// Bit mask of P2Int field.
	GPIOINT_STATUS_P2Int_Msk = 0x4
	// Bit P2Int.
	GPIOINT_STATUS_P2Int = 0x4
	// No pending interrupts on Port 2.
	GPIOINT_STATUS_P2Int_NO_PENDING_INTERRUPT = 0x0
	// At least one pending interrupt on Port 2.
	GPIOINT_STATUS_P2Int_AT_LEAST_ONE_PENDING = 0x1
	// Position of RESERVED field.
	GPIOINT_STATUS_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	GPIOINT_STATUS_RESERVED_Msk = 0xfffffffc

	// STATR0: GPIO Interrupt Status for Rising edge for Port 0.
	// Position of P0_0REI field.
	GPIOINT_STATR0_P0_0REI_Pos = 0x0
	// Bit mask of P0_0REI field.
	GPIOINT_STATR0_P0_0REI_Msk = 0x1
	// Bit P0_0REI.
	GPIOINT_STATR0_P0_0REI = 0x1
	// Position of P0_1REI field.
	GPIOINT_STATR0_P0_1REI_Pos = 0x1
	// Bit mask of P0_1REI field.
	GPIOINT_STATR0_P0_1REI_Msk = 0x2
	// Bit P0_1REI.
	GPIOINT_STATR0_P0_1REI = 0x2
	// Position of P0_2REI field.
	GPIOINT_STATR0_P0_2REI_Pos = 0x2
	// Bit mask of P0_2REI field.
	GPIOINT_STATR0_P0_2REI_Msk = 0x4
	// Bit P0_2REI.
	GPIOINT_STATR0_P0_2REI = 0x4
	// Position of P0_3REI field.
	GPIOINT_STATR0_P0_3REI_Pos = 0x3
	// Bit mask of P0_3REI field.
	GPIOINT_STATR0_P0_3REI_Msk = 0x8
	// Bit P0_3REI.
	GPIOINT_STATR0_P0_3REI = 0x8
	// Position of P0_4REI field.
	GPIOINT_STATR0_P0_4REI_Pos = 0x4
	// Bit mask of P0_4REI field.
	GPIOINT_STATR0_P0_4REI_Msk = 0x10
	// Bit P0_4REI.
	GPIOINT_STATR0_P0_4REI = 0x10
	// Position of P0_5REI field.
	GPIOINT_STATR0_P0_5REI_Pos = 0x5
	// Bit mask of P0_5REI field.
	GPIOINT_STATR0_P0_5REI_Msk = 0x20
	// Bit P0_5REI.
	GPIOINT_STATR0_P0_5REI = 0x20
	// Position of P0_6REI field.
	GPIOINT_STATR0_P0_6REI_Pos = 0x6
	// Bit mask of P0_6REI field.
	GPIOINT_STATR0_P0_6REI_Msk = 0x40
	// Bit P0_6REI.
	GPIOINT_STATR0_P0_6REI = 0x40
	// Position of P0_7REI field.
	GPIOINT_STATR0_P0_7REI_Pos = 0x7
	// Bit mask of P0_7REI field.
	GPIOINT_STATR0_P0_7REI_Msk = 0x80
	// Bit P0_7REI.
	GPIOINT_STATR0_P0_7REI = 0x80
	// Position of P0_8REI field.
	GPIOINT_STATR0_P0_8REI_Pos = 0x8
	// Bit mask of P0_8REI field.
	GPIOINT_STATR0_P0_8REI_Msk = 0x100
	// Bit P0_8REI.
	GPIOINT_STATR0_P0_8REI = 0x100
	// Position of P0_9REI field.
	GPIOINT_STATR0_P0_9REI_Pos = 0x9
	// Bit mask of P0_9REI field.
	GPIOINT_STATR0_P0_9REI_Msk = 0x200
	// Bit P0_9REI.
	GPIOINT_STATR0_P0_9REI = 0x200
	// Position of P0_10REI field.
	GPIOINT_STATR0_P0_10REI_Pos = 0xa
	// Bit mask of P0_10REI field.
	GPIOINT_STATR0_P0_10REI_Msk = 0x400
	// Bit P0_10REI.
	GPIOINT_STATR0_P0_10REI = 0x400
	// Position of P0_11REI field.
	GPIOINT_STATR0_P0_11REI_Pos = 0xb
	// Bit mask of P0_11REI field.
	GPIOINT_STATR0_P0_11REI_Msk = 0x800
	// Bit P0_11REI.
	GPIOINT_STATR0_P0_11REI = 0x800
	// Position of P0_12REI field.
	GPIOINT_STATR0_P0_12REI_Pos = 0xc
	// Bit mask of P0_12REI field.
	GPIOINT_STATR0_P0_12REI_Msk = 0x1000
	// Bit P0_12REI.
	GPIOINT_STATR0_P0_12REI = 0x1000
	// Position of P0_13REI field.
	GPIOINT_STATR0_P0_13REI_Pos = 0xd
	// Bit mask of P0_13REI field.
	GPIOINT_STATR0_P0_13REI_Msk = 0x2000
	// Bit P0_13REI.
	GPIOINT_STATR0_P0_13REI = 0x2000
	// Position of P0_14REI field.
	GPIOINT_STATR0_P0_14REI_Pos = 0xe
	// Bit mask of P0_14REI field.
	GPIOINT_STATR0_P0_14REI_Msk = 0x4000
	// Bit P0_14REI.
	GPIOINT_STATR0_P0_14REI = 0x4000
	// Position of P0_15REI field.
	GPIOINT_STATR0_P0_15REI_Pos = 0xf
	// Bit mask of P0_15REI field.
	GPIOINT_STATR0_P0_15REI_Msk = 0x8000
	// Bit P0_15REI.
	GPIOINT_STATR0_P0_15REI = 0x8000
	// Position of P0_16REI field.
	GPIOINT_STATR0_P0_16REI_Pos = 0x10
	// Bit mask of P0_16REI field.
	GPIOINT_STATR0_P0_16REI_Msk = 0x10000
	// Bit P0_16REI.
	GPIOINT_STATR0_P0_16REI = 0x10000
	// Position of P0_17REI field.
	GPIOINT_STATR0_P0_17REI_Pos = 0x11
	// Bit mask of P0_17REI field.
	GPIOINT_STATR0_P0_17REI_Msk = 0x20000
	// Bit P0_17REI.
	GPIOINT_STATR0_P0_17REI = 0x20000
	// Position of P0_18REI field.
	GPIOINT_STATR0_P0_18REI_Pos = 0x12
	// Bit mask of P0_18REI field.
	GPIOINT_STATR0_P0_18REI_Msk = 0x40000
	// Bit P0_18REI.
	GPIOINT_STATR0_P0_18REI = 0x40000
	// Position of P0_19REI field.
	GPIOINT_STATR0_P0_19REI_Pos = 0x13
	// Bit mask of P0_19REI field.
	GPIOINT_STATR0_P0_19REI_Msk = 0x80000
	// Bit P0_19REI.
	GPIOINT_STATR0_P0_19REI = 0x80000
	// Position of P0_20REI field.
	GPIOINT_STATR0_P0_20REI_Pos = 0x14
	// Bit mask of P0_20REI field.
	GPIOINT_STATR0_P0_20REI_Msk = 0x100000
	// Bit P0_20REI.
	GPIOINT_STATR0_P0_20REI = 0x100000
	// Position of P0_21REI field.
	GPIOINT_STATR0_P0_21REI_Pos = 0x15
	// Bit mask of P0_21REI field.
	GPIOINT_STATR0_P0_21REI_Msk = 0x200000
	// Bit P0_21REI.
	GPIOINT_STATR0_P0_21REI = 0x200000
	// Position of P0_22REI field.
	GPIOINT_STATR0_P0_22REI_Pos = 0x16
	// Bit mask of P0_22REI field.
	GPIOINT_STATR0_P0_22REI_Msk = 0x400000
	// Bit P0_22REI.
	GPIOINT_STATR0_P0_22REI = 0x400000
	// Position of P0_23REI field.
	GPIOINT_STATR0_P0_23REI_Pos = 0x17
	// Bit mask of P0_23REI field.
	GPIOINT_STATR0_P0_23REI_Msk = 0x800000
	// Bit P0_23REI.
	GPIOINT_STATR0_P0_23REI = 0x800000
	// Position of P0_24REI field.
	GPIOINT_STATR0_P0_24REI_Pos = 0x18
	// Bit mask of P0_24REI field.
	GPIOINT_STATR0_P0_24REI_Msk = 0x1000000
	// Bit P0_24REI.
	GPIOINT_STATR0_P0_24REI = 0x1000000
	// Position of P0_25REI field.
	GPIOINT_STATR0_P0_25REI_Pos = 0x19
	// Bit mask of P0_25REI field.
	GPIOINT_STATR0_P0_25REI_Msk = 0x2000000
	// Bit P0_25REI.
	GPIOINT_STATR0_P0_25REI = 0x2000000
	// Position of P0_26REI field.
	GPIOINT_STATR0_P0_26REI_Pos = 0x1a
	// Bit mask of P0_26REI field.
	GPIOINT_STATR0_P0_26REI_Msk = 0x4000000
	// Bit P0_26REI.
	GPIOINT_STATR0_P0_26REI = 0x4000000
	// Position of P0_27REI field.
	GPIOINT_STATR0_P0_27REI_Pos = 0x1b
	// Bit mask of P0_27REI field.
	GPIOINT_STATR0_P0_27REI_Msk = 0x8000000
	// Bit P0_27REI.
	GPIOINT_STATR0_P0_27REI = 0x8000000
	// Position of P0_28REI field.
	GPIOINT_STATR0_P0_28REI_Pos = 0x1c
	// Bit mask of P0_28REI field.
	GPIOINT_STATR0_P0_28REI_Msk = 0x10000000
	// Bit P0_28REI.
	GPIOINT_STATR0_P0_28REI = 0x10000000
	// Position of P0_29REI field.
	GPIOINT_STATR0_P0_29REI_Pos = 0x1d
	// Bit mask of P0_29REI field.
	GPIOINT_STATR0_P0_29REI_Msk = 0x20000000
	// Bit P0_29REI.
	GPIOINT_STATR0_P0_29REI = 0x20000000
	// Position of P0_30REI field.
	GPIOINT_STATR0_P0_30REI_Pos = 0x1e
	// Bit mask of P0_30REI field.
	GPIOINT_STATR0_P0_30REI_Msk = 0x40000000
	// Bit P0_30REI.
	GPIOINT_STATR0_P0_30REI = 0x40000000
	// Position of P0_31REI field.
	GPIOINT_STATR0_P0_31REI_Pos = 0x1f
	// Bit mask of P0_31REI field.
	GPIOINT_STATR0_P0_31REI_Msk = 0x80000000
	// Bit P0_31REI.
	GPIOINT_STATR0_P0_31REI = 0x80000000

	// STATF0: GPIO Interrupt Status for Falling edge for Port 0.
	// Position of P0_0FEI field.
	GPIOINT_STATF0_P0_0FEI_Pos = 0x0
	// Bit mask of P0_0FEI field.
	GPIOINT_STATF0_P0_0FEI_Msk = 0x1
	// Bit P0_0FEI.
	GPIOINT_STATF0_P0_0FEI = 0x1
	// Position of P0_1FEI field.
	GPIOINT_STATF0_P0_1FEI_Pos = 0x1
	// Bit mask of P0_1FEI field.
	GPIOINT_STATF0_P0_1FEI_Msk = 0x2
	// Bit P0_1FEI.
	GPIOINT_STATF0_P0_1FEI = 0x2
	// Position of P0_2FEI field.
	GPIOINT_STATF0_P0_2FEI_Pos = 0x2
	// Bit mask of P0_2FEI field.
	GPIOINT_STATF0_P0_2FEI_Msk = 0x4
	// Bit P0_2FEI.
	GPIOINT_STATF0_P0_2FEI = 0x4
	// Position of P0_3FEI field.
	GPIOINT_STATF0_P0_3FEI_Pos = 0x3
	// Bit mask of P0_3FEI field.
	GPIOINT_STATF0_P0_3FEI_Msk = 0x8
	// Bit P0_3FEI.
	GPIOINT_STATF0_P0_3FEI = 0x8
	// Position of P0_4FEI field.
	GPIOINT_STATF0_P0_4FEI_Pos = 0x4
	// Bit mask of P0_4FEI field.
	GPIOINT_STATF0_P0_4FEI_Msk = 0x10
	// Bit P0_4FEI.
	GPIOINT_STATF0_P0_4FEI = 0x10
	// Position of P0_5FEI field.
	GPIOINT_STATF0_P0_5FEI_Pos = 0x5
	// Bit mask of P0_5FEI field.
	GPIOINT_STATF0_P0_5FEI_Msk = 0x20
	// Bit P0_5FEI.
	GPIOINT_STATF0_P0_5FEI = 0x20
	// Position of P0_6FEI field.
	GPIOINT_STATF0_P0_6FEI_Pos = 0x6
	// Bit mask of P0_6FEI field.
	GPIOINT_STATF0_P0_6FEI_Msk = 0x40
	// Bit P0_6FEI.
	GPIOINT_STATF0_P0_6FEI = 0x40
	// Position of P0_7FEI field.
	GPIOINT_STATF0_P0_7FEI_Pos = 0x7
	// Bit mask of P0_7FEI field.
	GPIOINT_STATF0_P0_7FEI_Msk = 0x80
	// Bit P0_7FEI.
	GPIOINT_STATF0_P0_7FEI = 0x80
	// Position of P0_8FEI field.
	GPIOINT_STATF0_P0_8FEI_Pos = 0x8
	// Bit mask of P0_8FEI field.
	GPIOINT_STATF0_P0_8FEI_Msk = 0x100
	// Bit P0_8FEI.
	GPIOINT_STATF0_P0_8FEI = 0x100
	// Position of P0_9FEI field.
	GPIOINT_STATF0_P0_9FEI_Pos = 0x9
	// Bit mask of P0_9FEI field.
	GPIOINT_STATF0_P0_9FEI_Msk = 0x200
	// Bit P0_9FEI.
	GPIOINT_STATF0_P0_9FEI = 0x200
	// Position of P0_10FEI field.
	GPIOINT_STATF0_P0_10FEI_Pos = 0xa
	// Bit mask of P0_10FEI field.
	GPIOINT_STATF0_P0_10FEI_Msk = 0x400
	// Bit P0_10FEI.
	GPIOINT_STATF0_P0_10FEI = 0x400
	// Position of P0_11FEI field.
	GPIOINT_STATF0_P0_11FEI_Pos = 0xb
	// Bit mask of P0_11FEI field.
	GPIOINT_STATF0_P0_11FEI_Msk = 0x800
	// Bit P0_11FEI.
	GPIOINT_STATF0_P0_11FEI = 0x800
	// Position of P0_12FEI field.
	GPIOINT_STATF0_P0_12FEI_Pos = 0xc
	// Bit mask of P0_12FEI field.
	GPIOINT_STATF0_P0_12FEI_Msk = 0x1000
	// Bit P0_12FEI.
	GPIOINT_STATF0_P0_12FEI = 0x1000
	// Position of P0_13FEI field.
	GPIOINT_STATF0_P0_13FEI_Pos = 0xd
	// Bit mask of P0_13FEI field.
	GPIOINT_STATF0_P0_13FEI_Msk = 0x2000
	// Bit P0_13FEI.
	GPIOINT_STATF0_P0_13FEI = 0x2000
	// Position of P0_14FEI field.
	GPIOINT_STATF0_P0_14FEI_Pos = 0xe
	// Bit mask of P0_14FEI field.
	GPIOINT_STATF0_P0_14FEI_Msk = 0x4000
	// Bit P0_14FEI.
	GPIOINT_STATF0_P0_14FEI = 0x4000
	// Position of P0_15FEI field.
	GPIOINT_STATF0_P0_15FEI_Pos = 0xf
	// Bit mask of P0_15FEI field.
	GPIOINT_STATF0_P0_15FEI_Msk = 0x8000
	// Bit P0_15FEI.
	GPIOINT_STATF0_P0_15FEI = 0x8000
	// Position of P0_16FEI field.
	GPIOINT_STATF0_P0_16FEI_Pos = 0x10
	// Bit mask of P0_16FEI field.
	GPIOINT_STATF0_P0_16FEI_Msk = 0x10000
	// Bit P0_16FEI.
	GPIOINT_STATF0_P0_16FEI = 0x10000
	// Position of P0_17FEI field.
	GPIOINT_STATF0_P0_17FEI_Pos = 0x11
	// Bit mask of P0_17FEI field.
	GPIOINT_STATF0_P0_17FEI_Msk = 0x20000
	// Bit P0_17FEI.
	GPIOINT_STATF0_P0_17FEI = 0x20000
	// Position of P0_18FEI field.
	GPIOINT_STATF0_P0_18FEI_Pos = 0x12
	// Bit mask of P0_18FEI field.
	GPIOINT_STATF0_P0_18FEI_Msk = 0x40000
	// Bit P0_18FEI.
	GPIOINT_STATF0_P0_18FEI = 0x40000
	// Position of P0_19FEI field.
	GPIOINT_STATF0_P0_19FEI_Pos = 0x13
	// Bit mask of P0_19FEI field.
	GPIOINT_STATF0_P0_19FEI_Msk = 0x80000
	// Bit P0_19FEI.
	GPIOINT_STATF0_P0_19FEI = 0x80000
	// Position of P0_20FEI field.
	GPIOINT_STATF0_P0_20FEI_Pos = 0x14
	// Bit mask of P0_20FEI field.
	GPIOINT_STATF0_P0_20FEI_Msk = 0x100000
	// Bit P0_20FEI.
	GPIOINT_STATF0_P0_20FEI = 0x100000
	// Position of P0_21FEI field.
	GPIOINT_STATF0_P0_21FEI_Pos = 0x15
	// Bit mask of P0_21FEI field.
	GPIOINT_STATF0_P0_21FEI_Msk = 0x200000
	// Bit P0_21FEI.
	GPIOINT_STATF0_P0_21FEI = 0x200000
	// Position of P0_22FEI field.
	GPIOINT_STATF0_P0_22FEI_Pos = 0x16
	// Bit mask of P0_22FEI field.
	GPIOINT_STATF0_P0_22FEI_Msk = 0x400000
	// Bit P0_22FEI.
	GPIOINT_STATF0_P0_22FEI = 0x400000
	// Position of P0_23FEI field.
	GPIOINT_STATF0_P0_23FEI_Pos = 0x17
	// Bit mask of P0_23FEI field.
	GPIOINT_STATF0_P0_23FEI_Msk = 0x800000
	// Bit P0_23FEI.
	GPIOINT_STATF0_P0_23FEI = 0x800000
	// Position of P0_24FEI field.
	GPIOINT_STATF0_P0_24FEI_Pos = 0x18
	// Bit mask of P0_24FEI field.
	GPIOINT_STATF0_P0_24FEI_Msk = 0x1000000
	// Bit P0_24FEI.
	GPIOINT_STATF0_P0_24FEI = 0x1000000
	// Position of P0_25FEI field.
	GPIOINT_STATF0_P0_25FEI_Pos = 0x19
	// Bit mask of P0_25FEI field.
	GPIOINT_STATF0_P0_25FEI_Msk = 0x2000000
	// Bit P0_25FEI.
	GPIOINT_STATF0_P0_25FEI = 0x2000000
	// Position of P0_26FEI field.
	GPIOINT_STATF0_P0_26FEI_Pos = 0x1a
	// Bit mask of P0_26FEI field.
	GPIOINT_STATF0_P0_26FEI_Msk = 0x4000000
	// Bit P0_26FEI.
	GPIOINT_STATF0_P0_26FEI = 0x4000000
	// Position of P0_27FEI field.
	GPIOINT_STATF0_P0_27FEI_Pos = 0x1b
	// Bit mask of P0_27FEI field.
	GPIOINT_STATF0_P0_27FEI_Msk = 0x8000000
	// Bit P0_27FEI.
	GPIOINT_STATF0_P0_27FEI = 0x8000000
	// Position of P0_28FEI field.
	GPIOINT_STATF0_P0_28FEI_Pos = 0x1c
	// Bit mask of P0_28FEI field.
	GPIOINT_STATF0_P0_28FEI_Msk = 0x10000000
	// Bit P0_28FEI.
	GPIOINT_STATF0_P0_28FEI = 0x10000000
	// Position of P0_29FEI field.
	GPIOINT_STATF0_P0_29FEI_Pos = 0x1d
	// Bit mask of P0_29FEI field.
	GPIOINT_STATF0_P0_29FEI_Msk = 0x20000000
	// Bit P0_29FEI.
	GPIOINT_STATF0_P0_29FEI = 0x20000000
	// Position of P0_30FEI field.
	GPIOINT_STATF0_P0_30FEI_Pos = 0x1e
	// Bit mask of P0_30FEI field.
	GPIOINT_STATF0_P0_30FEI_Msk = 0x40000000
	// Bit P0_30FEI.
	GPIOINT_STATF0_P0_30FEI = 0x40000000
	// Position of P0_31FEI field.
	GPIOINT_STATF0_P0_31FEI_Pos = 0x1f
	// Bit mask of P0_31FEI field.
	GPIOINT_STATF0_P0_31FEI_Msk = 0x80000000
	// Bit P0_31FEI.
	GPIOINT_STATF0_P0_31FEI = 0x80000000

	// CLR0: GPIO Interrupt Clear.
	// Position of P0_0CI field.
	GPIOINT_CLR0_P0_0CI_Pos = 0x0
	// Bit mask of P0_0CI field.
	GPIOINT_CLR0_P0_0CI_Msk = 0x1
	// Bit P0_0CI.
	GPIOINT_CLR0_P0_0CI = 0x1
	// Position of P0_1CI field.
	GPIOINT_CLR0_P0_1CI_Pos = 0x1
	// Bit mask of P0_1CI field.
	GPIOINT_CLR0_P0_1CI_Msk = 0x2
	// Bit P0_1CI.
	GPIOINT_CLR0_P0_1CI = 0x2
	// Position of P0_2CI field.
	GPIOINT_CLR0_P0_2CI_Pos = 0x2
	// Bit mask of P0_2CI field.
	GPIOINT_CLR0_P0_2CI_Msk = 0x4
	// Bit P0_2CI.
	GPIOINT_CLR0_P0_2CI = 0x4
	// Position of P0_3CI field.
	GPIOINT_CLR0_P0_3CI_Pos = 0x3
	// Bit mask of P0_3CI field.
	GPIOINT_CLR0_P0_3CI_Msk = 0x8
	// Bit P0_3CI.
	GPIOINT_CLR0_P0_3CI = 0x8
	// Position of P0_4CI field.
	GPIOINT_CLR0_P0_4CI_Pos = 0x4
	// Bit mask of P0_4CI field.
	GPIOINT_CLR0_P0_4CI_Msk = 0x10
	// Bit P0_4CI.
	GPIOINT_CLR0_P0_4CI = 0x10
	// Position of P0_5CI field.
	GPIOINT_CLR0_P0_5CI_Pos = 0x5
	// Bit mask of P0_5CI field.
	GPIOINT_CLR0_P0_5CI_Msk = 0x20
	// Bit P0_5CI.
	GPIOINT_CLR0_P0_5CI = 0x20
	// Position of P0_6CI field.
	GPIOINT_CLR0_P0_6CI_Pos = 0x6
	// Bit mask of P0_6CI field.
	GPIOINT_CLR0_P0_6CI_Msk = 0x40
	// Bit P0_6CI.
	GPIOINT_CLR0_P0_6CI = 0x40
	// Position of P0_7CI field.
	GPIOINT_CLR0_P0_7CI_Pos = 0x7
	// Bit mask of P0_7CI field.
	GPIOINT_CLR0_P0_7CI_Msk = 0x80
	// Bit P0_7CI.
	GPIOINT_CLR0_P0_7CI = 0x80
	// Position of P0_8CI field.
	GPIOINT_CLR0_P0_8CI_Pos = 0x8
	// Bit mask of P0_8CI field.
	GPIOINT_CLR0_P0_8CI_Msk = 0x100
	// Bit P0_8CI.
	GPIOINT_CLR0_P0_8CI = 0x100
	// Position of P0_9CI field.
	GPIOINT_CLR0_P0_9CI_Pos = 0x9
	// Bit mask of P0_9CI field.
	GPIOINT_CLR0_P0_9CI_Msk = 0x200
	// Bit P0_9CI.
	GPIOINT_CLR0_P0_9CI = 0x200
	// Position of P0_10CI field.
	GPIOINT_CLR0_P0_10CI_Pos = 0xa
	// Bit mask of P0_10CI field.
	GPIOINT_CLR0_P0_10CI_Msk = 0x400
	// Bit P0_10CI.
	GPIOINT_CLR0_P0_10CI = 0x400
	// Position of P0_11CI field.
	GPIOINT_CLR0_P0_11CI_Pos = 0xb
	// Bit mask of P0_11CI field.
	GPIOINT_CLR0_P0_11CI_Msk = 0x800
	// Bit P0_11CI.
	GPIOINT_CLR0_P0_11CI = 0x800
	// Position of P0_12CI field.
	GPIOINT_CLR0_P0_12CI_Pos = 0xc
	// Bit mask of P0_12CI field.
	GPIOINT_CLR0_P0_12CI_Msk = 0x1000
	// Bit P0_12CI.
	GPIOINT_CLR0_P0_12CI = 0x1000
	// Position of P0_13CI field.
	GPIOINT_CLR0_P0_13CI_Pos = 0xd
	// Bit mask of P0_13CI field.
	GPIOINT_CLR0_P0_13CI_Msk = 0x2000
	// Bit P0_13CI.
	GPIOINT_CLR0_P0_13CI = 0x2000
	// Position of P0_14CI field.
	GPIOINT_CLR0_P0_14CI_Pos = 0xe
	// Bit mask of P0_14CI field.
	GPIOINT_CLR0_P0_14CI_Msk = 0x4000
	// Bit P0_14CI.
	GPIOINT_CLR0_P0_14CI = 0x4000
	// Position of P0_15CI field.
	GPIOINT_CLR0_P0_15CI_Pos = 0xf
	// Bit mask of P0_15CI field.
	GPIOINT_CLR0_P0_15CI_Msk = 0x8000
	// Bit P0_15CI.
	GPIOINT_CLR0_P0_15CI = 0x8000
	// Position of P0_16CI field.
	GPIOINT_CLR0_P0_16CI_Pos = 0x10
	// Bit mask of P0_16CI field.
	GPIOINT_CLR0_P0_16CI_Msk = 0x10000
	// Bit P0_16CI.
	GPIOINT_CLR0_P0_16CI = 0x10000
	// Position of P0_17CI field.
	GPIOINT_CLR0_P0_17CI_Pos = 0x11
	// Bit mask of P0_17CI field.
	GPIOINT_CLR0_P0_17CI_Msk = 0x20000
	// Bit P0_17CI.
	GPIOINT_CLR0_P0_17CI = 0x20000
	// Position of P0_18CI field.
	GPIOINT_CLR0_P0_18CI_Pos = 0x12
	// Bit mask of P0_18CI field.
	GPIOINT_CLR0_P0_18CI_Msk = 0x40000
	// Bit P0_18CI.
	GPIOINT_CLR0_P0_18CI = 0x40000
	// Position of P0_19CI field.
	GPIOINT_CLR0_P0_19CI_Pos = 0x13
	// Bit mask of P0_19CI field.
	GPIOINT_CLR0_P0_19CI_Msk = 0x80000
	// Bit P0_19CI.
	GPIOINT_CLR0_P0_19CI = 0x80000
	// Position of P0_20CI field.
	GPIOINT_CLR0_P0_20CI_Pos = 0x14
	// Bit mask of P0_20CI field.
	GPIOINT_CLR0_P0_20CI_Msk = 0x100000
	// Bit P0_20CI.
	GPIOINT_CLR0_P0_20CI = 0x100000
	// Position of P0_21CI field.
	GPIOINT_CLR0_P0_21CI_Pos = 0x15
	// Bit mask of P0_21CI field.
	GPIOINT_CLR0_P0_21CI_Msk = 0x200000
	// Bit P0_21CI.
	GPIOINT_CLR0_P0_21CI = 0x200000
	// Position of P0_22CI field.
	GPIOINT_CLR0_P0_22CI_Pos = 0x16
	// Bit mask of P0_22CI field.
	GPIOINT_CLR0_P0_22CI_Msk = 0x400000
	// Bit P0_22CI.
	GPIOINT_CLR0_P0_22CI = 0x400000
	// Position of P0_23CI field.
	GPIOINT_CLR0_P0_23CI_Pos = 0x17
	// Bit mask of P0_23CI field.
	GPIOINT_CLR0_P0_23CI_Msk = 0x800000
	// Bit P0_23CI.
	GPIOINT_CLR0_P0_23CI = 0x800000
	// Position of P0_24CI field.
	GPIOINT_CLR0_P0_24CI_Pos = 0x18
	// Bit mask of P0_24CI field.
	GPIOINT_CLR0_P0_24CI_Msk = 0x1000000
	// Bit P0_24CI.
	GPIOINT_CLR0_P0_24CI = 0x1000000
	// Position of P0_25CI field.
	GPIOINT_CLR0_P0_25CI_Pos = 0x19
	// Bit mask of P0_25CI field.
	GPIOINT_CLR0_P0_25CI_Msk = 0x2000000
	// Bit P0_25CI.
	GPIOINT_CLR0_P0_25CI = 0x2000000
	// Position of P0_26CI field.
	GPIOINT_CLR0_P0_26CI_Pos = 0x1a
	// Bit mask of P0_26CI field.
	GPIOINT_CLR0_P0_26CI_Msk = 0x4000000
	// Bit P0_26CI.
	GPIOINT_CLR0_P0_26CI = 0x4000000
	// Position of P0_27CI field.
	GPIOINT_CLR0_P0_27CI_Pos = 0x1b
	// Bit mask of P0_27CI field.
	GPIOINT_CLR0_P0_27CI_Msk = 0x8000000
	// Bit P0_27CI.
	GPIOINT_CLR0_P0_27CI = 0x8000000
	// Position of P0_28CI field.
	GPIOINT_CLR0_P0_28CI_Pos = 0x1c
	// Bit mask of P0_28CI field.
	GPIOINT_CLR0_P0_28CI_Msk = 0x10000000
	// Bit P0_28CI.
	GPIOINT_CLR0_P0_28CI = 0x10000000
	// Position of P0_29CI field.
	GPIOINT_CLR0_P0_29CI_Pos = 0x1d
	// Bit mask of P0_29CI field.
	GPIOINT_CLR0_P0_29CI_Msk = 0x20000000
	// Bit P0_29CI.
	GPIOINT_CLR0_P0_29CI = 0x20000000
	// Position of P0_30CI field.
	GPIOINT_CLR0_P0_30CI_Pos = 0x1e
	// Bit mask of P0_30CI field.
	GPIOINT_CLR0_P0_30CI_Msk = 0x40000000
	// Bit P0_30CI.
	GPIOINT_CLR0_P0_30CI = 0x40000000
	// Position of P0_31CI field.
	GPIOINT_CLR0_P0_31CI_Pos = 0x1f
	// Bit mask of P0_31CI field.
	GPIOINT_CLR0_P0_31CI_Msk = 0x80000000
	// Bit P0_31CI.
	GPIOINT_CLR0_P0_31CI = 0x80000000

	// ENR0: GPIO Interrupt Enable for Rising edge for Port 0.
	// Position of P0_0ER field.
	GPIOINT_ENR0_P0_0ER_Pos = 0x0
	// Bit mask of P0_0ER field.
	GPIOINT_ENR0_P0_0ER_Msk = 0x1
	// Bit P0_0ER.
	GPIOINT_ENR0_P0_0ER = 0x1
	// Position of P0_1ER field.
	GPIOINT_ENR0_P0_1ER_Pos = 0x1
	// Bit mask of P0_1ER field.
	GPIOINT_ENR0_P0_1ER_Msk = 0x2
	// Bit P0_1ER.
	GPIOINT_ENR0_P0_1ER = 0x2
	// Position of P0_2ER field.
	GPIOINT_ENR0_P0_2ER_Pos = 0x2
	// Bit mask of P0_2ER field.
	GPIOINT_ENR0_P0_2ER_Msk = 0x4
	// Bit P0_2ER.
	GPIOINT_ENR0_P0_2ER = 0x4
	// Position of P0_3ER field.
	GPIOINT_ENR0_P0_3ER_Pos = 0x3
	// Bit mask of P0_3ER field.
	GPIOINT_ENR0_P0_3ER_Msk = 0x8
	// Bit P0_3ER.
	GPIOINT_ENR0_P0_3ER = 0x8
	// Position of P0_4ER field.
	GPIOINT_ENR0_P0_4ER_Pos = 0x4
	// Bit mask of P0_4ER field.
	GPIOINT_ENR0_P0_4ER_Msk = 0x10
	// Bit P0_4ER.
	GPIOINT_ENR0_P0_4ER = 0x10
	// Position of P0_5ER field.
	GPIOINT_ENR0_P0_5ER_Pos = 0x5
	// Bit mask of P0_5ER field.
	GPIOINT_ENR0_P0_5ER_Msk = 0x20
	// Bit P0_5ER.
	GPIOINT_ENR0_P0_5ER = 0x20
	// Position of P0_6ER field.
	GPIOINT_ENR0_P0_6ER_Pos = 0x6
	// Bit mask of P0_6ER field.
	GPIOINT_ENR0_P0_6ER_Msk = 0x40
	// Bit P0_6ER.
	GPIOINT_ENR0_P0_6ER = 0x40
	// Position of P0_7ER field.
	GPIOINT_ENR0_P0_7ER_Pos = 0x7
	// Bit mask of P0_7ER field.
	GPIOINT_ENR0_P0_7ER_Msk = 0x80
	// Bit P0_7ER.
	GPIOINT_ENR0_P0_7ER = 0x80
	// Position of P0_8ER field.
	GPIOINT_ENR0_P0_8ER_Pos = 0x8
	// Bit mask of P0_8ER field.
	GPIOINT_ENR0_P0_8ER_Msk = 0x100
	// Bit P0_8ER.
	GPIOINT_ENR0_P0_8ER = 0x100
	// Position of P0_9ER field.
	GPIOINT_ENR0_P0_9ER_Pos = 0x9
	// Bit mask of P0_9ER field.
	GPIOINT_ENR0_P0_9ER_Msk = 0x200
	// Bit P0_9ER.
	GPIOINT_ENR0_P0_9ER = 0x200
	// Position of P0_10ER field.
	GPIOINT_ENR0_P0_10ER_Pos = 0xa
	// Bit mask of P0_10ER field.
	GPIOINT_ENR0_P0_10ER_Msk = 0x400
	// Bit P0_10ER.
	GPIOINT_ENR0_P0_10ER = 0x400
	// Position of P0_11ER field.
	GPIOINT_ENR0_P0_11ER_Pos = 0xb
	// Bit mask of P0_11ER field.
	GPIOINT_ENR0_P0_11ER_Msk = 0x800
	// Bit P0_11ER.
	GPIOINT_ENR0_P0_11ER = 0x800
	// Position of P0_12ER field.
	GPIOINT_ENR0_P0_12ER_Pos = 0xc
	// Bit mask of P0_12ER field.
	GPIOINT_ENR0_P0_12ER_Msk = 0x1000
	// Bit P0_12ER.
	GPIOINT_ENR0_P0_12ER = 0x1000
	// Position of P0_13ER field.
	GPIOINT_ENR0_P0_13ER_Pos = 0xd
	// Bit mask of P0_13ER field.
	GPIOINT_ENR0_P0_13ER_Msk = 0x2000
	// Bit P0_13ER.
	GPIOINT_ENR0_P0_13ER = 0x2000
	// Position of P0_14ER field.
	GPIOINT_ENR0_P0_14ER_Pos = 0xe
	// Bit mask of P0_14ER field.
	GPIOINT_ENR0_P0_14ER_Msk = 0x4000
	// Bit P0_14ER.
	GPIOINT_ENR0_P0_14ER = 0x4000
	// Position of P0_15ER field.
	GPIOINT_ENR0_P0_15ER_Pos = 0xf
	// Bit mask of P0_15ER field.
	GPIOINT_ENR0_P0_15ER_Msk = 0x8000
	// Bit P0_15ER.
	GPIOINT_ENR0_P0_15ER = 0x8000
	// Position of P0_16ER field.
	GPIOINT_ENR0_P0_16ER_Pos = 0x10
	// Bit mask of P0_16ER field.
	GPIOINT_ENR0_P0_16ER_Msk = 0x10000
	// Bit P0_16ER.
	GPIOINT_ENR0_P0_16ER = 0x10000
	// Position of P0_17ER field.
	GPIOINT_ENR0_P0_17ER_Pos = 0x11
	// Bit mask of P0_17ER field.
	GPIOINT_ENR0_P0_17ER_Msk = 0x20000
	// Bit P0_17ER.
	GPIOINT_ENR0_P0_17ER = 0x20000
	// Position of P0_18ER field.
	GPIOINT_ENR0_P0_18ER_Pos = 0x12
	// Bit mask of P0_18ER field.
	GPIOINT_ENR0_P0_18ER_Msk = 0x40000
	// Bit P0_18ER.
	GPIOINT_ENR0_P0_18ER = 0x40000
	// Position of P0_19ER field.
	GPIOINT_ENR0_P0_19ER_Pos = 0x13
	// Bit mask of P0_19ER field.
	GPIOINT_ENR0_P0_19ER_Msk = 0x80000
	// Bit P0_19ER.
	GPIOINT_ENR0_P0_19ER = 0x80000
	// Position of P0_20ER field.
	GPIOINT_ENR0_P0_20ER_Pos = 0x14
	// Bit mask of P0_20ER field.
	GPIOINT_ENR0_P0_20ER_Msk = 0x100000
	// Bit P0_20ER.
	GPIOINT_ENR0_P0_20ER = 0x100000
	// Position of P0_21ER field.
	GPIOINT_ENR0_P0_21ER_Pos = 0x15
	// Bit mask of P0_21ER field.
	GPIOINT_ENR0_P0_21ER_Msk = 0x200000
	// Bit P0_21ER.
	GPIOINT_ENR0_P0_21ER = 0x200000
	// Position of P0_22ER field.
	GPIOINT_ENR0_P0_22ER_Pos = 0x16
	// Bit mask of P0_22ER field.
	GPIOINT_ENR0_P0_22ER_Msk = 0x400000
	// Bit P0_22ER.
	GPIOINT_ENR0_P0_22ER = 0x400000
	// Position of P0_23ER field.
	GPIOINT_ENR0_P0_23ER_Pos = 0x17
	// Bit mask of P0_23ER field.
	GPIOINT_ENR0_P0_23ER_Msk = 0x800000
	// Bit P0_23ER.
	GPIOINT_ENR0_P0_23ER = 0x800000
	// Position of P0_24ER field.
	GPIOINT_ENR0_P0_24ER_Pos = 0x18
	// Bit mask of P0_24ER field.
	GPIOINT_ENR0_P0_24ER_Msk = 0x1000000
	// Bit P0_24ER.
	GPIOINT_ENR0_P0_24ER = 0x1000000
	// Position of P0_25ER field.
	GPIOINT_ENR0_P0_25ER_Pos = 0x19
	// Bit mask of P0_25ER field.
	GPIOINT_ENR0_P0_25ER_Msk = 0x2000000
	// Bit P0_25ER.
	GPIOINT_ENR0_P0_25ER = 0x2000000
	// Position of P0_26ER field.
	GPIOINT_ENR0_P0_26ER_Pos = 0x1a
	// Bit mask of P0_26ER field.
	GPIOINT_ENR0_P0_26ER_Msk = 0x4000000
	// Bit P0_26ER.
	GPIOINT_ENR0_P0_26ER = 0x4000000
	// Position of P0_27ER field.
	GPIOINT_ENR0_P0_27ER_Pos = 0x1b
	// Bit mask of P0_27ER field.
	GPIOINT_ENR0_P0_27ER_Msk = 0x8000000
	// Bit P0_27ER.
	GPIOINT_ENR0_P0_27ER = 0x8000000
	// Position of P0_28ER field.
	GPIOINT_ENR0_P0_28ER_Pos = 0x1c
	// Bit mask of P0_28ER field.
	GPIOINT_ENR0_P0_28ER_Msk = 0x10000000
	// Bit P0_28ER.
	GPIOINT_ENR0_P0_28ER = 0x10000000
	// Position of P0_29ER field.
	GPIOINT_ENR0_P0_29ER_Pos = 0x1d
	// Bit mask of P0_29ER field.
	GPIOINT_ENR0_P0_29ER_Msk = 0x20000000
	// Bit P0_29ER.
	GPIOINT_ENR0_P0_29ER = 0x20000000
	// Position of P0_30ER field.
	GPIOINT_ENR0_P0_30ER_Pos = 0x1e
	// Bit mask of P0_30ER field.
	GPIOINT_ENR0_P0_30ER_Msk = 0x40000000
	// Bit P0_30ER.
	GPIOINT_ENR0_P0_30ER = 0x40000000
	// Position of P0_31ER field.
	GPIOINT_ENR0_P0_31ER_Pos = 0x1f
	// Bit mask of P0_31ER field.
	GPIOINT_ENR0_P0_31ER_Msk = 0x80000000
	// Bit P0_31ER.
	GPIOINT_ENR0_P0_31ER = 0x80000000

	// ENF0: GPIO Interrupt Enable for Falling edge for Port 0.
	// Position of P0_0EF field.
	GPIOINT_ENF0_P0_0EF_Pos = 0x0
	// Bit mask of P0_0EF field.
	GPIOINT_ENF0_P0_0EF_Msk = 0x1
	// Bit P0_0EF.
	GPIOINT_ENF0_P0_0EF = 0x1
	// Position of P0_1EF field.
	GPIOINT_ENF0_P0_1EF_Pos = 0x1
	// Bit mask of P0_1EF field.
	GPIOINT_ENF0_P0_1EF_Msk = 0x2
	// Bit P0_1EF.
	GPIOINT_ENF0_P0_1EF = 0x2
	// Position of P0_2EF field.
	GPIOINT_ENF0_P0_2EF_Pos = 0x2
	// Bit mask of P0_2EF field.
	GPIOINT_ENF0_P0_2EF_Msk = 0x4
	// Bit P0_2EF.
	GPIOINT_ENF0_P0_2EF = 0x4
	// Position of P0_3EF field.
	GPIOINT_ENF0_P0_3EF_Pos = 0x3
	// Bit mask of P0_3EF field.
	GPIOINT_ENF0_P0_3EF_Msk = 0x8
	// Bit P0_3EF.
	GPIOINT_ENF0_P0_3EF = 0x8
	// Position of P0_4EF field.
	GPIOINT_ENF0_P0_4EF_Pos = 0x4
	// Bit mask of P0_4EF field.
	GPIOINT_ENF0_P0_4EF_Msk = 0x10
	// Bit P0_4EF.
	GPIOINT_ENF0_P0_4EF = 0x10
	// Position of P0_5EF field.
	GPIOINT_ENF0_P0_5EF_Pos = 0x5
	// Bit mask of P0_5EF field.
	GPIOINT_ENF0_P0_5EF_Msk = 0x20
	// Bit P0_5EF.
	GPIOINT_ENF0_P0_5EF = 0x20
	// Position of P0_6EF field.
	GPIOINT_ENF0_P0_6EF_Pos = 0x6
	// Bit mask of P0_6EF field.
	GPIOINT_ENF0_P0_6EF_Msk = 0x40
	// Bit P0_6EF.
	GPIOINT_ENF0_P0_6EF = 0x40
	// Position of P0_7EF field.
	GPIOINT_ENF0_P0_7EF_Pos = 0x7
	// Bit mask of P0_7EF field.
	GPIOINT_ENF0_P0_7EF_Msk = 0x80
	// Bit P0_7EF.
	GPIOINT_ENF0_P0_7EF = 0x80
	// Position of P0_8EF field.
	GPIOINT_ENF0_P0_8EF_Pos = 0x8
	// Bit mask of P0_8EF field.
	GPIOINT_ENF0_P0_8EF_Msk = 0x100
	// Bit P0_8EF.
	GPIOINT_ENF0_P0_8EF = 0x100
	// Position of P0_9EF field.
	GPIOINT_ENF0_P0_9EF_Pos = 0x9
	// Bit mask of P0_9EF field.
	GPIOINT_ENF0_P0_9EF_Msk = 0x200
	// Bit P0_9EF.
	GPIOINT_ENF0_P0_9EF = 0x200
	// Position of P0_10EF field.
	GPIOINT_ENF0_P0_10EF_Pos = 0xa
	// Bit mask of P0_10EF field.
	GPIOINT_ENF0_P0_10EF_Msk = 0x400
	// Bit P0_10EF.
	GPIOINT_ENF0_P0_10EF = 0x400
	// Position of P0_11EF field.
	GPIOINT_ENF0_P0_11EF_Pos = 0xb
	// Bit mask of P0_11EF field.
	GPIOINT_ENF0_P0_11EF_Msk = 0x800
	// Bit P0_11EF.
	GPIOINT_ENF0_P0_11EF = 0x800
	// Position of P0_12EF field.
	GPIOINT_ENF0_P0_12EF_Pos = 0xc
	// Bit mask of P0_12EF field.
	GPIOINT_ENF0_P0_12EF_Msk = 0x1000
	// Bit P0_12EF.
	GPIOINT_ENF0_P0_12EF = 0x1000
	// Position of P0_13EF field.
	GPIOINT_ENF0_P0_13EF_Pos = 0xd
	// Bit mask of P0_13EF field.
	GPIOINT_ENF0_P0_13EF_Msk = 0x2000
	// Bit P0_13EF.
	GPIOINT_ENF0_P0_13EF = 0x2000
	// Position of P0_14EF field.
	GPIOINT_ENF0_P0_14EF_Pos = 0xe
	// Bit mask of P0_14EF field.
	GPIOINT_ENF0_P0_14EF_Msk = 0x4000
	// Bit P0_14EF.
	GPIOINT_ENF0_P0_14EF = 0x4000
	// Position of P0_15EF field.
	GPIOINT_ENF0_P0_15EF_Pos = 0xf
	// Bit mask of P0_15EF field.
	GPIOINT_ENF0_P0_15EF_Msk = 0x8000
	// Bit P0_15EF.
	GPIOINT_ENF0_P0_15EF = 0x8000
	// Position of P0_16EF field.
	GPIOINT_ENF0_P0_16EF_Pos = 0x10
	// Bit mask of P0_16EF field.
	GPIOINT_ENF0_P0_16EF_Msk = 0x10000
	// Bit P0_16EF.
	GPIOINT_ENF0_P0_16EF = 0x10000
	// Position of P0_17EF field.
	GPIOINT_ENF0_P0_17EF_Pos = 0x11
	// Bit mask of P0_17EF field.
	GPIOINT_ENF0_P0_17EF_Msk = 0x20000
	// Bit P0_17EF.
	GPIOINT_ENF0_P0_17EF = 0x20000
	// Position of P0_18EF field.
	GPIOINT_ENF0_P0_18EF_Pos = 0x12
	// Bit mask of P0_18EF field.
	GPIOINT_ENF0_P0_18EF_Msk = 0x40000
	// Bit P0_18EF.
	GPIOINT_ENF0_P0_18EF = 0x40000
	// Position of P0_19EF field.
	GPIOINT_ENF0_P0_19EF_Pos = 0x13
	// Bit mask of P0_19EF field.
	GPIOINT_ENF0_P0_19EF_Msk = 0x80000
	// Bit P0_19EF.
	GPIOINT_ENF0_P0_19EF = 0x80000
	// Position of P0_20EF field.
	GPIOINT_ENF0_P0_20EF_Pos = 0x14
	// Bit mask of P0_20EF field.
	GPIOINT_ENF0_P0_20EF_Msk = 0x100000
	// Bit P0_20EF.
	GPIOINT_ENF0_P0_20EF = 0x100000
	// Position of P0_21EF field.
	GPIOINT_ENF0_P0_21EF_Pos = 0x15
	// Bit mask of P0_21EF field.
	GPIOINT_ENF0_P0_21EF_Msk = 0x200000
	// Bit P0_21EF.
	GPIOINT_ENF0_P0_21EF = 0x200000
	// Position of P0_22EF field.
	GPIOINT_ENF0_P0_22EF_Pos = 0x16
	// Bit mask of P0_22EF field.
	GPIOINT_ENF0_P0_22EF_Msk = 0x400000
	// Bit P0_22EF.
	GPIOINT_ENF0_P0_22EF = 0x400000
	// Position of P0_23EF field.
	GPIOINT_ENF0_P0_23EF_Pos = 0x17
	// Bit mask of P0_23EF field.
	GPIOINT_ENF0_P0_23EF_Msk = 0x800000
	// Bit P0_23EF.
	GPIOINT_ENF0_P0_23EF = 0x800000
	// Position of P0_24EF field.
	GPIOINT_ENF0_P0_24EF_Pos = 0x18
	// Bit mask of P0_24EF field.
	GPIOINT_ENF0_P0_24EF_Msk = 0x1000000
	// Bit P0_24EF.
	GPIOINT_ENF0_P0_24EF = 0x1000000
	// Position of P0_25EF field.
	GPIOINT_ENF0_P0_25EF_Pos = 0x19
	// Bit mask of P0_25EF field.
	GPIOINT_ENF0_P0_25EF_Msk = 0x2000000
	// Bit P0_25EF.
	GPIOINT_ENF0_P0_25EF = 0x2000000
	// Position of P0_26EF field.
	GPIOINT_ENF0_P0_26EF_Pos = 0x1a
	// Bit mask of P0_26EF field.
	GPIOINT_ENF0_P0_26EF_Msk = 0x4000000
	// Bit P0_26EF.
	GPIOINT_ENF0_P0_26EF = 0x4000000
	// Position of P0_27EF field.
	GPIOINT_ENF0_P0_27EF_Pos = 0x1b
	// Bit mask of P0_27EF field.
	GPIOINT_ENF0_P0_27EF_Msk = 0x8000000
	// Bit P0_27EF.
	GPIOINT_ENF0_P0_27EF = 0x8000000
	// Position of P0_28EF field.
	GPIOINT_ENF0_P0_28EF_Pos = 0x1c
	// Bit mask of P0_28EF field.
	GPIOINT_ENF0_P0_28EF_Msk = 0x10000000
	// Bit P0_28EF.
	GPIOINT_ENF0_P0_28EF = 0x10000000
	// Position of P0_29EF field.
	GPIOINT_ENF0_P0_29EF_Pos = 0x1d
	// Bit mask of P0_29EF field.
	GPIOINT_ENF0_P0_29EF_Msk = 0x20000000
	// Bit P0_29EF.
	GPIOINT_ENF0_P0_29EF = 0x20000000
	// Position of P0_30EF field.
	GPIOINT_ENF0_P0_30EF_Pos = 0x1e
	// Bit mask of P0_30EF field.
	GPIOINT_ENF0_P0_30EF_Msk = 0x40000000
	// Bit P0_30EF.
	GPIOINT_ENF0_P0_30EF = 0x40000000
	// Position of P0_31EF field.
	GPIOINT_ENF0_P0_31EF_Pos = 0x1f
	// Bit mask of P0_31EF field.
	GPIOINT_ENF0_P0_31EF_Msk = 0x80000000
	// Bit P0_31EF.
	GPIOINT_ENF0_P0_31EF = 0x80000000

	// STATR2: GPIO Interrupt Status for Rising edge for Port 0.
	// Position of P2_0REI field.
	GPIOINT_STATR2_P2_0REI_Pos = 0x0
	// Bit mask of P2_0REI field.
	GPIOINT_STATR2_P2_0REI_Msk = 0x1
	// Bit P2_0REI.
	GPIOINT_STATR2_P2_0REI = 0x1
	// Position of P2_1REI field.
	GPIOINT_STATR2_P2_1REI_Pos = 0x1
	// Bit mask of P2_1REI field.
	GPIOINT_STATR2_P2_1REI_Msk = 0x2
	// Bit P2_1REI.
	GPIOINT_STATR2_P2_1REI = 0x2
	// Position of P2_2REI field.
	GPIOINT_STATR2_P2_2REI_Pos = 0x2
	// Bit mask of P2_2REI field.
	GPIOINT_STATR2_P2_2REI_Msk = 0x4
	// Bit P2_2REI.
	GPIOINT_STATR2_P2_2REI = 0x4
	// Position of P2_3REI field.
	GPIOINT_STATR2_P2_3REI_Pos = 0x3
	// Bit mask of P2_3REI field.
	GPIOINT_STATR2_P2_3REI_Msk = 0x8
	// Bit P2_3REI.
	GPIOINT_STATR2_P2_3REI = 0x8
	// Position of P2_4REI field.
	GPIOINT_STATR2_P2_4REI_Pos = 0x4
	// Bit mask of P2_4REI field.
	GPIOINT_STATR2_P2_4REI_Msk = 0x10
	// Bit P2_4REI.
	GPIOINT_STATR2_P2_4REI = 0x10
	// Position of P2_5REI field.
	GPIOINT_STATR2_P2_5REI_Pos = 0x5
	// Bit mask of P2_5REI field.
	GPIOINT_STATR2_P2_5REI_Msk = 0x20
	// Bit P2_5REI.
	GPIOINT_STATR2_P2_5REI = 0x20
	// Position of P2_6REI field.
	GPIOINT_STATR2_P2_6REI_Pos = 0x6
	// Bit mask of P2_6REI field.
	GPIOINT_STATR2_P2_6REI_Msk = 0x40
	// Bit P2_6REI.
	GPIOINT_STATR2_P2_6REI = 0x40
	// Position of P2_7REI field.
	GPIOINT_STATR2_P2_7REI_Pos = 0x7
	// Bit mask of P2_7REI field.
	GPIOINT_STATR2_P2_7REI_Msk = 0x80
	// Bit P2_7REI.
	GPIOINT_STATR2_P2_7REI = 0x80
	// Position of P2_8REI field.
	GPIOINT_STATR2_P2_8REI_Pos = 0x8
	// Bit mask of P2_8REI field.
	GPIOINT_STATR2_P2_8REI_Msk = 0x100
	// Bit P2_8REI.
	GPIOINT_STATR2_P2_8REI = 0x100
	// Position of P2_9REI field.
	GPIOINT_STATR2_P2_9REI_Pos = 0x9
	// Bit mask of P2_9REI field.
	GPIOINT_STATR2_P2_9REI_Msk = 0x200
	// Bit P2_9REI.
	GPIOINT_STATR2_P2_9REI = 0x200
	// Position of P2_10REI field.
	GPIOINT_STATR2_P2_10REI_Pos = 0xa
	// Bit mask of P2_10REI field.
	GPIOINT_STATR2_P2_10REI_Msk = 0x400
	// Bit P2_10REI.
	GPIOINT_STATR2_P2_10REI = 0x400
	// Position of P2_11REI field.
	GPIOINT_STATR2_P2_11REI_Pos = 0xb
	// Bit mask of P2_11REI field.
	GPIOINT_STATR2_P2_11REI_Msk = 0x800
	// Bit P2_11REI.
	GPIOINT_STATR2_P2_11REI = 0x800
	// Position of P2_12REI field.
	GPIOINT_STATR2_P2_12REI_Pos = 0xc
	// Bit mask of P2_12REI field.
	GPIOINT_STATR2_P2_12REI_Msk = 0x1000
	// Bit P2_12REI.
	GPIOINT_STATR2_P2_12REI = 0x1000
	// Position of P2_13REI field.
	GPIOINT_STATR2_P2_13REI_Pos = 0xd
	// Bit mask of P2_13REI field.
	GPIOINT_STATR2_P2_13REI_Msk = 0x2000
	// Bit P2_13REI.
	GPIOINT_STATR2_P2_13REI = 0x2000
	// Position of P2_14REI field.
	GPIOINT_STATR2_P2_14REI_Pos = 0xe
	// Bit mask of P2_14REI field.
	GPIOINT_STATR2_P2_14REI_Msk = 0x4000
	// Bit P2_14REI.
	GPIOINT_STATR2_P2_14REI = 0x4000
	// Position of P2_15REI field.
	GPIOINT_STATR2_P2_15REI_Pos = 0xf
	// Bit mask of P2_15REI field.
	GPIOINT_STATR2_P2_15REI_Msk = 0x8000
	// Bit P2_15REI.
	GPIOINT_STATR2_P2_15REI = 0x8000
	// Position of P2_16REI field.
	GPIOINT_STATR2_P2_16REI_Pos = 0x10
	// Bit mask of P2_16REI field.
	GPIOINT_STATR2_P2_16REI_Msk = 0x10000
	// Bit P2_16REI.
	GPIOINT_STATR2_P2_16REI = 0x10000
	// Position of P2_17REI field.
	GPIOINT_STATR2_P2_17REI_Pos = 0x11
	// Bit mask of P2_17REI field.
	GPIOINT_STATR2_P2_17REI_Msk = 0x20000
	// Bit P2_17REI.
	GPIOINT_STATR2_P2_17REI = 0x20000
	// Position of P2_18REI field.
	GPIOINT_STATR2_P2_18REI_Pos = 0x12
	// Bit mask of P2_18REI field.
	GPIOINT_STATR2_P2_18REI_Msk = 0x40000
	// Bit P2_18REI.
	GPIOINT_STATR2_P2_18REI = 0x40000
	// Position of P2_19REI field.
	GPIOINT_STATR2_P2_19REI_Pos = 0x13
	// Bit mask of P2_19REI field.
	GPIOINT_STATR2_P2_19REI_Msk = 0x80000
	// Bit P2_19REI.
	GPIOINT_STATR2_P2_19REI = 0x80000
	// Position of P2_20REI field.
	GPIOINT_STATR2_P2_20REI_Pos = 0x14
	// Bit mask of P2_20REI field.
	GPIOINT_STATR2_P2_20REI_Msk = 0x100000
	// Bit P2_20REI.
	GPIOINT_STATR2_P2_20REI = 0x100000
	// Position of P2_21REI field.
	GPIOINT_STATR2_P2_21REI_Pos = 0x15
	// Bit mask of P2_21REI field.
	GPIOINT_STATR2_P2_21REI_Msk = 0x200000
	// Bit P2_21REI.
	GPIOINT_STATR2_P2_21REI = 0x200000
	// Position of P2_22REI field.
	GPIOINT_STATR2_P2_22REI_Pos = 0x16
	// Bit mask of P2_22REI field.
	GPIOINT_STATR2_P2_22REI_Msk = 0x400000
	// Bit P2_22REI.
	GPIOINT_STATR2_P2_22REI = 0x400000
	// Position of P2_23REI field.
	GPIOINT_STATR2_P2_23REI_Pos = 0x17
	// Bit mask of P2_23REI field.
	GPIOINT_STATR2_P2_23REI_Msk = 0x800000
	// Bit P2_23REI.
	GPIOINT_STATR2_P2_23REI = 0x800000
	// Position of P2_24REI field.
	GPIOINT_STATR2_P2_24REI_Pos = 0x18
	// Bit mask of P2_24REI field.
	GPIOINT_STATR2_P2_24REI_Msk = 0x1000000
	// Bit P2_24REI.
	GPIOINT_STATR2_P2_24REI = 0x1000000
	// Position of P2_25REI field.
	GPIOINT_STATR2_P2_25REI_Pos = 0x19
	// Bit mask of P2_25REI field.
	GPIOINT_STATR2_P2_25REI_Msk = 0x2000000
	// Bit P2_25REI.
	GPIOINT_STATR2_P2_25REI = 0x2000000
	// Position of P2_26REI field.
	GPIOINT_STATR2_P2_26REI_Pos = 0x1a
	// Bit mask of P2_26REI field.
	GPIOINT_STATR2_P2_26REI_Msk = 0x4000000
	// Bit P2_26REI.
	GPIOINT_STATR2_P2_26REI = 0x4000000
	// Position of P2_27REI field.
	GPIOINT_STATR2_P2_27REI_Pos = 0x1b
	// Bit mask of P2_27REI field.
	GPIOINT_STATR2_P2_27REI_Msk = 0x8000000
	// Bit P2_27REI.
	GPIOINT_STATR2_P2_27REI = 0x8000000
	// Position of P2_28REI field.
	GPIOINT_STATR2_P2_28REI_Pos = 0x1c
	// Bit mask of P2_28REI field.
	GPIOINT_STATR2_P2_28REI_Msk = 0x10000000
	// Bit P2_28REI.
	GPIOINT_STATR2_P2_28REI = 0x10000000
	// Position of P2_29REI field.
	GPIOINT_STATR2_P2_29REI_Pos = 0x1d
	// Bit mask of P2_29REI field.
	GPIOINT_STATR2_P2_29REI_Msk = 0x20000000
	// Bit P2_29REI.
	GPIOINT_STATR2_P2_29REI = 0x20000000
	// Position of P2_30REI field.
	GPIOINT_STATR2_P2_30REI_Pos = 0x1e
	// Bit mask of P2_30REI field.
	GPIOINT_STATR2_P2_30REI_Msk = 0x40000000
	// Bit P2_30REI.
	GPIOINT_STATR2_P2_30REI = 0x40000000
	// Position of P2_31REI field.
	GPIOINT_STATR2_P2_31REI_Pos = 0x1f
	// Bit mask of P2_31REI field.
	GPIOINT_STATR2_P2_31REI_Msk = 0x80000000
	// Bit P2_31REI.
	GPIOINT_STATR2_P2_31REI = 0x80000000

	// STATF2: GPIO Interrupt Status for Falling edge for Port 0.
	// Position of P2_0FEI field.
	GPIOINT_STATF2_P2_0FEI_Pos = 0x0
	// Bit mask of P2_0FEI field.
	GPIOINT_STATF2_P2_0FEI_Msk = 0x1
	// Bit P2_0FEI.
	GPIOINT_STATF2_P2_0FEI = 0x1
	// Position of P2_1FEI field.
	GPIOINT_STATF2_P2_1FEI_Pos = 0x1
	// Bit mask of P2_1FEI field.
	GPIOINT_STATF2_P2_1FEI_Msk = 0x2
	// Bit P2_1FEI.
	GPIOINT_STATF2_P2_1FEI = 0x2
	// Position of P2_2FEI field.
	GPIOINT_STATF2_P2_2FEI_Pos = 0x2
	// Bit mask of P2_2FEI field.
	GPIOINT_STATF2_P2_2FEI_Msk = 0x4
	// Bit P2_2FEI.
	GPIOINT_STATF2_P2_2FEI = 0x4
	// Position of P2_3FEI field.
	GPIOINT_STATF2_P2_3FEI_Pos = 0x3
	// Bit mask of P2_3FEI field.
	GPIOINT_STATF2_P2_3FEI_Msk = 0x8
	// Bit P2_3FEI.
	GPIOINT_STATF2_P2_3FEI = 0x8
	// Position of P2_4FEI field.
	GPIOINT_STATF2_P2_4FEI_Pos = 0x4
	// Bit mask of P2_4FEI field.
	GPIOINT_STATF2_P2_4FEI_Msk = 0x10
	// Bit P2_4FEI.
	GPIOINT_STATF2_P2_4FEI = 0x10
	// Position of P2_5FEI field.
	GPIOINT_STATF2_P2_5FEI_Pos = 0x5
	// Bit mask of P2_5FEI field.
	GPIOINT_STATF2_P2_5FEI_Msk = 0x20
	// Bit P2_5FEI.
	GPIOINT_STATF2_P2_5FEI = 0x20
	// Position of P2_6FEI field.
	GPIOINT_STATF2_P2_6FEI_Pos = 0x6
	// Bit mask of P2_6FEI field.
	GPIOINT_STATF2_P2_6FEI_Msk = 0x40
	// Bit P2_6FEI.
	GPIOINT_STATF2_P2_6FEI = 0x40
	// Position of P2_7FEI field.
	GPIOINT_STATF2_P2_7FEI_Pos = 0x7
	// Bit mask of P2_7FEI field.
	GPIOINT_STATF2_P2_7FEI_Msk = 0x80
	// Bit P2_7FEI.
	GPIOINT_STATF2_P2_7FEI = 0x80
	// Position of P2_8FEI field.
	GPIOINT_STATF2_P2_8FEI_Pos = 0x8
	// Bit mask of P2_8FEI field.
	GPIOINT_STATF2_P2_8FEI_Msk = 0x100
	// Bit P2_8FEI.
	GPIOINT_STATF2_P2_8FEI = 0x100
	// Position of P2_9FEI field.
	GPIOINT_STATF2_P2_9FEI_Pos = 0x9
	// Bit mask of P2_9FEI field.
	GPIOINT_STATF2_P2_9FEI_Msk = 0x200
	// Bit P2_9FEI.
	GPIOINT_STATF2_P2_9FEI = 0x200
	// Position of P2_10FEI field.
	GPIOINT_STATF2_P2_10FEI_Pos = 0xa
	// Bit mask of P2_10FEI field.
	GPIOINT_STATF2_P2_10FEI_Msk = 0x400
	// Bit P2_10FEI.
	GPIOINT_STATF2_P2_10FEI = 0x400
	// Position of P2_11FEI field.
	GPIOINT_STATF2_P2_11FEI_Pos = 0xb
	// Bit mask of P2_11FEI field.
	GPIOINT_STATF2_P2_11FEI_Msk = 0x800
	// Bit P2_11FEI.
	GPIOINT_STATF2_P2_11FEI = 0x800
	// Position of P2_12FEI field.
	GPIOINT_STATF2_P2_12FEI_Pos = 0xc
	// Bit mask of P2_12FEI field.
	GPIOINT_STATF2_P2_12FEI_Msk = 0x1000
	// Bit P2_12FEI.
	GPIOINT_STATF2_P2_12FEI = 0x1000
	// Position of P2_13FEI field.
	GPIOINT_STATF2_P2_13FEI_Pos = 0xd
	// Bit mask of P2_13FEI field.
	GPIOINT_STATF2_P2_13FEI_Msk = 0x2000
	// Bit P2_13FEI.
	GPIOINT_STATF2_P2_13FEI = 0x2000
	// Position of P2_14FEI field.
	GPIOINT_STATF2_P2_14FEI_Pos = 0xe
	// Bit mask of P2_14FEI field.
	GPIOINT_STATF2_P2_14FEI_Msk = 0x4000
	// Bit P2_14FEI.
	GPIOINT_STATF2_P2_14FEI = 0x4000
	// Position of P2_15FEI field.
	GPIOINT_STATF2_P2_15FEI_Pos = 0xf
	// Bit mask of P2_15FEI field.
	GPIOINT_STATF2_P2_15FEI_Msk = 0x8000
	// Bit P2_15FEI.
	GPIOINT_STATF2_P2_15FEI = 0x8000
	// Position of P2_16FEI field.
	GPIOINT_STATF2_P2_16FEI_Pos = 0x10
	// Bit mask of P2_16FEI field.
	GPIOINT_STATF2_P2_16FEI_Msk = 0x10000
	// Bit P2_16FEI.
	GPIOINT_STATF2_P2_16FEI = 0x10000
	// Position of P2_17FEI field.
	GPIOINT_STATF2_P2_17FEI_Pos = 0x11
	// Bit mask of P2_17FEI field.
	GPIOINT_STATF2_P2_17FEI_Msk = 0x20000
	// Bit P2_17FEI.
	GPIOINT_STATF2_P2_17FEI = 0x20000
	// Position of P2_18FEI field.
	GPIOINT_STATF2_P2_18FEI_Pos = 0x12
	// Bit mask of P2_18FEI field.
	GPIOINT_STATF2_P2_18FEI_Msk = 0x40000
	// Bit P2_18FEI.
	GPIOINT_STATF2_P2_18FEI = 0x40000
	// Position of P2_19FEI field.
	GPIOINT_STATF2_P2_19FEI_Pos = 0x13
	// Bit mask of P2_19FEI field.
	GPIOINT_STATF2_P2_19FEI_Msk = 0x80000
	// Bit P2_19FEI.
	GPIOINT_STATF2_P2_19FEI = 0x80000
	// Position of P2_20FEI field.
	GPIOINT_STATF2_P2_20FEI_Pos = 0x14
	// Bit mask of P2_20FEI field.
	GPIOINT_STATF2_P2_20FEI_Msk = 0x100000
	// Bit P2_20FEI.
	GPIOINT_STATF2_P2_20FEI = 0x100000
	// Position of P2_21FEI field.
	GPIOINT_STATF2_P2_21FEI_Pos = 0x15
	// Bit mask of P2_21FEI field.
	GPIOINT_STATF2_P2_21FEI_Msk = 0x200000
	// Bit P2_21FEI.
	GPIOINT_STATF2_P2_21FEI = 0x200000
	// Position of P2_22FEI field.
	GPIOINT_STATF2_P2_22FEI_Pos = 0x16
	// Bit mask of P2_22FEI field.
	GPIOINT_STATF2_P2_22FEI_Msk = 0x400000
	// Bit P2_22FEI.
	GPIOINT_STATF2_P2_22FEI = 0x400000
	// Position of P2_23FEI field.
	GPIOINT_STATF2_P2_23FEI_Pos = 0x17
	// Bit mask of P2_23FEI field.
	GPIOINT_STATF2_P2_23FEI_Msk = 0x800000
	// Bit P2_23FEI.
	GPIOINT_STATF2_P2_23FEI = 0x800000
	// Position of P2_24FEI field.
	GPIOINT_STATF2_P2_24FEI_Pos = 0x18
	// Bit mask of P2_24FEI field.
	GPIOINT_STATF2_P2_24FEI_Msk = 0x1000000
	// Bit P2_24FEI.
	GPIOINT_STATF2_P2_24FEI = 0x1000000
	// Position of P2_25FEI field.
	GPIOINT_STATF2_P2_25FEI_Pos = 0x19
	// Bit mask of P2_25FEI field.
	GPIOINT_STATF2_P2_25FEI_Msk = 0x2000000
	// Bit P2_25FEI.
	GPIOINT_STATF2_P2_25FEI = 0x2000000
	// Position of P2_26FEI field.
	GPIOINT_STATF2_P2_26FEI_Pos = 0x1a
	// Bit mask of P2_26FEI field.
	GPIOINT_STATF2_P2_26FEI_Msk = 0x4000000
	// Bit P2_26FEI.
	GPIOINT_STATF2_P2_26FEI = 0x4000000
	// Position of P2_27FEI field.
	GPIOINT_STATF2_P2_27FEI_Pos = 0x1b
	// Bit mask of P2_27FEI field.
	GPIOINT_STATF2_P2_27FEI_Msk = 0x8000000
	// Bit P2_27FEI.
	GPIOINT_STATF2_P2_27FEI = 0x8000000
	// Position of P2_28FEI field.
	GPIOINT_STATF2_P2_28FEI_Pos = 0x1c
	// Bit mask of P2_28FEI field.
	GPIOINT_STATF2_P2_28FEI_Msk = 0x10000000
	// Bit P2_28FEI.
	GPIOINT_STATF2_P2_28FEI = 0x10000000
	// Position of P2_29FEI field.
	GPIOINT_STATF2_P2_29FEI_Pos = 0x1d
	// Bit mask of P2_29FEI field.
	GPIOINT_STATF2_P2_29FEI_Msk = 0x20000000
	// Bit P2_29FEI.
	GPIOINT_STATF2_P2_29FEI = 0x20000000
	// Position of P2_30FEI field.
	GPIOINT_STATF2_P2_30FEI_Pos = 0x1e
	// Bit mask of P2_30FEI field.
	GPIOINT_STATF2_P2_30FEI_Msk = 0x40000000
	// Bit P2_30FEI.
	GPIOINT_STATF2_P2_30FEI = 0x40000000
	// Position of P2_31FEI field.
	GPIOINT_STATF2_P2_31FEI_Pos = 0x1f
	// Bit mask of P2_31FEI field.
	GPIOINT_STATF2_P2_31FEI_Msk = 0x80000000
	// Bit P2_31FEI.
	GPIOINT_STATF2_P2_31FEI = 0x80000000

	// CLR2: GPIO Interrupt Clear.
	// Position of P2_0CI field.
	GPIOINT_CLR2_P2_0CI_Pos = 0x0
	// Bit mask of P2_0CI field.
	GPIOINT_CLR2_P2_0CI_Msk = 0x1
	// Bit P2_0CI.
	GPIOINT_CLR2_P2_0CI = 0x1
	// Position of P2_1CI field.
	GPIOINT_CLR2_P2_1CI_Pos = 0x1
	// Bit mask of P2_1CI field.
	GPIOINT_CLR2_P2_1CI_Msk = 0x2
	// Bit P2_1CI.
	GPIOINT_CLR2_P2_1CI = 0x2
	// Position of P2_2CI field.
	GPIOINT_CLR2_P2_2CI_Pos = 0x2
	// Bit mask of P2_2CI field.
	GPIOINT_CLR2_P2_2CI_Msk = 0x4
	// Bit P2_2CI.
	GPIOINT_CLR2_P2_2CI = 0x4
	// Position of P2_3CI field.
	GPIOINT_CLR2_P2_3CI_Pos = 0x3
	// Bit mask of P2_3CI field.
	GPIOINT_CLR2_P2_3CI_Msk = 0x8
	// Bit P2_3CI.
	GPIOINT_CLR2_P2_3CI = 0x8
	// Position of P2_4CI field.
	GPIOINT_CLR2_P2_4CI_Pos = 0x4
	// Bit mask of P2_4CI field.
	GPIOINT_CLR2_P2_4CI_Msk = 0x10
	// Bit P2_4CI.
	GPIOINT_CLR2_P2_4CI = 0x10
	// Position of P2_5CI field.
	GPIOINT_CLR2_P2_5CI_Pos = 0x5
	// Bit mask of P2_5CI field.
	GPIOINT_CLR2_P2_5CI_Msk = 0x20
	// Bit P2_5CI.
	GPIOINT_CLR2_P2_5CI = 0x20
	// Position of P2_6CI field.
	GPIOINT_CLR2_P2_6CI_Pos = 0x6
	// Bit mask of P2_6CI field.
	GPIOINT_CLR2_P2_6CI_Msk = 0x40
	// Bit P2_6CI.
	GPIOINT_CLR2_P2_6CI = 0x40
	// Position of P2_7CI field.
	GPIOINT_CLR2_P2_7CI_Pos = 0x7
	// Bit mask of P2_7CI field.
	GPIOINT_CLR2_P2_7CI_Msk = 0x80
	// Bit P2_7CI.
	GPIOINT_CLR2_P2_7CI = 0x80
	// Position of P2_8CI field.
	GPIOINT_CLR2_P2_8CI_Pos = 0x8
	// Bit mask of P2_8CI field.
	GPIOINT_CLR2_P2_8CI_Msk = 0x100
	// Bit P2_8CI.
	GPIOINT_CLR2_P2_8CI = 0x100
	// Position of P2_9CI field.
	GPIOINT_CLR2_P2_9CI_Pos = 0x9
	// Bit mask of P2_9CI field.
	GPIOINT_CLR2_P2_9CI_Msk = 0x200
	// Bit P2_9CI.
	GPIOINT_CLR2_P2_9CI = 0x200
	// Position of P2_10CI field.
	GPIOINT_CLR2_P2_10CI_Pos = 0xa
	// Bit mask of P2_10CI field.
	GPIOINT_CLR2_P2_10CI_Msk = 0x400
	// Bit P2_10CI.
	GPIOINT_CLR2_P2_10CI = 0x400
	// Position of P2_11CI field.
	GPIOINT_CLR2_P2_11CI_Pos = 0xb
	// Bit mask of P2_11CI field.
	GPIOINT_CLR2_P2_11CI_Msk = 0x800
	// Bit P2_11CI.
	GPIOINT_CLR2_P2_11CI = 0x800
	// Position of P2_12CI field.
	GPIOINT_CLR2_P2_12CI_Pos = 0xc
	// Bit mask of P2_12CI field.
	GPIOINT_CLR2_P2_12CI_Msk = 0x1000
	// Bit P2_12CI.
	GPIOINT_CLR2_P2_12CI = 0x1000
	// Position of P2_13CI field.
	GPIOINT_CLR2_P2_13CI_Pos = 0xd
	// Bit mask of P2_13CI field.
	GPIOINT_CLR2_P2_13CI_Msk = 0x2000
	// Bit P2_13CI.
	GPIOINT_CLR2_P2_13CI = 0x2000
	// Position of P2_14CI field.
	GPIOINT_CLR2_P2_14CI_Pos = 0xe
	// Bit mask of P2_14CI field.
	GPIOINT_CLR2_P2_14CI_Msk = 0x4000
	// Bit P2_14CI.
	GPIOINT_CLR2_P2_14CI = 0x4000
	// Position of P2_15CI field.
	GPIOINT_CLR2_P2_15CI_Pos = 0xf
	// Bit mask of P2_15CI field.
	GPIOINT_CLR2_P2_15CI_Msk = 0x8000
	// Bit P2_15CI.
	GPIOINT_CLR2_P2_15CI = 0x8000
	// Position of P2_16CI field.
	GPIOINT_CLR2_P2_16CI_Pos = 0x10
	// Bit mask of P2_16CI field.
	GPIOINT_CLR2_P2_16CI_Msk = 0x10000
	// Bit P2_16CI.
	GPIOINT_CLR2_P2_16CI = 0x10000
	// Position of P2_17CI field.
	GPIOINT_CLR2_P2_17CI_Pos = 0x11
	// Bit mask of P2_17CI field.
	GPIOINT_CLR2_P2_17CI_Msk = 0x20000
	// Bit P2_17CI.
	GPIOINT_CLR2_P2_17CI = 0x20000
	// Position of P2_18CI field.
	GPIOINT_CLR2_P2_18CI_Pos = 0x12
	// Bit mask of P2_18CI field.
	GPIOINT_CLR2_P2_18CI_Msk = 0x40000
	// Bit P2_18CI.
	GPIOINT_CLR2_P2_18CI = 0x40000
	// Position of P2_19CI field.
	GPIOINT_CLR2_P2_19CI_Pos = 0x13
	// Bit mask of P2_19CI field.
	GPIOINT_CLR2_P2_19CI_Msk = 0x80000
	// Bit P2_19CI.
	GPIOINT_CLR2_P2_19CI = 0x80000
	// Position of P2_20CI field.
	GPIOINT_CLR2_P2_20CI_Pos = 0x14
	// Bit mask of P2_20CI field.
	GPIOINT_CLR2_P2_20CI_Msk = 0x100000
	// Bit P2_20CI.
	GPIOINT_CLR2_P2_20CI = 0x100000
	// Position of P2_21CI field.
	GPIOINT_CLR2_P2_21CI_Pos = 0x15
	// Bit mask of P2_21CI field.
	GPIOINT_CLR2_P2_21CI_Msk = 0x200000
	// Bit P2_21CI.
	GPIOINT_CLR2_P2_21CI = 0x200000
	// Position of P2_22CI field.
	GPIOINT_CLR2_P2_22CI_Pos = 0x16
	// Bit mask of P2_22CI field.
	GPIOINT_CLR2_P2_22CI_Msk = 0x400000
	// Bit P2_22CI.
	GPIOINT_CLR2_P2_22CI = 0x400000
	// Position of P2_23CI field.
	GPIOINT_CLR2_P2_23CI_Pos = 0x17
	// Bit mask of P2_23CI field.
	GPIOINT_CLR2_P2_23CI_Msk = 0x800000
	// Bit P2_23CI.
	GPIOINT_CLR2_P2_23CI = 0x800000
	// Position of P2_24CI field.
	GPIOINT_CLR2_P2_24CI_Pos = 0x18
	// Bit mask of P2_24CI field.
	GPIOINT_CLR2_P2_24CI_Msk = 0x1000000
	// Bit P2_24CI.
	GPIOINT_CLR2_P2_24CI = 0x1000000
	// Position of P2_25CI field.
	GPIOINT_CLR2_P2_25CI_Pos = 0x19
	// Bit mask of P2_25CI field.
	GPIOINT_CLR2_P2_25CI_Msk = 0x2000000
	// Bit P2_25CI.
	GPIOINT_CLR2_P2_25CI = 0x2000000
	// Position of P2_26CI field.
	GPIOINT_CLR2_P2_26CI_Pos = 0x1a
	// Bit mask of P2_26CI field.
	GPIOINT_CLR2_P2_26CI_Msk = 0x4000000
	// Bit P2_26CI.
	GPIOINT_CLR2_P2_26CI = 0x4000000
	// Position of P2_27CI field.
	GPIOINT_CLR2_P2_27CI_Pos = 0x1b
	// Bit mask of P2_27CI field.
	GPIOINT_CLR2_P2_27CI_Msk = 0x8000000
	// Bit P2_27CI.
	GPIOINT_CLR2_P2_27CI = 0x8000000
	// Position of P2_28CI field.
	GPIOINT_CLR2_P2_28CI_Pos = 0x1c
	// Bit mask of P2_28CI field.
	GPIOINT_CLR2_P2_28CI_Msk = 0x10000000
	// Bit P2_28CI.
	GPIOINT_CLR2_P2_28CI = 0x10000000
	// Position of P2_29CI field.
	GPIOINT_CLR2_P2_29CI_Pos = 0x1d
	// Bit mask of P2_29CI field.
	GPIOINT_CLR2_P2_29CI_Msk = 0x20000000
	// Bit P2_29CI.
	GPIOINT_CLR2_P2_29CI = 0x20000000
	// Position of P2_30CI field.
	GPIOINT_CLR2_P2_30CI_Pos = 0x1e
	// Bit mask of P2_30CI field.
	GPIOINT_CLR2_P2_30CI_Msk = 0x40000000
	// Bit P2_30CI.
	GPIOINT_CLR2_P2_30CI = 0x40000000
	// Position of P2_31CI field.
	GPIOINT_CLR2_P2_31CI_Pos = 0x1f
	// Bit mask of P2_31CI field.
	GPIOINT_CLR2_P2_31CI_Msk = 0x80000000
	// Bit P2_31CI.
	GPIOINT_CLR2_P2_31CI = 0x80000000

	// ENR2: GPIO Interrupt Enable for Rising edge for Port 0.
	// Position of P2_0ER field.
	GPIOINT_ENR2_P2_0ER_Pos = 0x0
	// Bit mask of P2_0ER field.
	GPIOINT_ENR2_P2_0ER_Msk = 0x1
	// Bit P2_0ER.
	GPIOINT_ENR2_P2_0ER = 0x1
	// Position of P2_1ER field.
	GPIOINT_ENR2_P2_1ER_Pos = 0x1
	// Bit mask of P2_1ER field.
	GPIOINT_ENR2_P2_1ER_Msk = 0x2
	// Bit P2_1ER.
	GPIOINT_ENR2_P2_1ER = 0x2
	// Position of P2_2ER field.
	GPIOINT_ENR2_P2_2ER_Pos = 0x2
	// Bit mask of P2_2ER field.
	GPIOINT_ENR2_P2_2ER_Msk = 0x4
	// Bit P2_2ER.
	GPIOINT_ENR2_P2_2ER = 0x4
	// Position of P2_3ER field.
	GPIOINT_ENR2_P2_3ER_Pos = 0x3
	// Bit mask of P2_3ER field.
	GPIOINT_ENR2_P2_3ER_Msk = 0x8
	// Bit P2_3ER.
	GPIOINT_ENR2_P2_3ER = 0x8
	// Position of P2_4ER field.
	GPIOINT_ENR2_P2_4ER_Pos = 0x4
	// Bit mask of P2_4ER field.
	GPIOINT_ENR2_P2_4ER_Msk = 0x10
	// Bit P2_4ER.
	GPIOINT_ENR2_P2_4ER = 0x10
	// Position of P2_5ER field.
	GPIOINT_ENR2_P2_5ER_Pos = 0x5
	// Bit mask of P2_5ER field.
	GPIOINT_ENR2_P2_5ER_Msk = 0x20
	// Bit P2_5ER.
	GPIOINT_ENR2_P2_5ER = 0x20
	// Position of P2_6ER field.
	GPIOINT_ENR2_P2_6ER_Pos = 0x6
	// Bit mask of P2_6ER field.
	GPIOINT_ENR2_P2_6ER_Msk = 0x40
	// Bit P2_6ER.
	GPIOINT_ENR2_P2_6ER = 0x40
	// Position of P2_7ER field.
	GPIOINT_ENR2_P2_7ER_Pos = 0x7
	// Bit mask of P2_7ER field.
	GPIOINT_ENR2_P2_7ER_Msk = 0x80
	// Bit P2_7ER.
	GPIOINT_ENR2_P2_7ER = 0x80
	// Position of P2_8ER field.
	GPIOINT_ENR2_P2_8ER_Pos = 0x8
	// Bit mask of P2_8ER field.
	GPIOINT_ENR2_P2_8ER_Msk = 0x100
	// Bit P2_8ER.
	GPIOINT_ENR2_P2_8ER = 0x100
	// Position of P2_9ER field.
	GPIOINT_ENR2_P2_9ER_Pos = 0x9
	// Bit mask of P2_9ER field.
	GPIOINT_ENR2_P2_9ER_Msk = 0x200
	// Bit P2_9ER.
	GPIOINT_ENR2_P2_9ER = 0x200
	// Position of P2_10ER field.
	GPIOINT_ENR2_P2_10ER_Pos = 0xa
	// Bit mask of P2_10ER field.
	GPIOINT_ENR2_P2_10ER_Msk = 0x400
	// Bit P2_10ER.
	GPIOINT_ENR2_P2_10ER = 0x400
	// Position of P2_11ER field.
	GPIOINT_ENR2_P2_11ER_Pos = 0xb
	// Bit mask of P2_11ER field.
	GPIOINT_ENR2_P2_11ER_Msk = 0x800
	// Bit P2_11ER.
	GPIOINT_ENR2_P2_11ER = 0x800
	// Position of P2_12ER field.
	GPIOINT_ENR2_P2_12ER_Pos = 0xc
	// Bit mask of P2_12ER field.
	GPIOINT_ENR2_P2_12ER_Msk = 0x1000
	// Bit P2_12ER.
	GPIOINT_ENR2_P2_12ER = 0x1000
	// Position of P2_13ER field.
	GPIOINT_ENR2_P2_13ER_Pos = 0xd
	// Bit mask of P2_13ER field.
	GPIOINT_ENR2_P2_13ER_Msk = 0x2000
	// Bit P2_13ER.
	GPIOINT_ENR2_P2_13ER = 0x2000
	// Position of P2_14ER field.
	GPIOINT_ENR2_P2_14ER_Pos = 0xe
	// Bit mask of P2_14ER field.
	GPIOINT_ENR2_P2_14ER_Msk = 0x4000
	// Bit P2_14ER.
	GPIOINT_ENR2_P2_14ER = 0x4000
	// Position of P2_15ER field.
	GPIOINT_ENR2_P2_15ER_Pos = 0xf
	// Bit mask of P2_15ER field.
	GPIOINT_ENR2_P2_15ER_Msk = 0x8000
	// Bit P2_15ER.
	GPIOINT_ENR2_P2_15ER = 0x8000
	// Position of P2_16ER field.
	GPIOINT_ENR2_P2_16ER_Pos = 0x10
	// Bit mask of P2_16ER field.
	GPIOINT_ENR2_P2_16ER_Msk = 0x10000
	// Bit P2_16ER.
	GPIOINT_ENR2_P2_16ER = 0x10000
	// Position of P2_17ER field.
	GPIOINT_ENR2_P2_17ER_Pos = 0x11
	// Bit mask of P2_17ER field.
	GPIOINT_ENR2_P2_17ER_Msk = 0x20000
	// Bit P2_17ER.
	GPIOINT_ENR2_P2_17ER = 0x20000
	// Position of P2_18ER field.
	GPIOINT_ENR2_P2_18ER_Pos = 0x12
	// Bit mask of P2_18ER field.
	GPIOINT_ENR2_P2_18ER_Msk = 0x40000
	// Bit P2_18ER.
	GPIOINT_ENR2_P2_18ER = 0x40000
	// Position of P2_19ER field.
	GPIOINT_ENR2_P2_19ER_Pos = 0x13
	// Bit mask of P2_19ER field.
	GPIOINT_ENR2_P2_19ER_Msk = 0x80000
	// Bit P2_19ER.
	GPIOINT_ENR2_P2_19ER = 0x80000
	// Position of P2_20ER field.
	GPIOINT_ENR2_P2_20ER_Pos = 0x14
	// Bit mask of P2_20ER field.
	GPIOINT_ENR2_P2_20ER_Msk = 0x100000
	// Bit P2_20ER.
	GPIOINT_ENR2_P2_20ER = 0x100000
	// Position of P2_21ER field.
	GPIOINT_ENR2_P2_21ER_Pos = 0x15
	// Bit mask of P2_21ER field.
	GPIOINT_ENR2_P2_21ER_Msk = 0x200000
	// Bit P2_21ER.
	GPIOINT_ENR2_P2_21ER = 0x200000
	// Position of P2_22ER field.
	GPIOINT_ENR2_P2_22ER_Pos = 0x16
	// Bit mask of P2_22ER field.
	GPIOINT_ENR2_P2_22ER_Msk = 0x400000
	// Bit P2_22ER.
	GPIOINT_ENR2_P2_22ER = 0x400000
	// Position of P2_23ER field.
	GPIOINT_ENR2_P2_23ER_Pos = 0x17
	// Bit mask of P2_23ER field.
	GPIOINT_ENR2_P2_23ER_Msk = 0x800000
	// Bit P2_23ER.
	GPIOINT_ENR2_P2_23ER = 0x800000
	// Position of P2_24ER field.
	GPIOINT_ENR2_P2_24ER_Pos = 0x18
	// Bit mask of P2_24ER field.
	GPIOINT_ENR2_P2_24ER_Msk = 0x1000000
	// Bit P2_24ER.
	GPIOINT_ENR2_P2_24ER = 0x1000000
	// Position of P2_25ER field.
	GPIOINT_ENR2_P2_25ER_Pos = 0x19
	// Bit mask of P2_25ER field.
	GPIOINT_ENR2_P2_25ER_Msk = 0x2000000
	// Bit P2_25ER.
	GPIOINT_ENR2_P2_25ER = 0x2000000
	// Position of P2_26ER field.
	GPIOINT_ENR2_P2_26ER_Pos = 0x1a
	// Bit mask of P2_26ER field.
	GPIOINT_ENR2_P2_26ER_Msk = 0x4000000
	// Bit P2_26ER.
	GPIOINT_ENR2_P2_26ER = 0x4000000
	// Position of P2_27ER field.
	GPIOINT_ENR2_P2_27ER_Pos = 0x1b
	// Bit mask of P2_27ER field.
	GPIOINT_ENR2_P2_27ER_Msk = 0x8000000
	// Bit P2_27ER.
	GPIOINT_ENR2_P2_27ER = 0x8000000
	// Position of P2_28ER field.
	GPIOINT_ENR2_P2_28ER_Pos = 0x1c
	// Bit mask of P2_28ER field.
	GPIOINT_ENR2_P2_28ER_Msk = 0x10000000
	// Bit P2_28ER.
	GPIOINT_ENR2_P2_28ER = 0x10000000
	// Position of P2_29ER field.
	GPIOINT_ENR2_P2_29ER_Pos = 0x1d
	// Bit mask of P2_29ER field.
	GPIOINT_ENR2_P2_29ER_Msk = 0x20000000
	// Bit P2_29ER.
	GPIOINT_ENR2_P2_29ER = 0x20000000
	// Position of P2_30ER field.
	GPIOINT_ENR2_P2_30ER_Pos = 0x1e
	// Bit mask of P2_30ER field.
	GPIOINT_ENR2_P2_30ER_Msk = 0x40000000
	// Bit P2_30ER.
	GPIOINT_ENR2_P2_30ER = 0x40000000
	// Position of P2_31ER field.
	GPIOINT_ENR2_P2_31ER_Pos = 0x1f
	// Bit mask of P2_31ER field.
	GPIOINT_ENR2_P2_31ER_Msk = 0x80000000
	// Bit P2_31ER.
	GPIOINT_ENR2_P2_31ER = 0x80000000

	// ENF2: GPIO Interrupt Enable for Falling edge for Port 0.
	// Position of P2_0EF field.
	GPIOINT_ENF2_P2_0EF_Pos = 0x0
	// Bit mask of P2_0EF field.
	GPIOINT_ENF2_P2_0EF_Msk = 0x1
	// Bit P2_0EF.
	GPIOINT_ENF2_P2_0EF = 0x1
	// Position of P2_1EF field.
	GPIOINT_ENF2_P2_1EF_Pos = 0x1
	// Bit mask of P2_1EF field.
	GPIOINT_ENF2_P2_1EF_Msk = 0x2
	// Bit P2_1EF.
	GPIOINT_ENF2_P2_1EF = 0x2
	// Position of P2_2EF field.
	GPIOINT_ENF2_P2_2EF_Pos = 0x2
	// Bit mask of P2_2EF field.
	GPIOINT_ENF2_P2_2EF_Msk = 0x4
	// Bit P2_2EF.
	GPIOINT_ENF2_P2_2EF = 0x4
	// Position of P2_3EF field.
	GPIOINT_ENF2_P2_3EF_Pos = 0x3
	// Bit mask of P2_3EF field.
	GPIOINT_ENF2_P2_3EF_Msk = 0x8
	// Bit P2_3EF.
	GPIOINT_ENF2_P2_3EF = 0x8
	// Position of P2_4EF field.
	GPIOINT_ENF2_P2_4EF_Pos = 0x4
	// Bit mask of P2_4EF field.
	GPIOINT_ENF2_P2_4EF_Msk = 0x10
	// Bit P2_4EF.
	GPIOINT_ENF2_P2_4EF = 0x10
	// Position of P2_5EF field.
	GPIOINT_ENF2_P2_5EF_Pos = 0x5
	// Bit mask of P2_5EF field.
	GPIOINT_ENF2_P2_5EF_Msk = 0x20
	// Bit P2_5EF.
	GPIOINT_ENF2_P2_5EF = 0x20
	// Position of P2_6EF field.
	GPIOINT_ENF2_P2_6EF_Pos = 0x6
	// Bit mask of P2_6EF field.
	GPIOINT_ENF2_P2_6EF_Msk = 0x40
	// Bit P2_6EF.
	GPIOINT_ENF2_P2_6EF = 0x40
	// Position of P2_7EF field.
	GPIOINT_ENF2_P2_7EF_Pos = 0x7
	// Bit mask of P2_7EF field.
	GPIOINT_ENF2_P2_7EF_Msk = 0x80
	// Bit P2_7EF.
	GPIOINT_ENF2_P2_7EF = 0x80
	// Position of P2_8EF field.
	GPIOINT_ENF2_P2_8EF_Pos = 0x8
	// Bit mask of P2_8EF field.
	GPIOINT_ENF2_P2_8EF_Msk = 0x100
	// Bit P2_8EF.
	GPIOINT_ENF2_P2_8EF = 0x100
	// Position of P2_9EF field.
	GPIOINT_ENF2_P2_9EF_Pos = 0x9
	// Bit mask of P2_9EF field.
	GPIOINT_ENF2_P2_9EF_Msk = 0x200
	// Bit P2_9EF.
	GPIOINT_ENF2_P2_9EF = 0x200
	// Position of P2_10EF field.
	GPIOINT_ENF2_P2_10EF_Pos = 0xa
	// Bit mask of P2_10EF field.
	GPIOINT_ENF2_P2_10EF_Msk = 0x400
	// Bit P2_10EF.
	GPIOINT_ENF2_P2_10EF = 0x400
	// Position of P2_11EF field.
	GPIOINT_ENF2_P2_11EF_Pos = 0xb
	// Bit mask of P2_11EF field.
	GPIOINT_ENF2_P2_11EF_Msk = 0x800
	// Bit P2_11EF.
	GPIOINT_ENF2_P2_11EF = 0x800
	// Position of P2_12EF field.
	GPIOINT_ENF2_P2_12EF_Pos = 0xc
	// Bit mask of P2_12EF field.
	GPIOINT_ENF2_P2_12EF_Msk = 0x1000
	// Bit P2_12EF.
	GPIOINT_ENF2_P2_12EF = 0x1000
	// Position of P2_13EF field.
	GPIOINT_ENF2_P2_13EF_Pos = 0xd
	// Bit mask of P2_13EF field.
	GPIOINT_ENF2_P2_13EF_Msk = 0x2000
	// Bit P2_13EF.
	GPIOINT_ENF2_P2_13EF = 0x2000
	// Position of P2_14EF field.
	GPIOINT_ENF2_P2_14EF_Pos = 0xe
	// Bit mask of P2_14EF field.
	GPIOINT_ENF2_P2_14EF_Msk = 0x4000
	// Bit P2_14EF.
	GPIOINT_ENF2_P2_14EF = 0x4000
	// Position of P2_15EF field.
	GPIOINT_ENF2_P2_15EF_Pos = 0xf
	// Bit mask of P2_15EF field.
	GPIOINT_ENF2_P2_15EF_Msk = 0x8000
	// Bit P2_15EF.
	GPIOINT_ENF2_P2_15EF = 0x8000
	// Position of P2_16EF field.
	GPIOINT_ENF2_P2_16EF_Pos = 0x10
	// Bit mask of P2_16EF field.
	GPIOINT_ENF2_P2_16EF_Msk = 0x10000
	// Bit P2_16EF.
	GPIOINT_ENF2_P2_16EF = 0x10000
	// Position of P2_17EF field.
	GPIOINT_ENF2_P2_17EF_Pos = 0x11
	// Bit mask of P2_17EF field.
	GPIOINT_ENF2_P2_17EF_Msk = 0x20000
	// Bit P2_17EF.
	GPIOINT_ENF2_P2_17EF = 0x20000
	// Position of P2_18EF field.
	GPIOINT_ENF2_P2_18EF_Pos = 0x12
	// Bit mask of P2_18EF field.
	GPIOINT_ENF2_P2_18EF_Msk = 0x40000
	// Bit P2_18EF.
	GPIOINT_ENF2_P2_18EF = 0x40000
	// Position of P2_19EF field.
	GPIOINT_ENF2_P2_19EF_Pos = 0x13
	// Bit mask of P2_19EF field.
	GPIOINT_ENF2_P2_19EF_Msk = 0x80000
	// Bit P2_19EF.
	GPIOINT_ENF2_P2_19EF = 0x80000
	// Position of P2_20EF field.
	GPIOINT_ENF2_P2_20EF_Pos = 0x14
	// Bit mask of P2_20EF field.
	GPIOINT_ENF2_P2_20EF_Msk = 0x100000
	// Bit P2_20EF.
	GPIOINT_ENF2_P2_20EF = 0x100000
	// Position of P2_21EF field.
	GPIOINT_ENF2_P2_21EF_Pos = 0x15
	// Bit mask of P2_21EF field.
	GPIOINT_ENF2_P2_21EF_Msk = 0x200000
	// Bit P2_21EF.
	GPIOINT_ENF2_P2_21EF = 0x200000
	// Position of P2_22EF field.
	GPIOINT_ENF2_P2_22EF_Pos = 0x16
	// Bit mask of P2_22EF field.
	GPIOINT_ENF2_P2_22EF_Msk = 0x400000
	// Bit P2_22EF.
	GPIOINT_ENF2_P2_22EF = 0x400000
	// Position of P2_23EF field.
	GPIOINT_ENF2_P2_23EF_Pos = 0x17
	// Bit mask of P2_23EF field.
	GPIOINT_ENF2_P2_23EF_Msk = 0x800000
	// Bit P2_23EF.
	GPIOINT_ENF2_P2_23EF = 0x800000
	// Position of P2_24EF field.
	GPIOINT_ENF2_P2_24EF_Pos = 0x18
	// Bit mask of P2_24EF field.
	GPIOINT_ENF2_P2_24EF_Msk = 0x1000000
	// Bit P2_24EF.
	GPIOINT_ENF2_P2_24EF = 0x1000000
	// Position of P2_25EF field.
	GPIOINT_ENF2_P2_25EF_Pos = 0x19
	// Bit mask of P2_25EF field.
	GPIOINT_ENF2_P2_25EF_Msk = 0x2000000
	// Bit P2_25EF.
	GPIOINT_ENF2_P2_25EF = 0x2000000
	// Position of P2_26EF field.
	GPIOINT_ENF2_P2_26EF_Pos = 0x1a
	// Bit mask of P2_26EF field.
	GPIOINT_ENF2_P2_26EF_Msk = 0x4000000
	// Bit P2_26EF.
	GPIOINT_ENF2_P2_26EF = 0x4000000
	// Position of P2_27EF field.
	GPIOINT_ENF2_P2_27EF_Pos = 0x1b
	// Bit mask of P2_27EF field.
	GPIOINT_ENF2_P2_27EF_Msk = 0x8000000
	// Bit P2_27EF.
	GPIOINT_ENF2_P2_27EF = 0x8000000
	// Position of P2_28EF field.
	GPIOINT_ENF2_P2_28EF_Pos = 0x1c
	// Bit mask of P2_28EF field.
	GPIOINT_ENF2_P2_28EF_Msk = 0x10000000
	// Bit P2_28EF.
	GPIOINT_ENF2_P2_28EF = 0x10000000
	// Position of P2_29EF field.
	GPIOINT_ENF2_P2_29EF_Pos = 0x1d
	// Bit mask of P2_29EF field.
	GPIOINT_ENF2_P2_29EF_Msk = 0x20000000
	// Bit P2_29EF.
	GPIOINT_ENF2_P2_29EF = 0x20000000
	// Position of P2_30EF field.
	GPIOINT_ENF2_P2_30EF_Pos = 0x1e
	// Bit mask of P2_30EF field.
	GPIOINT_ENF2_P2_30EF_Msk = 0x40000000
	// Bit P2_30EF.
	GPIOINT_ENF2_P2_30EF = 0x40000000
	// Position of P2_31EF field.
	GPIOINT_ENF2_P2_31EF_Pos = 0x1f
	// Bit mask of P2_31EF field.
	GPIOINT_ENF2_P2_31EF_Msk = 0x80000000
	// Bit P2_31EF.
	GPIOINT_ENF2_P2_31EF = 0x80000000
)

// Constants for IOCON: IOCON pin configuration
const (
	// P0_0: I/O configuration register for pin P0[0]
	// Position of FUNC field.
	IOCON_P0_0_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_0_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_0_FUNC_P0_0 = 0x0
	// CAN1 receiver input.
	IOCON_P0_0_FUNC_CAN_RD1 = 0x1
	// Transmitter output for UART3.
	IOCON_P0_0_FUNC_U3_TXD = 0x2
	// I2C1 data input/output (this pin does not use a specialized I2C pad).
	IOCON_P0_0_FUNC_I2C1_SDA = 0x3
	// Transmitter output for UART0.
	IOCON_P0_0_FUNC_U0_TXD = 0x4
	// Position of MODE field.
	IOCON_P0_0_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P0_0_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P0_0_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P0_0_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P0_0_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P0_0_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P0_0_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P0_0_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P0_0_HYS = 0x20
	// Disable.
	IOCON_P0_0_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P0_0_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P0_0_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P0_0_INV_Msk = 0x40
	// Bit INV.
	IOCON_P0_0_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P0_0_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P0_0_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P0_0_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P0_0_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P0_0_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P0_0_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P0_0_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P0_0_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P0_0_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P0_0_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P0_0_OD_Msk = 0x400
	// Bit OD.
	IOCON_P0_0_OD = 0x400
	// Disable.
	IOCON_P0_0_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P0_0_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P0_0_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P0_0_RESERVED_Msk = 0xfffff800

	// P0_1: I/O configuration register for pin P0[1]
	// Position of FUNC field.
	IOCON_P0_1_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_1_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_1_FUNC_P0_1 = 0x0
	// CAN1 transmitter output.
	IOCON_P0_1_FUNC_CAN_TD1 = 0x1
	// Receiver input for UART3.
	IOCON_P0_1_FUNC_U3_RXD = 0x2
	// I2C1 clock input/output (this pin does not use a specialized I2C pad).
	IOCON_P0_1_FUNC_I2C1_SCL = 0x3
	// Receiver input for UART0.
	IOCON_P0_1_FUNC_U0_RXD = 0x4
	// Position of MODE field.
	IOCON_P0_1_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P0_1_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P0_1_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P0_1_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P0_1_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P0_1_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P0_1_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P0_1_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P0_1_HYS = 0x20
	// Disable.
	IOCON_P0_1_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P0_1_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P0_1_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P0_1_INV_Msk = 0x40
	// Bit INV.
	IOCON_P0_1_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P0_1_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P0_1_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P0_1_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P0_1_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P0_1_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P0_1_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P0_1_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P0_1_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P0_1_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P0_1_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P0_1_OD_Msk = 0x400
	// Bit OD.
	IOCON_P0_1_OD = 0x400
	// Disable.
	IOCON_P0_1_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P0_1_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P0_1_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P0_1_RESERVED_Msk = 0xfffff800

	// P0_2: I/O configuration register for pin P0[2]
	// Position of FUNC field.
	IOCON_P0_2_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_2_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_2_FUNC_P0_2 = 0x0
	// Transmitter output for UART0.
	IOCON_P0_2_FUNC_U0_TXD = 0x1
	// Transmitter output for UART3.
	IOCON_P0_2_FUNC_U3_TXD = 0x2
	// Position of MODE field.
	IOCON_P0_2_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P0_2_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P0_2_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P0_2_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P0_2_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P0_2_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P0_2_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P0_2_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P0_2_HYS = 0x20
	// Disable.
	IOCON_P0_2_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P0_2_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P0_2_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P0_2_INV_Msk = 0x40
	// Bit INV.
	IOCON_P0_2_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P0_2_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P0_2_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P0_2_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P0_2_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P0_2_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P0_2_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P0_2_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P0_2_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P0_2_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P0_2_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P0_2_OD_Msk = 0x400
	// Bit OD.
	IOCON_P0_2_OD = 0x400
	// Disable.
	IOCON_P0_2_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P0_2_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P0_2_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P0_2_RESERVED_Msk = 0xfffff800

	// P0_3: I/O configuration register for pin P0[3]
	// Position of FUNC field.
	IOCON_P0_3_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_3_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_3_FUNC_P0_3 = 0x0
	// Receiver input for UART0.
	IOCON_P0_3_FUNC_U0_RXD = 0x1
	// Receiver input for UART3.
	IOCON_P0_3_FUNC_U3_RXD = 0x2
	// Position of MODE field.
	IOCON_P0_3_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P0_3_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P0_3_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P0_3_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P0_3_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P0_3_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P0_3_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P0_3_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P0_3_HYS = 0x20
	// Disable.
	IOCON_P0_3_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P0_3_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P0_3_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P0_3_INV_Msk = 0x40
	// Bit INV.
	IOCON_P0_3_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P0_3_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P0_3_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P0_3_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P0_3_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P0_3_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P0_3_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P0_3_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P0_3_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P0_3_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P0_3_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P0_3_OD_Msk = 0x400
	// Bit OD.
	IOCON_P0_3_OD = 0x400
	// Disable.
	IOCON_P0_3_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P0_3_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P0_3_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P0_3_RESERVED_Msk = 0xfffff800

	// P0_4: I/O configuration register for pin P0[4]
	// Position of FUNC field.
	IOCON_P0_4_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_4_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_4_FUNC_P0_4 = 0x0
	// I2S Receive clock. It is driven by the master and received by the slave. Corresponds to the signal SCK in the I2S-bus specification.
	IOCON_P0_4_FUNC_I2S_RX_SCK = 0x1
	// CAN2 receiver input.
	IOCON_P0_4_FUNC_CAN_RD2 = 0x2
	// Capture input for Timer 2, channel 0.
	IOCON_P0_4_FUNC_T2_CAP0 = 0x3
	// Comparator relaxation oscillator for 555 timer applications.
	IOCON_P0_4_FUNC_CMP_ROSC = 0x5
	// LCD data.
	IOCON_P0_4_FUNC_LCD_VD_0 = 0x7
	// Position of MODE field.
	IOCON_P0_4_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P0_4_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P0_4_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P0_4_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P0_4_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P0_4_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P0_4_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P0_4_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P0_4_HYS = 0x20
	// Disable.
	IOCON_P0_4_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P0_4_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P0_4_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P0_4_INV_Msk = 0x40
	// Bit INV.
	IOCON_P0_4_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P0_4_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P0_4_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P0_4_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P0_4_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P0_4_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P0_4_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P0_4_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P0_4_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P0_4_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P0_4_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P0_4_OD_Msk = 0x400
	// Bit OD.
	IOCON_P0_4_OD = 0x400
	// Disable.
	IOCON_P0_4_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P0_4_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P0_4_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P0_4_RESERVED_Msk = 0xfffff800

	// P0_5: I/O configuration register for pin P0[5]
	// Position of FUNC field.
	IOCON_P0_5_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_5_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_5_FUNC_P0_5 = 0x0
	// I2S Receive word select. It is driven by the master and received by the slave. Corresponds to the signal WS in the I2S-bus specification.
	IOCON_P0_5_FUNC_I2S_RX_WS = 0x1
	// CAN2 transmitter output.
	IOCON_P0_5_FUNC_CAN_TD2 = 0x2
	// Capture input for Timer 2, channel 1.
	IOCON_P0_5_FUNC_T2_CAP1 = 0x3
	// Comparator reset.
	IOCON_P0_5_FUNC_CMP_RESET = 0x5
	// LCD data.
	IOCON_P0_5_FUNC_LCD_VD_1 = 0x7
	// Position of MODE field.
	IOCON_P0_5_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P0_5_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P0_5_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P0_5_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P0_5_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P0_5_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P0_5_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P0_5_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P0_5_HYS = 0x20
	// Disable.
	IOCON_P0_5_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P0_5_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P0_5_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P0_5_INV_Msk = 0x40
	// Bit INV.
	IOCON_P0_5_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P0_5_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P0_5_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P0_5_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P0_5_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P0_5_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P0_5_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P0_5_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P0_5_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P0_5_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P0_5_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P0_5_OD_Msk = 0x400
	// Bit OD.
	IOCON_P0_5_OD = 0x400
	// Disable.
	IOCON_P0_5_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P0_5_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P0_5_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P0_5_RESERVED_Msk = 0xfffff800

	// P0_6: I/O configuration register for pin P0[6]
	// Position of FUNC field.
	IOCON_P0_6_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_6_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_6_FUNC_P0_6 = 0x0
	// I2S Receive data. It is driven by the transmitter and read by the receiver. Corresponds to the signal SD in the I2S-bus specification.
	IOCON_P0_6_FUNC_I2S_RX_SDA = 0x1
	// Slave Select for SSP1.
	IOCON_P0_6_FUNC_SSP1_SSEL = 0x2
	// Match output for Timer 2, channel 0.
	IOCON_P0_6_FUNC_T2_MAT0 = 0x3
	// Request to Send output for UART1. Can also be configured to be an RS-485/EIA-485 output enable signal for UART1.
	IOCON_P0_6_FUNC_U1_RTS = 0x4
	// Comparator relaxation oscillator for 555 timer applications.
	IOCON_P0_6_FUNC_CMP_ROSC = 0x5
	// LCD data.
	IOCON_P0_6_FUNC_LCD_VD_8 = 0x7
	// Position of MODE field.
	IOCON_P0_6_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P0_6_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P0_6_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P0_6_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P0_6_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P0_6_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P0_6_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P0_6_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P0_6_HYS = 0x20
	// Disable.
	IOCON_P0_6_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P0_6_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P0_6_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P0_6_INV_Msk = 0x40
	// Bit INV.
	IOCON_P0_6_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P0_6_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P0_6_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P0_6_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P0_6_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P0_6_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P0_6_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P0_6_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P0_6_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P0_6_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P0_6_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P0_6_OD_Msk = 0x400
	// Bit OD.
	IOCON_P0_6_OD = 0x400
	// Disable.
	IOCON_P0_6_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P0_6_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P0_6_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P0_6_RESERVED_Msk = 0xfffff800

	// P0_7: I/O configuration register for pin P0[7]
	// Position of FUNC field.
	IOCON_P0_7_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_7_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_7_FUNC_P0_7 = 0x0
	// I2S transmit clock. It is driven by the master and received by the slave. Corresponds to the signal SCK in the I2S-bus specification.
	IOCON_P0_7_FUNC_I2S_TX_SCK = 0x1
	// Serial Clock for SSP1.
	IOCON_P0_7_FUNC_SSP1_SCK = 0x2
	// Match output for Timer 2, channel 1.
	IOCON_P0_7_FUNC_T2_MAT1 = 0x3
	// Event input 0 to Event Monitor/Recorder.
	IOCON_P0_7_FUNC_RTC_EV0 = 0x4
	// Comparator reference voltage.
	IOCON_P0_7_FUNC_CMP_VREF = 0x5
	// LCD data.
	IOCON_P0_7_FUNC_LCD_VD_9 = 0x7
	// Position of MODE field.
	IOCON_P0_7_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P0_7_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P0_7_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P0_7_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P0_7_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P0_7_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P0_7_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P0_7_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P0_7_HYS = 0x20
	// Disable.
	IOCON_P0_7_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P0_7_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P0_7_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P0_7_INV_Msk = 0x40
	// Bit INV.
	IOCON_P0_7_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P0_7_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P0_7_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P0_7_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P0_7_RESERVED_Msk = 0x80
	// Bit RESERVED.
	IOCON_P0_7_RESERVED = 0x80
	// Position of FILTER field.
	IOCON_P0_7_FILTER_Pos = 0x8
	// Bit mask of FILTER field.
	IOCON_P0_7_FILTER_Msk = 0x100
	// Bit FILTER.
	IOCON_P0_7_FILTER = 0x100
	// Noise pulses below approximately 10 ns are filtered out.
	IOCON_P0_7_FILTER_ENABLED = 0x0
	// No input filtering is done.
	IOCON_P0_7_FILTER_DISABLED = 0x1
	// Position of SLEW field.
	IOCON_P0_7_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P0_7_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P0_7_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P0_7_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P0_7_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P0_7_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P0_7_OD_Msk = 0x400
	// Bit OD.
	IOCON_P0_7_OD = 0x400
	// Disable.
	IOCON_P0_7_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P0_7_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P0_7_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P0_7_RESERVED_Msk = 0xfffff800

	// P0_8: I/O configuration register for pin P0[8]
	// Position of FUNC field.
	IOCON_P0_8_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_8_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_8_FUNC_P0_8 = 0x0
	// I2S Transmit word select. It is driven by the master and received by the slave. Corresponds to the signal WS in the I2S-bus specification.
	IOCON_P0_8_FUNC_I2S_TX_WS = 0x1
	// Master In Slave Out for SSP1.
	IOCON_P0_8_FUNC_SSP1_MISO = 0x2
	// Match output for Timer 2, channel 2.
	IOCON_P0_8_FUNC_T2_MAT2 = 0x3
	// Event input 1 to Event Monitor/Recorder.
	IOCON_P0_8_FUNC_RTC_EV1 = 0x4
	// Comparator 1, input 3.
	IOCON_P0_8_FUNC_CMP1_IN_3 = 0x5
	// LCD data.
	IOCON_P0_8_FUNC_LCD_VD_16 = 0x7
	// Position of MODE field.
	IOCON_P0_8_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P0_8_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P0_8_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P0_8_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P0_8_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P0_8_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P0_8_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P0_8_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P0_8_HYS = 0x20
	// Disable.
	IOCON_P0_8_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P0_8_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P0_8_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P0_8_INV_Msk = 0x40
	// Bit INV.
	IOCON_P0_8_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P0_8_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P0_8_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P0_8_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P0_8_RESERVED_Msk = 0x80
	// Bit RESERVED.
	IOCON_P0_8_RESERVED = 0x80
	// Position of FILTER field.
	IOCON_P0_8_FILTER_Pos = 0x8
	// Bit mask of FILTER field.
	IOCON_P0_8_FILTER_Msk = 0x100
	// Bit FILTER.
	IOCON_P0_8_FILTER = 0x100
	// Noise pulses below approximately 10 ns are filtered out.
	IOCON_P0_8_FILTER_ENABLED = 0x0
	// No input filtering is done.
	IOCON_P0_8_FILTER_DISABLED = 0x1
	// Position of SLEW field.
	IOCON_P0_8_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P0_8_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P0_8_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P0_8_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P0_8_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P0_8_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P0_8_OD_Msk = 0x400
	// Bit OD.
	IOCON_P0_8_OD = 0x400
	// Disable.
	IOCON_P0_8_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P0_8_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P0_8_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P0_8_RESERVED_Msk = 0xfffff800

	// P0_9: I/O configuration register for pin P0[9]
	// Position of FUNC field.
	IOCON_P0_9_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_9_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_9_FUNC_P0_9 = 0x0
	// I2S transmit data. It is driven by the transmitter and read by the receiver. Corresponds to the signal SD in the I2S-bus specification.
	IOCON_P0_9_FUNC_I2S_TX_SDA = 0x1
	// Master Out Slave In for SSP1.
	IOCON_P0_9_FUNC_SSP1_MOSI = 0x2
	// Match output for Timer 2, channel 3.
	IOCON_P0_9_FUNC_T2_MAT3 = 0x3
	// Event input 2 to Event Monitor/Recorder.
	IOCON_P0_9_FUNC_RTC_EV2 = 0x4
	// Comparator 1, input 2.
	IOCON_P0_9_FUNC_CMP1_IN_2 = 0x5
	// LCD data.
	IOCON_P0_9_FUNC_LCD_VD_17 = 0x7
	// Position of MODE field.
	IOCON_P0_9_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P0_9_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P0_9_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P0_9_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P0_9_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P0_9_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P0_9_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P0_9_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P0_9_HYS = 0x20
	// Disable.
	IOCON_P0_9_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P0_9_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P0_9_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P0_9_INV_Msk = 0x40
	// Bit INV.
	IOCON_P0_9_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P0_9_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P0_9_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P0_9_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P0_9_RESERVED_Msk = 0x80
	// Bit RESERVED.
	IOCON_P0_9_RESERVED = 0x80
	// Position of FILTER field.
	IOCON_P0_9_FILTER_Pos = 0x8
	// Bit mask of FILTER field.
	IOCON_P0_9_FILTER_Msk = 0x100
	// Bit FILTER.
	IOCON_P0_9_FILTER = 0x100
	// Noise pulses below approximately 10 ns are filtered out.
	IOCON_P0_9_FILTER_ENABLED = 0x0
	// No input filtering is done.
	IOCON_P0_9_FILTER_DISABLED = 0x1
	// Position of SLEW field.
	IOCON_P0_9_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P0_9_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P0_9_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P0_9_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P0_9_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P0_9_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P0_9_OD_Msk = 0x400
	// Bit OD.
	IOCON_P0_9_OD = 0x400
	// Disable.
	IOCON_P0_9_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P0_9_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P0_9_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P0_9_RESERVED_Msk = 0xfffff800

	// P0_10: I/O configuration register for pin P0[10]
	// Position of FUNC field.
	IOCON_P0_10_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_10_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_10_FUNC_P0_10 = 0x0
	// Transmitter output for UART2.
	IOCON_P0_10_FUNC_U2_TXD = 0x1
	// I2C2 data input/output (this pin does not use a specialized I2C pad).
	IOCON_P0_10_FUNC_I2C2_SDA = 0x2
	// Match output for Timer 3, channel 0.
	IOCON_P0_10_FUNC_T3_MAT0 = 0x3
	// LCD data.
	IOCON_P0_10_FUNC_LCD_VD_5 = 0x7
	// Position of MODE field.
	IOCON_P0_10_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P0_10_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P0_10_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P0_10_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P0_10_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P0_10_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P0_10_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P0_10_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P0_10_HYS = 0x20
	// Disable.
	IOCON_P0_10_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P0_10_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P0_10_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P0_10_INV_Msk = 0x40
	// Bit INV.
	IOCON_P0_10_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P0_10_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P0_10_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P0_10_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P0_10_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P0_10_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P0_10_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P0_10_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P0_10_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P0_10_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P0_10_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P0_10_OD_Msk = 0x400
	// Bit OD.
	IOCON_P0_10_OD = 0x400
	// Disable.
	IOCON_P0_10_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P0_10_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P0_10_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P0_10_RESERVED_Msk = 0xfffff800

	// P0_11: I/O configuration register for pin P0[11]
	// Position of FUNC field.
	IOCON_P0_11_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_11_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_11_FUNC_P0_11 = 0x0
	// Receiver input for UART2.
	IOCON_P0_11_FUNC_U2_RXD = 0x1
	// I2C2 clock input/output (this pin does not use a specialized I2C pad).
	IOCON_P0_11_FUNC_I2C2_SCL = 0x2
	// Match output for Timer 3, channel 1.
	IOCON_P0_11_FUNC_T3_MAT1 = 0x3
	// LCD data.
	IOCON_P0_11_FUNC_LCD_VD_10 = 0x7
	// Position of MODE field.
	IOCON_P0_11_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P0_11_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P0_11_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P0_11_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P0_11_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P0_11_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P0_11_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P0_11_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P0_11_HYS = 0x20
	// Disable.
	IOCON_P0_11_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P0_11_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P0_11_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P0_11_INV_Msk = 0x40
	// Bit INV.
	IOCON_P0_11_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P0_11_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P0_11_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P0_11_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P0_11_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P0_11_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P0_11_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P0_11_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P0_11_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P0_11_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P0_11_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P0_11_OD_Msk = 0x400
	// Bit OD.
	IOCON_P0_11_OD = 0x400
	// Disable.
	IOCON_P0_11_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P0_11_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P0_11_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P0_11_RESERVED_Msk = 0xfffff800

	// P0_12: I/O configuration register for pin P0[12]
	// Position of FUNC field.
	IOCON_P0_12_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_12_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_12_FUNC_P0_12 = 0x0
	// Port Power enable signal for USB port 2.
	IOCON_P0_12_FUNC_USB_PPWR2 = 0x1
	// Master In Slave Out for SSP1.
	IOCON_P0_12_FUNC_SSP1_MISO = 0x2
	// A/D converter 0, input 6. When configured as an ADC input, the digital function of the pin must be disabled.
	IOCON_P0_12_FUNC_ADC0_IN_6 = 0x3

	// P0_13: I/O configuration register for pin P0[13]
	// Position of FUNC field.
	IOCON_P0_13_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_13_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_13_FUNC_P0_13 = 0x0
	// USB port 2 GoodLink LED indicator. It is LOW when the device is configured (non-control endpoints enabled), or when the host is enabled and has detected a device on the bus. It is HIGH when the device is not configured, or when host is enabled and has not detected a device on the bus, or during global suspend. It transitions between LOW and HIGH (flashes) when the host is enabled and detects activity on the bus.
	IOCON_P0_13_FUNC_USB_UP_LED2 = 0x1
	// Master Out Slave In for SSP1.
	IOCON_P0_13_FUNC_SSP1_MOSI = 0x2
	// A/D converter 0, input 7. When configured as an ADC input, the digital function of the pin must be disabled.
	IOCON_P0_13_FUNC_ADC0_IN_7 = 0x3

	// P0_14: I/O configuration register for pin P0[14]
	// Position of FUNC field.
	IOCON_P0_14_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_14_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_14_FUNC_P0_14 = 0x0
	// Host Enabled status for USB port 2.
	IOCON_P0_14_FUNC_USB_HSTEN2 = 0x1
	// Slave Select for SSP1.
	IOCON_P0_14_FUNC_SSP1_SSEL = 0x2
	// SoftConnect control for USB port 2. Signal used to switch an external 1.5 kW resistor under software control. Used with the SoftConnect USB feature.
	IOCON_P0_14_FUNC_USB_CONNECT2 = 0x3
	// Position of MODE field.
	IOCON_P0_14_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P0_14_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P0_14_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P0_14_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P0_14_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P0_14_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P0_14_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P0_14_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P0_14_HYS = 0x20
	// Disable.
	IOCON_P0_14_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P0_14_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P0_14_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P0_14_INV_Msk = 0x40
	// Bit INV.
	IOCON_P0_14_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P0_14_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P0_14_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P0_14_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P0_14_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P0_14_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P0_14_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P0_14_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P0_14_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P0_14_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P0_14_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P0_14_OD_Msk = 0x400
	// Bit OD.
	IOCON_P0_14_OD = 0x400
	// Disable.
	IOCON_P0_14_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P0_14_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P0_14_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P0_14_RESERVED_Msk = 0xfffff800

	// P0_15: I/O configuration register for pin P0[15]
	// Position of FUNC field.
	IOCON_P0_15_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_15_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_15_FUNC_P0_15 = 0x0
	// Transmitter output for UART1.
	IOCON_P0_15_FUNC_U1_TXD = 0x1
	// Serial clock for SSP0.
	IOCON_P0_15_FUNC_SSP0_SCK = 0x2
	// Data bit 0 for SPIFI.
	IOCON_P0_15_FUNC_SPIFI_IO_2 = 0x5
	// Position of MODE field.
	IOCON_P0_15_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P0_15_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P0_15_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P0_15_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P0_15_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P0_15_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P0_15_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P0_15_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P0_15_HYS = 0x20
	// Disable.
	IOCON_P0_15_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P0_15_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P0_15_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P0_15_INV_Msk = 0x40
	// Bit INV.
	IOCON_P0_15_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P0_15_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P0_15_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P0_15_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P0_15_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P0_15_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P0_15_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P0_15_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P0_15_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P0_15_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P0_15_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P0_15_OD_Msk = 0x400
	// Bit OD.
	IOCON_P0_15_OD = 0x400
	// Disable.
	IOCON_P0_15_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P0_15_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P0_15_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P0_15_RESERVED_Msk = 0xfffff800

	// P0_16: I/O configuration register for pin P0[16]
	// Position of FUNC field.
	IOCON_P0_16_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_16_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_16_FUNC_P0_16 = 0x0
	// Receiver input for UART1.
	IOCON_P0_16_FUNC_U1_RXD = 0x1
	// Slave Select for SSP0.
	IOCON_P0_16_FUNC_SSP0_SSEL = 0x2
	// Data bit 0 for SPIFI.
	IOCON_P0_16_FUNC_SPIFI_IO_3 = 0x5
	// Position of MODE field.
	IOCON_P0_16_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P0_16_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P0_16_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P0_16_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P0_16_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P0_16_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P0_16_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P0_16_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P0_16_HYS = 0x20
	// Disable.
	IOCON_P0_16_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P0_16_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P0_16_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P0_16_INV_Msk = 0x40
	// Bit INV.
	IOCON_P0_16_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P0_16_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P0_16_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P0_16_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P0_16_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P0_16_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P0_16_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P0_16_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P0_16_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P0_16_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P0_16_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P0_16_OD_Msk = 0x400
	// Bit OD.
	IOCON_P0_16_OD = 0x400
	// Disable.
	IOCON_P0_16_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P0_16_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P0_16_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P0_16_RESERVED_Msk = 0xfffff800

	// P0_17: I/O configuration register for pin P0[17]
	// Position of FUNC field.
	IOCON_P0_17_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_17_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_17_FUNC_P0_17 = 0x0
	// Clear to Send input for UART1.
	IOCON_P0_17_FUNC_U1_CTS = 0x1
	// Master In Slave Out for SSP0.
	IOCON_P0_17_FUNC_SSP0_MISO = 0x2
	// Data bit 0 for SPIFI.
	IOCON_P0_17_FUNC_SPIFI_IO_1 = 0x5
	// Position of MODE field.
	IOCON_P0_17_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P0_17_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P0_17_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P0_17_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P0_17_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P0_17_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P0_17_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P0_17_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P0_17_HYS = 0x20
	// Disable.
	IOCON_P0_17_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P0_17_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P0_17_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P0_17_INV_Msk = 0x40
	// Bit INV.
	IOCON_P0_17_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P0_17_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P0_17_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P0_17_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P0_17_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P0_17_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P0_17_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P0_17_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P0_17_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P0_17_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P0_17_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P0_17_OD_Msk = 0x400
	// Bit OD.
	IOCON_P0_17_OD = 0x400
	// Disable.
	IOCON_P0_17_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P0_17_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P0_17_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P0_17_RESERVED_Msk = 0xfffff800

	// P0_18: I/O configuration register for pin P0[18]
	// Position of FUNC field.
	IOCON_P0_18_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_18_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_18_FUNC_P0_18 = 0x0
	// Data Carrier Detect input for UART1.
	IOCON_P0_18_FUNC_U1_DCD = 0x1
	// Master Out Slave In for SSP0.
	IOCON_P0_18_FUNC_SSP0_MOSI = 0x2
	// Data bit 0 for SPIFI.
	IOCON_P0_18_FUNC_SPIFI_IO_0 = 0x5
	// Position of MODE field.
	IOCON_P0_18_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P0_18_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P0_18_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P0_18_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P0_18_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P0_18_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P0_18_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P0_18_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P0_18_HYS = 0x20
	// Disable.
	IOCON_P0_18_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P0_18_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P0_18_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P0_18_INV_Msk = 0x40
	// Bit INV.
	IOCON_P0_18_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P0_18_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P0_18_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P0_18_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P0_18_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P0_18_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P0_18_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P0_18_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P0_18_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P0_18_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P0_18_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P0_18_OD_Msk = 0x400
	// Bit OD.
	IOCON_P0_18_OD = 0x400
	// Disable.
	IOCON_P0_18_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P0_18_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P0_18_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P0_18_RESERVED_Msk = 0xfffff800

	// P0_19: I/O configuration register for pin P0[19]
	// Position of FUNC field.
	IOCON_P0_19_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_19_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_19_FUNC_P0_19 = 0x0
	// Data Set Ready input for UART1.
	IOCON_P0_19_FUNC_U1_DSR = 0x1
	// Clock output line for SD card interface.
	IOCON_P0_19_FUNC_SD_CLK = 0x2
	// I2C1 data input/output (this pin does not use a specialized I2C pad).
	IOCON_P0_19_FUNC_I2C1_SDA = 0x3
	// LCD data.
	IOCON_P0_19_FUNC_LCD_VD_13 = 0x7
	// Position of MODE field.
	IOCON_P0_19_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P0_19_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P0_19_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P0_19_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P0_19_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P0_19_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P0_19_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P0_19_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P0_19_HYS = 0x20
	// Disable.
	IOCON_P0_19_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P0_19_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P0_19_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P0_19_INV_Msk = 0x40
	// Bit INV.
	IOCON_P0_19_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P0_19_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P0_19_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P0_19_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P0_19_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P0_19_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P0_19_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P0_19_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P0_19_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P0_19_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P0_19_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P0_19_OD_Msk = 0x400
	// Bit OD.
	IOCON_P0_19_OD = 0x400
	// Disable.
	IOCON_P0_19_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P0_19_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P0_19_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P0_19_RESERVED_Msk = 0xfffff800

	// P0_20: I/O configuration register for pin P0[20]
	// Position of FUNC field.
	IOCON_P0_20_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_20_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_20_FUNC_P0_20 = 0x0
	// Data Terminal Ready output for UART1. Can also be configured to be an RS-485/EIA-485 output enable signal for UART1.
	IOCON_P0_20_FUNC_U1_DTR = 0x1
	// Command line for SD card interface.
	IOCON_P0_20_FUNC_SD_CMD = 0x2
	// I2C1 clock input/output (this pin does not use a specialized I2C pad).
	IOCON_P0_20_FUNC_I2C1_SCL = 0x3
	// LCD data.
	IOCON_P0_20_FUNC_LCD_VD_14 = 0x7
	// Position of MODE field.
	IOCON_P0_20_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P0_20_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P0_20_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P0_20_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P0_20_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P0_20_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P0_20_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P0_20_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P0_20_HYS = 0x20
	// Disable.
	IOCON_P0_20_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P0_20_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P0_20_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P0_20_INV_Msk = 0x40
	// Bit INV.
	IOCON_P0_20_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P0_20_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P0_20_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P0_20_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P0_20_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P0_20_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P0_20_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P0_20_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P0_20_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P0_20_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P0_20_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P0_20_OD_Msk = 0x400
	// Bit OD.
	IOCON_P0_20_OD = 0x400
	// Disable.
	IOCON_P0_20_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P0_20_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P0_20_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P0_20_RESERVED_Msk = 0xfffff800

	// P0_21: I/O configuration register for pin P0[21]
	// Position of FUNC field.
	IOCON_P0_21_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_21_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_21_FUNC_P0_21 = 0x0
	// Ring Indicator input for UART1.
	IOCON_P0_21_FUNC_U1_RI = 0x1
	// Power Supply Enable for external SD card power supply.
	IOCON_P0_21_FUNC_SD_PWR = 0x2
	// RS-485/EIA-485 output enable signal for UART4.
	IOCON_P0_21_FUNC_U4_OE = 0x3
	// CAN1 receiver input.
	IOCON_P0_21_FUNC_CAN_RD1 = 0x4
	// USART 4 clock input or output in synchronous mode.
	IOCON_P0_21_FUNC_U4_SCLK = 0x5
	// Position of MODE field.
	IOCON_P0_21_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P0_21_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P0_21_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P0_21_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P0_21_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P0_21_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P0_21_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P0_21_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P0_21_HYS = 0x20
	// Disable.
	IOCON_P0_21_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P0_21_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P0_21_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P0_21_INV_Msk = 0x40
	// Bit INV.
	IOCON_P0_21_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P0_21_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P0_21_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P0_21_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P0_21_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P0_21_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P0_21_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P0_21_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P0_21_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P0_21_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P0_21_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P0_21_OD_Msk = 0x400
	// Bit OD.
	IOCON_P0_21_OD = 0x400
	// Disable.
	IOCON_P0_21_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P0_21_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P0_21_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P0_21_RESERVED_Msk = 0xfffff800

	// P0_22: I/O configuration register for pin P0[22]
	// Position of FUNC field.
	IOCON_P0_22_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_22_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_22_FUNC_P0_22 = 0x0
	// Request to Send output for UART1. Can also be configured to be an RS-485/EIA-485 output enable signal for UART1.
	IOCON_P0_22_FUNC_U1_RTS = 0x1
	// Data line 0 for SD card interface.
	IOCON_P0_22_FUNC_SD_DAT_0 = 0x2
	// Transmitter output for USART4 (input/output in smart card mode).
	IOCON_P0_22_FUNC_U4_TXD = 0x3
	// CAN1 transmitter output.
	IOCON_P0_22_FUNC_CAN_TD1 = 0x4
	// Clock output for SPIFI.
	IOCON_P0_22_FUNC_SPIFI_CLK = 0x5
	// Position of MODE field.
	IOCON_P0_22_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P0_22_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P0_22_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P0_22_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P0_22_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P0_22_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P0_22_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P0_22_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P0_22_HYS = 0x20
	// Disable.
	IOCON_P0_22_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P0_22_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P0_22_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P0_22_INV_Msk = 0x40
	// Bit INV.
	IOCON_P0_22_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P0_22_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P0_22_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of ADMODE field.
	IOCON_P0_22_ADMODE_Pos = 0x7
	// Bit mask of ADMODE field.
	IOCON_P0_22_ADMODE_Msk = 0x80
	// Bit ADMODE.
	IOCON_P0_22_ADMODE = 0x80
	// Analog input mode.
	IOCON_P0_22_ADMODE_ANALOG_INPUT_MODE_ = 0x0
	// Digital functional mode.
	IOCON_P0_22_ADMODE_DIGITAL_FUNCTIONAL_M = 0x1
	// Position of FILTR field.
	IOCON_P0_22_FILTR_Pos = 0x8
	// Bit mask of FILTR field.
	IOCON_P0_22_FILTR_Msk = 0x100
	// Bit FILTR.
	IOCON_P0_22_FILTR = 0x100
	// Filter disabled.
	IOCON_P0_22_FILTR_FILTER_DISABLED_ = 0x0
	// Filter enabled.
	IOCON_P0_22_FILTR_FILTER_ENABLED_ = 0x1
	// Position of RESERVED field.
	IOCON_P0_22_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	IOCON_P0_22_RESERVED_Msk = 0x200
	// Bit RESERVED.
	IOCON_P0_22_RESERVED = 0x200
	// Position of OD field.
	IOCON_P0_22_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P0_22_OD_Msk = 0x400
	// Bit OD.
	IOCON_P0_22_OD = 0x400
	// Disable.
	IOCON_P0_22_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode.
	IOCON_P0_22_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P0_22_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P0_22_RESERVED_Msk = 0xfffff800

	// P0_23: I/O configuration register for pin P0[23]
	// Position of FUNC field.
	IOCON_P0_23_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_23_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_23_FUNC_P0_23 = 0x0
	// A/D converter 0, input 0. When configured as an ADC input, the digital function of the pin must be disabled.
	IOCON_P0_23_FUNC_ADC0_IN_0 = 0x1
	// Receive Clock. It is driven by the master and received by the slave. Corresponds to the signal SCK in the I2S-bus specification.
	IOCON_P0_23_FUNC_I2S_RX_SCK = 0x2
	// Capture input for Timer 3, channel 0.
	IOCON_P0_23_FUNC_T3_CAP0 = 0x3

	// P0_24: I/O configuration register for pin P0[24]
	// Position of FUNC field.
	IOCON_P0_24_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_24_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_24_FUNC_P0_24 = 0x0
	// A/D converter 0, input 1. When configured as an ADC input, the digital function of the pin must be disabled.
	IOCON_P0_24_FUNC_ADC0_IN_1 = 0x1
	// Receive Word Select. It is driven by the master and received by the slave. Corresponds to the signal WS in the I2S-bus specification.
	IOCON_P0_24_FUNC_I2S_RX_WS = 0x2
	// Capture input for Timer 3, channel 1.
	IOCON_P0_24_FUNC_T3_CAP1 = 0x3

	// P0_25: I/O configuration register for pin P0[25]
	// Position of FUNC field.
	IOCON_P0_25_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_25_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_25_FUNC_P0_25 = 0x0
	// A/D converter 0, input 2. When configured as an ADC input, the digital function of the pin must be disabled.
	IOCON_P0_25_FUNC_ADC0_IN_2 = 0x1
	// Receive data. It is driven by the transmitter and read by the receiver. Corresponds to the signal SD in the I2S-bus specification.
	IOCON_P0_25_FUNC_I2S_RX_SDA = 0x2
	// Transmitter output for UART3.
	IOCON_P0_25_FUNC_U3_TXD = 0x3

	// P0_26: I/O configuration register for pin P0[26]
	// Position of FUNC field.
	IOCON_P0_26_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_26_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_26_FUNC_P0_26 = 0x0
	// A/D converter 0, input 3. When configured as an ADC input, the digital function of the pin must be disabled.
	IOCON_P0_26_FUNC_ADC0_IN_3 = 0x1
	// D/A converter output. When configured as the DAC output, the digital function of the pin must be disabled.
	IOCON_P0_26_FUNC_DAC_OUT = 0x2
	// Receiver input for UART3.
	IOCON_P0_26_FUNC_U3_RXD = 0x3
	// Position of MODE field.
	IOCON_P0_26_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P0_26_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P0_26_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P0_26_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P0_26_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P0_26_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P0_26_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P0_26_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P0_26_HYS = 0x20
	// Disable.
	IOCON_P0_26_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P0_26_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P0_26_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P0_26_INV_Msk = 0x40
	// Bit INV.
	IOCON_P0_26_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P0_26_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P0_26_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of ADMODE field.
	IOCON_P0_26_ADMODE_Pos = 0x7
	// Bit mask of ADMODE field.
	IOCON_P0_26_ADMODE_Msk = 0x80
	// Bit ADMODE.
	IOCON_P0_26_ADMODE = 0x80
	// Analog input mode.
	IOCON_P0_26_ADMODE_ANALOG_INPUT_MODE_ = 0x0
	// Digital functional mode.
	IOCON_P0_26_ADMODE_DIGITAL_FUNCTIONAL_M = 0x1
	// Position of FILTR field.
	IOCON_P0_26_FILTR_Pos = 0x8
	// Bit mask of FILTR field.
	IOCON_P0_26_FILTR_Msk = 0x100
	// Bit FILTR.
	IOCON_P0_26_FILTR = 0x100
	// Filter disabled.
	IOCON_P0_26_FILTR_FILTER_DISABLED_ = 0x0
	// Filter enabled.
	IOCON_P0_26_FILTR_FILTER_ENABLED_ = 0x1
	// Position of RESERVED field.
	IOCON_P0_26_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	IOCON_P0_26_RESERVED_Msk = 0x200
	// Bit RESERVED.
	IOCON_P0_26_RESERVED = 0x200
	// Position of OD field.
	IOCON_P0_26_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P0_26_OD_Msk = 0x400
	// Bit OD.
	IOCON_P0_26_OD = 0x400
	// Disable.
	IOCON_P0_26_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode.
	IOCON_P0_26_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P0_26_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P0_26_RESERVED_Msk = 0xf800
	// Position of DACEN field.
	IOCON_P0_26_DACEN_Pos = 0x10
	// Bit mask of DACEN field.
	IOCON_P0_26_DACEN_Msk = 0x10000
	// Bit DACEN.
	IOCON_P0_26_DACEN = 0x10000
	// DAC disable.
	IOCON_P0_26_DACEN_DISABLE = 0x0
	// DAC enable.
	IOCON_P0_26_DACEN_ENABLE = 0x1
	// Position of RESERVED field.
	IOCON_P0_26_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	IOCON_P0_26_RESERVED_Msk = 0xfffe0000

	// P0_27: I/O configuration register for pin P0[27]
	// Position of FUNC field.
	IOCON_P0_27_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_27_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_27_FUNC_P0_27 = 0x0
	// I2C0 data input/output. (This pin uses a specialized I2C pad).
	IOCON_P0_27_FUNC_I2C0_SDA = 0x1
	// I2C serial data for communication with an external USB transceiver.
	IOCON_P0_27_FUNC_USB_SDA1 = 0x2
	// Position of RESERVED field.
	IOCON_P0_27_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	IOCON_P0_27_RESERVED_Msk = 0x38
	// Position of INV field.
	IOCON_P0_27_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P0_27_INV_Msk = 0x40
	// Bit INV.
	IOCON_P0_27_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P0_27_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P0_27_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P0_27_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P0_27_RESERVED_Msk = 0x80
	// Bit RESERVED.
	IOCON_P0_27_RESERVED = 0x80
	// Position of HS field.
	IOCON_P0_27_HS_Pos = 0x8
	// Bit mask of HS field.
	IOCON_P0_27_HS_Msk = 0x100
	// Bit HS.
	IOCON_P0_27_HS = 0x100
	// I2C 50ns glitch filter and slew rate control enabled.
	IOCON_P0_27_HS_ENABLED = 0x0
	// I2C 50ns glitch filter and slew rate control disabled.
	IOCON_P0_27_HS_DISABLED = 0x1
	// Position of HIDRIVE field.
	IOCON_P0_27_HIDRIVE_Pos = 0x9
	// Bit mask of HIDRIVE field.
	IOCON_P0_27_HIDRIVE_Msk = 0x200
	// Bit HIDRIVE.
	IOCON_P0_27_HIDRIVE = 0x200
	// Output drive sink is 4 mA. This is sufficient for standard and fast mode I2C.
	IOCON_P0_27_HIDRIVE_LOWDRIVE = 0x0
	// Output drive sink is 20 mA. This is needed for Fast Mode Plus I2C. Refer to the appropriate specific device data sheet for details.
	IOCON_P0_27_HIDRIVE_HIGHDRIVE = 0x1
	// Position of RESERVED field.
	IOCON_P0_27_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	IOCON_P0_27_RESERVED_Msk = 0xfffffc00

	// P0_28: I/O configuration register for pin P0[28]
	// Position of FUNC field.
	IOCON_P0_28_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_28_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_28_FUNC_P0_28 = 0x0
	// I2C0 clock input/output (this pin uses a specialized I2C pad.
	IOCON_P0_28_FUNC_I2C0_SCL = 0x1
	// I2C serial clock for communication with an external USB transceiver.
	IOCON_P0_28_FUNC_USB_SCL1 = 0x2
	// Position of RESERVED field.
	IOCON_P0_28_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	IOCON_P0_28_RESERVED_Msk = 0x38
	// Position of INV field.
	IOCON_P0_28_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P0_28_INV_Msk = 0x40
	// Bit INV.
	IOCON_P0_28_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P0_28_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P0_28_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P0_28_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P0_28_RESERVED_Msk = 0x80
	// Bit RESERVED.
	IOCON_P0_28_RESERVED = 0x80
	// Position of HS field.
	IOCON_P0_28_HS_Pos = 0x8
	// Bit mask of HS field.
	IOCON_P0_28_HS_Msk = 0x100
	// Bit HS.
	IOCON_P0_28_HS = 0x100
	// I2C 50ns glitch filter and slew rate control enabled.
	IOCON_P0_28_HS_ENABLED = 0x0
	// I2C 50ns glitch filter and slew rate control disabled.
	IOCON_P0_28_HS_DISABLED = 0x1
	// Position of HIDRIVE field.
	IOCON_P0_28_HIDRIVE_Pos = 0x9
	// Bit mask of HIDRIVE field.
	IOCON_P0_28_HIDRIVE_Msk = 0x200
	// Bit HIDRIVE.
	IOCON_P0_28_HIDRIVE = 0x200
	// Output drive sink is 4 mA. This is sufficient for standard and fast mode I2C.
	IOCON_P0_28_HIDRIVE_LOWDRIVE = 0x0
	// Output drive sink is 20 mA. This is needed for Fast Mode Plus I2C. Refer to the appropriate specific device data sheet for details.
	IOCON_P0_28_HIDRIVE_HIGHDRIVE = 0x1
	// Position of RESERVED field.
	IOCON_P0_28_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	IOCON_P0_28_RESERVED_Msk = 0xfffffc00

	// P0_29: I/O configuration register for pin P0[29]
	// Position of FUNC field.
	IOCON_P0_29_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_29_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_29_FUNC_P0_29 = 0x0
	// USB port 1 bidirectional D+ line.
	IOCON_P0_29_FUNC_USB_DP1 = 0x1
	// External interrupt 0 input.
	IOCON_P0_29_FUNC_EINT0 = 0x2
	// Position of RESERVED field.
	IOCON_P0_29_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	IOCON_P0_29_RESERVED_Msk = 0xfffffff8

	// P0_30: I/O configuration register for pin P0[30]
	// Position of FUNC field.
	IOCON_P0_30_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_30_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_30_FUNC_P0_30 = 0x0
	// USB port 1 bidirectional D- line.
	IOCON_P0_30_FUNC_USB_DM1 = 0x1
	// External interrupt 1 input.
	IOCON_P0_30_FUNC_EINT1 = 0x2
	// Position of RESERVED field.
	IOCON_P0_30_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	IOCON_P0_30_RESERVED_Msk = 0xfffffff8

	// P0_31: I/O configuration register for pin P0[31]
	// Position of FUNC field.
	IOCON_P0_31_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P0_31_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P0_31_FUNC_P0_31 = 0x0
	// USB port 2 bidirectional D+ line.
	IOCON_P0_31_FUNC_USB_DP2 = 0x1
	// Position of RESERVED field.
	IOCON_P0_31_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	IOCON_P0_31_RESERVED_Msk = 0xfffffff8

	// P1_0: I/O configuration register for pin P1[0]
	// Position of FUNC field.
	IOCON_P1_0_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_0_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_0_FUNC_P1_0 = 0x0
	// Ethernet transmit data 0 (RMII/MII interface).
	IOCON_P1_0_FUNC_ENET_TXD0 = 0x1
	// Capture input for Timer 3, channel 1.
	IOCON_P1_0_FUNC_T3_CAP1 = 0x3
	// Serial clock for SSP2.
	IOCON_P1_0_FUNC_SSP2_SCK = 0x4
	// Position of MODE field.
	IOCON_P1_0_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_0_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_0_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_0_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_0_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_0_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_0_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_0_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_0_HYS = 0x20
	// Disable.
	IOCON_P1_0_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_0_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_0_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_0_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_0_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_0_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_0_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_0_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_0_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_0_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_0_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_0_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_0_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_0_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_0_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_0_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_0_OD = 0x400
	// Disable.
	IOCON_P1_0_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_0_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_0_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_0_RESERVED_Msk = 0xfffff800

	// P1_1: I/O configuration register for pin P1[1]
	// Position of FUNC field.
	IOCON_P1_1_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_1_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_1_FUNC_P1_1 = 0x0
	// Ethernet transmit data 1 (RMII/MII interface).
	IOCON_P1_1_FUNC_ENET_TXD1 = 0x1
	// Match output for Timer 3, channel 3.
	IOCON_P1_1_FUNC_T3_MAT3 = 0x3
	// Master Out Slave In for SSP2.
	IOCON_P1_1_FUNC_SSP2_MOSI = 0x4
	// Position of MODE field.
	IOCON_P1_1_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_1_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_1_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_1_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_1_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_1_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_1_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_1_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_1_HYS = 0x20
	// Disable.
	IOCON_P1_1_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_1_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_1_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_1_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_1_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_1_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_1_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_1_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_1_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_1_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_1_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_1_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_1_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_1_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_1_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_1_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_1_OD = 0x400
	// Disable.
	IOCON_P1_1_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_1_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_1_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_1_RESERVED_Msk = 0xfffff800

	// P1_2: I/O configuration register for pin P1[2]
	// Position of FUNC field.
	IOCON_P1_2_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_2_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_2_FUNC_P1_2 = 0x0
	// Ethernet transmit data 2 (MII interface).
	IOCON_P1_2_FUNC_ENET_TXD2 = 0x1
	// Clock output line for SD card interface.
	IOCON_P1_2_FUNC_SD_CLK = 0x2
	// Pulse Width Modulator 0, output 1.
	IOCON_P1_2_FUNC_PWM0_1 = 0x3
	// Position of MODE field.
	IOCON_P1_2_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_2_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_2_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_2_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_2_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_2_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_2_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_2_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_2_HYS = 0x20
	// Disable.
	IOCON_P1_2_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_2_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_2_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_2_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_2_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_2_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_2_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_2_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_2_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_2_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_2_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_2_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_2_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_2_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_2_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_2_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_2_OD = 0x400
	// Disable.
	IOCON_P1_2_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_2_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_2_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_2_RESERVED_Msk = 0xfffff800

	// P1_3: I/O configuration register for pin P1[3]
	// Position of FUNC field.
	IOCON_P1_3_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_3_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_3_FUNC_P1_3 = 0x0
	// Ethernet transmit data 3 (MII interface).
	IOCON_P1_3_FUNC_ENET_TXD3 = 0x1
	// Command line for SD card interface.
	IOCON_P1_3_FUNC_SD_CMD = 0x2
	// Pulse Width Modulator 0, output 2.
	IOCON_P1_3_FUNC_PWM0_2 = 0x3
	// Position of MODE field.
	IOCON_P1_3_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_3_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_3_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_3_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_3_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_3_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_3_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_3_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_3_HYS = 0x20
	// Disable.
	IOCON_P1_3_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_3_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_3_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_3_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_3_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_3_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_3_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_3_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_3_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_3_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_3_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_3_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_3_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_3_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_3_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_3_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_3_OD = 0x400
	// Disable.
	IOCON_P1_3_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_3_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_3_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_3_RESERVED_Msk = 0xfffff800

	// P1_4: I/O configuration register for pin P1[4]
	// Position of FUNC field.
	IOCON_P1_4_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_4_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_4_FUNC_P1_4 = 0x0
	// Ethernet transmit data enable (RMII/MII interface).
	IOCON_P1_4_FUNC_ENET_TX_EN = 0x1
	// Match output for Timer 3, channel 2.
	IOCON_P1_4_FUNC_T3_MAT2 = 0x3
	// Master In Slave Out for SSP2.
	IOCON_P1_4_FUNC_SSP2_MISO = 0x4
	// Position of MODE field.
	IOCON_P1_4_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_4_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_4_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_4_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_4_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_4_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_4_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_4_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_4_HYS = 0x20
	// Disable.
	IOCON_P1_4_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_4_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_4_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_4_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_4_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_4_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_4_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_4_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_4_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_4_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_4_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_4_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_4_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_4_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_4_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_4_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_4_OD = 0x400
	// Disable.
	IOCON_P1_4_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_4_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_4_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_4_RESERVED_Msk = 0xfffff800

	// P1_5: I/O configuration register for pin P1[5]
	// Position of FUNC field.
	IOCON_P1_5_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_5_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_5_FUNC_P1_5 = 0x0
	// Ethernet Transmit Error (MII interface).
	IOCON_P1_5_FUNC_ENET_TX_ER = 0x1
	// Power Supply Enable for external SD card power supply.
	IOCON_P1_5_FUNC_SD_PWR = 0x2
	// Pulse Width Modulator 0, output 3.
	IOCON_P1_5_FUNC_PWM0_3 = 0x3
	// Comparator 1, input 1.
	IOCON_P1_5_FUNC_CMP1_IN_1 = 0x5
	// Position of MODE field.
	IOCON_P1_5_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_5_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_5_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_5_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_5_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_5_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_5_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_5_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_5_HYS = 0x20
	// Disable.
	IOCON_P1_5_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_5_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_5_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_5_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_5_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_5_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_5_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_5_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_5_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_5_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_5_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_5_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_5_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_5_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_5_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_5_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_5_OD = 0x400
	// Disable.
	IOCON_P1_5_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_5_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_5_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_5_RESERVED_Msk = 0xfffff800

	// P1_6: I/O configuration register for pin P1[6]
	// Position of FUNC field.
	IOCON_P1_6_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_6_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_6_FUNC_P1_6 = 0x0
	// Ethernet Transmit Clock (MII interface).
	IOCON_P1_6_FUNC_ENET_TX_CLK = 0x1
	// Data line 0 for SD card interface.
	IOCON_P1_6_FUNC_SD_DAT_0 = 0x2
	// Pulse Width Modulator 0, output 4.
	IOCON_P1_6_FUNC_PWM0_4 = 0x3
	// Comparator 0, input 3.
	IOCON_P1_6_FUNC_CMP0_IN_3 = 0x5
	// Position of MODE field.
	IOCON_P1_6_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_6_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_6_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_6_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_6_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_6_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_6_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_6_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_6_HYS = 0x20
	// Disable.
	IOCON_P1_6_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_6_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_6_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_6_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_6_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_6_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_6_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_6_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_6_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_6_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_6_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_6_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_6_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_6_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_6_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_6_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_6_OD = 0x400
	// Disable.
	IOCON_P1_6_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_6_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_6_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_6_RESERVED_Msk = 0xfffff800

	// P1_7: I/O configuration register for pin P1[7]
	// Position of FUNC field.
	IOCON_P1_7_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_7_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_7_FUNC_P1_7 = 0x0
	// Ethernet Collision detect (MII interface).
	IOCON_P1_7_FUNC_ENET_COL = 0x1
	// Data line 1 for SD card interface.
	IOCON_P1_7_FUNC_SD_DAT_1 = 0x2
	// Pulse Width Modulator 0, output 5.
	IOCON_P1_7_FUNC_PWM0_5 = 0x3
	// Comparator 1, input 0.
	IOCON_P1_7_FUNC_CMP1_IN_0 = 0x5
	// Position of MODE field.
	IOCON_P1_7_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_7_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_7_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_7_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_7_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_7_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_7_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_7_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_7_HYS = 0x20
	// Disable.
	IOCON_P1_7_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_7_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_7_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_7_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_7_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_7_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_7_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_7_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_7_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_7_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_7_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_7_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_7_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_7_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_7_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_7_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_7_OD = 0x400
	// Disable.
	IOCON_P1_7_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_7_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_7_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_7_RESERVED_Msk = 0xfffff800

	// P1_8: I/O configuration register for pin P1[8]
	// Position of FUNC field.
	IOCON_P1_8_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_8_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_8_FUNC_P1_8 = 0x0
	// Ethernet Carrier Sense (MII interface) or Ethernet Carrier Sense/Data Valid (RMII interface).
	IOCON_P1_8_FUNC_ENET_CRS_CRS_DV = 0x1
	// Match output for Timer 3, channel 1.
	IOCON_P1_8_FUNC_T3_MAT1 = 0x3
	// Slave Select for SSP2.
	IOCON_P1_8_FUNC_SSP2_SSEL = 0x4
	// Position of MODE field.
	IOCON_P1_8_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_8_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_8_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_8_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_8_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_8_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_8_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_8_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_8_HYS = 0x20
	// Disable.
	IOCON_P1_8_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_8_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_8_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_8_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_8_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_8_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_8_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_8_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_8_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_8_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_8_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_8_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_8_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_8_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_8_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_8_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_8_OD = 0x400
	// Disable.
	IOCON_P1_8_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_8_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_8_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_8_RESERVED_Msk = 0xfffff800

	// P1_9: I/O configuration register for pin P1[9]
	// Position of FUNC field.
	IOCON_P1_9_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_9_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_9_FUNC_P1_9 = 0x0
	// Ethernet receive data 0 (RMII/MII interface).
	IOCON_P1_9_FUNC_ENET_RXD0 = 0x1
	// Match output for Timer 3, channel 0.
	IOCON_P1_9_FUNC_T3_MAT0 = 0x3
	// Position of MODE field.
	IOCON_P1_9_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_9_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_9_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_9_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_9_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_9_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_9_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_9_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_9_HYS = 0x20
	// Disable.
	IOCON_P1_9_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_9_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_9_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_9_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_9_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_9_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_9_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_9_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_9_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_9_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_9_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_9_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_9_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_9_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_9_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_9_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_9_OD = 0x400
	// Disable.
	IOCON_P1_9_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_9_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_9_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_9_RESERVED_Msk = 0xfffff800

	// P1_10: I/O configuration register for pin P1[10]
	// Position of FUNC field.
	IOCON_P1_10_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_10_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_10_FUNC_P1_10 = 0x0
	// Ethernet receive data 1 (RMII/MII interface).
	IOCON_P1_10_FUNC_ENET_RXD1 = 0x1
	// Capture input for Timer 3, channel 0.
	IOCON_P1_10_FUNC_T3_CAP0 = 0x3
	// Position of MODE field.
	IOCON_P1_10_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_10_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_10_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_10_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_10_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_10_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_10_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_10_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_10_HYS = 0x20
	// Disable.
	IOCON_P1_10_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_10_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_10_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_10_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_10_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_10_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_10_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_10_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_10_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_10_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_10_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_10_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_10_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_10_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_10_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_10_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_10_OD = 0x400
	// Disable.
	IOCON_P1_10_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_10_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_10_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_10_RESERVED_Msk = 0xfffff800

	// P1_11: I/O configuration register for pin P1[11]
	// Position of FUNC field.
	IOCON_P1_11_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_11_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_11_FUNC_P1_11 = 0x0
	// Ethernet Receive Data 2 (MII interface).
	IOCON_P1_11_FUNC_ENET_RXD2 = 0x1
	// Data line 2 for SD card interface.
	IOCON_P1_11_FUNC_SD_DAT_2 = 0x2
	// Pulse Width Modulator 0, output 6.
	IOCON_P1_11_FUNC_PWM0_6 = 0x3
	// Position of MODE field.
	IOCON_P1_11_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_11_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_11_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_11_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_11_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_11_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_11_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_11_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_11_HYS = 0x20
	// Disable.
	IOCON_P1_11_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_11_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_11_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_11_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_11_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_11_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_11_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_11_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_11_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_11_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_11_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_11_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_11_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_11_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_11_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_11_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_11_OD = 0x400
	// Disable.
	IOCON_P1_11_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_11_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_11_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_11_RESERVED_Msk = 0xfffff800

	// P1_12: I/O configuration register for pin P1[12]
	// Position of FUNC field.
	IOCON_P1_12_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_12_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_12_FUNC_P1_12 = 0x0
	// Ethernet Receive Data (MII interface).
	IOCON_P1_12_FUNC_ENET_RXD3 = 0x1
	// Data line 3 for SD card interface.
	IOCON_P1_12_FUNC_SD_DAT_3 = 0x2
	// Capture input for PWM0, channel 0.
	IOCON_P1_12_FUNC_PWM0_CAP0 = 0x3
	// Comparator 1, output.
	IOCON_P1_12_FUNC_CMP1_OUT = 0x5
	// Position of MODE field.
	IOCON_P1_12_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_12_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_12_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_12_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_12_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_12_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_12_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_12_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_12_HYS = 0x20
	// Disable.
	IOCON_P1_12_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_12_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_12_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_12_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_12_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_12_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_12_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_12_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_12_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_12_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_12_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_12_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_12_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_12_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_12_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_12_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_12_OD = 0x400
	// Disable.
	IOCON_P1_12_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_12_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_12_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_12_RESERVED_Msk = 0xfffff800

	// P1_13: I/O configuration register for pin P1[13]
	// Position of FUNC field.
	IOCON_P1_13_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_13_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_13_FUNC_P1_13 = 0x0
	// Ethernet Receive Data Valid (MII interface).
	IOCON_P1_13_FUNC_ENET_RX_DV = 0x1
	// Position of MODE field.
	IOCON_P1_13_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_13_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_13_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_13_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_13_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_13_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_13_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_13_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_13_HYS = 0x20
	// Disable.
	IOCON_P1_13_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_13_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_13_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_13_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_13_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_13_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_13_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_13_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_13_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_13_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_13_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_13_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_13_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_13_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_13_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_13_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_13_OD = 0x400
	// Disable.
	IOCON_P1_13_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_13_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_13_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_13_RESERVED_Msk = 0xfffff800

	// P1_14: I/O configuration register for pin P1[14]
	// Position of FUNC field.
	IOCON_P1_14_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_14_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_14_FUNC_P1_14 = 0x0
	// Ethernet receive error (RMII/MII interface).
	IOCON_P1_14_FUNC_ENET_RX_ER = 0x1
	// Capture input for Timer 2, channel 0.
	IOCON_P1_14_FUNC_T2_CAP0 = 0x3
	// Comparator 0, input 0.
	IOCON_P1_14_FUNC_CMP0_IN_0 = 0x5
	// Position of MODE field.
	IOCON_P1_14_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_14_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_14_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_14_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_14_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_14_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_14_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_14_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_14_HYS = 0x20
	// Disable.
	IOCON_P1_14_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_14_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_14_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_14_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_14_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_14_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_14_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_14_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_14_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_14_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_14_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_14_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_14_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_14_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_14_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_14_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_14_OD = 0x400
	// Disable.
	IOCON_P1_14_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_14_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_14_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_14_RESERVED_Msk = 0xfffff800

	// P1_15: I/O configuration register for pin P1[15]
	// Position of FUNC field.
	IOCON_P1_15_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_15_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_15_FUNC_P1_15 = 0x0
	// Ethernet Receive Clock (MII interface) or Ethernet Reference Clock (RMII interface).
	IOCON_P1_15_FUNC_ENET_RX_CLK_REF_CLK = 0x1
	// I2C2 data input/output (this pin does not use a specialized I2C pad).
	IOCON_P1_15_FUNC_I2C2_SDA = 0x3
	// Position of MODE field.
	IOCON_P1_15_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_15_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_15_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_15_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_15_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_15_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_15_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_15_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_15_HYS = 0x20
	// Disable.
	IOCON_P1_15_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_15_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_15_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_15_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_15_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_15_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_15_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_15_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_15_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_15_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_15_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_15_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_15_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_15_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_15_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_15_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_15_OD = 0x400
	// Disable.
	IOCON_P1_15_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_15_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_15_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_15_RESERVED_Msk = 0xfffff800

	// P1_16: I/O configuration register for pin P1[16]
	// Position of FUNC field.
	IOCON_P1_16_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_16_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_16_FUNC_P1_16 = 0x0
	// Ethernet MIIM clock.
	IOCON_P1_16_FUNC_ENET_MDC = 0x1
	// I2S transmit master clock.
	IOCON_P1_16_FUNC_I2S_TX_MCLK = 0x2
	// Comparator 0, input 1.
	IOCON_P1_16_FUNC_CMP0_IN_1 = 0x5
	// Position of MODE field.
	IOCON_P1_16_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_16_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_16_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_16_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_16_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_16_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_16_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_16_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_16_HYS = 0x20
	// Disable.
	IOCON_P1_16_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_16_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_16_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_16_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_16_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_16_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_16_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_16_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_16_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_16_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_16_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_16_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_16_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_16_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_16_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_16_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_16_OD = 0x400
	// Disable.
	IOCON_P1_16_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_16_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_16_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_16_RESERVED_Msk = 0xfffff800

	// P1_17: I/O configuration register for pin P1[17]
	// Position of FUNC field.
	IOCON_P1_17_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_17_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_17_FUNC_P1_17 = 0x0
	// Ethernet MIIM data input and output.
	IOCON_P1_17_FUNC_ENET_MDIO = 0x1
	// I2S receive master clock.
	IOCON_P1_17_FUNC_I2S_RX_MCLK = 0x2
	// Comparator 0, input 2.
	IOCON_P1_17_FUNC_CMP0_IN_2 = 0x5
	// Position of MODE field.
	IOCON_P1_17_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_17_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_17_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_17_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_17_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_17_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_17_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_17_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_17_HYS = 0x20
	// Disable.
	IOCON_P1_17_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_17_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_17_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_17_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_17_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_17_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_17_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_17_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_17_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_17_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_17_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_17_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_17_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_17_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_17_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_17_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_17_OD = 0x400
	// Disable.
	IOCON_P1_17_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_17_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_17_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_17_RESERVED_Msk = 0xfffff800

	// P1_18: I/O configuration register for pin P1[18]
	// Position of FUNC field.
	IOCON_P1_18_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_18_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_18_FUNC_P1_18 = 0x0
	// It is LOW when the device is configured (non-control endpoints enabled), or when the host is enabled and has detected a device on the bus. It is HIGH when the device is not configured, or when host is enabled and has not detected a device on the bus, or during global suspend. It transitions between LOW and HIGH (flashes) when the host is enabled and detects activity on the bus.
	IOCON_P1_18_FUNC_USB_UP_LED1 = 0x1
	// Pulse Width Modulator 1, channel 1 output.
	IOCON_P1_18_FUNC_PWM1_1 = 0x2
	// Capture input for Timer 1, channel 0.
	IOCON_P1_18_FUNC_T1_CAP0 = 0x3
	// Master In Slave Out for SSP1.
	IOCON_P1_18_FUNC_SSP1_MISO = 0x5
	// Position of MODE field.
	IOCON_P1_18_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_18_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_18_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_18_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_18_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_18_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_18_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_18_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_18_HYS = 0x20
	// Disable.
	IOCON_P1_18_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_18_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_18_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_18_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_18_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_18_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_18_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_18_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_18_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_18_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_18_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_18_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_18_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_18_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_18_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_18_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_18_OD = 0x400
	// Disable.
	IOCON_P1_18_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_18_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_18_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_18_RESERVED_Msk = 0xfffff800

	// P1_19: I/O configuration register for pin P1[19]
	// Position of FUNC field.
	IOCON_P1_19_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_19_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_19_FUNC_P1_19 = 0x0
	// Transmit Enable signal for USB port 1 (OTG transceiver).
	IOCON_P1_19_FUNC_USB_TX_E1 = 0x1
	// Port Power enable signal for USB port 1.
	IOCON_P1_19_FUNC_USB_PPWR1 = 0x2
	// Capture input for Timer 1, channel 1.
	IOCON_P1_19_FUNC_T1_CAP1 = 0x3
	// Motor control PWM channel 0, output A.
	IOCON_P1_19_FUNC_MC_0A = 0x4
	// Serial clock for SSP1.
	IOCON_P1_19_FUNC_SSP1_SCK = 0x5
	// RS-485/EIA-485 output enable signal for UART2.
	IOCON_P1_19_FUNC_U2_OE = 0x6
	// Position of MODE field.
	IOCON_P1_19_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_19_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_19_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_19_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_19_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_19_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_19_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_19_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_19_HYS = 0x20
	// Disable.
	IOCON_P1_19_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_19_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_19_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_19_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_19_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_19_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_19_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_19_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_19_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_19_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_19_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_19_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_19_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_19_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_19_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_19_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_19_OD = 0x400
	// Disable.
	IOCON_P1_19_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_19_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_19_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_19_RESERVED_Msk = 0xfffff800

	// P1_20: I/O configuration register for pin P1[20]
	// Position of FUNC field.
	IOCON_P1_20_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_20_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_20_FUNC_P1_20 = 0x0
	// D+ transmit data for USB port 1 (OTG transceiver).
	IOCON_P1_20_FUNC_USB_TX_DP1 = 0x1
	// Pulse Width Modulator 1, channel 2 output.
	IOCON_P1_20_FUNC_PWM1_2 = 0x2
	// Quadrature Encoder Interface PHA input.
	IOCON_P1_20_FUNC_QEI_PHA = 0x3
	// Motor control PWM channel 0 feedback input.
	IOCON_P1_20_FUNC_MC_FB0 = 0x4
	// Serial clock for SSP0.
	IOCON_P1_20_FUNC_SSP0_SCK = 0x5
	// LCD data.
	IOCON_P1_20_FUNC_LCD_VD_6 = 0x6
	// LCD data.
	IOCON_P1_20_FUNC_LCD_VD_10 = 0x7
	// Position of MODE field.
	IOCON_P1_20_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_20_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_20_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_20_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_20_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_20_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_20_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_20_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_20_HYS = 0x20
	// Disable.
	IOCON_P1_20_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_20_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_20_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_20_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_20_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_20_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_20_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_20_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_20_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_20_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_20_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_20_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_20_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_20_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_20_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_20_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_20_OD = 0x400
	// Disable.
	IOCON_P1_20_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_20_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_20_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_20_RESERVED_Msk = 0xfffff800

	// P1_21: I/O configuration register for pin P1[21]
	// Position of FUNC field.
	IOCON_P1_21_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_21_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_21_FUNC_P1_21 = 0x0
	// D- transmit data for USB port 1 (OTG transceiver).
	IOCON_P1_21_FUNC_USB_TX_DM1 = 0x1
	// Pulse Width Modulator 1, channel 3 output.
	IOCON_P1_21_FUNC_PWM1_3 = 0x2
	// Slave Select for SSP0.
	IOCON_P1_21_FUNC_SSP0_SSEL = 0x3
	// Motor control PWM, active low fast abort.
	IOCON_P1_21_FUNC_MC_ABORT = 0x4
	// LCD data.
	IOCON_P1_21_FUNC_LCD_VD_7 = 0x6
	// LCD data.
	IOCON_P1_21_FUNC_LCD_VD_11 = 0x7
	// Position of MODE field.
	IOCON_P1_21_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_21_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_21_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_21_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_21_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_21_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_21_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_21_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_21_HYS = 0x20
	// Disable.
	IOCON_P1_21_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_21_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_21_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_21_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_21_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_21_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_21_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_21_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_21_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_21_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_21_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_21_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_21_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_21_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_21_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_21_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_21_OD = 0x400
	// Disable.
	IOCON_P1_21_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_21_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_21_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_21_RESERVED_Msk = 0xfffff800

	// P1_22: I/O configuration register for pin P1[22]
	// Position of FUNC field.
	IOCON_P1_22_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_22_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_22_FUNC_P1_22 = 0x0
	// Differential receive data for USB port 1 (OTG transceiver).
	IOCON_P1_22_FUNC_USB_RCV1 = 0x1
	// Power Status for USB port 1 (host power switch).
	IOCON_P1_22_FUNC_USB_PWRD1 = 0x2
	// Match output for Timer 1, channel 0.
	IOCON_P1_22_FUNC_T1_MAT0 = 0x3
	// Motor control PWM channel 0, output B.
	IOCON_P1_22_FUNC_MC_0B = 0x4
	// Master Out Slave In for SSP1.
	IOCON_P1_22_FUNC_SSP1_MOSI = 0x5
	// LCD data.
	IOCON_P1_22_FUNC_LCD_VD_8 = 0x6
	// LCD data.
	IOCON_P1_22_FUNC_LCD_VD_12 = 0x7
	// Position of MODE field.
	IOCON_P1_22_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_22_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_22_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_22_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_22_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_22_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_22_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_22_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_22_HYS = 0x20
	// Disable.
	IOCON_P1_22_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_22_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_22_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_22_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_22_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_22_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_22_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_22_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_22_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_22_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_22_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_22_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_22_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_22_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_22_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_22_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_22_OD = 0x400
	// Disable.
	IOCON_P1_22_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_22_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_22_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_22_RESERVED_Msk = 0xfffff800

	// P1_23: I/O configuration register for pin P1[23]
	// Position of FUNC field.
	IOCON_P1_23_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_23_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_23_FUNC_P1_23 = 0x0
	// D+ receive data for USB port 1 (OTG transceiver).
	IOCON_P1_23_FUNC_USB_RX_DP1 = 0x1
	// Pulse Width Modulator 1, channel 4 output.
	IOCON_P1_23_FUNC_PWM1_4 = 0x2
	// Quadrature Encoder Interface PHB input.
	IOCON_P1_23_FUNC_QEI_PHB = 0x3
	// Motor control PWM channel 1 feedback input.
	IOCON_P1_23_FUNC_MC_FB1 = 0x4
	// Master In Slave Out for SSP0.
	IOCON_P1_23_FUNC_SSP0_MISO = 0x5
	// LCD data.
	IOCON_P1_23_FUNC_LCD_VD_9 = 0x6
	// LCD data.
	IOCON_P1_23_FUNC_LCD_VD_13 = 0x7
	// Position of MODE field.
	IOCON_P1_23_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_23_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_23_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_23_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_23_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_23_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_23_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_23_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_23_HYS = 0x20
	// Disable.
	IOCON_P1_23_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_23_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_23_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_23_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_23_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_23_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_23_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_23_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_23_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_23_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_23_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_23_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_23_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_23_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_23_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_23_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_23_OD = 0x400
	// Disable.
	IOCON_P1_23_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_23_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_23_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_23_RESERVED_Msk = 0xfffff800

	// P1_24: I/O configuration register for pin P1[24]
	// Position of FUNC field.
	IOCON_P1_24_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_24_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_24_FUNC_P1_24 = 0x0
	// D- receive data for USB port 1 (OTG transceiver).
	IOCON_P1_24_FUNC_USB_RX_DM1 = 0x1
	// Pulse Width Modulator 1, channel 5 output.
	IOCON_P1_24_FUNC_PWM1_5 = 0x2
	// Quadrature Encoder Interface INDEX input.
	IOCON_P1_24_FUNC_QEI_IDX = 0x3
	// Motor control PWM channel 2 feedback input.
	IOCON_P1_24_FUNC_MC_FB2 = 0x4
	// Master Out Slave in for SSP0.
	IOCON_P1_24_FUNC_SSP0_MOSI = 0x5
	// LCD data.
	IOCON_P1_24_FUNC_LCD_VD_10 = 0x6
	// LCD data.
	IOCON_P1_24_FUNC_LCD_VD_14 = 0x7
	// Position of MODE field.
	IOCON_P1_24_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_24_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_24_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_24_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_24_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_24_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_24_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_24_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_24_HYS = 0x20
	// Disable.
	IOCON_P1_24_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_24_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_24_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_24_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_24_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_24_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_24_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_24_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_24_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_24_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_24_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_24_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_24_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_24_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_24_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_24_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_24_OD = 0x400
	// Disable.
	IOCON_P1_24_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_24_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_24_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_24_RESERVED_Msk = 0xfffff800

	// P1_25: I/O configuration register for pin P1[25]
	// Position of FUNC field.
	IOCON_P1_25_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_25_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_25_FUNC_P1_25 = 0x0
	// Low Speed status for USB port 1 (OTG transceiver).
	IOCON_P1_25_FUNC_USB_LS1 = 0x1
	// Host Enabled status for USB port 1.
	IOCON_P1_25_FUNC_USB_HSTEN1 = 0x2
	// Match output for Timer 1, channel 1.
	IOCON_P1_25_FUNC_T1_MAT1 = 0x3
	// Motor control PWM channel 1, output A.
	IOCON_P1_25_FUNC_MC_1A = 0x4
	// Selectable clock output.
	IOCON_P1_25_FUNC_CLKOUT = 0x5
	// LCD data.
	IOCON_P1_25_FUNC_LCD_VD_11 = 0x6
	// LCD data.
	IOCON_P1_25_FUNC_LCD_VD_15 = 0x7
	// Position of MODE field.
	IOCON_P1_25_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_25_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_25_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_25_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_25_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_25_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_25_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_25_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_25_HYS = 0x20
	// Disable.
	IOCON_P1_25_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_25_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_25_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_25_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_25_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_25_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_25_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_25_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_25_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_25_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_25_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_25_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_25_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_25_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_25_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_25_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_25_OD = 0x400
	// Disable.
	IOCON_P1_25_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_25_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_25_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_25_RESERVED_Msk = 0xfffff800

	// P1_26: I/O configuration register for pin P1[26]
	// Position of FUNC field.
	IOCON_P1_26_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_26_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_26_FUNC_P1_26 = 0x0
	// USB port 1 Bus Suspend status (OTG transceiver).
	IOCON_P1_26_FUNC_USB_SSPND1 = 0x1
	// Pulse Width Modulator 1, channel 6 output.
	IOCON_P1_26_FUNC_PWM1_6 = 0x2
	// Capture input for Timer 0, channel 0.
	IOCON_P1_26_FUNC_T0_CAP0 = 0x3
	// Motor control PWM channel 1, output B.
	IOCON_P1_26_FUNC_MC_1B = 0x4
	// Slave Select for SSP1.
	IOCON_P1_26_FUNC_SSP1_SSEL = 0x5
	// LCD data.
	IOCON_P1_26_FUNC_LCD_VD_12 = 0x6
	// LCD data.
	IOCON_P1_26_FUNC_LCD_VD_20 = 0x7
	// Position of MODE field.
	IOCON_P1_26_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_26_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_26_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_26_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_26_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_26_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_26_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_26_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_26_HYS = 0x20
	// Disable.
	IOCON_P1_26_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_26_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_26_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_26_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_26_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_26_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_26_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_26_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_26_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_26_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_26_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_26_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_26_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_26_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_26_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_26_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_26_OD = 0x400
	// Disable.
	IOCON_P1_26_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_26_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_26_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_26_RESERVED_Msk = 0xfffff800

	// P1_27: I/O configuration register for pin P1[27]
	// Position of FUNC field.
	IOCON_P1_27_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_27_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_27_FUNC_P1_27 = 0x0
	// USB port 1 OTG transceiver interrupt (OTG transceiver).
	IOCON_P1_27_FUNC_USB_INT1 = 0x1
	// USB port 1 Over-Current status.
	IOCON_P1_27_FUNC_USB_OVRCR1 = 0x2
	// Capture input for Timer 0, channel 1.
	IOCON_P1_27_FUNC_T0_CAP1 = 0x3
	// Selectable clock output.
	IOCON_P1_27_FUNC_CLKOUT = 0x4
	// LCD data.
	IOCON_P1_27_FUNC_LCD_VD_13 = 0x6
	// LCD data.
	IOCON_P1_27_FUNC_LCD_VD_21 = 0x7
	// Position of MODE field.
	IOCON_P1_27_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_27_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_27_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_27_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_27_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_27_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_27_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_27_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_27_HYS = 0x20
	// Disable.
	IOCON_P1_27_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_27_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_27_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_27_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_27_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_27_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_27_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_27_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_27_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_27_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_27_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_27_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_27_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_27_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_27_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_27_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_27_OD = 0x400
	// Disable.
	IOCON_P1_27_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_27_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_27_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_27_RESERVED_Msk = 0xfffff800

	// P1_28: I/O configuration register for pin P1[28]
	// Position of FUNC field.
	IOCON_P1_28_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_28_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_28_FUNC_P1_28 = 0x0
	// USB port 1 I2C serial clock (OTG transceiver).
	IOCON_P1_28_FUNC_USB_SCL1 = 0x1
	// Capture input for PWM1, channel 0.
	IOCON_P1_28_FUNC_PWM1_CAP0 = 0x2
	// Match output for Timer 0, channel 0.
	IOCON_P1_28_FUNC_T0_MAT0 = 0x3
	// Motor control PWM channel 2, output A.
	IOCON_P1_28_FUNC_MC_2A = 0x4
	// Slave Select for SSP0.
	IOCON_P1_28_FUNC_SSP0_SSEL = 0x5
	// LCD data.
	IOCON_P1_28_FUNC_LCD_VD_14 = 0x6
	// LCD data.
	IOCON_P1_28_FUNC_LCD_VD_22 = 0x7
	// Position of MODE field.
	IOCON_P1_28_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_28_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_28_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_28_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_28_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_28_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_28_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_28_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_28_HYS = 0x20
	// Disable.
	IOCON_P1_28_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_28_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_28_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_28_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_28_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_28_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_28_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_28_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_28_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_28_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_28_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_28_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_28_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_28_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_28_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_28_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_28_OD = 0x400
	// Disable.
	IOCON_P1_28_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_28_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_28_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_28_RESERVED_Msk = 0xfffff800

	// P1_29: I/O configuration register for pin P1[29]
	// Position of FUNC field.
	IOCON_P1_29_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_29_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_29_FUNC_P1_29 = 0x0
	// USB port 1 I2C serial data (OTG transceiver).
	IOCON_P1_29_FUNC_USB_SDA1 = 0x1
	// Capture input for PWM1, channel 1.
	IOCON_P1_29_FUNC_PWM1_CAP1 = 0x2
	// Match output for Timer 0, channel 1.
	IOCON_P1_29_FUNC_T0_MAT1 = 0x3
	// Motor control PWM channel 2, output B.
	IOCON_P1_29_FUNC_MC_2B = 0x4
	// Transmitter output for USART4 (input/output in smart card mode).
	IOCON_P1_29_FUNC_U4_TXD = 0x5
	// LCD data.
	IOCON_P1_29_FUNC_LCD_VD_15 = 0x6
	// LCD data.
	IOCON_P1_29_FUNC_LCD_VD_23 = 0x7
	// Position of MODE field.
	IOCON_P1_29_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P1_29_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P1_29_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P1_29_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P1_29_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P1_29_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P1_29_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P1_29_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P1_29_HYS = 0x20
	// Disable.
	IOCON_P1_29_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P1_29_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P1_29_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P1_29_INV_Msk = 0x40
	// Bit INV.
	IOCON_P1_29_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P1_29_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P1_29_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P1_29_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P1_29_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P1_29_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P1_29_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P1_29_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P1_29_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P1_29_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P1_29_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P1_29_OD_Msk = 0x400
	// Bit OD.
	IOCON_P1_29_OD = 0x400
	// Disable.
	IOCON_P1_29_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P1_29_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P1_29_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P1_29_RESERVED_Msk = 0xfffff800

	// P1_30: I/O configuration register for pin P1[30]
	// Position of FUNC field.
	IOCON_P1_30_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_30_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_30_FUNC_P1_30 = 0x0
	// Power Status for USB port 2.
	IOCON_P1_30_FUNC_USB_PWRD2 = 0x1
	// Monitors the presence of USB bus power.This signal must be HIGH for USB reset to occur.
	IOCON_P1_30_FUNC_USB_VBUS = 0x2
	// A/D converter 0, input 4. When configured as an ADC input, the digital function of the pin must be disabled.
	IOCON_P1_30_FUNC_ADC0_IN_4 = 0x3
	// I2C0 data input/output (this pin does not use a specialized I2C pad.
	IOCON_P1_30_FUNC_I2C0_SDA = 0x4
	// RS-485/EIA-485 output enable signal for UART3.
	IOCON_P1_30_FUNC_U3_OE = 0x5

	// P1_31: I/O configuration register for pin P1[31]
	// Position of FUNC field.
	IOCON_P1_31_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P1_31_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P1_31_FUNC_P1_31 = 0x0
	// Over-Current status for USB port 2.
	IOCON_P1_31_FUNC_USB_OVRCR2 = 0x1
	// Serial Clock for SSP1.
	IOCON_P1_31_FUNC_SSP1_SCK = 0x2
	// A/D converter 0, input 5. When configured as an ADC input, the digital function of the pin must be disabled.
	IOCON_P1_31_FUNC_ADC0_IN_5 = 0x3
	// I2C0 clock input/output (this pin does not use a specialized I2C pad.
	IOCON_P1_31_FUNC_I2C0_SCL = 0x4

	// P2_0: I/O configuration register for pin P2[0]
	// Position of FUNC field.
	IOCON_P2_0_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_0_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P2_0_FUNC_P2_0 = 0x0
	// Pulse Width Modulator 1, channel 1 output.
	IOCON_P2_0_FUNC_PWM1_1 = 0x1
	// Transmitter output for UART1.
	IOCON_P2_0_FUNC_U1_TXD = 0x2
	// LCD panel power enable.
	IOCON_P2_0_FUNC_LCD_PWR = 0x7
	// Position of MODE field.
	IOCON_P2_0_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P2_0_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P2_0_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P2_0_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P2_0_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P2_0_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P2_0_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P2_0_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P2_0_HYS = 0x20
	// Disable.
	IOCON_P2_0_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P2_0_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P2_0_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P2_0_INV_Msk = 0x40
	// Bit INV.
	IOCON_P2_0_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P2_0_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P2_0_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P2_0_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P2_0_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P2_0_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P2_0_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P2_0_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P2_0_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P2_0_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P2_0_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P2_0_OD_Msk = 0x400
	// Bit OD.
	IOCON_P2_0_OD = 0x400
	// Disable.
	IOCON_P2_0_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P2_0_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P2_0_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P2_0_RESERVED_Msk = 0xfffff800

	// P2_1: I/O configuration register for pin P2[1]
	// Position of FUNC field.
	IOCON_P2_1_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_1_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P2_1_FUNC_P2_1 = 0x0
	// Pulse Width Modulator 1, channel 2 output.
	IOCON_P2_1_FUNC_PWM1_2 = 0x1
	// Receiver input for UART1.
	IOCON_P2_1_FUNC_U1_RXD = 0x2
	// Line end signal.
	IOCON_P2_1_FUNC_LCD_LE = 0x7
	// Position of MODE field.
	IOCON_P2_1_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P2_1_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P2_1_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P2_1_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P2_1_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P2_1_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P2_1_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P2_1_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P2_1_HYS = 0x20
	// Disable.
	IOCON_P2_1_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P2_1_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P2_1_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P2_1_INV_Msk = 0x40
	// Bit INV.
	IOCON_P2_1_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P2_1_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P2_1_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P2_1_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P2_1_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P2_1_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P2_1_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P2_1_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P2_1_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P2_1_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P2_1_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P2_1_OD_Msk = 0x400
	// Bit OD.
	IOCON_P2_1_OD = 0x400
	// Disable.
	IOCON_P2_1_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P2_1_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P2_1_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P2_1_RESERVED_Msk = 0xfffff800

	// P2_2: I/O configuration register for pin P2[2]
	// Position of FUNC field.
	IOCON_P2_2_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_2_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P2_2_FUNC_P2_2 = 0x0
	// Pulse Width Modulator 1, channel 3 output.
	IOCON_P2_2_FUNC_PWM1_3 = 0x1
	// Clear to Send input for UART1.
	IOCON_P2_2_FUNC_U1_CTS = 0x2
	// Match output for Timer 2, channel 3.
	IOCON_P2_2_FUNC_T2_MAT3 = 0x3
	// Trace data, bit 3.
	IOCON_P2_2_FUNC_TRACEDATA_3 = 0x5
	// LCD panel clock.
	IOCON_P2_2_FUNC_LCD_DCLK = 0x7
	// Position of MODE field.
	IOCON_P2_2_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P2_2_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P2_2_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P2_2_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P2_2_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P2_2_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P2_2_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P2_2_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P2_2_HYS = 0x20
	// Disable.
	IOCON_P2_2_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P2_2_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P2_2_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P2_2_INV_Msk = 0x40
	// Bit INV.
	IOCON_P2_2_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P2_2_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P2_2_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P2_2_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P2_2_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P2_2_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P2_2_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P2_2_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P2_2_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P2_2_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P2_2_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P2_2_OD_Msk = 0x400
	// Bit OD.
	IOCON_P2_2_OD = 0x400
	// Disable.
	IOCON_P2_2_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P2_2_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P2_2_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P2_2_RESERVED_Msk = 0xfffff800

	// P2_3: I/O configuration register for pin P2[3]
	// Position of FUNC field.
	IOCON_P2_3_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_3_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P2_3_FUNC_P2_3 = 0x0
	// Pulse Width Modulator 1, channel 4 output.
	IOCON_P2_3_FUNC_PWM1_4 = 0x1
	// Data Carrier Detect input for UART1.
	IOCON_P2_3_FUNC_U1_DCD = 0x2
	// Match output for Timer 2, channel 2.
	IOCON_P2_3_FUNC_T2_MAT2 = 0x3
	// Trace data, bit 2.
	IOCON_P2_3_FUNC_TRACEDATA_2 = 0x5
	// Frame pulse (STN). Vertical synchronization pulse (TFT).
	IOCON_P2_3_FUNC_LCD_FP = 0x7
	// Position of MODE field.
	IOCON_P2_3_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P2_3_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P2_3_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P2_3_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P2_3_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P2_3_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P2_3_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P2_3_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P2_3_HYS = 0x20
	// Disable.
	IOCON_P2_3_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P2_3_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P2_3_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P2_3_INV_Msk = 0x40
	// Bit INV.
	IOCON_P2_3_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P2_3_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P2_3_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P2_3_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P2_3_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P2_3_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P2_3_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P2_3_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P2_3_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P2_3_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P2_3_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P2_3_OD_Msk = 0x400
	// Bit OD.
	IOCON_P2_3_OD = 0x400
	// Disable.
	IOCON_P2_3_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P2_3_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P2_3_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P2_3_RESERVED_Msk = 0xfffff800

	// P2_4: I/O configuration register for pin P2[4]
	// Position of FUNC field.
	IOCON_P2_4_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_4_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P2_4_FUNC_P2_4 = 0x0
	// Pulse Width Modulator 1, channel 5 output.
	IOCON_P2_4_FUNC_PWM1_5 = 0x1
	// Data Set Ready input for UART1.
	IOCON_P2_4_FUNC_U1_DSR = 0x2
	// Match output for Timer 2, channel 1.
	IOCON_P2_4_FUNC_T2_MAT1 = 0x3
	// Trace data, bit 1.
	IOCON_P2_4_FUNC_TRACEDATA_1 = 0x5
	// STN AC bias drive or TFT data enable output.
	IOCON_P2_4_FUNC_LCD_ENAB_M = 0x7
	// Position of MODE field.
	IOCON_P2_4_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P2_4_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P2_4_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P2_4_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P2_4_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P2_4_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P2_4_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P2_4_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P2_4_HYS = 0x20
	// Disable.
	IOCON_P2_4_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P2_4_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P2_4_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P2_4_INV_Msk = 0x40
	// Bit INV.
	IOCON_P2_4_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P2_4_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P2_4_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P2_4_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P2_4_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P2_4_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P2_4_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P2_4_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P2_4_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P2_4_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P2_4_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P2_4_OD_Msk = 0x400
	// Bit OD.
	IOCON_P2_4_OD = 0x400
	// Disable.
	IOCON_P2_4_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P2_4_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P2_4_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P2_4_RESERVED_Msk = 0xfffff800

	// P2_5: I/O configuration register for pin P2[5]
	// Position of FUNC field.
	IOCON_P2_5_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_5_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P2_5_FUNC_P2_5 = 0x0
	// Pulse Width Modulator 1, channel 6 output.
	IOCON_P2_5_FUNC_PWM1_6 = 0x1
	// Data Terminal Ready output for UART1. Can also be configured to be an RS-485/EIA-485 output enable signal for UART1.
	IOCON_P2_5_FUNC_U1_DTR = 0x2
	// Match output for Timer 2, channel 0.
	IOCON_P2_5_FUNC_T2_MAT0 = 0x3
	// Trace data, bit 0.
	IOCON_P2_5_FUNC_TRACEDATA_0 = 0x5
	// Line synchronization pulse (STN). Horizontal synchronization pulse (TFT).
	IOCON_P2_5_FUNC_LCD_LP = 0x7
	// Position of MODE field.
	IOCON_P2_5_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P2_5_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P2_5_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P2_5_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P2_5_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P2_5_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P2_5_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P2_5_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P2_5_HYS = 0x20
	// Disable.
	IOCON_P2_5_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P2_5_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P2_5_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P2_5_INV_Msk = 0x40
	// Bit INV.
	IOCON_P2_5_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P2_5_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P2_5_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P2_5_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P2_5_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P2_5_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P2_5_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P2_5_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P2_5_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P2_5_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P2_5_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P2_5_OD_Msk = 0x400
	// Bit OD.
	IOCON_P2_5_OD = 0x400
	// Disable.
	IOCON_P2_5_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P2_5_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P2_5_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P2_5_RESERVED_Msk = 0xfffff800

	// P2_6: I/O configuration register for pin P2[6]
	// Position of FUNC field.
	IOCON_P2_6_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_6_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P2_6_FUNC_P2_6 = 0x0
	// Capture input for PWM1, channel 0.
	IOCON_P2_6_FUNC_PWM1_CAP0 = 0x1
	// Ring Indicator input for UART1.
	IOCON_P2_6_FUNC_U1_RI = 0x2
	// Capture input for Timer 2, channel 0.
	IOCON_P2_6_FUNC_T2_CAP0 = 0x3
	// RS-485/EIA-485 output enable signal for UART2.
	IOCON_P2_6_FUNC_U2_OE = 0x4
	// Trace clock.
	IOCON_P2_6_FUNC_TRACECLK = 0x5
	// LCD data.
	IOCON_P2_6_FUNC_LCD_VD_0 = 0x6
	// LCD data.
	IOCON_P2_6_FUNC_LCD_VD_4 = 0x7
	// Position of MODE field.
	IOCON_P2_6_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P2_6_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P2_6_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P2_6_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P2_6_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P2_6_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P2_6_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P2_6_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P2_6_HYS = 0x20
	// Disable.
	IOCON_P2_6_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P2_6_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P2_6_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P2_6_INV_Msk = 0x40
	// Bit INV.
	IOCON_P2_6_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P2_6_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P2_6_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P2_6_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P2_6_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P2_6_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P2_6_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P2_6_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P2_6_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P2_6_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P2_6_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P2_6_OD_Msk = 0x400
	// Bit OD.
	IOCON_P2_6_OD = 0x400
	// Disable.
	IOCON_P2_6_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P2_6_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P2_6_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P2_6_RESERVED_Msk = 0xfffff800

	// P2_7: I/O configuration register for pin P2[7]
	// Position of FUNC field.
	IOCON_P2_7_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_7_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P2_7_FUNC_P2_7 = 0x0
	// CAN2 receiver input.
	IOCON_P2_7_FUNC_CAN_RD2 = 0x1
	// Request to Send output for UART1. Can also be configured to be an RS-485/EIA-485 output enable signal for UART1.
	IOCON_P2_7_FUNC_U1_RTS = 0x2
	// Chip select output for SPIFI.
	IOCON_P2_7_FUNC_SPIFI_CS = 0x5
	// LCD data.
	IOCON_P2_7_FUNC_LCD_VD_1 = 0x6
	// LCD data.
	IOCON_P2_7_FUNC_LCD_VD_5 = 0x7
	// Position of MODE field.
	IOCON_P2_7_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P2_7_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P2_7_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P2_7_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P2_7_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P2_7_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P2_7_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P2_7_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P2_7_HYS = 0x20
	// Disable.
	IOCON_P2_7_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P2_7_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P2_7_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P2_7_INV_Msk = 0x40
	// Bit INV.
	IOCON_P2_7_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P2_7_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P2_7_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P2_7_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P2_7_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P2_7_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P2_7_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P2_7_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P2_7_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P2_7_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P2_7_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P2_7_OD_Msk = 0x400
	// Bit OD.
	IOCON_P2_7_OD = 0x400
	// Disable.
	IOCON_P2_7_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P2_7_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P2_7_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P2_7_RESERVED_Msk = 0xfffff800

	// P2_8: I/O configuration register for pin P2[8]
	// Position of FUNC field.
	IOCON_P2_8_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_8_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P2_8_FUNC_P2_8 = 0x0
	// CAN2 transmitter output.
	IOCON_P2_8_FUNC_CAN_TD2 = 0x1
	// Transmitter output for UART2.
	IOCON_P2_8_FUNC_U2_TXD = 0x2
	// Clear to Send input for UART1.
	IOCON_P2_8_FUNC_U1_CTS = 0x3
	// Ethernet MIIM clock.
	IOCON_P2_8_FUNC_ENET_MDC = 0x4
	// LCD data.
	IOCON_P2_8_FUNC_LCD_VD_2 = 0x6
	// LCD data.
	IOCON_P2_8_FUNC_LCD_VD_6 = 0x7
	// Position of MODE field.
	IOCON_P2_8_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P2_8_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P2_8_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P2_8_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P2_8_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P2_8_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P2_8_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P2_8_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P2_8_HYS = 0x20
	// Disable.
	IOCON_P2_8_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P2_8_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P2_8_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P2_8_INV_Msk = 0x40
	// Bit INV.
	IOCON_P2_8_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P2_8_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P2_8_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P2_8_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P2_8_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P2_8_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P2_8_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P2_8_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P2_8_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P2_8_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P2_8_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P2_8_OD_Msk = 0x400
	// Bit OD.
	IOCON_P2_8_OD = 0x400
	// Disable.
	IOCON_P2_8_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P2_8_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P2_8_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P2_8_RESERVED_Msk = 0xfffff800

	// P2_9: I/O configuration register for pin P2[9]
	// Position of FUNC field.
	IOCON_P2_9_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_9_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P2_9_FUNC_P2_9 = 0x0
	// USB1 SoftConnect control. Signal used to switch an external 1.5 kW resistor under the software control. Used with the SoftConnect USB feature.
	IOCON_P2_9_FUNC_USB_CONNECT1 = 0x1
	// Receiver input for UART2.
	IOCON_P2_9_FUNC_U2_RXD = 0x2
	// Receiver input for USART4.
	IOCON_P2_9_FUNC_U4_RXD = 0x3
	// Ethernet MIIM data input and output.
	IOCON_P2_9_FUNC_ENET_MDIO = 0x4
	// LCD data.
	IOCON_P2_9_FUNC_LCD_VD_3 = 0x6
	// LCD data.
	IOCON_P2_9_FUNC_LCD_VD_7 = 0x7
	// Position of MODE field.
	IOCON_P2_9_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P2_9_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P2_9_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P2_9_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P2_9_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P2_9_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P2_9_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P2_9_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P2_9_HYS = 0x20
	// Disable.
	IOCON_P2_9_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P2_9_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P2_9_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P2_9_INV_Msk = 0x40
	// Bit INV.
	IOCON_P2_9_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P2_9_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P2_9_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P2_9_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P2_9_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P2_9_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P2_9_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P2_9_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P2_9_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P2_9_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P2_9_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P2_9_OD_Msk = 0x400
	// Bit OD.
	IOCON_P2_9_OD = 0x400
	// Disable.
	IOCON_P2_9_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P2_9_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P2_9_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P2_9_RESERVED_Msk = 0xfffff800

	// P2_10: I/O configuration register for pin P2[10]
	// Position of FUNC field.
	IOCON_P2_10_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_10_FUNC_Msk = 0x7
	// General purpose digital input/output pin. This pin includes a 5 ns input glitch filter.A LOW on this pin while RESET is LOW forces the on-chip boot loader to take over control of the part after a reset and go into ISP mode.
	IOCON_P2_10_FUNC_P2_10 = 0x0
	// External interrupt 0 input.
	IOCON_P2_10_FUNC_EINT0 = 0x1
	// Non-maskable interrupt input.
	IOCON_P2_10_FUNC_NMI = 0x2

	// P2_11: I/O configuration register for pin P2[11]
	// Position of FUNC field.
	IOCON_P2_11_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_11_FUNC_Msk = 0x7
	// General purpose digital input/output pin. This pin includes a 5 ns input glitch filter.
	IOCON_P2_11_FUNC_P2_11 = 0x0
	// External interrupt 1 input.
	IOCON_P2_11_FUNC_EINT1 = 0x1
	// Data line 1 for SD card interface.
	IOCON_P2_11_FUNC_SD_DAT_1 = 0x2
	// Transmit Clock. It is driven by the master and received by the slave. Corresponds to the signal SCK in the I2S-bus specification.
	IOCON_P2_11_FUNC_I2S_TX_SCK = 0x3
	// LCD clock.
	IOCON_P2_11_FUNC_LCD_CLKIN = 0x7

	// P2_12: I/O configuration register for pin P2[12]
	// Position of FUNC field.
	IOCON_P2_12_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_12_FUNC_Msk = 0x7
	// General purpose digital input/output pin. This pin includes a 5 ns input glitch filter.
	IOCON_P2_12_FUNC_P2_12 = 0x0
	// External interrupt 2 input.
	IOCON_P2_12_FUNC_EINT2 = 0x1
	// Data line 2 for SD card interface.
	IOCON_P2_12_FUNC_SD_DAT_2 = 0x2
	// Transmit Word Select. It is driven by the master and received by the slave. Corresponds to the signal WS in the I2S-bus specification.
	IOCON_P2_12_FUNC_I2S_TX_WS = 0x3
	// LCD data.
	IOCON_P2_12_FUNC_LCD_VD_4 = 0x4
	// LCD data.
	IOCON_P2_12_FUNC_LCD_VD_3 = 0x5
	// LCD data.
	IOCON_P2_12_FUNC_LCD_VD_8 = 0x6
	// LCD data.
	IOCON_P2_12_FUNC_LCD_VD_18 = 0x7

	// P2_13: I/O configuration register for pin P2[13]
	// Position of FUNC field.
	IOCON_P2_13_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_13_FUNC_Msk = 0x7
	// General purpose digital input/output pin. This pin includes a 5 ns input glitch filter.
	IOCON_P2_13_FUNC_P2_13 = 0x0
	// External interrupt 3 input.
	IOCON_P2_13_FUNC_EINT3 = 0x1
	// Data line 3 for SD card interface.
	IOCON_P2_13_FUNC_SD_DAT_3 = 0x2
	// Transmit data. It is driven by the transmitter and read by the receiver. Corresponds to the signal SD in the I2S-bus specification.
	IOCON_P2_13_FUNC_I2S_TX_SDA = 0x3
	// LCD data.
	IOCON_P2_13_FUNC_LCD_VD_5 = 0x5
	// LCD data.
	IOCON_P2_13_FUNC_LCD_VD_9 = 0x6
	// LCD data.
	IOCON_P2_13_FUNC_LCD_VD_19 = 0x7

	// P2_14: I/O configuration register for pin P2[14]
	// Position of FUNC field.
	IOCON_P2_14_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_14_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P2_14_FUNC_P2_14 = 0x0
	// LOW active Chip Select 2 signal.
	IOCON_P2_14_FUNC_EMC_CS2 = 0x1
	// I2C1 data input/output (this pin does not use a specialized I2C pad).
	IOCON_P2_14_FUNC_I2C1_SDA = 0x2
	// Capture input for Timer 2, channel 0.
	IOCON_P2_14_FUNC_T2_CAP0 = 0x3
	// Position of MODE field.
	IOCON_P2_14_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P2_14_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P2_14_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P2_14_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P2_14_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P2_14_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P2_14_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P2_14_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P2_14_HYS = 0x20
	// Disable.
	IOCON_P2_14_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P2_14_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P2_14_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P2_14_INV_Msk = 0x40
	// Bit INV.
	IOCON_P2_14_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P2_14_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P2_14_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P2_14_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P2_14_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P2_14_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P2_14_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P2_14_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P2_14_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P2_14_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P2_14_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P2_14_OD_Msk = 0x400
	// Bit OD.
	IOCON_P2_14_OD = 0x400
	// Disable.
	IOCON_P2_14_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P2_14_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P2_14_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P2_14_RESERVED_Msk = 0xfffff800

	// P2_15: I/O configuration register for pin P2[15]
	// Position of FUNC field.
	IOCON_P2_15_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_15_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P2_15_FUNC_P2_15 = 0x0
	// LOW active Chip Select 3 signal.
	IOCON_P2_15_FUNC_EMC_CS3 = 0x1
	// I2C1 clock input/output (this pin does not use a specialized I2C pad).
	IOCON_P2_15_FUNC_I2C1_SCL = 0x2
	// Capture input for Timer 2, channel 1.
	IOCON_P2_15_FUNC_T2_CAP1 = 0x3
	// Position of MODE field.
	IOCON_P2_15_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P2_15_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P2_15_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P2_15_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P2_15_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P2_15_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P2_15_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P2_15_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P2_15_HYS = 0x20
	// Disable.
	IOCON_P2_15_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P2_15_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P2_15_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P2_15_INV_Msk = 0x40
	// Bit INV.
	IOCON_P2_15_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P2_15_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P2_15_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P2_15_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P2_15_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P2_15_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P2_15_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P2_15_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P2_15_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P2_15_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P2_15_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P2_15_OD_Msk = 0x400
	// Bit OD.
	IOCON_P2_15_OD = 0x400
	// Disable.
	IOCON_P2_15_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P2_15_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P2_15_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P2_15_RESERVED_Msk = 0xfffff800

	// P2_16: I/O configuration register for pin P2[16]
	// Position of FUNC field.
	IOCON_P2_16_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_16_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P2_16_FUNC_P2_16 = 0x0
	// LOW active SDRAM Column Address Strobe.
	IOCON_P2_16_FUNC_EMC_CAS = 0x1
	// Position of MODE field.
	IOCON_P2_16_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P2_16_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P2_16_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P2_16_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P2_16_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P2_16_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P2_16_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P2_16_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P2_16_HYS = 0x20
	// Disable.
	IOCON_P2_16_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P2_16_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P2_16_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P2_16_INV_Msk = 0x40
	// Bit INV.
	IOCON_P2_16_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P2_16_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P2_16_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P2_16_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P2_16_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P2_16_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P2_16_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P2_16_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P2_16_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P2_16_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P2_16_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P2_16_OD_Msk = 0x400
	// Bit OD.
	IOCON_P2_16_OD = 0x400
	// Disable.
	IOCON_P2_16_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P2_16_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P2_16_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P2_16_RESERVED_Msk = 0xfffff800

	// P2_17: I/O configuration register for pin P2[17]
	// Position of FUNC field.
	IOCON_P2_17_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_17_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P2_17_FUNC_P2_17 = 0x0
	// LOW active SDRAM Row Address Strobe.
	IOCON_P2_17_FUNC_EMC_RAS = 0x1
	// Position of MODE field.
	IOCON_P2_17_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P2_17_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P2_17_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P2_17_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P2_17_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P2_17_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P2_17_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P2_17_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P2_17_HYS = 0x20
	// Disable.
	IOCON_P2_17_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P2_17_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P2_17_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P2_17_INV_Msk = 0x40
	// Bit INV.
	IOCON_P2_17_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P2_17_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P2_17_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P2_17_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P2_17_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P2_17_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P2_17_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P2_17_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P2_17_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P2_17_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P2_17_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P2_17_OD_Msk = 0x400
	// Bit OD.
	IOCON_P2_17_OD = 0x400
	// Disable.
	IOCON_P2_17_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P2_17_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P2_17_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P2_17_RESERVED_Msk = 0xfffff800

	// P2_18: I/O configuration register for pin P2[18]
	// Position of FUNC field.
	IOCON_P2_18_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_18_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P2_18_FUNC_P2_18 = 0x0
	// SDRAM clock 0.
	IOCON_P2_18_FUNC_EMC_CLK_0 = 0x1
	// Position of MODE field.
	IOCON_P2_18_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P2_18_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P2_18_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P2_18_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P2_18_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P2_18_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P2_18_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P2_18_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P2_18_HYS = 0x20
	// Disable.
	IOCON_P2_18_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P2_18_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P2_18_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P2_18_INV_Msk = 0x40
	// Bit INV.
	IOCON_P2_18_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P2_18_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P2_18_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of ADMODE field.
	IOCON_P2_18_ADMODE_Pos = 0x7
	// Bit mask of ADMODE field.
	IOCON_P2_18_ADMODE_Msk = 0x80
	// Bit ADMODE.
	IOCON_P2_18_ADMODE = 0x80
	// Analog input mode.
	IOCON_P2_18_ADMODE_ANALOG_INPUT_MODE_ = 0x0
	// Digital functional mode.
	IOCON_P2_18_ADMODE_DIGITAL_FUNCTIONAL_M = 0x1
	// Position of FILTR field.
	IOCON_P2_18_FILTR_Pos = 0x8
	// Bit mask of FILTR field.
	IOCON_P2_18_FILTR_Msk = 0x100
	// Bit FILTR.
	IOCON_P2_18_FILTR = 0x100
	// Filter disabled.
	IOCON_P2_18_FILTR_FILTER_DISABLED_ = 0x0
	// Filter enabled.
	IOCON_P2_18_FILTR_FILTER_ENABLED_ = 0x1
	// Position of RESERVED field.
	IOCON_P2_18_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	IOCON_P2_18_RESERVED_Msk = 0x200
	// Bit RESERVED.
	IOCON_P2_18_RESERVED = 0x200
	// Position of OD field.
	IOCON_P2_18_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P2_18_OD_Msk = 0x400
	// Bit OD.
	IOCON_P2_18_OD = 0x400
	// Disable.
	IOCON_P2_18_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode.
	IOCON_P2_18_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P2_18_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P2_18_RESERVED_Msk = 0xfffff800

	// P2_19: I/O configuration register for pin P2[19]
	// Position of FUNC field.
	IOCON_P2_19_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_19_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P2_19_FUNC_P2_19 = 0x0
	// SDRAM clock 1.
	IOCON_P2_19_FUNC_EMC_CLK_1 = 0x1
	// Position of MODE field.
	IOCON_P2_19_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P2_19_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P2_19_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P2_19_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P2_19_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P2_19_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P2_19_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P2_19_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P2_19_HYS = 0x20
	// Disable.
	IOCON_P2_19_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P2_19_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P2_19_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P2_19_INV_Msk = 0x40
	// Bit INV.
	IOCON_P2_19_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P2_19_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P2_19_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of ADMODE field.
	IOCON_P2_19_ADMODE_Pos = 0x7
	// Bit mask of ADMODE field.
	IOCON_P2_19_ADMODE_Msk = 0x80
	// Bit ADMODE.
	IOCON_P2_19_ADMODE = 0x80
	// Analog input mode.
	IOCON_P2_19_ADMODE_ANALOG_INPUT_MODE_ = 0x0
	// Digital functional mode.
	IOCON_P2_19_ADMODE_DIGITAL_FUNCTIONAL_M = 0x1
	// Position of FILTR field.
	IOCON_P2_19_FILTR_Pos = 0x8
	// Bit mask of FILTR field.
	IOCON_P2_19_FILTR_Msk = 0x100
	// Bit FILTR.
	IOCON_P2_19_FILTR = 0x100
	// Filter disabled.
	IOCON_P2_19_FILTR_FILTER_DISABLED_ = 0x0
	// Filter enabled.
	IOCON_P2_19_FILTR_FILTER_ENABLED_ = 0x1
	// Position of RESERVED field.
	IOCON_P2_19_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	IOCON_P2_19_RESERVED_Msk = 0x200
	// Bit RESERVED.
	IOCON_P2_19_RESERVED = 0x200
	// Position of OD field.
	IOCON_P2_19_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P2_19_OD_Msk = 0x400
	// Bit OD.
	IOCON_P2_19_OD = 0x400
	// Disable.
	IOCON_P2_19_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode.
	IOCON_P2_19_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P2_19_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P2_19_RESERVED_Msk = 0xfffff800

	// P2_20: I/O configuration register for pin P2[20]
	// Position of FUNC field.
	IOCON_P2_20_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_20_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P2_20_FUNC_P2_20 = 0x0
	// SDRAM chip select 0.
	IOCON_P2_20_FUNC_EMC_DYCS0 = 0x1
	// Position of MODE field.
	IOCON_P2_20_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P2_20_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P2_20_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P2_20_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P2_20_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P2_20_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P2_20_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P2_20_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P2_20_HYS = 0x20
	// Disable.
	IOCON_P2_20_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P2_20_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P2_20_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P2_20_INV_Msk = 0x40
	// Bit INV.
	IOCON_P2_20_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P2_20_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P2_20_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P2_20_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P2_20_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P2_20_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P2_20_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P2_20_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P2_20_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P2_20_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P2_20_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P2_20_OD_Msk = 0x400
	// Bit OD.
	IOCON_P2_20_OD = 0x400
	// Disable.
	IOCON_P2_20_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P2_20_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P2_20_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P2_20_RESERVED_Msk = 0xfffff800

	// P2_21: I/O configuration register for pin P2[21]
	// Position of FUNC field.
	IOCON_P2_21_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_21_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P2_21_FUNC_P2_21 = 0x0
	// SDRAM chip select 1.
	IOCON_P2_21_FUNC_EMC_DYCS1 = 0x1
	// Position of MODE field.
	IOCON_P2_21_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P2_21_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P2_21_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P2_21_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P2_21_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P2_21_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P2_21_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P2_21_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P2_21_HYS = 0x20
	// Disable.
	IOCON_P2_21_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P2_21_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P2_21_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P2_21_INV_Msk = 0x40
	// Bit INV.
	IOCON_P2_21_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P2_21_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P2_21_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P2_21_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P2_21_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P2_21_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P2_21_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P2_21_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P2_21_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P2_21_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P2_21_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P2_21_OD_Msk = 0x400
	// Bit OD.
	IOCON_P2_21_OD = 0x400
	// Disable.
	IOCON_P2_21_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P2_21_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P2_21_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P2_21_RESERVED_Msk = 0xfffff800

	// P2_22: I/O configuration register for pin P2[22]
	// Position of FUNC field.
	IOCON_P2_22_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_22_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P2_22_FUNC_P2_22 = 0x0
	// SDRAM chip select 2.
	IOCON_P2_22_FUNC_EMC_DYCS2 = 0x1
	// Serial clock for SSP0.
	IOCON_P2_22_FUNC_SSP0_SCK = 0x2
	// Capture input for Timer 3, channel 0.
	IOCON_P2_22_FUNC_T3_CAP0 = 0x3
	// Position of MODE field.
	IOCON_P2_22_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P2_22_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P2_22_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P2_22_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P2_22_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P2_22_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P2_22_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P2_22_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P2_22_HYS = 0x20
	// Disable.
	IOCON_P2_22_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P2_22_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P2_22_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P2_22_INV_Msk = 0x40
	// Bit INV.
	IOCON_P2_22_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P2_22_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P2_22_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P2_22_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P2_22_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P2_22_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P2_22_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P2_22_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P2_22_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P2_22_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P2_22_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P2_22_OD_Msk = 0x400
	// Bit OD.
	IOCON_P2_22_OD = 0x400
	// Disable.
	IOCON_P2_22_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P2_22_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P2_22_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P2_22_RESERVED_Msk = 0xfffff800

	// P2_23: I/O configuration register for pin P2[23]
	// Position of FUNC field.
	IOCON_P2_23_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_23_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P2_23_FUNC_P2_23 = 0x0
	// SDRAM chip select 3.
	IOCON_P2_23_FUNC_EMC_DYCS3 = 0x1
	// Slave Select for SSP0.
	IOCON_P2_23_FUNC_SSP0_SSEL = 0x2
	// Capture input for Timer 3, channel 1.
	IOCON_P2_23_FUNC_T3_CAP1 = 0x3
	// Position of MODE field.
	IOCON_P2_23_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P2_23_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P2_23_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P2_23_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P2_23_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P2_23_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P2_23_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P2_23_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P2_23_HYS = 0x20
	// Disable.
	IOCON_P2_23_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P2_23_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P2_23_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P2_23_INV_Msk = 0x40
	// Bit INV.
	IOCON_P2_23_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P2_23_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P2_23_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P2_23_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P2_23_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P2_23_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P2_23_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P2_23_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P2_23_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P2_23_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P2_23_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P2_23_OD_Msk = 0x400
	// Bit OD.
	IOCON_P2_23_OD = 0x400
	// Disable.
	IOCON_P2_23_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P2_23_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P2_23_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P2_23_RESERVED_Msk = 0xfffff800

	// P2_24: I/O configuration register for pin P2[24]
	// Position of FUNC field.
	IOCON_P2_24_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_24_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P2_24_FUNC_P2_24 = 0x0
	// SDRAM clock enable 0.
	IOCON_P2_24_FUNC_EMC_CKE0 = 0x1
	// Position of MODE field.
	IOCON_P2_24_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P2_24_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P2_24_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P2_24_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P2_24_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P2_24_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P2_24_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P2_24_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P2_24_HYS = 0x20
	// Disable.
	IOCON_P2_24_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P2_24_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P2_24_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P2_24_INV_Msk = 0x40
	// Bit INV.
	IOCON_P2_24_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P2_24_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P2_24_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P2_24_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P2_24_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P2_24_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P2_24_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P2_24_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P2_24_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P2_24_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P2_24_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P2_24_OD_Msk = 0x400
	// Bit OD.
	IOCON_P2_24_OD = 0x400
	// Disable.
	IOCON_P2_24_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P2_24_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P2_24_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P2_24_RESERVED_Msk = 0xfffff800

	// P2_25: I/O configuration register for pin P2[25]
	// Position of FUNC field.
	IOCON_P2_25_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_25_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P2_25_FUNC_P2_25 = 0x0
	// SDRAM clock enable 1.
	IOCON_P2_25_FUNC_EMC_CKE1 = 0x1
	// Position of MODE field.
	IOCON_P2_25_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P2_25_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P2_25_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P2_25_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P2_25_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P2_25_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P2_25_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P2_25_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P2_25_HYS = 0x20
	// Disable.
	IOCON_P2_25_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P2_25_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P2_25_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P2_25_INV_Msk = 0x40
	// Bit INV.
	IOCON_P2_25_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P2_25_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P2_25_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P2_25_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P2_25_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P2_25_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P2_25_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P2_25_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P2_25_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P2_25_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P2_25_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P2_25_OD_Msk = 0x400
	// Bit OD.
	IOCON_P2_25_OD = 0x400
	// Disable.
	IOCON_P2_25_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P2_25_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P2_25_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P2_25_RESERVED_Msk = 0xfffff800

	// P2_26: I/O configuration register for pin P2[26]
	// Position of FUNC field.
	IOCON_P2_26_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_26_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P2_26_FUNC_P2_26 = 0x0
	// SDRAM clock enable 2.
	IOCON_P2_26_FUNC_EMC_CKE2 = 0x1
	// Master In Slave Out for SSP0.
	IOCON_P2_26_FUNC_SSP0_MISO = 0x2
	// Match output for Timer 3, channel 0.
	IOCON_P2_26_FUNC_T3_MAT0 = 0x3
	// Position of MODE field.
	IOCON_P2_26_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P2_26_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P2_26_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P2_26_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P2_26_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P2_26_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P2_26_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P2_26_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P2_26_HYS = 0x20
	// Disable.
	IOCON_P2_26_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P2_26_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P2_26_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P2_26_INV_Msk = 0x40
	// Bit INV.
	IOCON_P2_26_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P2_26_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P2_26_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P2_26_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P2_26_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P2_26_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P2_26_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P2_26_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P2_26_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P2_26_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P2_26_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P2_26_OD_Msk = 0x400
	// Bit OD.
	IOCON_P2_26_OD = 0x400
	// Disable.
	IOCON_P2_26_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P2_26_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P2_26_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P2_26_RESERVED_Msk = 0xfffff800

	// P2_27: I/O configuration register for pin P2[27]
	// Position of FUNC field.
	IOCON_P2_27_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_27_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P2_27_FUNC_P2_27 = 0x0
	// SDRAM clock enable 3.
	IOCON_P2_27_FUNC_EMC_CKE3 = 0x1
	// Master Out Slave In for SSP0.
	IOCON_P2_27_FUNC_SSP0_MOSI = 0x2
	// Match output for Timer 3, channel 1.
	IOCON_P2_27_FUNC_T3_MAT1 = 0x3
	// Position of MODE field.
	IOCON_P2_27_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P2_27_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P2_27_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P2_27_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P2_27_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P2_27_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P2_27_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P2_27_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P2_27_HYS = 0x20
	// Disable.
	IOCON_P2_27_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P2_27_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P2_27_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P2_27_INV_Msk = 0x40
	// Bit INV.
	IOCON_P2_27_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P2_27_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P2_27_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P2_27_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P2_27_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P2_27_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P2_27_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P2_27_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P2_27_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P2_27_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P2_27_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P2_27_OD_Msk = 0x400
	// Bit OD.
	IOCON_P2_27_OD = 0x400
	// Disable.
	IOCON_P2_27_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P2_27_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P2_27_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P2_27_RESERVED_Msk = 0xfffff800

	// P2_28: I/O configuration register for pin P2[28]
	// Position of FUNC field.
	IOCON_P2_28_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_28_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P2_28_FUNC_P2_28 = 0x0
	// Data mask 0 used with SDRAM and static devices.
	IOCON_P2_28_FUNC_EMC_DQM0 = 0x1
	// Position of MODE field.
	IOCON_P2_28_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P2_28_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P2_28_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P2_28_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P2_28_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P2_28_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P2_28_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P2_28_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P2_28_HYS = 0x20
	// Disable.
	IOCON_P2_28_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P2_28_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P2_28_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P2_28_INV_Msk = 0x40
	// Bit INV.
	IOCON_P2_28_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P2_28_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P2_28_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P2_28_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P2_28_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P2_28_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P2_28_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P2_28_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P2_28_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P2_28_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P2_28_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P2_28_OD_Msk = 0x400
	// Bit OD.
	IOCON_P2_28_OD = 0x400
	// Disable.
	IOCON_P2_28_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P2_28_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P2_28_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P2_28_RESERVED_Msk = 0xfffff800

	// P2_29: I/O configuration register for pin P2[29]
	// Position of FUNC field.
	IOCON_P2_29_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_29_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P2_29_FUNC_P2_29 = 0x0
	// Data mask 1 used with SDRAM and static devices.
	IOCON_P2_29_FUNC_EMC_DQM1 = 0x1
	// Position of MODE field.
	IOCON_P2_29_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P2_29_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P2_29_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P2_29_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P2_29_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P2_29_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P2_29_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P2_29_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P2_29_HYS = 0x20
	// Disable.
	IOCON_P2_29_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P2_29_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P2_29_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P2_29_INV_Msk = 0x40
	// Bit INV.
	IOCON_P2_29_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P2_29_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P2_29_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P2_29_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P2_29_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P2_29_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P2_29_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P2_29_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P2_29_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P2_29_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P2_29_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P2_29_OD_Msk = 0x400
	// Bit OD.
	IOCON_P2_29_OD = 0x400
	// Disable.
	IOCON_P2_29_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P2_29_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P2_29_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P2_29_RESERVED_Msk = 0xfffff800

	// P2_30: I/O configuration register for pin P2[30]
	// Position of FUNC field.
	IOCON_P2_30_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_30_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P2_30_FUNC_P2_30 = 0x0
	// Data mask 2 used with SDRAM and static devices.
	IOCON_P2_30_FUNC_EMC_DQM2 = 0x1
	// I2C2 data input/output (this pin does not use a specialized I2C pad).
	IOCON_P2_30_FUNC_I2C2_SDA = 0x2
	// Match output for Timer 3, channel 2.
	IOCON_P2_30_FUNC_T3_MAT2 = 0x3
	// Position of MODE field.
	IOCON_P2_30_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P2_30_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P2_30_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P2_30_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P2_30_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P2_30_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P2_30_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P2_30_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P2_30_HYS = 0x20
	// Disable.
	IOCON_P2_30_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P2_30_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P2_30_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P2_30_INV_Msk = 0x40
	// Bit INV.
	IOCON_P2_30_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P2_30_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P2_30_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P2_30_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P2_30_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P2_30_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P2_30_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P2_30_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P2_30_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P2_30_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P2_30_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P2_30_OD_Msk = 0x400
	// Bit OD.
	IOCON_P2_30_OD = 0x400
	// Disable.
	IOCON_P2_30_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P2_30_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P2_30_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P2_30_RESERVED_Msk = 0xfffff800

	// P2_31: I/O configuration register for pin P2[31]
	// Position of FUNC field.
	IOCON_P2_31_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P2_31_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P2_31_FUNC_P2_31 = 0x0
	// Data mask 3 used with SDRAM and static devices.
	IOCON_P2_31_FUNC_EMC_DQM3 = 0x1
	// I2C2 clock input/output (this pin does not use a specialized I2C pad).
	IOCON_P2_31_FUNC_I2C2_SCL = 0x2
	// Match output for Timer 3, channel 3.
	IOCON_P2_31_FUNC_T3_MAT3 = 0x3
	// Position of MODE field.
	IOCON_P2_31_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P2_31_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P2_31_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P2_31_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P2_31_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P2_31_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P2_31_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P2_31_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P2_31_HYS = 0x20
	// Disable.
	IOCON_P2_31_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P2_31_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P2_31_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P2_31_INV_Msk = 0x40
	// Bit INV.
	IOCON_P2_31_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P2_31_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P2_31_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P2_31_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P2_31_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P2_31_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P2_31_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P2_31_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P2_31_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P2_31_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P2_31_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P2_31_OD_Msk = 0x400
	// Bit OD.
	IOCON_P2_31_OD = 0x400
	// Disable.
	IOCON_P2_31_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P2_31_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P2_31_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P2_31_RESERVED_Msk = 0xfffff800

	// P3_0: I/O configuration register for pin P3[0]
	// Position of FUNC field.
	IOCON_P3_0_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_0_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_0_FUNC_P3_0 = 0x0
	// External memory data line 0.
	IOCON_P3_0_FUNC_EMC_D_0 = 0x1
	// Position of MODE field.
	IOCON_P3_0_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_0_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_0_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_0_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_0_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_0_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_0_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_0_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_0_HYS = 0x20
	// Disable.
	IOCON_P3_0_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_0_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_0_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_0_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_0_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_0_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_0_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_0_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_0_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_0_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_0_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_0_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_0_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_0_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_0_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_0_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_0_OD = 0x400
	// Disable.
	IOCON_P3_0_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_0_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_0_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_0_RESERVED_Msk = 0xfffff800

	// P3_1: I/O configuration register for pin P3[1]
	// Position of FUNC field.
	IOCON_P3_1_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_1_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_1_FUNC_P3_1 = 0x0
	// External memory data line 1.
	IOCON_P3_1_FUNC_EMC_D_1 = 0x1
	// Position of MODE field.
	IOCON_P3_1_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_1_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_1_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_1_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_1_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_1_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_1_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_1_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_1_HYS = 0x20
	// Disable.
	IOCON_P3_1_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_1_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_1_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_1_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_1_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_1_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_1_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_1_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_1_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_1_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_1_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_1_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_1_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_1_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_1_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_1_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_1_OD = 0x400
	// Disable.
	IOCON_P3_1_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_1_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_1_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_1_RESERVED_Msk = 0xfffff800

	// P3_2: I/O configuration register for pin P3[2]
	// Position of FUNC field.
	IOCON_P3_2_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_2_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_2_FUNC_P3_2 = 0x0
	// External memory data line 2.
	IOCON_P3_2_FUNC_EMC_D_2 = 0x1
	// Position of MODE field.
	IOCON_P3_2_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_2_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_2_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_2_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_2_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_2_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_2_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_2_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_2_HYS = 0x20
	// Disable.
	IOCON_P3_2_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_2_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_2_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_2_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_2_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_2_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_2_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_2_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_2_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_2_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_2_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_2_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_2_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_2_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_2_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_2_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_2_OD = 0x400
	// Disable.
	IOCON_P3_2_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_2_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_2_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_2_RESERVED_Msk = 0xfffff800

	// P3_3: I/O configuration register for pin P3[3]
	// Position of FUNC field.
	IOCON_P3_3_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_3_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_3_FUNC_P3_3 = 0x0
	// External memory data line 3.
	IOCON_P3_3_FUNC_EMC_D_3 = 0x1
	// Position of MODE field.
	IOCON_P3_3_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_3_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_3_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_3_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_3_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_3_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_3_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_3_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_3_HYS = 0x20
	// Disable.
	IOCON_P3_3_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_3_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_3_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_3_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_3_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_3_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_3_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_3_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_3_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_3_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_3_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_3_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_3_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_3_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_3_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_3_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_3_OD = 0x400
	// Disable.
	IOCON_P3_3_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_3_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_3_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_3_RESERVED_Msk = 0xfffff800

	// P3_4: I/O configuration register for pin P3[4]
	// Position of FUNC field.
	IOCON_P3_4_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_4_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_4_FUNC_P3_4 = 0x0
	// External memory data line 4.
	IOCON_P3_4_FUNC_EMC_D_4 = 0x1
	// Position of MODE field.
	IOCON_P3_4_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_4_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_4_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_4_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_4_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_4_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_4_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_4_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_4_HYS = 0x20
	// Disable.
	IOCON_P3_4_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_4_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_4_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_4_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_4_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_4_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_4_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_4_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_4_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_4_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_4_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_4_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_4_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_4_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_4_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_4_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_4_OD = 0x400
	// Disable.
	IOCON_P3_4_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_4_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_4_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_4_RESERVED_Msk = 0xfffff800

	// P3_5: I/O configuration register for pin P3[5]
	// Position of FUNC field.
	IOCON_P3_5_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_5_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_5_FUNC_P3_5 = 0x0
	// External memory data line 5.
	IOCON_P3_5_FUNC_EMC_D_5 = 0x1
	// Position of MODE field.
	IOCON_P3_5_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_5_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_5_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_5_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_5_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_5_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_5_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_5_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_5_HYS = 0x20
	// Disable.
	IOCON_P3_5_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_5_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_5_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_5_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_5_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_5_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_5_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_5_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_5_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_5_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_5_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_5_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_5_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_5_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_5_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_5_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_5_OD = 0x400
	// Disable.
	IOCON_P3_5_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_5_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_5_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_5_RESERVED_Msk = 0xfffff800

	// P3_6: I/O configuration register for pin P3[6]
	// Position of FUNC field.
	IOCON_P3_6_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_6_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_6_FUNC_P3_6 = 0x0
	// External memory data line 6.
	IOCON_P3_6_FUNC_EMC_D_6 = 0x1
	// Position of MODE field.
	IOCON_P3_6_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_6_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_6_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_6_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_6_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_6_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_6_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_6_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_6_HYS = 0x20
	// Disable.
	IOCON_P3_6_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_6_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_6_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_6_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_6_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_6_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_6_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_6_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_6_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_6_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_6_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_6_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_6_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_6_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_6_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_6_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_6_OD = 0x400
	// Disable.
	IOCON_P3_6_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_6_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_6_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_6_RESERVED_Msk = 0xfffff800

	// P3_7: I/O configuration register for pin P3[7]
	// Position of FUNC field.
	IOCON_P3_7_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_7_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_7_FUNC_P3_7 = 0x0
	// External memory data line 7.
	IOCON_P3_7_FUNC_EMC_D_7 = 0x1
	// Position of MODE field.
	IOCON_P3_7_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_7_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_7_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_7_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_7_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_7_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_7_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_7_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_7_HYS = 0x20
	// Disable.
	IOCON_P3_7_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_7_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_7_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_7_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_7_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_7_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_7_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_7_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_7_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_7_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_7_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_7_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_7_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_7_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_7_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_7_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_7_OD = 0x400
	// Disable.
	IOCON_P3_7_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_7_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_7_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_7_RESERVED_Msk = 0xfffff800

	// P3_8: I/O configuration register for pin P3[8]
	// Position of FUNC field.
	IOCON_P3_8_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_8_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_8_FUNC_P3_8 = 0x0
	// External memory data line 8.
	IOCON_P3_8_FUNC_EMC_D_8 = 0x1
	// Position of MODE field.
	IOCON_P3_8_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_8_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_8_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_8_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_8_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_8_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_8_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_8_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_8_HYS = 0x20
	// Disable.
	IOCON_P3_8_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_8_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_8_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_8_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_8_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_8_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_8_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_8_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_8_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_8_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_8_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_8_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_8_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_8_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_8_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_8_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_8_OD = 0x400
	// Disable.
	IOCON_P3_8_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_8_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_8_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_8_RESERVED_Msk = 0xfffff800

	// P3_9: I/O configuration register for pin P3[9]
	// Position of FUNC field.
	IOCON_P3_9_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_9_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_9_FUNC_P3_9 = 0x0
	// External memory data line 9.
	IOCON_P3_9_FUNC_EMC_D_9 = 0x1
	// Position of MODE field.
	IOCON_P3_9_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_9_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_9_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_9_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_9_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_9_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_9_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_9_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_9_HYS = 0x20
	// Disable.
	IOCON_P3_9_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_9_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_9_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_9_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_9_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_9_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_9_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_9_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_9_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_9_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_9_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_9_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_9_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_9_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_9_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_9_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_9_OD = 0x400
	// Disable.
	IOCON_P3_9_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_9_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_9_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_9_RESERVED_Msk = 0xfffff800

	// P3_10: I/O configuration register for pin P3[10]
	// Position of FUNC field.
	IOCON_P3_10_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_10_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_10_FUNC_P3_10 = 0x0
	// External memory data line 10.
	IOCON_P3_10_FUNC_EMC_D_10 = 0x1
	// Position of MODE field.
	IOCON_P3_10_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_10_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_10_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_10_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_10_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_10_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_10_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_10_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_10_HYS = 0x20
	// Disable.
	IOCON_P3_10_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_10_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_10_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_10_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_10_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_10_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_10_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_10_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_10_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_10_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_10_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_10_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_10_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_10_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_10_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_10_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_10_OD = 0x400
	// Disable.
	IOCON_P3_10_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_10_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_10_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_10_RESERVED_Msk = 0xfffff800

	// P3_11: I/O configuration register for pin P3[11]
	// Position of FUNC field.
	IOCON_P3_11_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_11_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_11_FUNC_P3_11 = 0x0
	// External memory data line 11.
	IOCON_P3_11_FUNC_EMC_D_11 = 0x1
	// Position of MODE field.
	IOCON_P3_11_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_11_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_11_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_11_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_11_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_11_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_11_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_11_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_11_HYS = 0x20
	// Disable.
	IOCON_P3_11_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_11_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_11_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_11_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_11_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_11_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_11_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_11_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_11_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_11_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_11_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_11_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_11_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_11_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_11_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_11_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_11_OD = 0x400
	// Disable.
	IOCON_P3_11_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_11_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_11_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_11_RESERVED_Msk = 0xfffff800

	// P3_12: I/O configuration register for pin P3[12]
	// Position of FUNC field.
	IOCON_P3_12_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_12_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_12_FUNC_P3_12 = 0x0
	// External memory data line 12.
	IOCON_P3_12_FUNC_EMC_D_12 = 0x1
	// Position of MODE field.
	IOCON_P3_12_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_12_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_12_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_12_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_12_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_12_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_12_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_12_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_12_HYS = 0x20
	// Disable.
	IOCON_P3_12_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_12_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_12_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_12_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_12_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_12_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_12_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_12_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_12_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_12_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_12_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_12_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_12_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_12_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_12_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_12_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_12_OD = 0x400
	// Disable.
	IOCON_P3_12_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_12_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_12_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_12_RESERVED_Msk = 0xfffff800

	// P3_13: I/O configuration register for pin P3[13]
	// Position of FUNC field.
	IOCON_P3_13_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_13_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_13_FUNC_P3_13 = 0x0
	// External memory data line 13.
	IOCON_P3_13_FUNC_EMC_D_13 = 0x1
	// Position of MODE field.
	IOCON_P3_13_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_13_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_13_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_13_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_13_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_13_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_13_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_13_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_13_HYS = 0x20
	// Disable.
	IOCON_P3_13_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_13_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_13_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_13_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_13_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_13_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_13_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_13_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_13_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_13_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_13_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_13_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_13_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_13_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_13_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_13_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_13_OD = 0x400
	// Disable.
	IOCON_P3_13_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_13_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_13_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_13_RESERVED_Msk = 0xfffff800

	// P3_14: I/O configuration register for pin P3[14]
	// Position of FUNC field.
	IOCON_P3_14_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_14_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_14_FUNC_P3_14 = 0x0
	// External memory data line 14.
	IOCON_P3_14_FUNC_EMC_D_14 = 0x1
	// Position of MODE field.
	IOCON_P3_14_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_14_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_14_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_14_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_14_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_14_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_14_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_14_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_14_HYS = 0x20
	// Disable.
	IOCON_P3_14_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_14_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_14_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_14_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_14_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_14_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_14_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_14_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_14_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_14_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_14_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_14_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_14_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_14_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_14_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_14_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_14_OD = 0x400
	// Disable.
	IOCON_P3_14_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_14_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_14_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_14_RESERVED_Msk = 0xfffff800

	// P3_15: I/O configuration register for pin P3[15]
	// Position of FUNC field.
	IOCON_P3_15_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_15_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_15_FUNC_P3_15 = 0x0
	// External memory data line 15.
	IOCON_P3_15_FUNC_EMC_D_15 = 0x1
	// Position of MODE field.
	IOCON_P3_15_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_15_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_15_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_15_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_15_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_15_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_15_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_15_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_15_HYS = 0x20
	// Disable.
	IOCON_P3_15_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_15_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_15_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_15_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_15_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_15_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_15_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_15_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_15_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_15_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_15_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_15_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_15_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_15_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_15_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_15_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_15_OD = 0x400
	// Disable.
	IOCON_P3_15_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_15_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_15_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_15_RESERVED_Msk = 0xfffff800

	// P3_16: I/O configuration register for pin P3[16]
	// Position of FUNC field.
	IOCON_P3_16_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_16_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_16_FUNC_P3_16 = 0x0
	// External memory data line 16.
	IOCON_P3_16_FUNC_EMC_D_16 = 0x1
	// Pulse Width Modulator 0, output 1.
	IOCON_P3_16_FUNC_PWM0_1 = 0x2
	// Transmitter output for UART1.
	IOCON_P3_16_FUNC_U1_TXD = 0x3
	// Position of MODE field.
	IOCON_P3_16_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_16_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_16_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_16_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_16_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_16_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_16_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_16_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_16_HYS = 0x20
	// Disable.
	IOCON_P3_16_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_16_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_16_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_16_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_16_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_16_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_16_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_16_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_16_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_16_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_16_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_16_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_16_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_16_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_16_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_16_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_16_OD = 0x400
	// Disable.
	IOCON_P3_16_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_16_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_16_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_16_RESERVED_Msk = 0xfffff800

	// P3_17: I/O configuration register for pin P3[17]
	// Position of FUNC field.
	IOCON_P3_17_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_17_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_17_FUNC_P3_17 = 0x0
	// External memory data line 17.
	IOCON_P3_17_FUNC_EMC_D_17 = 0x1
	// Pulse Width Modulator 0, output 2.
	IOCON_P3_17_FUNC_PWM0_2 = 0x2
	// Receiver input for UART1.
	IOCON_P3_17_FUNC_U1_RXD = 0x3
	// Position of MODE field.
	IOCON_P3_17_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_17_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_17_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_17_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_17_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_17_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_17_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_17_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_17_HYS = 0x20
	// Disable.
	IOCON_P3_17_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_17_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_17_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_17_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_17_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_17_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_17_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_17_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_17_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_17_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_17_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_17_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_17_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_17_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_17_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_17_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_17_OD = 0x400
	// Disable.
	IOCON_P3_17_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_17_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_17_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_17_RESERVED_Msk = 0xfffff800

	// P3_18: I/O configuration register for pin P3[18]
	// Position of FUNC field.
	IOCON_P3_18_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_18_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_18_FUNC_P3_18 = 0x0
	// External memory data line 18.
	IOCON_P3_18_FUNC_EMC_D_18 = 0x1
	// Pulse Width Modulator 0, output 3.
	IOCON_P3_18_FUNC_PWM0_3 = 0x2
	// Clear to Send input for UART1.
	IOCON_P3_18_FUNC_U1_CTS = 0x3
	// Position of MODE field.
	IOCON_P3_18_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_18_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_18_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_18_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_18_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_18_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_18_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_18_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_18_HYS = 0x20
	// Disable.
	IOCON_P3_18_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_18_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_18_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_18_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_18_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_18_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_18_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_18_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_18_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_18_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_18_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_18_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_18_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_18_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_18_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_18_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_18_OD = 0x400
	// Disable.
	IOCON_P3_18_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_18_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_18_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_18_RESERVED_Msk = 0xfffff800

	// P3_19: I/O configuration register for pin P3[19]
	// Position of FUNC field.
	IOCON_P3_19_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_19_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_19_FUNC_P3_19 = 0x0
	// External memory data line 19.
	IOCON_P3_19_FUNC_EMC_D_19 = 0x1
	// Pulse Width Modulator 0, output 4.
	IOCON_P3_19_FUNC_PWM0_4 = 0x2
	// Data Carrier Detect input for UART1.
	IOCON_P3_19_FUNC_U1_DCD = 0x3
	// Position of MODE field.
	IOCON_P3_19_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_19_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_19_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_19_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_19_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_19_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_19_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_19_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_19_HYS = 0x20
	// Disable.
	IOCON_P3_19_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_19_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_19_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_19_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_19_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_19_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_19_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_19_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_19_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_19_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_19_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_19_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_19_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_19_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_19_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_19_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_19_OD = 0x400
	// Disable.
	IOCON_P3_19_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_19_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_19_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_19_RESERVED_Msk = 0xfffff800

	// P3_20: I/O configuration register for pin P3[20]
	// Position of FUNC field.
	IOCON_P3_20_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_20_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_20_FUNC_P3_20 = 0x0
	// External memory data line 20.
	IOCON_P3_20_FUNC_EMC_D_20 = 0x1
	// Pulse Width Modulator 0, output 5.
	IOCON_P3_20_FUNC_PWM0_5 = 0x2
	// Data Set Ready input for UART1.
	IOCON_P3_20_FUNC_U1_DSR = 0x3
	// Position of MODE field.
	IOCON_P3_20_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_20_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_20_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_20_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_20_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_20_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_20_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_20_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_20_HYS = 0x20
	// Disable.
	IOCON_P3_20_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_20_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_20_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_20_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_20_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_20_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_20_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_20_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_20_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_20_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_20_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_20_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_20_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_20_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_20_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_20_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_20_OD = 0x400
	// Disable.
	IOCON_P3_20_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_20_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_20_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_20_RESERVED_Msk = 0xfffff800

	// P3_21: I/O configuration register for pin P3[21]
	// Position of FUNC field.
	IOCON_P3_21_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_21_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_21_FUNC_P3_21 = 0x0
	// External memory data line 21.
	IOCON_P3_21_FUNC_EMC_D_21 = 0x1
	// Pulse Width Modulator 0, output 6.
	IOCON_P3_21_FUNC_PWM0_6 = 0x2
	// Data Terminal Ready output for UART1. Can also be configured to be an RS-485/EIA-485 output enable signal for UART1.
	IOCON_P3_21_FUNC_U1_DTR = 0x3
	// Position of MODE field.
	IOCON_P3_21_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_21_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_21_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_21_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_21_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_21_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_21_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_21_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_21_HYS = 0x20
	// Disable.
	IOCON_P3_21_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_21_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_21_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_21_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_21_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_21_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_21_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_21_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_21_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_21_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_21_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_21_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_21_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_21_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_21_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_21_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_21_OD = 0x400
	// Disable.
	IOCON_P3_21_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_21_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_21_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_21_RESERVED_Msk = 0xfffff800

	// P3_22: I/O configuration register for pin P3[22]
	// Position of FUNC field.
	IOCON_P3_22_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_22_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_22_FUNC_P3_22 = 0x0
	// External memory data line 22.
	IOCON_P3_22_FUNC_EMC_D_22 = 0x1
	// Capture input for PWM0, channel 0.
	IOCON_P3_22_FUNC_PWM0_CAP0 = 0x2
	// Ring Indicator input for UART1.
	IOCON_P3_22_FUNC_U1_RI = 0x3
	// Position of MODE field.
	IOCON_P3_22_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_22_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_22_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_22_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_22_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_22_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_22_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_22_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_22_HYS = 0x20
	// Disable.
	IOCON_P3_22_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_22_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_22_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_22_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_22_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_22_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_22_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_22_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_22_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_22_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_22_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_22_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_22_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_22_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_22_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_22_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_22_OD = 0x400
	// Disable.
	IOCON_P3_22_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_22_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_22_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_22_RESERVED_Msk = 0xfffff800

	// P3_23: I/O configuration register for pin P3[23]
	// Position of FUNC field.
	IOCON_P3_23_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_23_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_23_FUNC_P3_23 = 0x0
	// External memory data line 23.
	IOCON_P3_23_FUNC_EMC_D_23 = 0x1
	// Capture input for PWM1, channel 0.
	IOCON_P3_23_FUNC_PWM1_CAP0 = 0x2
	// Capture input for Timer 0, channel 0.
	IOCON_P3_23_FUNC_T0_CAP0 = 0x3
	// Position of MODE field.
	IOCON_P3_23_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_23_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_23_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_23_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_23_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_23_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_23_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_23_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_23_HYS = 0x20
	// Disable.
	IOCON_P3_23_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_23_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_23_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_23_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_23_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_23_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_23_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_23_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_23_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_23_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_23_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_23_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_23_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_23_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_23_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_23_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_23_OD = 0x400
	// Disable.
	IOCON_P3_23_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_23_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_23_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_23_RESERVED_Msk = 0xfffff800

	// P3_24: I/O configuration register for pin P3[24]
	// Position of FUNC field.
	IOCON_P3_24_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_24_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_24_FUNC_P3_24 = 0x0
	// External memory data line 24.
	IOCON_P3_24_FUNC_EMC_D_24 = 0x1
	// Pulse Width Modulator 1, output 1.
	IOCON_P3_24_FUNC_PWM1_1 = 0x2
	// Capture input for Timer 0, channel 1.
	IOCON_P3_24_FUNC_T0_CAP1 = 0x3
	// Position of MODE field.
	IOCON_P3_24_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_24_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_24_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_24_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_24_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_24_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_24_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_24_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_24_HYS = 0x20
	// Disable.
	IOCON_P3_24_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_24_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_24_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_24_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_24_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_24_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_24_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_24_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_24_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_24_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_24_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_24_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_24_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_24_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_24_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_24_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_24_OD = 0x400
	// Disable.
	IOCON_P3_24_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_24_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_24_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_24_RESERVED_Msk = 0xfffff800

	// P3_25: I/O configuration register for pin P3[25]
	// Position of FUNC field.
	IOCON_P3_25_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_25_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_25_FUNC_P3_25 = 0x0
	// External memory data line 25.
	IOCON_P3_25_FUNC_EMC_D_25 = 0x1
	// Pulse Width Modulator 1, output 2.
	IOCON_P3_25_FUNC_PWM1_2 = 0x2
	// Match output for Timer 0, channel 0.
	IOCON_P3_25_FUNC_T0_MAT0 = 0x3
	// Position of MODE field.
	IOCON_P3_25_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_25_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_25_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_25_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_25_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_25_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_25_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_25_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_25_HYS = 0x20
	// Disable.
	IOCON_P3_25_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_25_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_25_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_25_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_25_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_25_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_25_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_25_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_25_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_25_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_25_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_25_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_25_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_25_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_25_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_25_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_25_OD = 0x400
	// Disable.
	IOCON_P3_25_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_25_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_25_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_25_RESERVED_Msk = 0xfffff800

	// P3_26: I/O configuration register for pin P3[26]
	// Position of FUNC field.
	IOCON_P3_26_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_26_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_26_FUNC_P3_26 = 0x0
	// External memory data line 26.
	IOCON_P3_26_FUNC_EMC_D_26 = 0x1
	// Pulse Width Modulator 1, output 3.
	IOCON_P3_26_FUNC_PWM1_3 = 0x2
	// Match output for Timer 0, channel 1.
	IOCON_P3_26_FUNC_T0_MAT1 = 0x3
	// System tick timer clock input.
	IOCON_P3_26_FUNC_STCLK = 0x4
	// Position of MODE field.
	IOCON_P3_26_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_26_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_26_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_26_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_26_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_26_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_26_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_26_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_26_HYS = 0x20
	// Disable.
	IOCON_P3_26_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_26_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_26_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_26_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_26_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_26_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_26_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_26_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_26_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_26_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_26_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_26_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_26_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_26_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_26_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_26_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_26_OD = 0x400
	// Disable.
	IOCON_P3_26_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_26_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_26_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_26_RESERVED_Msk = 0xfffff800

	// P3_27: I/O configuration register for pin P3[27]
	// Position of FUNC field.
	IOCON_P3_27_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_27_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_27_FUNC_P3_27 = 0x0
	// External memory data line 27.
	IOCON_P3_27_FUNC_EMC_D_27 = 0x1
	// Pulse Width Modulator 1, output 4.
	IOCON_P3_27_FUNC_PWM1_4 = 0x2
	// Capture input for Timer 1, channel 0.
	IOCON_P3_27_FUNC_T1_CAP0 = 0x3
	// Position of MODE field.
	IOCON_P3_27_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_27_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_27_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_27_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_27_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_27_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_27_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_27_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_27_HYS = 0x20
	// Disable.
	IOCON_P3_27_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_27_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_27_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_27_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_27_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_27_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_27_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_27_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_27_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_27_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_27_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_27_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_27_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_27_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_27_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_27_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_27_OD = 0x400
	// Disable.
	IOCON_P3_27_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_27_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_27_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_27_RESERVED_Msk = 0xfffff800

	// P3_28: I/O configuration register for pin P3[28]
	// Position of FUNC field.
	IOCON_P3_28_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_28_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_28_FUNC_P3_28 = 0x0
	// External memory data line 28.
	IOCON_P3_28_FUNC_EMC_D_28 = 0x1
	// Pulse Width Modulator 1, output 5.
	IOCON_P3_28_FUNC_PWM1_5 = 0x2
	// Capture input for Timer 1, channel 1.
	IOCON_P3_28_FUNC_T1_CAP1 = 0x3
	// Position of MODE field.
	IOCON_P3_28_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_28_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_28_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_28_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_28_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_28_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_28_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_28_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_28_HYS = 0x20
	// Disable.
	IOCON_P3_28_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_28_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_28_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_28_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_28_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_28_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_28_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_28_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_28_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_28_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_28_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_28_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_28_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_28_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_28_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_28_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_28_OD = 0x400
	// Disable.
	IOCON_P3_28_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_28_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_28_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_28_RESERVED_Msk = 0xfffff800

	// P3_29: I/O configuration register for pin P3[29]
	// Position of FUNC field.
	IOCON_P3_29_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_29_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_29_FUNC_P3_29 = 0x0
	// External memory data line 29.
	IOCON_P3_29_FUNC_EMC_D_29 = 0x1
	// Pulse Width Modulator 1, output 6.
	IOCON_P3_29_FUNC_PWM1_6 = 0x2
	// Match output for Timer 1, channel 0.
	IOCON_P3_29_FUNC_T1_MAT0 = 0x3
	// Position of MODE field.
	IOCON_P3_29_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_29_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_29_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_29_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_29_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_29_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_29_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_29_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_29_HYS = 0x20
	// Disable.
	IOCON_P3_29_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_29_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_29_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_29_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_29_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_29_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_29_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_29_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_29_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_29_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_29_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_29_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_29_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_29_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_29_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_29_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_29_OD = 0x400
	// Disable.
	IOCON_P3_29_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_29_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_29_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_29_RESERVED_Msk = 0xfffff800

	// P3_30: I/O configuration register for pin P3[30]
	// Position of FUNC field.
	IOCON_P3_30_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_30_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_30_FUNC_P3_30 = 0x0
	// External memory data line 30.
	IOCON_P3_30_FUNC_EMC_D_30 = 0x1
	// Request to Send output for UART1. Can also be configured to be an RS-485/EIA-485 output enable signal for UART1.
	IOCON_P3_30_FUNC_U1_RTS = 0x2
	// Match output for Timer 1, channel 1.
	IOCON_P3_30_FUNC_T1_MAT1 = 0x3
	// Position of MODE field.
	IOCON_P3_30_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_30_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_30_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_30_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_30_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_30_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_30_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_30_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_30_HYS = 0x20
	// Disable.
	IOCON_P3_30_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_30_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_30_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_30_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_30_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_30_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_30_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_30_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_30_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_30_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_30_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_30_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_30_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_30_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_30_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_30_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_30_OD = 0x400
	// Disable.
	IOCON_P3_30_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_30_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_30_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_30_RESERVED_Msk = 0xfffff800

	// P3_31: I/O configuration register for pin P3[31]
	// Position of FUNC field.
	IOCON_P3_31_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P3_31_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P3_31_FUNC_P3_31 = 0x0
	// External memory data line 31.
	IOCON_P3_31_FUNC_EMC_D_31 = 0x1
	// Match output for Timer 1, channel 2.
	IOCON_P3_31_FUNC_T1_MAT2 = 0x3
	// Position of MODE field.
	IOCON_P3_31_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P3_31_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P3_31_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P3_31_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P3_31_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P3_31_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P3_31_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P3_31_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P3_31_HYS = 0x20
	// Disable.
	IOCON_P3_31_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P3_31_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P3_31_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P3_31_INV_Msk = 0x40
	// Bit INV.
	IOCON_P3_31_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P3_31_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P3_31_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P3_31_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P3_31_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P3_31_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P3_31_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P3_31_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P3_31_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P3_31_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P3_31_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P3_31_OD_Msk = 0x400
	// Bit OD.
	IOCON_P3_31_OD = 0x400
	// Disable.
	IOCON_P3_31_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P3_31_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P3_31_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P3_31_RESERVED_Msk = 0xfffff800

	// P4_0: I/O configuration register for pin P4[0]
	// Position of FUNC field.
	IOCON_P4_0_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_0_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_0_FUNC_P4_0 = 0x0
	// External memory address line 0.
	IOCON_P4_0_FUNC_EMC_A_0 = 0x1
	// Position of MODE field.
	IOCON_P4_0_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_0_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_0_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_0_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_0_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_0_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_0_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_0_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_0_HYS = 0x20
	// Disable.
	IOCON_P4_0_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_0_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_0_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_0_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_0_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_0_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_0_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_0_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_0_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_0_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_0_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_0_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_0_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_0_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_0_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_0_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_0_OD = 0x400
	// Disable.
	IOCON_P4_0_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_0_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_0_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_0_RESERVED_Msk = 0xfffff800

	// P4_1: I/O configuration register for pin P4[1]
	// Position of FUNC field.
	IOCON_P4_1_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_1_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_1_FUNC_P4_1 = 0x0
	// External memory address line 1.
	IOCON_P4_1_FUNC_EMC_A_1 = 0x1
	// Position of MODE field.
	IOCON_P4_1_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_1_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_1_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_1_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_1_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_1_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_1_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_1_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_1_HYS = 0x20
	// Disable.
	IOCON_P4_1_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_1_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_1_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_1_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_1_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_1_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_1_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_1_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_1_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_1_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_1_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_1_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_1_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_1_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_1_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_1_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_1_OD = 0x400
	// Disable.
	IOCON_P4_1_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_1_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_1_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_1_RESERVED_Msk = 0xfffff800

	// P4_2: I/O configuration register for pin P4[2]
	// Position of FUNC field.
	IOCON_P4_2_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_2_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_2_FUNC_P4_2 = 0x0
	// External memory address line 2.
	IOCON_P4_2_FUNC_EMC_A_2 = 0x1
	// Position of MODE field.
	IOCON_P4_2_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_2_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_2_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_2_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_2_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_2_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_2_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_2_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_2_HYS = 0x20
	// Disable.
	IOCON_P4_2_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_2_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_2_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_2_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_2_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_2_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_2_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_2_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_2_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_2_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_2_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_2_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_2_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_2_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_2_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_2_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_2_OD = 0x400
	// Disable.
	IOCON_P4_2_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_2_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_2_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_2_RESERVED_Msk = 0xfffff800

	// P4_3: I/O configuration register for pin P4[3]
	// Position of FUNC field.
	IOCON_P4_3_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_3_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_3_FUNC_P4_3 = 0x0
	// External memory address line 3.
	IOCON_P4_3_FUNC_EMC_A_3 = 0x1
	// Position of MODE field.
	IOCON_P4_3_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_3_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_3_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_3_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_3_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_3_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_3_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_3_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_3_HYS = 0x20
	// Disable.
	IOCON_P4_3_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_3_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_3_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_3_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_3_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_3_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_3_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_3_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_3_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_3_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_3_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_3_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_3_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_3_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_3_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_3_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_3_OD = 0x400
	// Disable.
	IOCON_P4_3_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_3_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_3_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_3_RESERVED_Msk = 0xfffff800

	// P4_4: I/O configuration register for pin P4[4]
	// Position of FUNC field.
	IOCON_P4_4_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_4_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_4_FUNC_P4_4 = 0x0
	// External memory address line 4.
	IOCON_P4_4_FUNC_EMC_A_4 = 0x1
	// Position of MODE field.
	IOCON_P4_4_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_4_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_4_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_4_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_4_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_4_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_4_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_4_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_4_HYS = 0x20
	// Disable.
	IOCON_P4_4_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_4_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_4_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_4_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_4_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_4_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_4_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_4_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_4_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_4_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_4_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_4_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_4_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_4_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_4_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_4_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_4_OD = 0x400
	// Disable.
	IOCON_P4_4_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_4_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_4_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_4_RESERVED_Msk = 0xfffff800

	// P4_5: I/O configuration register for pin P4[5]
	// Position of FUNC field.
	IOCON_P4_5_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_5_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_5_FUNC_P4_5 = 0x0
	// External memory address line 5.
	IOCON_P4_5_FUNC_EMC_A_5 = 0x1
	// Position of MODE field.
	IOCON_P4_5_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_5_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_5_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_5_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_5_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_5_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_5_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_5_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_5_HYS = 0x20
	// Disable.
	IOCON_P4_5_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_5_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_5_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_5_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_5_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_5_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_5_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_5_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_5_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_5_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_5_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_5_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_5_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_5_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_5_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_5_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_5_OD = 0x400
	// Disable.
	IOCON_P4_5_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_5_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_5_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_5_RESERVED_Msk = 0xfffff800

	// P4_6: I/O configuration register for pin P4[6]
	// Position of FUNC field.
	IOCON_P4_6_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_6_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_6_FUNC_P4_6 = 0x0
	// External memory address line 6.
	IOCON_P4_6_FUNC_EMC_A_6 = 0x1
	// Position of MODE field.
	IOCON_P4_6_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_6_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_6_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_6_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_6_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_6_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_6_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_6_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_6_HYS = 0x20
	// Disable.
	IOCON_P4_6_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_6_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_6_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_6_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_6_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_6_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_6_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_6_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_6_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_6_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_6_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_6_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_6_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_6_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_6_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_6_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_6_OD = 0x400
	// Disable.
	IOCON_P4_6_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_6_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_6_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_6_RESERVED_Msk = 0xfffff800

	// P4_7: I/O configuration register for pin P4[7]
	// Position of FUNC field.
	IOCON_P4_7_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_7_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_7_FUNC_P4_7 = 0x0
	// External memory address line 7.
	IOCON_P4_7_FUNC_EMC_A_7 = 0x1
	// Position of MODE field.
	IOCON_P4_7_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_7_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_7_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_7_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_7_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_7_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_7_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_7_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_7_HYS = 0x20
	// Disable.
	IOCON_P4_7_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_7_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_7_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_7_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_7_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_7_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_7_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_7_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_7_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_7_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_7_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_7_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_7_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_7_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_7_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_7_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_7_OD = 0x400
	// Disable.
	IOCON_P4_7_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_7_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_7_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_7_RESERVED_Msk = 0xfffff800

	// P4_8: I/O configuration register for pin P4[8]
	// Position of FUNC field.
	IOCON_P4_8_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_8_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_8_FUNC_P4_8 = 0x0
	// External memory address line 8.
	IOCON_P4_8_FUNC_EMC_A_8 = 0x1
	// Position of MODE field.
	IOCON_P4_8_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_8_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_8_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_8_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_8_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_8_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_8_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_8_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_8_HYS = 0x20
	// Disable.
	IOCON_P4_8_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_8_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_8_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_8_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_8_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_8_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_8_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_8_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_8_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_8_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_8_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_8_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_8_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_8_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_8_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_8_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_8_OD = 0x400
	// Disable.
	IOCON_P4_8_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_8_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_8_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_8_RESERVED_Msk = 0xfffff800

	// P4_9: I/O configuration register for pin P4[9]
	// Position of FUNC field.
	IOCON_P4_9_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_9_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_9_FUNC_P4_9 = 0x0
	// External memory address line 9.
	IOCON_P4_9_FUNC_EMC_A_9 = 0x1
	// Position of MODE field.
	IOCON_P4_9_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_9_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_9_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_9_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_9_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_9_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_9_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_9_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_9_HYS = 0x20
	// Disable.
	IOCON_P4_9_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_9_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_9_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_9_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_9_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_9_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_9_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_9_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_9_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_9_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_9_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_9_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_9_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_9_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_9_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_9_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_9_OD = 0x400
	// Disable.
	IOCON_P4_9_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_9_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_9_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_9_RESERVED_Msk = 0xfffff800

	// P4_10: I/O configuration register for pin P4[10]
	// Position of FUNC field.
	IOCON_P4_10_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_10_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_10_FUNC_P4_10 = 0x0
	// External memory address line 10.
	IOCON_P4_10_FUNC_EMC_A_10 = 0x1
	// Position of MODE field.
	IOCON_P4_10_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_10_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_10_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_10_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_10_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_10_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_10_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_10_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_10_HYS = 0x20
	// Disable.
	IOCON_P4_10_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_10_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_10_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_10_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_10_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_10_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_10_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_10_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_10_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_10_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_10_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_10_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_10_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_10_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_10_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_10_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_10_OD = 0x400
	// Disable.
	IOCON_P4_10_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_10_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_10_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_10_RESERVED_Msk = 0xfffff800

	// P4_11: I/O configuration register for pin P4[11]
	// Position of FUNC field.
	IOCON_P4_11_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_11_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_11_FUNC_P4_11 = 0x0
	// External memory address line 11.
	IOCON_P4_11_FUNC_EMC_A_11 = 0x1
	// Position of MODE field.
	IOCON_P4_11_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_11_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_11_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_11_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_11_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_11_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_11_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_11_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_11_HYS = 0x20
	// Disable.
	IOCON_P4_11_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_11_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_11_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_11_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_11_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_11_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_11_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_11_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_11_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_11_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_11_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_11_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_11_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_11_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_11_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_11_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_11_OD = 0x400
	// Disable.
	IOCON_P4_11_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_11_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_11_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_11_RESERVED_Msk = 0xfffff800

	// P4_12: I/O configuration register for pin P4[12]
	// Position of FUNC field.
	IOCON_P4_12_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_12_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_12_FUNC_P4_12 = 0x0
	// External memory address line 12.
	IOCON_P4_12_FUNC_EMC_A_12 = 0x1
	// Position of MODE field.
	IOCON_P4_12_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_12_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_12_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_12_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_12_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_12_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_12_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_12_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_12_HYS = 0x20
	// Disable.
	IOCON_P4_12_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_12_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_12_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_12_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_12_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_12_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_12_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_12_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_12_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_12_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_12_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_12_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_12_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_12_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_12_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_12_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_12_OD = 0x400
	// Disable.
	IOCON_P4_12_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_12_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_12_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_12_RESERVED_Msk = 0xfffff800

	// P4_13: I/O configuration register for pin P4[13]
	// Position of FUNC field.
	IOCON_P4_13_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_13_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_13_FUNC_P4_13 = 0x0
	// External memory address line 13.
	IOCON_P4_13_FUNC_EMC_A_13 = 0x1
	// Position of MODE field.
	IOCON_P4_13_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_13_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_13_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_13_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_13_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_13_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_13_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_13_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_13_HYS = 0x20
	// Disable.
	IOCON_P4_13_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_13_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_13_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_13_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_13_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_13_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_13_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_13_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_13_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_13_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_13_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_13_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_13_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_13_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_13_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_13_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_13_OD = 0x400
	// Disable.
	IOCON_P4_13_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_13_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_13_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_13_RESERVED_Msk = 0xfffff800

	// P4_14: I/O configuration register for pin P4[14]
	// Position of FUNC field.
	IOCON_P4_14_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_14_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_14_FUNC_P4_14 = 0x0
	// External memory address line 14.
	IOCON_P4_14_FUNC_EMC_A_14 = 0x1
	// Position of MODE field.
	IOCON_P4_14_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_14_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_14_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_14_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_14_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_14_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_14_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_14_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_14_HYS = 0x20
	// Disable.
	IOCON_P4_14_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_14_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_14_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_14_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_14_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_14_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_14_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_14_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_14_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_14_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_14_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_14_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_14_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_14_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_14_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_14_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_14_OD = 0x400
	// Disable.
	IOCON_P4_14_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_14_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_14_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_14_RESERVED_Msk = 0xfffff800

	// P4_15: I/O configuration register for pin P4[15]
	// Position of FUNC field.
	IOCON_P4_15_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_15_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_15_FUNC_P4_15 = 0x0
	// External memory address line 15.
	IOCON_P4_15_FUNC_EMC_A_15 = 0x1
	// Position of MODE field.
	IOCON_P4_15_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_15_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_15_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_15_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_15_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_15_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_15_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_15_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_15_HYS = 0x20
	// Disable.
	IOCON_P4_15_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_15_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_15_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_15_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_15_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_15_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_15_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_15_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_15_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_15_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_15_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_15_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_15_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_15_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_15_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_15_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_15_OD = 0x400
	// Disable.
	IOCON_P4_15_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_15_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_15_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_15_RESERVED_Msk = 0xfffff800

	// P4_16: I/O configuration register for pin P4[16]
	// Position of FUNC field.
	IOCON_P4_16_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_16_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_16_FUNC_P4_16 = 0x0
	// External memory address line 16.
	IOCON_P4_16_FUNC_EMC_A_16 = 0x1
	// Position of MODE field.
	IOCON_P4_16_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_16_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_16_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_16_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_16_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_16_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_16_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_16_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_16_HYS = 0x20
	// Disable.
	IOCON_P4_16_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_16_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_16_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_16_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_16_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_16_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_16_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_16_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_16_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_16_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_16_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_16_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_16_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_16_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_16_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_16_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_16_OD = 0x400
	// Disable.
	IOCON_P4_16_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_16_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_16_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_16_RESERVED_Msk = 0xfffff800

	// P4_17: I/O configuration register for pin P4[17]
	// Position of FUNC field.
	IOCON_P4_17_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_17_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_17_FUNC_P4_17 = 0x0
	// External memory address line 17.
	IOCON_P4_17_FUNC_EMC_A_17 = 0x1
	// Position of MODE field.
	IOCON_P4_17_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_17_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_17_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_17_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_17_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_17_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_17_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_17_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_17_HYS = 0x20
	// Disable.
	IOCON_P4_17_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_17_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_17_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_17_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_17_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_17_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_17_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_17_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_17_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_17_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_17_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_17_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_17_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_17_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_17_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_17_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_17_OD = 0x400
	// Disable.
	IOCON_P4_17_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_17_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_17_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_17_RESERVED_Msk = 0xfffff800

	// P4_18: I/O configuration register for pin P4[18]
	// Position of FUNC field.
	IOCON_P4_18_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_18_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_18_FUNC_P4_18 = 0x0
	// External memory address line 18.
	IOCON_P4_18_FUNC_EMC_A_18 = 0x1
	// Position of MODE field.
	IOCON_P4_18_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_18_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_18_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_18_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_18_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_18_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_18_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_18_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_18_HYS = 0x20
	// Disable.
	IOCON_P4_18_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_18_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_18_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_18_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_18_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_18_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_18_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_18_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_18_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_18_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_18_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_18_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_18_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_18_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_18_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_18_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_18_OD = 0x400
	// Disable.
	IOCON_P4_18_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_18_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_18_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_18_RESERVED_Msk = 0xfffff800

	// P4_19: I/O configuration register for pin P4[19]
	// Position of FUNC field.
	IOCON_P4_19_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_19_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_19_FUNC_P4_19 = 0x0
	// External memory address line 19.
	IOCON_P4_19_FUNC_EMC_A_19 = 0x1
	// Position of MODE field.
	IOCON_P4_19_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_19_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_19_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_19_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_19_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_19_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_19_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_19_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_19_HYS = 0x20
	// Disable.
	IOCON_P4_19_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_19_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_19_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_19_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_19_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_19_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_19_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_19_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_19_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_19_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_19_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_19_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_19_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_19_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_19_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_19_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_19_OD = 0x400
	// Disable.
	IOCON_P4_19_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_19_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_19_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_19_RESERVED_Msk = 0xfffff800

	// P4_20: I/O configuration register for pin P4[20]
	// Position of FUNC field.
	IOCON_P4_20_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_20_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_20_FUNC_P4_20 = 0x0
	// External memory address line 20.
	IOCON_P4_20_FUNC_EMC_A_20 = 0x1
	// I2C2 data input/output (this pin does not use a specialized I2C pad).
	IOCON_P4_20_FUNC_I2C2_SDA = 0x2
	// Serial Clock for SSP1.
	IOCON_P4_20_FUNC_SSP1_SCK = 0x3
	// Position of MODE field.
	IOCON_P4_20_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_20_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_20_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_20_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_20_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_20_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_20_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_20_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_20_HYS = 0x20
	// Disable.
	IOCON_P4_20_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_20_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_20_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_20_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_20_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_20_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_20_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_20_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_20_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_20_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_20_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_20_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_20_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_20_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_20_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_20_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_20_OD = 0x400
	// Disable.
	IOCON_P4_20_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_20_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_20_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_20_RESERVED_Msk = 0xfffff800

	// P4_21: I/O configuration register for pin P4[21]
	// Position of FUNC field.
	IOCON_P4_21_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_21_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_21_FUNC_P4_21 = 0x0
	// External memory address line 21.
	IOCON_P4_21_FUNC_EMC_A_21 = 0x1
	// I2C2 clock input/output (this pin does not use a specialized I2C pad).
	IOCON_P4_21_FUNC_I2C2_SCL = 0x2
	// Slave Select for SSP1.
	IOCON_P4_21_FUNC_SSP1_SSEL = 0x3
	// Position of MODE field.
	IOCON_P4_21_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_21_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_21_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_21_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_21_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_21_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_21_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_21_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_21_HYS = 0x20
	// Disable.
	IOCON_P4_21_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_21_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_21_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_21_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_21_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_21_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_21_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_21_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_21_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_21_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_21_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_21_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_21_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_21_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_21_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_21_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_21_OD = 0x400
	// Disable.
	IOCON_P4_21_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_21_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_21_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_21_RESERVED_Msk = 0xfffff800

	// P4_22: I/O configuration register for pin P4[22]
	// Position of FUNC field.
	IOCON_P4_22_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_22_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_22_FUNC_P4_22 = 0x0
	// External memory address line 22.
	IOCON_P4_22_FUNC_EMC_A_22 = 0x1
	// Transmitter output for UART2.
	IOCON_P4_22_FUNC_U2_TXD = 0x2
	// Master In Slave Out for SSP1.
	IOCON_P4_22_FUNC_SSP1_MISO = 0x3
	// Position of MODE field.
	IOCON_P4_22_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_22_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_22_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_22_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_22_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_22_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_22_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_22_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_22_HYS = 0x20
	// Disable.
	IOCON_P4_22_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_22_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_22_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_22_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_22_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_22_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_22_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_22_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_22_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_22_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_22_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_22_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_22_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_22_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_22_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_22_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_22_OD = 0x400
	// Disable.
	IOCON_P4_22_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_22_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_22_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_22_RESERVED_Msk = 0xfffff800

	// P4_23: I/O configuration register for pin P4[23]
	// Position of FUNC field.
	IOCON_P4_23_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_23_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_23_FUNC_P4_23 = 0x0
	// External memory address line 23.
	IOCON_P4_23_FUNC_EMC_A_23 = 0x1
	// Receiver input for UART2.
	IOCON_P4_23_FUNC_U2_RXD = 0x2
	// Master Out Slave In for SSP1.
	IOCON_P4_23_FUNC_SSP1_MOSI = 0x3
	// Position of MODE field.
	IOCON_P4_23_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_23_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_23_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_23_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_23_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_23_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_23_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_23_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_23_HYS = 0x20
	// Disable.
	IOCON_P4_23_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_23_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_23_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_23_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_23_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_23_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_23_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_23_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_23_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_23_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_23_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_23_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_23_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_23_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_23_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_23_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_23_OD = 0x400
	// Disable.
	IOCON_P4_23_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_23_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_23_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_23_RESERVED_Msk = 0xfffff800

	// P4_24: I/O configuration register for pin P4[24]
	// Position of FUNC field.
	IOCON_P4_24_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_24_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_24_FUNC_P4_24 = 0x0
	// LOW active Output Enable signal.
	IOCON_P4_24_FUNC_EMC_OE = 0x1
	// Position of MODE field.
	IOCON_P4_24_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_24_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_24_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_24_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_24_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_24_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_24_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_24_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_24_HYS = 0x20
	// Disable.
	IOCON_P4_24_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_24_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_24_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_24_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_24_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_24_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_24_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_24_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_24_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_24_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_24_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_24_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_24_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_24_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_24_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_24_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_24_OD = 0x400
	// Disable.
	IOCON_P4_24_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_24_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_24_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_24_RESERVED_Msk = 0xfffff800

	// P4_25: I/O configuration register for pin P4[25]
	// Position of FUNC field.
	IOCON_P4_25_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_25_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_25_FUNC_P4_25 = 0x0
	// LOW active Write Enable signal.
	IOCON_P4_25_FUNC_EMC_WE = 0x1
	// Position of MODE field.
	IOCON_P4_25_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_25_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_25_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_25_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_25_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_25_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_25_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_25_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_25_HYS = 0x20
	// Disable.
	IOCON_P4_25_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_25_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_25_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_25_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_25_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_25_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_25_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_25_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_25_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_25_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_25_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_25_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_25_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_25_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_25_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_25_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_25_OD = 0x400
	// Disable.
	IOCON_P4_25_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_25_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_25_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_25_RESERVED_Msk = 0xfffff800

	// P4_26: I/O configuration register for pin P4[26]
	// Position of FUNC field.
	IOCON_P4_26_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_26_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_26_FUNC_P4_26 = 0x0
	// LOW active Byte Lane select signal 0.
	IOCON_P4_26_FUNC_EMC_BLS0 = 0x1
	// Position of MODE field.
	IOCON_P4_26_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_26_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_26_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_26_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_26_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_26_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_26_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_26_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_26_HYS = 0x20
	// Disable.
	IOCON_P4_26_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_26_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_26_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_26_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_26_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_26_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_26_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_26_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_26_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_26_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_26_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_26_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_26_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_26_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_26_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_26_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_26_OD = 0x400
	// Disable.
	IOCON_P4_26_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_26_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_26_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_26_RESERVED_Msk = 0xfffff800

	// P4_27: I/O configuration register for pin P4[27]
	// Position of FUNC field.
	IOCON_P4_27_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_27_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_27_FUNC_P4_27 = 0x0
	// LOW active Byte Lane select signal 1.
	IOCON_P4_27_FUNC_EMC_BLS1 = 0x1
	// Position of MODE field.
	IOCON_P4_27_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_27_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_27_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_27_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_27_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_27_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_27_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_27_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_27_HYS = 0x20
	// Disable.
	IOCON_P4_27_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_27_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_27_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_27_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_27_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_27_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_27_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_27_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_27_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_27_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_27_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_27_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_27_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_27_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_27_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_27_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_27_OD = 0x400
	// Disable.
	IOCON_P4_27_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_27_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_27_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_27_RESERVED_Msk = 0xfffff800

	// P4_28: I/O configuration register for pin P4[28]
	// Position of FUNC field.
	IOCON_P4_28_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_28_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_28_FUNC_P4_28 = 0x0
	// LOW active Byte Lane select signal 2.
	IOCON_P4_28_FUNC_EMC_BLS2 = 0x1
	// Transmitter output for UART3.
	IOCON_P4_28_FUNC_U3_TXD = 0x2
	// Match output for Timer 2, channel 0.
	IOCON_P4_28_FUNC_T2_MAT0 = 0x3
	// LCD data.
	IOCON_P4_28_FUNC_LCD_VD_6 = 0x5
	// LCD data.
	IOCON_P4_28_FUNC_LCD_VD_10 = 0x6
	// LCD data.
	IOCON_P4_28_FUNC_LCD_VD_2 = 0x7
	// Position of MODE field.
	IOCON_P4_28_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_28_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_28_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_28_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_28_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_28_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_28_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_28_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_28_HYS = 0x20
	// Disable.
	IOCON_P4_28_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_28_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_28_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_28_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_28_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_28_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_28_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_28_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_28_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_28_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_28_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_28_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_28_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_28_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_28_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_28_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_28_OD = 0x400
	// Disable.
	IOCON_P4_28_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_28_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_28_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_28_RESERVED_Msk = 0xfffff800

	// P4_29: I/O configuration register for pin P4[29]
	// Position of FUNC field.
	IOCON_P4_29_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_29_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_29_FUNC_P4_29 = 0x0
	// LOW active Byte Lane select signal 3.
	IOCON_P4_29_FUNC_EMC_BLS3 = 0x1
	// Receiver input for UART3.
	IOCON_P4_29_FUNC_U3_RXD = 0x2
	// Match output for Timer 2, channel 1.
	IOCON_P4_29_FUNC_T2_MAT1 = 0x3
	// I2C2 clock input/output (this pin does not use a specialized I2C pad).
	IOCON_P4_29_FUNC_I2C2_SCL = 0x4
	// LCD data.
	IOCON_P4_29_FUNC_LCD_VD_7 = 0x5
	// LCD data.
	IOCON_P4_29_FUNC_LCD_VD_11 = 0x6
	// LCD data.
	IOCON_P4_29_FUNC_LCD_VD_3 = 0x7
	// Position of MODE field.
	IOCON_P4_29_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_29_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_29_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_29_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_29_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_29_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_29_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_29_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_29_HYS = 0x20
	// Disable.
	IOCON_P4_29_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_29_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_29_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_29_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_29_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_29_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_29_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_29_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_29_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_29_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_29_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_29_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_29_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_29_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_29_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_29_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_29_OD = 0x400
	// Disable.
	IOCON_P4_29_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_29_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_29_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_29_RESERVED_Msk = 0xfffff800

	// P4_30: I/O configuration register for pin P4[30]
	// Position of FUNC field.
	IOCON_P4_30_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_30_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_30_FUNC_P4_30 = 0x0
	// LOW active Chip Select 0 signal.
	IOCON_P4_30_FUNC_EMC_CS0 = 0x1
	// Comparator 0, output.
	IOCON_P4_30_FUNC_CMP0_OUT = 0x5
	// Position of MODE field.
	IOCON_P4_30_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_30_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_30_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_30_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_30_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_30_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_30_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_30_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_30_HYS = 0x20
	// Disable.
	IOCON_P4_30_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_30_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_30_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_30_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_30_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_30_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_30_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_30_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_30_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_30_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_30_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_30_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_30_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_30_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_30_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_30_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_30_OD = 0x400
	// Disable.
	IOCON_P4_30_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_30_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_30_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_30_RESERVED_Msk = 0xfffff800

	// P4_31: I/O configuration register for pin P4[31]
	// Position of FUNC field.
	IOCON_P4_31_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P4_31_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P4_31_FUNC_P4_31 = 0x0
	// LOW active Chip Select 1 signal.
	IOCON_P4_31_FUNC_EMC_CS1 = 0x1
	// Position of MODE field.
	IOCON_P4_31_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P4_31_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P4_31_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P4_31_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P4_31_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P4_31_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P4_31_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P4_31_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P4_31_HYS = 0x20
	// Disable.
	IOCON_P4_31_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P4_31_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P4_31_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P4_31_INV_Msk = 0x40
	// Bit INV.
	IOCON_P4_31_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P4_31_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P4_31_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P4_31_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P4_31_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P4_31_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P4_31_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P4_31_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P4_31_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P4_31_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P4_31_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P4_31_OD_Msk = 0x400
	// Bit OD.
	IOCON_P4_31_OD = 0x400
	// Disable.
	IOCON_P4_31_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P4_31_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P4_31_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P4_31_RESERVED_Msk = 0xfffff800

	// P5_0: I/O configuration register for pin P5[0]
	// Position of FUNC field.
	IOCON_P5_0_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P5_0_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P5_0_FUNC_P5_0 = 0x0
	// External memory address line 24.
	IOCON_P5_0_FUNC_EMC_A_24 = 0x1
	// Master Out Slave In for SSP2.
	IOCON_P5_0_FUNC_SSP2_MOSI = 0x2
	// Match output for Timer 2, channel 2.
	IOCON_P5_0_FUNC_T2_MAT2 = 0x3
	// Position of MODE field.
	IOCON_P5_0_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P5_0_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P5_0_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P5_0_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P5_0_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P5_0_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P5_0_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P5_0_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P5_0_HYS = 0x20
	// Disable.
	IOCON_P5_0_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P5_0_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P5_0_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P5_0_INV_Msk = 0x40
	// Bit INV.
	IOCON_P5_0_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P5_0_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P5_0_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P5_0_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P5_0_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P5_0_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P5_0_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P5_0_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P5_0_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P5_0_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P5_0_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P5_0_OD_Msk = 0x400
	// Bit OD.
	IOCON_P5_0_OD = 0x400
	// Disable.
	IOCON_P5_0_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P5_0_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P5_0_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P5_0_RESERVED_Msk = 0xfffff800

	// P5_1: I/O configuration register for pin P5[1]
	// Position of FUNC field.
	IOCON_P5_1_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P5_1_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P5_1_FUNC_P5_1 = 0x0
	// External memory address line 25.
	IOCON_P5_1_FUNC_EMC_A_25 = 0x1
	// Master In Slave Out for SSP2.
	IOCON_P5_1_FUNC_SSP2_MISO = 0x2
	// Match output for Timer 2, channel 3.
	IOCON_P5_1_FUNC_T2_MAT3 = 0x3
	// Position of MODE field.
	IOCON_P5_1_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P5_1_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P5_1_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P5_1_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P5_1_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P5_1_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P5_1_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P5_1_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P5_1_HYS = 0x20
	// Disable.
	IOCON_P5_1_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P5_1_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P5_1_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P5_1_INV_Msk = 0x40
	// Bit INV.
	IOCON_P5_1_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P5_1_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P5_1_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P5_1_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P5_1_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P5_1_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P5_1_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P5_1_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P5_1_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P5_1_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P5_1_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P5_1_OD_Msk = 0x400
	// Bit OD.
	IOCON_P5_1_OD = 0x400
	// Disable.
	IOCON_P5_1_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P5_1_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P5_1_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P5_1_RESERVED_Msk = 0xfffff800

	// P5_2: I/O configuration register for pin P5[2]
	// Position of FUNC field.
	IOCON_P5_2_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P5_2_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P5_2_FUNC_P5_2 = 0x0
	// Match output for Timer 3, channel 2.
	IOCON_P5_2_FUNC_T3_MAT2 = 0x3
	// I2C0 data input/output (this pin uses a specialized I2C pad that supports I2C Fast Mode Plus).
	IOCON_P5_2_FUNC_I2C0_SDA = 0x5
	// Position of RESERVED field.
	IOCON_P5_2_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	IOCON_P5_2_RESERVED_Msk = 0x38
	// Position of INV field.
	IOCON_P5_2_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P5_2_INV_Msk = 0x40
	// Bit INV.
	IOCON_P5_2_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P5_2_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P5_2_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P5_2_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P5_2_RESERVED_Msk = 0x80
	// Bit RESERVED.
	IOCON_P5_2_RESERVED = 0x80
	// Position of HS field.
	IOCON_P5_2_HS_Pos = 0x8
	// Bit mask of HS field.
	IOCON_P5_2_HS_Msk = 0x100
	// Bit HS.
	IOCON_P5_2_HS = 0x100
	// I2C 50ns glitch filter and slew rate control enabled.
	IOCON_P5_2_HS_ENABLED = 0x0
	// I2C 50ns glitch filter and slew rate control disabled.
	IOCON_P5_2_HS_DISABLED = 0x1
	// Position of HIDRIVE field.
	IOCON_P5_2_HIDRIVE_Pos = 0x9
	// Bit mask of HIDRIVE field.
	IOCON_P5_2_HIDRIVE_Msk = 0x200
	// Bit HIDRIVE.
	IOCON_P5_2_HIDRIVE = 0x200
	// Output drive sink is 4 mA. This is sufficient for standard and fast mode I2C.
	IOCON_P5_2_HIDRIVE_LOWDRIVE = 0x0
	// Output drive sink is 20 mA. This is needed for Fast Mode Plus I2C. Refer to the appropriate specific device data sheet for details.
	IOCON_P5_2_HIDRIVE_HIGHDRIVE = 0x1
	// Position of RESERVED field.
	IOCON_P5_2_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	IOCON_P5_2_RESERVED_Msk = 0xfffffc00

	// P5_3: I/O configuration register for pin P5[3]
	// Position of FUNC field.
	IOCON_P5_3_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P5_3_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P5_3_FUNC_P5_3 = 0x0
	// Receiver input for USART4.
	IOCON_P5_3_FUNC_U4_RXD = 0x4
	// I2C0 clock input/output (this pin uses a specialized I2C pad that supports I2C Fast Mode Plus.
	IOCON_P5_3_FUNC_I2C0_SCL = 0x5
	// Position of RESERVED field.
	IOCON_P5_3_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	IOCON_P5_3_RESERVED_Msk = 0x38
	// Position of INV field.
	IOCON_P5_3_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P5_3_INV_Msk = 0x40
	// Bit INV.
	IOCON_P5_3_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P5_3_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P5_3_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P5_3_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P5_3_RESERVED_Msk = 0x80
	// Bit RESERVED.
	IOCON_P5_3_RESERVED = 0x80
	// Position of HS field.
	IOCON_P5_3_HS_Pos = 0x8
	// Bit mask of HS field.
	IOCON_P5_3_HS_Msk = 0x100
	// Bit HS.
	IOCON_P5_3_HS = 0x100
	// I2C 50ns glitch filter and slew rate control enabled.
	IOCON_P5_3_HS_ENABLED = 0x0
	// I2C 50ns glitch filter and slew rate control disabled.
	IOCON_P5_3_HS_DISABLED = 0x1
	// Position of HIDRIVE field.
	IOCON_P5_3_HIDRIVE_Pos = 0x9
	// Bit mask of HIDRIVE field.
	IOCON_P5_3_HIDRIVE_Msk = 0x200
	// Bit HIDRIVE.
	IOCON_P5_3_HIDRIVE = 0x200
	// Output drive sink is 4 mA. This is sufficient for standard and fast mode I2C.
	IOCON_P5_3_HIDRIVE_LOWDRIVE = 0x0
	// Output drive sink is 20 mA. This is needed for Fast Mode Plus I2C. Refer to the appropriate specific device data sheet for details.
	IOCON_P5_3_HIDRIVE_HIGHDRIVE = 0x1
	// Position of RESERVED field.
	IOCON_P5_3_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	IOCON_P5_3_RESERVED_Msk = 0xfffffc00

	// P5_4: I/O configuration register for pin P5[4]
	// Position of FUNC field.
	IOCON_P5_4_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_P5_4_FUNC_Msk = 0x7
	// General purpose digital input/output pin.
	IOCON_P5_4_FUNC_P5_4 = 0x0
	// RS-485/EIA-485 output enable signal for UART0.
	IOCON_P5_4_FUNC_U0_OE = 0x1
	// Match output for Timer 3, channel 3.
	IOCON_P5_4_FUNC_T3_MAT3 = 0x3
	// Transmitter output for USART4 (input/output in smart card mode).
	IOCON_P5_4_FUNC_U4_TXD = 0x4
	// Position of MODE field.
	IOCON_P5_4_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_P5_4_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_P5_4_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_P5_4_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_P5_4_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_P5_4_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_P5_4_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_P5_4_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_P5_4_HYS = 0x20
	// Disable.
	IOCON_P5_4_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_P5_4_HYS_ENABLE_ = 0x1
	// Position of INV field.
	IOCON_P5_4_INV_Pos = 0x6
	// Bit mask of INV field.
	IOCON_P5_4_INV_Msk = 0x40
	// Bit INV.
	IOCON_P5_4_INV = 0x40
	// Input not inverted (HIGH on pin reads as 1, LOW on pin reads as 0).
	IOCON_P5_4_INV_INPUT_NOT_INVERTED_ = 0x0
	// Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).
	IOCON_P5_4_INV_INPUT_INVERTED_HIGH = 0x1
	// Position of RESERVED field.
	IOCON_P5_4_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	IOCON_P5_4_RESERVED_Msk = 0x180
	// Position of SLEW field.
	IOCON_P5_4_SLEW_Pos = 0x9
	// Bit mask of SLEW field.
	IOCON_P5_4_SLEW_Msk = 0x200
	// Bit SLEW.
	IOCON_P5_4_SLEW = 0x200
	// Standard mode, output slew rate control is enabled. More outputs can be switched simultaneously.
	IOCON_P5_4_SLEW_STANDARD = 0x0
	// Fast mode, slew rate control is disabled. Refer to the appropriate specific device data sheet for details.
	IOCON_P5_4_SLEW_FAST = 0x1
	// Position of OD field.
	IOCON_P5_4_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_P5_4_OD_Msk = 0x400
	// Bit OD.
	IOCON_P5_4_OD = 0x400
	// Disable.
	IOCON_P5_4_OD_DISABLE_ = 0x0
	// Open-drain mode enabled. This is not a true open-drain mode. Input cannot be pulled up above VDD.
	IOCON_P5_4_OD_OPEN_DRAIN_MODE_ENAB = 0x1
	// Position of RESERVED field.
	IOCON_P5_4_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_P5_4_RESERVED_Msk = 0xfffff800
)

// Constants for SSP1: SSP1 controller
const (
	// CR0: Control Register 0. Selects the serial clock rate, bus type, and data size.
	// Position of DSS field.
	SSP1_CR0_DSS_Pos = 0x0
	// Bit mask of DSS field.
	SSP1_CR0_DSS_Msk = 0xf
	// 4-bit transfer
	SSP1_CR0_DSS_4_BIT_TRANSFER = 0x3
	// 5-bit transfer
	SSP1_CR0_DSS_5_BIT_TRANSFER = 0x4
	// 6-bit transfer
	SSP1_CR0_DSS_6_BIT_TRANSFER = 0x5
	// 7-bit transfer
	SSP1_CR0_DSS_7_BIT_TRANSFER = 0x6
	// 8-bit transfer
	SSP1_CR0_DSS_8_BIT_TRANSFER = 0x7
	// 9-bit transfer
	SSP1_CR0_DSS_9_BIT_TRANSFER = 0x8
	// 10-bit transfer
	SSP1_CR0_DSS_10_BIT_TRANSFER = 0x9
	// 11-bit transfer
	SSP1_CR0_DSS_11_BIT_TRANSFER = 0xa
	// 12-bit transfer
	SSP1_CR0_DSS_12_BIT_TRANSFER = 0xb
	// 13-bit transfer
	SSP1_CR0_DSS_13_BIT_TRANSFER = 0xc
	// 14-bit transfer
	SSP1_CR0_DSS_14_BIT_TRANSFER = 0xd
	// 15-bit transfer
	SSP1_CR0_DSS_15_BIT_TRANSFER = 0xe
	// 16-bit transfer
	SSP1_CR0_DSS_16_BIT_TRANSFER = 0xf
	// Position of FRF field.
	SSP1_CR0_FRF_Pos = 0x4
	// Bit mask of FRF field.
	SSP1_CR0_FRF_Msk = 0x30
	// SPI
	SSP1_CR0_FRF_SPI = 0x0
	// TI
	SSP1_CR0_FRF_TI = 0x1
	// Microwire
	SSP1_CR0_FRF_MICROWIRE = 0x2
	// This combination is not supported and should not be used.
	SSP1_CR0_FRF_THIS_COMBINATION_IS_ = 0x3
	// Position of CPOL field.
	SSP1_CR0_CPOL_Pos = 0x6
	// Bit mask of CPOL field.
	SSP1_CR0_CPOL_Msk = 0x40
	// Bit CPOL.
	SSP1_CR0_CPOL = 0x40
	// SSP controller maintains the bus clock low between frames.
	SSP1_CR0_CPOL_BUS_LOW = 0x0
	// SSP controller maintains the bus clock high between frames.
	SSP1_CR0_CPOL_BUS_HIGH = 0x1
	// Position of CPHA field.
	SSP1_CR0_CPHA_Pos = 0x7
	// Bit mask of CPHA field.
	SSP1_CR0_CPHA_Msk = 0x80
	// Bit CPHA.
	SSP1_CR0_CPHA = 0x80
	// SSP controller captures serial data on the first clock transition of the frame, that is, the transition away from the inter-frame state of the clock line.
	SSP1_CR0_CPHA_FIRST_CLOCK = 0x0
	// SSP controller captures serial data on the second clock transition of the frame, that is, the transition back to the inter-frame state of the clock line.
	SSP1_CR0_CPHA_SECOND_CLOCK = 0x1
	// Position of SCR field.
	SSP1_CR0_SCR_Pos = 0x8
	// Bit mask of SCR field.
	SSP1_CR0_SCR_Msk = 0xff00
	// Position of RESERVED field.
	SSP1_CR0_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	SSP1_CR0_RESERVED_Msk = 0xffff0000

	// CR1: Control Register 1. Selects master/slave and other modes.
	// Position of LBM field.
	SSP1_CR1_LBM_Pos = 0x0
	// Bit mask of LBM field.
	SSP1_CR1_LBM_Msk = 0x1
	// Bit LBM.
	SSP1_CR1_LBM = 0x1
	// During normal operation.
	SSP1_CR1_LBM_NORMAL = 0x0
	// Serial input is taken from the serial output (MOSI or MISO) rather than the serial input pin (MISO or MOSI respectively).
	SSP1_CR1_LBM_OUPTU = 0x1
	// Position of SSE field.
	SSP1_CR1_SSE_Pos = 0x1
	// Bit mask of SSE field.
	SSP1_CR1_SSE_Msk = 0x2
	// Bit SSE.
	SSP1_CR1_SSE = 0x2
	// The SSP controller is disabled.
	SSP1_CR1_SSE_DISABLED = 0x0
	// The SSP controller will interact with other devices on the serial bus. Software should write the appropriate control information to the other SSP registers and interrupt controller registers, before setting this bit.
	SSP1_CR1_SSE_ENABLED = 0x1
	// Position of MS field.
	SSP1_CR1_MS_Pos = 0x2
	// Bit mask of MS field.
	SSP1_CR1_MS_Msk = 0x4
	// Bit MS.
	SSP1_CR1_MS = 0x4
	// The SSP controller acts as a master on the bus, driving the SCLK, MOSI, and SSEL lines and receiving the MISO line.
	SSP1_CR1_MS_MASTER = 0x0
	// The SSP controller acts as a slave on the bus, driving MISO line and receiving SCLK, MOSI, and SSEL lines.
	SSP1_CR1_MS_SLAVE = 0x1
	// Position of SOD field.
	SSP1_CR1_SOD_Pos = 0x3
	// Bit mask of SOD field.
	SSP1_CR1_SOD_Msk = 0x8
	// Bit SOD.
	SSP1_CR1_SOD = 0x8
	// Position of RESERVED field.
	SSP1_CR1_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	SSP1_CR1_RESERVED_Msk = 0xfffffff0

	// DR: Data Register. Writes fill the transmit FIFO, and reads empty the receive FIFO.
	// Position of DATA field.
	SSP1_DR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	SSP1_DR_DATA_Msk = 0xffff
	// Position of RESERVED field.
	SSP1_DR_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	SSP1_DR_RESERVED_Msk = 0xffff0000

	// SR: Status Register
	// Position of TFE field.
	SSP1_SR_TFE_Pos = 0x0
	// Bit mask of TFE field.
	SSP1_SR_TFE_Msk = 0x1
	// Bit TFE.
	SSP1_SR_TFE = 0x1
	// Position of TNF field.
	SSP1_SR_TNF_Pos = 0x1
	// Bit mask of TNF field.
	SSP1_SR_TNF_Msk = 0x2
	// Bit TNF.
	SSP1_SR_TNF = 0x2
	// Position of RNE field.
	SSP1_SR_RNE_Pos = 0x2
	// Bit mask of RNE field.
	SSP1_SR_RNE_Msk = 0x4
	// Bit RNE.
	SSP1_SR_RNE = 0x4
	// Position of RFF field.
	SSP1_SR_RFF_Pos = 0x3
	// Bit mask of RFF field.
	SSP1_SR_RFF_Msk = 0x8
	// Bit RFF.
	SSP1_SR_RFF = 0x8
	// Position of BSY field.
	SSP1_SR_BSY_Pos = 0x4
	// Bit mask of BSY field.
	SSP1_SR_BSY_Msk = 0x10
	// Bit BSY.
	SSP1_SR_BSY = 0x10
	// Position of RESERVED field.
	SSP1_SR_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	SSP1_SR_RESERVED_Msk = 0xffffffe0

	// CPSR: Clock Prescale Register
	// Position of CPSDVSR field.
	SSP1_CPSR_CPSDVSR_Pos = 0x0
	// Bit mask of CPSDVSR field.
	SSP1_CPSR_CPSDVSR_Msk = 0xff
	// Position of RESERVED field.
	SSP1_CPSR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SSP1_CPSR_RESERVED_Msk = 0xffffff00

	// IMSC: Interrupt Mask Set and Clear Register
	// Position of RORIM field.
	SSP1_IMSC_RORIM_Pos = 0x0
	// Bit mask of RORIM field.
	SSP1_IMSC_RORIM_Msk = 0x1
	// Bit RORIM.
	SSP1_IMSC_RORIM = 0x1
	// Position of RTIM field.
	SSP1_IMSC_RTIM_Pos = 0x1
	// Bit mask of RTIM field.
	SSP1_IMSC_RTIM_Msk = 0x2
	// Bit RTIM.
	SSP1_IMSC_RTIM = 0x2
	// Position of RXIM field.
	SSP1_IMSC_RXIM_Pos = 0x2
	// Bit mask of RXIM field.
	SSP1_IMSC_RXIM_Msk = 0x4
	// Bit RXIM.
	SSP1_IMSC_RXIM = 0x4
	// Position of TXIM field.
	SSP1_IMSC_TXIM_Pos = 0x3
	// Bit mask of TXIM field.
	SSP1_IMSC_TXIM_Msk = 0x8
	// Bit TXIM.
	SSP1_IMSC_TXIM = 0x8
	// Position of RESERVED field.
	SSP1_IMSC_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	SSP1_IMSC_RESERVED_Msk = 0xfffffff0

	// RIS: Raw Interrupt Status Register
	// Position of RORRIS field.
	SSP1_RIS_RORRIS_Pos = 0x0
	// Bit mask of RORRIS field.
	SSP1_RIS_RORRIS_Msk = 0x1
	// Bit RORRIS.
	SSP1_RIS_RORRIS = 0x1
	// Position of RTRIS field.
	SSP1_RIS_RTRIS_Pos = 0x1
	// Bit mask of RTRIS field.
	SSP1_RIS_RTRIS_Msk = 0x2
	// Bit RTRIS.
	SSP1_RIS_RTRIS = 0x2
	// Position of RXRIS field.
	SSP1_RIS_RXRIS_Pos = 0x2
	// Bit mask of RXRIS field.
	SSP1_RIS_RXRIS_Msk = 0x4
	// Bit RXRIS.
	SSP1_RIS_RXRIS = 0x4
	// Position of TXRIS field.
	SSP1_RIS_TXRIS_Pos = 0x3
	// Bit mask of TXRIS field.
	SSP1_RIS_TXRIS_Msk = 0x8
	// Bit TXRIS.
	SSP1_RIS_TXRIS = 0x8
	// Position of RESERVED field.
	SSP1_RIS_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	SSP1_RIS_RESERVED_Msk = 0xfffffff0

	// MIS: Masked Interrupt Status Register
	// Position of RORMIS field.
	SSP1_MIS_RORMIS_Pos = 0x0
	// Bit mask of RORMIS field.
	SSP1_MIS_RORMIS_Msk = 0x1
	// Bit RORMIS.
	SSP1_MIS_RORMIS = 0x1
	// Position of RTMIS field.
	SSP1_MIS_RTMIS_Pos = 0x1
	// Bit mask of RTMIS field.
	SSP1_MIS_RTMIS_Msk = 0x2
	// Bit RTMIS.
	SSP1_MIS_RTMIS = 0x2
	// Position of RXMIS field.
	SSP1_MIS_RXMIS_Pos = 0x2
	// Bit mask of RXMIS field.
	SSP1_MIS_RXMIS_Msk = 0x4
	// Bit RXMIS.
	SSP1_MIS_RXMIS = 0x4
	// Position of TXMIS field.
	SSP1_MIS_TXMIS_Pos = 0x3
	// Bit mask of TXMIS field.
	SSP1_MIS_TXMIS_Msk = 0x8
	// Bit TXMIS.
	SSP1_MIS_TXMIS = 0x8
	// Position of RESERVED field.
	SSP1_MIS_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	SSP1_MIS_RESERVED_Msk = 0xfffffff0

	// ICR: SSPICR Interrupt Clear Register
	// Position of RORIC field.
	SSP1_ICR_RORIC_Pos = 0x0
	// Bit mask of RORIC field.
	SSP1_ICR_RORIC_Msk = 0x1
	// Bit RORIC.
	SSP1_ICR_RORIC = 0x1
	// Position of RTIC field.
	SSP1_ICR_RTIC_Pos = 0x1
	// Bit mask of RTIC field.
	SSP1_ICR_RTIC_Msk = 0x2
	// Bit RTIC.
	SSP1_ICR_RTIC = 0x2
	// Position of RESERVED field.
	SSP1_ICR_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	SSP1_ICR_RESERVED_Msk = 0xfffffffc

	// DMACR: SSP0 DMA control register
	// Position of RXDMAE field.
	SSP1_DMACR_RXDMAE_Pos = 0x0
	// Bit mask of RXDMAE field.
	SSP1_DMACR_RXDMAE_Msk = 0x1
	// Bit RXDMAE.
	SSP1_DMACR_RXDMAE = 0x1
	// Position of TXDMAE field.
	SSP1_DMACR_TXDMAE_Pos = 0x1
	// Bit mask of TXDMAE field.
	SSP1_DMACR_TXDMAE_Msk = 0x2
	// Bit TXDMAE.
	SSP1_DMACR_TXDMAE = 0x2
	// Position of RESERVED field.
	SSP1_DMACR_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	SSP1_DMACR_RESERVED_Msk = 0xfffffffc
)

// Constants for ADC: Analog-to-Digital Converter (ADC)
const (
	// CR: A/D Control Register. The ADCR register must be written to select the operating mode before A/D conversion can occur.
	// Position of SEL field.
	ADC_CR_SEL_Pos = 0x0
	// Bit mask of SEL field.
	ADC_CR_SEL_Msk = 0xff
	// Position of CLKDIV field.
	ADC_CR_CLKDIV_Pos = 0x8
	// Bit mask of CLKDIV field.
	ADC_CR_CLKDIV_Msk = 0xff00
	// Position of BURST field.
	ADC_CR_BURST_Pos = 0x10
	// Bit mask of BURST field.
	ADC_CR_BURST_Msk = 0x10000
	// Bit BURST.
	ADC_CR_BURST = 0x10000
	// The AD converter does repeated conversions at up to 400 kHz, scanning (if necessary) through the pins selected by bits set to ones in the SEL field. The first conversion after the start corresponds to the least-significant 1 in the SEL field, then higher numbered 1-bits (pins) if applicable. Repeated conversions can be terminated by clearing this bit, but the conversion that's in progress when this bit is cleared will be completed. START bits must be 000 when BURST = 1 or conversions will not start.
	ADC_CR_BURST_BURST = 0x1
	// Conversions are software controlled and require 31 clocks.
	ADC_CR_BURST_SW = 0x0
	// Position of RESERVED field.
	ADC_CR_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	ADC_CR_RESERVED_Msk = 0x1e0000
	// Position of PDN field.
	ADC_CR_PDN_Pos = 0x15
	// Bit mask of PDN field.
	ADC_CR_PDN_Msk = 0x200000
	// Bit PDN.
	ADC_CR_PDN = 0x200000
	// The A/D converter is operational.
	ADC_CR_PDN_POWERED = 0x1
	// The A/D converter is in power-down mode.
	ADC_CR_PDN_POWERDOWN = 0x0
	// Position of RESERVED field.
	ADC_CR_RESERVED_Pos = 0x16
	// Bit mask of RESERVED field.
	ADC_CR_RESERVED_Msk = 0xc00000
	// Position of START field.
	ADC_CR_START_Pos = 0x18
	// Bit mask of START field.
	ADC_CR_START_Msk = 0x7000000
	// No start (this value should be used when clearing PDN to 0).
	ADC_CR_START_NO_START_THIS_VALUE = 0x0
	// Start conversion now.
	ADC_CR_START_START_CONVERSION_NOW = 0x1
	// Start conversion when the edge selected by bit 27 occurs on the P2[10] pin.
	ADC_CR_START_P2_10 = 0x2
	// Start conversion when the edge selected by bit 27 occurs on the P1[27] pin.
	ADC_CR_START_P1_27 = 0x3
	// Start conversion when the edge selected by bit 27 occurs on MAT0.1. Note that this does not require that the MAT0.1 function appear on a device pin.
	ADC_CR_START_MAT0_1 = 0x4
	// Start conversion when the edge selected by bit 27 occurs on MAT0.3. Note that it is not possible to cause the MAT0.3 function to appear on a device pin.
	ADC_CR_START_MAT0_3 = 0x5
	// Start conversion when the edge selected by bit 27 occurs on MAT1.0. Note that this does not require that the MAT1.0 function appear on a device pin.
	ADC_CR_START_MAT1_0 = 0x6
	// Start conversion when the edge selected by bit 27 occurs on MAT1.1. Note that this does not require that the MAT1.1 function appear on a device pin.
	ADC_CR_START_MAT1_1 = 0x7
	// Position of EDGE field.
	ADC_CR_EDGE_Pos = 0x1b
	// Bit mask of EDGE field.
	ADC_CR_EDGE_Msk = 0x8000000
	// Bit EDGE.
	ADC_CR_EDGE = 0x8000000
	// Start conversion on a falling edge on the selected CAP/MAT signal.
	ADC_CR_EDGE_FALLLING = 0x1
	// Start conversion on a rising edge on the selected CAP/MAT signal.
	ADC_CR_EDGE_RISING = 0x0
	// Position of RESERVED field.
	ADC_CR_RESERVED_Pos = 0x1c
	// Bit mask of RESERVED field.
	ADC_CR_RESERVED_Msk = 0xf0000000

	// GDR: A/D Global Data Register. This register contains the ADC's DONE bit and the result of the most recent A/D conversion.
	// Position of RESERVED field.
	ADC_GDR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	ADC_GDR_RESERVED_Msk = 0xf
	// Position of RESULT field.
	ADC_GDR_RESULT_Pos = 0x4
	// Bit mask of RESULT field.
	ADC_GDR_RESULT_Msk = 0xfff0
	// Position of RESERVED field.
	ADC_GDR_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	ADC_GDR_RESERVED_Msk = 0xff0000
	// Position of CHN field.
	ADC_GDR_CHN_Pos = 0x18
	// Bit mask of CHN field.
	ADC_GDR_CHN_Msk = 0x7000000
	// Position of RESERVED field.
	ADC_GDR_RESERVED_Pos = 0x1b
	// Bit mask of RESERVED field.
	ADC_GDR_RESERVED_Msk = 0x38000000
	// Position of OVERRUN field.
	ADC_GDR_OVERRUN_Pos = 0x1e
	// Bit mask of OVERRUN field.
	ADC_GDR_OVERRUN_Msk = 0x40000000
	// Bit OVERRUN.
	ADC_GDR_OVERRUN = 0x40000000
	// Position of DONE field.
	ADC_GDR_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	ADC_GDR_DONE_Msk = 0x80000000
	// Bit DONE.
	ADC_GDR_DONE = 0x80000000

	// INTEN: A/D Interrupt Enable Register. This register contains enable bits that allow the DONE flag of each A/D channel to be included or excluded from contributing to the generation of an A/D interrupt.
	// Position of ADINTEN0 field.
	ADC_INTEN_ADINTEN0_Pos = 0x0
	// Bit mask of ADINTEN0 field.
	ADC_INTEN_ADINTEN0_Msk = 0x1
	// Bit ADINTEN0.
	ADC_INTEN_ADINTEN0 = 0x1
	// Completion of a conversion on ADC channel 0 will not generate an interrupt.
	ADC_INTEN_ADINTEN0_DISABLE = 0x0
	// Completion of a conversion on ADC channel 0 will generate an interrupt.
	ADC_INTEN_ADINTEN0_ENABLE = 0x1
	// Position of ADINTEN1 field.
	ADC_INTEN_ADINTEN1_Pos = 0x1
	// Bit mask of ADINTEN1 field.
	ADC_INTEN_ADINTEN1_Msk = 0x2
	// Bit ADINTEN1.
	ADC_INTEN_ADINTEN1 = 0x2
	// Completion of a conversion on ADC channel 1 will not generate an interrupt.
	ADC_INTEN_ADINTEN1_DISABLE = 0x0
	// Completion of a conversion on ADC channel 1 will generate an interrupt.
	ADC_INTEN_ADINTEN1_ENABLE = 0x1
	// Position of ADINTEN2 field.
	ADC_INTEN_ADINTEN2_Pos = 0x2
	// Bit mask of ADINTEN2 field.
	ADC_INTEN_ADINTEN2_Msk = 0x4
	// Bit ADINTEN2.
	ADC_INTEN_ADINTEN2 = 0x4
	// Completion of a conversion on ADC channel 2 will not generate an interrupt.
	ADC_INTEN_ADINTEN2_DISABLE = 0x0
	// Completion of a conversion on ADC channel 2 will generate an interrupt.
	ADC_INTEN_ADINTEN2_ENABLE = 0x1
	// Position of ADINTEN3 field.
	ADC_INTEN_ADINTEN3_Pos = 0x3
	// Bit mask of ADINTEN3 field.
	ADC_INTEN_ADINTEN3_Msk = 0x8
	// Bit ADINTEN3.
	ADC_INTEN_ADINTEN3 = 0x8
	// Completion of a conversion on ADC channel 3 will not generate an interrupt.
	ADC_INTEN_ADINTEN3_DISABLE = 0x0
	// Completion of a conversion on ADC channel 3 will generate an interrupt.
	ADC_INTEN_ADINTEN3_ENABLE = 0x1
	// Position of ADINTEN4 field.
	ADC_INTEN_ADINTEN4_Pos = 0x4
	// Bit mask of ADINTEN4 field.
	ADC_INTEN_ADINTEN4_Msk = 0x10
	// Bit ADINTEN4.
	ADC_INTEN_ADINTEN4 = 0x10
	// Completion of a conversion on ADC channel 4 will not generate an interrupt.
	ADC_INTEN_ADINTEN4_DISABLE = 0x0
	// Completion of a conversion on ADC channel 4 will generate an interrupt.
	ADC_INTEN_ADINTEN4_ENABLE = 0x1
	// Position of ADINTEN5 field.
	ADC_INTEN_ADINTEN5_Pos = 0x5
	// Bit mask of ADINTEN5 field.
	ADC_INTEN_ADINTEN5_Msk = 0x20
	// Bit ADINTEN5.
	ADC_INTEN_ADINTEN5 = 0x20
	// Completion of a conversion on ADC channel 5 will not generate an interrupt.
	ADC_INTEN_ADINTEN5_DISABLE = 0x0
	// Completion of a conversion on ADC channel 5 will generate an interrupt.
	ADC_INTEN_ADINTEN5_ENABLE = 0x1
	// Position of ADINTEN6 field.
	ADC_INTEN_ADINTEN6_Pos = 0x6
	// Bit mask of ADINTEN6 field.
	ADC_INTEN_ADINTEN6_Msk = 0x40
	// Bit ADINTEN6.
	ADC_INTEN_ADINTEN6 = 0x40
	// Completion of a conversion on ADC channel 6 will not generate an interrupt.
	ADC_INTEN_ADINTEN6_DISABLE = 0x0
	// Completion of a conversion on ADC channel 6 will generate an interrupt.
	ADC_INTEN_ADINTEN6_ENABLE = 0x1
	// Position of ADINTEN7 field.
	ADC_INTEN_ADINTEN7_Pos = 0x7
	// Bit mask of ADINTEN7 field.
	ADC_INTEN_ADINTEN7_Msk = 0x80
	// Bit ADINTEN7.
	ADC_INTEN_ADINTEN7 = 0x80
	// Completion of a conversion on ADC channel 7 will not generate an interrupt.
	ADC_INTEN_ADINTEN7_DISABLE = 0x0
	// Completion of a conversion on ADC channel 7 will generate an interrupt.
	ADC_INTEN_ADINTEN7_ENABLE = 0x1
	// Position of ADGINTEN field.
	ADC_INTEN_ADGINTEN_Pos = 0x8
	// Bit mask of ADGINTEN field.
	ADC_INTEN_ADGINTEN_Msk = 0x100
	// Bit ADGINTEN.
	ADC_INTEN_ADGINTEN = 0x100
	// Only the individual ADC channels enabled by ADINTEN7:0 will generate interrupts.
	ADC_INTEN_ADGINTEN_CHANNELS = 0x0
	// The global DONE flag in ADDR is enabled to generate an interrupt in addition to any individual ADC channels that are enabled to generate interrupts.
	ADC_INTEN_ADGINTEN_GLOBAL = 0x1
	// Position of RESERVED field.
	ADC_INTEN_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	ADC_INTEN_RESERVED_Msk = 0xfffffe00

	// DR: A/D Channel 0 Data Register. This register contains the result of the most recent conversion completed on channel 0.
	// Position of RESERVED field.
	ADC_DR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	ADC_DR_RESERVED_Msk = 0xf
	// Position of RESULT field.
	ADC_DR_RESULT_Pos = 0x4
	// Bit mask of RESULT field.
	ADC_DR_RESULT_Msk = 0xfff0
	// Position of RESERVED field.
	ADC_DR_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	ADC_DR_RESERVED_Msk = 0x3fff0000
	// Position of OVERRUN field.
	ADC_DR_OVERRUN_Pos = 0x1e
	// Bit mask of OVERRUN field.
	ADC_DR_OVERRUN_Msk = 0x40000000
	// Bit OVERRUN.
	ADC_DR_OVERRUN = 0x40000000
	// Position of DONE field.
	ADC_DR_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	ADC_DR_DONE_Msk = 0x80000000
	// Bit DONE.
	ADC_DR_DONE = 0x80000000

	// STAT: A/D Status Register. This register contains DONE and OVERRUN flags for all of the A/D channels, as well as the A/D interrupt/DMA flag.
	// Position of DONE0 field.
	ADC_STAT_DONE0_Pos = 0x0
	// Bit mask of DONE0 field.
	ADC_STAT_DONE0_Msk = 0x1
	// Bit DONE0.
	ADC_STAT_DONE0 = 0x1
	// Position of DONE1 field.
	ADC_STAT_DONE1_Pos = 0x1
	// Bit mask of DONE1 field.
	ADC_STAT_DONE1_Msk = 0x2
	// Bit DONE1.
	ADC_STAT_DONE1 = 0x2
	// Position of DONE2 field.
	ADC_STAT_DONE2_Pos = 0x2
	// Bit mask of DONE2 field.
	ADC_STAT_DONE2_Msk = 0x4
	// Bit DONE2.
	ADC_STAT_DONE2 = 0x4
	// Position of DONE3 field.
	ADC_STAT_DONE3_Pos = 0x3
	// Bit mask of DONE3 field.
	ADC_STAT_DONE3_Msk = 0x8
	// Bit DONE3.
	ADC_STAT_DONE3 = 0x8
	// Position of DONE4 field.
	ADC_STAT_DONE4_Pos = 0x4
	// Bit mask of DONE4 field.
	ADC_STAT_DONE4_Msk = 0x10
	// Bit DONE4.
	ADC_STAT_DONE4 = 0x10
	// Position of DONE5 field.
	ADC_STAT_DONE5_Pos = 0x5
	// Bit mask of DONE5 field.
	ADC_STAT_DONE5_Msk = 0x20
	// Bit DONE5.
	ADC_STAT_DONE5 = 0x20
	// Position of DONE6 field.
	ADC_STAT_DONE6_Pos = 0x6
	// Bit mask of DONE6 field.
	ADC_STAT_DONE6_Msk = 0x40
	// Bit DONE6.
	ADC_STAT_DONE6 = 0x40
	// Position of DONE7 field.
	ADC_STAT_DONE7_Pos = 0x7
	// Bit mask of DONE7 field.
	ADC_STAT_DONE7_Msk = 0x80
	// Bit DONE7.
	ADC_STAT_DONE7 = 0x80
	// Position of OVERRUN0 field.
	ADC_STAT_OVERRUN0_Pos = 0x8
	// Bit mask of OVERRUN0 field.
	ADC_STAT_OVERRUN0_Msk = 0x100
	// Bit OVERRUN0.
	ADC_STAT_OVERRUN0 = 0x100
	// Position of OVERRUN1 field.
	ADC_STAT_OVERRUN1_Pos = 0x9
	// Bit mask of OVERRUN1 field.
	ADC_STAT_OVERRUN1_Msk = 0x200
	// Bit OVERRUN1.
	ADC_STAT_OVERRUN1 = 0x200
	// Position of OVERRUN2 field.
	ADC_STAT_OVERRUN2_Pos = 0xa
	// Bit mask of OVERRUN2 field.
	ADC_STAT_OVERRUN2_Msk = 0x400
	// Bit OVERRUN2.
	ADC_STAT_OVERRUN2 = 0x400
	// Position of OVERRUN3 field.
	ADC_STAT_OVERRUN3_Pos = 0xb
	// Bit mask of OVERRUN3 field.
	ADC_STAT_OVERRUN3_Msk = 0x800
	// Bit OVERRUN3.
	ADC_STAT_OVERRUN3 = 0x800
	// Position of OVERRUN4 field.
	ADC_STAT_OVERRUN4_Pos = 0xc
	// Bit mask of OVERRUN4 field.
	ADC_STAT_OVERRUN4_Msk = 0x1000
	// Bit OVERRUN4.
	ADC_STAT_OVERRUN4 = 0x1000
	// Position of OVERRUN5 field.
	ADC_STAT_OVERRUN5_Pos = 0xd
	// Bit mask of OVERRUN5 field.
	ADC_STAT_OVERRUN5_Msk = 0x2000
	// Bit OVERRUN5.
	ADC_STAT_OVERRUN5 = 0x2000
	// Position of OVERRUN6 field.
	ADC_STAT_OVERRUN6_Pos = 0xe
	// Bit mask of OVERRUN6 field.
	ADC_STAT_OVERRUN6_Msk = 0x4000
	// Bit OVERRUN6.
	ADC_STAT_OVERRUN6 = 0x4000
	// Position of OVERRUN7 field.
	ADC_STAT_OVERRUN7_Pos = 0xf
	// Bit mask of OVERRUN7 field.
	ADC_STAT_OVERRUN7_Msk = 0x8000
	// Bit OVERRUN7.
	ADC_STAT_OVERRUN7 = 0x8000
	// Position of ADINT field.
	ADC_STAT_ADINT_Pos = 0x10
	// Bit mask of ADINT field.
	ADC_STAT_ADINT_Msk = 0x10000
	// Bit ADINT.
	ADC_STAT_ADINT = 0x10000
	// Position of RESERVED field.
	ADC_STAT_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	ADC_STAT_RESERVED_Msk = 0xfffe0000

	// TRM: ADC trim register.
	// Position of RESERVED field.
	ADC_TRM_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	ADC_TRM_RESERVED_Msk = 0xf
	// Position of ADCOFFS field.
	ADC_TRM_ADCOFFS_Pos = 0x4
	// Bit mask of ADCOFFS field.
	ADC_TRM_ADCOFFS_Msk = 0xf0
	// Position of TRIM field.
	ADC_TRM_TRIM_Pos = 0x8
	// Bit mask of TRIM field.
	ADC_TRM_TRIM_Msk = 0xf00
	// Position of RESERVED field.
	ADC_TRM_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	ADC_TRM_RESERVED_Msk = 0xfffff000
)

// Constants for CANAFRAM: CAN acceptance filter RAM
const (
	// MASK: CAN AF ram access register
	// Position of MASK field.
	CANAFRAM_MASK_MASK_Pos = 0x0
	// Bit mask of MASK field.
	CANAFRAM_MASK_MASK_Msk = 0xffffffff
)

// Constants for CANAF: CAN controller
const (
	// AFMR: Acceptance Filter Register
	// Position of ACCOFF field.
	CANAF_AFMR_ACCOFF_Pos = 0x0
	// Bit mask of ACCOFF field.
	CANAF_AFMR_ACCOFF_Msk = 0x1
	// Bit ACCOFF.
	CANAF_AFMR_ACCOFF = 0x1
	// Position of ACCBP field.
	CANAF_AFMR_ACCBP_Pos = 0x1
	// Bit mask of ACCBP field.
	CANAF_AFMR_ACCBP_Msk = 0x2
	// Bit ACCBP.
	CANAF_AFMR_ACCBP = 0x2
	// Position of EFCAN field.
	CANAF_AFMR_EFCAN_Pos = 0x2
	// Bit mask of EFCAN field.
	CANAF_AFMR_EFCAN_Msk = 0x4
	// Bit EFCAN.
	CANAF_AFMR_EFCAN = 0x4
	// Software must read all messages for all enabled IDs on all enabled CAN buses, from the receiving CAN controllers.
	CANAF_AFMR_EFCAN_SOFTWARE_MUST_READ_A = 0x0
	// The Acceptance Filter itself will take care of receiving and storing messages for selected Standard ID values on selected CAN buses. See Section 21.16 FullCAN mode on page 576.
	CANAF_AFMR_EFCAN_THE_ACCEPTANCE_FILTE = 0x1
	// Position of RESERVED field.
	CANAF_AFMR_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	CANAF_AFMR_RESERVED_Msk = 0xfffffff8

	// SFF_SA: Standard Frame Individual Start Address Register
	// Position of RESERVED field.
	CANAF_SFF_SA_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	CANAF_SFF_SA_RESERVED_Msk = 0x3
	// Position of SFF_SA field.
	CANAF_SFF_SA_SFF_SA_Pos = 0x2
	// Bit mask of SFF_SA field.
	CANAF_SFF_SA_SFF_SA_Msk = 0x7fc
	// Position of RESERVED field.
	CANAF_SFF_SA_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	CANAF_SFF_SA_RESERVED_Msk = 0xfffff800

	// SFF_GRP_SA: Standard Frame Group Start Address Register
	// Position of RESERVED field.
	CANAF_SFF_GRP_SA_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	CANAF_SFF_GRP_SA_RESERVED_Msk = 0x3
	// Position of SFF_GRP_SA field.
	CANAF_SFF_GRP_SA_SFF_GRP_SA_Pos = 0x2
	// Bit mask of SFF_GRP_SA field.
	CANAF_SFF_GRP_SA_SFF_GRP_SA_Msk = 0xffc
	// Position of RESERVED field.
	CANAF_SFF_GRP_SA_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CANAF_SFF_GRP_SA_RESERVED_Msk = 0xfffff000

	// EFF_SA: Extended Frame Start Address Register
	// Position of RESERVED field.
	CANAF_EFF_SA_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	CANAF_EFF_SA_RESERVED_Msk = 0x3
	// Position of EFF_SA field.
	CANAF_EFF_SA_EFF_SA_Pos = 0x2
	// Bit mask of EFF_SA field.
	CANAF_EFF_SA_EFF_SA_Msk = 0x7fc
	// Position of RESERVED field.
	CANAF_EFF_SA_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	CANAF_EFF_SA_RESERVED_Msk = 0xfffff800

	// EFF_GRP_SA: Extended Frame Group Start Address Register
	// Position of RESERVED field.
	CANAF_EFF_GRP_SA_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	CANAF_EFF_GRP_SA_RESERVED_Msk = 0x3
	// Position of EFF_GRP_SA field.
	CANAF_EFF_GRP_SA_EFF_GRP_SA_Pos = 0x2
	// Bit mask of EFF_GRP_SA field.
	CANAF_EFF_GRP_SA_EFF_GRP_SA_Msk = 0xffc
	// Position of RESERVED field.
	CANAF_EFF_GRP_SA_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CANAF_EFF_GRP_SA_RESERVED_Msk = 0xfffff000

	// ENDOFTABLE: End of AF Tables register
	// Position of RESERVED field.
	CANAF_ENDOFTABLE_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	CANAF_ENDOFTABLE_RESERVED_Msk = 0x3
	// Position of ENDOFTABLE field.
	CANAF_ENDOFTABLE_ENDOFTABLE_Pos = 0x2
	// Bit mask of ENDOFTABLE field.
	CANAF_ENDOFTABLE_ENDOFTABLE_Msk = 0xffc
	// Position of RESERVED field.
	CANAF_ENDOFTABLE_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CANAF_ENDOFTABLE_RESERVED_Msk = 0xfffff000

	// LUTERRAD: LUT Error Address register
	// Position of RESERVED field.
	CANAF_LUTERRAD_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	CANAF_LUTERRAD_RESERVED_Msk = 0x3
	// Position of LUTERRAD field.
	CANAF_LUTERRAD_LUTERRAD_Pos = 0x2
	// Bit mask of LUTERRAD field.
	CANAF_LUTERRAD_LUTERRAD_Msk = 0x7fc
	// Position of RESERVED field.
	CANAF_LUTERRAD_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	CANAF_LUTERRAD_RESERVED_Msk = 0xfffff800

	// LUTERR: LUT Error Register
	// Position of LUTERR field.
	CANAF_LUTERR_LUTERR_Pos = 0x0
	// Bit mask of LUTERR field.
	CANAF_LUTERR_LUTERR_Msk = 0x1
	// Bit LUTERR.
	CANAF_LUTERR_LUTERR = 0x1
	// Position of RESERVED field.
	CANAF_LUTERR_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CANAF_LUTERR_RESERVED_Msk = 0xfffffffe

	// FCANIE: FullCAN interrupt enable register
	// Position of FCANIE field.
	CANAF_FCANIE_FCANIE_Pos = 0x0
	// Bit mask of FCANIE field.
	CANAF_FCANIE_FCANIE_Msk = 0x1
	// Bit FCANIE.
	CANAF_FCANIE_FCANIE = 0x1
	// Position of RESERVED field.
	CANAF_FCANIE_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	CANAF_FCANIE_RESERVED_Msk = 0xfffffffe

	// FCANIC0: FullCAN interrupt and capture register0
	// Position of INTPND field.
	CANAF_FCANIC0_INTPND_Pos = 0x0
	// Bit mask of INTPND field.
	CANAF_FCANIC0_INTPND_Msk = 0xffffffff

	// FCANIC1: FullCAN interrupt and capture register1
	// Position of IntPnd32 field.
	CANAF_FCANIC1_IntPnd32_Pos = 0x0
	// Bit mask of IntPnd32 field.
	CANAF_FCANIC1_IntPnd32_Msk = 0xffffffff
)

// Constants for CCAN: CAN controller
const (
	// TXSR: CAN Central Transmit Status Register
	// Position of TS1 field.
	CCAN_TXSR_TS1_Pos = 0x0
	// Bit mask of TS1 field.
	CCAN_TXSR_TS1_Msk = 0x1
	// Bit TS1.
	CCAN_TXSR_TS1 = 0x1
	// Position of TS2 field.
	CCAN_TXSR_TS2_Pos = 0x1
	// Bit mask of TS2 field.
	CCAN_TXSR_TS2_Msk = 0x2
	// Bit TS2.
	CCAN_TXSR_TS2 = 0x2
	// Position of RESERVED field.
	CCAN_TXSR_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	CCAN_TXSR_RESERVED_Msk = 0xfc
	// Position of TBS1 field.
	CCAN_TXSR_TBS1_Pos = 0x8
	// Bit mask of TBS1 field.
	CCAN_TXSR_TBS1_Msk = 0x100
	// Bit TBS1.
	CCAN_TXSR_TBS1 = 0x100
	// Position of TBS2 field.
	CCAN_TXSR_TBS2_Pos = 0x9
	// Bit mask of TBS2 field.
	CCAN_TXSR_TBS2_Msk = 0x200
	// Bit TBS2.
	CCAN_TXSR_TBS2 = 0x200
	// Position of RESERVED field.
	CCAN_TXSR_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	CCAN_TXSR_RESERVED_Msk = 0xfc00
	// Position of TCS1 field.
	CCAN_TXSR_TCS1_Pos = 0x10
	// Bit mask of TCS1 field.
	CCAN_TXSR_TCS1_Msk = 0x10000
	// Bit TCS1.
	CCAN_TXSR_TCS1 = 0x10000
	// Position of TCS2 field.
	CCAN_TXSR_TCS2_Pos = 0x11
	// Bit mask of TCS2 field.
	CCAN_TXSR_TCS2_Msk = 0x20000
	// Bit TCS2.
	CCAN_TXSR_TCS2 = 0x20000
	// Position of RESERVED field.
	CCAN_TXSR_RESERVED_Pos = 0x12
	// Bit mask of RESERVED field.
	CCAN_TXSR_RESERVED_Msk = 0xfffc0000

	// RXSR: CAN Central Receive Status Register
	// Position of RS1 field.
	CCAN_RXSR_RS1_Pos = 0x0
	// Bit mask of RS1 field.
	CCAN_RXSR_RS1_Msk = 0x1
	// Bit RS1.
	CCAN_RXSR_RS1 = 0x1
	// Position of RS2 field.
	CCAN_RXSR_RS2_Pos = 0x1
	// Bit mask of RS2 field.
	CCAN_RXSR_RS2_Msk = 0x2
	// Bit RS2.
	CCAN_RXSR_RS2 = 0x2
	// Position of RESERVED field.
	CCAN_RXSR_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	CCAN_RXSR_RESERVED_Msk = 0xfc
	// Position of RB1 field.
	CCAN_RXSR_RB1_Pos = 0x8
	// Bit mask of RB1 field.
	CCAN_RXSR_RB1_Msk = 0x100
	// Bit RB1.
	CCAN_RXSR_RB1 = 0x100
	// Position of RB2 field.
	CCAN_RXSR_RB2_Pos = 0x9
	// Bit mask of RB2 field.
	CCAN_RXSR_RB2_Msk = 0x200
	// Bit RB2.
	CCAN_RXSR_RB2 = 0x200
	// Position of RESERVED field.
	CCAN_RXSR_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	CCAN_RXSR_RESERVED_Msk = 0xfc00
	// Position of DOS1 field.
	CCAN_RXSR_DOS1_Pos = 0x10
	// Bit mask of DOS1 field.
	CCAN_RXSR_DOS1_Msk = 0x10000
	// Bit DOS1.
	CCAN_RXSR_DOS1 = 0x10000
	// Position of DOS2 field.
	CCAN_RXSR_DOS2_Pos = 0x11
	// Bit mask of DOS2 field.
	CCAN_RXSR_DOS2_Msk = 0x20000
	// Bit DOS2.
	CCAN_RXSR_DOS2 = 0x20000
	// Position of RESERVED field.
	CCAN_RXSR_RESERVED_Pos = 0x12
	// Bit mask of RESERVED field.
	CCAN_RXSR_RESERVED_Msk = 0xfffc0000

	// MSR: CAN Central Miscellaneous Register
	// Position of E1 field.
	CCAN_MSR_E1_Pos = 0x0
	// Bit mask of E1 field.
	CCAN_MSR_E1_Msk = 0x1
	// Bit E1.
	CCAN_MSR_E1 = 0x1
	// Position of E2 field.
	CCAN_MSR_E2_Pos = 0x1
	// Bit mask of E2 field.
	CCAN_MSR_E2_Msk = 0x2
	// Bit E2.
	CCAN_MSR_E2 = 0x2
	// Position of RESERVED field.
	CCAN_MSR_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	CCAN_MSR_RESERVED_Msk = 0xfc
	// Position of BS1 field.
	CCAN_MSR_BS1_Pos = 0x8
	// Bit mask of BS1 field.
	CCAN_MSR_BS1_Msk = 0x100
	// Bit BS1.
	CCAN_MSR_BS1 = 0x100
	// Position of BS2 field.
	CCAN_MSR_BS2_Pos = 0x9
	// Bit mask of BS2 field.
	CCAN_MSR_BS2_Msk = 0x200
	// Bit BS2.
	CCAN_MSR_BS2 = 0x200
	// Position of RESERVED field.
	CCAN_MSR_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	CCAN_MSR_RESERVED_Msk = 0xfffffc00
)

// Constants for CAN1: CAN controller
const (
	// MOD: Controls the operating mode of the CAN Controller.
	// Position of RM field.
	CAN_MOD_RM_Pos = 0x0
	// Bit mask of RM field.
	CAN_MOD_RM_Msk = 0x1
	// Bit RM.
	CAN_MOD_RM = 0x1
	// Normal.The CAN Controller is in the Operating Mode, and certain registers can not be written.
	CAN_MOD_RM_NORMAL_THE_CAN_CONTR = 0x0
	// Reset. CAN operation is disabled, writable registers can be written and the current transmission/reception of a message is aborted.
	CAN_MOD_RM_RESET_CAN_OPERATION = 0x1
	// Position of LOM field.
	CAN_MOD_LOM_Pos = 0x1
	// Bit mask of LOM field.
	CAN_MOD_LOM_Msk = 0x2
	// Bit LOM.
	CAN_MOD_LOM = 0x2
	// Normal. The CAN controller acknowledges a successfully received message on the CAN bus. The error counters are stopped at the current value.
	CAN_MOD_LOM_NORMAL_THE_CAN_CONT = 0x0
	// Listen only. The controller gives no acknowledgment, even if a message is successfully received. Messages cannot be sent, and the controller operates in error passive mode. This mode is intended for software bit rate detection and hot plugging.
	CAN_MOD_LOM_LISTEN_ONLY_THE_CON = 0x1
	// Position of STM field.
	CAN_MOD_STM_Pos = 0x2
	// Bit mask of STM field.
	CAN_MOD_STM_Msk = 0x4
	// Bit STM.
	CAN_MOD_STM = 0x4
	// Normal. A transmitted message must be acknowledged to be considered successful.
	CAN_MOD_STM_NORMAL_A_TRANSMITTE = 0x0
	// Self test. The controller will consider a Tx message successful even if there is no acknowledgment received. In this mode a full node test is possible without any other active node on the bus using the SRR bit in CANxCMR.
	CAN_MOD_STM_SELF_TEST_THE_CONTR = 0x1
	// Position of TPM field.
	CAN_MOD_TPM_Pos = 0x3
	// Bit mask of TPM field.
	CAN_MOD_TPM_Msk = 0x8
	// Bit TPM.
	CAN_MOD_TPM = 0x8
	// CAN ID. The transmit priority for 3 Transmit Buffers depends on the CAN Identifier.
	CAN_MOD_TPM_CAN_ID_THE_TRANSMIT = 0x0
	// Local priority. The transmit priority for 3 Transmit Buffers depends on the contents of the Tx Priority register within the Transmit Buffer.
	CAN_MOD_TPM_LOCAL_PRIORITY_THE_ = 0x1
	// Position of SM field.
	CAN_MOD_SM_Pos = 0x4
	// Bit mask of SM field.
	CAN_MOD_SM_Msk = 0x10
	// Bit SM.
	CAN_MOD_SM = 0x10
	// Wake-up. Normal operation.
	CAN_MOD_SM_WAKE_UP_NORMAL_OPER = 0x0
	// Sleep. The CAN controller enters Sleep Mode if no CAN interrupt is pending and there is no bus activity. See the Sleep Mode description Section 21.8.2 on page 565.
	CAN_MOD_SM_SLEEP_THE_CAN_CONTR = 0x1
	// Position of RPM field.
	CAN_MOD_RPM_Pos = 0x5
	// Bit mask of RPM field.
	CAN_MOD_RPM_Msk = 0x20
	// Bit RPM.
	CAN_MOD_RPM = 0x20
	// Low active. RD input is active Low (dominant bit = 0).
	CAN_MOD_RPM_LOW_ACTIVE_RD_INPUT = 0x0
	// High active. RD input is active High (dominant bit = 1) -- reverse polarity.
	CAN_MOD_RPM_HIGH_ACTIVE_RD_INPU = 0x1
	// Position of RESERVED field.
	CAN_MOD_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	CAN_MOD_RESERVED_Msk = 0x40
	// Bit RESERVED.
	CAN_MOD_RESERVED = 0x40
	// Position of TM field.
	CAN_MOD_TM_Pos = 0x7
	// Bit mask of TM field.
	CAN_MOD_TM_Msk = 0x80
	// Bit TM.
	CAN_MOD_TM = 0x80
	// Disabled. Normal operation.
	CAN_MOD_TM_DISABLED_NORMAL_OPE = 0x0
	// Enabled. The TD pin will reflect the bit, detected on RD pin, with the next positive edge of the system clock.
	CAN_MOD_TM_ENABLED_THE_TD_PIN_ = 0x1
	// Position of RESERVED field.
	CAN_MOD_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	CAN_MOD_RESERVED_Msk = 0xffffff00

	// CMR: Command bits that affect the state of the CAN Controller
	// Position of TR field.
	CAN_CMR_TR_Pos = 0x0
	// Bit mask of TR field.
	CAN_CMR_TR_Msk = 0x1
	// Bit TR.
	CAN_CMR_TR = 0x1
	// Absent.No transmission request.
	CAN_CMR_TR_ABSENT_NO_TRANSMISSI = 0x0
	// Present. The message, previously written to the CANxTFI, CANxTID, and optionally the CANxTDA and CANxTDB registers, is queued for transmission from the selected Transmit Buffer. If at two or all three of STB1, STB2 and STB3 bits are selected when TR=1 is written, Transmit Buffer will be selected based on the chosen priority scheme (for details see Section 21.5.3 Transmit Buffers (TXB))
	CAN_CMR_TR_PRESENT_THE_MESSAGE = 0x1
	// Position of AT field.
	CAN_CMR_AT_Pos = 0x1
	// Bit mask of AT field.
	CAN_CMR_AT_Msk = 0x2
	// Bit AT.
	CAN_CMR_AT = 0x2
	// No action. Do not abort the transmission.
	CAN_CMR_AT_NO_ACTION_DO_NOT_AB = 0x0
	// Present. if not already in progress, a pending Transmission Request for the selected Transmit Buffer is cancelled.
	CAN_CMR_AT_PRESENT_IF_NOT_ALRE = 0x1
	// Position of RRB field.
	CAN_CMR_RRB_Pos = 0x2
	// Bit mask of RRB field.
	CAN_CMR_RRB_Msk = 0x4
	// Bit RRB.
	CAN_CMR_RRB = 0x4
	// No action. Do not release the receive buffer.
	CAN_CMR_RRB_NO_ACTION_DO_NOT_RE = 0x0
	// Released. The information in the Receive Buffer (consisting of CANxRFS, CANxRID, and if applicable the CANxRDA and CANxRDB registers) is released, and becomes eligible for replacement by the next received frame. If the next received frame is not available, writing this command clears the RBS bit in the Status Register(s).
	CAN_CMR_RRB_RELEASED_THE_INFORM = 0x1
	// Position of CDO field.
	CAN_CMR_CDO_Pos = 0x3
	// Bit mask of CDO field.
	CAN_CMR_CDO_Msk = 0x8
	// Bit CDO.
	CAN_CMR_CDO = 0x8
	// No action. Do not clear the data overrun bit.
	CAN_CMR_CDO_NO_ACTION_DO_NOT_CL = 0x0
	// Clear. The Data Overrun bit in Status Register(s) is cleared.
	CAN_CMR_CDO_CLEAR_THE_DATA_OVER = 0x1
	// Position of SRR field.
	CAN_CMR_SRR_Pos = 0x4
	// Bit mask of SRR field.
	CAN_CMR_SRR_Msk = 0x10
	// Bit SRR.
	CAN_CMR_SRR = 0x10
	// Absent. No self reception request.
	CAN_CMR_SRR_ABSENT_NO_SELF_RECE = 0x0
	// Present. The message, previously written to the CANxTFS, CANxTID, and optionally the CANxTDA and CANxTDB registers, is queued for transmission from the selected Transmit Buffer and received simultaneously. This differs from the TR bit above in that the receiver is not disabled during the transmission, so that it receives the message if its Identifier is recognized by the Acceptance Filter.
	CAN_CMR_SRR_PRESENT_THE_MESSAGE = 0x1
	// Position of STB1 field.
	CAN_CMR_STB1_Pos = 0x5
	// Bit mask of STB1 field.
	CAN_CMR_STB1_Msk = 0x20
	// Bit STB1.
	CAN_CMR_STB1 = 0x20
	// Not selected. Tx Buffer 1 is not selected for transmission.
	CAN_CMR_STB1_NOT_SELECTED_TX_BUF = 0x0
	// Selected. Tx Buffer 1 is selected for transmission.
	CAN_CMR_STB1_SELECTED_TX_BUFFER_ = 0x1
	// Position of STB2 field.
	CAN_CMR_STB2_Pos = 0x6
	// Bit mask of STB2 field.
	CAN_CMR_STB2_Msk = 0x40
	// Bit STB2.
	CAN_CMR_STB2 = 0x40
	// Not selected. Tx Buffer 2 is not selected for transmission.
	CAN_CMR_STB2_NOT_SELECTED_TX_BUF = 0x0
	// Selected. Tx Buffer 2 is selected for transmission.
	CAN_CMR_STB2_SELECTED_TX_BUFFER_ = 0x1
	// Position of STB3 field.
	CAN_CMR_STB3_Pos = 0x7
	// Bit mask of STB3 field.
	CAN_CMR_STB3_Msk = 0x80
	// Bit STB3.
	CAN_CMR_STB3 = 0x80
	// Not selected. Tx Buffer 3 is not selected for transmission.
	CAN_CMR_STB3_NOT_SELECTED_TX_BUF = 0x0
	// Selected. Tx Buffer 3 is selected for transmission.
	CAN_CMR_STB3_SELECTED_TX_BUFFER_ = 0x1
	// Position of RESERVED field.
	CAN_CMR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	CAN_CMR_RESERVED_Msk = 0xffffff00

	// GSR: Global Controller Status and Error Counters. The error counters can only be written when RM in CANMOD is 1.
	// Position of RBS field.
	CAN_GSR_RBS_Pos = 0x0
	// Bit mask of RBS field.
	CAN_GSR_RBS_Msk = 0x1
	// Bit RBS.
	CAN_GSR_RBS = 0x1
	// Empty. No message is available.
	CAN_GSR_RBS_EMPTY_NO_MESSAGE_IS = 0x0
	// Full. At least one complete message is received by the Double Receive Buffer and available in the CANxRFS, CANxRID, and if applicable the CANxRDA and CANxRDB registers. This bit is cleared by the Release Receive Buffer command in CANxCMR, if no subsequent received message is available.
	CAN_GSR_RBS_FULL_AT_LEAST_ONE_C = 0x1
	// Position of DOS field.
	CAN_GSR_DOS_Pos = 0x1
	// Bit mask of DOS field.
	CAN_GSR_DOS_Msk = 0x2
	// Bit DOS.
	CAN_GSR_DOS = 0x2
	// Absent. No data overrun has occurred since the last Clear Data Overrun command was given/written to CANxCMR (or since Reset).
	CAN_GSR_DOS_ABSENT_NO_DATA_OVER = 0x0
	// Overrun. A message was lost because the preceding message to this CAN controller was not read and released quickly enough (there was not enough space for a new message in the Double Receive Buffer).
	CAN_GSR_DOS_OVERRUN_A_MESSAGE_W = 0x1
	// Position of TBS field.
	CAN_GSR_TBS_Pos = 0x2
	// Bit mask of TBS field.
	CAN_GSR_TBS_Msk = 0x4
	// Bit TBS.
	CAN_GSR_TBS = 0x4
	// Locked. At least one of the Transmit Buffers is not available for the CPU, i.e. at least one previously queued message for this CAN controller has not yet been sent, and therefore software should not write to the CANxTFI, CANxTID, CANxTDA, nor CANxTDB registers of that (those) Tx buffer(s).
	CAN_GSR_TBS_LOCKED_AT_LEAST_ONE = 0x0
	// Released. All three Transmit Buffers are available for the CPU. No transmit message is pending for this CAN controller (in any of the 3 Tx buffers), and software may write to any of the CANxTFI, CANxTID, CANxTDA, and CANxTDB registers.
	CAN_GSR_TBS_RELEASED_ALL_THREE_ = 0x1
	// Position of TCS field.
	CAN_GSR_TCS_Pos = 0x3
	// Bit mask of TCS field.
	CAN_GSR_TCS_Msk = 0x8
	// Bit TCS.
	CAN_GSR_TCS = 0x8
	// Incomplete. At least one requested transmission has not been successfully completed yet.
	CAN_GSR_TCS_INCOMPLETE_AT_LEAST = 0x0
	// Complete. All requested transmission(s) has (have) been successfully completed.
	CAN_GSR_TCS_COMPLETE_ALL_REQUES = 0x1
	// Position of RS field.
	CAN_GSR_RS_Pos = 0x4
	// Bit mask of RS field.
	CAN_GSR_RS_Msk = 0x10
	// Bit RS.
	CAN_GSR_RS = 0x10
	// Idle. The CAN controller is idle.
	CAN_GSR_RS_IDLE_THE_CAN_CONTRO = 0x0
	// Receive. The CAN controller is receiving a message.
	CAN_GSR_RS_RECEIVE_THE_CAN_CON = 0x1
	// Position of TS field.
	CAN_GSR_TS_Pos = 0x5
	// Bit mask of TS field.
	CAN_GSR_TS_Msk = 0x20
	// Bit TS.
	CAN_GSR_TS = 0x20
	// Idle. The CAN controller is idle.
	CAN_GSR_TS_IDLE_THE_CAN_CONTRO = 0x0
	// Transmit. The CAN controller is sending a message.
	CAN_GSR_TS_TRANSMIT_THE_CAN_CO = 0x1
	// Position of ES field.
	CAN_GSR_ES_Pos = 0x6
	// Bit mask of ES field.
	CAN_GSR_ES_Msk = 0x40
	// Bit ES.
	CAN_GSR_ES = 0x40
	// OK. Both error counters are below the Error Warning Limit.
	CAN_GSR_ES_OK_BOTH_ERROR_COUNT = 0x0
	// Error. One or both of the Transmit and Receive Error Counters has reached the limit set in the Error Warning Limit register.
	CAN_GSR_ES_ERROR_ONE_OR_BOTH_O = 0x1
	// Position of BS field.
	CAN_GSR_BS_Pos = 0x7
	// Bit mask of BS field.
	CAN_GSR_BS_Msk = 0x80
	// Bit BS.
	CAN_GSR_BS = 0x80
	// Bus-on. The CAN Controller is involved in bus activities
	CAN_GSR_BS_BUS_ON_THE_CAN_CONT = 0x0
	// Bus-off. The CAN controller is currently not involved/prohibited from bus activity because the Transmit Error Counter reached its limiting value of 255.
	CAN_GSR_BS_BUS_OFF_THE_CAN_CON = 0x1
	// Position of RESERVED field.
	CAN_GSR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	CAN_GSR_RESERVED_Msk = 0xff00
	// Position of RXERR field.
	CAN_GSR_RXERR_Pos = 0x10
	// Bit mask of RXERR field.
	CAN_GSR_RXERR_Msk = 0xff0000
	// Position of TXERR field.
	CAN_GSR_TXERR_Pos = 0x18
	// Bit mask of TXERR field.
	CAN_GSR_TXERR_Msk = 0xff000000

	// ICR: Interrupt status, Arbitration Lost Capture, Error Code Capture
	// Position of RI field.
	CAN_ICR_RI_Pos = 0x0
	// Bit mask of RI field.
	CAN_ICR_RI_Msk = 0x1
	// Bit RI.
	CAN_ICR_RI = 0x1
	// Reset
	CAN_ICR_RI_RESET = 0x0
	// Set
	CAN_ICR_RI_SET = 0x1
	// Position of TI1 field.
	CAN_ICR_TI1_Pos = 0x1
	// Bit mask of TI1 field.
	CAN_ICR_TI1_Msk = 0x2
	// Bit TI1.
	CAN_ICR_TI1 = 0x2
	// Reset
	CAN_ICR_TI1_RESET = 0x0
	// Set
	CAN_ICR_TI1_SET = 0x1
	// Position of EI field.
	CAN_ICR_EI_Pos = 0x2
	// Bit mask of EI field.
	CAN_ICR_EI_Msk = 0x4
	// Bit EI.
	CAN_ICR_EI = 0x4
	// Reset
	CAN_ICR_EI_RESET = 0x0
	// Set
	CAN_ICR_EI_SET = 0x1
	// Position of DOI field.
	CAN_ICR_DOI_Pos = 0x3
	// Bit mask of DOI field.
	CAN_ICR_DOI_Msk = 0x8
	// Bit DOI.
	CAN_ICR_DOI = 0x8
	// Reset
	CAN_ICR_DOI_RESET = 0x0
	// Set
	CAN_ICR_DOI_SET = 0x1
	// Position of WUI field.
	CAN_ICR_WUI_Pos = 0x4
	// Bit mask of WUI field.
	CAN_ICR_WUI_Msk = 0x10
	// Bit WUI.
	CAN_ICR_WUI = 0x10
	// Reset
	CAN_ICR_WUI_RESET = 0x0
	// Set
	CAN_ICR_WUI_SET = 0x1
	// Position of EPI field.
	CAN_ICR_EPI_Pos = 0x5
	// Bit mask of EPI field.
	CAN_ICR_EPI_Msk = 0x20
	// Bit EPI.
	CAN_ICR_EPI = 0x20
	// Reset
	CAN_ICR_EPI_RESET = 0x0
	// Set
	CAN_ICR_EPI_SET = 0x1
	// Position of ALI field.
	CAN_ICR_ALI_Pos = 0x6
	// Bit mask of ALI field.
	CAN_ICR_ALI_Msk = 0x40
	// Bit ALI.
	CAN_ICR_ALI = 0x40
	// Reset
	CAN_ICR_ALI_RESET = 0x0
	// Set
	CAN_ICR_ALI_SET = 0x1
	// Position of BEI field.
	CAN_ICR_BEI_Pos = 0x7
	// Bit mask of BEI field.
	CAN_ICR_BEI_Msk = 0x80
	// Bit BEI.
	CAN_ICR_BEI = 0x80
	// Reset
	CAN_ICR_BEI_RESET = 0x0
	// Set
	CAN_ICR_BEI_SET = 0x1
	// Position of IDI field.
	CAN_ICR_IDI_Pos = 0x8
	// Bit mask of IDI field.
	CAN_ICR_IDI_Msk = 0x100
	// Bit IDI.
	CAN_ICR_IDI = 0x100
	// Reset
	CAN_ICR_IDI_RESET = 0x0
	// Set
	CAN_ICR_IDI_SET = 0x1
	// Position of TI2 field.
	CAN_ICR_TI2_Pos = 0x9
	// Bit mask of TI2 field.
	CAN_ICR_TI2_Msk = 0x200
	// Bit TI2.
	CAN_ICR_TI2 = 0x200
	// Reset
	CAN_ICR_TI2_RESET = 0x0
	// Set
	CAN_ICR_TI2_SET = 0x1
	// Position of TI3 field.
	CAN_ICR_TI3_Pos = 0xa
	// Bit mask of TI3 field.
	CAN_ICR_TI3_Msk = 0x400
	// Bit TI3.
	CAN_ICR_TI3 = 0x400
	// Reset
	CAN_ICR_TI3_RESET = 0x0
	// Set
	CAN_ICR_TI3_SET = 0x1
	// Position of RESERVED field.
	CAN_ICR_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	CAN_ICR_RESERVED_Msk = 0xf800
	// Position of ERRBIT4_0 field.
	CAN_ICR_ERRBIT4_0_Pos = 0x10
	// Bit mask of ERRBIT4_0 field.
	CAN_ICR_ERRBIT4_0_Msk = 0x1f0000
	// Position of ERRDIR field.
	CAN_ICR_ERRDIR_Pos = 0x15
	// Bit mask of ERRDIR field.
	CAN_ICR_ERRDIR_Msk = 0x200000
	// Bit ERRDIR.
	CAN_ICR_ERRDIR = 0x200000
	// Position of ERRC1_0 field.
	CAN_ICR_ERRC1_0_Pos = 0x16
	// Bit mask of ERRC1_0 field.
	CAN_ICR_ERRC1_0_Msk = 0xc00000
	// Bit error
	CAN_ICR_ERRC1_0_BIT_ERROR = 0x0
	// Form error
	CAN_ICR_ERRC1_0_FORM_ERROR = 0x1
	// Stuff error
	CAN_ICR_ERRC1_0_STUFF_ERROR = 0x2
	// Other error
	CAN_ICR_ERRC1_0_OTHER_ERROR = 0x3
	// Position of ALCBIT field.
	CAN_ICR_ALCBIT_Pos = 0x18
	// Bit mask of ALCBIT field.
	CAN_ICR_ALCBIT_Msk = 0xff000000

	// IER: Interrupt Enable
	// Position of RIE field.
	CAN_IER_RIE_Pos = 0x0
	// Bit mask of RIE field.
	CAN_IER_RIE_Msk = 0x1
	// Bit RIE.
	CAN_IER_RIE = 0x1
	// Position of TIE1 field.
	CAN_IER_TIE1_Pos = 0x1
	// Bit mask of TIE1 field.
	CAN_IER_TIE1_Msk = 0x2
	// Bit TIE1.
	CAN_IER_TIE1 = 0x2
	// Position of EIE field.
	CAN_IER_EIE_Pos = 0x2
	// Bit mask of EIE field.
	CAN_IER_EIE_Msk = 0x4
	// Bit EIE.
	CAN_IER_EIE = 0x4
	// Position of DOIE field.
	CAN_IER_DOIE_Pos = 0x3
	// Bit mask of DOIE field.
	CAN_IER_DOIE_Msk = 0x8
	// Bit DOIE.
	CAN_IER_DOIE = 0x8
	// Position of WUIE field.
	CAN_IER_WUIE_Pos = 0x4
	// Bit mask of WUIE field.
	CAN_IER_WUIE_Msk = 0x10
	// Bit WUIE.
	CAN_IER_WUIE = 0x10
	// Position of EPIE field.
	CAN_IER_EPIE_Pos = 0x5
	// Bit mask of EPIE field.
	CAN_IER_EPIE_Msk = 0x20
	// Bit EPIE.
	CAN_IER_EPIE = 0x20
	// Position of ALIE field.
	CAN_IER_ALIE_Pos = 0x6
	// Bit mask of ALIE field.
	CAN_IER_ALIE_Msk = 0x40
	// Bit ALIE.
	CAN_IER_ALIE = 0x40
	// Position of BEIE field.
	CAN_IER_BEIE_Pos = 0x7
	// Bit mask of BEIE field.
	CAN_IER_BEIE_Msk = 0x80
	// Bit BEIE.
	CAN_IER_BEIE = 0x80
	// Position of IDIE field.
	CAN_IER_IDIE_Pos = 0x8
	// Bit mask of IDIE field.
	CAN_IER_IDIE_Msk = 0x100
	// Bit IDIE.
	CAN_IER_IDIE = 0x100
	// Position of TIE2 field.
	CAN_IER_TIE2_Pos = 0x9
	// Bit mask of TIE2 field.
	CAN_IER_TIE2_Msk = 0x200
	// Bit TIE2.
	CAN_IER_TIE2 = 0x200
	// Position of TIE3 field.
	CAN_IER_TIE3_Pos = 0xa
	// Bit mask of TIE3 field.
	CAN_IER_TIE3_Msk = 0x400
	// Bit TIE3.
	CAN_IER_TIE3 = 0x400
	// Position of RESERVED field.
	CAN_IER_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	CAN_IER_RESERVED_Msk = 0xfffff800

	// BTR: Bus Timing. Can only be written when RM in CANMOD is 1.
	// Position of BRP field.
	CAN_BTR_BRP_Pos = 0x0
	// Bit mask of BRP field.
	CAN_BTR_BRP_Msk = 0x3ff
	// Position of RESERVED field.
	CAN_BTR_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	CAN_BTR_RESERVED_Msk = 0x3c00
	// Position of SJW field.
	CAN_BTR_SJW_Pos = 0xe
	// Bit mask of SJW field.
	CAN_BTR_SJW_Msk = 0xc000
	// Position of TESG1 field.
	CAN_BTR_TESG1_Pos = 0x10
	// Bit mask of TESG1 field.
	CAN_BTR_TESG1_Msk = 0xf0000
	// Position of TESG2 field.
	CAN_BTR_TESG2_Pos = 0x14
	// Bit mask of TESG2 field.
	CAN_BTR_TESG2_Msk = 0x700000
	// Position of SAM field.
	CAN_BTR_SAM_Pos = 0x17
	// Bit mask of SAM field.
	CAN_BTR_SAM_Msk = 0x800000
	// Bit SAM.
	CAN_BTR_SAM = 0x800000
	// The bus is sampled once (recommended for high speed buses)
	CAN_BTR_SAM_THE_BUS_IS_SAMPLED_O = 0x0
	// The bus is sampled 3 times (recommended for low to medium speed buses to filter spikes on the bus-line)
	CAN_BTR_SAM_THE_BUS_IS_SAMPLED_3 = 0x1
	// Position of RESERVED field.
	CAN_BTR_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	CAN_BTR_RESERVED_Msk = 0xff000000

	// EWL: Error Warning Limit. Can only be written when RM in CANMOD is 1.
	// Position of EWL field.
	CAN_EWL_EWL_Pos = 0x0
	// Bit mask of EWL field.
	CAN_EWL_EWL_Msk = 0xff
	// Position of RESERVED field.
	CAN_EWL_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	CAN_EWL_RESERVED_Msk = 0xffffff00

	// SR: Status Register
	// Position of RBS_1 field.
	CAN_SR_RBS_1_Pos = 0x0
	// Bit mask of RBS_1 field.
	CAN_SR_RBS_1_Msk = 0x1
	// Bit RBS_1.
	CAN_SR_RBS_1 = 0x1
	// Position of DOS_1 field.
	CAN_SR_DOS_1_Pos = 0x1
	// Bit mask of DOS_1 field.
	CAN_SR_DOS_1_Msk = 0x2
	// Bit DOS_1.
	CAN_SR_DOS_1 = 0x2
	// Position of TBS1_1 field.
	CAN_SR_TBS1_1_Pos = 0x2
	// Bit mask of TBS1_1 field.
	CAN_SR_TBS1_1_Msk = 0x4
	// Bit TBS1_1.
	CAN_SR_TBS1_1 = 0x4
	// Locked. Software cannot access the Tx Buffer 1 nor write to the corresponding CANxTFI, CANxTID, CANxTDA, and CANxTDB registers because a message is either waiting for transmission or is in transmitting process.
	CAN_SR_TBS1_1_LOCKED_SOFTWARE_CAN = 0x0
	// Released. Software may write a message into the Transmit Buffer 1 and its CANxTFI, CANxTID, CANxTDA, and CANxTDB registers.
	CAN_SR_TBS1_1_RELEASED_SOFTWARE_M = 0x1
	// Position of TCS1_1 field.
	CAN_SR_TCS1_1_Pos = 0x3
	// Bit mask of TCS1_1 field.
	CAN_SR_TCS1_1_Msk = 0x8
	// Bit TCS1_1.
	CAN_SR_TCS1_1 = 0x8
	// Incomplete. The previously requested transmission for Tx Buffer 1 is not complete.
	CAN_SR_TCS1_1_INCOMPLETE_THE_PREV = 0x0
	// Complete. The previously requested transmission for Tx Buffer 1 has been successfully completed.
	CAN_SR_TCS1_1_COMPLETE_THE_PREVIO = 0x1
	// Position of RS_1 field.
	CAN_SR_RS_1_Pos = 0x4
	// Bit mask of RS_1 field.
	CAN_SR_RS_1_Msk = 0x10
	// Bit RS_1.
	CAN_SR_RS_1 = 0x10
	// Position of TS1_1 field.
	CAN_SR_TS1_1_Pos = 0x5
	// Bit mask of TS1_1 field.
	CAN_SR_TS1_1_Msk = 0x20
	// Bit TS1_1.
	CAN_SR_TS1_1 = 0x20
	// Idle. There is no transmission from Tx Buffer 1.
	CAN_SR_TS1_1_IDLE_THERE_IS_NO_TR = 0x0
	// Transmit. The CAN Controller is transmitting a message from Tx Buffer 1.
	CAN_SR_TS1_1_TRANSMIT_THE_CAN_CO = 0x1
	// Position of ES_1 field.
	CAN_SR_ES_1_Pos = 0x6
	// Bit mask of ES_1 field.
	CAN_SR_ES_1_Msk = 0x40
	// Bit ES_1.
	CAN_SR_ES_1 = 0x40
	// Position of BS_1 field.
	CAN_SR_BS_1_Pos = 0x7
	// Bit mask of BS_1 field.
	CAN_SR_BS_1_Msk = 0x80
	// Bit BS_1.
	CAN_SR_BS_1 = 0x80
	// Position of RBS_2 field.
	CAN_SR_RBS_2_Pos = 0x8
	// Bit mask of RBS_2 field.
	CAN_SR_RBS_2_Msk = 0x100
	// Bit RBS_2.
	CAN_SR_RBS_2 = 0x100
	// Position of DOS_2 field.
	CAN_SR_DOS_2_Pos = 0x9
	// Bit mask of DOS_2 field.
	CAN_SR_DOS_2_Msk = 0x200
	// Bit DOS_2.
	CAN_SR_DOS_2 = 0x200
	// Position of TBS2_2 field.
	CAN_SR_TBS2_2_Pos = 0xa
	// Bit mask of TBS2_2 field.
	CAN_SR_TBS2_2_Msk = 0x400
	// Bit TBS2_2.
	CAN_SR_TBS2_2 = 0x400
	// Locked. Software cannot access the Tx Buffer 2 nor write to the corresponding CANxTFI, CANxTID, CANxTDA, and CANxTDB registers because a message is either waiting for transmission or is in transmitting process.
	CAN_SR_TBS2_2_LOCKED_SOFTWARE_CAN = 0x0
	// Released. Software may write a message into the Transmit Buffer 2 and its CANxTFI, CANxTID, CANxTDA, and CANxTDB registers.
	CAN_SR_TBS2_2_RELEASED_SOFTWARE_M = 0x1
	// Position of TCS2_2 field.
	CAN_SR_TCS2_2_Pos = 0xb
	// Bit mask of TCS2_2 field.
	CAN_SR_TCS2_2_Msk = 0x800
	// Bit TCS2_2.
	CAN_SR_TCS2_2 = 0x800
	// Incomplete. The previously requested transmission for Tx Buffer 2 is not complete.
	CAN_SR_TCS2_2_INCOMPLETE_THE_PREV = 0x0
	// Complete. The previously requested transmission for Tx Buffer 2 has been successfully completed.
	CAN_SR_TCS2_2_COMPLETE_THE_PREVIO = 0x1
	// Position of RS_2 field.
	CAN_SR_RS_2_Pos = 0xc
	// Bit mask of RS_2 field.
	CAN_SR_RS_2_Msk = 0x1000
	// Bit RS_2.
	CAN_SR_RS_2 = 0x1000
	// Position of TS2_2 field.
	CAN_SR_TS2_2_Pos = 0xd
	// Bit mask of TS2_2 field.
	CAN_SR_TS2_2_Msk = 0x2000
	// Bit TS2_2.
	CAN_SR_TS2_2 = 0x2000
	// Idle. There is no transmission from Tx Buffer 2.
	CAN_SR_TS2_2_IDLE_THERE_IS_NO_TR = 0x0
	// Transmit. The CAN Controller is transmitting a message from Tx Buffer 2.
	CAN_SR_TS2_2_TRANSMIT_THE_CAN_CO = 0x1
	// Position of ES_2 field.
	CAN_SR_ES_2_Pos = 0xe
	// Bit mask of ES_2 field.
	CAN_SR_ES_2_Msk = 0x4000
	// Bit ES_2.
	CAN_SR_ES_2 = 0x4000
	// Position of BS_2 field.
	CAN_SR_BS_2_Pos = 0xf
	// Bit mask of BS_2 field.
	CAN_SR_BS_2_Msk = 0x8000
	// Bit BS_2.
	CAN_SR_BS_2 = 0x8000
	// Position of RBS_3 field.
	CAN_SR_RBS_3_Pos = 0x10
	// Bit mask of RBS_3 field.
	CAN_SR_RBS_3_Msk = 0x10000
	// Bit RBS_3.
	CAN_SR_RBS_3 = 0x10000
	// Position of DOS_3 field.
	CAN_SR_DOS_3_Pos = 0x11
	// Bit mask of DOS_3 field.
	CAN_SR_DOS_3_Msk = 0x20000
	// Bit DOS_3.
	CAN_SR_DOS_3 = 0x20000
	// Position of TBS3_3 field.
	CAN_SR_TBS3_3_Pos = 0x12
	// Bit mask of TBS3_3 field.
	CAN_SR_TBS3_3_Msk = 0x40000
	// Bit TBS3_3.
	CAN_SR_TBS3_3 = 0x40000
	// Locked. Software cannot access the Tx Buffer 3 nor write to the corresponding CANxTFI, CANxTID, CANxTDA, and CANxTDB registers because a message is either waiting for transmission or is in transmitting process.
	CAN_SR_TBS3_3_LOCKED_SOFTWARE_CAN = 0x0
	// Released. Software may write a message into the Transmit Buffer 3 and its CANxTFI, CANxTID, CANxTDA, and CANxTDB registers.
	CAN_SR_TBS3_3_RELEASED_SOFTWARE_M = 0x1
	// Position of TCS3_3 field.
	CAN_SR_TCS3_3_Pos = 0x13
	// Bit mask of TCS3_3 field.
	CAN_SR_TCS3_3_Msk = 0x80000
	// Bit TCS3_3.
	CAN_SR_TCS3_3 = 0x80000
	// Incomplete. The previously requested transmission for Tx Buffer 3 is not complete.
	CAN_SR_TCS3_3_INCOMPLETE_THE_PREV = 0x0
	// Complete. The previously requested transmission for Tx Buffer 3 has been successfully completed.
	CAN_SR_TCS3_3_COMPLETE_THE_PREVIO = 0x1
	// Position of RS_3 field.
	CAN_SR_RS_3_Pos = 0x14
	// Bit mask of RS_3 field.
	CAN_SR_RS_3_Msk = 0x100000
	// Bit RS_3.
	CAN_SR_RS_3 = 0x100000
	// Position of TS3_3 field.
	CAN_SR_TS3_3_Pos = 0x15
	// Bit mask of TS3_3 field.
	CAN_SR_TS3_3_Msk = 0x200000
	// Bit TS3_3.
	CAN_SR_TS3_3 = 0x200000
	// Idle. There is no transmission from Tx Buffer 3.
	CAN_SR_TS3_3_IDLE_THERE_IS_NO_TR = 0x0
	// Transmit. The CAN Controller is transmitting a message from Tx Buffer 3.
	CAN_SR_TS3_3_TRANSMIT_THE_CAN_CO = 0x1
	// Position of ES_3 field.
	CAN_SR_ES_3_Pos = 0x16
	// Bit mask of ES_3 field.
	CAN_SR_ES_3_Msk = 0x400000
	// Bit ES_3.
	CAN_SR_ES_3 = 0x400000
	// Position of BS_3 field.
	CAN_SR_BS_3_Pos = 0x17
	// Bit mask of BS_3 field.
	CAN_SR_BS_3_Msk = 0x800000
	// Bit BS_3.
	CAN_SR_BS_3 = 0x800000
	// Position of RESERVED field.
	CAN_SR_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	CAN_SR_RESERVED_Msk = 0xff000000

	// RFS: Receive frame status. Can only be written when RM in CANMOD is 1.
	// Position of IDINDEX field.
	CAN_RFS_IDINDEX_Pos = 0x0
	// Bit mask of IDINDEX field.
	CAN_RFS_IDINDEX_Msk = 0x3ff
	// Position of BP field.
	CAN_RFS_BP_Pos = 0xa
	// Bit mask of BP field.
	CAN_RFS_BP_Msk = 0x400
	// Bit BP.
	CAN_RFS_BP = 0x400
	// Position of RESERVED field.
	CAN_RFS_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	CAN_RFS_RESERVED_Msk = 0xf800
	// Position of DLC field.
	CAN_RFS_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN_RFS_DLC_Msk = 0xf0000
	// Position of RESERVED field.
	CAN_RFS_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	CAN_RFS_RESERVED_Msk = 0x3ff00000
	// Position of RTR field.
	CAN_RFS_RTR_Pos = 0x1e
	// Bit mask of RTR field.
	CAN_RFS_RTR_Msk = 0x40000000
	// Bit RTR.
	CAN_RFS_RTR = 0x40000000
	// Position of FF field.
	CAN_RFS_FF_Pos = 0x1f
	// Bit mask of FF field.
	CAN_RFS_FF_Msk = 0x80000000
	// Bit FF.
	CAN_RFS_FF = 0x80000000

	// RID: Received Identifier. Can only be written when RM in CANMOD is 1.
	// Position of ID field.
	CAN_RID_ID_Pos = 0x0
	// Bit mask of ID field.
	CAN_RID_ID_Msk = 0x7ff
	// Position of RESERVED field.
	CAN_RID_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	CAN_RID_RESERVED_Msk = 0xfffff800

	// RDA: Received data bytes 1-4. Can only be written when RM in CANMOD is 1.
	// Position of DATA1 field.
	CAN_RDA_DATA1_Pos = 0x0
	// Bit mask of DATA1 field.
	CAN_RDA_DATA1_Msk = 0xff
	// Position of DATA2 field.
	CAN_RDA_DATA2_Pos = 0x8
	// Bit mask of DATA2 field.
	CAN_RDA_DATA2_Msk = 0xff00
	// Position of DATA3 field.
	CAN_RDA_DATA3_Pos = 0x10
	// Bit mask of DATA3 field.
	CAN_RDA_DATA3_Msk = 0xff0000
	// Position of DATA4 field.
	CAN_RDA_DATA4_Pos = 0x18
	// Bit mask of DATA4 field.
	CAN_RDA_DATA4_Msk = 0xff000000

	// RDB: Received data bytes 5-8. Can only be written when RM in CANMOD is 1.
	// Position of DATA5 field.
	CAN_RDB_DATA5_Pos = 0x0
	// Bit mask of DATA5 field.
	CAN_RDB_DATA5_Msk = 0xff
	// Position of DATA6 field.
	CAN_RDB_DATA6_Pos = 0x8
	// Bit mask of DATA6 field.
	CAN_RDB_DATA6_Msk = 0xff00
	// Position of DATA7 field.
	CAN_RDB_DATA7_Pos = 0x10
	// Bit mask of DATA7 field.
	CAN_RDB_DATA7_Msk = 0xff0000
	// Position of DATA8 field.
	CAN_RDB_DATA8_Pos = 0x18
	// Bit mask of DATA8 field.
	CAN_RDB_DATA8_Msk = 0xff000000

	// TFI1: Transmit frame info (Tx Buffer )
	// Position of PRIO field.
	CAN_TFI_PRIO_Pos = 0x0
	// Bit mask of PRIO field.
	CAN_TFI_PRIO_Msk = 0xff
	// Position of RESERVED field.
	CAN_TFI_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	CAN_TFI_RESERVED_Msk = 0xff00
	// Position of DLC field.
	CAN_TFI_DLC_Pos = 0x10
	// Bit mask of DLC field.
	CAN_TFI_DLC_Msk = 0xf0000
	// Position of RESERVED field.
	CAN_TFI_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	CAN_TFI_RESERVED_Msk = 0x3ff00000
	// Position of RTR field.
	CAN_TFI_RTR_Pos = 0x1e
	// Bit mask of RTR field.
	CAN_TFI_RTR_Msk = 0x40000000
	// Bit RTR.
	CAN_TFI_RTR = 0x40000000
	// Position of FF field.
	CAN_TFI_FF_Pos = 0x1f
	// Bit mask of FF field.
	CAN_TFI_FF_Msk = 0x80000000
	// Bit FF.
	CAN_TFI_FF = 0x80000000

	// TID1: Transmit Identifier (Tx Buffer)
	// Position of ID field.
	CAN_TID_ID_Pos = 0x0
	// Bit mask of ID field.
	CAN_TID_ID_Msk = 0x7ff
	// Position of RESERVED field.
	CAN_TID_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	CAN_TID_RESERVED_Msk = 0xfffff800

	// TDA1: Transmit data bytes 1-4 (Tx Buffer)
	// Position of DATA1 field.
	CAN_TDA_DATA1_Pos = 0x0
	// Bit mask of DATA1 field.
	CAN_TDA_DATA1_Msk = 0xff
	// Position of DATA2 field.
	CAN_TDA_DATA2_Pos = 0x8
	// Bit mask of DATA2 field.
	CAN_TDA_DATA2_Msk = 0xff00
	// Position of DATA3 field.
	CAN_TDA_DATA3_Pos = 0x10
	// Bit mask of DATA3 field.
	CAN_TDA_DATA3_Msk = 0xff0000
	// Position of DATA4 field.
	CAN_TDA_DATA4_Pos = 0x18
	// Bit mask of DATA4 field.
	CAN_TDA_DATA4_Msk = 0xff000000

	// TDB1: Transmit data bytes 5-8 (Tx Buffer )
	// Position of DATA5 field.
	CAN_TDB_DATA5_Pos = 0x0
	// Bit mask of DATA5 field.
	CAN_TDB_DATA5_Msk = 0xff
	// Position of DATA6 field.
	CAN_TDB_DATA6_Pos = 0x8
	// Bit mask of DATA6 field.
	CAN_TDB_DATA6_Msk = 0xff00
	// Position of DATA7 field.
	CAN_TDB_DATA7_Pos = 0x10
	// Bit mask of DATA7 field.
	CAN_TDB_DATA7_Msk = 0xff0000
	// Position of DATA8 field.
	CAN_TDB_DATA8_Pos = 0x18
	// Bit mask of DATA8 field.
	CAN_TDB_DATA8_Msk = 0xff000000
)

// Constants for DAC: Digital-to-Analog Converter (DAC) Modification
const (
	// CR: D/A Converter Register. This register contains the digital value to be converted to analog and a power control bit.
	// Position of RESERVED field.
	DAC_CR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	DAC_CR_RESERVED_Msk = 0x3f
	// Position of VALUE field.
	DAC_CR_VALUE_Pos = 0x6
	// Bit mask of VALUE field.
	DAC_CR_VALUE_Msk = 0xffc0
	// Position of BIAS field.
	DAC_CR_BIAS_Pos = 0x10
	// Bit mask of BIAS field.
	DAC_CR_BIAS_Msk = 0x10000
	// Bit BIAS.
	DAC_CR_BIAS = 0x10000
	// The settling time of the DAC is 1 us max, and the maximum current is 700 uA. This allows a maximum update rate of 1 MHz.
	DAC_CR_BIAS_FAST = 0x0
	// The settling time of the DAC is 2.5 us and the maximum current is 350 uA. This allows a maximum update rate of 400 kHz.
	DAC_CR_BIAS_SLOW = 0x1
	// Position of RESERVED field.
	DAC_CR_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	DAC_CR_RESERVED_Msk = 0xfffe0000

	// CTRL: DAC Control register. This register controls DMA and timer operation.
	// Position of INT_DMA_REQ field.
	DAC_CTRL_INT_DMA_REQ_Pos = 0x0
	// Bit mask of INT_DMA_REQ field.
	DAC_CTRL_INT_DMA_REQ_Msk = 0x1
	// Bit INT_DMA_REQ.
	DAC_CTRL_INT_DMA_REQ = 0x1
	// Clear on any write to the DACR register.
	DAC_CTRL_INT_DMA_REQ_CLEAR_ON_ANY_WRITE_T = 0x0
	// Set by hardware when the timer times out.
	DAC_CTRL_INT_DMA_REQ_SET_BY_HARDWARE_WHEN = 0x1
	// Position of DBLBUF_ENA field.
	DAC_CTRL_DBLBUF_ENA_Pos = 0x1
	// Bit mask of DBLBUF_ENA field.
	DAC_CTRL_DBLBUF_ENA_Msk = 0x2
	// Bit DBLBUF_ENA.
	DAC_CTRL_DBLBUF_ENA = 0x2
	// Disable
	DAC_CTRL_DBLBUF_ENA_DISABLE = 0x0
	// Enable. When this bit and the CNT_ENA bit are both set, the double-buffering feature in the DACR register will be enabled. Writes to the DACR register are written to a pre-buffer and then transferred to the DACR on the next time-out of the counter.
	DAC_CTRL_DBLBUF_ENA_ENABLE_WHEN_THIS_BI = 0x1
	// Position of CNT_ENA field.
	DAC_CTRL_CNT_ENA_Pos = 0x2
	// Bit mask of CNT_ENA field.
	DAC_CTRL_CNT_ENA_Msk = 0x4
	// Bit CNT_ENA.
	DAC_CTRL_CNT_ENA = 0x4
	// Disable
	DAC_CTRL_CNT_ENA_DISABLE = 0x0
	// Enable
	DAC_CTRL_CNT_ENA_ENABLE = 0x1
	// Position of DMA_ENA field.
	DAC_CTRL_DMA_ENA_Pos = 0x3
	// Bit mask of DMA_ENA field.
	DAC_CTRL_DMA_ENA_Msk = 0x8
	// Bit DMA_ENA.
	DAC_CTRL_DMA_ENA = 0x8
	// Disable
	DAC_CTRL_DMA_ENA_DISABLE = 0x0
	// Enable. DMA Burst Request Input 7 is enabled for the DAC (see Table 672).
	DAC_CTRL_DMA_ENA_ENABLE_DMA_BURST_RE = 0x1
	// Position of RESERVED field.
	DAC_CTRL_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	DAC_CTRL_RESERVED_Msk = 0xfffffff0

	// CNTVAL: DAC Counter Value register. This register contains the reload value for the DAC DMA/Interrupt timer.
	// Position of VALUE field.
	DAC_CNTVAL_VALUE_Pos = 0x0
	// Bit mask of VALUE field.
	DAC_CNTVAL_VALUE_Msk = 0xffff
	// Position of RESERVED field.
	DAC_CNTVAL_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	DAC_CNTVAL_RESERVED_Msk = 0xffff0000
)

// Constants for UART4: UART4
const (
	// RBR: Receiver Buffer Register. Contains the next received character to be read (DLAB =0).
	// Position of RBR field.
	UART4_RBR_RBR_Pos = 0x0
	// Bit mask of RBR field.
	UART4_RBR_RBR_Msk = 0xff
	// Position of RESERVED field.
	UART4_RBR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART4_RBR_RESERVED_Msk = 0xffffff00

	// THR: Transmit Holding Register. The next character to be transmitted is written here (DLAB =0).
	// Position of THR field.
	UART4_THR_THR_Pos = 0x0
	// Bit mask of THR field.
	UART4_THR_THR_Msk = 0xff
	// Position of RESERVED field.
	UART4_THR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART4_THR_RESERVED_Msk = 0xffffff00

	// DLL: Divisor Latch LSB. Least significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider (DLAB =1).
	// Position of DLLSB field.
	UART4_DLL_DLLSB_Pos = 0x0
	// Bit mask of DLLSB field.
	UART4_DLL_DLLSB_Msk = 0xff
	// Position of RESERVED field.
	UART4_DLL_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART4_DLL_RESERVED_Msk = 0xffffff00

	// DLM: Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider (DLAB =1).
	// Position of DLMSB field.
	UART4_DLM_DLMSB_Pos = 0x0
	// Bit mask of DLMSB field.
	UART4_DLM_DLMSB_Msk = 0xff
	// Position of RESERVED field.
	UART4_DLM_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART4_DLM_RESERVED_Msk = 0xffffff00

	// IER: Interrupt Enable Register. Contains individual interrupt enable bits for the 7 potential UART interrupts (DLAB =0).
	// Position of RBRIE field.
	UART4_IER_RBRIE_Pos = 0x0
	// Bit mask of RBRIE field.
	UART4_IER_RBRIE_Msk = 0x1
	// Bit RBRIE.
	UART4_IER_RBRIE = 0x1
	// Disable the RDA interrupts.
	UART4_IER_RBRIE_DISABLE_THE_RDA_INTE = 0x0
	// Enable the RDA interrupts.
	UART4_IER_RBRIE_ENABLE_THE_RDA_INTER = 0x1
	// Position of THREIE field.
	UART4_IER_THREIE_Pos = 0x1
	// Bit mask of THREIE field.
	UART4_IER_THREIE_Msk = 0x2
	// Bit THREIE.
	UART4_IER_THREIE = 0x2
	// Disable the THRE interrupts.
	UART4_IER_THREIE_DISABLE_THE_THRE_INT = 0x0
	// Enable the THRE interrupts.
	UART4_IER_THREIE_ENABLE_THE_THRE_INTE = 0x1
	// Position of RXIE field.
	UART4_IER_RXIE_Pos = 0x2
	// Bit mask of RXIE field.
	UART4_IER_RXIE_Msk = 0x4
	// Bit RXIE.
	UART4_IER_RXIE = 0x4
	// Disable the RX line status interrupts.
	UART4_IER_RXIE_DISABLE_THE_RX_LINE_ = 0x0
	// Enable the RX line status interrupts.
	UART4_IER_RXIE_ENABLE_THE_RX_LINE_S = 0x1
	// Position of RESERVED field.
	UART4_IER_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	UART4_IER_RESERVED_Msk = 0xf8
	// Position of ABEOINTEN field.
	UART4_IER_ABEOINTEN_Pos = 0x8
	// Bit mask of ABEOINTEN field.
	UART4_IER_ABEOINTEN_Msk = 0x100
	// Bit ABEOINTEN.
	UART4_IER_ABEOINTEN = 0x100
	// Disable end of auto-baud Interrupt.
	UART4_IER_ABEOINTEN_DISABLE_END_OF_AUTO_ = 0x0
	// Enable end of auto-baud Interrupt.
	UART4_IER_ABEOINTEN_ENABLE_END_OF_AUTO_B = 0x1
	// Position of ABTOINTEN field.
	UART4_IER_ABTOINTEN_Pos = 0x9
	// Bit mask of ABTOINTEN field.
	UART4_IER_ABTOINTEN_Msk = 0x200
	// Bit ABTOINTEN.
	UART4_IER_ABTOINTEN = 0x200
	// Disable auto-baud time-out Interrupt.
	UART4_IER_ABTOINTEN_DISABLE_AUTO_BAUD_TI = 0x0
	// Enable auto-baud time-out Interrupt.
	UART4_IER_ABTOINTEN_ENABLE_AUTO_BAUD_TIM = 0x1
	// Position of RESERVED field.
	UART4_IER_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	UART4_IER_RESERVED_Msk = 0xfffffc00

	// IIR: Interrupt ID Register. Identifies which interrupt(s) are pending.
	// Position of INTSTATUS field.
	UART4_IIR_INTSTATUS_Pos = 0x0
	// Bit mask of INTSTATUS field.
	UART4_IIR_INTSTATUS_Msk = 0x1
	// Bit INTSTATUS.
	UART4_IIR_INTSTATUS = 0x1
	// At least one interrupt is pending.
	UART4_IIR_INTSTATUS_AT_LEAST_ONE_INTERRU = 0x0
	// No interrupt is pending.
	UART4_IIR_INTSTATUS_NO_INTERRUPT_IS_PEND = 0x1
	// Position of INTID field.
	UART4_IIR_INTID_Pos = 0x1
	// Bit mask of INTID field.
	UART4_IIR_INTID_Msk = 0xe
	// 1 - Receive Line Status (RLS).
	UART4_IIR_INTID_1_RECEIVE_LINE_S = 0x3
	// 2a - Receive Data Available (RDA).
	UART4_IIR_INTID_2A__RECEIVE_DATA_AV = 0x2
	// 2b - Character Time-out Indicator (CTI).
	UART4_IIR_INTID_2B__CHARACTER_TIME_ = 0x6
	// 3 - THRE Interrupt
	UART4_IIR_INTID_3_THRE_INTERRUPT = 0x1
	// Position of RESERVED field.
	UART4_IIR_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	UART4_IIR_RESERVED_Msk = 0x30
	// Position of FIFOENABLE field.
	UART4_IIR_FIFOENABLE_Pos = 0x6
	// Bit mask of FIFOENABLE field.
	UART4_IIR_FIFOENABLE_Msk = 0xc0
	// Position of ABEOINT field.
	UART4_IIR_ABEOINT_Pos = 0x8
	// Bit mask of ABEOINT field.
	UART4_IIR_ABEOINT_Msk = 0x100
	// Bit ABEOINT.
	UART4_IIR_ABEOINT = 0x100
	// Position of ABTOINT field.
	UART4_IIR_ABTOINT_Pos = 0x9
	// Bit mask of ABTOINT field.
	UART4_IIR_ABTOINT_Msk = 0x200
	// Bit ABTOINT.
	UART4_IIR_ABTOINT = 0x200
	// Position of RESERVED field.
	UART4_IIR_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	UART4_IIR_RESERVED_Msk = 0xfffffc00

	// FCR: FIFO Control Register. Controls UART FIFO usage and modes.
	// Position of FIFOEN field.
	UART4_FCR_FIFOEN_Pos = 0x0
	// Bit mask of FIFOEN field.
	UART4_FCR_FIFOEN_Msk = 0x1
	// Bit FIFOEN.
	UART4_FCR_FIFOEN = 0x1
	// UARTn FIFOs are disabled. Must not be used in the application.
	UART4_FCR_FIFOEN_UARTN_FIFOS_ARE_DISA = 0x0
	// Active high enable for both UARTn Rx and TX FIFOs and UnFCR[7:1] access. This bit must be set for proper UART operation. Any transition on this bit will automatically clear the related UART FIFOs.
	UART4_FCR_FIFOEN_ACTIVE_HIGH_ENABLE_F = 0x1
	// Position of RXFIFORES field.
	UART4_FCR_RXFIFORES_Pos = 0x1
	// Bit mask of RXFIFORES field.
	UART4_FCR_RXFIFORES_Msk = 0x2
	// Bit RXFIFORES.
	UART4_FCR_RXFIFORES = 0x2
	// No impact on either of UARTn FIFOs.
	UART4_FCR_RXFIFORES_NO_IMPACT_ON_EITHER_ = 0x0
	// Writing a logic 1 to UnFCR[1] will clear all bytes in UARTn Rx FIFO, reset the pointer logic. This bit is self-clearing.
	UART4_FCR_RXFIFORES_WRITING_A_LOGIC_1_TO = 0x1
	// Position of TXFIFORES field.
	UART4_FCR_TXFIFORES_Pos = 0x2
	// Bit mask of TXFIFORES field.
	UART4_FCR_TXFIFORES_Msk = 0x4
	// Bit TXFIFORES.
	UART4_FCR_TXFIFORES = 0x4
	// No impact on either of UARTn FIFOs.
	UART4_FCR_TXFIFORES_NO_IMPACT_ON_EITHER_ = 0x0
	// Writing a logic 1 to UnFCR[2] will clear all bytes in UARTn TX FIFO, reset the pointer logic. This bit is self-clearing.
	UART4_FCR_TXFIFORES_WRITING_A_LOGIC_1_TO = 0x1
	// Position of DMAMODE field.
	UART4_FCR_DMAMODE_Pos = 0x3
	// Bit mask of DMAMODE field.
	UART4_FCR_DMAMODE_Msk = 0x8
	// Bit DMAMODE.
	UART4_FCR_DMAMODE = 0x8
	// Position of RESERVED field.
	UART4_FCR_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	UART4_FCR_RESERVED_Msk = 0x30
	// Position of RXTRIGLVL field.
	UART4_FCR_RXTRIGLVL_Pos = 0x6
	// Bit mask of RXTRIGLVL field.
	UART4_FCR_RXTRIGLVL_Msk = 0xc0
	// Trigger level 0 (1 character or 0x01).
	UART4_FCR_RXTRIGLVL_TRIGGER_LEVEL_0_1_C = 0x0
	// Trigger level 1 (4 characters or 0x04).
	UART4_FCR_RXTRIGLVL_TRIGGER_LEVEL_1_4_C = 0x1
	// Trigger level 2 (8 characters or 0x08).
	UART4_FCR_RXTRIGLVL_TRIGGER_LEVEL_2_8_C = 0x2
	// Trigger level 3 (14 characters or 0x0E).
	UART4_FCR_RXTRIGLVL_TRIGGER_LEVEL_3_14_ = 0x3
	// Position of RESERVED field.
	UART4_FCR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART4_FCR_RESERVED_Msk = 0xffffff00

	// LCR: Line Control Register. Contains controls for frame formatting and break generation.
	// Position of WLS field.
	UART4_LCR_WLS_Pos = 0x0
	// Bit mask of WLS field.
	UART4_LCR_WLS_Msk = 0x3
	// 5-bit character length
	UART4_LCR_WLS_5_BIT_CHARACTER_LENG = 0x0
	// 6-bit character length
	UART4_LCR_WLS_6_BIT_CHARACTER_LENG = 0x1
	// 7-bit character length
	UART4_LCR_WLS_7_BIT_CHARACTER_LENG = 0x2
	// 8-bit character length
	UART4_LCR_WLS_8_BIT_CHARACTER_LENG = 0x3
	// Position of SBS field.
	UART4_LCR_SBS_Pos = 0x2
	// Bit mask of SBS field.
	UART4_LCR_SBS_Msk = 0x4
	// Bit SBS.
	UART4_LCR_SBS = 0x4
	// 1 stop bit.
	UART4_LCR_SBS_1_STOP_BIT_ = 0x0
	// 2 stop bits (1.5 if UnLCR[1:0]=00).
	UART4_LCR_SBS_2_STOP_BITS_1_5_IF_ = 0x1
	// Position of PE field.
	UART4_LCR_PE_Pos = 0x3
	// Bit mask of PE field.
	UART4_LCR_PE_Msk = 0x8
	// Bit PE.
	UART4_LCR_PE = 0x8
	// Disable parity generation and checking.
	UART4_LCR_PE_DISABLE_PARITY_GENER = 0x0
	// Enable parity generation and checking.
	UART4_LCR_PE_ENABLE_PARITY_GENERA = 0x1
	// Position of PS field.
	UART4_LCR_PS_Pos = 0x4
	// Bit mask of PS field.
	UART4_LCR_PS_Msk = 0x30
	// Odd parity. Number of 1s in the transmitted character and the attached parity bit will be odd.
	UART4_LCR_PS_ODD_PARITY_NUMBER_O = 0x0
	// Even Parity. Number of 1s in the transmitted character and the attached parity bit will be even.
	UART4_LCR_PS_EVEN_PARITY_NUMBER_ = 0x1
	// Forced 1 stick parity.
	UART4_LCR_PS_FORCED_1_STICK_PARIT = 0x2
	// Forced 0 stick parity.
	UART4_LCR_PS_FORCED_0_STICK_PARIT = 0x3
	// Position of BC field.
	UART4_LCR_BC_Pos = 0x6
	// Bit mask of BC field.
	UART4_LCR_BC_Msk = 0x40
	// Bit BC.
	UART4_LCR_BC = 0x40
	// Disable break transmission.
	UART4_LCR_BC_DISABLE_BREAK_TRANSM = 0x0
	// Enable break transmission. Output pin UARTn TXD is forced to logic 0 when UnLCR[6] is active high.
	UART4_LCR_BC_ENABLE_BREAK_TRANSMI = 0x1
	// Position of DLAB field.
	UART4_LCR_DLAB_Pos = 0x7
	// Bit mask of DLAB field.
	UART4_LCR_DLAB_Msk = 0x80
	// Bit DLAB.
	UART4_LCR_DLAB = 0x80
	// Disable access to Divisor Latches.
	UART4_LCR_DLAB_DISABLE_ACCESS_TO_DI = 0x0
	// Enable access to Divisor Latches.
	UART4_LCR_DLAB_ENABLE_ACCESS_TO_DIV = 0x1
	// Position of RESERVED field.
	UART4_LCR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART4_LCR_RESERVED_Msk = 0xffffff00

	// LSR: Line Status Register. Contains flags for transmit and receive status, including line errors.
	// Position of RDR field.
	UART4_LSR_RDR_Pos = 0x0
	// Bit mask of RDR field.
	UART4_LSR_RDR_Msk = 0x1
	// Bit RDR.
	UART4_LSR_RDR = 0x1
	// Position of OE field.
	UART4_LSR_OE_Pos = 0x1
	// Bit mask of OE field.
	UART4_LSR_OE_Msk = 0x2
	// Bit OE.
	UART4_LSR_OE = 0x2
	// Position of PE field.
	UART4_LSR_PE_Pos = 0x2
	// Bit mask of PE field.
	UART4_LSR_PE_Msk = 0x4
	// Bit PE.
	UART4_LSR_PE = 0x4
	// Position of FE field.
	UART4_LSR_FE_Pos = 0x3
	// Bit mask of FE field.
	UART4_LSR_FE_Msk = 0x8
	// Bit FE.
	UART4_LSR_FE = 0x8
	// Position of BI field.
	UART4_LSR_BI_Pos = 0x4
	// Bit mask of BI field.
	UART4_LSR_BI_Msk = 0x10
	// Bit BI.
	UART4_LSR_BI = 0x10
	// Position of THRE field.
	UART4_LSR_THRE_Pos = 0x5
	// Bit mask of THRE field.
	UART4_LSR_THRE_Msk = 0x20
	// Bit THRE.
	UART4_LSR_THRE = 0x20
	// UnTHR contains valid data.
	UART4_LSR_THRE_UNTHR_CONTAINS_VALID = 0x0
	// UnTHR is empty.
	UART4_LSR_THRE_UNTHR_IS_EMPTY_ = 0x1
	// Position of TEMT field.
	UART4_LSR_TEMT_Pos = 0x6
	// Bit mask of TEMT field.
	UART4_LSR_TEMT_Msk = 0x40
	// Bit TEMT.
	UART4_LSR_TEMT = 0x40
	// UnTHR and/or the UnTSR contains valid data.
	UART4_LSR_TEMT_VALID_DATA = 0x0
	// UnTHR and the UnTSR are empty.
	UART4_LSR_TEMT_EMPTY = 0x1
	// Position of RXFE field.
	UART4_LSR_RXFE_Pos = 0x7
	// Bit mask of RXFE field.
	UART4_LSR_RXFE_Msk = 0x80
	// Bit RXFE.
	UART4_LSR_RXFE = 0x80
	// UnRBR contains no UARTn RX errors or UnFCR[0]=0.
	UART4_LSR_RXFE_UNRBR_CONTAINS_NO_UA = 0x0
	// UARTn RBR contains at least one UARTn RX error.
	UART4_LSR_RXFE_UARTN_RBR_CONTAINS_A = 0x1
	// Position of RESERVED field.
	UART4_LSR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART4_LSR_RESERVED_Msk = 0xffffff00

	// SCR: Scratch Pad Register. 8-bit temporary storage for software.
	// Position of Pad field.
	UART4_SCR_Pad_Pos = 0x0
	// Bit mask of Pad field.
	UART4_SCR_Pad_Msk = 0xff
	// Position of RESERVED field.
	UART4_SCR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART4_SCR_RESERVED_Msk = 0xffffff00

	// ACR: Auto-baud Control Register. Contains controls for the auto-baud feature.
	// Position of START field.
	UART4_ACR_START_Pos = 0x0
	// Bit mask of START field.
	UART4_ACR_START_Msk = 0x1
	// Bit START.
	UART4_ACR_START = 0x1
	// Auto-baud stop (auto-baud is not running).
	UART4_ACR_START_AUTO_BAUD_STOP_AUTO = 0x0
	// Auto-baud start (auto-baud is running). Auto-baud run bit. This bit is automatically cleared after auto-baud completion.
	UART4_ACR_START_AUTO_BAUD_START_AUT = 0x1
	// Position of MODE field.
	UART4_ACR_MODE_Pos = 0x1
	// Bit mask of MODE field.
	UART4_ACR_MODE_Msk = 0x2
	// Bit MODE.
	UART4_ACR_MODE = 0x2
	// Mode 0.
	UART4_ACR_MODE_MODE_0_ = 0x0
	// Mode 1.
	UART4_ACR_MODE_MODE_1_ = 0x1
	// Position of AUTORESTART field.
	UART4_ACR_AUTORESTART_Pos = 0x2
	// Bit mask of AUTORESTART field.
	UART4_ACR_AUTORESTART_Msk = 0x4
	// Bit AUTORESTART.
	UART4_ACR_AUTORESTART = 0x4
	// No restart.
	UART4_ACR_AUTORESTART_NO_RESTART_ = 0x0
	// Restart in case of time-out (counter restarts at next UARTn Rx falling edge)
	UART4_ACR_AUTORESTART_RESTART_IN_CASE_OF_T = 0x1
	// Position of RESERVED field.
	UART4_ACR_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	UART4_ACR_RESERVED_Msk = 0xf8
	// Position of ABEOINTCLR field.
	UART4_ACR_ABEOINTCLR_Pos = 0x8
	// Bit mask of ABEOINTCLR field.
	UART4_ACR_ABEOINTCLR_Msk = 0x100
	// Bit ABEOINTCLR.
	UART4_ACR_ABEOINTCLR = 0x100
	// No impact.
	UART4_ACR_ABEOINTCLR_NO_IMPACT_ = 0x0
	// Clear the corresponding interrupt in the IIR.
	UART4_ACR_ABEOINTCLR_CLEAR_THE_CORRESPOND = 0x1
	// Position of ABTOINTCLR field.
	UART4_ACR_ABTOINTCLR_Pos = 0x9
	// Bit mask of ABTOINTCLR field.
	UART4_ACR_ABTOINTCLR_Msk = 0x200
	// Bit ABTOINTCLR.
	UART4_ACR_ABTOINTCLR = 0x200
	// No impact.
	UART4_ACR_ABTOINTCLR_NO_IMPACT_ = 0x0
	// Clear the corresponding interrupt in the IIR.
	UART4_ACR_ABTOINTCLR_CLEAR_THE_CORRESPOND = 0x1
	// Position of RESERVED field.
	UART4_ACR_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	UART4_ACR_RESERVED_Msk = 0xfffffc00

	// ICR: IrDA Control Register. Enables and configures the IrDA mode.
	// Position of IRDAEN field.
	UART4_ICR_IRDAEN_Pos = 0x0
	// Bit mask of IRDAEN field.
	UART4_ICR_IRDAEN_Msk = 0x1
	// Bit IRDAEN.
	UART4_ICR_IRDAEN = 0x1
	// Disabled. IrDA mode on UART4 is disabled, UART4 acts as a standard UART.
	UART4_ICR_IRDAEN_DISABLED_IRDA_MODE_ = 0x0
	// Enabled. IrDA mode on UART4 is enabled.
	UART4_ICR_IRDAEN_ENABLED_IRDA_MODE_O = 0x1
	// Position of IRDAINV field.
	UART4_ICR_IRDAINV_Pos = 0x1
	// Bit mask of IRDAINV field.
	UART4_ICR_IRDAINV_Msk = 0x2
	// Bit IRDAINV.
	UART4_ICR_IRDAINV = 0x2
	// Not inverted.
	UART4_ICR_IRDAINV_NOT_INVERTED_ = 0x0
	// Inverted. This has no effect on the serial output.
	UART4_ICR_IRDAINV_INVERTED_THIS_HAS_N = 0x1
	// Position of FIXPULSEEN field.
	UART4_ICR_FIXPULSEEN_Pos = 0x2
	// Bit mask of FIXPULSEEN field.
	UART4_ICR_FIXPULSEEN_Msk = 0x4
	// Bit FIXPULSEEN.
	UART4_ICR_FIXPULSEEN = 0x4
	// Disabled.
	UART4_ICR_FIXPULSEEN_DISABLED_ = 0x0
	// Enabled.
	UART4_ICR_FIXPULSEEN_ENABLED_ = 0x1
	// Position of PULSEDIV field.
	UART4_ICR_PULSEDIV_Pos = 0x3
	// Bit mask of PULSEDIV field.
	UART4_ICR_PULSEDIV_Msk = 0x38
	// 2xTPCLK
	UART4_ICR_PULSEDIV_2XTPCLK = 0x0
	// 4xTPCLK
	UART4_ICR_PULSEDIV_4XTPCLK = 0x1
	// 8xTPCLK
	UART4_ICR_PULSEDIV_8XTPCLK = 0x2
	// 16xTPCLK
	UART4_ICR_PULSEDIV_16XTPCLK = 0x3
	// 32xTPCLK
	UART4_ICR_PULSEDIV_32XTPCLK = 0x4
	// 64xTPCLK
	UART4_ICR_PULSEDIV_64XTPCLK = 0x5
	// 128xTPCLK
	UART4_ICR_PULSEDIV_128XTPCLK = 0x6
	// 256xTPCLK
	UART4_ICR_PULSEDIV_256XTPCLK = 0x7
	// Position of RESERVED field.
	UART4_ICR_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	UART4_ICR_RESERVED_Msk = 0xffffffc0

	// FDR: Fractional Divider Register. Generates a clock input for the baud rate divider.
	// Position of DIVADDVAL field.
	UART4_FDR_DIVADDVAL_Pos = 0x0
	// Bit mask of DIVADDVAL field.
	UART4_FDR_DIVADDVAL_Msk = 0xf
	// Position of MULVAL field.
	UART4_FDR_MULVAL_Pos = 0x4
	// Bit mask of MULVAL field.
	UART4_FDR_MULVAL_Msk = 0xf0
	// Position of RESERVED field.
	UART4_FDR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART4_FDR_RESERVED_Msk = 0xffffff00

	// OSR: Oversampling register. Controls the degree of oversampling during each bit time.
	// Position of RESERVED field.
	UART4_OSR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	UART4_OSR_RESERVED_Msk = 0x1
	// Bit RESERVED.
	UART4_OSR_RESERVED = 0x1
	// Position of OSFRAC field.
	UART4_OSR_OSFRAC_Pos = 0x1
	// Bit mask of OSFRAC field.
	UART4_OSR_OSFRAC_Msk = 0xe
	// Position of OSINT field.
	UART4_OSR_OSINT_Pos = 0x4
	// Bit mask of OSINT field.
	UART4_OSR_OSINT_Msk = 0xf0
	// Position of FDINT field.
	UART4_OSR_FDINT_Pos = 0x8
	// Bit mask of FDINT field.
	UART4_OSR_FDINT_Msk = 0x7f00
	// Position of RESERVED field.
	UART4_OSR_RESERVED_Pos = 0xf
	// Bit mask of RESERVED field.
	UART4_OSR_RESERVED_Msk = 0xffff8000

	// SCICTRL: Smart Card Interface control register. Enables and configures the smartcard Interface feature.
	// Position of SCIEN field.
	UART4_SCICTRL_SCIEN_Pos = 0x0
	// Bit mask of SCIEN field.
	UART4_SCICTRL_SCIEN_Msk = 0x1
	// Bit SCIEN.
	UART4_SCICTRL_SCIEN = 0x1
	// Smart card interface disabled.
	UART4_SCICTRL_SCIEN_SMART_CARD_INTERFACE = 0x0
	// Asynchronous half duplex smart card interface is enabled.
	UART4_SCICTRL_SCIEN_ASYNCHRONOUS_HALF_DU = 0x1
	// Position of NACKDIS field.
	UART4_SCICTRL_NACKDIS_Pos = 0x1
	// Bit mask of NACKDIS field.
	UART4_SCICTRL_NACKDIS_Msk = 0x2
	// Bit NACKDIS.
	UART4_SCICTRL_NACKDIS = 0x2
	// A NACK response is enabled.
	UART4_SCICTRL_NACKDIS_A_NACK_RESPONSE_IS_E = 0x0
	// A NACK response is inhibited.
	UART4_SCICTRL_NACKDIS_A_NACK_RESPONSE_IS_I = 0x1
	// Position of PROTSEL field.
	UART4_SCICTRL_PROTSEL_Pos = 0x2
	// Bit mask of PROTSEL field.
	UART4_SCICTRL_PROTSEL_Msk = 0x4
	// Bit PROTSEL.
	UART4_SCICTRL_PROTSEL = 0x4
	// T = 0
	UART4_SCICTRL_PROTSEL_T_EQ_0 = 0x0
	// T = 1
	UART4_SCICTRL_PROTSEL_T_EQ_1 = 0x1
	// Position of TXRETRY field.
	UART4_SCICTRL_TXRETRY_Pos = 0x5
	// Bit mask of TXRETRY field.
	UART4_SCICTRL_TXRETRY_Msk = 0xe0
	// Position of GUARDTIME field.
	UART4_SCICTRL_GUARDTIME_Pos = 0x8
	// Bit mask of GUARDTIME field.
	UART4_SCICTRL_GUARDTIME_Msk = 0xff00
	// Position of RESERVED field.
	UART4_SCICTRL_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	UART4_SCICTRL_RESERVED_Msk = 0xffff0000

	// RS485CTRL: RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes.
	// Position of NMMEN field.
	UART4_RS485CTRL_NMMEN_Pos = 0x0
	// Bit mask of NMMEN field.
	UART4_RS485CTRL_NMMEN_Msk = 0x1
	// Bit NMMEN.
	UART4_RS485CTRL_NMMEN = 0x1
	// RS-485/EIA-485 Normal Multidrop Mode (NMM) is disabled.
	UART4_RS485CTRL_NMMEN_DISABLED = 0x0
	// RS-485/EIA-485 Normal Multidrop Mode (NMM) is enabled. In this mode, an address is detected when a received byte causes the USART to set the parity error and generate an interrupt. See Section 20.6.18 RS-485/EIA-485 modes of operation.
	UART4_RS485CTRL_NMMEN_ENABLED = 0x1
	// Position of RXDIS field.
	UART4_RS485CTRL_RXDIS_Pos = 0x1
	// Bit mask of RXDIS field.
	UART4_RS485CTRL_RXDIS_Msk = 0x2
	// Bit RXDIS.
	UART4_RS485CTRL_RXDIS = 0x2
	// Enabled.
	UART4_RS485CTRL_RXDIS_ENABLED_ = 0x0
	// Disabled.
	UART4_RS485CTRL_RXDIS_DISABLED_ = 0x1
	// Position of AADEN field.
	UART4_RS485CTRL_AADEN_Pos = 0x2
	// Bit mask of AADEN field.
	UART4_RS485CTRL_AADEN_Msk = 0x4
	// Bit AADEN.
	UART4_RS485CTRL_AADEN = 0x4
	// Disabled.
	UART4_RS485CTRL_AADEN_DISABLED_ = 0x0
	// Enabled.
	UART4_RS485CTRL_AADEN_ENABLED_ = 0x1
	// Position of RESERVED field.
	UART4_RS485CTRL_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	UART4_RS485CTRL_RESERVED_Msk = 0x8
	// Bit RESERVED.
	UART4_RS485CTRL_RESERVED = 0x8
	// Position of DCTRL field.
	UART4_RS485CTRL_DCTRL_Pos = 0x4
	// Bit mask of DCTRL field.
	UART4_RS485CTRL_DCTRL_Msk = 0x10
	// Bit DCTRL.
	UART4_RS485CTRL_DCTRL = 0x10
	// Disable Auto Direction Control.
	UART4_RS485CTRL_DCTRL_DISABLE_AUTO_DIRECTI = 0x0
	// Enable Auto Direction Control.
	UART4_RS485CTRL_DCTRL_ENABLE_AUTO_DIRECTIO = 0x1
	// Position of OINV field.
	UART4_RS485CTRL_OINV_Pos = 0x5
	// Bit mask of OINV field.
	UART4_RS485CTRL_OINV_Msk = 0x20
	// Bit OINV.
	UART4_RS485CTRL_OINV = 0x20
	// Low. The direction control pin will be driven to logic 0 when the transmitter has data to be sent. It will be driven to logic 1 after the last bit of data has been transmitted.
	UART4_RS485CTRL_OINV_LOW_THE_DIRECTION_C = 0x0
	// High. The direction control pin will be driven to logic 1 when the transmitter has data to be sent. It will be driven to logic 0 after the last bit of data has been transmitted.
	UART4_RS485CTRL_OINV_HIGH_THE_DIRECTION_ = 0x1
	// Position of RESERVED field.
	UART4_RS485CTRL_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	UART4_RS485CTRL_RESERVED_Msk = 0xffffffc0

	// RS485ADRMATCH: RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode.
	// Position of ADRMATCH field.
	UART4_RS485ADRMATCH_ADRMATCH_Pos = 0x0
	// Bit mask of ADRMATCH field.
	UART4_RS485ADRMATCH_ADRMATCH_Msk = 0xff
	// Position of RESERVED field.
	UART4_RS485ADRMATCH_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART4_RS485ADRMATCH_RESERVED_Msk = 0xffffff00

	// RS485DLY: RS-485/EIA-485 direction control delay.
	// Position of DLY field.
	UART4_RS485DLY_DLY_Pos = 0x0
	// Bit mask of DLY field.
	UART4_RS485DLY_DLY_Msk = 0xff
	// Position of RESERVED field.
	UART4_RS485DLY_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART4_RS485DLY_RESERVED_Msk = 0xffffff00

	// SYNCCTRL: Synchronous mode control register.
	// Position of SYNC field.
	UART4_SYNCCTRL_SYNC_Pos = 0x0
	// Bit mask of SYNC field.
	UART4_SYNCCTRL_SYNC_Msk = 0x1
	// Bit SYNC.
	UART4_SYNCCTRL_SYNC = 0x1
	// Disabled
	UART4_SYNCCTRL_SYNC_DISABLED = 0x0
	// Enabled
	UART4_SYNCCTRL_SYNC_ENABLED = 0x1
	// Position of CSRC field.
	UART4_SYNCCTRL_CSRC_Pos = 0x1
	// Bit mask of CSRC field.
	UART4_SYNCCTRL_CSRC_Msk = 0x2
	// Bit CSRC.
	UART4_SYNCCTRL_CSRC = 0x2
	// Synchronous slave mode (SCLK in)
	UART4_SYNCCTRL_CSRC_SYNCHRONOUS_SLAVE_MO = 0x0
	// Synchronous master mode (SCLK out)
	UART4_SYNCCTRL_CSRC_SYNCHRONOUS_MASTER_M = 0x1
	// Position of FES field.
	UART4_SYNCCTRL_FES_Pos = 0x2
	// Bit mask of FES field.
	UART4_SYNCCTRL_FES_Msk = 0x4
	// Bit FES.
	UART4_SYNCCTRL_FES = 0x4
	// Position of TSBYPASS field.
	UART4_SYNCCTRL_TSBYPASS_Pos = 0x3
	// Bit mask of TSBYPASS field.
	UART4_SYNCCTRL_TSBYPASS_Msk = 0x8
	// Bit TSBYPASS.
	UART4_SYNCCTRL_TSBYPASS = 0x8
	// The input clock is synchronized prior to being used in clock edge detection logic.
	UART4_SYNCCTRL_TSBYPASS_THE_INPUT_CLOCK_IS_S = 0x0
	// The input clock is not synchronized prior to being used in clock edge detection logic. This allows for a high er input clock rate at the expense of potential metastability.
	UART4_SYNCCTRL_TSBYPASS_THE_INPUT_CLOCK_IS_N = 0x1
	// Position of CSCEN field.
	UART4_SYNCCTRL_CSCEN_Pos = 0x4
	// Bit mask of CSCEN field.
	UART4_SYNCCTRL_CSCEN_Msk = 0x10
	// Bit CSCEN.
	UART4_SYNCCTRL_CSCEN = 0x10
	// SCLK cycles only when characters are being sent on TxD
	UART4_SYNCCTRL_CSCEN_SCLK_CYCLES_ONLY_WHE = 0x0
	// SCLK runs continuously (characters can be received on RxD independently from transmission on TxD)
	UART4_SYNCCTRL_CSCEN_SCLK_RUNS_CONTINUOUS = 0x1
	// Position of SSSDIS field.
	UART4_SYNCCTRL_SSSDIS_Pos = 0x5
	// Bit mask of SSSDIS field.
	UART4_SYNCCTRL_SSSDIS_Msk = 0x20
	// Bit SSSDIS.
	UART4_SYNCCTRL_SSSDIS = 0x20
	// Send start and stop bits as in other modes.
	UART4_SYNCCTRL_SSSDIS_SEND_START_AND_STOP_ = 0x0
	// Do not send start/stop bits.
	UART4_SYNCCTRL_SSSDIS_NOSTARTSTOPBIT = 0x1
	// Position of CCCLR field.
	UART4_SYNCCTRL_CCCLR_Pos = 0x6
	// Bit mask of CCCLR field.
	UART4_SYNCCTRL_CCCLR_Msk = 0x40
	// Bit CCCLR.
	UART4_SYNCCTRL_CCCLR = 0x40
	// CSCEN is under software control.
	UART4_SYNCCTRL_CCCLR_CSCEN_IS_UNDER_SOFTW = 0x0
	// Hardware clears CSCEN after each character is received.
	UART4_SYNCCTRL_CCCLR_HARDWARE_CLEARS_CSCE = 0x1
	// Position of RESERVED field.
	UART4_SYNCCTRL_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	UART4_SYNCCTRL_RESERVED_Msk = 0xffffffc0
)

// Constants for I2S: I2S interface
const (
	// DAO: I2S Digital Audio Output Register. Contains control bits for the I2S transmit channel.
	// Position of WORDWIDTH field.
	I2S_DAO_WORDWIDTH_Pos = 0x0
	// Bit mask of WORDWIDTH field.
	I2S_DAO_WORDWIDTH_Msk = 0x3
	// 8-bit data
	I2S_DAO_WORDWIDTH_8_BIT_DATA = 0x0
	// 16-bit data
	I2S_DAO_WORDWIDTH_16_BIT_DATA = 0x1
	// 32-bit data
	I2S_DAO_WORDWIDTH_32_BIT_DATA = 0x3
	// Position of MONO field.
	I2S_DAO_MONO_Pos = 0x2
	// Bit mask of MONO field.
	I2S_DAO_MONO_Msk = 0x4
	// Bit MONO.
	I2S_DAO_MONO = 0x4
	// Position of STOP field.
	I2S_DAO_STOP_Pos = 0x3
	// Bit mask of STOP field.
	I2S_DAO_STOP_Msk = 0x8
	// Bit STOP.
	I2S_DAO_STOP = 0x8
	// Position of RESET field.
	I2S_DAO_RESET_Pos = 0x4
	// Bit mask of RESET field.
	I2S_DAO_RESET_Msk = 0x10
	// Bit RESET.
	I2S_DAO_RESET = 0x10
	// Position of WS_SEL field.
	I2S_DAO_WS_SEL_Pos = 0x5
	// Bit mask of WS_SEL field.
	I2S_DAO_WS_SEL_Msk = 0x20
	// Bit WS_SEL.
	I2S_DAO_WS_SEL = 0x20
	// Position of WS_HALFPERIOD field.
	I2S_DAO_WS_HALFPERIOD_Pos = 0x6
	// Bit mask of WS_HALFPERIOD field.
	I2S_DAO_WS_HALFPERIOD_Msk = 0x7fc0
	// Position of MUTE field.
	I2S_DAO_MUTE_Pos = 0xf
	// Bit mask of MUTE field.
	I2S_DAO_MUTE_Msk = 0x8000
	// Bit MUTE.
	I2S_DAO_MUTE = 0x8000
	// Position of RESERVED field.
	I2S_DAO_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	I2S_DAO_RESERVED_Msk = 0xffff0000

	// DAI: I2S Digital Audio Input Register. Contains control bits for the I2S receive channel.
	// Position of WORDWIDTH field.
	I2S_DAI_WORDWIDTH_Pos = 0x0
	// Bit mask of WORDWIDTH field.
	I2S_DAI_WORDWIDTH_Msk = 0x3
	// 8-bit data
	I2S_DAI_WORDWIDTH_8_BIT_DATA = 0x0
	// 16-bit data
	I2S_DAI_WORDWIDTH_16_BIT_DATA = 0x1
	// 32-bit data
	I2S_DAI_WORDWIDTH_32_BIT_DATA = 0x3
	// Position of MONO field.
	I2S_DAI_MONO_Pos = 0x2
	// Bit mask of MONO field.
	I2S_DAI_MONO_Msk = 0x4
	// Bit MONO.
	I2S_DAI_MONO = 0x4
	// Position of STOP field.
	I2S_DAI_STOP_Pos = 0x3
	// Bit mask of STOP field.
	I2S_DAI_STOP_Msk = 0x8
	// Bit STOP.
	I2S_DAI_STOP = 0x8
	// Position of RESET field.
	I2S_DAI_RESET_Pos = 0x4
	// Bit mask of RESET field.
	I2S_DAI_RESET_Msk = 0x10
	// Bit RESET.
	I2S_DAI_RESET = 0x10
	// Position of WS_SEL field.
	I2S_DAI_WS_SEL_Pos = 0x5
	// Bit mask of WS_SEL field.
	I2S_DAI_WS_SEL_Msk = 0x20
	// Bit WS_SEL.
	I2S_DAI_WS_SEL = 0x20
	// Position of WS_HALFPERIOD field.
	I2S_DAI_WS_HALFPERIOD_Pos = 0x6
	// Bit mask of WS_HALFPERIOD field.
	I2S_DAI_WS_HALFPERIOD_Msk = 0x7fc0
	// Position of RESERVED field.
	I2S_DAI_RESERVED_Pos = 0xf
	// Bit mask of RESERVED field.
	I2S_DAI_RESERVED_Msk = 0xffff8000

	// TXFIFO: I2S Transmit FIFO. Access register for the 8 x 32-bit transmitter FIFO.
	// Position of I2STXFIFO field.
	I2S_TXFIFO_I2STXFIFO_Pos = 0x0
	// Bit mask of I2STXFIFO field.
	I2S_TXFIFO_I2STXFIFO_Msk = 0xffffffff

	// RXFIFO: I2S Receive FIFO. Access register for the 8 x 32-bit receiver FIFO.
	// Position of I2SRXFIFO field.
	I2S_RXFIFO_I2SRXFIFO_Pos = 0x0
	// Bit mask of I2SRXFIFO field.
	I2S_RXFIFO_I2SRXFIFO_Msk = 0xffffffff

	// STATE: I2S Status Feedback Register. Contains status information about the I2S interface.
	// Position of IRQ field.
	I2S_STATE_IRQ_Pos = 0x0
	// Bit mask of IRQ field.
	I2S_STATE_IRQ_Msk = 0x1
	// Bit IRQ.
	I2S_STATE_IRQ = 0x1
	// Position of DMAREQ1 field.
	I2S_STATE_DMAREQ1_Pos = 0x1
	// Bit mask of DMAREQ1 field.
	I2S_STATE_DMAREQ1_Msk = 0x2
	// Bit DMAREQ1.
	I2S_STATE_DMAREQ1 = 0x2
	// Position of DMAREQ2 field.
	I2S_STATE_DMAREQ2_Pos = 0x2
	// Bit mask of DMAREQ2 field.
	I2S_STATE_DMAREQ2_Msk = 0x4
	// Bit DMAREQ2.
	I2S_STATE_DMAREQ2 = 0x4
	// Position of RESERVED field.
	I2S_STATE_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	I2S_STATE_RESERVED_Msk = 0xf8
	// Position of RX_LEVEL field.
	I2S_STATE_RX_LEVEL_Pos = 0x8
	// Bit mask of RX_LEVEL field.
	I2S_STATE_RX_LEVEL_Msk = 0xf00
	// Position of RESERVED field.
	I2S_STATE_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	I2S_STATE_RESERVED_Msk = 0xf000
	// Position of TX_LEVEL field.
	I2S_STATE_TX_LEVEL_Pos = 0x10
	// Bit mask of TX_LEVEL field.
	I2S_STATE_TX_LEVEL_Msk = 0xf0000
	// Position of RESERVED field.
	I2S_STATE_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	I2S_STATE_RESERVED_Msk = 0xfff00000

	// DMA1: I2S DMA Configuration Register 1. Contains control information for DMA request 1.
	// Position of RX_DMA1_ENABLE field.
	I2S_DMA1_RX_DMA1_ENABLE_Pos = 0x0
	// Bit mask of RX_DMA1_ENABLE field.
	I2S_DMA1_RX_DMA1_ENABLE_Msk = 0x1
	// Bit RX_DMA1_ENABLE.
	I2S_DMA1_RX_DMA1_ENABLE = 0x1
	// Position of TX_DMA1_ENABLE field.
	I2S_DMA1_TX_DMA1_ENABLE_Pos = 0x1
	// Bit mask of TX_DMA1_ENABLE field.
	I2S_DMA1_TX_DMA1_ENABLE_Msk = 0x2
	// Bit TX_DMA1_ENABLE.
	I2S_DMA1_TX_DMA1_ENABLE = 0x2
	// Position of RESERVED field.
	I2S_DMA1_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	I2S_DMA1_RESERVED_Msk = 0xfc
	// Position of RX_DEPTH_DMA1 field.
	I2S_DMA1_RX_DEPTH_DMA1_Pos = 0x8
	// Bit mask of RX_DEPTH_DMA1 field.
	I2S_DMA1_RX_DEPTH_DMA1_Msk = 0xf00
	// Position of RESERVED field.
	I2S_DMA1_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	I2S_DMA1_RESERVED_Msk = 0xf000
	// Position of TX_DEPTH_DMA1 field.
	I2S_DMA1_TX_DEPTH_DMA1_Pos = 0x10
	// Bit mask of TX_DEPTH_DMA1 field.
	I2S_DMA1_TX_DEPTH_DMA1_Msk = 0xf0000
	// Position of RESERVED field.
	I2S_DMA1_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	I2S_DMA1_RESERVED_Msk = 0xfff00000

	// DMA2: I2S DMA Configuration Register 2. Contains control information for DMA request 2.
	// Position of RX_DMA2_ENABLE field.
	I2S_DMA2_RX_DMA2_ENABLE_Pos = 0x0
	// Bit mask of RX_DMA2_ENABLE field.
	I2S_DMA2_RX_DMA2_ENABLE_Msk = 0x1
	// Bit RX_DMA2_ENABLE.
	I2S_DMA2_RX_DMA2_ENABLE = 0x1
	// Position of TX_DMA2_ENABLE field.
	I2S_DMA2_TX_DMA2_ENABLE_Pos = 0x1
	// Bit mask of TX_DMA2_ENABLE field.
	I2S_DMA2_TX_DMA2_ENABLE_Msk = 0x2
	// Bit TX_DMA2_ENABLE.
	I2S_DMA2_TX_DMA2_ENABLE = 0x2
	// Position of RESERVED field.
	I2S_DMA2_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	I2S_DMA2_RESERVED_Msk = 0xfc
	// Position of RX_DEPTH_DMA2 field.
	I2S_DMA2_RX_DEPTH_DMA2_Pos = 0x8
	// Bit mask of RX_DEPTH_DMA2 field.
	I2S_DMA2_RX_DEPTH_DMA2_Msk = 0xf00
	// Position of RESERVED field.
	I2S_DMA2_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	I2S_DMA2_RESERVED_Msk = 0xf000
	// Position of TX_DEPTH_DMA2 field.
	I2S_DMA2_TX_DEPTH_DMA2_Pos = 0x10
	// Bit mask of TX_DEPTH_DMA2 field.
	I2S_DMA2_TX_DEPTH_DMA2_Msk = 0xf0000
	// Position of RESERVED field.
	I2S_DMA2_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	I2S_DMA2_RESERVED_Msk = 0xfff00000

	// IRQ: I2S Interrupt Request Control Register. Contains bits that control how the I2S interrupt request is generated.
	// Position of RX_IRQ_ENABLE field.
	I2S_IRQ_RX_IRQ_ENABLE_Pos = 0x0
	// Bit mask of RX_IRQ_ENABLE field.
	I2S_IRQ_RX_IRQ_ENABLE_Msk = 0x1
	// Bit RX_IRQ_ENABLE.
	I2S_IRQ_RX_IRQ_ENABLE = 0x1
	// Position of TX_IRQ_ENABLE field.
	I2S_IRQ_TX_IRQ_ENABLE_Pos = 0x1
	// Bit mask of TX_IRQ_ENABLE field.
	I2S_IRQ_TX_IRQ_ENABLE_Msk = 0x2
	// Bit TX_IRQ_ENABLE.
	I2S_IRQ_TX_IRQ_ENABLE = 0x2
	// Position of RESERVED field.
	I2S_IRQ_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	I2S_IRQ_RESERVED_Msk = 0xfc
	// Position of RX_DEPTH_IRQ field.
	I2S_IRQ_RX_DEPTH_IRQ_Pos = 0x8
	// Bit mask of RX_DEPTH_IRQ field.
	I2S_IRQ_RX_DEPTH_IRQ_Msk = 0xf00
	// Position of RESERVED field.
	I2S_IRQ_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	I2S_IRQ_RESERVED_Msk = 0xf000
	// Position of TX_DEPTH_IRQ field.
	I2S_IRQ_TX_DEPTH_IRQ_Pos = 0x10
	// Bit mask of TX_DEPTH_IRQ field.
	I2S_IRQ_TX_DEPTH_IRQ_Msk = 0xf0000
	// Position of RESERVED field.
	I2S_IRQ_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	I2S_IRQ_RESERVED_Msk = 0xfff00000

	// TXRATE: I2S Transmit MCLK divider. This register determines the I2S TX MCLK rate by specifying the value to divide PCLK by in order to produce MCLK.
	// Position of Y_DIVIDER field.
	I2S_TXRATE_Y_DIVIDER_Pos = 0x0
	// Bit mask of Y_DIVIDER field.
	I2S_TXRATE_Y_DIVIDER_Msk = 0xff
	// Position of X_DIVIDER field.
	I2S_TXRATE_X_DIVIDER_Pos = 0x8
	// Bit mask of X_DIVIDER field.
	I2S_TXRATE_X_DIVIDER_Msk = 0xff00
	// Position of RESERVED field.
	I2S_TXRATE_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	I2S_TXRATE_RESERVED_Msk = 0xffff0000

	// RXRATE: I2S Receive MCLK divider. This register determines the I2S RX MCLK rate by specifying the value to divide PCLK by in order to produce MCLK.
	// Position of Y_DIVIDER field.
	I2S_RXRATE_Y_DIVIDER_Pos = 0x0
	// Bit mask of Y_DIVIDER field.
	I2S_RXRATE_Y_DIVIDER_Msk = 0xff
	// Position of X_DIVIDER field.
	I2S_RXRATE_X_DIVIDER_Pos = 0x8
	// Bit mask of X_DIVIDER field.
	I2S_RXRATE_X_DIVIDER_Msk = 0xff00
	// Position of RESERVED field.
	I2S_RXRATE_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	I2S_RXRATE_RESERVED_Msk = 0xffff0000

	// TXBITRATE: I2S Transmit bit rate divider. This register determines the I2S transmit bit rate by specifying the value to divide TX_MCLK by in order to produce the transmit bit clock.
	// Position of TX_BITRATE field.
	I2S_TXBITRATE_TX_BITRATE_Pos = 0x0
	// Bit mask of TX_BITRATE field.
	I2S_TXBITRATE_TX_BITRATE_Msk = 0x3f
	// Position of RESERVED field.
	I2S_TXBITRATE_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	I2S_TXBITRATE_RESERVED_Msk = 0xffffffc0

	// RXBITRATE: I2S Receive bit rate divider. This register determines the I2S receive bit rate by specifying the value to divide RX_MCLK by in order to produce the receive bit clock.
	// Position of RX_BITRATE field.
	I2S_RXBITRATE_RX_BITRATE_Pos = 0x0
	// Bit mask of RX_BITRATE field.
	I2S_RXBITRATE_RX_BITRATE_Msk = 0x3f
	// Position of RESERVED field.
	I2S_RXBITRATE_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	I2S_RXBITRATE_RESERVED_Msk = 0xffffffc0

	// TXMODE: I2S Transmit mode control.
	// Position of TXCLKSEL field.
	I2S_TXMODE_TXCLKSEL_Pos = 0x0
	// Bit mask of TXCLKSEL field.
	I2S_TXMODE_TXCLKSEL_Msk = 0x3
	// Select the TX fractional rate divider clock output as the source
	I2S_TXMODE_TXCLKSEL_SELECT_THE_TX_FRACTI = 0x0
	// Select the RX_MCLK signal as the TX_MCLK clock source
	I2S_TXMODE_TXCLKSEL_SELECT_THE_RX_MCLK_S = 0x2
	// Position of TX4PIN field.
	I2S_TXMODE_TX4PIN_Pos = 0x2
	// Bit mask of TX4PIN field.
	I2S_TXMODE_TX4PIN_Msk = 0x4
	// Bit TX4PIN.
	I2S_TXMODE_TX4PIN = 0x4
	// Position of TXMCENA field.
	I2S_TXMODE_TXMCENA_Pos = 0x3
	// Bit mask of TXMCENA field.
	I2S_TXMODE_TXMCENA_Msk = 0x8
	// Bit TXMCENA.
	I2S_TXMODE_TXMCENA = 0x8
	// Position of RESERVED field.
	I2S_TXMODE_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	I2S_TXMODE_RESERVED_Msk = 0xfffffff0

	// RXMODE: I2S Receive mode control.
	// Position of RXCLKSEL field.
	I2S_RXMODE_RXCLKSEL_Pos = 0x0
	// Bit mask of RXCLKSEL field.
	I2S_RXMODE_RXCLKSEL_Msk = 0x3
	// Select the RX fractional rate divider clock output as the source
	I2S_RXMODE_RXCLKSEL_SELECT_THE_RX_FRACTI = 0x0
	// Select the TX_MCLK signal as the RX_MCLK clock source
	I2S_RXMODE_RXCLKSEL_SELECT_THE_TX_MCLK_S = 0x2
	// Position of RX4PIN field.
	I2S_RXMODE_RX4PIN_Pos = 0x2
	// Bit mask of RX4PIN field.
	I2S_RXMODE_RX4PIN_Msk = 0x4
	// Bit RX4PIN.
	I2S_RXMODE_RX4PIN = 0x4
	// Position of RXMCENA field.
	I2S_RXMODE_RXMCENA_Pos = 0x3
	// Bit mask of RXMCENA field.
	I2S_RXMODE_RXMCENA_Msk = 0x8
	// Bit RXMCENA.
	I2S_RXMODE_RXMCENA = 0x8
	// Position of RESERVED field.
	I2S_RXMODE_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	I2S_RXMODE_RESERVED_Msk = 0xfffffff0
)

// Constants for MCPWM: Motor Control PWM
const (
	// CON: PWM Control read address
	// Position of RUN0 field.
	MCPWM_CON_RUN0_Pos = 0x0
	// Bit mask of RUN0 field.
	MCPWM_CON_RUN0_Msk = 0x1
	// Bit RUN0.
	MCPWM_CON_RUN0 = 0x1
	// Stop.
	MCPWM_CON_RUN0_STOP_ = 0x0
	// Run.
	MCPWM_CON_RUN0_RUN_ = 0x1
	// Position of CENTER0 field.
	MCPWM_CON_CENTER0_Pos = 0x1
	// Bit mask of CENTER0 field.
	MCPWM_CON_CENTER0_Msk = 0x2
	// Bit CENTER0.
	MCPWM_CON_CENTER0 = 0x2
	// Edge-aligned.
	MCPWM_CON_CENTER0_EDGE_ALIGNED_ = 0x0
	// Center-aligned.
	MCPWM_CON_CENTER0_CENTER_ALIGNED_ = 0x1
	// Position of POLA0 field.
	MCPWM_CON_POLA0_Pos = 0x2
	// Bit mask of POLA0 field.
	MCPWM_CON_POLA0_Msk = 0x4
	// Bit POLA0.
	MCPWM_CON_POLA0 = 0x4
	// Passive state is LOW, active state is HIGH.
	MCPWM_CON_POLA0_PASSIVE_STATE_IS_LOW = 0x0
	// Passive state is HIGH, active state is LOW.
	MCPWM_CON_POLA0_PASSIVE_STATE_IS_HIG = 0x1
	// Position of DTE0 field.
	MCPWM_CON_DTE0_Pos = 0x3
	// Bit mask of DTE0 field.
	MCPWM_CON_DTE0_Msk = 0x8
	// Bit DTE0.
	MCPWM_CON_DTE0 = 0x8
	// Dead-time disabled.
	MCPWM_CON_DTE0_DEAD_TIME_DISABLED_ = 0x0
	// Dead-time enabled.
	MCPWM_CON_DTE0_DEAD_TIME_ENABLED_ = 0x1
	// Position of DISUP0 field.
	MCPWM_CON_DISUP0_Pos = 0x4
	// Bit mask of DISUP0 field.
	MCPWM_CON_DISUP0_Msk = 0x10
	// Bit DISUP0.
	MCPWM_CON_DISUP0 = 0x10
	// Functional registers are updated from the write registers at the end of each PWM cycle.
	MCPWM_CON_DISUP0_UPDATE = 0x0
	// Functional registers remain the same as long as the timer is running.
	MCPWM_CON_DISUP0_NOUPDATE = 0x1
	// Position of RESERVED field.
	MCPWM_CON_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	MCPWM_CON_RESERVED_Msk = 0xe0
	// Position of RUN1 field.
	MCPWM_CON_RUN1_Pos = 0x8
	// Bit mask of RUN1 field.
	MCPWM_CON_RUN1_Msk = 0x100
	// Bit RUN1.
	MCPWM_CON_RUN1 = 0x100
	// Stop.
	MCPWM_CON_RUN1_STOP_ = 0x0
	// Run.
	MCPWM_CON_RUN1_RUN_ = 0x1
	// Position of CENTER1 field.
	MCPWM_CON_CENTER1_Pos = 0x9
	// Bit mask of CENTER1 field.
	MCPWM_CON_CENTER1_Msk = 0x200
	// Bit CENTER1.
	MCPWM_CON_CENTER1 = 0x200
	// Edge-aligned.
	MCPWM_CON_CENTER1_EDGE_ALIGNED_ = 0x0
	// Center-aligned.
	MCPWM_CON_CENTER1_CENTER_ALIGNED_ = 0x1
	// Position of POLA1 field.
	MCPWM_CON_POLA1_Pos = 0xa
	// Bit mask of POLA1 field.
	MCPWM_CON_POLA1_Msk = 0x400
	// Bit POLA1.
	MCPWM_CON_POLA1 = 0x400
	// Passive state is LOW, active state is HIGH.
	MCPWM_CON_POLA1_PASSIVE_STATE_IS_LOW = 0x0
	// Passive state is HIGH, active state is LOW.
	MCPWM_CON_POLA1_PASSIVE_STATE_IS_HIG = 0x1
	// Position of DTE1 field.
	MCPWM_CON_DTE1_Pos = 0xb
	// Bit mask of DTE1 field.
	MCPWM_CON_DTE1_Msk = 0x800
	// Bit DTE1.
	MCPWM_CON_DTE1 = 0x800
	// Dead-time disabled.
	MCPWM_CON_DTE1_DEAD_TIME_DISABLED_ = 0x0
	// Dead-time enabled.
	MCPWM_CON_DTE1_DEAD_TIME_ENABLED_ = 0x1
	// Position of DISUP1 field.
	MCPWM_CON_DISUP1_Pos = 0xc
	// Bit mask of DISUP1 field.
	MCPWM_CON_DISUP1_Msk = 0x1000
	// Bit DISUP1.
	MCPWM_CON_DISUP1 = 0x1000
	// Functional registers are updated from the write registers at the end of each PWM cycle.
	MCPWM_CON_DISUP1_UPDATE = 0x0
	// Functional registers remain the same as long as the timer is running.
	MCPWM_CON_DISUP1_NOUPDATE = 0x1
	// Position of RESERVED field.
	MCPWM_CON_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	MCPWM_CON_RESERVED_Msk = 0xe000
	// Position of RUN2 field.
	MCPWM_CON_RUN2_Pos = 0x10
	// Bit mask of RUN2 field.
	MCPWM_CON_RUN2_Msk = 0x10000
	// Bit RUN2.
	MCPWM_CON_RUN2 = 0x10000
	// Stop.
	MCPWM_CON_RUN2_STOP_ = 0x0
	// Run.
	MCPWM_CON_RUN2_RUN_ = 0x1
	// Position of CENTER2 field.
	MCPWM_CON_CENTER2_Pos = 0x11
	// Bit mask of CENTER2 field.
	MCPWM_CON_CENTER2_Msk = 0x20000
	// Bit CENTER2.
	MCPWM_CON_CENTER2 = 0x20000
	// Edge-aligned.
	MCPWM_CON_CENTER2_EDGE_ALIGNED_ = 0x0
	// Center-aligned.
	MCPWM_CON_CENTER2_CENTER_ALIGNED_ = 0x1
	// Position of POLA2 field.
	MCPWM_CON_POLA2_Pos = 0x12
	// Bit mask of POLA2 field.
	MCPWM_CON_POLA2_Msk = 0x40000
	// Bit POLA2.
	MCPWM_CON_POLA2 = 0x40000
	// Passive state is LOW, active state is HIGH.
	MCPWM_CON_POLA2_PASSIVE_STATE_IS_LOW = 0x0
	// Passive state is HIGH, active state is LOW.
	MCPWM_CON_POLA2_PASSIVE_STATE_IS_HIG = 0x1
	// Position of DTE2 field.
	MCPWM_CON_DTE2_Pos = 0x13
	// Bit mask of DTE2 field.
	MCPWM_CON_DTE2_Msk = 0x80000
	// Bit DTE2.
	MCPWM_CON_DTE2 = 0x80000
	// Dead-time disabled.
	MCPWM_CON_DTE2_DEAD_TIME_DISABLED_ = 0x0
	// Dead-time enabled.
	MCPWM_CON_DTE2_DEAD_TIME_ENABLED_ = 0x1
	// Position of DISUP2 field.
	MCPWM_CON_DISUP2_Pos = 0x14
	// Bit mask of DISUP2 field.
	MCPWM_CON_DISUP2_Msk = 0x100000
	// Bit DISUP2.
	MCPWM_CON_DISUP2 = 0x100000
	// Functional registers are updated from the write registers at the end of each PWM cycle.
	MCPWM_CON_DISUP2_UPDATE = 0x0
	// Functional registers remain the same as long as the timer is running.
	MCPWM_CON_DISUP2_NOUPDATE = 0x1
	// Position of RESERVED field.
	MCPWM_CON_RESERVED_Pos = 0x15
	// Bit mask of RESERVED field.
	MCPWM_CON_RESERVED_Msk = 0x1fe00000
	// Position of INVBDC field.
	MCPWM_CON_INVBDC_Pos = 0x1d
	// Bit mask of INVBDC field.
	MCPWM_CON_INVBDC_Msk = 0x20000000
	// Bit INVBDC.
	MCPWM_CON_INVBDC = 0x20000000
	// The MCOB outputs have opposite polarity from the MCOA outputs (aside from dead time).
	MCPWM_CON_INVBDC_OPPOSITE = 0x0
	// The MCOB outputs have the same basic polarity as the MCOA outputs. (see Section 24.8.6)
	MCPWM_CON_INVBDC_SAME = 0x1
	// Position of ACMODE field.
	MCPWM_CON_ACMODE_Pos = 0x1e
	// Bit mask of ACMODE field.
	MCPWM_CON_ACMODE_Msk = 0x40000000
	// Bit ACMODE.
	MCPWM_CON_ACMODE = 0x40000000
	// 3-phase AC-mode off: Each PWM channel uses its own timer-counter and period register.
	MCPWM_CON_ACMODE_3_PHASE_AC_MODE_OFF = 0x0
	// 3-phase AC-mode on: All PWM channels use the timer-counter and period register of channel 0.
	MCPWM_CON_ACMODE_3_PHASE_AC_MODE_ON_ = 0x1
	// Position of DCMODE field.
	MCPWM_CON_DCMODE_Pos = 0x1f
	// Bit mask of DCMODE field.
	MCPWM_CON_DCMODE_Msk = 0x80000000
	// Bit DCMODE.
	MCPWM_CON_DCMODE = 0x80000000
	// 3-phase DC mode off: PWM channels are independent (unless bit ACMODE = 1)
	MCPWM_CON_DCMODE_3_PHASE_DC_MODE_OFF = 0x0
	// 3-phase DC mode on: The internal MCOA0 output is routed through the CP register (i.e. a mask) register to all six PWM outputs.
	MCPWM_CON_DCMODE_3_PHASE_DC_MODE_ON_ = 0x1

	// CON_SET: PWM Control set address
	// Position of RUN0_SET field.
	MCPWM_CON_SET_RUN0_SET_Pos = 0x0
	// Bit mask of RUN0_SET field.
	MCPWM_CON_SET_RUN0_SET_Msk = 0x1
	// Bit RUN0_SET.
	MCPWM_CON_SET_RUN0_SET = 0x1
	// Position of CENTER0_SET field.
	MCPWM_CON_SET_CENTER0_SET_Pos = 0x1
	// Bit mask of CENTER0_SET field.
	MCPWM_CON_SET_CENTER0_SET_Msk = 0x2
	// Bit CENTER0_SET.
	MCPWM_CON_SET_CENTER0_SET = 0x2
	// Position of POLA0_SET field.
	MCPWM_CON_SET_POLA0_SET_Pos = 0x2
	// Bit mask of POLA0_SET field.
	MCPWM_CON_SET_POLA0_SET_Msk = 0x4
	// Bit POLA0_SET.
	MCPWM_CON_SET_POLA0_SET = 0x4
	// Position of DTE0_SET field.
	MCPWM_CON_SET_DTE0_SET_Pos = 0x3
	// Bit mask of DTE0_SET field.
	MCPWM_CON_SET_DTE0_SET_Msk = 0x8
	// Bit DTE0_SET.
	MCPWM_CON_SET_DTE0_SET = 0x8
	// Position of DISUP0_SET field.
	MCPWM_CON_SET_DISUP0_SET_Pos = 0x4
	// Bit mask of DISUP0_SET field.
	MCPWM_CON_SET_DISUP0_SET_Msk = 0x10
	// Bit DISUP0_SET.
	MCPWM_CON_SET_DISUP0_SET = 0x10
	// Position of RESERVED field.
	MCPWM_CON_SET_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	MCPWM_CON_SET_RESERVED_Msk = 0xe0
	// Position of RUN1_SET field.
	MCPWM_CON_SET_RUN1_SET_Pos = 0x8
	// Bit mask of RUN1_SET field.
	MCPWM_CON_SET_RUN1_SET_Msk = 0x100
	// Bit RUN1_SET.
	MCPWM_CON_SET_RUN1_SET = 0x100
	// Position of CENTER1_SET field.
	MCPWM_CON_SET_CENTER1_SET_Pos = 0x9
	// Bit mask of CENTER1_SET field.
	MCPWM_CON_SET_CENTER1_SET_Msk = 0x200
	// Bit CENTER1_SET.
	MCPWM_CON_SET_CENTER1_SET = 0x200
	// Position of POLA1_SET field.
	MCPWM_CON_SET_POLA1_SET_Pos = 0xa
	// Bit mask of POLA1_SET field.
	MCPWM_CON_SET_POLA1_SET_Msk = 0x400
	// Bit POLA1_SET.
	MCPWM_CON_SET_POLA1_SET = 0x400
	// Position of DTE1_SET field.
	MCPWM_CON_SET_DTE1_SET_Pos = 0xb
	// Bit mask of DTE1_SET field.
	MCPWM_CON_SET_DTE1_SET_Msk = 0x800
	// Bit DTE1_SET.
	MCPWM_CON_SET_DTE1_SET = 0x800
	// Position of DISUP1_SET field.
	MCPWM_CON_SET_DISUP1_SET_Pos = 0xc
	// Bit mask of DISUP1_SET field.
	MCPWM_CON_SET_DISUP1_SET_Msk = 0x1000
	// Bit DISUP1_SET.
	MCPWM_CON_SET_DISUP1_SET = 0x1000
	// Position of RESERVED field.
	MCPWM_CON_SET_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	MCPWM_CON_SET_RESERVED_Msk = 0xe000
	// Position of RUN2_SET field.
	MCPWM_CON_SET_RUN2_SET_Pos = 0x10
	// Bit mask of RUN2_SET field.
	MCPWM_CON_SET_RUN2_SET_Msk = 0x10000
	// Bit RUN2_SET.
	MCPWM_CON_SET_RUN2_SET = 0x10000
	// Position of CENTER2_SET field.
	MCPWM_CON_SET_CENTER2_SET_Pos = 0x11
	// Bit mask of CENTER2_SET field.
	MCPWM_CON_SET_CENTER2_SET_Msk = 0x20000
	// Bit CENTER2_SET.
	MCPWM_CON_SET_CENTER2_SET = 0x20000
	// Position of POLA2_SET field.
	MCPWM_CON_SET_POLA2_SET_Pos = 0x12
	// Bit mask of POLA2_SET field.
	MCPWM_CON_SET_POLA2_SET_Msk = 0x40000
	// Bit POLA2_SET.
	MCPWM_CON_SET_POLA2_SET = 0x40000
	// Position of DTE2_SET field.
	MCPWM_CON_SET_DTE2_SET_Pos = 0x13
	// Bit mask of DTE2_SET field.
	MCPWM_CON_SET_DTE2_SET_Msk = 0x80000
	// Bit DTE2_SET.
	MCPWM_CON_SET_DTE2_SET = 0x80000
	// Position of DISUP2_SET field.
	MCPWM_CON_SET_DISUP2_SET_Pos = 0x14
	// Bit mask of DISUP2_SET field.
	MCPWM_CON_SET_DISUP2_SET_Msk = 0x100000
	// Bit DISUP2_SET.
	MCPWM_CON_SET_DISUP2_SET = 0x100000
	// Position of RESERVED field.
	MCPWM_CON_SET_RESERVED_Pos = 0x15
	// Bit mask of RESERVED field.
	MCPWM_CON_SET_RESERVED_Msk = 0x1fe00000
	// Position of INVBDC_SET field.
	MCPWM_CON_SET_INVBDC_SET_Pos = 0x1d
	// Bit mask of INVBDC_SET field.
	MCPWM_CON_SET_INVBDC_SET_Msk = 0x20000000
	// Bit INVBDC_SET.
	MCPWM_CON_SET_INVBDC_SET = 0x20000000
	// Position of ACMODE_SET field.
	MCPWM_CON_SET_ACMODE_SET_Pos = 0x1e
	// Bit mask of ACMODE_SET field.
	MCPWM_CON_SET_ACMODE_SET_Msk = 0x40000000
	// Bit ACMODE_SET.
	MCPWM_CON_SET_ACMODE_SET = 0x40000000
	// Position of DCMODE_SET field.
	MCPWM_CON_SET_DCMODE_SET_Pos = 0x1f
	// Bit mask of DCMODE_SET field.
	MCPWM_CON_SET_DCMODE_SET_Msk = 0x80000000
	// Bit DCMODE_SET.
	MCPWM_CON_SET_DCMODE_SET = 0x80000000

	// CON_CLR: PWM Control clear address
	// Position of RUN0_CLR field.
	MCPWM_CON_CLR_RUN0_CLR_Pos = 0x0
	// Bit mask of RUN0_CLR field.
	MCPWM_CON_CLR_RUN0_CLR_Msk = 0x1
	// Bit RUN0_CLR.
	MCPWM_CON_CLR_RUN0_CLR = 0x1
	// Position of CENTER0_CLR field.
	MCPWM_CON_CLR_CENTER0_CLR_Pos = 0x1
	// Bit mask of CENTER0_CLR field.
	MCPWM_CON_CLR_CENTER0_CLR_Msk = 0x2
	// Bit CENTER0_CLR.
	MCPWM_CON_CLR_CENTER0_CLR = 0x2
	// Position of POLA0_CLR field.
	MCPWM_CON_CLR_POLA0_CLR_Pos = 0x2
	// Bit mask of POLA0_CLR field.
	MCPWM_CON_CLR_POLA0_CLR_Msk = 0x4
	// Bit POLA0_CLR.
	MCPWM_CON_CLR_POLA0_CLR = 0x4
	// Position of DTE0_CLR field.
	MCPWM_CON_CLR_DTE0_CLR_Pos = 0x3
	// Bit mask of DTE0_CLR field.
	MCPWM_CON_CLR_DTE0_CLR_Msk = 0x8
	// Bit DTE0_CLR.
	MCPWM_CON_CLR_DTE0_CLR = 0x8
	// Position of DISUP0_CLR field.
	MCPWM_CON_CLR_DISUP0_CLR_Pos = 0x4
	// Bit mask of DISUP0_CLR field.
	MCPWM_CON_CLR_DISUP0_CLR_Msk = 0x10
	// Bit DISUP0_CLR.
	MCPWM_CON_CLR_DISUP0_CLR = 0x10
	// Position of RESERVED field.
	MCPWM_CON_CLR_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	MCPWM_CON_CLR_RESERVED_Msk = 0xe0
	// Position of RUN1_CLR field.
	MCPWM_CON_CLR_RUN1_CLR_Pos = 0x8
	// Bit mask of RUN1_CLR field.
	MCPWM_CON_CLR_RUN1_CLR_Msk = 0x100
	// Bit RUN1_CLR.
	MCPWM_CON_CLR_RUN1_CLR = 0x100
	// Position of CENTER1_CLR field.
	MCPWM_CON_CLR_CENTER1_CLR_Pos = 0x9
	// Bit mask of CENTER1_CLR field.
	MCPWM_CON_CLR_CENTER1_CLR_Msk = 0x200
	// Bit CENTER1_CLR.
	MCPWM_CON_CLR_CENTER1_CLR = 0x200
	// Position of POLA1_CLR field.
	MCPWM_CON_CLR_POLA1_CLR_Pos = 0xa
	// Bit mask of POLA1_CLR field.
	MCPWM_CON_CLR_POLA1_CLR_Msk = 0x400
	// Bit POLA1_CLR.
	MCPWM_CON_CLR_POLA1_CLR = 0x400
	// Position of DTE1_CLR field.
	MCPWM_CON_CLR_DTE1_CLR_Pos = 0xb
	// Bit mask of DTE1_CLR field.
	MCPWM_CON_CLR_DTE1_CLR_Msk = 0x800
	// Bit DTE1_CLR.
	MCPWM_CON_CLR_DTE1_CLR = 0x800
	// Position of DISUP1_CLR field.
	MCPWM_CON_CLR_DISUP1_CLR_Pos = 0xc
	// Bit mask of DISUP1_CLR field.
	MCPWM_CON_CLR_DISUP1_CLR_Msk = 0x1000
	// Bit DISUP1_CLR.
	MCPWM_CON_CLR_DISUP1_CLR = 0x1000
	// Position of RESERVED field.
	MCPWM_CON_CLR_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	MCPWM_CON_CLR_RESERVED_Msk = 0xe000
	// Position of RUN2_CLR field.
	MCPWM_CON_CLR_RUN2_CLR_Pos = 0x10
	// Bit mask of RUN2_CLR field.
	MCPWM_CON_CLR_RUN2_CLR_Msk = 0x10000
	// Bit RUN2_CLR.
	MCPWM_CON_CLR_RUN2_CLR = 0x10000
	// Position of CENTER2_CLR field.
	MCPWM_CON_CLR_CENTER2_CLR_Pos = 0x11
	// Bit mask of CENTER2_CLR field.
	MCPWM_CON_CLR_CENTER2_CLR_Msk = 0x20000
	// Bit CENTER2_CLR.
	MCPWM_CON_CLR_CENTER2_CLR = 0x20000
	// Position of POLA2_CLR field.
	MCPWM_CON_CLR_POLA2_CLR_Pos = 0x12
	// Bit mask of POLA2_CLR field.
	MCPWM_CON_CLR_POLA2_CLR_Msk = 0x40000
	// Bit POLA2_CLR.
	MCPWM_CON_CLR_POLA2_CLR = 0x40000
	// Position of DTE2_CLR field.
	MCPWM_CON_CLR_DTE2_CLR_Pos = 0x13
	// Bit mask of DTE2_CLR field.
	MCPWM_CON_CLR_DTE2_CLR_Msk = 0x80000
	// Bit DTE2_CLR.
	MCPWM_CON_CLR_DTE2_CLR = 0x80000
	// Position of DISUP2_CLR field.
	MCPWM_CON_CLR_DISUP2_CLR_Pos = 0x14
	// Bit mask of DISUP2_CLR field.
	MCPWM_CON_CLR_DISUP2_CLR_Msk = 0x100000
	// Bit DISUP2_CLR.
	MCPWM_CON_CLR_DISUP2_CLR = 0x100000
	// Position of RESERVED field.
	MCPWM_CON_CLR_RESERVED_Pos = 0x15
	// Bit mask of RESERVED field.
	MCPWM_CON_CLR_RESERVED_Msk = 0x1fe00000
	// Position of INVBDC_CLR field.
	MCPWM_CON_CLR_INVBDC_CLR_Pos = 0x1d
	// Bit mask of INVBDC_CLR field.
	MCPWM_CON_CLR_INVBDC_CLR_Msk = 0x20000000
	// Bit INVBDC_CLR.
	MCPWM_CON_CLR_INVBDC_CLR = 0x20000000
	// Position of ACMOD_CLR field.
	MCPWM_CON_CLR_ACMOD_CLR_Pos = 0x1e
	// Bit mask of ACMOD_CLR field.
	MCPWM_CON_CLR_ACMOD_CLR_Msk = 0x40000000
	// Bit ACMOD_CLR.
	MCPWM_CON_CLR_ACMOD_CLR = 0x40000000
	// Position of DCMODE_CLR field.
	MCPWM_CON_CLR_DCMODE_CLR_Pos = 0x1f
	// Bit mask of DCMODE_CLR field.
	MCPWM_CON_CLR_DCMODE_CLR_Msk = 0x80000000
	// Bit DCMODE_CLR.
	MCPWM_CON_CLR_DCMODE_CLR = 0x80000000

	// CAPCON: Capture Control read address
	// Position of CAP0MCI0_RE field.
	MCPWM_CAPCON_CAP0MCI0_RE_Pos = 0x0
	// Bit mask of CAP0MCI0_RE field.
	MCPWM_CAPCON_CAP0MCI0_RE_Msk = 0x1
	// Bit CAP0MCI0_RE.
	MCPWM_CAPCON_CAP0MCI0_RE = 0x1
	// Position of CAP0MCI0_FE field.
	MCPWM_CAPCON_CAP0MCI0_FE_Pos = 0x1
	// Bit mask of CAP0MCI0_FE field.
	MCPWM_CAPCON_CAP0MCI0_FE_Msk = 0x2
	// Bit CAP0MCI0_FE.
	MCPWM_CAPCON_CAP0MCI0_FE = 0x2
	// Position of CAP0MCI1_RE field.
	MCPWM_CAPCON_CAP0MCI1_RE_Pos = 0x2
	// Bit mask of CAP0MCI1_RE field.
	MCPWM_CAPCON_CAP0MCI1_RE_Msk = 0x4
	// Bit CAP0MCI1_RE.
	MCPWM_CAPCON_CAP0MCI1_RE = 0x4
	// Position of CAP0MCI1_FE field.
	MCPWM_CAPCON_CAP0MCI1_FE_Pos = 0x3
	// Bit mask of CAP0MCI1_FE field.
	MCPWM_CAPCON_CAP0MCI1_FE_Msk = 0x8
	// Bit CAP0MCI1_FE.
	MCPWM_CAPCON_CAP0MCI1_FE = 0x8
	// Position of CAP0MCI2_RE field.
	MCPWM_CAPCON_CAP0MCI2_RE_Pos = 0x4
	// Bit mask of CAP0MCI2_RE field.
	MCPWM_CAPCON_CAP0MCI2_RE_Msk = 0x10
	// Bit CAP0MCI2_RE.
	MCPWM_CAPCON_CAP0MCI2_RE = 0x10
	// Position of CAP0MCI2_FE field.
	MCPWM_CAPCON_CAP0MCI2_FE_Pos = 0x5
	// Bit mask of CAP0MCI2_FE field.
	MCPWM_CAPCON_CAP0MCI2_FE_Msk = 0x20
	// Bit CAP0MCI2_FE.
	MCPWM_CAPCON_CAP0MCI2_FE = 0x20
	// Position of CAP1MCI0_RE field.
	MCPWM_CAPCON_CAP1MCI0_RE_Pos = 0x6
	// Bit mask of CAP1MCI0_RE field.
	MCPWM_CAPCON_CAP1MCI0_RE_Msk = 0x40
	// Bit CAP1MCI0_RE.
	MCPWM_CAPCON_CAP1MCI0_RE = 0x40
	// Position of CAP1MCI0_FE field.
	MCPWM_CAPCON_CAP1MCI0_FE_Pos = 0x7
	// Bit mask of CAP1MCI0_FE field.
	MCPWM_CAPCON_CAP1MCI0_FE_Msk = 0x80
	// Bit CAP1MCI0_FE.
	MCPWM_CAPCON_CAP1MCI0_FE = 0x80
	// Position of CAP1MCI1_RE field.
	MCPWM_CAPCON_CAP1MCI1_RE_Pos = 0x8
	// Bit mask of CAP1MCI1_RE field.
	MCPWM_CAPCON_CAP1MCI1_RE_Msk = 0x100
	// Bit CAP1MCI1_RE.
	MCPWM_CAPCON_CAP1MCI1_RE = 0x100
	// Position of CAP1MCI1_FE field.
	MCPWM_CAPCON_CAP1MCI1_FE_Pos = 0x9
	// Bit mask of CAP1MCI1_FE field.
	MCPWM_CAPCON_CAP1MCI1_FE_Msk = 0x200
	// Bit CAP1MCI1_FE.
	MCPWM_CAPCON_CAP1MCI1_FE = 0x200
	// Position of CAP1MCI2_RE field.
	MCPWM_CAPCON_CAP1MCI2_RE_Pos = 0xa
	// Bit mask of CAP1MCI2_RE field.
	MCPWM_CAPCON_CAP1MCI2_RE_Msk = 0x400
	// Bit CAP1MCI2_RE.
	MCPWM_CAPCON_CAP1MCI2_RE = 0x400
	// Position of CAP1MCI2_FE field.
	MCPWM_CAPCON_CAP1MCI2_FE_Pos = 0xb
	// Bit mask of CAP1MCI2_FE field.
	MCPWM_CAPCON_CAP1MCI2_FE_Msk = 0x800
	// Bit CAP1MCI2_FE.
	MCPWM_CAPCON_CAP1MCI2_FE = 0x800
	// Position of CAP2MCI0_RE field.
	MCPWM_CAPCON_CAP2MCI0_RE_Pos = 0xc
	// Bit mask of CAP2MCI0_RE field.
	MCPWM_CAPCON_CAP2MCI0_RE_Msk = 0x1000
	// Bit CAP2MCI0_RE.
	MCPWM_CAPCON_CAP2MCI0_RE = 0x1000
	// Position of CAP2MCI0_FE field.
	MCPWM_CAPCON_CAP2MCI0_FE_Pos = 0xd
	// Bit mask of CAP2MCI0_FE field.
	MCPWM_CAPCON_CAP2MCI0_FE_Msk = 0x2000
	// Bit CAP2MCI0_FE.
	MCPWM_CAPCON_CAP2MCI0_FE = 0x2000
	// Position of CAP2MCI1_RE field.
	MCPWM_CAPCON_CAP2MCI1_RE_Pos = 0xe
	// Bit mask of CAP2MCI1_RE field.
	MCPWM_CAPCON_CAP2MCI1_RE_Msk = 0x4000
	// Bit CAP2MCI1_RE.
	MCPWM_CAPCON_CAP2MCI1_RE = 0x4000
	// Position of CAP2MCI1_FE field.
	MCPWM_CAPCON_CAP2MCI1_FE_Pos = 0xf
	// Bit mask of CAP2MCI1_FE field.
	MCPWM_CAPCON_CAP2MCI1_FE_Msk = 0x8000
	// Bit CAP2MCI1_FE.
	MCPWM_CAPCON_CAP2MCI1_FE = 0x8000
	// Position of CAP2MCI2_RE field.
	MCPWM_CAPCON_CAP2MCI2_RE_Pos = 0x10
	// Bit mask of CAP2MCI2_RE field.
	MCPWM_CAPCON_CAP2MCI2_RE_Msk = 0x10000
	// Bit CAP2MCI2_RE.
	MCPWM_CAPCON_CAP2MCI2_RE = 0x10000
	// Position of CAP2MCI2_FE field.
	MCPWM_CAPCON_CAP2MCI2_FE_Pos = 0x11
	// Bit mask of CAP2MCI2_FE field.
	MCPWM_CAPCON_CAP2MCI2_FE_Msk = 0x20000
	// Bit CAP2MCI2_FE.
	MCPWM_CAPCON_CAP2MCI2_FE = 0x20000
	// Position of RT0 field.
	MCPWM_CAPCON_RT0_Pos = 0x12
	// Bit mask of RT0 field.
	MCPWM_CAPCON_RT0_Msk = 0x40000
	// Bit RT0.
	MCPWM_CAPCON_RT0 = 0x40000
	// Position of RT1 field.
	MCPWM_CAPCON_RT1_Pos = 0x13
	// Bit mask of RT1 field.
	MCPWM_CAPCON_RT1_Msk = 0x80000
	// Bit RT1.
	MCPWM_CAPCON_RT1 = 0x80000
	// Position of RT2 field.
	MCPWM_CAPCON_RT2_Pos = 0x14
	// Bit mask of RT2 field.
	MCPWM_CAPCON_RT2_Msk = 0x100000
	// Bit RT2.
	MCPWM_CAPCON_RT2 = 0x100000
	// Position of RESERVED field.
	MCPWM_CAPCON_RESERVED_Pos = 0x15
	// Bit mask of RESERVED field.
	MCPWM_CAPCON_RESERVED_Msk = 0xffe00000

	// CAPCON_SET: Capture Control set address
	// Position of CAP0MCI0_RE_SET field.
	MCPWM_CAPCON_SET_CAP0MCI0_RE_SET_Pos = 0x0
	// Bit mask of CAP0MCI0_RE_SET field.
	MCPWM_CAPCON_SET_CAP0MCI0_RE_SET_Msk = 0x1
	// Bit CAP0MCI0_RE_SET.
	MCPWM_CAPCON_SET_CAP0MCI0_RE_SET = 0x1
	// Position of CAP0MCI0_FE_SET field.
	MCPWM_CAPCON_SET_CAP0MCI0_FE_SET_Pos = 0x1
	// Bit mask of CAP0MCI0_FE_SET field.
	MCPWM_CAPCON_SET_CAP0MCI0_FE_SET_Msk = 0x2
	// Bit CAP0MCI0_FE_SET.
	MCPWM_CAPCON_SET_CAP0MCI0_FE_SET = 0x2
	// Position of CAP0MCI1_RE_SET field.
	MCPWM_CAPCON_SET_CAP0MCI1_RE_SET_Pos = 0x2
	// Bit mask of CAP0MCI1_RE_SET field.
	MCPWM_CAPCON_SET_CAP0MCI1_RE_SET_Msk = 0x4
	// Bit CAP0MCI1_RE_SET.
	MCPWM_CAPCON_SET_CAP0MCI1_RE_SET = 0x4
	// Position of CAP0MCI1_FE_SET field.
	MCPWM_CAPCON_SET_CAP0MCI1_FE_SET_Pos = 0x3
	// Bit mask of CAP0MCI1_FE_SET field.
	MCPWM_CAPCON_SET_CAP0MCI1_FE_SET_Msk = 0x8
	// Bit CAP0MCI1_FE_SET.
	MCPWM_CAPCON_SET_CAP0MCI1_FE_SET = 0x8
	// Position of CAP0MCI2_RE_SET field.
	MCPWM_CAPCON_SET_CAP0MCI2_RE_SET_Pos = 0x4
	// Bit mask of CAP0MCI2_RE_SET field.
	MCPWM_CAPCON_SET_CAP0MCI2_RE_SET_Msk = 0x10
	// Bit CAP0MCI2_RE_SET.
	MCPWM_CAPCON_SET_CAP0MCI2_RE_SET = 0x10
	// Position of CAP0MCI2_FE_SET field.
	MCPWM_CAPCON_SET_CAP0MCI2_FE_SET_Pos = 0x5
	// Bit mask of CAP0MCI2_FE_SET field.
	MCPWM_CAPCON_SET_CAP0MCI2_FE_SET_Msk = 0x20
	// Bit CAP0MCI2_FE_SET.
	MCPWM_CAPCON_SET_CAP0MCI2_FE_SET = 0x20
	// Position of CAP1MCI0_RE_SET field.
	MCPWM_CAPCON_SET_CAP1MCI0_RE_SET_Pos = 0x6
	// Bit mask of CAP1MCI0_RE_SET field.
	MCPWM_CAPCON_SET_CAP1MCI0_RE_SET_Msk = 0x40
	// Bit CAP1MCI0_RE_SET.
	MCPWM_CAPCON_SET_CAP1MCI0_RE_SET = 0x40
	// Position of CAP1MCI0_FE_SET field.
	MCPWM_CAPCON_SET_CAP1MCI0_FE_SET_Pos = 0x7
	// Bit mask of CAP1MCI0_FE_SET field.
	MCPWM_CAPCON_SET_CAP1MCI0_FE_SET_Msk = 0x80
	// Bit CAP1MCI0_FE_SET.
	MCPWM_CAPCON_SET_CAP1MCI0_FE_SET = 0x80
	// Position of CAP1MCI1_RE_SET field.
	MCPWM_CAPCON_SET_CAP1MCI1_RE_SET_Pos = 0x8
	// Bit mask of CAP1MCI1_RE_SET field.
	MCPWM_CAPCON_SET_CAP1MCI1_RE_SET_Msk = 0x100
	// Bit CAP1MCI1_RE_SET.
	MCPWM_CAPCON_SET_CAP1MCI1_RE_SET = 0x100
	// Position of CAP1MCI1_FE_SET field.
	MCPWM_CAPCON_SET_CAP1MCI1_FE_SET_Pos = 0x9
	// Bit mask of CAP1MCI1_FE_SET field.
	MCPWM_CAPCON_SET_CAP1MCI1_FE_SET_Msk = 0x200
	// Bit CAP1MCI1_FE_SET.
	MCPWM_CAPCON_SET_CAP1MCI1_FE_SET = 0x200
	// Position of CAP1MCI2_RE_SET field.
	MCPWM_CAPCON_SET_CAP1MCI2_RE_SET_Pos = 0xa
	// Bit mask of CAP1MCI2_RE_SET field.
	MCPWM_CAPCON_SET_CAP1MCI2_RE_SET_Msk = 0x400
	// Bit CAP1MCI2_RE_SET.
	MCPWM_CAPCON_SET_CAP1MCI2_RE_SET = 0x400
	// Position of CAP1MCI2_FE_SET field.
	MCPWM_CAPCON_SET_CAP1MCI2_FE_SET_Pos = 0xb
	// Bit mask of CAP1MCI2_FE_SET field.
	MCPWM_CAPCON_SET_CAP1MCI2_FE_SET_Msk = 0x800
	// Bit CAP1MCI2_FE_SET.
	MCPWM_CAPCON_SET_CAP1MCI2_FE_SET = 0x800
	// Position of CAP2MCI0_RE_SET field.
	MCPWM_CAPCON_SET_CAP2MCI0_RE_SET_Pos = 0xc
	// Bit mask of CAP2MCI0_RE_SET field.
	MCPWM_CAPCON_SET_CAP2MCI0_RE_SET_Msk = 0x1000
	// Bit CAP2MCI0_RE_SET.
	MCPWM_CAPCON_SET_CAP2MCI0_RE_SET = 0x1000
	// Position of CAP2MCI0_FE_SET field.
	MCPWM_CAPCON_SET_CAP2MCI0_FE_SET_Pos = 0xd
	// Bit mask of CAP2MCI0_FE_SET field.
	MCPWM_CAPCON_SET_CAP2MCI0_FE_SET_Msk = 0x2000
	// Bit CAP2MCI0_FE_SET.
	MCPWM_CAPCON_SET_CAP2MCI0_FE_SET = 0x2000
	// Position of CAP2MCI1_RE_SET field.
	MCPWM_CAPCON_SET_CAP2MCI1_RE_SET_Pos = 0xe
	// Bit mask of CAP2MCI1_RE_SET field.
	MCPWM_CAPCON_SET_CAP2MCI1_RE_SET_Msk = 0x4000
	// Bit CAP2MCI1_RE_SET.
	MCPWM_CAPCON_SET_CAP2MCI1_RE_SET = 0x4000
	// Position of CAP2MCI1_FE_SET field.
	MCPWM_CAPCON_SET_CAP2MCI1_FE_SET_Pos = 0xf
	// Bit mask of CAP2MCI1_FE_SET field.
	MCPWM_CAPCON_SET_CAP2MCI1_FE_SET_Msk = 0x8000
	// Bit CAP2MCI1_FE_SET.
	MCPWM_CAPCON_SET_CAP2MCI1_FE_SET = 0x8000
	// Position of CAP2MCI2_RE_SET field.
	MCPWM_CAPCON_SET_CAP2MCI2_RE_SET_Pos = 0x10
	// Bit mask of CAP2MCI2_RE_SET field.
	MCPWM_CAPCON_SET_CAP2MCI2_RE_SET_Msk = 0x10000
	// Bit CAP2MCI2_RE_SET.
	MCPWM_CAPCON_SET_CAP2MCI2_RE_SET = 0x10000
	// Position of CAP2MCI2_FE_SET field.
	MCPWM_CAPCON_SET_CAP2MCI2_FE_SET_Pos = 0x11
	// Bit mask of CAP2MCI2_FE_SET field.
	MCPWM_CAPCON_SET_CAP2MCI2_FE_SET_Msk = 0x20000
	// Bit CAP2MCI2_FE_SET.
	MCPWM_CAPCON_SET_CAP2MCI2_FE_SET = 0x20000
	// Position of RT0_SET field.
	MCPWM_CAPCON_SET_RT0_SET_Pos = 0x12
	// Bit mask of RT0_SET field.
	MCPWM_CAPCON_SET_RT0_SET_Msk = 0x40000
	// Bit RT0_SET.
	MCPWM_CAPCON_SET_RT0_SET = 0x40000
	// Position of RT1_SET field.
	MCPWM_CAPCON_SET_RT1_SET_Pos = 0x13
	// Bit mask of RT1_SET field.
	MCPWM_CAPCON_SET_RT1_SET_Msk = 0x80000
	// Bit RT1_SET.
	MCPWM_CAPCON_SET_RT1_SET = 0x80000
	// Position of RT2_SET field.
	MCPWM_CAPCON_SET_RT2_SET_Pos = 0x14
	// Bit mask of RT2_SET field.
	MCPWM_CAPCON_SET_RT2_SET_Msk = 0x100000
	// Bit RT2_SET.
	MCPWM_CAPCON_SET_RT2_SET = 0x100000
	// Position of RESERVED field.
	MCPWM_CAPCON_SET_RESERVED_Pos = 0x15
	// Bit mask of RESERVED field.
	MCPWM_CAPCON_SET_RESERVED_Msk = 0xffe00000

	// CAPCON_CLR: Event Control clear address
	// Position of CAP0MCI0_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP0MCI0_RE_CLR_Pos = 0x0
	// Bit mask of CAP0MCI0_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP0MCI0_RE_CLR_Msk = 0x1
	// Bit CAP0MCI0_RE_CLR.
	MCPWM_CAPCON_CLR_CAP0MCI0_RE_CLR = 0x1
	// Position of CAP0MCI0_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP0MCI0_FE_CLR_Pos = 0x1
	// Bit mask of CAP0MCI0_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP0MCI0_FE_CLR_Msk = 0x2
	// Bit CAP0MCI0_FE_CLR.
	MCPWM_CAPCON_CLR_CAP0MCI0_FE_CLR = 0x2
	// Position of CAP0MCI1_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP0MCI1_RE_CLR_Pos = 0x2
	// Bit mask of CAP0MCI1_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP0MCI1_RE_CLR_Msk = 0x4
	// Bit CAP0MCI1_RE_CLR.
	MCPWM_CAPCON_CLR_CAP0MCI1_RE_CLR = 0x4
	// Position of CAP0MCI1_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP0MCI1_FE_CLR_Pos = 0x3
	// Bit mask of CAP0MCI1_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP0MCI1_FE_CLR_Msk = 0x8
	// Bit CAP0MCI1_FE_CLR.
	MCPWM_CAPCON_CLR_CAP0MCI1_FE_CLR = 0x8
	// Position of CAP0MCI2_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP0MCI2_RE_CLR_Pos = 0x4
	// Bit mask of CAP0MCI2_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP0MCI2_RE_CLR_Msk = 0x10
	// Bit CAP0MCI2_RE_CLR.
	MCPWM_CAPCON_CLR_CAP0MCI2_RE_CLR = 0x10
	// Position of CAP0MCI2_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP0MCI2_FE_CLR_Pos = 0x5
	// Bit mask of CAP0MCI2_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP0MCI2_FE_CLR_Msk = 0x20
	// Bit CAP0MCI2_FE_CLR.
	MCPWM_CAPCON_CLR_CAP0MCI2_FE_CLR = 0x20
	// Position of CAP1MCI0_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP1MCI0_RE_CLR_Pos = 0x6
	// Bit mask of CAP1MCI0_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP1MCI0_RE_CLR_Msk = 0x40
	// Bit CAP1MCI0_RE_CLR.
	MCPWM_CAPCON_CLR_CAP1MCI0_RE_CLR = 0x40
	// Position of CAP1MCI0_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP1MCI0_FE_CLR_Pos = 0x7
	// Bit mask of CAP1MCI0_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP1MCI0_FE_CLR_Msk = 0x80
	// Bit CAP1MCI0_FE_CLR.
	MCPWM_CAPCON_CLR_CAP1MCI0_FE_CLR = 0x80
	// Position of CAP1MCI1_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP1MCI1_RE_CLR_Pos = 0x8
	// Bit mask of CAP1MCI1_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP1MCI1_RE_CLR_Msk = 0x100
	// Bit CAP1MCI1_RE_CLR.
	MCPWM_CAPCON_CLR_CAP1MCI1_RE_CLR = 0x100
	// Position of CAP1MCI1_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP1MCI1_FE_CLR_Pos = 0x9
	// Bit mask of CAP1MCI1_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP1MCI1_FE_CLR_Msk = 0x200
	// Bit CAP1MCI1_FE_CLR.
	MCPWM_CAPCON_CLR_CAP1MCI1_FE_CLR = 0x200
	// Position of CAP1MCI2_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP1MCI2_RE_CLR_Pos = 0xa
	// Bit mask of CAP1MCI2_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP1MCI2_RE_CLR_Msk = 0x400
	// Bit CAP1MCI2_RE_CLR.
	MCPWM_CAPCON_CLR_CAP1MCI2_RE_CLR = 0x400
	// Position of CAP1MCI2_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP1MCI2_FE_CLR_Pos = 0xb
	// Bit mask of CAP1MCI2_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP1MCI2_FE_CLR_Msk = 0x800
	// Bit CAP1MCI2_FE_CLR.
	MCPWM_CAPCON_CLR_CAP1MCI2_FE_CLR = 0x800
	// Position of CAP2MCI0_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP2MCI0_RE_CLR_Pos = 0xc
	// Bit mask of CAP2MCI0_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP2MCI0_RE_CLR_Msk = 0x1000
	// Bit CAP2MCI0_RE_CLR.
	MCPWM_CAPCON_CLR_CAP2MCI0_RE_CLR = 0x1000
	// Position of CAP2MCI0_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP2MCI0_FE_CLR_Pos = 0xd
	// Bit mask of CAP2MCI0_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP2MCI0_FE_CLR_Msk = 0x2000
	// Bit CAP2MCI0_FE_CLR.
	MCPWM_CAPCON_CLR_CAP2MCI0_FE_CLR = 0x2000
	// Position of CAP2MCI1_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP2MCI1_RE_CLR_Pos = 0xe
	// Bit mask of CAP2MCI1_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP2MCI1_RE_CLR_Msk = 0x4000
	// Bit CAP2MCI1_RE_CLR.
	MCPWM_CAPCON_CLR_CAP2MCI1_RE_CLR = 0x4000
	// Position of CAP2MCI1_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP2MCI1_FE_CLR_Pos = 0xf
	// Bit mask of CAP2MCI1_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP2MCI1_FE_CLR_Msk = 0x8000
	// Bit CAP2MCI1_FE_CLR.
	MCPWM_CAPCON_CLR_CAP2MCI1_FE_CLR = 0x8000
	// Position of CAP2MCI2_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP2MCI2_RE_CLR_Pos = 0x10
	// Bit mask of CAP2MCI2_RE_CLR field.
	MCPWM_CAPCON_CLR_CAP2MCI2_RE_CLR_Msk = 0x10000
	// Bit CAP2MCI2_RE_CLR.
	MCPWM_CAPCON_CLR_CAP2MCI2_RE_CLR = 0x10000
	// Position of CAP2MCI2_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP2MCI2_FE_CLR_Pos = 0x11
	// Bit mask of CAP2MCI2_FE_CLR field.
	MCPWM_CAPCON_CLR_CAP2MCI2_FE_CLR_Msk = 0x20000
	// Bit CAP2MCI2_FE_CLR.
	MCPWM_CAPCON_CLR_CAP2MCI2_FE_CLR = 0x20000
	// Position of RT0_CLR field.
	MCPWM_CAPCON_CLR_RT0_CLR_Pos = 0x12
	// Bit mask of RT0_CLR field.
	MCPWM_CAPCON_CLR_RT0_CLR_Msk = 0x40000
	// Bit RT0_CLR.
	MCPWM_CAPCON_CLR_RT0_CLR = 0x40000
	// Position of RT1_CLR field.
	MCPWM_CAPCON_CLR_RT1_CLR_Pos = 0x13
	// Bit mask of RT1_CLR field.
	MCPWM_CAPCON_CLR_RT1_CLR_Msk = 0x80000
	// Bit RT1_CLR.
	MCPWM_CAPCON_CLR_RT1_CLR = 0x80000
	// Position of RT2_CLR field.
	MCPWM_CAPCON_CLR_RT2_CLR_Pos = 0x14
	// Bit mask of RT2_CLR field.
	MCPWM_CAPCON_CLR_RT2_CLR_Msk = 0x100000
	// Bit RT2_CLR.
	MCPWM_CAPCON_CLR_RT2_CLR = 0x100000
	// Position of RESERVED field.
	MCPWM_CAPCON_CLR_RESERVED_Pos = 0x15
	// Bit mask of RESERVED field.
	MCPWM_CAPCON_CLR_RESERVED_Msk = 0xffe00000

	// TC: Timer Counter register
	// Position of MCTC field.
	MCPWM_TC_MCTC_Pos = 0x0
	// Bit mask of MCTC field.
	MCPWM_TC_MCTC_Msk = 0xffffffff

	// LIM: Limit register
	// Position of MCLIM field.
	MCPWM_LIM_MCLIM_Pos = 0x0
	// Bit mask of MCLIM field.
	MCPWM_LIM_MCLIM_Msk = 0xffffffff

	// MAT: Match register
	// Position of MCMAT field.
	MCPWM_MAT_MCMAT_Pos = 0x0
	// Bit mask of MCMAT field.
	MCPWM_MAT_MCMAT_Msk = 0xffffffff

	// DT: Dead time register
	// Position of DT0 field.
	MCPWM_DT_DT0_Pos = 0x0
	// Bit mask of DT0 field.
	MCPWM_DT_DT0_Msk = 0x3ff
	// Position of DT1 field.
	MCPWM_DT_DT1_Pos = 0xa
	// Bit mask of DT1 field.
	MCPWM_DT_DT1_Msk = 0xffc00
	// Position of DT2 field.
	MCPWM_DT_DT2_Pos = 0x14
	// Bit mask of DT2 field.
	MCPWM_DT_DT2_Msk = 0x3ff00000
	// Position of RESERVED field.
	MCPWM_DT_RESERVED_Pos = 0x1e
	// Bit mask of RESERVED field.
	MCPWM_DT_RESERVED_Msk = 0xc0000000

	// CCP: Communication Pattern register
	// Position of CCPA0 field.
	MCPWM_CCP_CCPA0_Pos = 0x0
	// Bit mask of CCPA0 field.
	MCPWM_CCP_CCPA0_Msk = 0x1
	// Bit CCPA0.
	MCPWM_CCP_CCPA0 = 0x1
	// MCOA0 passive.
	MCPWM_CCP_CCPA0_MCOA0_PASSIVE_ = 0x0
	// internal MCOA0.
	MCPWM_CCP_CCPA0_INTERNAL_MCOA0_ = 0x1
	// Position of CCPB0 field.
	MCPWM_CCP_CCPB0_Pos = 0x1
	// Bit mask of CCPB0 field.
	MCPWM_CCP_CCPB0_Msk = 0x2
	// Bit CCPB0.
	MCPWM_CCP_CCPB0 = 0x2
	// MCOB0 passive.
	MCPWM_CCP_CCPB0_MCOB0_PASSIVE_ = 0x0
	// MCOB0 tracks internal MCOA0.
	MCPWM_CCP_CCPB0_MCOB0_TRACKS_INTERNA = 0x1
	// Position of CCPA1 field.
	MCPWM_CCP_CCPA1_Pos = 0x2
	// Bit mask of CCPA1 field.
	MCPWM_CCP_CCPA1_Msk = 0x4
	// Bit CCPA1.
	MCPWM_CCP_CCPA1 = 0x4
	// MCOA1 passive.
	MCPWM_CCP_CCPA1_MCOA1_PASSIVE_ = 0x0
	// MCOA1 tracks internal MCOA0.
	MCPWM_CCP_CCPA1_MCOA1_TRACKS_INTERNA = 0x1
	// Position of CCPB1 field.
	MCPWM_CCP_CCPB1_Pos = 0x3
	// Bit mask of CCPB1 field.
	MCPWM_CCP_CCPB1_Msk = 0x8
	// Bit CCPB1.
	MCPWM_CCP_CCPB1 = 0x8
	// MCOB1 passive.
	MCPWM_CCP_CCPB1_MCOB1_PASSIVE_ = 0x0
	// MCOB1 tracks internal MCOA0.
	MCPWM_CCP_CCPB1_MCOB1_TRACKS_INTERNA = 0x1
	// Position of CCPA2 field.
	MCPWM_CCP_CCPA2_Pos = 0x4
	// Bit mask of CCPA2 field.
	MCPWM_CCP_CCPA2_Msk = 0x10
	// Bit CCPA2.
	MCPWM_CCP_CCPA2 = 0x10
	// MCOA2 passive.
	MCPWM_CCP_CCPA2_MCOA2_PASSIVE_ = 0x0
	// MCOA2 tracks internal MCOA0.
	MCPWM_CCP_CCPA2_MCOA2_TRACKS_INTERNA = 0x1
	// Position of CCPB2 field.
	MCPWM_CCP_CCPB2_Pos = 0x5
	// Bit mask of CCPB2 field.
	MCPWM_CCP_CCPB2_Msk = 0x20
	// Bit CCPB2.
	MCPWM_CCP_CCPB2 = 0x20
	// MCOB2 passive.
	MCPWM_CCP_CCPB2_MCOB2_PASSIVE_ = 0x0
	// MCOB2 tracks internal MCOA0.
	MCPWM_CCP_CCPB2_MCOB2_TRACKS_INTERNA = 0x1
	// Position of RESERVED field.
	MCPWM_CCP_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	MCPWM_CCP_RESERVED_Msk = 0xffffffc0

	// CAP: Capture register
	// Position of CAP field.
	MCPWM_CAP_CAP_Pos = 0x0
	// Bit mask of CAP field.
	MCPWM_CAP_CAP_Msk = 0xffffffff

	// INTEN: Interrupt Enable read address
	// Position of ILIM0 field.
	MCPWM_INTEN_ILIM0_Pos = 0x0
	// Bit mask of ILIM0 field.
	MCPWM_INTEN_ILIM0_Msk = 0x1
	// Bit ILIM0.
	MCPWM_INTEN_ILIM0 = 0x1
	// Interrupt disabled.
	MCPWM_INTEN_ILIM0_INTERRUPT_DISABLED_ = 0x0
	// Interrupt enabled.
	MCPWM_INTEN_ILIM0_INTERRUPT_ENABLED_ = 0x1
	// Position of IMAT0 field.
	MCPWM_INTEN_IMAT0_Pos = 0x1
	// Bit mask of IMAT0 field.
	MCPWM_INTEN_IMAT0_Msk = 0x2
	// Bit IMAT0.
	MCPWM_INTEN_IMAT0 = 0x2
	// Interrupt disabled.
	MCPWM_INTEN_IMAT0_INTERRUPT_DISABLED_ = 0x0
	// Interrupt enabled.
	MCPWM_INTEN_IMAT0_INTERRUPT_ENABLED_ = 0x1
	// Position of ICAP0 field.
	MCPWM_INTEN_ICAP0_Pos = 0x2
	// Bit mask of ICAP0 field.
	MCPWM_INTEN_ICAP0_Msk = 0x4
	// Bit ICAP0.
	MCPWM_INTEN_ICAP0 = 0x4
	// Interrupt disabled.
	MCPWM_INTEN_ICAP0_INTERRUPT_DISABLED_ = 0x0
	// Interrupt enabled.
	MCPWM_INTEN_ICAP0_INTERRUPT_ENABLED_ = 0x1
	// Position of RESERVED field.
	MCPWM_INTEN_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	MCPWM_INTEN_RESERVED_Msk = 0x8
	// Bit RESERVED.
	MCPWM_INTEN_RESERVED = 0x8
	// Position of ILIM1 field.
	MCPWM_INTEN_ILIM1_Pos = 0x4
	// Bit mask of ILIM1 field.
	MCPWM_INTEN_ILIM1_Msk = 0x10
	// Bit ILIM1.
	MCPWM_INTEN_ILIM1 = 0x10
	// Interrupt disabled.
	MCPWM_INTEN_ILIM1_INTERRUPT_DISABLED_ = 0x0
	// Interrupt enabled.
	MCPWM_INTEN_ILIM1_INTERRUPT_ENABLED_ = 0x1
	// Position of IMAT1 field.
	MCPWM_INTEN_IMAT1_Pos = 0x5
	// Bit mask of IMAT1 field.
	MCPWM_INTEN_IMAT1_Msk = 0x20
	// Bit IMAT1.
	MCPWM_INTEN_IMAT1 = 0x20
	// Interrupt disabled.
	MCPWM_INTEN_IMAT1_INTERRUPT_DISABLED_ = 0x0
	// Interrupt enabled.
	MCPWM_INTEN_IMAT1_INTERRUPT_ENABLED_ = 0x1
	// Position of ICAP1 field.
	MCPWM_INTEN_ICAP1_Pos = 0x6
	// Bit mask of ICAP1 field.
	MCPWM_INTEN_ICAP1_Msk = 0x40
	// Bit ICAP1.
	MCPWM_INTEN_ICAP1 = 0x40
	// Interrupt disabled.
	MCPWM_INTEN_ICAP1_INTERRUPT_DISABLED_ = 0x0
	// Interrupt enabled.
	MCPWM_INTEN_ICAP1_INTERRUPT_ENABLED_ = 0x1
	// Position of RESERVED field.
	MCPWM_INTEN_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	MCPWM_INTEN_RESERVED_Msk = 0x80
	// Bit RESERVED.
	MCPWM_INTEN_RESERVED = 0x80
	// Position of ILIM2 field.
	MCPWM_INTEN_ILIM2_Pos = 0x8
	// Bit mask of ILIM2 field.
	MCPWM_INTEN_ILIM2_Msk = 0x100
	// Bit ILIM2.
	MCPWM_INTEN_ILIM2 = 0x100
	// Interrupt disabled.
	MCPWM_INTEN_ILIM2_INTERRUPT_DISABLED_ = 0x0
	// Interrupt enabled.
	MCPWM_INTEN_ILIM2_INTERRUPT_ENABLED_ = 0x1
	// Position of IMAT2 field.
	MCPWM_INTEN_IMAT2_Pos = 0x9
	// Bit mask of IMAT2 field.
	MCPWM_INTEN_IMAT2_Msk = 0x200
	// Bit IMAT2.
	MCPWM_INTEN_IMAT2 = 0x200
	// Interrupt disabled.
	MCPWM_INTEN_IMAT2_INTERRUPT_DISABLED_ = 0x0
	// Interrupt enabled.
	MCPWM_INTEN_IMAT2_INTERRUPT_ENABLED_ = 0x1
	// Position of ICAP2 field.
	MCPWM_INTEN_ICAP2_Pos = 0xa
	// Bit mask of ICAP2 field.
	MCPWM_INTEN_ICAP2_Msk = 0x400
	// Bit ICAP2.
	MCPWM_INTEN_ICAP2 = 0x400
	// Interrupt disabled.
	MCPWM_INTEN_ICAP2_INTERRUPT_DISABLED_ = 0x0
	// Interrupt enabled.
	MCPWM_INTEN_ICAP2_INTERRUPT_ENABLED_ = 0x1
	// Position of RESERVED field.
	MCPWM_INTEN_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	MCPWM_INTEN_RESERVED_Msk = 0x7800
	// Position of ABORT field.
	MCPWM_INTEN_ABORT_Pos = 0xf
	// Bit mask of ABORT field.
	MCPWM_INTEN_ABORT_Msk = 0x8000
	// Bit ABORT.
	MCPWM_INTEN_ABORT = 0x8000
	// Interrupt disabled.
	MCPWM_INTEN_ABORT_INTERRUPT_DISABLED_ = 0x0
	// Interrupt enabled.
	MCPWM_INTEN_ABORT_INTERRUPT_ENABLED_ = 0x1
	// Position of RESERVED field.
	MCPWM_INTEN_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	MCPWM_INTEN_RESERVED_Msk = 0xffff0000

	// INTEN_SET: Interrupt Enable set address
	// Position of ILIM0_SET field.
	MCPWM_INTEN_SET_ILIM0_SET_Pos = 0x0
	// Bit mask of ILIM0_SET field.
	MCPWM_INTEN_SET_ILIM0_SET_Msk = 0x1
	// Bit ILIM0_SET.
	MCPWM_INTEN_SET_ILIM0_SET = 0x1
	// Position of IMAT0_SET field.
	MCPWM_INTEN_SET_IMAT0_SET_Pos = 0x1
	// Bit mask of IMAT0_SET field.
	MCPWM_INTEN_SET_IMAT0_SET_Msk = 0x2
	// Bit IMAT0_SET.
	MCPWM_INTEN_SET_IMAT0_SET = 0x2
	// Position of ICAP0_SET field.
	MCPWM_INTEN_SET_ICAP0_SET_Pos = 0x2
	// Bit mask of ICAP0_SET field.
	MCPWM_INTEN_SET_ICAP0_SET_Msk = 0x4
	// Bit ICAP0_SET.
	MCPWM_INTEN_SET_ICAP0_SET = 0x4
	// Position of RESERVED field.
	MCPWM_INTEN_SET_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	MCPWM_INTEN_SET_RESERVED_Msk = 0x8
	// Bit RESERVED.
	MCPWM_INTEN_SET_RESERVED = 0x8
	// Position of ILIM1_SET field.
	MCPWM_INTEN_SET_ILIM1_SET_Pos = 0x4
	// Bit mask of ILIM1_SET field.
	MCPWM_INTEN_SET_ILIM1_SET_Msk = 0x10
	// Bit ILIM1_SET.
	MCPWM_INTEN_SET_ILIM1_SET = 0x10
	// Position of IMAT1_SET field.
	MCPWM_INTEN_SET_IMAT1_SET_Pos = 0x5
	// Bit mask of IMAT1_SET field.
	MCPWM_INTEN_SET_IMAT1_SET_Msk = 0x20
	// Bit IMAT1_SET.
	MCPWM_INTEN_SET_IMAT1_SET = 0x20
	// Position of ICAP1_SET field.
	MCPWM_INTEN_SET_ICAP1_SET_Pos = 0x6
	// Bit mask of ICAP1_SET field.
	MCPWM_INTEN_SET_ICAP1_SET_Msk = 0x40
	// Bit ICAP1_SET.
	MCPWM_INTEN_SET_ICAP1_SET = 0x40
	// Position of RESERVED field.
	MCPWM_INTEN_SET_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	MCPWM_INTEN_SET_RESERVED_Msk = 0x80
	// Bit RESERVED.
	MCPWM_INTEN_SET_RESERVED = 0x80
	// Position of ILIM2_SET field.
	MCPWM_INTEN_SET_ILIM2_SET_Pos = 0x9
	// Bit mask of ILIM2_SET field.
	MCPWM_INTEN_SET_ILIM2_SET_Msk = 0x200
	// Bit ILIM2_SET.
	MCPWM_INTEN_SET_ILIM2_SET = 0x200
	// Position of IMAT2_SET field.
	MCPWM_INTEN_SET_IMAT2_SET_Pos = 0xa
	// Bit mask of IMAT2_SET field.
	MCPWM_INTEN_SET_IMAT2_SET_Msk = 0x400
	// Bit IMAT2_SET.
	MCPWM_INTEN_SET_IMAT2_SET = 0x400
	// Position of ICAP2_SET field.
	MCPWM_INTEN_SET_ICAP2_SET_Pos = 0xb
	// Bit mask of ICAP2_SET field.
	MCPWM_INTEN_SET_ICAP2_SET_Msk = 0x800
	// Bit ICAP2_SET.
	MCPWM_INTEN_SET_ICAP2_SET = 0x800
	// Position of RESERVED field.
	MCPWM_INTEN_SET_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	MCPWM_INTEN_SET_RESERVED_Msk = 0x7000
	// Position of ABORT_SET field.
	MCPWM_INTEN_SET_ABORT_SET_Pos = 0xf
	// Bit mask of ABORT_SET field.
	MCPWM_INTEN_SET_ABORT_SET_Msk = 0x8000
	// Bit ABORT_SET.
	MCPWM_INTEN_SET_ABORT_SET = 0x8000
	// Position of RESERVED field.
	MCPWM_INTEN_SET_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	MCPWM_INTEN_SET_RESERVED_Msk = 0xffff0000

	// INTEN_CLR: Interrupt Enable clear address
	// Position of ILIM0_CLR field.
	MCPWM_INTEN_CLR_ILIM0_CLR_Pos = 0x0
	// Bit mask of ILIM0_CLR field.
	MCPWM_INTEN_CLR_ILIM0_CLR_Msk = 0x1
	// Bit ILIM0_CLR.
	MCPWM_INTEN_CLR_ILIM0_CLR = 0x1
	// Position of IMAT0_CLR field.
	MCPWM_INTEN_CLR_IMAT0_CLR_Pos = 0x1
	// Bit mask of IMAT0_CLR field.
	MCPWM_INTEN_CLR_IMAT0_CLR_Msk = 0x2
	// Bit IMAT0_CLR.
	MCPWM_INTEN_CLR_IMAT0_CLR = 0x2
	// Position of ICAP0_CLR field.
	MCPWM_INTEN_CLR_ICAP0_CLR_Pos = 0x2
	// Bit mask of ICAP0_CLR field.
	MCPWM_INTEN_CLR_ICAP0_CLR_Msk = 0x4
	// Bit ICAP0_CLR.
	MCPWM_INTEN_CLR_ICAP0_CLR = 0x4
	// Position of RESERVED field.
	MCPWM_INTEN_CLR_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	MCPWM_INTEN_CLR_RESERVED_Msk = 0x8
	// Bit RESERVED.
	MCPWM_INTEN_CLR_RESERVED = 0x8
	// Position of ILIM1_CLR field.
	MCPWM_INTEN_CLR_ILIM1_CLR_Pos = 0x4
	// Bit mask of ILIM1_CLR field.
	MCPWM_INTEN_CLR_ILIM1_CLR_Msk = 0x10
	// Bit ILIM1_CLR.
	MCPWM_INTEN_CLR_ILIM1_CLR = 0x10
	// Position of IMAT1_CLR field.
	MCPWM_INTEN_CLR_IMAT1_CLR_Pos = 0x5
	// Bit mask of IMAT1_CLR field.
	MCPWM_INTEN_CLR_IMAT1_CLR_Msk = 0x20
	// Bit IMAT1_CLR.
	MCPWM_INTEN_CLR_IMAT1_CLR = 0x20
	// Position of ICAP1_CLR field.
	MCPWM_INTEN_CLR_ICAP1_CLR_Pos = 0x6
	// Bit mask of ICAP1_CLR field.
	MCPWM_INTEN_CLR_ICAP1_CLR_Msk = 0x40
	// Bit ICAP1_CLR.
	MCPWM_INTEN_CLR_ICAP1_CLR = 0x40
	// Position of RESERVED field.
	MCPWM_INTEN_CLR_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	MCPWM_INTEN_CLR_RESERVED_Msk = 0x80
	// Bit RESERVED.
	MCPWM_INTEN_CLR_RESERVED = 0x80
	// Position of ILIM2_CLR field.
	MCPWM_INTEN_CLR_ILIM2_CLR_Pos = 0x8
	// Bit mask of ILIM2_CLR field.
	MCPWM_INTEN_CLR_ILIM2_CLR_Msk = 0x100
	// Bit ILIM2_CLR.
	MCPWM_INTEN_CLR_ILIM2_CLR = 0x100
	// Position of IMAT2_CLR field.
	MCPWM_INTEN_CLR_IMAT2_CLR_Pos = 0x9
	// Bit mask of IMAT2_CLR field.
	MCPWM_INTEN_CLR_IMAT2_CLR_Msk = 0x200
	// Bit IMAT2_CLR.
	MCPWM_INTEN_CLR_IMAT2_CLR = 0x200
	// Position of ICAP2_CLR field.
	MCPWM_INTEN_CLR_ICAP2_CLR_Pos = 0xa
	// Bit mask of ICAP2_CLR field.
	MCPWM_INTEN_CLR_ICAP2_CLR_Msk = 0x400
	// Bit ICAP2_CLR.
	MCPWM_INTEN_CLR_ICAP2_CLR = 0x400
	// Position of RESERVED field.
	MCPWM_INTEN_CLR_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	MCPWM_INTEN_CLR_RESERVED_Msk = 0x7800
	// Position of ABORT_CLR field.
	MCPWM_INTEN_CLR_ABORT_CLR_Pos = 0xf
	// Bit mask of ABORT_CLR field.
	MCPWM_INTEN_CLR_ABORT_CLR_Msk = 0x8000
	// Bit ABORT_CLR.
	MCPWM_INTEN_CLR_ABORT_CLR = 0x8000
	// Position of RESERVED field.
	MCPWM_INTEN_CLR_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	MCPWM_INTEN_CLR_RESERVED_Msk = 0xffff0000

	// CNTCON: Count Control read address
	// Position of TC0MCI0_RE field.
	MCPWM_CNTCON_TC0MCI0_RE_Pos = 0x0
	// Bit mask of TC0MCI0_RE field.
	MCPWM_CNTCON_TC0MCI0_RE_Msk = 0x1
	// Bit TC0MCI0_RE.
	MCPWM_CNTCON_TC0MCI0_RE = 0x1
	// A rising edge on MCI0 does not affect counter 0.
	MCPWM_CNTCON_TC0MCI0_RE_A_RISING_EDGE_ON_MCI = 0x0
	// If MODE0 is 1, counter 0 advances on a rising edge on MCI0.
	MCPWM_CNTCON_TC0MCI0_RE_RISING = 0x1
	// Position of TC0MCI0_FE field.
	MCPWM_CNTCON_TC0MCI0_FE_Pos = 0x1
	// Bit mask of TC0MCI0_FE field.
	MCPWM_CNTCON_TC0MCI0_FE_Msk = 0x2
	// Bit TC0MCI0_FE.
	MCPWM_CNTCON_TC0MCI0_FE = 0x2
	// A falling edge on MCI0 does not affect counter 0.
	MCPWM_CNTCON_TC0MCI0_FE_A_FALLING_EDGE_ON_MC = 0x0
	// If MODE0 is 1, counter 0 advances on a falling edge on MCI0.
	MCPWM_CNTCON_TC0MCI0_FE_FALLING = 0x1
	// Position of TC0MCI1_RE field.
	MCPWM_CNTCON_TC0MCI1_RE_Pos = 0x2
	// Bit mask of TC0MCI1_RE field.
	MCPWM_CNTCON_TC0MCI1_RE_Msk = 0x4
	// Bit TC0MCI1_RE.
	MCPWM_CNTCON_TC0MCI1_RE = 0x4
	// A rising edge on MCI1 does not affect counter 0.
	MCPWM_CNTCON_TC0MCI1_RE_A_RISING_EDGE_ON_MCI = 0x0
	// If MODE0 is 1, counter 0 advances on a rising edge on MCI1.
	MCPWM_CNTCON_TC0MCI1_RE_RISING = 0x1
	// Position of TC0MCI1_FE field.
	MCPWM_CNTCON_TC0MCI1_FE_Pos = 0x3
	// Bit mask of TC0MCI1_FE field.
	MCPWM_CNTCON_TC0MCI1_FE_Msk = 0x8
	// Bit TC0MCI1_FE.
	MCPWM_CNTCON_TC0MCI1_FE = 0x8
	// A falling edge on MCI1 does not affect counter 0.
	MCPWM_CNTCON_TC0MCI1_FE_A_FALLING_EDGE_ON_MC = 0x0
	// If MODE0 is 1, counter 0 advances on a falling edge on MCI1.
	MCPWM_CNTCON_TC0MCI1_FE_FALLING = 0x1
	// Position of TC0MCI2_RE field.
	MCPWM_CNTCON_TC0MCI2_RE_Pos = 0x4
	// Bit mask of TC0MCI2_RE field.
	MCPWM_CNTCON_TC0MCI2_RE_Msk = 0x10
	// Bit TC0MCI2_RE.
	MCPWM_CNTCON_TC0MCI2_RE = 0x10
	// A rising edge on MCI0 does not affect counter 0.
	MCPWM_CNTCON_TC0MCI2_RE_A_RISING_EDGE_ON_MCI = 0x0
	// If MODE0 is 1, counter 0 advances on a rising edge on MCI2.
	MCPWM_CNTCON_TC0MCI2_RE_RISING = 0x1
	// Position of TC0MCI2_FE field.
	MCPWM_CNTCON_TC0MCI2_FE_Pos = 0x5
	// Bit mask of TC0MCI2_FE field.
	MCPWM_CNTCON_TC0MCI2_FE_Msk = 0x20
	// Bit TC0MCI2_FE.
	MCPWM_CNTCON_TC0MCI2_FE = 0x20
	// A falling edge on MCI0 does not affect counter 0.
	MCPWM_CNTCON_TC0MCI2_FE_A_FALLING_EDGE_ON_MC = 0x0
	// If MODE0 is 1, counter 0 advances on a falling edge on MCI2.
	MCPWM_CNTCON_TC0MCI2_FE_FALLLING = 0x1
	// Position of TC1MCI0_RE field.
	MCPWM_CNTCON_TC1MCI0_RE_Pos = 0x6
	// Bit mask of TC1MCI0_RE field.
	MCPWM_CNTCON_TC1MCI0_RE_Msk = 0x40
	// Bit TC1MCI0_RE.
	MCPWM_CNTCON_TC1MCI0_RE = 0x40
	// A rising edge on MCI0 does not affect counter 1.
	MCPWM_CNTCON_TC1MCI0_RE_A_RISING_EDGE_ON_MCI = 0x0
	// If MODE1 is 1, counter 1 advances on a rising edge on MCI0.
	MCPWM_CNTCON_TC1MCI0_RE_RISING = 0x1
	// Position of TC1MCI0_FE field.
	MCPWM_CNTCON_TC1MCI0_FE_Pos = 0x7
	// Bit mask of TC1MCI0_FE field.
	MCPWM_CNTCON_TC1MCI0_FE_Msk = 0x80
	// Bit TC1MCI0_FE.
	MCPWM_CNTCON_TC1MCI0_FE = 0x80
	// A falling edge on MCI0 does not affect counter 1.
	MCPWM_CNTCON_TC1MCI0_FE_A_FALLING_EDGE_ON_MC = 0x0
	// If MODE1 is 1, counter 1 advances on a falling edge on MCI0.
	MCPWM_CNTCON_TC1MCI0_FE_FALLING = 0x1
	// Position of TC1MCI1_RE field.
	MCPWM_CNTCON_TC1MCI1_RE_Pos = 0x8
	// Bit mask of TC1MCI1_RE field.
	MCPWM_CNTCON_TC1MCI1_RE_Msk = 0x100
	// Bit TC1MCI1_RE.
	MCPWM_CNTCON_TC1MCI1_RE = 0x100
	// A rising edge on MCI1 does not affect counter 1.
	MCPWM_CNTCON_TC1MCI1_RE_A_RISING_EDGE_ON_MCI = 0x0
	// If MODE1 is 1, counter 1 advances on a rising edge on MCI1.
	MCPWM_CNTCON_TC1MCI1_RE_RISING = 0x1
	// Position of TC1MCI1_FE field.
	MCPWM_CNTCON_TC1MCI1_FE_Pos = 0x9
	// Bit mask of TC1MCI1_FE field.
	MCPWM_CNTCON_TC1MCI1_FE_Msk = 0x200
	// Bit TC1MCI1_FE.
	MCPWM_CNTCON_TC1MCI1_FE = 0x200
	// A falling edge on MCI0 does not affect counter 1.
	MCPWM_CNTCON_TC1MCI1_FE_A_FALLING_EDGE_ON_MC = 0x0
	// If MODE1 is 1, counter 1 advances on a falling edge on MCI1.
	MCPWM_CNTCON_TC1MCI1_FE_FALLING = 0x1
	// Position of TC1MCI2_RE field.
	MCPWM_CNTCON_TC1MCI2_RE_Pos = 0xa
	// Bit mask of TC1MCI2_RE field.
	MCPWM_CNTCON_TC1MCI2_RE_Msk = 0x400
	// Bit TC1MCI2_RE.
	MCPWM_CNTCON_TC1MCI2_RE = 0x400
	// A rising edge on MCI2 does not affect counter 1.
	MCPWM_CNTCON_TC1MCI2_RE_A_RISING_EDGE_ON_MCI = 0x0
	// If MODE1 is 1, counter 1 advances on a rising edge on MCI2.
	MCPWM_CNTCON_TC1MCI2_RE_RISING = 0x1
	// Position of TC1MCI2_FE field.
	MCPWM_CNTCON_TC1MCI2_FE_Pos = 0xb
	// Bit mask of TC1MCI2_FE field.
	MCPWM_CNTCON_TC1MCI2_FE_Msk = 0x800
	// Bit TC1MCI2_FE.
	MCPWM_CNTCON_TC1MCI2_FE = 0x800
	// A falling edge on MCI2 does not affect counter 1.
	MCPWM_CNTCON_TC1MCI2_FE_A_FALLING_EDGE_ON_MC = 0x0
	// If MODE1 is 1, counter 1 advances on a falling edge on MCI2.
	MCPWM_CNTCON_TC1MCI2_FE_FALLING = 0x1
	// Position of TC2MCI0_RE field.
	MCPWM_CNTCON_TC2MCI0_RE_Pos = 0xc
	// Bit mask of TC2MCI0_RE field.
	MCPWM_CNTCON_TC2MCI0_RE_Msk = 0x1000
	// Bit TC2MCI0_RE.
	MCPWM_CNTCON_TC2MCI0_RE = 0x1000
	// A rising edge on MCI0 does not affect counter 2.
	MCPWM_CNTCON_TC2MCI0_RE_A_RISING_EDGE_ON_MCI = 0x0
	// If MODE2 is 1, counter 2 advances on a rising edge on MCI0.
	MCPWM_CNTCON_TC2MCI0_RE_RISING = 0x1
	// Position of TC2MCI0_FE field.
	MCPWM_CNTCON_TC2MCI0_FE_Pos = 0xd
	// Bit mask of TC2MCI0_FE field.
	MCPWM_CNTCON_TC2MCI0_FE_Msk = 0x2000
	// Bit TC2MCI0_FE.
	MCPWM_CNTCON_TC2MCI0_FE = 0x2000
	// A falling edge on MCI0 does not affect counter 2.
	MCPWM_CNTCON_TC2MCI0_FE_A_FALLING_EDGE_ON_MC = 0x0
	// If MODE2 is 1, counter 2 advances on a falling edge on MCI0.
	MCPWM_CNTCON_TC2MCI0_FE_FALLING = 0x1
	// Position of TC2MCI1_RE field.
	MCPWM_CNTCON_TC2MCI1_RE_Pos = 0xe
	// Bit mask of TC2MCI1_RE field.
	MCPWM_CNTCON_TC2MCI1_RE_Msk = 0x4000
	// Bit TC2MCI1_RE.
	MCPWM_CNTCON_TC2MCI1_RE = 0x4000
	// A rising edge on MCI1 does not affect counter 2.
	MCPWM_CNTCON_TC2MCI1_RE_A_RISING_EDGE_ON_MCI = 0x0
	// If MODE2 is 1, counter 2 advances on a rising edge on MCI1.
	MCPWM_CNTCON_TC2MCI1_RE_RISING = 0x1
	// Position of TC2MCI1_FE field.
	MCPWM_CNTCON_TC2MCI1_FE_Pos = 0xf
	// Bit mask of TC2MCI1_FE field.
	MCPWM_CNTCON_TC2MCI1_FE_Msk = 0x8000
	// Bit TC2MCI1_FE.
	MCPWM_CNTCON_TC2MCI1_FE = 0x8000
	// A falling edge on MCI1 does not affect counter 2.
	MCPWM_CNTCON_TC2MCI1_FE_A_FALLING_EDGE_ON_MC = 0x0
	// If MODE2 is 1, counter 2 advances on a falling edge on MCI1.
	MCPWM_CNTCON_TC2MCI1_FE_FALLING = 0x1
	// Position of TC2MCI2_RE field.
	MCPWM_CNTCON_TC2MCI2_RE_Pos = 0x10
	// Bit mask of TC2MCI2_RE field.
	MCPWM_CNTCON_TC2MCI2_RE_Msk = 0x10000
	// Bit TC2MCI2_RE.
	MCPWM_CNTCON_TC2MCI2_RE = 0x10000
	// A rising edge on MCI2 does not affect counter 2.
	MCPWM_CNTCON_TC2MCI2_RE_A_RISING_EDGE_ON_MCI = 0x0
	// If MODE2 is 1, counter 2 advances on a rising edge on MCI2.
	MCPWM_CNTCON_TC2MCI2_RE_RISIING = 0x1
	// Position of TC2MCI2_FE field.
	MCPWM_CNTCON_TC2MCI2_FE_Pos = 0x11
	// Bit mask of TC2MCI2_FE field.
	MCPWM_CNTCON_TC2MCI2_FE_Msk = 0x20000
	// Bit TC2MCI2_FE.
	MCPWM_CNTCON_TC2MCI2_FE = 0x20000
	// A falling edge on MCI2 does not affect counter 2.
	MCPWM_CNTCON_TC2MCI2_FE_A_FALLING_EDGE_ON_MC = 0x0
	// If MODE2 is 1, counter 2 advances on a falling edge on MCI2.
	MCPWM_CNTCON_TC2MCI2_FE_FALLING = 0x1
	// Position of RESERVED field.
	MCPWM_CNTCON_RESERVED_Pos = 0x12
	// Bit mask of RESERVED field.
	MCPWM_CNTCON_RESERVED_Msk = 0x1ffc0000
	// Position of CNTR0 field.
	MCPWM_CNTCON_CNTR0_Pos = 0x1d
	// Bit mask of CNTR0 field.
	MCPWM_CNTCON_CNTR0_Msk = 0x20000000
	// Bit CNTR0.
	MCPWM_CNTCON_CNTR0 = 0x20000000
	// Channel 0 is in timer mode.
	MCPWM_CNTCON_CNTR0_CHANNEL_0_IS_IN_TIME = 0x0
	// Channel 0 is in counter mode.
	MCPWM_CNTCON_CNTR0_CHANNEL_0_IS_IN_COUN = 0x1
	// Position of CNTR1 field.
	MCPWM_CNTCON_CNTR1_Pos = 0x1e
	// Bit mask of CNTR1 field.
	MCPWM_CNTCON_CNTR1_Msk = 0x40000000
	// Bit CNTR1.
	MCPWM_CNTCON_CNTR1 = 0x40000000
	// Channel 1 is in timer mode.
	MCPWM_CNTCON_CNTR1_CHANNEL_1_IS_IN_TIME = 0x0
	// Channel 1 is in counter mode.
	MCPWM_CNTCON_CNTR1_CHANNEL_1_IS_IN_COUN = 0x1
	// Position of CNTR2 field.
	MCPWM_CNTCON_CNTR2_Pos = 0x1f
	// Bit mask of CNTR2 field.
	MCPWM_CNTCON_CNTR2_Msk = 0x80000000
	// Bit CNTR2.
	MCPWM_CNTCON_CNTR2 = 0x80000000
	// Channel 2 is in timer mode.
	MCPWM_CNTCON_CNTR2_CHANNEL_2_IS_IN_TIME = 0x0
	// Channel 2 is in counter mode.
	MCPWM_CNTCON_CNTR2_CHANNEL_2_IS_IN_COUN = 0x1

	// CNTCON_SET: Count Control set address
	// Position of TC0MCI0_RE_SET field.
	MCPWM_CNTCON_SET_TC0MCI0_RE_SET_Pos = 0x0
	// Bit mask of TC0MCI0_RE_SET field.
	MCPWM_CNTCON_SET_TC0MCI0_RE_SET_Msk = 0x1
	// Bit TC0MCI0_RE_SET.
	MCPWM_CNTCON_SET_TC0MCI0_RE_SET = 0x1
	// Position of TC0MCI0_FE_SET field.
	MCPWM_CNTCON_SET_TC0MCI0_FE_SET_Pos = 0x1
	// Bit mask of TC0MCI0_FE_SET field.
	MCPWM_CNTCON_SET_TC0MCI0_FE_SET_Msk = 0x2
	// Bit TC0MCI0_FE_SET.
	MCPWM_CNTCON_SET_TC0MCI0_FE_SET = 0x2
	// Position of TC0MCI1_RE_SET field.
	MCPWM_CNTCON_SET_TC0MCI1_RE_SET_Pos = 0x2
	// Bit mask of TC0MCI1_RE_SET field.
	MCPWM_CNTCON_SET_TC0MCI1_RE_SET_Msk = 0x4
	// Bit TC0MCI1_RE_SET.
	MCPWM_CNTCON_SET_TC0MCI1_RE_SET = 0x4
	// Position of TC0MCI1_FE_SET field.
	MCPWM_CNTCON_SET_TC0MCI1_FE_SET_Pos = 0x3
	// Bit mask of TC0MCI1_FE_SET field.
	MCPWM_CNTCON_SET_TC0MCI1_FE_SET_Msk = 0x8
	// Bit TC0MCI1_FE_SET.
	MCPWM_CNTCON_SET_TC0MCI1_FE_SET = 0x8
	// Position of TC0MCI2_RE_SET field.
	MCPWM_CNTCON_SET_TC0MCI2_RE_SET_Pos = 0x4
	// Bit mask of TC0MCI2_RE_SET field.
	MCPWM_CNTCON_SET_TC0MCI2_RE_SET_Msk = 0x10
	// Bit TC0MCI2_RE_SET.
	MCPWM_CNTCON_SET_TC0MCI2_RE_SET = 0x10
	// Position of TC0MCI2_FE_SET field.
	MCPWM_CNTCON_SET_TC0MCI2_FE_SET_Pos = 0x5
	// Bit mask of TC0MCI2_FE_SET field.
	MCPWM_CNTCON_SET_TC0MCI2_FE_SET_Msk = 0x20
	// Bit TC0MCI2_FE_SET.
	MCPWM_CNTCON_SET_TC0MCI2_FE_SET = 0x20
	// Position of TC1MCI0_RE_SET field.
	MCPWM_CNTCON_SET_TC1MCI0_RE_SET_Pos = 0x6
	// Bit mask of TC1MCI0_RE_SET field.
	MCPWM_CNTCON_SET_TC1MCI0_RE_SET_Msk = 0x40
	// Bit TC1MCI0_RE_SET.
	MCPWM_CNTCON_SET_TC1MCI0_RE_SET = 0x40
	// Position of TC1MCI0_FE_SET field.
	MCPWM_CNTCON_SET_TC1MCI0_FE_SET_Pos = 0x7
	// Bit mask of TC1MCI0_FE_SET field.
	MCPWM_CNTCON_SET_TC1MCI0_FE_SET_Msk = 0x80
	// Bit TC1MCI0_FE_SET.
	MCPWM_CNTCON_SET_TC1MCI0_FE_SET = 0x80
	// Position of TC1MCI1_RE_SET field.
	MCPWM_CNTCON_SET_TC1MCI1_RE_SET_Pos = 0x8
	// Bit mask of TC1MCI1_RE_SET field.
	MCPWM_CNTCON_SET_TC1MCI1_RE_SET_Msk = 0x100
	// Bit TC1MCI1_RE_SET.
	MCPWM_CNTCON_SET_TC1MCI1_RE_SET = 0x100
	// Position of TC1MCI1_FE_SET field.
	MCPWM_CNTCON_SET_TC1MCI1_FE_SET_Pos = 0x9
	// Bit mask of TC1MCI1_FE_SET field.
	MCPWM_CNTCON_SET_TC1MCI1_FE_SET_Msk = 0x200
	// Bit TC1MCI1_FE_SET.
	MCPWM_CNTCON_SET_TC1MCI1_FE_SET = 0x200
	// Position of TC1MCI2_RE_SET field.
	MCPWM_CNTCON_SET_TC1MCI2_RE_SET_Pos = 0xa
	// Bit mask of TC1MCI2_RE_SET field.
	MCPWM_CNTCON_SET_TC1MCI2_RE_SET_Msk = 0x400
	// Bit TC1MCI2_RE_SET.
	MCPWM_CNTCON_SET_TC1MCI2_RE_SET = 0x400
	// Position of TC1MCI2_FE_SET field.
	MCPWM_CNTCON_SET_TC1MCI2_FE_SET_Pos = 0xb
	// Bit mask of TC1MCI2_FE_SET field.
	MCPWM_CNTCON_SET_TC1MCI2_FE_SET_Msk = 0x800
	// Bit TC1MCI2_FE_SET.
	MCPWM_CNTCON_SET_TC1MCI2_FE_SET = 0x800
	// Position of TC2MCI0_RE_SET field.
	MCPWM_CNTCON_SET_TC2MCI0_RE_SET_Pos = 0xc
	// Bit mask of TC2MCI0_RE_SET field.
	MCPWM_CNTCON_SET_TC2MCI0_RE_SET_Msk = 0x1000
	// Bit TC2MCI0_RE_SET.
	MCPWM_CNTCON_SET_TC2MCI0_RE_SET = 0x1000
	// Position of TC2MCI0_FE_SET field.
	MCPWM_CNTCON_SET_TC2MCI0_FE_SET_Pos = 0xd
	// Bit mask of TC2MCI0_FE_SET field.
	MCPWM_CNTCON_SET_TC2MCI0_FE_SET_Msk = 0x2000
	// Bit TC2MCI0_FE_SET.
	MCPWM_CNTCON_SET_TC2MCI0_FE_SET = 0x2000
	// Position of TC2MCI1_RE_SET field.
	MCPWM_CNTCON_SET_TC2MCI1_RE_SET_Pos = 0xe
	// Bit mask of TC2MCI1_RE_SET field.
	MCPWM_CNTCON_SET_TC2MCI1_RE_SET_Msk = 0x4000
	// Bit TC2MCI1_RE_SET.
	MCPWM_CNTCON_SET_TC2MCI1_RE_SET = 0x4000
	// Position of TC2MCI1_FE_SET field.
	MCPWM_CNTCON_SET_TC2MCI1_FE_SET_Pos = 0xf
	// Bit mask of TC2MCI1_FE_SET field.
	MCPWM_CNTCON_SET_TC2MCI1_FE_SET_Msk = 0x8000
	// Bit TC2MCI1_FE_SET.
	MCPWM_CNTCON_SET_TC2MCI1_FE_SET = 0x8000
	// Position of TC2MCI2_RE_SET field.
	MCPWM_CNTCON_SET_TC2MCI2_RE_SET_Pos = 0x10
	// Bit mask of TC2MCI2_RE_SET field.
	MCPWM_CNTCON_SET_TC2MCI2_RE_SET_Msk = 0x10000
	// Bit TC2MCI2_RE_SET.
	MCPWM_CNTCON_SET_TC2MCI2_RE_SET = 0x10000
	// Position of TC2MCI2_FE_SET field.
	MCPWM_CNTCON_SET_TC2MCI2_FE_SET_Pos = 0x11
	// Bit mask of TC2MCI2_FE_SET field.
	MCPWM_CNTCON_SET_TC2MCI2_FE_SET_Msk = 0x20000
	// Bit TC2MCI2_FE_SET.
	MCPWM_CNTCON_SET_TC2MCI2_FE_SET = 0x20000
	// Position of RESERVED field.
	MCPWM_CNTCON_SET_RESERVED_Pos = 0x12
	// Bit mask of RESERVED field.
	MCPWM_CNTCON_SET_RESERVED_Msk = 0x1ffc0000
	// Position of CNTR0_SET field.
	MCPWM_CNTCON_SET_CNTR0_SET_Pos = 0x1d
	// Bit mask of CNTR0_SET field.
	MCPWM_CNTCON_SET_CNTR0_SET_Msk = 0x20000000
	// Bit CNTR0_SET.
	MCPWM_CNTCON_SET_CNTR0_SET = 0x20000000
	// Position of CNTR1_SET field.
	MCPWM_CNTCON_SET_CNTR1_SET_Pos = 0x1e
	// Bit mask of CNTR1_SET field.
	MCPWM_CNTCON_SET_CNTR1_SET_Msk = 0x40000000
	// Bit CNTR1_SET.
	MCPWM_CNTCON_SET_CNTR1_SET = 0x40000000
	// Position of CNTR2_SET field.
	MCPWM_CNTCON_SET_CNTR2_SET_Pos = 0x1f
	// Bit mask of CNTR2_SET field.
	MCPWM_CNTCON_SET_CNTR2_SET_Msk = 0x80000000
	// Bit CNTR2_SET.
	MCPWM_CNTCON_SET_CNTR2_SET = 0x80000000

	// CNTCON_CLR: Count Control clear address
	// Position of TC0MCI0_RE_CLR field.
	MCPWM_CNTCON_CLR_TC0MCI0_RE_CLR_Pos = 0x0
	// Bit mask of TC0MCI0_RE_CLR field.
	MCPWM_CNTCON_CLR_TC0MCI0_RE_CLR_Msk = 0x1
	// Bit TC0MCI0_RE_CLR.
	MCPWM_CNTCON_CLR_TC0MCI0_RE_CLR = 0x1
	// Position of TC0MCI0_FE_CLR field.
	MCPWM_CNTCON_CLR_TC0MCI0_FE_CLR_Pos = 0x1
	// Bit mask of TC0MCI0_FE_CLR field.
	MCPWM_CNTCON_CLR_TC0MCI0_FE_CLR_Msk = 0x2
	// Bit TC0MCI0_FE_CLR.
	MCPWM_CNTCON_CLR_TC0MCI0_FE_CLR = 0x2
	// Position of TC0MCI1_RE_CLR field.
	MCPWM_CNTCON_CLR_TC0MCI1_RE_CLR_Pos = 0x2
	// Bit mask of TC0MCI1_RE_CLR field.
	MCPWM_CNTCON_CLR_TC0MCI1_RE_CLR_Msk = 0x4
	// Bit TC0MCI1_RE_CLR.
	MCPWM_CNTCON_CLR_TC0MCI1_RE_CLR = 0x4
	// Position of TC0MCI1_FE_CLR field.
	MCPWM_CNTCON_CLR_TC0MCI1_FE_CLR_Pos = 0x3
	// Bit mask of TC0MCI1_FE_CLR field.
	MCPWM_CNTCON_CLR_TC0MCI1_FE_CLR_Msk = 0x8
	// Bit TC0MCI1_FE_CLR.
	MCPWM_CNTCON_CLR_TC0MCI1_FE_CLR = 0x8
	// Position of TC0MCI2_RE field.
	MCPWM_CNTCON_CLR_TC0MCI2_RE_Pos = 0x4
	// Bit mask of TC0MCI2_RE field.
	MCPWM_CNTCON_CLR_TC0MCI2_RE_Msk = 0x10
	// Bit TC0MCI2_RE.
	MCPWM_CNTCON_CLR_TC0MCI2_RE = 0x10
	// Position of TC0MCI2_FE_CLR field.
	MCPWM_CNTCON_CLR_TC0MCI2_FE_CLR_Pos = 0x5
	// Bit mask of TC0MCI2_FE_CLR field.
	MCPWM_CNTCON_CLR_TC0MCI2_FE_CLR_Msk = 0x20
	// Bit TC0MCI2_FE_CLR.
	MCPWM_CNTCON_CLR_TC0MCI2_FE_CLR = 0x20
	// Position of TC1MCI0_RE_CLR field.
	MCPWM_CNTCON_CLR_TC1MCI0_RE_CLR_Pos = 0x6
	// Bit mask of TC1MCI0_RE_CLR field.
	MCPWM_CNTCON_CLR_TC1MCI0_RE_CLR_Msk = 0x40
	// Bit TC1MCI0_RE_CLR.
	MCPWM_CNTCON_CLR_TC1MCI0_RE_CLR = 0x40
	// Position of TC1MCI0_FE_CLR field.
	MCPWM_CNTCON_CLR_TC1MCI0_FE_CLR_Pos = 0x7
	// Bit mask of TC1MCI0_FE_CLR field.
	MCPWM_CNTCON_CLR_TC1MCI0_FE_CLR_Msk = 0x80
	// Bit TC1MCI0_FE_CLR.
	MCPWM_CNTCON_CLR_TC1MCI0_FE_CLR = 0x80
	// Position of TC1MCI1_RE_CLR field.
	MCPWM_CNTCON_CLR_TC1MCI1_RE_CLR_Pos = 0x8
	// Bit mask of TC1MCI1_RE_CLR field.
	MCPWM_CNTCON_CLR_TC1MCI1_RE_CLR_Msk = 0x100
	// Bit TC1MCI1_RE_CLR.
	MCPWM_CNTCON_CLR_TC1MCI1_RE_CLR = 0x100
	// Position of TC1MCI1_FE_CLR field.
	MCPWM_CNTCON_CLR_TC1MCI1_FE_CLR_Pos = 0x9
	// Bit mask of TC1MCI1_FE_CLR field.
	MCPWM_CNTCON_CLR_TC1MCI1_FE_CLR_Msk = 0x200
	// Bit TC1MCI1_FE_CLR.
	MCPWM_CNTCON_CLR_TC1MCI1_FE_CLR = 0x200
	// Position of TC1MCI2_RE_CLR field.
	MCPWM_CNTCON_CLR_TC1MCI2_RE_CLR_Pos = 0xa
	// Bit mask of TC1MCI2_RE_CLR field.
	MCPWM_CNTCON_CLR_TC1MCI2_RE_CLR_Msk = 0x400
	// Bit TC1MCI2_RE_CLR.
	MCPWM_CNTCON_CLR_TC1MCI2_RE_CLR = 0x400
	// Position of TC1MCI2_FE_CLR field.
	MCPWM_CNTCON_CLR_TC1MCI2_FE_CLR_Pos = 0xb
	// Bit mask of TC1MCI2_FE_CLR field.
	MCPWM_CNTCON_CLR_TC1MCI2_FE_CLR_Msk = 0x800
	// Bit TC1MCI2_FE_CLR.
	MCPWM_CNTCON_CLR_TC1MCI2_FE_CLR = 0x800
	// Position of TC2MCI0_RE_CLR field.
	MCPWM_CNTCON_CLR_TC2MCI0_RE_CLR_Pos = 0xc
	// Bit mask of TC2MCI0_RE_CLR field.
	MCPWM_CNTCON_CLR_TC2MCI0_RE_CLR_Msk = 0x1000
	// Bit TC2MCI0_RE_CLR.
	MCPWM_CNTCON_CLR_TC2MCI0_RE_CLR = 0x1000
	// Position of TC2MCI0_FE_CLR field.
	MCPWM_CNTCON_CLR_TC2MCI0_FE_CLR_Pos = 0xd
	// Bit mask of TC2MCI0_FE_CLR field.
	MCPWM_CNTCON_CLR_TC2MCI0_FE_CLR_Msk = 0x2000
	// Bit TC2MCI0_FE_CLR.
	MCPWM_CNTCON_CLR_TC2MCI0_FE_CLR = 0x2000
	// Position of TC2MCI1_RE_CLR field.
	MCPWM_CNTCON_CLR_TC2MCI1_RE_CLR_Pos = 0xe
	// Bit mask of TC2MCI1_RE_CLR field.
	MCPWM_CNTCON_CLR_TC2MCI1_RE_CLR_Msk = 0x4000
	// Bit TC2MCI1_RE_CLR.
	MCPWM_CNTCON_CLR_TC2MCI1_RE_CLR = 0x4000
	// Position of TC2MCI1_FE_CLR field.
	MCPWM_CNTCON_CLR_TC2MCI1_FE_CLR_Pos = 0xf
	// Bit mask of TC2MCI1_FE_CLR field.
	MCPWM_CNTCON_CLR_TC2MCI1_FE_CLR_Msk = 0x8000
	// Bit TC2MCI1_FE_CLR.
	MCPWM_CNTCON_CLR_TC2MCI1_FE_CLR = 0x8000
	// Position of TC2MCI2_RE_CLR field.
	MCPWM_CNTCON_CLR_TC2MCI2_RE_CLR_Pos = 0x10
	// Bit mask of TC2MCI2_RE_CLR field.
	MCPWM_CNTCON_CLR_TC2MCI2_RE_CLR_Msk = 0x10000
	// Bit TC2MCI2_RE_CLR.
	MCPWM_CNTCON_CLR_TC2MCI2_RE_CLR = 0x10000
	// Position of TC2MCI2_FE_CLR field.
	MCPWM_CNTCON_CLR_TC2MCI2_FE_CLR_Pos = 0x11
	// Bit mask of TC2MCI2_FE_CLR field.
	MCPWM_CNTCON_CLR_TC2MCI2_FE_CLR_Msk = 0x20000
	// Bit TC2MCI2_FE_CLR.
	MCPWM_CNTCON_CLR_TC2MCI2_FE_CLR = 0x20000
	// Position of RESERVED field.
	MCPWM_CNTCON_CLR_RESERVED_Pos = 0x12
	// Bit mask of RESERVED field.
	MCPWM_CNTCON_CLR_RESERVED_Msk = 0x1ffc0000
	// Position of CNTR0_CLR field.
	MCPWM_CNTCON_CLR_CNTR0_CLR_Pos = 0x1d
	// Bit mask of CNTR0_CLR field.
	MCPWM_CNTCON_CLR_CNTR0_CLR_Msk = 0x20000000
	// Bit CNTR0_CLR.
	MCPWM_CNTCON_CLR_CNTR0_CLR = 0x20000000
	// Position of CNTR1_CLR field.
	MCPWM_CNTCON_CLR_CNTR1_CLR_Pos = 0x1e
	// Bit mask of CNTR1_CLR field.
	MCPWM_CNTCON_CLR_CNTR1_CLR_Msk = 0x40000000
	// Bit CNTR1_CLR.
	MCPWM_CNTCON_CLR_CNTR1_CLR = 0x40000000
	// Position of CNTR2_CLR field.
	MCPWM_CNTCON_CLR_CNTR2_CLR_Pos = 0x1f
	// Bit mask of CNTR2_CLR field.
	MCPWM_CNTCON_CLR_CNTR2_CLR_Msk = 0x80000000
	// Bit CNTR2_CLR.
	MCPWM_CNTCON_CLR_CNTR2_CLR = 0x80000000

	// INTF: Interrupt flags read address
	// Position of ILIM0_F field.
	MCPWM_INTF_ILIM0_F_Pos = 0x0
	// Bit mask of ILIM0_F field.
	MCPWM_INTF_ILIM0_F_Msk = 0x1
	// Bit ILIM0_F.
	MCPWM_INTF_ILIM0_F = 0x1
	// This interrupt source is not contributing to the MCPWM interrupt request.
	MCPWM_INTF_ILIM0_F_THIS_INTERRUPT_SOURC = 0x0
	// If the corresponding bit in INTEN is 1, the MCPWM module is asserting its interrupt request to the Interrupt Controller.
	MCPWM_INTF_ILIM0_F_IF_THE_CORRESPONDING = 0x1
	// Position of IMAT0_F field.
	MCPWM_INTF_IMAT0_F_Pos = 0x1
	// Bit mask of IMAT0_F field.
	MCPWM_INTF_IMAT0_F_Msk = 0x2
	// Bit IMAT0_F.
	MCPWM_INTF_IMAT0_F = 0x2
	// This interrupt source is not contributing to the MCPWM interrupt request.
	MCPWM_INTF_IMAT0_F_THIS_INTERRUPT_SOURC = 0x0
	// If the corresponding bit in INTEN is 1, the MCPWM module is asserting its interrupt request to the Interrupt Controller.
	MCPWM_INTF_IMAT0_F_IF_THE_CORRESPONDING = 0x1
	// Position of ICAP0_F field.
	MCPWM_INTF_ICAP0_F_Pos = 0x2
	// Bit mask of ICAP0_F field.
	MCPWM_INTF_ICAP0_F_Msk = 0x4
	// Bit ICAP0_F.
	MCPWM_INTF_ICAP0_F = 0x4
	// This interrupt source is not contributing to the MCPWM interrupt request.
	MCPWM_INTF_ICAP0_F_THIS_INTERRUPT_SOURC = 0x0
	// If the corresponding bit in INTEN is 1, the MCPWM module is asserting its interrupt request to the Interrupt Controller.
	MCPWM_INTF_ICAP0_F_IF_THE_CORRESPONDING = 0x1
	// Position of RESERVED field.
	MCPWM_INTF_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	MCPWM_INTF_RESERVED_Msk = 0x8
	// Bit RESERVED.
	MCPWM_INTF_RESERVED = 0x8
	// Position of ILIM1_F field.
	MCPWM_INTF_ILIM1_F_Pos = 0x4
	// Bit mask of ILIM1_F field.
	MCPWM_INTF_ILIM1_F_Msk = 0x10
	// Bit ILIM1_F.
	MCPWM_INTF_ILIM1_F = 0x10
	// This interrupt source is not contributing to the MCPWM interrupt request.
	MCPWM_INTF_ILIM1_F_THIS_INTERRUPT_SOURC = 0x0
	// If the corresponding bit in INTEN is 1, the MCPWM module is asserting its interrupt request to the Interrupt Controller.
	MCPWM_INTF_ILIM1_F_IF_THE_CORRESPONDING = 0x1
	// Position of IMAT1_F field.
	MCPWM_INTF_IMAT1_F_Pos = 0x5
	// Bit mask of IMAT1_F field.
	MCPWM_INTF_IMAT1_F_Msk = 0x20
	// Bit IMAT1_F.
	MCPWM_INTF_IMAT1_F = 0x20
	// This interrupt source is not contributing to the MCPWM interrupt request.
	MCPWM_INTF_IMAT1_F_THIS_INTERRUPT_SOURC = 0x0
	// If the corresponding bit in INTEN is 1, the MCPWM module is asserting its interrupt request to the Interrupt Controller.
	MCPWM_INTF_IMAT1_F_IF_THE_CORRESPONDING = 0x1
	// Position of ICAP1_F field.
	MCPWM_INTF_ICAP1_F_Pos = 0x6
	// Bit mask of ICAP1_F field.
	MCPWM_INTF_ICAP1_F_Msk = 0x40
	// Bit ICAP1_F.
	MCPWM_INTF_ICAP1_F = 0x40
	// This interrupt source is not contributing to the MCPWM interrupt request.
	MCPWM_INTF_ICAP1_F_THIS_INTERRUPT_SOURC = 0x0
	// If the corresponding bit in INTEN is 1, the MCPWM module is asserting its interrupt request to the Interrupt Controller.
	MCPWM_INTF_ICAP1_F_IF_THE_CORRESPONDING = 0x1
	// Position of RESERVED field.
	MCPWM_INTF_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	MCPWM_INTF_RESERVED_Msk = 0x80
	// Bit RESERVED.
	MCPWM_INTF_RESERVED = 0x80
	// Position of ILIM2_F field.
	MCPWM_INTF_ILIM2_F_Pos = 0x8
	// Bit mask of ILIM2_F field.
	MCPWM_INTF_ILIM2_F_Msk = 0x100
	// Bit ILIM2_F.
	MCPWM_INTF_ILIM2_F = 0x100
	// This interrupt source is not contributing to the MCPWM interrupt request.
	MCPWM_INTF_ILIM2_F_THIS_INTERRUPT_SOURC = 0x0
	// If the corresponding bit in INTEN is 1, the MCPWM module is asserting its interrupt request to the Interrupt Controller.
	MCPWM_INTF_ILIM2_F_IF_THE_CORRESPONDING = 0x1
	// Position of IMAT2_F field.
	MCPWM_INTF_IMAT2_F_Pos = 0x9
	// Bit mask of IMAT2_F field.
	MCPWM_INTF_IMAT2_F_Msk = 0x200
	// Bit IMAT2_F.
	MCPWM_INTF_IMAT2_F = 0x200
	// This interrupt source is not contributing to the MCPWM interrupt request.
	MCPWM_INTF_IMAT2_F_THIS_INTERRUPT_SOURC = 0x0
	// If the corresponding bit in INTEN is 1, the MCPWM module is asserting its interrupt request to the Interrupt Controller.
	MCPWM_INTF_IMAT2_F_IF_THE_CORRESPONDING = 0x1
	// Position of ICAP2_F field.
	MCPWM_INTF_ICAP2_F_Pos = 0xa
	// Bit mask of ICAP2_F field.
	MCPWM_INTF_ICAP2_F_Msk = 0x400
	// Bit ICAP2_F.
	MCPWM_INTF_ICAP2_F = 0x400
	// This interrupt source is not contributing to the MCPWM interrupt request.
	MCPWM_INTF_ICAP2_F_THIS_INTERRUPT_SOURC = 0x0
	// If the corresponding bit in INTEN is 1, the MCPWM module is asserting its interrupt request to the Interrupt Controller.
	MCPWM_INTF_ICAP2_F_IF_THE_CORRESPONDING = 0x1
	// Position of RESERVED field.
	MCPWM_INTF_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	MCPWM_INTF_RESERVED_Msk = 0x7800
	// Position of ABORT_F field.
	MCPWM_INTF_ABORT_F_Pos = 0xf
	// Bit mask of ABORT_F field.
	MCPWM_INTF_ABORT_F_Msk = 0x8000
	// Bit ABORT_F.
	MCPWM_INTF_ABORT_F = 0x8000
	// This interrupt source is not contributing to the MCPWM interrupt request.
	MCPWM_INTF_ABORT_F_THIS_INTERRUPT_SOURC = 0x0
	// If the corresponding bit in INTEN is 1, the MCPWM module is asserting its interrupt request to the Interrupt Controller.
	MCPWM_INTF_ABORT_F_IF_THE_CORRESPONDING = 0x1
	// Position of RESERVED field.
	MCPWM_INTF_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	MCPWM_INTF_RESERVED_Msk = 0xffff0000

	// INTF_SET: Interrupt flags set address
	// Position of ILIM0_F_SET field.
	MCPWM_INTF_SET_ILIM0_F_SET_Pos = 0x0
	// Bit mask of ILIM0_F_SET field.
	MCPWM_INTF_SET_ILIM0_F_SET_Msk = 0x1
	// Bit ILIM0_F_SET.
	MCPWM_INTF_SET_ILIM0_F_SET = 0x1
	// Position of IMAT0_F_SET field.
	MCPWM_INTF_SET_IMAT0_F_SET_Pos = 0x1
	// Bit mask of IMAT0_F_SET field.
	MCPWM_INTF_SET_IMAT0_F_SET_Msk = 0x2
	// Bit IMAT0_F_SET.
	MCPWM_INTF_SET_IMAT0_F_SET = 0x2
	// Position of ICAP0_F_SET field.
	MCPWM_INTF_SET_ICAP0_F_SET_Pos = 0x2
	// Bit mask of ICAP0_F_SET field.
	MCPWM_INTF_SET_ICAP0_F_SET_Msk = 0x4
	// Bit ICAP0_F_SET.
	MCPWM_INTF_SET_ICAP0_F_SET = 0x4
	// Position of RESERVED field.
	MCPWM_INTF_SET_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	MCPWM_INTF_SET_RESERVED_Msk = 0x8
	// Bit RESERVED.
	MCPWM_INTF_SET_RESERVED = 0x8
	// Position of ILIM1_F_SET field.
	MCPWM_INTF_SET_ILIM1_F_SET_Pos = 0x4
	// Bit mask of ILIM1_F_SET field.
	MCPWM_INTF_SET_ILIM1_F_SET_Msk = 0x10
	// Bit ILIM1_F_SET.
	MCPWM_INTF_SET_ILIM1_F_SET = 0x10
	// Position of IMAT1_F_SET field.
	MCPWM_INTF_SET_IMAT1_F_SET_Pos = 0x5
	// Bit mask of IMAT1_F_SET field.
	MCPWM_INTF_SET_IMAT1_F_SET_Msk = 0x20
	// Bit IMAT1_F_SET.
	MCPWM_INTF_SET_IMAT1_F_SET = 0x20
	// Position of ICAP1_F_SET field.
	MCPWM_INTF_SET_ICAP1_F_SET_Pos = 0x6
	// Bit mask of ICAP1_F_SET field.
	MCPWM_INTF_SET_ICAP1_F_SET_Msk = 0x40
	// Bit ICAP1_F_SET.
	MCPWM_INTF_SET_ICAP1_F_SET = 0x40
	// Position of RESERVED field.
	MCPWM_INTF_SET_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	MCPWM_INTF_SET_RESERVED_Msk = 0x80
	// Bit RESERVED.
	MCPWM_INTF_SET_RESERVED = 0x80
	// Position of ILIM2_F_SET field.
	MCPWM_INTF_SET_ILIM2_F_SET_Pos = 0x8
	// Bit mask of ILIM2_F_SET field.
	MCPWM_INTF_SET_ILIM2_F_SET_Msk = 0x100
	// Bit ILIM2_F_SET.
	MCPWM_INTF_SET_ILIM2_F_SET = 0x100
	// Position of IMAT2_F_SET field.
	MCPWM_INTF_SET_IMAT2_F_SET_Pos = 0x9
	// Bit mask of IMAT2_F_SET field.
	MCPWM_INTF_SET_IMAT2_F_SET_Msk = 0x200
	// Bit IMAT2_F_SET.
	MCPWM_INTF_SET_IMAT2_F_SET = 0x200
	// Position of ICAP2_F_SET field.
	MCPWM_INTF_SET_ICAP2_F_SET_Pos = 0xa
	// Bit mask of ICAP2_F_SET field.
	MCPWM_INTF_SET_ICAP2_F_SET_Msk = 0x400
	// Bit ICAP2_F_SET.
	MCPWM_INTF_SET_ICAP2_F_SET = 0x400
	// Position of RESERVED field.
	MCPWM_INTF_SET_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	MCPWM_INTF_SET_RESERVED_Msk = 0x7800
	// Position of ABORT_F_SET field.
	MCPWM_INTF_SET_ABORT_F_SET_Pos = 0xf
	// Bit mask of ABORT_F_SET field.
	MCPWM_INTF_SET_ABORT_F_SET_Msk = 0x8000
	// Bit ABORT_F_SET.
	MCPWM_INTF_SET_ABORT_F_SET = 0x8000
	// Position of RESERVED field.
	MCPWM_INTF_SET_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	MCPWM_INTF_SET_RESERVED_Msk = 0xffff0000

	// INTF_CLR: Interrupt flags clear address
	// Position of ILIM0_F_CLR field.
	MCPWM_INTF_CLR_ILIM0_F_CLR_Pos = 0x0
	// Bit mask of ILIM0_F_CLR field.
	MCPWM_INTF_CLR_ILIM0_F_CLR_Msk = 0x1
	// Bit ILIM0_F_CLR.
	MCPWM_INTF_CLR_ILIM0_F_CLR = 0x1
	// Position of IMAT0_F_CLR field.
	MCPWM_INTF_CLR_IMAT0_F_CLR_Pos = 0x1
	// Bit mask of IMAT0_F_CLR field.
	MCPWM_INTF_CLR_IMAT0_F_CLR_Msk = 0x2
	// Bit IMAT0_F_CLR.
	MCPWM_INTF_CLR_IMAT0_F_CLR = 0x2
	// Position of ICAP0_F_CLR field.
	MCPWM_INTF_CLR_ICAP0_F_CLR_Pos = 0x2
	// Bit mask of ICAP0_F_CLR field.
	MCPWM_INTF_CLR_ICAP0_F_CLR_Msk = 0x4
	// Bit ICAP0_F_CLR.
	MCPWM_INTF_CLR_ICAP0_F_CLR = 0x4
	// Position of RESERVED field.
	MCPWM_INTF_CLR_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	MCPWM_INTF_CLR_RESERVED_Msk = 0x8
	// Bit RESERVED.
	MCPWM_INTF_CLR_RESERVED = 0x8
	// Position of ILIM1_F_CLR field.
	MCPWM_INTF_CLR_ILIM1_F_CLR_Pos = 0x4
	// Bit mask of ILIM1_F_CLR field.
	MCPWM_INTF_CLR_ILIM1_F_CLR_Msk = 0x10
	// Bit ILIM1_F_CLR.
	MCPWM_INTF_CLR_ILIM1_F_CLR = 0x10
	// Position of IMAT1_F_CLR field.
	MCPWM_INTF_CLR_IMAT1_F_CLR_Pos = 0x5
	// Bit mask of IMAT1_F_CLR field.
	MCPWM_INTF_CLR_IMAT1_F_CLR_Msk = 0x20
	// Bit IMAT1_F_CLR.
	MCPWM_INTF_CLR_IMAT1_F_CLR = 0x20
	// Position of ICAP1_F_CLR field.
	MCPWM_INTF_CLR_ICAP1_F_CLR_Pos = 0x6
	// Bit mask of ICAP1_F_CLR field.
	MCPWM_INTF_CLR_ICAP1_F_CLR_Msk = 0x40
	// Bit ICAP1_F_CLR.
	MCPWM_INTF_CLR_ICAP1_F_CLR = 0x40
	// Position of RESERVED field.
	MCPWM_INTF_CLR_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	MCPWM_INTF_CLR_RESERVED_Msk = 0x80
	// Bit RESERVED.
	MCPWM_INTF_CLR_RESERVED = 0x80
	// Position of ILIM2_F_CLR field.
	MCPWM_INTF_CLR_ILIM2_F_CLR_Pos = 0x8
	// Bit mask of ILIM2_F_CLR field.
	MCPWM_INTF_CLR_ILIM2_F_CLR_Msk = 0x100
	// Bit ILIM2_F_CLR.
	MCPWM_INTF_CLR_ILIM2_F_CLR = 0x100
	// Position of IMAT2_F_CLR field.
	MCPWM_INTF_CLR_IMAT2_F_CLR_Pos = 0x9
	// Bit mask of IMAT2_F_CLR field.
	MCPWM_INTF_CLR_IMAT2_F_CLR_Msk = 0x200
	// Bit IMAT2_F_CLR.
	MCPWM_INTF_CLR_IMAT2_F_CLR = 0x200
	// Position of ICAP2_F_CLR field.
	MCPWM_INTF_CLR_ICAP2_F_CLR_Pos = 0xa
	// Bit mask of ICAP2_F_CLR field.
	MCPWM_INTF_CLR_ICAP2_F_CLR_Msk = 0x400
	// Bit ICAP2_F_CLR.
	MCPWM_INTF_CLR_ICAP2_F_CLR = 0x400
	// Position of RESERVED field.
	MCPWM_INTF_CLR_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	MCPWM_INTF_CLR_RESERVED_Msk = 0x7800
	// Position of ABORT_F_CLR field.
	MCPWM_INTF_CLR_ABORT_F_CLR_Pos = 0xf
	// Bit mask of ABORT_F_CLR field.
	MCPWM_INTF_CLR_ABORT_F_CLR_Msk = 0x8000
	// Bit ABORT_F_CLR.
	MCPWM_INTF_CLR_ABORT_F_CLR = 0x8000
	// Position of RESERVED field.
	MCPWM_INTF_CLR_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	MCPWM_INTF_CLR_RESERVED_Msk = 0xffff0000

	// CAP_CLR: Capture clear address
	// Position of CAP_CLR0 field.
	MCPWM_CAP_CLR_CAP_CLR0_Pos = 0x0
	// Bit mask of CAP_CLR0 field.
	MCPWM_CAP_CLR_CAP_CLR0_Msk = 0x1
	// Bit CAP_CLR0.
	MCPWM_CAP_CLR_CAP_CLR0 = 0x1
	// Position of CAP_CLR1 field.
	MCPWM_CAP_CLR_CAP_CLR1_Pos = 0x1
	// Bit mask of CAP_CLR1 field.
	MCPWM_CAP_CLR_CAP_CLR1_Msk = 0x2
	// Bit CAP_CLR1.
	MCPWM_CAP_CLR_CAP_CLR1 = 0x2
	// Position of CAP_CLR2 field.
	MCPWM_CAP_CLR_CAP_CLR2_Pos = 0x2
	// Bit mask of CAP_CLR2 field.
	MCPWM_CAP_CLR_CAP_CLR2_Msk = 0x4
	// Bit CAP_CLR2.
	MCPWM_CAP_CLR_CAP_CLR2 = 0x4
	// Position of RESERVED field.
	MCPWM_CAP_CLR_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	MCPWM_CAP_CLR_RESERVED_Msk = 0xfffffff8
)

// Constants for QEI: Quadrature Encoder Interface (QEI)
const (
	// CON: Control register
	// Position of RESP field.
	QEI_CON_RESP_Pos = 0x0
	// Bit mask of RESP field.
	QEI_CON_RESP_Msk = 0x1
	// Bit RESP.
	QEI_CON_RESP = 0x1
	// Position of RESPI field.
	QEI_CON_RESPI_Pos = 0x1
	// Bit mask of RESPI field.
	QEI_CON_RESPI_Msk = 0x2
	// Bit RESPI.
	QEI_CON_RESPI = 0x2
	// Position of RESV field.
	QEI_CON_RESV_Pos = 0x2
	// Bit mask of RESV field.
	QEI_CON_RESV_Msk = 0x4
	// Bit RESV.
	QEI_CON_RESV = 0x4
	// Position of RESI field.
	QEI_CON_RESI_Pos = 0x3
	// Bit mask of RESI field.
	QEI_CON_RESI_Msk = 0x8
	// Bit RESI.
	QEI_CON_RESI = 0x8
	// Position of RESERVED field.
	QEI_CON_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	QEI_CON_RESERVED_Msk = 0xfffffff0

	// STAT: Status register
	// Position of DIR field.
	QEI_STAT_DIR_Pos = 0x0
	// Bit mask of DIR field.
	QEI_STAT_DIR_Msk = 0x1
	// Bit DIR.
	QEI_STAT_DIR = 0x1
	// Position of RESERVED field.
	QEI_STAT_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	QEI_STAT_RESERVED_Msk = 0xfffffffe

	// CONF: Configuration register
	// Position of DIRINV field.
	QEI_CONF_DIRINV_Pos = 0x0
	// Bit mask of DIRINV field.
	QEI_CONF_DIRINV_Msk = 0x1
	// Bit DIRINV.
	QEI_CONF_DIRINV = 0x1
	// Position of SIGMODE field.
	QEI_CONF_SIGMODE_Pos = 0x1
	// Bit mask of SIGMODE field.
	QEI_CONF_SIGMODE_Msk = 0x2
	// Bit SIGMODE.
	QEI_CONF_SIGMODE = 0x2
	// Position of CAPMODE field.
	QEI_CONF_CAPMODE_Pos = 0x2
	// Bit mask of CAPMODE field.
	QEI_CONF_CAPMODE_Msk = 0x4
	// Bit CAPMODE.
	QEI_CONF_CAPMODE = 0x4
	// Position of INVINX field.
	QEI_CONF_INVINX_Pos = 0x3
	// Bit mask of INVINX field.
	QEI_CONF_INVINX_Msk = 0x8
	// Bit INVINX.
	QEI_CONF_INVINX = 0x8
	// Position of CRESPI field.
	QEI_CONF_CRESPI_Pos = 0x4
	// Bit mask of CRESPI field.
	QEI_CONF_CRESPI_Msk = 0x10
	// Bit CRESPI.
	QEI_CONF_CRESPI = 0x10
	// Position of RESERVED field.
	QEI_CONF_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	QEI_CONF_RESERVED_Msk = 0xffe0
	// Position of INXGATE field.
	QEI_CONF_INXGATE_Pos = 0x10
	// Bit mask of INXGATE field.
	QEI_CONF_INXGATE_Msk = 0xf0000
	// Position of RESERVED field.
	QEI_CONF_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	QEI_CONF_RESERVED_Msk = 0xfff00000

	// POS: Position register
	// Position of POS field.
	QEI_POS_POS_Pos = 0x0
	// Bit mask of POS field.
	QEI_POS_POS_Msk = 0xffffffff

	// MAXPOS: Maximum position register
	// Position of MAXPOS field.
	QEI_MAXPOS_MAXPOS_Pos = 0x0
	// Bit mask of MAXPOS field.
	QEI_MAXPOS_MAXPOS_Msk = 0xffffffff

	// CMPOS0: Position compare register 0
	// Position of PCMP0 field.
	QEI_CMPOS0_PCMP0_Pos = 0x0
	// Bit mask of PCMP0 field.
	QEI_CMPOS0_PCMP0_Msk = 0xffffffff

	// CMPOS1: Position compare register 1
	// Position of PCMP1 field.
	QEI_CMPOS1_PCMP1_Pos = 0x0
	// Bit mask of PCMP1 field.
	QEI_CMPOS1_PCMP1_Msk = 0xffffffff

	// CMPOS2: Position compare register 2
	// Position of PCMP2 field.
	QEI_CMPOS2_PCMP2_Pos = 0x0
	// Bit mask of PCMP2 field.
	QEI_CMPOS2_PCMP2_Msk = 0xffffffff

	// INXCNT: Index count register 0
	// Position of ENCPOS field.
	QEI_INXCNT_ENCPOS_Pos = 0x0
	// Bit mask of ENCPOS field.
	QEI_INXCNT_ENCPOS_Msk = 0xffffffff

	// INXCMP0: Index compare register 0
	// Position of ICMP0 field.
	QEI_INXCMP0_ICMP0_Pos = 0x0
	// Bit mask of ICMP0 field.
	QEI_INXCMP0_ICMP0_Msk = 0xffffffff

	// LOAD: Velocity timer reload register
	// Position of VELLOAD field.
	QEI_LOAD_VELLOAD_Pos = 0x0
	// Bit mask of VELLOAD field.
	QEI_LOAD_VELLOAD_Msk = 0xffffffff

	// TIME: Velocity timer register
	// Position of VELVAL field.
	QEI_TIME_VELVAL_Pos = 0x0
	// Bit mask of VELVAL field.
	QEI_TIME_VELVAL_Msk = 0xffffffff

	// VEL: Velocity counter register
	// Position of VELPC field.
	QEI_VEL_VELPC_Pos = 0x0
	// Bit mask of VELPC field.
	QEI_VEL_VELPC_Msk = 0xffffffff

	// CAP: Velocity capture register
	// Position of VELCAP field.
	QEI_CAP_VELCAP_Pos = 0x0
	// Bit mask of VELCAP field.
	QEI_CAP_VELCAP_Msk = 0xffffffff

	// VELCOMP: Velocity compare register
	// Position of VELPC field.
	QEI_VELCOMP_VELPC_Pos = 0x0
	// Bit mask of VELPC field.
	QEI_VELCOMP_VELPC_Msk = 0xffffffff

	// FILTERPHA: Digital filter register on PHA
	// Position of FILTA field.
	QEI_FILTERPHA_FILTA_Pos = 0x0
	// Bit mask of FILTA field.
	QEI_FILTERPHA_FILTA_Msk = 0xffffffff

	// FILTERPHB: Digital filter register on PHB
	// Position of FILTB field.
	QEI_FILTERPHB_FILTB_Pos = 0x0
	// Bit mask of FILTB field.
	QEI_FILTERPHB_FILTB_Msk = 0xffffffff

	// FILTERINX: Digital filter register on IDX
	// Position of FITLINX field.
	QEI_FILTERINX_FITLINX_Pos = 0x0
	// Bit mask of FITLINX field.
	QEI_FILTERINX_FITLINX_Msk = 0xffffffff

	// WINDOW: Index acceptance window register
	// Position of WINDOW field.
	QEI_WINDOW_WINDOW_Pos = 0x0
	// Bit mask of WINDOW field.
	QEI_WINDOW_WINDOW_Msk = 0xffffffff

	// INXCMP1: Index compare register 1
	// Position of ICMP1 field.
	QEI_INXCMP1_ICMP1_Pos = 0x0
	// Bit mask of ICMP1 field.
	QEI_INXCMP1_ICMP1_Msk = 0xffffffff

	// INXCMP2: Index compare register 2
	// Position of ICMP2 field.
	QEI_INXCMP2_ICMP2_Pos = 0x0
	// Bit mask of ICMP2 field.
	QEI_INXCMP2_ICMP2_Msk = 0xffffffff

	// IEC: Interrupt enable clear register
	// Position of INX_INT field.
	QEI_IEC_INX_INT_Pos = 0x0
	// Bit mask of INX_INT field.
	QEI_IEC_INX_INT_Msk = 0x1
	// Bit INX_INT.
	QEI_IEC_INX_INT = 0x1
	// Position of TIM_INT field.
	QEI_IEC_TIM_INT_Pos = 0x1
	// Bit mask of TIM_INT field.
	QEI_IEC_TIM_INT_Msk = 0x2
	// Bit TIM_INT.
	QEI_IEC_TIM_INT = 0x2
	// Position of VELC_INT field.
	QEI_IEC_VELC_INT_Pos = 0x2
	// Bit mask of VELC_INT field.
	QEI_IEC_VELC_INT_Msk = 0x4
	// Bit VELC_INT.
	QEI_IEC_VELC_INT = 0x4
	// Position of DIR_INT field.
	QEI_IEC_DIR_INT_Pos = 0x3
	// Bit mask of DIR_INT field.
	QEI_IEC_DIR_INT_Msk = 0x8
	// Bit DIR_INT.
	QEI_IEC_DIR_INT = 0x8
	// Position of ERR_INT field.
	QEI_IEC_ERR_INT_Pos = 0x4
	// Bit mask of ERR_INT field.
	QEI_IEC_ERR_INT_Msk = 0x10
	// Bit ERR_INT.
	QEI_IEC_ERR_INT = 0x10
	// Position of ENCLK_INT field.
	QEI_IEC_ENCLK_INT_Pos = 0x5
	// Bit mask of ENCLK_INT field.
	QEI_IEC_ENCLK_INT_Msk = 0x20
	// Bit ENCLK_INT.
	QEI_IEC_ENCLK_INT = 0x20
	// Position of POS0_INT field.
	QEI_IEC_POS0_INT_Pos = 0x6
	// Bit mask of POS0_INT field.
	QEI_IEC_POS0_INT_Msk = 0x40
	// Bit POS0_INT.
	QEI_IEC_POS0_INT = 0x40
	// Position of POS1_INT field.
	QEI_IEC_POS1_INT_Pos = 0x7
	// Bit mask of POS1_INT field.
	QEI_IEC_POS1_INT_Msk = 0x80
	// Bit POS1_INT.
	QEI_IEC_POS1_INT = 0x80
	// Position of POS2_INT field.
	QEI_IEC_POS2_INT_Pos = 0x8
	// Bit mask of POS2_INT field.
	QEI_IEC_POS2_INT_Msk = 0x100
	// Bit POS2_INT.
	QEI_IEC_POS2_INT = 0x100
	// Position of REV0_INT field.
	QEI_IEC_REV0_INT_Pos = 0x9
	// Bit mask of REV0_INT field.
	QEI_IEC_REV0_INT_Msk = 0x200
	// Bit REV0_INT.
	QEI_IEC_REV0_INT = 0x200
	// Position of POS0REV_INT field.
	QEI_IEC_POS0REV_INT_Pos = 0xa
	// Bit mask of POS0REV_INT field.
	QEI_IEC_POS0REV_INT_Msk = 0x400
	// Bit POS0REV_INT.
	QEI_IEC_POS0REV_INT = 0x400
	// Position of POS1REV_INT field.
	QEI_IEC_POS1REV_INT_Pos = 0xb
	// Bit mask of POS1REV_INT field.
	QEI_IEC_POS1REV_INT_Msk = 0x800
	// Bit POS1REV_INT.
	QEI_IEC_POS1REV_INT = 0x800
	// Position of POS2REV_INT field.
	QEI_IEC_POS2REV_INT_Pos = 0xc
	// Bit mask of POS2REV_INT field.
	QEI_IEC_POS2REV_INT_Msk = 0x1000
	// Bit POS2REV_INT.
	QEI_IEC_POS2REV_INT = 0x1000
	// Position of REV1_INT field.
	QEI_IEC_REV1_INT_Pos = 0xd
	// Bit mask of REV1_INT field.
	QEI_IEC_REV1_INT_Msk = 0x2000
	// Bit REV1_INT.
	QEI_IEC_REV1_INT = 0x2000
	// Position of REV2_INT field.
	QEI_IEC_REV2_INT_Pos = 0xe
	// Bit mask of REV2_INT field.
	QEI_IEC_REV2_INT_Msk = 0x4000
	// Bit REV2_INT.
	QEI_IEC_REV2_INT = 0x4000
	// Position of MAXPOS_INT field.
	QEI_IEC_MAXPOS_INT_Pos = 0xf
	// Bit mask of MAXPOS_INT field.
	QEI_IEC_MAXPOS_INT_Msk = 0x8000
	// Bit MAXPOS_INT.
	QEI_IEC_MAXPOS_INT = 0x8000
	// Position of RESERVED field.
	QEI_IEC_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	QEI_IEC_RESERVED_Msk = 0xffff0000

	// IES: Interrupt enable set register
	// Position of INX_INT field.
	QEI_IES_INX_INT_Pos = 0x0
	// Bit mask of INX_INT field.
	QEI_IES_INX_INT_Msk = 0x1
	// Bit INX_INT.
	QEI_IES_INX_INT = 0x1
	// Position of TIM_INT field.
	QEI_IES_TIM_INT_Pos = 0x1
	// Bit mask of TIM_INT field.
	QEI_IES_TIM_INT_Msk = 0x2
	// Bit TIM_INT.
	QEI_IES_TIM_INT = 0x2
	// Position of VELC_INT field.
	QEI_IES_VELC_INT_Pos = 0x2
	// Bit mask of VELC_INT field.
	QEI_IES_VELC_INT_Msk = 0x4
	// Bit VELC_INT.
	QEI_IES_VELC_INT = 0x4
	// Position of DIR_INT field.
	QEI_IES_DIR_INT_Pos = 0x3
	// Bit mask of DIR_INT field.
	QEI_IES_DIR_INT_Msk = 0x8
	// Bit DIR_INT.
	QEI_IES_DIR_INT = 0x8
	// Position of ERR_INT field.
	QEI_IES_ERR_INT_Pos = 0x4
	// Bit mask of ERR_INT field.
	QEI_IES_ERR_INT_Msk = 0x10
	// Bit ERR_INT.
	QEI_IES_ERR_INT = 0x10
	// Position of ENCLK_INT field.
	QEI_IES_ENCLK_INT_Pos = 0x5
	// Bit mask of ENCLK_INT field.
	QEI_IES_ENCLK_INT_Msk = 0x20
	// Bit ENCLK_INT.
	QEI_IES_ENCLK_INT = 0x20
	// Position of POS0_INT field.
	QEI_IES_POS0_INT_Pos = 0x6
	// Bit mask of POS0_INT field.
	QEI_IES_POS0_INT_Msk = 0x40
	// Bit POS0_INT.
	QEI_IES_POS0_INT = 0x40
	// Position of POS1_INT field.
	QEI_IES_POS1_INT_Pos = 0x7
	// Bit mask of POS1_INT field.
	QEI_IES_POS1_INT_Msk = 0x80
	// Bit POS1_INT.
	QEI_IES_POS1_INT = 0x80
	// Position of POS2_INT field.
	QEI_IES_POS2_INT_Pos = 0x8
	// Bit mask of POS2_INT field.
	QEI_IES_POS2_INT_Msk = 0x100
	// Bit POS2_INT.
	QEI_IES_POS2_INT = 0x100
	// Position of REV0_INT field.
	QEI_IES_REV0_INT_Pos = 0x9
	// Bit mask of REV0_INT field.
	QEI_IES_REV0_INT_Msk = 0x200
	// Bit REV0_INT.
	QEI_IES_REV0_INT = 0x200
	// Position of POS0REV_INT field.
	QEI_IES_POS0REV_INT_Pos = 0xa
	// Bit mask of POS0REV_INT field.
	QEI_IES_POS0REV_INT_Msk = 0x400
	// Bit POS0REV_INT.
	QEI_IES_POS0REV_INT = 0x400
	// Position of POS1REV_INT field.
	QEI_IES_POS1REV_INT_Pos = 0xb
	// Bit mask of POS1REV_INT field.
	QEI_IES_POS1REV_INT_Msk = 0x800
	// Bit POS1REV_INT.
	QEI_IES_POS1REV_INT = 0x800
	// Position of POS2REV_INT field.
	QEI_IES_POS2REV_INT_Pos = 0xc
	// Bit mask of POS2REV_INT field.
	QEI_IES_POS2REV_INT_Msk = 0x1000
	// Bit POS2REV_INT.
	QEI_IES_POS2REV_INT = 0x1000
	// Position of REV1_INT field.
	QEI_IES_REV1_INT_Pos = 0xd
	// Bit mask of REV1_INT field.
	QEI_IES_REV1_INT_Msk = 0x2000
	// Bit REV1_INT.
	QEI_IES_REV1_INT = 0x2000
	// Position of REV2_INT field.
	QEI_IES_REV2_INT_Pos = 0xe
	// Bit mask of REV2_INT field.
	QEI_IES_REV2_INT_Msk = 0x4000
	// Bit REV2_INT.
	QEI_IES_REV2_INT = 0x4000
	// Position of MAXPOS_INT field.
	QEI_IES_MAXPOS_INT_Pos = 0xf
	// Bit mask of MAXPOS_INT field.
	QEI_IES_MAXPOS_INT_Msk = 0x8000
	// Bit MAXPOS_INT.
	QEI_IES_MAXPOS_INT = 0x8000
	// Position of RESERVED field.
	QEI_IES_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	QEI_IES_RESERVED_Msk = 0xffff0000

	// INTSTAT: Interrupt status register
	// Position of INX_INT field.
	QEI_INTSTAT_INX_INT_Pos = 0x0
	// Bit mask of INX_INT field.
	QEI_INTSTAT_INX_INT_Msk = 0x1
	// Bit INX_INT.
	QEI_INTSTAT_INX_INT = 0x1
	// Position of TIM_INT field.
	QEI_INTSTAT_TIM_INT_Pos = 0x1
	// Bit mask of TIM_INT field.
	QEI_INTSTAT_TIM_INT_Msk = 0x2
	// Bit TIM_INT.
	QEI_INTSTAT_TIM_INT = 0x2
	// Position of VELC_INT field.
	QEI_INTSTAT_VELC_INT_Pos = 0x2
	// Bit mask of VELC_INT field.
	QEI_INTSTAT_VELC_INT_Msk = 0x4
	// Bit VELC_INT.
	QEI_INTSTAT_VELC_INT = 0x4
	// Position of DIR_INT field.
	QEI_INTSTAT_DIR_INT_Pos = 0x3
	// Bit mask of DIR_INT field.
	QEI_INTSTAT_DIR_INT_Msk = 0x8
	// Bit DIR_INT.
	QEI_INTSTAT_DIR_INT = 0x8
	// Position of ERR_INT field.
	QEI_INTSTAT_ERR_INT_Pos = 0x4
	// Bit mask of ERR_INT field.
	QEI_INTSTAT_ERR_INT_Msk = 0x10
	// Bit ERR_INT.
	QEI_INTSTAT_ERR_INT = 0x10
	// Position of ENCLK_INT field.
	QEI_INTSTAT_ENCLK_INT_Pos = 0x5
	// Bit mask of ENCLK_INT field.
	QEI_INTSTAT_ENCLK_INT_Msk = 0x20
	// Bit ENCLK_INT.
	QEI_INTSTAT_ENCLK_INT = 0x20
	// Position of POS0_INT field.
	QEI_INTSTAT_POS0_INT_Pos = 0x6
	// Bit mask of POS0_INT field.
	QEI_INTSTAT_POS0_INT_Msk = 0x40
	// Bit POS0_INT.
	QEI_INTSTAT_POS0_INT = 0x40
	// Position of POS1_INT field.
	QEI_INTSTAT_POS1_INT_Pos = 0x7
	// Bit mask of POS1_INT field.
	QEI_INTSTAT_POS1_INT_Msk = 0x80
	// Bit POS1_INT.
	QEI_INTSTAT_POS1_INT = 0x80
	// Position of POS2_INT field.
	QEI_INTSTAT_POS2_INT_Pos = 0x8
	// Bit mask of POS2_INT field.
	QEI_INTSTAT_POS2_INT_Msk = 0x100
	// Bit POS2_INT.
	QEI_INTSTAT_POS2_INT = 0x100
	// Position of REV0_INT field.
	QEI_INTSTAT_REV0_INT_Pos = 0x9
	// Bit mask of REV0_INT field.
	QEI_INTSTAT_REV0_INT_Msk = 0x200
	// Bit REV0_INT.
	QEI_INTSTAT_REV0_INT = 0x200
	// Position of POS0REV_INT field.
	QEI_INTSTAT_POS0REV_INT_Pos = 0xa
	// Bit mask of POS0REV_INT field.
	QEI_INTSTAT_POS0REV_INT_Msk = 0x400
	// Bit POS0REV_INT.
	QEI_INTSTAT_POS0REV_INT = 0x400
	// Position of POS1REV_INT field.
	QEI_INTSTAT_POS1REV_INT_Pos = 0xb
	// Bit mask of POS1REV_INT field.
	QEI_INTSTAT_POS1REV_INT_Msk = 0x800
	// Bit POS1REV_INT.
	QEI_INTSTAT_POS1REV_INT = 0x800
	// Position of POS2REV_INT field.
	QEI_INTSTAT_POS2REV_INT_Pos = 0xc
	// Bit mask of POS2REV_INT field.
	QEI_INTSTAT_POS2REV_INT_Msk = 0x1000
	// Bit POS2REV_INT.
	QEI_INTSTAT_POS2REV_INT = 0x1000
	// Position of REV1_INT field.
	QEI_INTSTAT_REV1_INT_Pos = 0xd
	// Bit mask of REV1_INT field.
	QEI_INTSTAT_REV1_INT_Msk = 0x2000
	// Bit REV1_INT.
	QEI_INTSTAT_REV1_INT = 0x2000
	// Position of REV2_INT field.
	QEI_INTSTAT_REV2_INT_Pos = 0xe
	// Bit mask of REV2_INT field.
	QEI_INTSTAT_REV2_INT_Msk = 0x4000
	// Bit REV2_INT.
	QEI_INTSTAT_REV2_INT = 0x4000
	// Position of MAXPOS_INT field.
	QEI_INTSTAT_MAXPOS_INT_Pos = 0xf
	// Bit mask of MAXPOS_INT field.
	QEI_INTSTAT_MAXPOS_INT_Msk = 0x8000
	// Bit MAXPOS_INT.
	QEI_INTSTAT_MAXPOS_INT = 0x8000
	// Position of RESERVED field.
	QEI_INTSTAT_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	QEI_INTSTAT_RESERVED_Msk = 0xffff0000

	// IE: Interrupt enable register
	// Position of INX_INT field.
	QEI_IE_INX_INT_Pos = 0x0
	// Bit mask of INX_INT field.
	QEI_IE_INX_INT_Msk = 0x1
	// Bit INX_INT.
	QEI_IE_INX_INT = 0x1
	// Position of TIM_INT field.
	QEI_IE_TIM_INT_Pos = 0x1
	// Bit mask of TIM_INT field.
	QEI_IE_TIM_INT_Msk = 0x2
	// Bit TIM_INT.
	QEI_IE_TIM_INT = 0x2
	// Position of VELC_INT field.
	QEI_IE_VELC_INT_Pos = 0x2
	// Bit mask of VELC_INT field.
	QEI_IE_VELC_INT_Msk = 0x4
	// Bit VELC_INT.
	QEI_IE_VELC_INT = 0x4
	// Position of DIR_INT field.
	QEI_IE_DIR_INT_Pos = 0x3
	// Bit mask of DIR_INT field.
	QEI_IE_DIR_INT_Msk = 0x8
	// Bit DIR_INT.
	QEI_IE_DIR_INT = 0x8
	// Position of ERR_INT field.
	QEI_IE_ERR_INT_Pos = 0x4
	// Bit mask of ERR_INT field.
	QEI_IE_ERR_INT_Msk = 0x10
	// Bit ERR_INT.
	QEI_IE_ERR_INT = 0x10
	// Position of ENCLK_INT field.
	QEI_IE_ENCLK_INT_Pos = 0x5
	// Bit mask of ENCLK_INT field.
	QEI_IE_ENCLK_INT_Msk = 0x20
	// Bit ENCLK_INT.
	QEI_IE_ENCLK_INT = 0x20
	// Position of POS0_INT field.
	QEI_IE_POS0_INT_Pos = 0x6
	// Bit mask of POS0_INT field.
	QEI_IE_POS0_INT_Msk = 0x40
	// Bit POS0_INT.
	QEI_IE_POS0_INT = 0x40
	// Position of POS1_INT field.
	QEI_IE_POS1_INT_Pos = 0x7
	// Bit mask of POS1_INT field.
	QEI_IE_POS1_INT_Msk = 0x80
	// Bit POS1_INT.
	QEI_IE_POS1_INT = 0x80
	// Position of POS2_INT field.
	QEI_IE_POS2_INT_Pos = 0x8
	// Bit mask of POS2_INT field.
	QEI_IE_POS2_INT_Msk = 0x100
	// Bit POS2_INT.
	QEI_IE_POS2_INT = 0x100
	// Position of REV0_INT field.
	QEI_IE_REV0_INT_Pos = 0x9
	// Bit mask of REV0_INT field.
	QEI_IE_REV0_INT_Msk = 0x200
	// Bit REV0_INT.
	QEI_IE_REV0_INT = 0x200
	// Position of POS0REV_INT field.
	QEI_IE_POS0REV_INT_Pos = 0xa
	// Bit mask of POS0REV_INT field.
	QEI_IE_POS0REV_INT_Msk = 0x400
	// Bit POS0REV_INT.
	QEI_IE_POS0REV_INT = 0x400
	// Position of POS1REV_INT field.
	QEI_IE_POS1REV_INT_Pos = 0xb
	// Bit mask of POS1REV_INT field.
	QEI_IE_POS1REV_INT_Msk = 0x800
	// Bit POS1REV_INT.
	QEI_IE_POS1REV_INT = 0x800
	// Position of POS2REV_INT field.
	QEI_IE_POS2REV_INT_Pos = 0xc
	// Bit mask of POS2REV_INT field.
	QEI_IE_POS2REV_INT_Msk = 0x1000
	// Bit POS2REV_INT.
	QEI_IE_POS2REV_INT = 0x1000
	// Position of REV1_INT field.
	QEI_IE_REV1_INT_Pos = 0xd
	// Bit mask of REV1_INT field.
	QEI_IE_REV1_INT_Msk = 0x2000
	// Bit REV1_INT.
	QEI_IE_REV1_INT = 0x2000
	// Position of REV2_INT field.
	QEI_IE_REV2_INT_Pos = 0xe
	// Bit mask of REV2_INT field.
	QEI_IE_REV2_INT_Msk = 0x4000
	// Bit REV2_INT.
	QEI_IE_REV2_INT = 0x4000
	// Position of MAXPOS_INT field.
	QEI_IE_MAXPOS_INT_Pos = 0xf
	// Bit mask of MAXPOS_INT field.
	QEI_IE_MAXPOS_INT_Msk = 0x8000
	// Bit MAXPOS_INT.
	QEI_IE_MAXPOS_INT = 0x8000
	// Position of RESERVED field.
	QEI_IE_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	QEI_IE_RESERVED_Msk = 0xffff0000

	// CLR: Interrupt status clear register
	// Position of INX_INT field.
	QEI_CLR_INX_INT_Pos = 0x0
	// Bit mask of INX_INT field.
	QEI_CLR_INX_INT_Msk = 0x1
	// Bit INX_INT.
	QEI_CLR_INX_INT = 0x1
	// Position of TIM_INT field.
	QEI_CLR_TIM_INT_Pos = 0x1
	// Bit mask of TIM_INT field.
	QEI_CLR_TIM_INT_Msk = 0x2
	// Bit TIM_INT.
	QEI_CLR_TIM_INT = 0x2
	// Position of VELC_INT field.
	QEI_CLR_VELC_INT_Pos = 0x2
	// Bit mask of VELC_INT field.
	QEI_CLR_VELC_INT_Msk = 0x4
	// Bit VELC_INT.
	QEI_CLR_VELC_INT = 0x4
	// Position of DIR_INT field.
	QEI_CLR_DIR_INT_Pos = 0x3
	// Bit mask of DIR_INT field.
	QEI_CLR_DIR_INT_Msk = 0x8
	// Bit DIR_INT.
	QEI_CLR_DIR_INT = 0x8
	// Position of ERR_INT field.
	QEI_CLR_ERR_INT_Pos = 0x4
	// Bit mask of ERR_INT field.
	QEI_CLR_ERR_INT_Msk = 0x10
	// Bit ERR_INT.
	QEI_CLR_ERR_INT = 0x10
	// Position of ENCLK_INT field.
	QEI_CLR_ENCLK_INT_Pos = 0x5
	// Bit mask of ENCLK_INT field.
	QEI_CLR_ENCLK_INT_Msk = 0x20
	// Bit ENCLK_INT.
	QEI_CLR_ENCLK_INT = 0x20
	// Position of POS0_INT field.
	QEI_CLR_POS0_INT_Pos = 0x6
	// Bit mask of POS0_INT field.
	QEI_CLR_POS0_INT_Msk = 0x40
	// Bit POS0_INT.
	QEI_CLR_POS0_INT = 0x40
	// Position of POS1_INT field.
	QEI_CLR_POS1_INT_Pos = 0x7
	// Bit mask of POS1_INT field.
	QEI_CLR_POS1_INT_Msk = 0x80
	// Bit POS1_INT.
	QEI_CLR_POS1_INT = 0x80
	// Position of POS2_INT field.
	QEI_CLR_POS2_INT_Pos = 0x8
	// Bit mask of POS2_INT field.
	QEI_CLR_POS2_INT_Msk = 0x100
	// Bit POS2_INT.
	QEI_CLR_POS2_INT = 0x100
	// Position of REV0_INT field.
	QEI_CLR_REV0_INT_Pos = 0x9
	// Bit mask of REV0_INT field.
	QEI_CLR_REV0_INT_Msk = 0x200
	// Bit REV0_INT.
	QEI_CLR_REV0_INT = 0x200
	// Position of POS0REV_INT field.
	QEI_CLR_POS0REV_INT_Pos = 0xa
	// Bit mask of POS0REV_INT field.
	QEI_CLR_POS0REV_INT_Msk = 0x400
	// Bit POS0REV_INT.
	QEI_CLR_POS0REV_INT = 0x400
	// Position of POS1REV_INT field.
	QEI_CLR_POS1REV_INT_Pos = 0xb
	// Bit mask of POS1REV_INT field.
	QEI_CLR_POS1REV_INT_Msk = 0x800
	// Bit POS1REV_INT.
	QEI_CLR_POS1REV_INT = 0x800
	// Position of POS2REV_INT field.
	QEI_CLR_POS2REV_INT_Pos = 0xc
	// Bit mask of POS2REV_INT field.
	QEI_CLR_POS2REV_INT_Msk = 0x1000
	// Bit POS2REV_INT.
	QEI_CLR_POS2REV_INT = 0x1000
	// Position of REV1_INT field.
	QEI_CLR_REV1_INT_Pos = 0xd
	// Bit mask of REV1_INT field.
	QEI_CLR_REV1_INT_Msk = 0x2000
	// Bit REV1_INT.
	QEI_CLR_REV1_INT = 0x2000
	// Position of REV2_INT field.
	QEI_CLR_REV2_INT_Pos = 0xe
	// Bit mask of REV2_INT field.
	QEI_CLR_REV2_INT_Msk = 0x4000
	// Bit REV2_INT.
	QEI_CLR_REV2_INT = 0x4000
	// Position of MAXPOS_INT field.
	QEI_CLR_MAXPOS_INT_Pos = 0xf
	// Bit mask of MAXPOS_INT field.
	QEI_CLR_MAXPOS_INT_Msk = 0x8000
	// Bit MAXPOS_INT.
	QEI_CLR_MAXPOS_INT = 0x8000
	// Position of RESERVED field.
	QEI_CLR_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	QEI_CLR_RESERVED_Msk = 0xffff0000

	// SET: Interrupt status set register
	// Position of INX_INT field.
	QEI_SET_INX_INT_Pos = 0x0
	// Bit mask of INX_INT field.
	QEI_SET_INX_INT_Msk = 0x1
	// Bit INX_INT.
	QEI_SET_INX_INT = 0x1
	// Position of TIM_INT field.
	QEI_SET_TIM_INT_Pos = 0x1
	// Bit mask of TIM_INT field.
	QEI_SET_TIM_INT_Msk = 0x2
	// Bit TIM_INT.
	QEI_SET_TIM_INT = 0x2
	// Position of VELC_INT field.
	QEI_SET_VELC_INT_Pos = 0x2
	// Bit mask of VELC_INT field.
	QEI_SET_VELC_INT_Msk = 0x4
	// Bit VELC_INT.
	QEI_SET_VELC_INT = 0x4
	// Position of DIR_INT field.
	QEI_SET_DIR_INT_Pos = 0x3
	// Bit mask of DIR_INT field.
	QEI_SET_DIR_INT_Msk = 0x8
	// Bit DIR_INT.
	QEI_SET_DIR_INT = 0x8
	// Position of ERR_INT field.
	QEI_SET_ERR_INT_Pos = 0x4
	// Bit mask of ERR_INT field.
	QEI_SET_ERR_INT_Msk = 0x10
	// Bit ERR_INT.
	QEI_SET_ERR_INT = 0x10
	// Position of ENCLK_INT field.
	QEI_SET_ENCLK_INT_Pos = 0x5
	// Bit mask of ENCLK_INT field.
	QEI_SET_ENCLK_INT_Msk = 0x20
	// Bit ENCLK_INT.
	QEI_SET_ENCLK_INT = 0x20
	// Position of POS0_INT field.
	QEI_SET_POS0_INT_Pos = 0x6
	// Bit mask of POS0_INT field.
	QEI_SET_POS0_INT_Msk = 0x40
	// Bit POS0_INT.
	QEI_SET_POS0_INT = 0x40
	// Position of POS1_INT field.
	QEI_SET_POS1_INT_Pos = 0x7
	// Bit mask of POS1_INT field.
	QEI_SET_POS1_INT_Msk = 0x80
	// Bit POS1_INT.
	QEI_SET_POS1_INT = 0x80
	// Position of POS2_INT field.
	QEI_SET_POS2_INT_Pos = 0x8
	// Bit mask of POS2_INT field.
	QEI_SET_POS2_INT_Msk = 0x100
	// Bit POS2_INT.
	QEI_SET_POS2_INT = 0x100
	// Position of REV0_INT field.
	QEI_SET_REV0_INT_Pos = 0x9
	// Bit mask of REV0_INT field.
	QEI_SET_REV0_INT_Msk = 0x200
	// Bit REV0_INT.
	QEI_SET_REV0_INT = 0x200
	// Position of POS0REV_INT field.
	QEI_SET_POS0REV_INT_Pos = 0xa
	// Bit mask of POS0REV_INT field.
	QEI_SET_POS0REV_INT_Msk = 0x400
	// Bit POS0REV_INT.
	QEI_SET_POS0REV_INT = 0x400
	// Position of POS1REV_INT field.
	QEI_SET_POS1REV_INT_Pos = 0xb
	// Bit mask of POS1REV_INT field.
	QEI_SET_POS1REV_INT_Msk = 0x800
	// Bit POS1REV_INT.
	QEI_SET_POS1REV_INT = 0x800
	// Position of POS2REV_INT field.
	QEI_SET_POS2REV_INT_Pos = 0xc
	// Bit mask of POS2REV_INT field.
	QEI_SET_POS2REV_INT_Msk = 0x1000
	// Bit POS2REV_INT.
	QEI_SET_POS2REV_INT = 0x1000
	// Position of REV1_INT field.
	QEI_SET_REV1_INT_Pos = 0xd
	// Bit mask of REV1_INT field.
	QEI_SET_REV1_INT_Msk = 0x2000
	// Bit REV1_INT.
	QEI_SET_REV1_INT = 0x2000
	// Position of REV2_INT field.
	QEI_SET_REV2_INT_Pos = 0xe
	// Bit mask of REV2_INT field.
	QEI_SET_REV2_INT_Msk = 0x4000
	// Bit REV2_INT.
	QEI_SET_REV2_INT = 0x4000
	// Position of MAXPOS_INT field.
	QEI_SET_MAXPOS_INT_Pos = 0xf
	// Bit mask of MAXPOS_INT field.
	QEI_SET_MAXPOS_INT_Msk = 0x8000
	// Bit MAXPOS_INT.
	QEI_SET_MAXPOS_INT = 0x8000
	// Position of RESERVED field.
	QEI_SET_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	QEI_SET_RESERVED_Msk = 0xffff0000
)

// Constants for SDMMC: SD card
const (
	// PWR: Power control register.
	// Position of CTRL field.
	SDMMC_PWR_CTRL_Pos = 0x0
	// Bit mask of CTRL field.
	SDMMC_PWR_CTRL_Msk = 0x3
	// Power-off
	SDMMC_PWR_CTRL_POWER_OFF = 0x0
	// Power-up
	SDMMC_PWR_CTRL_POWER_UP = 0x2
	// Power-on
	SDMMC_PWR_CTRL_POWER_ON = 0x3
	// Position of RESERVED field.
	SDMMC_PWR_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	SDMMC_PWR_RESERVED_Msk = 0x3c
	// Position of OPENDRAIN field.
	SDMMC_PWR_OPENDRAIN_Pos = 0x6
	// Bit mask of OPENDRAIN field.
	SDMMC_PWR_OPENDRAIN_Msk = 0x40
	// Bit OPENDRAIN.
	SDMMC_PWR_OPENDRAIN = 0x40
	// Position of ROD field.
	SDMMC_PWR_ROD_Pos = 0x7
	// Bit mask of ROD field.
	SDMMC_PWR_ROD_Msk = 0x80
	// Bit ROD.
	SDMMC_PWR_ROD = 0x80
	// Position of RESERVED field.
	SDMMC_PWR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SDMMC_PWR_RESERVED_Msk = 0xffffff00

	// CLOCK: Clock control register.
	// Position of CLKDIV field.
	SDMMC_CLOCK_CLKDIV_Pos = 0x0
	// Bit mask of CLKDIV field.
	SDMMC_CLOCK_CLKDIV_Msk = 0xff
	// Position of ENABLE field.
	SDMMC_CLOCK_ENABLE_Pos = 0x8
	// Bit mask of ENABLE field.
	SDMMC_CLOCK_ENABLE_Msk = 0x100
	// Bit ENABLE.
	SDMMC_CLOCK_ENABLE = 0x100
	// Clock disabled.
	SDMMC_CLOCK_ENABLE_CLOCK_DISABLED_ = 0x0
	// Clock enabled.
	SDMMC_CLOCK_ENABLE_CLOCK_ENABLED_ = 0x1
	// Position of PWRSAVE field.
	SDMMC_CLOCK_PWRSAVE_Pos = 0x9
	// Bit mask of PWRSAVE field.
	SDMMC_CLOCK_PWRSAVE_Msk = 0x200
	// Bit PWRSAVE.
	SDMMC_CLOCK_PWRSAVE = 0x200
	// Always enabled.
	SDMMC_CLOCK_PWRSAVE_ALWAYS_ENABLED_ = 0x0
	// Clock enabled when bus is active.
	SDMMC_CLOCK_PWRSAVE_CLOCK_ENABLED_WHEN_B = 0x1
	// Position of BYPASS field.
	SDMMC_CLOCK_BYPASS_Pos = 0xa
	// Bit mask of BYPASS field.
	SDMMC_CLOCK_BYPASS_Msk = 0x400
	// Bit BYPASS.
	SDMMC_CLOCK_BYPASS = 0x400
	// Disable bypass.
	SDMMC_CLOCK_BYPASS_DISABLE_BYPASS_ = 0x0
	// Enable bypass. MCLK driven to card bus output (SD_CLK).
	SDMMC_CLOCK_BYPASS_ENABLE_BYPASS_MCLK_ = 0x1
	// Position of WIDEBUS field.
	SDMMC_CLOCK_WIDEBUS_Pos = 0xb
	// Bit mask of WIDEBUS field.
	SDMMC_CLOCK_WIDEBUS_Msk = 0x800
	// Bit WIDEBUS.
	SDMMC_CLOCK_WIDEBUS = 0x800
	// Standard bus mode (only SD_DAT[0] used).
	SDMMC_CLOCK_WIDEBUS_STANDARD_BUS_MODE_O = 0x0
	// Wide bus mode (SD_DAT[3:0] used)
	SDMMC_CLOCK_WIDEBUS_WIDE_BUS_MODE_SD_DA = 0x1
	// Position of RESERVED field.
	SDMMC_CLOCK_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	SDMMC_CLOCK_RESERVED_Msk = 0xfffff000

	// ARGUMENT: Argument register.
	// Position of CmdArg field.
	SDMMC_ARGUMENT_CmdArg_Pos = 0x0
	// Bit mask of CmdArg field.
	SDMMC_ARGUMENT_CmdArg_Msk = 0xffffffff

	// COMMAND: Command register.
	// Position of CmdIndex field.
	SDMMC_COMMAND_CmdIndex_Pos = 0x0
	// Bit mask of CmdIndex field.
	SDMMC_COMMAND_CmdIndex_Msk = 0x3f
	// Position of Response field.
	SDMMC_COMMAND_Response_Pos = 0x6
	// Bit mask of Response field.
	SDMMC_COMMAND_Response_Msk = 0x40
	// Bit Response.
	SDMMC_COMMAND_Response = 0x40
	// Position of LongRsp field.
	SDMMC_COMMAND_LongRsp_Pos = 0x7
	// Bit mask of LongRsp field.
	SDMMC_COMMAND_LongRsp_Msk = 0x80
	// Bit LongRsp.
	SDMMC_COMMAND_LongRsp = 0x80
	// Position of Interrupt field.
	SDMMC_COMMAND_Interrupt_Pos = 0x8
	// Bit mask of Interrupt field.
	SDMMC_COMMAND_Interrupt_Msk = 0x100
	// Bit Interrupt.
	SDMMC_COMMAND_Interrupt = 0x100
	// Position of Pending field.
	SDMMC_COMMAND_Pending_Pos = 0x9
	// Bit mask of Pending field.
	SDMMC_COMMAND_Pending_Msk = 0x200
	// Bit Pending.
	SDMMC_COMMAND_Pending = 0x200
	// Position of Enable field.
	SDMMC_COMMAND_Enable_Pos = 0xa
	// Bit mask of Enable field.
	SDMMC_COMMAND_Enable_Msk = 0x400
	// Bit Enable.
	SDMMC_COMMAND_Enable = 0x400
	// Position of RESERVED field.
	SDMMC_COMMAND_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	SDMMC_COMMAND_RESERVED_Msk = 0xfffff800

	// RESPCMD: Response command register.
	// Position of RESPCMD field.
	SDMMC_RESPCMD_RESPCMD_Pos = 0x0
	// Bit mask of RESPCMD field.
	SDMMC_RESPCMD_RESPCMD_Msk = 0x3f
	// Position of RESERVED field.
	SDMMC_RESPCMD_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	SDMMC_RESPCMD_RESERVED_Msk = 0xffffffc0

	// RESPONSE0: Response register.
	// Position of STATUS field.
	SDMMC_RESPONSE_STATUS_Pos = 0x0
	// Bit mask of STATUS field.
	SDMMC_RESPONSE_STATUS_Msk = 0xffffffff

	// DATATIMER: Data Timer.
	// Position of DATATIME field.
	SDMMC_DATATIMER_DATATIME_Pos = 0x0
	// Bit mask of DATATIME field.
	SDMMC_DATATIMER_DATATIME_Msk = 0xffffffff

	// DATALENGTH: Data length register.
	// Position of DATALENGTH field.
	SDMMC_DATALENGTH_DATALENGTH_Pos = 0x0
	// Bit mask of DATALENGTH field.
	SDMMC_DATALENGTH_DATALENGTH_Msk = 0xffff
	// Position of RESERVED field.
	SDMMC_DATALENGTH_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	SDMMC_DATALENGTH_RESERVED_Msk = 0xffff0000

	// DATACTRL: Data control register.
	// Position of ENABLE field.
	SDMMC_DATACTRL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	SDMMC_DATACTRL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	SDMMC_DATACTRL_ENABLE = 0x1
	// Position of DIRECTION field.
	SDMMC_DATACTRL_DIRECTION_Pos = 0x1
	// Bit mask of DIRECTION field.
	SDMMC_DATACTRL_DIRECTION_Msk = 0x2
	// Bit DIRECTION.
	SDMMC_DATACTRL_DIRECTION = 0x2
	// From controller to card.
	SDMMC_DATACTRL_DIRECTION_FROM_CONTROLLER_TO_C = 0x0
	// From card to controller.
	SDMMC_DATACTRL_DIRECTION_FROM_CARD_TO_CONTROL = 0x1
	// Position of MODE field.
	SDMMC_DATACTRL_MODE_Pos = 0x2
	// Bit mask of MODE field.
	SDMMC_DATACTRL_MODE_Msk = 0x4
	// Bit MODE.
	SDMMC_DATACTRL_MODE = 0x4
	// Block data transfer.
	SDMMC_DATACTRL_MODE_BLOCK_DATA_TRANSFER_ = 0x0
	// Stream data transfer.
	SDMMC_DATACTRL_MODE_STREAM_DATA_TRANSFER = 0x1
	// Position of DMAENABLE field.
	SDMMC_DATACTRL_DMAENABLE_Pos = 0x3
	// Bit mask of DMAENABLE field.
	SDMMC_DATACTRL_DMAENABLE_Msk = 0x8
	// Bit DMAENABLE.
	SDMMC_DATACTRL_DMAENABLE = 0x8
	// DMA disabled.
	SDMMC_DATACTRL_DMAENABLE_DMA_DISABLED_ = 0x0
	// DMA enabled.
	SDMMC_DATACTRL_DMAENABLE_DMA_ENABLED_ = 0x1
	// Position of BLOCKSIZE field.
	SDMMC_DATACTRL_BLOCKSIZE_Pos = 0x4
	// Bit mask of BLOCKSIZE field.
	SDMMC_DATACTRL_BLOCKSIZE_Msk = 0xf0
	// Position of RESERVED field.
	SDMMC_DATACTRL_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SDMMC_DATACTRL_RESERVED_Msk = 0xffffff00

	// DATACNT: Data counter.
	// Position of DATACOUNT field.
	SDMMC_DATACNT_DATACOUNT_Pos = 0x0
	// Bit mask of DATACOUNT field.
	SDMMC_DATACNT_DATACOUNT_Msk = 0xffff
	// Position of RESERVED field.
	SDMMC_DATACNT_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	SDMMC_DATACNT_RESERVED_Msk = 0xffff0000

	// STATUS: Status register.
	// Position of CMDCRCFAIL field.
	SDMMC_STATUS_CMDCRCFAIL_Pos = 0x0
	// Bit mask of CMDCRCFAIL field.
	SDMMC_STATUS_CMDCRCFAIL_Msk = 0x1
	// Bit CMDCRCFAIL.
	SDMMC_STATUS_CMDCRCFAIL = 0x1
	// Position of DATACRCFAIL field.
	SDMMC_STATUS_DATACRCFAIL_Pos = 0x1
	// Bit mask of DATACRCFAIL field.
	SDMMC_STATUS_DATACRCFAIL_Msk = 0x2
	// Bit DATACRCFAIL.
	SDMMC_STATUS_DATACRCFAIL = 0x2
	// Position of CMDTIMEOUT field.
	SDMMC_STATUS_CMDTIMEOUT_Pos = 0x2
	// Bit mask of CMDTIMEOUT field.
	SDMMC_STATUS_CMDTIMEOUT_Msk = 0x4
	// Bit CMDTIMEOUT.
	SDMMC_STATUS_CMDTIMEOUT = 0x4
	// Position of DATATIMEOUT field.
	SDMMC_STATUS_DATATIMEOUT_Pos = 0x3
	// Bit mask of DATATIMEOUT field.
	SDMMC_STATUS_DATATIMEOUT_Msk = 0x8
	// Bit DATATIMEOUT.
	SDMMC_STATUS_DATATIMEOUT = 0x8
	// Position of TXUNDERRUN field.
	SDMMC_STATUS_TXUNDERRUN_Pos = 0x4
	// Bit mask of TXUNDERRUN field.
	SDMMC_STATUS_TXUNDERRUN_Msk = 0x10
	// Bit TXUNDERRUN.
	SDMMC_STATUS_TXUNDERRUN = 0x10
	// Position of RXOVERRUN field.
	SDMMC_STATUS_RXOVERRUN_Pos = 0x5
	// Bit mask of RXOVERRUN field.
	SDMMC_STATUS_RXOVERRUN_Msk = 0x20
	// Bit RXOVERRUN.
	SDMMC_STATUS_RXOVERRUN = 0x20
	// Position of CMDRESPEND field.
	SDMMC_STATUS_CMDRESPEND_Pos = 0x6
	// Bit mask of CMDRESPEND field.
	SDMMC_STATUS_CMDRESPEND_Msk = 0x40
	// Bit CMDRESPEND.
	SDMMC_STATUS_CMDRESPEND = 0x40
	// Position of CMDSENT field.
	SDMMC_STATUS_CMDSENT_Pos = 0x7
	// Bit mask of CMDSENT field.
	SDMMC_STATUS_CMDSENT_Msk = 0x80
	// Bit CMDSENT.
	SDMMC_STATUS_CMDSENT = 0x80
	// Position of DATAEND field.
	SDMMC_STATUS_DATAEND_Pos = 0x8
	// Bit mask of DATAEND field.
	SDMMC_STATUS_DATAEND_Msk = 0x100
	// Bit DATAEND.
	SDMMC_STATUS_DATAEND = 0x100
	// Position of STARTBITERR field.
	SDMMC_STATUS_STARTBITERR_Pos = 0x9
	// Bit mask of STARTBITERR field.
	SDMMC_STATUS_STARTBITERR_Msk = 0x200
	// Bit STARTBITERR.
	SDMMC_STATUS_STARTBITERR = 0x200
	// Position of DATABLOCKEND field.
	SDMMC_STATUS_DATABLOCKEND_Pos = 0xa
	// Bit mask of DATABLOCKEND field.
	SDMMC_STATUS_DATABLOCKEND_Msk = 0x400
	// Bit DATABLOCKEND.
	SDMMC_STATUS_DATABLOCKEND = 0x400
	// Position of CMDACTIVE field.
	SDMMC_STATUS_CMDACTIVE_Pos = 0xb
	// Bit mask of CMDACTIVE field.
	SDMMC_STATUS_CMDACTIVE_Msk = 0x800
	// Bit CMDACTIVE.
	SDMMC_STATUS_CMDACTIVE = 0x800
	// Position of TXACTIVE field.
	SDMMC_STATUS_TXACTIVE_Pos = 0xc
	// Bit mask of TXACTIVE field.
	SDMMC_STATUS_TXACTIVE_Msk = 0x1000
	// Bit TXACTIVE.
	SDMMC_STATUS_TXACTIVE = 0x1000
	// Position of RXACTIVE field.
	SDMMC_STATUS_RXACTIVE_Pos = 0xd
	// Bit mask of RXACTIVE field.
	SDMMC_STATUS_RXACTIVE_Msk = 0x2000
	// Bit RXACTIVE.
	SDMMC_STATUS_RXACTIVE = 0x2000
	// Position of TXFIFOHALFEMPTY field.
	SDMMC_STATUS_TXFIFOHALFEMPTY_Pos = 0xe
	// Bit mask of TXFIFOHALFEMPTY field.
	SDMMC_STATUS_TXFIFOHALFEMPTY_Msk = 0x4000
	// Bit TXFIFOHALFEMPTY.
	SDMMC_STATUS_TXFIFOHALFEMPTY = 0x4000
	// Position of RXFIFOHALFFULL field.
	SDMMC_STATUS_RXFIFOHALFFULL_Pos = 0xf
	// Bit mask of RXFIFOHALFFULL field.
	SDMMC_STATUS_RXFIFOHALFFULL_Msk = 0x8000
	// Bit RXFIFOHALFFULL.
	SDMMC_STATUS_RXFIFOHALFFULL = 0x8000
	// Position of TXFIFOFULL field.
	SDMMC_STATUS_TXFIFOFULL_Pos = 0x10
	// Bit mask of TXFIFOFULL field.
	SDMMC_STATUS_TXFIFOFULL_Msk = 0x10000
	// Bit TXFIFOFULL.
	SDMMC_STATUS_TXFIFOFULL = 0x10000
	// Position of RXFIFOFULL field.
	SDMMC_STATUS_RXFIFOFULL_Pos = 0x11
	// Bit mask of RXFIFOFULL field.
	SDMMC_STATUS_RXFIFOFULL_Msk = 0x20000
	// Bit RXFIFOFULL.
	SDMMC_STATUS_RXFIFOFULL = 0x20000
	// Position of TXFIFOEMPTY field.
	SDMMC_STATUS_TXFIFOEMPTY_Pos = 0x12
	// Bit mask of TXFIFOEMPTY field.
	SDMMC_STATUS_TXFIFOEMPTY_Msk = 0x40000
	// Bit TXFIFOEMPTY.
	SDMMC_STATUS_TXFIFOEMPTY = 0x40000
	// Position of RXFIFOEMPTY field.
	SDMMC_STATUS_RXFIFOEMPTY_Pos = 0x13
	// Bit mask of RXFIFOEMPTY field.
	SDMMC_STATUS_RXFIFOEMPTY_Msk = 0x80000
	// Bit RXFIFOEMPTY.
	SDMMC_STATUS_RXFIFOEMPTY = 0x80000
	// Position of TXDATAAVLBL field.
	SDMMC_STATUS_TXDATAAVLBL_Pos = 0x14
	// Bit mask of TXDATAAVLBL field.
	SDMMC_STATUS_TXDATAAVLBL_Msk = 0x100000
	// Bit TXDATAAVLBL.
	SDMMC_STATUS_TXDATAAVLBL = 0x100000
	// Position of RXDATAAVLBL field.
	SDMMC_STATUS_RXDATAAVLBL_Pos = 0x15
	// Bit mask of RXDATAAVLBL field.
	SDMMC_STATUS_RXDATAAVLBL_Msk = 0x200000
	// Bit RXDATAAVLBL.
	SDMMC_STATUS_RXDATAAVLBL = 0x200000
	// Position of RESERVED field.
	SDMMC_STATUS_RESERVED_Pos = 0x16
	// Bit mask of RESERVED field.
	SDMMC_STATUS_RESERVED_Msk = 0xffc00000

	// CLEAR: Clear register.
	// Position of CMDCRCFAILCLR field.
	SDMMC_CLEAR_CMDCRCFAILCLR_Pos = 0x0
	// Bit mask of CMDCRCFAILCLR field.
	SDMMC_CLEAR_CMDCRCFAILCLR_Msk = 0x1
	// Bit CMDCRCFAILCLR.
	SDMMC_CLEAR_CMDCRCFAILCLR = 0x1
	// Position of DATACRCFAILCLR field.
	SDMMC_CLEAR_DATACRCFAILCLR_Pos = 0x1
	// Bit mask of DATACRCFAILCLR field.
	SDMMC_CLEAR_DATACRCFAILCLR_Msk = 0x2
	// Bit DATACRCFAILCLR.
	SDMMC_CLEAR_DATACRCFAILCLR = 0x2
	// Position of CMDTIMEOUTCLR field.
	SDMMC_CLEAR_CMDTIMEOUTCLR_Pos = 0x2
	// Bit mask of CMDTIMEOUTCLR field.
	SDMMC_CLEAR_CMDTIMEOUTCLR_Msk = 0x4
	// Bit CMDTIMEOUTCLR.
	SDMMC_CLEAR_CMDTIMEOUTCLR = 0x4
	// Position of DATATIMEOUTCLR field.
	SDMMC_CLEAR_DATATIMEOUTCLR_Pos = 0x3
	// Bit mask of DATATIMEOUTCLR field.
	SDMMC_CLEAR_DATATIMEOUTCLR_Msk = 0x8
	// Bit DATATIMEOUTCLR.
	SDMMC_CLEAR_DATATIMEOUTCLR = 0x8
	// Position of TXUNDERRUNCLR field.
	SDMMC_CLEAR_TXUNDERRUNCLR_Pos = 0x4
	// Bit mask of TXUNDERRUNCLR field.
	SDMMC_CLEAR_TXUNDERRUNCLR_Msk = 0x10
	// Bit TXUNDERRUNCLR.
	SDMMC_CLEAR_TXUNDERRUNCLR = 0x10
	// Position of RXOVERRUNCLR field.
	SDMMC_CLEAR_RXOVERRUNCLR_Pos = 0x5
	// Bit mask of RXOVERRUNCLR field.
	SDMMC_CLEAR_RXOVERRUNCLR_Msk = 0x20
	// Bit RXOVERRUNCLR.
	SDMMC_CLEAR_RXOVERRUNCLR = 0x20
	// Position of CMDRESPENDCLR field.
	SDMMC_CLEAR_CMDRESPENDCLR_Pos = 0x6
	// Bit mask of CMDRESPENDCLR field.
	SDMMC_CLEAR_CMDRESPENDCLR_Msk = 0x40
	// Bit CMDRESPENDCLR.
	SDMMC_CLEAR_CMDRESPENDCLR = 0x40
	// Position of CMDSENTCLR field.
	SDMMC_CLEAR_CMDSENTCLR_Pos = 0x7
	// Bit mask of CMDSENTCLR field.
	SDMMC_CLEAR_CMDSENTCLR_Msk = 0x80
	// Bit CMDSENTCLR.
	SDMMC_CLEAR_CMDSENTCLR = 0x80
	// Position of DATAENDCLR field.
	SDMMC_CLEAR_DATAENDCLR_Pos = 0x8
	// Bit mask of DATAENDCLR field.
	SDMMC_CLEAR_DATAENDCLR_Msk = 0x100
	// Bit DATAENDCLR.
	SDMMC_CLEAR_DATAENDCLR = 0x100
	// Position of STARTBITERRCLR field.
	SDMMC_CLEAR_STARTBITERRCLR_Pos = 0x9
	// Bit mask of STARTBITERRCLR field.
	SDMMC_CLEAR_STARTBITERRCLR_Msk = 0x200
	// Bit STARTBITERRCLR.
	SDMMC_CLEAR_STARTBITERRCLR = 0x200
	// Position of DATABLOCKENDCLR field.
	SDMMC_CLEAR_DATABLOCKENDCLR_Pos = 0xa
	// Bit mask of DATABLOCKENDCLR field.
	SDMMC_CLEAR_DATABLOCKENDCLR_Msk = 0x400
	// Bit DATABLOCKENDCLR.
	SDMMC_CLEAR_DATABLOCKENDCLR = 0x400
	// Position of RESERVED field.
	SDMMC_CLEAR_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	SDMMC_CLEAR_RESERVED_Msk = 0xfffff800

	// MASK0: Interrupt 0 mask register.
	// Position of MASK0 field.
	SDMMC_MASK0_MASK0_Pos = 0x0
	// Bit mask of MASK0 field.
	SDMMC_MASK0_MASK0_Msk = 0x1
	// Bit MASK0.
	SDMMC_MASK0_MASK0 = 0x1
	// Position of MASK1 field.
	SDMMC_MASK0_MASK1_Pos = 0x1
	// Bit mask of MASK1 field.
	SDMMC_MASK0_MASK1_Msk = 0x2
	// Bit MASK1.
	SDMMC_MASK0_MASK1 = 0x2
	// Position of MASK2 field.
	SDMMC_MASK0_MASK2_Pos = 0x2
	// Bit mask of MASK2 field.
	SDMMC_MASK0_MASK2_Msk = 0x4
	// Bit MASK2.
	SDMMC_MASK0_MASK2 = 0x4
	// Position of MASK3 field.
	SDMMC_MASK0_MASK3_Pos = 0x3
	// Bit mask of MASK3 field.
	SDMMC_MASK0_MASK3_Msk = 0x8
	// Bit MASK3.
	SDMMC_MASK0_MASK3 = 0x8
	// Position of MASK4 field.
	SDMMC_MASK0_MASK4_Pos = 0x4
	// Bit mask of MASK4 field.
	SDMMC_MASK0_MASK4_Msk = 0x10
	// Bit MASK4.
	SDMMC_MASK0_MASK4 = 0x10
	// Position of MASK5 field.
	SDMMC_MASK0_MASK5_Pos = 0x5
	// Bit mask of MASK5 field.
	SDMMC_MASK0_MASK5_Msk = 0x20
	// Bit MASK5.
	SDMMC_MASK0_MASK5 = 0x20
	// Position of MASK6 field.
	SDMMC_MASK0_MASK6_Pos = 0x6
	// Bit mask of MASK6 field.
	SDMMC_MASK0_MASK6_Msk = 0x40
	// Bit MASK6.
	SDMMC_MASK0_MASK6 = 0x40
	// Position of MASK7 field.
	SDMMC_MASK0_MASK7_Pos = 0x7
	// Bit mask of MASK7 field.
	SDMMC_MASK0_MASK7_Msk = 0x80
	// Bit MASK7.
	SDMMC_MASK0_MASK7 = 0x80
	// Position of MASK8 field.
	SDMMC_MASK0_MASK8_Pos = 0x8
	// Bit mask of MASK8 field.
	SDMMC_MASK0_MASK8_Msk = 0x100
	// Bit MASK8.
	SDMMC_MASK0_MASK8 = 0x100
	// Position of MASK9 field.
	SDMMC_MASK0_MASK9_Pos = 0x9
	// Bit mask of MASK9 field.
	SDMMC_MASK0_MASK9_Msk = 0x200
	// Bit MASK9.
	SDMMC_MASK0_MASK9 = 0x200
	// Position of MASK10 field.
	SDMMC_MASK0_MASK10_Pos = 0xa
	// Bit mask of MASK10 field.
	SDMMC_MASK0_MASK10_Msk = 0x400
	// Bit MASK10.
	SDMMC_MASK0_MASK10 = 0x400
	// Position of MASK11 field.
	SDMMC_MASK0_MASK11_Pos = 0xb
	// Bit mask of MASK11 field.
	SDMMC_MASK0_MASK11_Msk = 0x800
	// Bit MASK11.
	SDMMC_MASK0_MASK11 = 0x800
	// Position of MASK12 field.
	SDMMC_MASK0_MASK12_Pos = 0xc
	// Bit mask of MASK12 field.
	SDMMC_MASK0_MASK12_Msk = 0x1000
	// Bit MASK12.
	SDMMC_MASK0_MASK12 = 0x1000
	// Position of MASK13 field.
	SDMMC_MASK0_MASK13_Pos = 0xd
	// Bit mask of MASK13 field.
	SDMMC_MASK0_MASK13_Msk = 0x2000
	// Bit MASK13.
	SDMMC_MASK0_MASK13 = 0x2000
	// Position of MASK14 field.
	SDMMC_MASK0_MASK14_Pos = 0xe
	// Bit mask of MASK14 field.
	SDMMC_MASK0_MASK14_Msk = 0x4000
	// Bit MASK14.
	SDMMC_MASK0_MASK14 = 0x4000
	// Position of MASK15 field.
	SDMMC_MASK0_MASK15_Pos = 0xf
	// Bit mask of MASK15 field.
	SDMMC_MASK0_MASK15_Msk = 0x8000
	// Bit MASK15.
	SDMMC_MASK0_MASK15 = 0x8000
	// Position of MASK16 field.
	SDMMC_MASK0_MASK16_Pos = 0x10
	// Bit mask of MASK16 field.
	SDMMC_MASK0_MASK16_Msk = 0x10000
	// Bit MASK16.
	SDMMC_MASK0_MASK16 = 0x10000
	// Position of MASK17 field.
	SDMMC_MASK0_MASK17_Pos = 0x11
	// Bit mask of MASK17 field.
	SDMMC_MASK0_MASK17_Msk = 0x20000
	// Bit MASK17.
	SDMMC_MASK0_MASK17 = 0x20000
	// Position of MASK18 field.
	SDMMC_MASK0_MASK18_Pos = 0x12
	// Bit mask of MASK18 field.
	SDMMC_MASK0_MASK18_Msk = 0x40000
	// Bit MASK18.
	SDMMC_MASK0_MASK18 = 0x40000
	// Position of MASK19 field.
	SDMMC_MASK0_MASK19_Pos = 0x13
	// Bit mask of MASK19 field.
	SDMMC_MASK0_MASK19_Msk = 0x80000
	// Bit MASK19.
	SDMMC_MASK0_MASK19 = 0x80000
	// Position of MASK20 field.
	SDMMC_MASK0_MASK20_Pos = 0x14
	// Bit mask of MASK20 field.
	SDMMC_MASK0_MASK20_Msk = 0x100000
	// Bit MASK20.
	SDMMC_MASK0_MASK20 = 0x100000
	// Position of MASK21 field.
	SDMMC_MASK0_MASK21_Pos = 0x15
	// Bit mask of MASK21 field.
	SDMMC_MASK0_MASK21_Msk = 0x200000
	// Bit MASK21.
	SDMMC_MASK0_MASK21 = 0x200000
	// Position of RESERVED field.
	SDMMC_MASK0_RESERVED_Pos = 0x16
	// Bit mask of RESERVED field.
	SDMMC_MASK0_RESERVED_Msk = 0xffc00000

	// FIFOCNT: FIFO Counter.
	// Position of DATACOUNT field.
	SDMMC_FIFOCNT_DATACOUNT_Pos = 0x0
	// Bit mask of DATACOUNT field.
	SDMMC_FIFOCNT_DATACOUNT_Msk = 0x7fff
	// Position of RESERVED field.
	SDMMC_FIFOCNT_RESERVED_Pos = 0xf
	// Bit mask of RESERVED field.
	SDMMC_FIFOCNT_RESERVED_Msk = 0xffff8000

	// FIFO0: Data FIFO Register.
	// Position of DATA field.
	SDMMC_FIFO_DATA_Pos = 0x0
	// Bit mask of DATA field.
	SDMMC_FIFO_DATA_Msk = 0xffffffff
)

// Constants for SYSCON: System and clock control
const (
	// FLASHCFG: Flash Accelerator Configuration Register. Controls flash access timing.
	// Position of RESERVED field.
	SYSCON_FLASHCFG_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	SYSCON_FLASHCFG_RESERVED_Msk = 0xfff
	// Position of FLASHTIM field.
	SYSCON_FLASHCFG_FLASHTIM_Pos = 0xc
	// Bit mask of FLASHTIM field.
	SYSCON_FLASHCFG_FLASHTIM_Msk = 0xf000
	// Flash accesses use 1 CPU clock. Use for up to 20 MHz CPU clock with power boost off.
	SYSCON_FLASHCFG_FLASHTIM_FLASH_ACCESSES_USE_1 = 0x0
	// Flash accesses use 2 CPU clocks. Use for up to 40 MHz CPU clock with power boost off.
	SYSCON_FLASHCFG_FLASHTIM_FLASH_ACCESSES_USE_2 = 0x1
	// Flash accesses use 3 CPU clocks. Use for up to 60 MHz CPU clock with power boost off.
	SYSCON_FLASHCFG_FLASHTIM_FLASH_ACCESSES_USE_3 = 0x2
	// Flash accesses use 4 CPU clocks. Use for up to 80 MHz CPU clock with power boost off. Use this setting for operation from 100 to 120 MHz operation with power boost on.
	SYSCON_FLASHCFG_FLASHTIM_FLASH_ACCESSES_USE_4 = 0x3
	// Flash accesses use 5 CPU clocks. Use for up to 100 MHz CPU clock with power boost off.
	SYSCON_FLASHCFG_FLASHTIM_FLASH_ACCESSES_USE_5 = 0x4
	// Flash accesses use 6 CPU clocks. Safe setting for any allowed conditions.
	SYSCON_FLASHCFG_FLASHTIM_FLASH_ACCESSES_USE_6 = 0x5
	// Position of RESERVED field.
	SYSCON_FLASHCFG_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	SYSCON_FLASHCFG_RESERVED_Msk = 0xffff0000

	// PLLCON0: PLL0 Control register
	// Position of PLLE field.
	SYSCON_PLLCON_PLLE_Pos = 0x0
	// Bit mask of PLLE field.
	SYSCON_PLLCON_PLLE_Msk = 0x1
	// Bit PLLE.
	SYSCON_PLLCON_PLLE = 0x1
	// Position of RESERVED field.
	SYSCON_PLLCON_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	SYSCON_PLLCON_RESERVED_Msk = 0xfffffffe

	// PLLCFG0: PLL0 Configuration register
	// Position of MSEL field.
	SYSCON_PLLCFG_MSEL_Pos = 0x0
	// Bit mask of MSEL field.
	SYSCON_PLLCFG_MSEL_Msk = 0x1f
	// Position of PSEL field.
	SYSCON_PLLCFG_PSEL_Pos = 0x5
	// Bit mask of PSEL field.
	SYSCON_PLLCFG_PSEL_Msk = 0x60
	// Position of RESERVED field.
	SYSCON_PLLCFG_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	SYSCON_PLLCFG_RESERVED_Msk = 0xffffff80

	// PLLSTAT0: PLL0 Status register
	// Position of MSEL field.
	SYSCON_PLLSTAT_MSEL_Pos = 0x0
	// Bit mask of MSEL field.
	SYSCON_PLLSTAT_MSEL_Msk = 0x1f
	// Position of PSEL field.
	SYSCON_PLLSTAT_PSEL_Pos = 0x5
	// Bit mask of PSEL field.
	SYSCON_PLLSTAT_PSEL_Msk = 0x60
	// Position of RESERVED field.
	SYSCON_PLLSTAT_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	SYSCON_PLLSTAT_RESERVED_Msk = 0x80
	// Bit RESERVED.
	SYSCON_PLLSTAT_RESERVED = 0x80
	// Position of PLLE_STAT field.
	SYSCON_PLLSTAT_PLLE_STAT_Pos = 0x8
	// Bit mask of PLLE_STAT field.
	SYSCON_PLLSTAT_PLLE_STAT_Msk = 0x100
	// Bit PLLE_STAT.
	SYSCON_PLLSTAT_PLLE_STAT = 0x100
	// Position of RESERVED field.
	SYSCON_PLLSTAT_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	SYSCON_PLLSTAT_RESERVED_Msk = 0x200
	// Bit RESERVED.
	SYSCON_PLLSTAT_RESERVED = 0x200
	// Position of PLOCK field.
	SYSCON_PLLSTAT_PLOCK_Pos = 0xa
	// Bit mask of PLOCK field.
	SYSCON_PLLSTAT_PLOCK_Msk = 0x400
	// Bit PLOCK.
	SYSCON_PLLSTAT_PLOCK = 0x400
	// Position of RESERVED field.
	SYSCON_PLLSTAT_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	SYSCON_PLLSTAT_RESERVED_Msk = 0xfffff800

	// PLLFEED0: PLL0 Feed register
	// Position of PLLFEED field.
	SYSCON_PLLFEED_PLLFEED_Pos = 0x0
	// Bit mask of PLLFEED field.
	SYSCON_PLLFEED_PLLFEED_Msk = 0xff
	// Position of RESERVED field.
	SYSCON_PLLFEED_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SYSCON_PLLFEED_RESERVED_Msk = 0xffffff00

	// PCON: Power Control register
	// Position of PM0 field.
	SYSCON_PCON_PM0_Pos = 0x0
	// Bit mask of PM0 field.
	SYSCON_PCON_PM0_Msk = 0x1
	// Bit PM0.
	SYSCON_PCON_PM0 = 0x1
	// Position of PM1 field.
	SYSCON_PCON_PM1_Pos = 0x1
	// Bit mask of PM1 field.
	SYSCON_PCON_PM1_Msk = 0x2
	// Bit PM1.
	SYSCON_PCON_PM1 = 0x2
	// Position of BODRPM field.
	SYSCON_PCON_BODRPM_Pos = 0x2
	// Bit mask of BODRPM field.
	SYSCON_PCON_BODRPM_Msk = 0x4
	// Bit BODRPM.
	SYSCON_PCON_BODRPM = 0x4
	// Position of BOGD field.
	SYSCON_PCON_BOGD_Pos = 0x3
	// Bit mask of BOGD field.
	SYSCON_PCON_BOGD_Msk = 0x8
	// Bit BOGD.
	SYSCON_PCON_BOGD = 0x8
	// Position of BORD field.
	SYSCON_PCON_BORD_Pos = 0x4
	// Bit mask of BORD field.
	SYSCON_PCON_BORD_Msk = 0x10
	// Bit BORD.
	SYSCON_PCON_BORD = 0x10
	// Position of RESERVED field.
	SYSCON_PCON_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	SYSCON_PCON_RESERVED_Msk = 0xf8
	// Position of SMFLAG field.
	SYSCON_PCON_SMFLAG_Pos = 0x8
	// Bit mask of SMFLAG field.
	SYSCON_PCON_SMFLAG_Msk = 0x100
	// Bit SMFLAG.
	SYSCON_PCON_SMFLAG = 0x100
	// Position of DSFLAG field.
	SYSCON_PCON_DSFLAG_Pos = 0x9
	// Bit mask of DSFLAG field.
	SYSCON_PCON_DSFLAG_Msk = 0x200
	// Bit DSFLAG.
	SYSCON_PCON_DSFLAG = 0x200
	// Position of PDFLAG field.
	SYSCON_PCON_PDFLAG_Pos = 0xa
	// Bit mask of PDFLAG field.
	SYSCON_PCON_PDFLAG_Msk = 0x400
	// Bit PDFLAG.
	SYSCON_PCON_PDFLAG = 0x400
	// Position of DPDFLAG field.
	SYSCON_PCON_DPDFLAG_Pos = 0xb
	// Bit mask of DPDFLAG field.
	SYSCON_PCON_DPDFLAG_Msk = 0x800
	// Bit DPDFLAG.
	SYSCON_PCON_DPDFLAG = 0x800
	// Position of RESERVED field.
	SYSCON_PCON_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	SYSCON_PCON_RESERVED_Msk = 0xfffff000

	// PCONP0: Power Control for Peripherals
	// Position of PCLCD field.
	SYSCON_PCONP0_PCLCD_Pos = 0x0
	// Bit mask of PCLCD field.
	SYSCON_PCONP0_PCLCD_Msk = 0x1
	// Bit PCLCD.
	SYSCON_PCONP0_PCLCD = 0x1
	// Position of PCTIM0 field.
	SYSCON_PCONP0_PCTIM0_Pos = 0x1
	// Bit mask of PCTIM0 field.
	SYSCON_PCONP0_PCTIM0_Msk = 0x2
	// Bit PCTIM0.
	SYSCON_PCONP0_PCTIM0 = 0x2
	// Position of PCTIM1 field.
	SYSCON_PCONP0_PCTIM1_Pos = 0x2
	// Bit mask of PCTIM1 field.
	SYSCON_PCONP0_PCTIM1_Msk = 0x4
	// Bit PCTIM1.
	SYSCON_PCONP0_PCTIM1 = 0x4
	// Position of PCUART0 field.
	SYSCON_PCONP0_PCUART0_Pos = 0x3
	// Bit mask of PCUART0 field.
	SYSCON_PCONP0_PCUART0_Msk = 0x8
	// Bit PCUART0.
	SYSCON_PCONP0_PCUART0 = 0x8
	// Position of PCUART1 field.
	SYSCON_PCONP0_PCUART1_Pos = 0x4
	// Bit mask of PCUART1 field.
	SYSCON_PCONP0_PCUART1_Msk = 0x10
	// Bit PCUART1.
	SYSCON_PCONP0_PCUART1 = 0x10
	// Position of PCPWM0 field.
	SYSCON_PCONP0_PCPWM0_Pos = 0x5
	// Bit mask of PCPWM0 field.
	SYSCON_PCONP0_PCPWM0_Msk = 0x20
	// Bit PCPWM0.
	SYSCON_PCONP0_PCPWM0 = 0x20
	// Position of PCPWM1 field.
	SYSCON_PCONP0_PCPWM1_Pos = 0x6
	// Bit mask of PCPWM1 field.
	SYSCON_PCONP0_PCPWM1_Msk = 0x40
	// Bit PCPWM1.
	SYSCON_PCONP0_PCPWM1 = 0x40
	// Position of PCI2C0 field.
	SYSCON_PCONP0_PCI2C0_Pos = 0x7
	// Bit mask of PCI2C0 field.
	SYSCON_PCONP0_PCI2C0_Msk = 0x80
	// Bit PCI2C0.
	SYSCON_PCONP0_PCI2C0 = 0x80
	// Position of PCUART4 field.
	SYSCON_PCONP0_PCUART4_Pos = 0x8
	// Bit mask of PCUART4 field.
	SYSCON_PCONP0_PCUART4_Msk = 0x100
	// Bit PCUART4.
	SYSCON_PCONP0_PCUART4 = 0x100
	// Position of PCRTC field.
	SYSCON_PCONP0_PCRTC_Pos = 0x9
	// Bit mask of PCRTC field.
	SYSCON_PCONP0_PCRTC_Msk = 0x200
	// Bit PCRTC.
	SYSCON_PCONP0_PCRTC = 0x200
	// Position of PCSSP1 field.
	SYSCON_PCONP0_PCSSP1_Pos = 0xa
	// Bit mask of PCSSP1 field.
	SYSCON_PCONP0_PCSSP1_Msk = 0x400
	// Bit PCSSP1.
	SYSCON_PCONP0_PCSSP1 = 0x400
	// Position of PCEMC field.
	SYSCON_PCONP0_PCEMC_Pos = 0xb
	// Bit mask of PCEMC field.
	SYSCON_PCONP0_PCEMC_Msk = 0x800
	// Bit PCEMC.
	SYSCON_PCONP0_PCEMC = 0x800
	// Position of PCADC field.
	SYSCON_PCONP0_PCADC_Pos = 0xc
	// Bit mask of PCADC field.
	SYSCON_PCONP0_PCADC_Msk = 0x1000
	// Bit PCADC.
	SYSCON_PCONP0_PCADC = 0x1000
	// Position of PCCAN1 field.
	SYSCON_PCONP0_PCCAN1_Pos = 0xd
	// Bit mask of PCCAN1 field.
	SYSCON_PCONP0_PCCAN1_Msk = 0x2000
	// Bit PCCAN1.
	SYSCON_PCONP0_PCCAN1 = 0x2000
	// Position of PCCAN2 field.
	SYSCON_PCONP0_PCCAN2_Pos = 0xe
	// Bit mask of PCCAN2 field.
	SYSCON_PCONP0_PCCAN2_Msk = 0x4000
	// Bit PCCAN2.
	SYSCON_PCONP0_PCCAN2 = 0x4000
	// Position of PCGPIO field.
	SYSCON_PCONP0_PCGPIO_Pos = 0xf
	// Bit mask of PCGPIO field.
	SYSCON_PCONP0_PCGPIO_Msk = 0x8000
	// Bit PCGPIO.
	SYSCON_PCONP0_PCGPIO = 0x8000
	// Position of PCSPIFI field.
	SYSCON_PCONP0_PCSPIFI_Pos = 0x10
	// Bit mask of PCSPIFI field.
	SYSCON_PCONP0_PCSPIFI_Msk = 0x10000
	// Bit PCSPIFI.
	SYSCON_PCONP0_PCSPIFI = 0x10000
	// Position of PCMCPWM field.
	SYSCON_PCONP0_PCMCPWM_Pos = 0x11
	// Bit mask of PCMCPWM field.
	SYSCON_PCONP0_PCMCPWM_Msk = 0x20000
	// Bit PCMCPWM.
	SYSCON_PCONP0_PCMCPWM = 0x20000
	// Position of PCQEI field.
	SYSCON_PCONP0_PCQEI_Pos = 0x12
	// Bit mask of PCQEI field.
	SYSCON_PCONP0_PCQEI_Msk = 0x40000
	// Bit PCQEI.
	SYSCON_PCONP0_PCQEI = 0x40000
	// Position of PCI2C1 field.
	SYSCON_PCONP0_PCI2C1_Pos = 0x13
	// Bit mask of PCI2C1 field.
	SYSCON_PCONP0_PCI2C1_Msk = 0x80000
	// Bit PCI2C1.
	SYSCON_PCONP0_PCI2C1 = 0x80000
	// Position of PCSSP2 field.
	SYSCON_PCONP0_PCSSP2_Pos = 0x14
	// Bit mask of PCSSP2 field.
	SYSCON_PCONP0_PCSSP2_Msk = 0x100000
	// Bit PCSSP2.
	SYSCON_PCONP0_PCSSP2 = 0x100000
	// Position of PCSSP0 field.
	SYSCON_PCONP0_PCSSP0_Pos = 0x15
	// Bit mask of PCSSP0 field.
	SYSCON_PCONP0_PCSSP0_Msk = 0x200000
	// Bit PCSSP0.
	SYSCON_PCONP0_PCSSP0 = 0x200000
	// Position of PCTIM2 field.
	SYSCON_PCONP0_PCTIM2_Pos = 0x16
	// Bit mask of PCTIM2 field.
	SYSCON_PCONP0_PCTIM2_Msk = 0x400000
	// Bit PCTIM2.
	SYSCON_PCONP0_PCTIM2 = 0x400000
	// Position of PCTIM3 field.
	SYSCON_PCONP0_PCTIM3_Pos = 0x17
	// Bit mask of PCTIM3 field.
	SYSCON_PCONP0_PCTIM3_Msk = 0x800000
	// Bit PCTIM3.
	SYSCON_PCONP0_PCTIM3 = 0x800000
	// Position of PCUART2 field.
	SYSCON_PCONP0_PCUART2_Pos = 0x18
	// Bit mask of PCUART2 field.
	SYSCON_PCONP0_PCUART2_Msk = 0x1000000
	// Bit PCUART2.
	SYSCON_PCONP0_PCUART2 = 0x1000000
	// Position of PCUART3 field.
	SYSCON_PCONP0_PCUART3_Pos = 0x19
	// Bit mask of PCUART3 field.
	SYSCON_PCONP0_PCUART3_Msk = 0x2000000
	// Bit PCUART3.
	SYSCON_PCONP0_PCUART3 = 0x2000000
	// Position of PCI2C2 field.
	SYSCON_PCONP0_PCI2C2_Pos = 0x1a
	// Bit mask of PCI2C2 field.
	SYSCON_PCONP0_PCI2C2_Msk = 0x4000000
	// Bit PCI2C2.
	SYSCON_PCONP0_PCI2C2 = 0x4000000
	// Position of PCI2S field.
	SYSCON_PCONP0_PCI2S_Pos = 0x1b
	// Bit mask of PCI2S field.
	SYSCON_PCONP0_PCI2S_Msk = 0x8000000
	// Bit PCI2S.
	SYSCON_PCONP0_PCI2S = 0x8000000
	// Position of PCSDC field.
	SYSCON_PCONP0_PCSDC_Pos = 0x1c
	// Bit mask of PCSDC field.
	SYSCON_PCONP0_PCSDC_Msk = 0x10000000
	// Bit PCSDC.
	SYSCON_PCONP0_PCSDC = 0x10000000
	// Position of PCGPDMA field.
	SYSCON_PCONP0_PCGPDMA_Pos = 0x1d
	// Bit mask of PCGPDMA field.
	SYSCON_PCONP0_PCGPDMA_Msk = 0x20000000
	// Bit PCGPDMA.
	SYSCON_PCONP0_PCGPDMA = 0x20000000
	// Position of PCENET field.
	SYSCON_PCONP0_PCENET_Pos = 0x1e
	// Bit mask of PCENET field.
	SYSCON_PCONP0_PCENET_Msk = 0x40000000
	// Bit PCENET.
	SYSCON_PCONP0_PCENET = 0x40000000
	// Position of PCUSB field.
	SYSCON_PCONP0_PCUSB_Pos = 0x1f
	// Bit mask of PCUSB field.
	SYSCON_PCONP0_PCUSB_Msk = 0x80000000
	// Bit PCUSB.
	SYSCON_PCONP0_PCUSB = 0x80000000

	// PCONP1: Power Control for Peripherals
	// Position of RESERVED field.
	SYSCON_PCONP1_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	SYSCON_PCONP1_RESERVED_Msk = 0x7
	// Position of PCCMP field.
	SYSCON_PCONP1_PCCMP_Pos = 0x3
	// Bit mask of PCCMP field.
	SYSCON_PCONP1_PCCMP_Msk = 0x8
	// Bit PCCMP.
	SYSCON_PCONP1_PCCMP = 0x8
	// Position of RESERVED field.
	SYSCON_PCONP1_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	SYSCON_PCONP1_RESERVED_Msk = 0xfffffff0

	// EMCCLKSEL: External Memory Controller Clock Selection register
	// Position of EMCDIV field.
	SYSCON_EMCCLKSEL_EMCDIV_Pos = 0x0
	// Bit mask of EMCDIV field.
	SYSCON_EMCCLKSEL_EMCDIV_Msk = 0x1
	// Bit EMCDIV.
	SYSCON_EMCCLKSEL_EMCDIV = 0x1
	// The EMC uses the same clock as the CPU.
	SYSCON_EMCCLKSEL_EMCDIV_THE_EMC_USES_THE_SAM = 0x0
	// The EMC uses a clock at half the rate of the CPU.
	SYSCON_EMCCLKSEL_EMCDIV_THE_EMC_USES_A_CLOCK = 0x1
	// Position of RESERVED field.
	SYSCON_EMCCLKSEL_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	SYSCON_EMCCLKSEL_RESERVED_Msk = 0xfffffffe

	// CCLKSEL: CPU Clock Selection register
	// Position of CCLKDIV field.
	SYSCON_CCLKSEL_CCLKDIV_Pos = 0x0
	// Bit mask of CCLKDIV field.
	SYSCON_CCLKSEL_CCLKDIV_Msk = 0x1f
	// Position of RESERVED field.
	SYSCON_CCLKSEL_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	SYSCON_CCLKSEL_RESERVED_Msk = 0xe0
	// Position of CCLKSEL field.
	SYSCON_CCLKSEL_CCLKSEL_Pos = 0x8
	// Bit mask of CCLKSEL field.
	SYSCON_CCLKSEL_CCLKSEL_Msk = 0x100
	// Bit CCLKSEL.
	SYSCON_CCLKSEL_CCLKSEL = 0x100
	// Sysclk is used as the input to the CPU clock divider.
	SYSCON_CCLKSEL_CCLKSEL_SYSCLK_IS_USED_AS_TH = 0x0
	// The output of the Main PLL is used as the input to the CPU clock divider.
	SYSCON_CCLKSEL_CCLKSEL_THE_OUTPUT_OF_THE_MA = 0x1
	// Position of RESERVED field.
	SYSCON_CCLKSEL_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	SYSCON_CCLKSEL_RESERVED_Msk = 0xfffffe00

	// USBCLKSEL: USB Clock Selection register
	// Position of USBDIV field.
	SYSCON_USBCLKSEL_USBDIV_Pos = 0x0
	// Bit mask of USBDIV field.
	SYSCON_USBCLKSEL_USBDIV_Msk = 0x1f
	// The divider is turned off, no clock will be provided to the USB subsystem.
	SYSCON_USBCLKSEL_USBDIV_THE_DIVIDER_IS_TURNE = 0x0
	// Position of RESERVED field.
	SYSCON_USBCLKSEL_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	SYSCON_USBCLKSEL_RESERVED_Msk = 0xe0
	// Position of USBSEL field.
	SYSCON_USBCLKSEL_USBSEL_Pos = 0x8
	// Bit mask of USBSEL field.
	SYSCON_USBCLKSEL_USBSEL_Msk = 0x300
	// Sysclk is used as the input to the USB clock divider. When this clock is selected, the USB can be accessed by software but cannot perform USB functions.
	SYSCON_USBCLKSEL_USBSEL_SYSCLK = 0x0
	// The output of the Main PLL is used as the input to the USB clock divider.
	SYSCON_USBCLKSEL_USBSEL_MAINPLLOUT = 0x1
	// The output of the Alt PLL is used as the input to the USB clock divider.
	SYSCON_USBCLKSEL_USBSEL_ALTPLLOOUT = 0x2
	// Position of RESERVED field.
	SYSCON_USBCLKSEL_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	SYSCON_USBCLKSEL_RESERVED_Msk = 0xfffffc00

	// CLKSRCSEL: Clock Source Select Register
	// Position of CLKSRC field.
	SYSCON_CLKSRCSEL_CLKSRC_Pos = 0x0
	// Bit mask of CLKSRC field.
	SYSCON_CLKSRCSEL_CLKSRC_Msk = 0x1
	// Bit CLKSRC.
	SYSCON_CLKSRCSEL_CLKSRC = 0x1
	// Selects the Internal RC oscillator as the sysclk and PLL0 clock source (default).
	SYSCON_CLKSRCSEL_CLKSRC_SELECTS_THE_INTERNAL = 0x0
	// Selects the main oscillator as the sysclk and PLL0 clock source.
	SYSCON_CLKSRCSEL_CLKSRC_SELECTS_THE_MAIN_OSC = 0x1
	// Position of RESERVED field.
	SYSCON_CLKSRCSEL_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	SYSCON_CLKSRCSEL_RESERVED_Msk = 0xfffffffe

	// CANSLEEPCLR: Allows clearing the current CAN channel sleep state as well as reading that state.
	// Position of RESERVED field.
	SYSCON_CANSLEEPCLR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	SYSCON_CANSLEEPCLR_RESERVED_Msk = 0x1
	// Bit RESERVED.
	SYSCON_CANSLEEPCLR_RESERVED = 0x1
	// Position of CAN1SLEEP field.
	SYSCON_CANSLEEPCLR_CAN1SLEEP_Pos = 0x1
	// Bit mask of CAN1SLEEP field.
	SYSCON_CANSLEEPCLR_CAN1SLEEP_Msk = 0x2
	// Bit CAN1SLEEP.
	SYSCON_CANSLEEPCLR_CAN1SLEEP = 0x2
	// Position of CAN2SLEEP field.
	SYSCON_CANSLEEPCLR_CAN2SLEEP_Pos = 0x2
	// Bit mask of CAN2SLEEP field.
	SYSCON_CANSLEEPCLR_CAN2SLEEP_Msk = 0x4
	// Bit CAN2SLEEP.
	SYSCON_CANSLEEPCLR_CAN2SLEEP = 0x4
	// Position of RESERVED field.
	SYSCON_CANSLEEPCLR_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	SYSCON_CANSLEEPCLR_RESERVED_Msk = 0xfffffff8

	// CANWAKEFLAGS: Allows reading the wake-up state of the CAN channels.
	// Position of RESERVED field.
	SYSCON_CANWAKEFLAGS_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	SYSCON_CANWAKEFLAGS_RESERVED_Msk = 0x1
	// Bit RESERVED.
	SYSCON_CANWAKEFLAGS_RESERVED = 0x1
	// Position of CAN1WAKE field.
	SYSCON_CANWAKEFLAGS_CAN1WAKE_Pos = 0x1
	// Bit mask of CAN1WAKE field.
	SYSCON_CANWAKEFLAGS_CAN1WAKE_Msk = 0x2
	// Bit CAN1WAKE.
	SYSCON_CANWAKEFLAGS_CAN1WAKE = 0x2
	// Position of CAN2WAKE field.
	SYSCON_CANWAKEFLAGS_CAN2WAKE_Pos = 0x2
	// Bit mask of CAN2WAKE field.
	SYSCON_CANWAKEFLAGS_CAN2WAKE_Msk = 0x4
	// Bit CAN2WAKE.
	SYSCON_CANWAKEFLAGS_CAN2WAKE = 0x4
	// Position of RESERVED field.
	SYSCON_CANWAKEFLAGS_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	SYSCON_CANWAKEFLAGS_RESERVED_Msk = 0xfffffff8

	// EXTINT: External Interrupt Flag Register
	// Position of EINT0 field.
	SYSCON_EXTINT_EINT0_Pos = 0x0
	// Bit mask of EINT0 field.
	SYSCON_EXTINT_EINT0_Msk = 0x1
	// Bit EINT0.
	SYSCON_EXTINT_EINT0 = 0x1
	// Position of EINT1 field.
	SYSCON_EXTINT_EINT1_Pos = 0x1
	// Bit mask of EINT1 field.
	SYSCON_EXTINT_EINT1_Msk = 0x2
	// Bit EINT1.
	SYSCON_EXTINT_EINT1 = 0x2
	// Position of EINT2 field.
	SYSCON_EXTINT_EINT2_Pos = 0x2
	// Bit mask of EINT2 field.
	SYSCON_EXTINT_EINT2_Msk = 0x4
	// Bit EINT2.
	SYSCON_EXTINT_EINT2 = 0x4
	// Position of EINT3 field.
	SYSCON_EXTINT_EINT3_Pos = 0x3
	// Bit mask of EINT3 field.
	SYSCON_EXTINT_EINT3_Msk = 0x8
	// Bit EINT3.
	SYSCON_EXTINT_EINT3 = 0x8
	// Position of RESERVED field.
	SYSCON_EXTINT_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	SYSCON_EXTINT_RESERVED_Msk = 0xfffffff0

	// EXTMODE: External Interrupt Mode register
	// Position of EXTMODE0 field.
	SYSCON_EXTMODE_EXTMODE0_Pos = 0x0
	// Bit mask of EXTMODE0 field.
	SYSCON_EXTMODE_EXTMODE0_Msk = 0x1
	// Bit EXTMODE0.
	SYSCON_EXTMODE_EXTMODE0 = 0x1
	// Level sensitive.
	SYSCON_EXTMODE_EXTMODE0_LEVEL_SENSITIVE_ = 0x0
	// Edge sensitive.
	SYSCON_EXTMODE_EXTMODE0_EDGE_SENSITIVE_ = 0x1
	// Position of EXTMODE1 field.
	SYSCON_EXTMODE_EXTMODE1_Pos = 0x1
	// Bit mask of EXTMODE1 field.
	SYSCON_EXTMODE_EXTMODE1_Msk = 0x2
	// Bit EXTMODE1.
	SYSCON_EXTMODE_EXTMODE1 = 0x2
	// Level sensitive.
	SYSCON_EXTMODE_EXTMODE1_LEVEL_SENSITIVE_ = 0x0
	// Edge sensitive.
	SYSCON_EXTMODE_EXTMODE1_EDGE_SENSITIVE_ = 0x1
	// Position of EXTMODE2 field.
	SYSCON_EXTMODE_EXTMODE2_Pos = 0x2
	// Bit mask of EXTMODE2 field.
	SYSCON_EXTMODE_EXTMODE2_Msk = 0x4
	// Bit EXTMODE2.
	SYSCON_EXTMODE_EXTMODE2 = 0x4
	// Level sensitive.
	SYSCON_EXTMODE_EXTMODE2_LEVEL_SENSITIVE_ = 0x0
	// Edge sensitive.
	SYSCON_EXTMODE_EXTMODE2_EDGE_SENSITIVE_ = 0x1
	// Position of EXTMODE3 field.
	SYSCON_EXTMODE_EXTMODE3_Pos = 0x3
	// Bit mask of EXTMODE3 field.
	SYSCON_EXTMODE_EXTMODE3_Msk = 0x8
	// Bit EXTMODE3.
	SYSCON_EXTMODE_EXTMODE3 = 0x8
	// Level sensitive.
	SYSCON_EXTMODE_EXTMODE3_LEVEL_SENSITIVE_ = 0x0
	// Edge sensitive.
	SYSCON_EXTMODE_EXTMODE3_EDGE_SENSITIVE_ = 0x1
	// Position of RESERVED field.
	SYSCON_EXTMODE_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	SYSCON_EXTMODE_RESERVED_Msk = 0xfffffff0

	// EXTPOLAR: External Interrupt Polarity Register
	// Position of EXTPOLAR0 field.
	SYSCON_EXTPOLAR_EXTPOLAR0_Pos = 0x0
	// Bit mask of EXTPOLAR0 field.
	SYSCON_EXTPOLAR_EXTPOLAR0_Msk = 0x1
	// Bit EXTPOLAR0.
	SYSCON_EXTPOLAR_EXTPOLAR0 = 0x1
	// Low-active or falling-edge sensitive (depending on EXTMODE0).
	SYSCON_EXTPOLAR_EXTPOLAR0_LOW_ACTIVE_OR_FALLIN = 0x0
	// High-active or rising-edge sensitive (depending on EXTMODE0).
	SYSCON_EXTPOLAR_EXTPOLAR0_HIGH_ACTIVE_OR_RISIN = 0x1
	// Position of EXTPOLAR1 field.
	SYSCON_EXTPOLAR_EXTPOLAR1_Pos = 0x1
	// Bit mask of EXTPOLAR1 field.
	SYSCON_EXTPOLAR_EXTPOLAR1_Msk = 0x2
	// Bit EXTPOLAR1.
	SYSCON_EXTPOLAR_EXTPOLAR1 = 0x2
	// Low-active or falling-edge sensitive (depending on EXTMODE1).
	SYSCON_EXTPOLAR_EXTPOLAR1_LOW_ACTIVE_OR_FALLIN = 0x0
	// High-active or rising-edge sensitive (depending on EXTMODE1).
	SYSCON_EXTPOLAR_EXTPOLAR1_HIGH_ACTIVE_OR_RISIN = 0x1
	// Position of EXTPOLAR2 field.
	SYSCON_EXTPOLAR_EXTPOLAR2_Pos = 0x2
	// Bit mask of EXTPOLAR2 field.
	SYSCON_EXTPOLAR_EXTPOLAR2_Msk = 0x4
	// Bit EXTPOLAR2.
	SYSCON_EXTPOLAR_EXTPOLAR2 = 0x4
	// Low-active or falling-edge sensitive (depending on EXTMODE2).
	SYSCON_EXTPOLAR_EXTPOLAR2_LOW_ACTIVE_OR_FALLIN = 0x0
	// High-active or rising-edge sensitive (depending on EXTMODE2).
	SYSCON_EXTPOLAR_EXTPOLAR2_HIGH_ACTIVE_OR_RISIN = 0x1
	// Position of EXTPOLAR3 field.
	SYSCON_EXTPOLAR_EXTPOLAR3_Pos = 0x3
	// Bit mask of EXTPOLAR3 field.
	SYSCON_EXTPOLAR_EXTPOLAR3_Msk = 0x8
	// Bit EXTPOLAR3.
	SYSCON_EXTPOLAR_EXTPOLAR3 = 0x8
	// Low-active or falling-edge sensitive (depending on EXTMODE3).
	SYSCON_EXTPOLAR_EXTPOLAR3_LOW_ACTIVE_OR_FALLIN = 0x0
	// High-active or rising-edge sensitive (depending on EXTMODE3).
	SYSCON_EXTPOLAR_EXTPOLAR3_HIGH_ACTIVE_OR_RISIN = 0x1
	// Position of RESERVED field.
	SYSCON_EXTPOLAR_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	SYSCON_EXTPOLAR_RESERVED_Msk = 0xfffffff0

	// RSID: Reset Source Identification Register
	// Position of POR field.
	SYSCON_RSID_POR_Pos = 0x0
	// Bit mask of POR field.
	SYSCON_RSID_POR_Msk = 0x1
	// Bit POR.
	SYSCON_RSID_POR = 0x1
	// Position of EXTR field.
	SYSCON_RSID_EXTR_Pos = 0x1
	// Bit mask of EXTR field.
	SYSCON_RSID_EXTR_Msk = 0x2
	// Bit EXTR.
	SYSCON_RSID_EXTR = 0x2
	// Position of WDTR field.
	SYSCON_RSID_WDTR_Pos = 0x2
	// Bit mask of WDTR field.
	SYSCON_RSID_WDTR_Msk = 0x4
	// Bit WDTR.
	SYSCON_RSID_WDTR = 0x4
	// Position of BODR field.
	SYSCON_RSID_BODR_Pos = 0x3
	// Bit mask of BODR field.
	SYSCON_RSID_BODR_Msk = 0x8
	// Bit BODR.
	SYSCON_RSID_BODR = 0x8
	// Position of SYSRESET field.
	SYSCON_RSID_SYSRESET_Pos = 0x4
	// Bit mask of SYSRESET field.
	SYSCON_RSID_SYSRESET_Msk = 0x10
	// Bit SYSRESET.
	SYSCON_RSID_SYSRESET = 0x10
	// Position of LOCKUP field.
	SYSCON_RSID_LOCKUP_Pos = 0x5
	// Bit mask of LOCKUP field.
	SYSCON_RSID_LOCKUP_Msk = 0x20
	// Bit LOCKUP.
	SYSCON_RSID_LOCKUP = 0x20
	// Position of RESERVED field.
	SYSCON_RSID_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	SYSCON_RSID_RESERVED_Msk = 0xffffffc0

	// MATRIXARB: Matrix arbitration register
	// Position of PRI_ICODE field.
	SYSCON_MATRIXARB_PRI_ICODE_Pos = 0x0
	// Bit mask of PRI_ICODE field.
	SYSCON_MATRIXARB_PRI_ICODE_Msk = 0x3
	// Position of PRI_DCODE field.
	SYSCON_MATRIXARB_PRI_DCODE_Pos = 0x2
	// Bit mask of PRI_DCODE field.
	SYSCON_MATRIXARB_PRI_DCODE_Msk = 0xc
	// Position of PRI_SYS field.
	SYSCON_MATRIXARB_PRI_SYS_Pos = 0x4
	// Bit mask of PRI_SYS field.
	SYSCON_MATRIXARB_PRI_SYS_Msk = 0x30
	// Position of PRI_GPDMA field.
	SYSCON_MATRIXARB_PRI_GPDMA_Pos = 0x6
	// Bit mask of PRI_GPDMA field.
	SYSCON_MATRIXARB_PRI_GPDMA_Msk = 0xc0
	// Position of PRI_ETH field.
	SYSCON_MATRIXARB_PRI_ETH_Pos = 0x8
	// Bit mask of PRI_ETH field.
	SYSCON_MATRIXARB_PRI_ETH_Msk = 0x300
	// Position of PRI_LCD field.
	SYSCON_MATRIXARB_PRI_LCD_Pos = 0xa
	// Bit mask of PRI_LCD field.
	SYSCON_MATRIXARB_PRI_LCD_Msk = 0xc00
	// Position of PRI_USB field.
	SYSCON_MATRIXARB_PRI_USB_Pos = 0xc
	// Bit mask of PRI_USB field.
	SYSCON_MATRIXARB_PRI_USB_Msk = 0x3000
	// Position of RESERVED field.
	SYSCON_MATRIXARB_RESERVED_Pos = 0xe
	// Bit mask of RESERVED field.
	SYSCON_MATRIXARB_RESERVED_Msk = 0xc000
	// Position of ROM_LAT field.
	SYSCON_MATRIXARB_ROM_LAT_Pos = 0x10
	// Bit mask of ROM_LAT field.
	SYSCON_MATRIXARB_ROM_LAT_Msk = 0x10000
	// Bit ROM_LAT.
	SYSCON_MATRIXARB_ROM_LAT = 0x10000
	// Position of RESERVED field.
	SYSCON_MATRIXARB_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	SYSCON_MATRIXARB_RESERVED_Msk = 0xfffe0000

	// SCS: System Control and Status
	// Position of EMCSC field.
	SYSCON_SCS_EMCSC_Pos = 0x0
	// Bit mask of EMCSC field.
	SYSCON_SCS_EMCSC_Msk = 0x1
	// Bit EMCSC.
	SYSCON_SCS_EMCSC = 0x1
	// Position of EMCRD field.
	SYSCON_SCS_EMCRD_Pos = 0x1
	// Bit mask of EMCRD field.
	SYSCON_SCS_EMCRD_Msk = 0x2
	// Bit EMCRD.
	SYSCON_SCS_EMCRD = 0x2
	// Both EMC resets are asserted when any type of chip reset event occurs. In this mode, all registers and functions of the EMC are initialized upon any reset condition.
	SYSCON_SCS_EMCRD_BOTH_EMC_RESETS_ARE_ = 0x0
	// Many portions of the EMC are only reset by a power-on or brown-out event, in order to allow the EMC to retain its state through a warm reset (external reset or watchdog reset). If the EMC is configured correctly, auto-refresh can be maintained through a warm reset.
	SYSCON_SCS_EMCRD_MANY_PORTIONS_OF_THE = 0x1
	// Position of EMCBC field.
	SYSCON_SCS_EMCBC_Pos = 0x2
	// Bit mask of EMCBC field.
	SYSCON_SCS_EMCBC_Msk = 0x4
	// Bit EMCBC.
	SYSCON_SCS_EMCBC = 0x4
	// Burst enabled.
	SYSCON_SCS_EMCBC_BURST_ENABLED_ = 0x0
	// Burst disabled. This mode can be used to prevent multiple sequential accesses to memory mapped I/O devices connected to EMC static memory chip selects. These unrequested accesses can cause issues with some I/O devices.
	SYSCON_SCS_EMCBC_BURST_DISABLED_THIS = 0x1
	// Position of MCIPWRAL field.
	SYSCON_SCS_MCIPWRAL_Pos = 0x3
	// Bit mask of MCIPWRAL field.
	SYSCON_SCS_MCIPWRAL_Msk = 0x8
	// Bit MCIPWRAL.
	SYSCON_SCS_MCIPWRAL = 0x8
	// SD_PWR is active low (inverted output of the SD Card interface block).
	SYSCON_SCS_MCIPWRAL_SD_PWR_IS_ACTIVE_LOW = 0x0
	// SD_PWR is active high (follows the output of the SD Card interface block).
	SYSCON_SCS_MCIPWRAL_SD_PWR_IS_ACTIVE_HIG = 0x1
	// Position of OSCRS field.
	SYSCON_SCS_OSCRS_Pos = 0x4
	// Bit mask of OSCRS field.
	SYSCON_SCS_OSCRS_Msk = 0x10
	// Bit OSCRS.
	SYSCON_SCS_OSCRS = 0x10
	// Position of OSCEN field.
	SYSCON_SCS_OSCEN_Pos = 0x5
	// Bit mask of OSCEN field.
	SYSCON_SCS_OSCEN_Msk = 0x20
	// Bit OSCEN.
	SYSCON_SCS_OSCEN = 0x20
	// Position of OSCSTAT field.
	SYSCON_SCS_OSCSTAT_Pos = 0x6
	// Bit mask of OSCSTAT field.
	SYSCON_SCS_OSCSTAT_Msk = 0x40
	// Bit OSCSTAT.
	SYSCON_SCS_OSCSTAT = 0x40
	// Position of RESERVED field.
	SYSCON_SCS_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	SYSCON_SCS_RESERVED_Msk = 0xffffff80

	// PCLKSEL: Peripheral Clock Selection register
	// Position of PCLKDIV field.
	SYSCON_PCLKSEL_PCLKDIV_Pos = 0x0
	// Bit mask of PCLKDIV field.
	SYSCON_PCLKSEL_PCLKDIV_Msk = 0x1f
	// Position of RESERVED field.
	SYSCON_PCLKSEL_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	SYSCON_PCLKSEL_RESERVED_Msk = 0xffffffe0

	// PBOOST: Power boost register
	// Position of Boost field.
	SYSCON_PBOOST_Boost_Pos = 0x0
	// Bit mask of Boost field.
	SYSCON_PBOOST_Boost_Msk = 0x3
	// Position of RESERVED field.
	SYSCON_PBOOST_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	SYSCON_PBOOST_RESERVED_Msk = 0xfffffffc

	// SPIFICLKSEL: SPIFI Clock Selection register
	// Position of SPIFIDIV field.
	SYSCON_SPIFICLKSEL_SPIFIDIV_Pos = 0x0
	// Bit mask of SPIFIDIV field.
	SYSCON_SPIFICLKSEL_SPIFIDIV_Msk = 0x1f
	// Position of RESERVED field.
	SYSCON_SPIFICLKSEL_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	SYSCON_SPIFICLKSEL_RESERVED_Msk = 0xe0
	// Position of SPIFISEL field.
	SYSCON_SPIFICLKSEL_SPIFISEL_Pos = 0x8
	// Bit mask of SPIFISEL field.
	SYSCON_SPIFICLKSEL_SPIFISEL_Msk = 0x300
	// Sysclk is used as the input to the SPIFI clock divider.
	SYSCON_SPIFICLKSEL_SPIFISEL_SYSCLK = 0x0
	// The output of the Main PLL is used as the input to the SPIFI clock divider.
	SYSCON_SPIFICLKSEL_SPIFISEL_MAINPLLOUT = 0x1
	// The output of the Alt PLL is used as the input to the SPIFI clock divider.
	SYSCON_SPIFICLKSEL_SPIFISEL_ALTPLLOUT = 0x2
	// Position of RESERVED field.
	SYSCON_SPIFICLKSEL_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	SYSCON_SPIFICLKSEL_RESERVED_Msk = 0xfffffc00

	// LCD_CFG: LCD Clock configuration register
	// Position of CLKDIV field.
	SYSCON_LCD_CFG_CLKDIV_Pos = 0x0
	// Bit mask of CLKDIV field.
	SYSCON_LCD_CFG_CLKDIV_Msk = 0x1f
	// Position of RESERVED field.
	SYSCON_LCD_CFG_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	SYSCON_LCD_CFG_RESERVED_Msk = 0xffffffe0

	// USBINTST: USB Interrupt Status
	// Position of USB_INT_REQ_LP field.
	SYSCON_USBINTST_USB_INT_REQ_LP_Pos = 0x0
	// Bit mask of USB_INT_REQ_LP field.
	SYSCON_USBINTST_USB_INT_REQ_LP_Msk = 0x1
	// Bit USB_INT_REQ_LP.
	SYSCON_USBINTST_USB_INT_REQ_LP = 0x1
	// Position of USB_INT_REQ_HP field.
	SYSCON_USBINTST_USB_INT_REQ_HP_Pos = 0x1
	// Bit mask of USB_INT_REQ_HP field.
	SYSCON_USBINTST_USB_INT_REQ_HP_Msk = 0x2
	// Bit USB_INT_REQ_HP.
	SYSCON_USBINTST_USB_INT_REQ_HP = 0x2
	// Position of USB_INT_REQ_DMA field.
	SYSCON_USBINTST_USB_INT_REQ_DMA_Pos = 0x2
	// Bit mask of USB_INT_REQ_DMA field.
	SYSCON_USBINTST_USB_INT_REQ_DMA_Msk = 0x4
	// Bit USB_INT_REQ_DMA.
	SYSCON_USBINTST_USB_INT_REQ_DMA = 0x4
	// Position of USB_HOST_INT field.
	SYSCON_USBINTST_USB_HOST_INT_Pos = 0x3
	// Bit mask of USB_HOST_INT field.
	SYSCON_USBINTST_USB_HOST_INT_Msk = 0x8
	// Bit USB_HOST_INT.
	SYSCON_USBINTST_USB_HOST_INT = 0x8
	// Position of USB_ATX_INT field.
	SYSCON_USBINTST_USB_ATX_INT_Pos = 0x4
	// Bit mask of USB_ATX_INT field.
	SYSCON_USBINTST_USB_ATX_INT_Msk = 0x10
	// Bit USB_ATX_INT.
	SYSCON_USBINTST_USB_ATX_INT = 0x10
	// Position of USB_OTG_INT field.
	SYSCON_USBINTST_USB_OTG_INT_Pos = 0x5
	// Bit mask of USB_OTG_INT field.
	SYSCON_USBINTST_USB_OTG_INT_Msk = 0x20
	// Bit USB_OTG_INT.
	SYSCON_USBINTST_USB_OTG_INT = 0x20
	// Position of USB_I2C_INT field.
	SYSCON_USBINTST_USB_I2C_INT_Pos = 0x6
	// Bit mask of USB_I2C_INT field.
	SYSCON_USBINTST_USB_I2C_INT_Msk = 0x40
	// Bit USB_I2C_INT.
	SYSCON_USBINTST_USB_I2C_INT = 0x40
	// Position of RESERVED field.
	SYSCON_USBINTST_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	SYSCON_USBINTST_RESERVED_Msk = 0x80
	// Bit RESERVED.
	SYSCON_USBINTST_RESERVED = 0x80
	// Position of USB_NEED_CLK field.
	SYSCON_USBINTST_USB_NEED_CLK_Pos = 0x8
	// Bit mask of USB_NEED_CLK field.
	SYSCON_USBINTST_USB_NEED_CLK_Msk = 0x100
	// Bit USB_NEED_CLK.
	SYSCON_USBINTST_USB_NEED_CLK = 0x100
	// Position of RESERVED field.
	SYSCON_USBINTST_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	SYSCON_USBINTST_RESERVED_Msk = 0x7ffffe00
	// Position of EN_USB_INTS field.
	SYSCON_USBINTST_EN_USB_INTS_Pos = 0x1f
	// Bit mask of EN_USB_INTS field.
	SYSCON_USBINTST_EN_USB_INTS_Msk = 0x80000000
	// Bit EN_USB_INTS.
	SYSCON_USBINTST_EN_USB_INTS = 0x80000000

	// DMACREQSEL: Selects between alternative requests on DMA channels 0 through 7 and 10 through 15
	// Position of DMASEL00 field.
	SYSCON_DMACREQSEL_DMASEL00_Pos = 0x0
	// Bit mask of DMASEL00 field.
	SYSCON_DMACREQSEL_DMASEL00_Msk = 0x1
	// Bit DMASEL00.
	SYSCON_DMACREQSEL_DMASEL00 = 0x1
	// Position of DMASEL01 field.
	SYSCON_DMACREQSEL_DMASEL01_Pos = 0x1
	// Bit mask of DMASEL01 field.
	SYSCON_DMACREQSEL_DMASEL01_Msk = 0x2
	// Bit DMASEL01.
	SYSCON_DMACREQSEL_DMASEL01 = 0x2
	// Position of DMASEL02 field.
	SYSCON_DMACREQSEL_DMASEL02_Pos = 0x2
	// Bit mask of DMASEL02 field.
	SYSCON_DMACREQSEL_DMASEL02_Msk = 0x4
	// Bit DMASEL02.
	SYSCON_DMACREQSEL_DMASEL02 = 0x4
	// Position of DMASEL03 field.
	SYSCON_DMACREQSEL_DMASEL03_Pos = 0x3
	// Bit mask of DMASEL03 field.
	SYSCON_DMACREQSEL_DMASEL03_Msk = 0x8
	// Bit DMASEL03.
	SYSCON_DMACREQSEL_DMASEL03 = 0x8
	// Position of DMASEL04 field.
	SYSCON_DMACREQSEL_DMASEL04_Pos = 0x4
	// Bit mask of DMASEL04 field.
	SYSCON_DMACREQSEL_DMASEL04_Msk = 0x10
	// Bit DMASEL04.
	SYSCON_DMACREQSEL_DMASEL04 = 0x10
	// Position of DMASEL05 field.
	SYSCON_DMACREQSEL_DMASEL05_Pos = 0x5
	// Bit mask of DMASEL05 field.
	SYSCON_DMACREQSEL_DMASEL05_Msk = 0x20
	// Bit DMASEL05.
	SYSCON_DMACREQSEL_DMASEL05 = 0x20
	// Position of DMASEL06 field.
	SYSCON_DMACREQSEL_DMASEL06_Pos = 0x6
	// Bit mask of DMASEL06 field.
	SYSCON_DMACREQSEL_DMASEL06_Msk = 0x40
	// Bit DMASEL06.
	SYSCON_DMACREQSEL_DMASEL06 = 0x40
	// Position of DMASEL07 field.
	SYSCON_DMACREQSEL_DMASEL07_Pos = 0x7
	// Bit mask of DMASEL07 field.
	SYSCON_DMACREQSEL_DMASEL07_Msk = 0x80
	// Bit DMASEL07.
	SYSCON_DMACREQSEL_DMASEL07 = 0x80
	// Position of RESERVED field.
	SYSCON_DMACREQSEL_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SYSCON_DMACREQSEL_RESERVED_Msk = 0x300
	// Position of DMASEL10 field.
	SYSCON_DMACREQSEL_DMASEL10_Pos = 0xa
	// Bit mask of DMASEL10 field.
	SYSCON_DMACREQSEL_DMASEL10_Msk = 0x400
	// Bit DMASEL10.
	SYSCON_DMACREQSEL_DMASEL10 = 0x400
	// Position of DMASEL11 field.
	SYSCON_DMACREQSEL_DMASEL11_Pos = 0xb
	// Bit mask of DMASEL11 field.
	SYSCON_DMACREQSEL_DMASEL11_Msk = 0x800
	// Bit DMASEL11.
	SYSCON_DMACREQSEL_DMASEL11 = 0x800
	// Position of DMASEL12 field.
	SYSCON_DMACREQSEL_DMASEL12_Pos = 0xc
	// Bit mask of DMASEL12 field.
	SYSCON_DMACREQSEL_DMASEL12_Msk = 0x1000
	// Bit DMASEL12.
	SYSCON_DMACREQSEL_DMASEL12 = 0x1000
	// Position of DMASEL13 field.
	SYSCON_DMACREQSEL_DMASEL13_Pos = 0xd
	// Bit mask of DMASEL13 field.
	SYSCON_DMACREQSEL_DMASEL13_Msk = 0x2000
	// Bit DMASEL13.
	SYSCON_DMACREQSEL_DMASEL13 = 0x2000
	// Position of DMASEL14 field.
	SYSCON_DMACREQSEL_DMASEL14_Pos = 0xe
	// Bit mask of DMASEL14 field.
	SYSCON_DMACREQSEL_DMASEL14_Msk = 0x4000
	// Bit DMASEL14.
	SYSCON_DMACREQSEL_DMASEL14 = 0x4000
	// Position of DMASEL15 field.
	SYSCON_DMACREQSEL_DMASEL15_Pos = 0xf
	// Bit mask of DMASEL15 field.
	SYSCON_DMACREQSEL_DMASEL15_Msk = 0x8000
	// Bit DMASEL15.
	SYSCON_DMACREQSEL_DMASEL15 = 0x8000
	// Position of RESERVED field.
	SYSCON_DMACREQSEL_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	SYSCON_DMACREQSEL_RESERVED_Msk = 0xffff0000

	// CLKOUTCFG: Clock Output Configuration register
	// Position of CLKOUTSEL field.
	SYSCON_CLKOUTCFG_CLKOUTSEL_Pos = 0x0
	// Bit mask of CLKOUTSEL field.
	SYSCON_CLKOUTCFG_CLKOUTSEL_Msk = 0xf
	// Position of CLKOUTDIV field.
	SYSCON_CLKOUTCFG_CLKOUTDIV_Pos = 0x4
	// Bit mask of CLKOUTDIV field.
	SYSCON_CLKOUTCFG_CLKOUTDIV_Msk = 0xf0
	// Position of CLKOUT_EN field.
	SYSCON_CLKOUTCFG_CLKOUT_EN_Pos = 0x8
	// Bit mask of CLKOUT_EN field.
	SYSCON_CLKOUTCFG_CLKOUT_EN_Msk = 0x100
	// Bit CLKOUT_EN.
	SYSCON_CLKOUTCFG_CLKOUT_EN = 0x100
	// Position of CLKOUT_ACT field.
	SYSCON_CLKOUTCFG_CLKOUT_ACT_Pos = 0x9
	// Bit mask of CLKOUT_ACT field.
	SYSCON_CLKOUTCFG_CLKOUT_ACT_Msk = 0x200
	// Bit CLKOUT_ACT.
	SYSCON_CLKOUTCFG_CLKOUT_ACT = 0x200
	// Position of RESERVED field.
	SYSCON_CLKOUTCFG_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	SYSCON_CLKOUTCFG_RESERVED_Msk = 0xfffffc00

	// RSTCON0: Individual peripheral reset control bits
	// Position of RSTLCD field.
	SYSCON_RSTCON0_RSTLCD_Pos = 0x0
	// Bit mask of RSTLCD field.
	SYSCON_RSTCON0_RSTLCD_Msk = 0x1
	// Bit RSTLCD.
	SYSCON_RSTCON0_RSTLCD = 0x1
	// Position of RSTTIM0 field.
	SYSCON_RSTCON0_RSTTIM0_Pos = 0x1
	// Bit mask of RSTTIM0 field.
	SYSCON_RSTCON0_RSTTIM0_Msk = 0x2
	// Bit RSTTIM0.
	SYSCON_RSTCON0_RSTTIM0 = 0x2
	// Position of RSTTIM1 field.
	SYSCON_RSTCON0_RSTTIM1_Pos = 0x2
	// Bit mask of RSTTIM1 field.
	SYSCON_RSTCON0_RSTTIM1_Msk = 0x4
	// Bit RSTTIM1.
	SYSCON_RSTCON0_RSTTIM1 = 0x4
	// Position of RSTUART0 field.
	SYSCON_RSTCON0_RSTUART0_Pos = 0x3
	// Bit mask of RSTUART0 field.
	SYSCON_RSTCON0_RSTUART0_Msk = 0x8
	// Bit RSTUART0.
	SYSCON_RSTCON0_RSTUART0 = 0x8
	// Position of RSTUART1 field.
	SYSCON_RSTCON0_RSTUART1_Pos = 0x4
	// Bit mask of RSTUART1 field.
	SYSCON_RSTCON0_RSTUART1_Msk = 0x10
	// Bit RSTUART1.
	SYSCON_RSTCON0_RSTUART1 = 0x10
	// Position of RSTPWM0 field.
	SYSCON_RSTCON0_RSTPWM0_Pos = 0x5
	// Bit mask of RSTPWM0 field.
	SYSCON_RSTCON0_RSTPWM0_Msk = 0x20
	// Bit RSTPWM0.
	SYSCON_RSTCON0_RSTPWM0 = 0x20
	// Position of RSTPWM1 field.
	SYSCON_RSTCON0_RSTPWM1_Pos = 0x6
	// Bit mask of RSTPWM1 field.
	SYSCON_RSTCON0_RSTPWM1_Msk = 0x40
	// Bit RSTPWM1.
	SYSCON_RSTCON0_RSTPWM1 = 0x40
	// Position of RSTI2C0 field.
	SYSCON_RSTCON0_RSTI2C0_Pos = 0x7
	// Bit mask of RSTI2C0 field.
	SYSCON_RSTCON0_RSTI2C0_Msk = 0x80
	// Bit RSTI2C0.
	SYSCON_RSTCON0_RSTI2C0 = 0x80
	// Position of RSTUART4 field.
	SYSCON_RSTCON0_RSTUART4_Pos = 0x8
	// Bit mask of RSTUART4 field.
	SYSCON_RSTCON0_RSTUART4_Msk = 0x100
	// Bit RSTUART4.
	SYSCON_RSTCON0_RSTUART4 = 0x100
	// Position of RSTRTC field.
	SYSCON_RSTCON0_RSTRTC_Pos = 0x9
	// Bit mask of RSTRTC field.
	SYSCON_RSTCON0_RSTRTC_Msk = 0x200
	// Bit RSTRTC.
	SYSCON_RSTCON0_RSTRTC = 0x200
	// Position of RSTSSP1 field.
	SYSCON_RSTCON0_RSTSSP1_Pos = 0xa
	// Bit mask of RSTSSP1 field.
	SYSCON_RSTCON0_RSTSSP1_Msk = 0x400
	// Bit RSTSSP1.
	SYSCON_RSTCON0_RSTSSP1 = 0x400
	// Position of RSTEMC field.
	SYSCON_RSTCON0_RSTEMC_Pos = 0xb
	// Bit mask of RSTEMC field.
	SYSCON_RSTCON0_RSTEMC_Msk = 0x800
	// Bit RSTEMC.
	SYSCON_RSTCON0_RSTEMC = 0x800
	// Position of RSTADC field.
	SYSCON_RSTCON0_RSTADC_Pos = 0xc
	// Bit mask of RSTADC field.
	SYSCON_RSTCON0_RSTADC_Msk = 0x1000
	// Bit RSTADC.
	SYSCON_RSTCON0_RSTADC = 0x1000
	// Position of RSTCAN1 field.
	SYSCON_RSTCON0_RSTCAN1_Pos = 0xd
	// Bit mask of RSTCAN1 field.
	SYSCON_RSTCON0_RSTCAN1_Msk = 0x2000
	// Bit RSTCAN1.
	SYSCON_RSTCON0_RSTCAN1 = 0x2000
	// Position of RSTCAN2 field.
	SYSCON_RSTCON0_RSTCAN2_Pos = 0xe
	// Bit mask of RSTCAN2 field.
	SYSCON_RSTCON0_RSTCAN2_Msk = 0x4000
	// Bit RSTCAN2.
	SYSCON_RSTCON0_RSTCAN2 = 0x4000
	// Position of RSTGPIO field.
	SYSCON_RSTCON0_RSTGPIO_Pos = 0xf
	// Bit mask of RSTGPIO field.
	SYSCON_RSTCON0_RSTGPIO_Msk = 0x8000
	// Bit RSTGPIO.
	SYSCON_RSTCON0_RSTGPIO = 0x8000
	// Position of RSTSPIFI field.
	SYSCON_RSTCON0_RSTSPIFI_Pos = 0x10
	// Bit mask of RSTSPIFI field.
	SYSCON_RSTCON0_RSTSPIFI_Msk = 0x10000
	// Bit RSTSPIFI.
	SYSCON_RSTCON0_RSTSPIFI = 0x10000
	// Position of RSTMCPWM field.
	SYSCON_RSTCON0_RSTMCPWM_Pos = 0x11
	// Bit mask of RSTMCPWM field.
	SYSCON_RSTCON0_RSTMCPWM_Msk = 0x20000
	// Bit RSTMCPWM.
	SYSCON_RSTCON0_RSTMCPWM = 0x20000
	// Position of RSTQEI field.
	SYSCON_RSTCON0_RSTQEI_Pos = 0x12
	// Bit mask of RSTQEI field.
	SYSCON_RSTCON0_RSTQEI_Msk = 0x40000
	// Bit RSTQEI.
	SYSCON_RSTCON0_RSTQEI = 0x40000
	// Position of RSTI2C1 field.
	SYSCON_RSTCON0_RSTI2C1_Pos = 0x13
	// Bit mask of RSTI2C1 field.
	SYSCON_RSTCON0_RSTI2C1_Msk = 0x80000
	// Bit RSTI2C1.
	SYSCON_RSTCON0_RSTI2C1 = 0x80000
	// Position of RSTSSP2 field.
	SYSCON_RSTCON0_RSTSSP2_Pos = 0x14
	// Bit mask of RSTSSP2 field.
	SYSCON_RSTCON0_RSTSSP2_Msk = 0x100000
	// Bit RSTSSP2.
	SYSCON_RSTCON0_RSTSSP2 = 0x100000
	// Position of RSTSSP0 field.
	SYSCON_RSTCON0_RSTSSP0_Pos = 0x15
	// Bit mask of RSTSSP0 field.
	SYSCON_RSTCON0_RSTSSP0_Msk = 0x200000
	// Bit RSTSSP0.
	SYSCON_RSTCON0_RSTSSP0 = 0x200000
	// Position of RSTTIM2 field.
	SYSCON_RSTCON0_RSTTIM2_Pos = 0x16
	// Bit mask of RSTTIM2 field.
	SYSCON_RSTCON0_RSTTIM2_Msk = 0x400000
	// Bit RSTTIM2.
	SYSCON_RSTCON0_RSTTIM2 = 0x400000
	// Position of RSTTIM3 field.
	SYSCON_RSTCON0_RSTTIM3_Pos = 0x17
	// Bit mask of RSTTIM3 field.
	SYSCON_RSTCON0_RSTTIM3_Msk = 0x800000
	// Bit RSTTIM3.
	SYSCON_RSTCON0_RSTTIM3 = 0x800000
	// Position of RSTUART2 field.
	SYSCON_RSTCON0_RSTUART2_Pos = 0x18
	// Bit mask of RSTUART2 field.
	SYSCON_RSTCON0_RSTUART2_Msk = 0x1000000
	// Bit RSTUART2.
	SYSCON_RSTCON0_RSTUART2 = 0x1000000
	// Position of RSTUART3 field.
	SYSCON_RSTCON0_RSTUART3_Pos = 0x19
	// Bit mask of RSTUART3 field.
	SYSCON_RSTCON0_RSTUART3_Msk = 0x2000000
	// Bit RSTUART3.
	SYSCON_RSTCON0_RSTUART3 = 0x2000000
	// Position of RSTI2C2 field.
	SYSCON_RSTCON0_RSTI2C2_Pos = 0x1a
	// Bit mask of RSTI2C2 field.
	SYSCON_RSTCON0_RSTI2C2_Msk = 0x4000000
	// Bit RSTI2C2.
	SYSCON_RSTCON0_RSTI2C2 = 0x4000000
	// Position of RSTI2S field.
	SYSCON_RSTCON0_RSTI2S_Pos = 0x1b
	// Bit mask of RSTI2S field.
	SYSCON_RSTCON0_RSTI2S_Msk = 0x8000000
	// Bit RSTI2S.
	SYSCON_RSTCON0_RSTI2S = 0x8000000
	// Position of RSTSDC field.
	SYSCON_RSTCON0_RSTSDC_Pos = 0x1c
	// Bit mask of RSTSDC field.
	SYSCON_RSTCON0_RSTSDC_Msk = 0x10000000
	// Bit RSTSDC.
	SYSCON_RSTCON0_RSTSDC = 0x10000000
	// Position of RSTGPDMA field.
	SYSCON_RSTCON0_RSTGPDMA_Pos = 0x1d
	// Bit mask of RSTGPDMA field.
	SYSCON_RSTCON0_RSTGPDMA_Msk = 0x20000000
	// Bit RSTGPDMA.
	SYSCON_RSTCON0_RSTGPDMA = 0x20000000
	// Position of RSTENET field.
	SYSCON_RSTCON0_RSTENET_Pos = 0x1e
	// Bit mask of RSTENET field.
	SYSCON_RSTCON0_RSTENET_Msk = 0x40000000
	// Bit RSTENET.
	SYSCON_RSTCON0_RSTENET = 0x40000000
	// Position of RSTUSB field.
	SYSCON_RSTCON0_RSTUSB_Pos = 0x1f
	// Bit mask of RSTUSB field.
	SYSCON_RSTCON0_RSTUSB_Msk = 0x80000000
	// Bit RSTUSB.
	SYSCON_RSTCON0_RSTUSB = 0x80000000

	// RSTCON1: Individual peripheral reset control bits
	// Position of RSTIOCON field.
	SYSCON_RSTCON1_RSTIOCON_Pos = 0x0
	// Bit mask of RSTIOCON field.
	SYSCON_RSTCON1_RSTIOCON_Msk = 0x1
	// Bit RSTIOCON.
	SYSCON_RSTCON1_RSTIOCON = 0x1
	// Position of RSTDAC field.
	SYSCON_RSTCON1_RSTDAC_Pos = 0x1
	// Bit mask of RSTDAC field.
	SYSCON_RSTCON1_RSTDAC_Msk = 0x2
	// Bit RSTDAC.
	SYSCON_RSTCON1_RSTDAC = 0x2
	// Position of RSTCANACC field.
	SYSCON_RSTCON1_RSTCANACC_Pos = 0x2
	// Bit mask of RSTCANACC field.
	SYSCON_RSTCON1_RSTCANACC_Msk = 0x4
	// Bit RSTCANACC.
	SYSCON_RSTCON1_RSTCANACC = 0x4
	// Position of RSTCMP field.
	SYSCON_RSTCON1_RSTCMP_Pos = 0x3
	// Bit mask of RSTCMP field.
	SYSCON_RSTCON1_RSTCMP_Msk = 0x8
	// Bit RSTCMP.
	SYSCON_RSTCON1_RSTCMP = 0x8
	// Position of RESERVED field.
	SYSCON_RSTCON1_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	SYSCON_RSTCON1_RESERVED_Msk = 0xfffffff0

	// EMCDLYCTL: Values for the 4 programmable delays associated with SDRAM operation.
	// Position of CMDDLY field.
	SYSCON_EMCDLYCTL_CMDDLY_Pos = 0x0
	// Bit mask of CMDDLY field.
	SYSCON_EMCDLYCTL_CMDDLY_Msk = 0x1f
	// Position of RESERVED field.
	SYSCON_EMCDLYCTL_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	SYSCON_EMCDLYCTL_RESERVED_Msk = 0xe0
	// Position of FBCLKDLY field.
	SYSCON_EMCDLYCTL_FBCLKDLY_Pos = 0x8
	// Bit mask of FBCLKDLY field.
	SYSCON_EMCDLYCTL_FBCLKDLY_Msk = 0x1f00
	// Position of RESERVED field.
	SYSCON_EMCDLYCTL_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	SYSCON_EMCDLYCTL_RESERVED_Msk = 0xe000
	// Position of CLKOUT0DLY field.
	SYSCON_EMCDLYCTL_CLKOUT0DLY_Pos = 0x10
	// Bit mask of CLKOUT0DLY field.
	SYSCON_EMCDLYCTL_CLKOUT0DLY_Msk = 0x1f0000
	// Position of RESERVED field.
	SYSCON_EMCDLYCTL_RESERVED_Pos = 0x15
	// Bit mask of RESERVED field.
	SYSCON_EMCDLYCTL_RESERVED_Msk = 0xe00000
	// Position of CLKOUT1DLY field.
	SYSCON_EMCDLYCTL_CLKOUT1DLY_Pos = 0x18
	// Bit mask of CLKOUT1DLY field.
	SYSCON_EMCDLYCTL_CLKOUT1DLY_Msk = 0x1f000000
	// Position of RESERVED field.
	SYSCON_EMCDLYCTL_RESERVED_Pos = 0x1d
	// Bit mask of RESERVED field.
	SYSCON_EMCDLYCTL_RESERVED_Msk = 0xe0000000

	// EMCCAL: Controls the calibration counter for programmable delays and returns the result value.
	// Position of CALVALUE field.
	SYSCON_EMCCAL_CALVALUE_Pos = 0x0
	// Bit mask of CALVALUE field.
	SYSCON_EMCCAL_CALVALUE_Msk = 0xff
	// Position of RESERVED field.
	SYSCON_EMCCAL_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SYSCON_EMCCAL_RESERVED_Msk = 0x3f00
	// Position of START field.
	SYSCON_EMCCAL_START_Pos = 0xe
	// Bit mask of START field.
	SYSCON_EMCCAL_START_Msk = 0x4000
	// Bit START.
	SYSCON_EMCCAL_START = 0x4000
	// Position of DONE field.
	SYSCON_EMCCAL_DONE_Pos = 0xf
	// Bit mask of DONE field.
	SYSCON_EMCCAL_DONE_Msk = 0x8000
	// Bit DONE.
	SYSCON_EMCCAL_DONE = 0x8000
	// Position of RESERVED field.
	SYSCON_EMCCAL_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	SYSCON_EMCCAL_RESERVED_Msk = 0xffff0000
)
