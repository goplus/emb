// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from MIMXRT1011.svd, see https://github.com/posborne/cmsis-svd/tree/master/data/NXP

//go:build nxp && mimxrt1011

/*
// MIMXRT1011DAE5A
*/
//     Copyright 2016-2019 NXP All rights reserved. SPDX-License-Identifier: BSD-3-Clause
package nxp

import (
	"github.com/goplus/emb/runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device       = "MIMXRT1011"
	CPU          = "CM7"
	FPUPresent   = true
	NVICPrioBits = 4
)

// Interrupt numbers.
const (
	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA0 = 0

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA1 = 1

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA2 = 2

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA3 = 3

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA4 = 4

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA5 = 5

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA6 = 6

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA7 = 7

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA8 = 8

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA9 = 9

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA10 = 10

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA11 = 11

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA12 = 12

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA13 = 13

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA14 = 14

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA15 = 15

	// DMA // Nested Vectored Interrupt Controller
	IRQ_DMA_ERROR = 16

	// Nested Vectored Interrupt Controller
	IRQ_CTI0_ERROR = 17

	// Nested Vectored Interrupt Controller
	IRQ_CTI1_ERROR = 18

	// Nested Vectored Interrupt Controller
	IRQ_CORE = 19

	// LPUART // Nested Vectored Interrupt Controller
	IRQ_LPUART1 = 20

	// Nested Vectored Interrupt Controller // LPUART
	IRQ_LPUART2 = 21

	// Nested Vectored Interrupt Controller // LPUART
	IRQ_LPUART3 = 22

	// Nested Vectored Interrupt Controller // LPUART
	IRQ_LPUART4 = 23

	// PIT // Nested Vectored Interrupt Controller
	IRQ_PIT = 24

	// USB // Nested Vectored Interrupt Controller
	IRQ_USB_OTG1 = 25

	// FlexSPI // Nested Vectored Interrupt Controller
	IRQ_FLEXSPI = 26

	// FLEXRAM // Nested Vectored Interrupt Controller
	IRQ_FLEXRAM = 27

	// LPI2C // Nested Vectored Interrupt Controller
	IRQ_LPI2C1 = 28

	// Nested Vectored Interrupt Controller // LPI2C
	IRQ_LPI2C2 = 29

	// GPT // Nested Vectored Interrupt Controller
	IRQ_GPT1 = 30

	// Nested Vectored Interrupt Controller // GPT
	IRQ_GPT2 = 31

	// LPSPI // Nested Vectored Interrupt Controller
	IRQ_LPSPI1 = 32

	// Nested Vectored Interrupt Controller // LPSPI
	IRQ_LPSPI2 = 33

	// PWM // Nested Vectored Interrupt Controller
	IRQ_PWM1_0 = 34

	// PWM // Nested Vectored Interrupt Controller
	IRQ_PWM1_1 = 35

	// PWM // Nested Vectored Interrupt Controller
	IRQ_PWM1_2 = 36

	// PWM // Nested Vectored Interrupt Controller
	IRQ_PWM1_3 = 37

	// PWM // Nested Vectored Interrupt Controller
	IRQ_PWM1_FAULT = 38

	// KPP Registers // Nested Vectored Interrupt Controller
	IRQ_KPP = 39

	// SRC // Nested Vectored Interrupt Controller
	IRQ_SRC = 40

	// Nested Vectored Interrupt Controller
	IRQ_GPR_IRQ = 41

	// CCM // Nested Vectored Interrupt Controller
	IRQ_CCM_1 = 42

	// CCM // Nested Vectored Interrupt Controller
	IRQ_CCM_2 = 43

	// EWM // Nested Vectored Interrupt Controller
	IRQ_EWM = 44

	// Nested Vectored Interrupt Controller // WDOG
	IRQ_WDOG2 = 45

	// SNVS // Nested Vectored Interrupt Controller
	IRQ_SNVS_HP_WRAPPER = 46

	// SNVS // Nested Vectored Interrupt Controller
	IRQ_SNVS_HP_WRAPPER_TZ = 47

	// SNVS // Nested Vectored Interrupt Controller
	IRQ_SNVS_LP_WRAPPER = 48

	// CSU registers // Nested Vectored Interrupt Controller
	IRQ_CSU = 49

	// DCP register reference index // Nested Vectored Interrupt Controller
	IRQ_DCP = 50

	// DCP register reference index // Nested Vectored Interrupt Controller
	IRQ_DCP_VMI = 51

	// Nested Vectored Interrupt Controller
	IRQ_Reserved68 = 52

	// TRNG // Nested Vectored Interrupt Controller
	IRQ_TRNG = 53

	// Nested Vectored Interrupt Controller
	IRQ_Reserved70 = 54

	// Nested Vectored Interrupt Controller
	IRQ_Reserved71 = 55

	// I2S // Nested Vectored Interrupt Controller
	IRQ_SAI1 = 56

	// WDOG // Nested Vectored Interrupt Controller
	IRQ_RTWDOG = 57

	// Nested Vectored Interrupt Controller // I2S
	IRQ_SAI3_RX = 58

	// Nested Vectored Interrupt Controller // I2S
	IRQ_SAI3_TX = 59

	// SPDIF // Nested Vectored Interrupt Controller
	IRQ_SPDIF = 60

	// PMU // Nested Vectored Interrupt Controller
	IRQ_PMU = 61

	// Nested Vectored Interrupt Controller
	IRQ_XBAR1_IRQ_0_1_2_3 = 62

	// Temperature Monitor // Nested Vectored Interrupt Controller
	IRQ_TEMP_LOW_HIGH = 63

	// Temperature Monitor // Nested Vectored Interrupt Controller
	IRQ_TEMP_PANIC = 64

	// USBPHY Register Reference Index // Nested Vectored Interrupt Controller
	IRQ_USB_PHY = 65

	// GPC // Nested Vectored Interrupt Controller
	IRQ_GPC = 66

	// Analog-to-Digital Converter // Nested Vectored Interrupt Controller
	IRQ_ADC1 = 67

	// FLEXIO // Nested Vectored Interrupt Controller
	IRQ_FLEXIO1 = 68

	// DCDC // Nested Vectored Interrupt Controller
	IRQ_DCDC = 69

	// GPIO // Nested Vectored Interrupt Controller
	IRQ_GPIO1_Combined_0_15 = 70

	// GPIO // Nested Vectored Interrupt Controller
	IRQ_GPIO1_Combined_16_31 = 71

	// Nested Vectored Interrupt Controller // GPIO
	IRQ_GPIO2_Combined_0_15 = 72

	// Nested Vectored Interrupt Controller // GPIO
	IRQ_GPIO5_Combined_0_15 = 73

	// WDOG // Nested Vectored Interrupt Controller
	IRQ_WDOG1 = 74

	// ADC_ETC // Nested Vectored Interrupt Controller
	IRQ_ADC_ETC_IRQ0 = 75

	// ADC_ETC // Nested Vectored Interrupt Controller
	IRQ_ADC_ETC_IRQ1 = 76

	// ADC_ETC // Nested Vectored Interrupt Controller
	IRQ_ADC_ETC_IRQ2 = 77

	// ADC_ETC // Nested Vectored Interrupt Controller
	IRQ_ADC_ETC_IRQ3 = 78

	// ADC_ETC // Nested Vectored Interrupt Controller
	IRQ_ADC_ETC_ERROR_IRQ = 79

	// Highest interrupt number on this device.
	IRQ_max = 79
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//
// NOTE(zzy): runtime/interrupt.callHandlers is not yet implemented in LLGO
// Original linkname: //go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int) {
	// TODO: implement interrupt handler dispatch mechanism
}

//export DMA0_IRQHandler
func interruptDMA0() {
	callHandlers(IRQ_DMA0)
}

//export DMA1_IRQHandler
func interruptDMA1() {
	callHandlers(IRQ_DMA1)
}

//export DMA2_IRQHandler
func interruptDMA2() {
	callHandlers(IRQ_DMA2)
}

//export DMA3_IRQHandler
func interruptDMA3() {
	callHandlers(IRQ_DMA3)
}

//export DMA4_IRQHandler
func interruptDMA4() {
	callHandlers(IRQ_DMA4)
}

//export DMA5_IRQHandler
func interruptDMA5() {
	callHandlers(IRQ_DMA5)
}

//export DMA6_IRQHandler
func interruptDMA6() {
	callHandlers(IRQ_DMA6)
}

//export DMA7_IRQHandler
func interruptDMA7() {
	callHandlers(IRQ_DMA7)
}

//export DMA8_IRQHandler
func interruptDMA8() {
	callHandlers(IRQ_DMA8)
}

//export DMA9_IRQHandler
func interruptDMA9() {
	callHandlers(IRQ_DMA9)
}

//export DMA10_IRQHandler
func interruptDMA10() {
	callHandlers(IRQ_DMA10)
}

//export DMA11_IRQHandler
func interruptDMA11() {
	callHandlers(IRQ_DMA11)
}

//export DMA12_IRQHandler
func interruptDMA12() {
	callHandlers(IRQ_DMA12)
}

//export DMA13_IRQHandler
func interruptDMA13() {
	callHandlers(IRQ_DMA13)
}

//export DMA14_IRQHandler
func interruptDMA14() {
	callHandlers(IRQ_DMA14)
}

//export DMA15_IRQHandler
func interruptDMA15() {
	callHandlers(IRQ_DMA15)
}

//export DMA_ERROR_IRQHandler
func interruptDMA_ERROR() {
	callHandlers(IRQ_DMA_ERROR)
}

//export CTI0_ERROR_IRQHandler
func interruptCTI0_ERROR() {
	callHandlers(IRQ_CTI0_ERROR)
}

//export CTI1_ERROR_IRQHandler
func interruptCTI1_ERROR() {
	callHandlers(IRQ_CTI1_ERROR)
}

//export CORE_IRQHandler
func interruptCORE() {
	callHandlers(IRQ_CORE)
}

//export LPUART1_IRQHandler
func interruptLPUART1() {
	callHandlers(IRQ_LPUART1)
}

//export LPUART2_IRQHandler
func interruptLPUART2() {
	callHandlers(IRQ_LPUART2)
}

//export LPUART3_IRQHandler
func interruptLPUART3() {
	callHandlers(IRQ_LPUART3)
}

//export LPUART4_IRQHandler
func interruptLPUART4() {
	callHandlers(IRQ_LPUART4)
}

//export PIT_IRQHandler
func interruptPIT() {
	callHandlers(IRQ_PIT)
}

//export USB_OTG1_IRQHandler
func interruptUSB_OTG1() {
	callHandlers(IRQ_USB_OTG1)
}

//export FLEXSPI_IRQHandler
func interruptFLEXSPI() {
	callHandlers(IRQ_FLEXSPI)
}

//export FLEXRAM_IRQHandler
func interruptFLEXRAM() {
	callHandlers(IRQ_FLEXRAM)
}

//export LPI2C1_IRQHandler
func interruptLPI2C1() {
	callHandlers(IRQ_LPI2C1)
}

//export LPI2C2_IRQHandler
func interruptLPI2C2() {
	callHandlers(IRQ_LPI2C2)
}

//export GPT1_IRQHandler
func interruptGPT1() {
	callHandlers(IRQ_GPT1)
}

//export GPT2_IRQHandler
func interruptGPT2() {
	callHandlers(IRQ_GPT2)
}

//export LPSPI1_IRQHandler
func interruptLPSPI1() {
	callHandlers(IRQ_LPSPI1)
}

//export LPSPI2_IRQHandler
func interruptLPSPI2() {
	callHandlers(IRQ_LPSPI2)
}

//export PWM1_0_IRQHandler
func interruptPWM1_0() {
	callHandlers(IRQ_PWM1_0)
}

//export PWM1_1_IRQHandler
func interruptPWM1_1() {
	callHandlers(IRQ_PWM1_1)
}

//export PWM1_2_IRQHandler
func interruptPWM1_2() {
	callHandlers(IRQ_PWM1_2)
}

//export PWM1_3_IRQHandler
func interruptPWM1_3() {
	callHandlers(IRQ_PWM1_3)
}

//export PWM1_FAULT_IRQHandler
func interruptPWM1_FAULT() {
	callHandlers(IRQ_PWM1_FAULT)
}

//export KPP_IRQHandler
func interruptKPP() {
	callHandlers(IRQ_KPP)
}

//export SRC_IRQHandler
func interruptSRC() {
	callHandlers(IRQ_SRC)
}

//export GPR_IRQ_IRQHandler
func interruptGPR_IRQ() {
	callHandlers(IRQ_GPR_IRQ)
}

//export CCM_1_IRQHandler
func interruptCCM_1() {
	callHandlers(IRQ_CCM_1)
}

//export CCM_2_IRQHandler
func interruptCCM_2() {
	callHandlers(IRQ_CCM_2)
}

//export EWM_IRQHandler
func interruptEWM() {
	callHandlers(IRQ_EWM)
}

//export WDOG2_IRQHandler
func interruptWDOG2() {
	callHandlers(IRQ_WDOG2)
}

//export SNVS_HP_WRAPPER_IRQHandler
func interruptSNVS_HP_WRAPPER() {
	callHandlers(IRQ_SNVS_HP_WRAPPER)
}

//export SNVS_HP_WRAPPER_TZ_IRQHandler
func interruptSNVS_HP_WRAPPER_TZ() {
	callHandlers(IRQ_SNVS_HP_WRAPPER_TZ)
}

//export SNVS_LP_WRAPPER_IRQHandler
func interruptSNVS_LP_WRAPPER() {
	callHandlers(IRQ_SNVS_LP_WRAPPER)
}

//export CSU_IRQHandler
func interruptCSU() {
	callHandlers(IRQ_CSU)
}

//export DCP_IRQHandler
func interruptDCP() {
	callHandlers(IRQ_DCP)
}

//export DCP_VMI_IRQHandler
func interruptDCP_VMI() {
	callHandlers(IRQ_DCP_VMI)
}

//export Reserved68_IRQHandler
func interruptReserved68() {
	callHandlers(IRQ_Reserved68)
}

//export TRNG_IRQHandler
func interruptTRNG() {
	callHandlers(IRQ_TRNG)
}

//export Reserved70_IRQHandler
func interruptReserved70() {
	callHandlers(IRQ_Reserved70)
}

//export Reserved71_IRQHandler
func interruptReserved71() {
	callHandlers(IRQ_Reserved71)
}

//export SAI1_IRQHandler
func interruptSAI1() {
	callHandlers(IRQ_SAI1)
}

//export RTWDOG_IRQHandler
func interruptRTWDOG() {
	callHandlers(IRQ_RTWDOG)
}

//export SAI3_RX_IRQHandler
func interruptSAI3_RX() {
	callHandlers(IRQ_SAI3_RX)
}

//export SAI3_TX_IRQHandler
func interruptSAI3_TX() {
	callHandlers(IRQ_SAI3_TX)
}

//export SPDIF_IRQHandler
func interruptSPDIF() {
	callHandlers(IRQ_SPDIF)
}

//export PMU_IRQHandler
func interruptPMU() {
	callHandlers(IRQ_PMU)
}

//export XBAR1_IRQ_0_1_2_3_IRQHandler
func interruptXBAR1_IRQ_0_1_2_3() {
	callHandlers(IRQ_XBAR1_IRQ_0_1_2_3)
}

//export TEMP_LOW_HIGH_IRQHandler
func interruptTEMP_LOW_HIGH() {
	callHandlers(IRQ_TEMP_LOW_HIGH)
}

//export TEMP_PANIC_IRQHandler
func interruptTEMP_PANIC() {
	callHandlers(IRQ_TEMP_PANIC)
}

//export USB_PHY_IRQHandler
func interruptUSB_PHY() {
	callHandlers(IRQ_USB_PHY)
}

//export GPC_IRQHandler
func interruptGPC() {
	callHandlers(IRQ_GPC)
}

//export ADC1_IRQHandler
func interruptADC1() {
	callHandlers(IRQ_ADC1)
}

//export FLEXIO1_IRQHandler
func interruptFLEXIO1() {
	callHandlers(IRQ_FLEXIO1)
}

//export DCDC_IRQHandler
func interruptDCDC() {
	callHandlers(IRQ_DCDC)
}

//export GPIO1_Combined_0_15_IRQHandler
func interruptGPIO1_Combined_0_15() {
	callHandlers(IRQ_GPIO1_Combined_0_15)
}

//export GPIO1_Combined_16_31_IRQHandler
func interruptGPIO1_Combined_16_31() {
	callHandlers(IRQ_GPIO1_Combined_16_31)
}

//export GPIO2_Combined_0_15_IRQHandler
func interruptGPIO2_Combined_0_15() {
	callHandlers(IRQ_GPIO2_Combined_0_15)
}

//export GPIO5_Combined_0_15_IRQHandler
func interruptGPIO5_Combined_0_15() {
	callHandlers(IRQ_GPIO5_Combined_0_15)
}

//export WDOG1_IRQHandler
func interruptWDOG1() {
	callHandlers(IRQ_WDOG1)
}

//export ADC_ETC_IRQ0_IRQHandler
func interruptADC_ETC_IRQ0() {
	callHandlers(IRQ_ADC_ETC_IRQ0)
}

//export ADC_ETC_IRQ1_IRQHandler
func interruptADC_ETC_IRQ1() {
	callHandlers(IRQ_ADC_ETC_IRQ1)
}

//export ADC_ETC_IRQ2_IRQHandler
func interruptADC_ETC_IRQ2() {
	callHandlers(IRQ_ADC_ETC_IRQ2)
}

//export ADC_ETC_IRQ3_IRQHandler
func interruptADC_ETC_IRQ3() {
	callHandlers(IRQ_ADC_ETC_IRQ3)
}

//export ADC_ETC_ERROR_IRQ_IRQHandler
func interruptADC_ETC_ERROR_IRQ() {
	callHandlers(IRQ_ADC_ETC_ERROR_IRQ)
}

// Peripherals.
var (
	// AIPSTZ Control Registers
	AIPSTZ1 = (*AIPSTZ_Type)(unsafe.Pointer(uintptr(0x4007c000)))

	// DCDC
	DCDC = (*DCDC_Type)(unsafe.Pointer(uintptr(0x40080000)))

	// PIT
	PIT = (*PIT_Type)(unsafe.Pointer(uintptr(0x40084000)))

	// ADC_ETC
	ADC_ETC = (*ADC_ETC_Type)(unsafe.Pointer(uintptr(0x40088000)))

	// AND/OR/INVERT module
	AOI = (*AOI_Type)(unsafe.Pointer(uintptr(0x40094000)))

	// Crossbar Switch
	XBARA = (*XBARA_Type)(unsafe.Pointer(uintptr(0x40098000)))

	// FlexSPI
	FLEXSPI = (*FlexSPI_Type)(unsafe.Pointer(uintptr(0x400a0000)))

	// OTFAD
	OTFAD = (*OTFAD_Type)(unsafe.Pointer(uintptr(0x400a0000)))

	// IOMUXC
	IOMUXC_SNVS_GPR = (*IOMUXC_SNVS_GPR_Type)(unsafe.Pointer(uintptr(0x400a4000)))

	// IOMUXC_SNVS
	IOMUXC_SNVS = (*IOMUXC_SNVS_Type)(unsafe.Pointer(uintptr(0x400a8000)))

	// IOMUXC_GPR
	IOMUXC_GPR = (*IOMUXC_GPR_Type)(unsafe.Pointer(uintptr(0x400ac000)))

	// FLEXRAM
	FLEXRAM = (*FLEXRAM_Type)(unsafe.Pointer(uintptr(0x400b0000)))

	// EWM
	EWM = (*EWM_Type)(unsafe.Pointer(uintptr(0x400b4000)))

	// WDOG
	WDOG1 = (*WDOG_Type)(unsafe.Pointer(uintptr(0x400b8000)))

	// WDOG
	RTWDOG = (*RTWDOG_Type)(unsafe.Pointer(uintptr(0x400bc000)))

	// Analog-to-Digital Converter
	ADC1 = (*ADC_Type)(unsafe.Pointer(uintptr(0x400c4000)))

	// TRNG
	TRNG = (*TRNG_Type)(unsafe.Pointer(uintptr(0x400cc000)))

	// SNVS
	SNVS = (*SNVS_Type)(unsafe.Pointer(uintptr(0x400d4000)))

	// CCM_ANALOG
	CCM_ANALOG = (*CCM_ANALOG_Type)(unsafe.Pointer(uintptr(0x400d8000)))

	// PMU
	PMU = (*PMU_Type)(unsafe.Pointer(uintptr(0x400d8000)))

	// Temperature Monitor
	TEMPMON = (*TEMPMON_Type)(unsafe.Pointer(uintptr(0x400d8000)))

	// USB Analog
	USB_ANALOG = (*USB_ANALOG_Type)(unsafe.Pointer(uintptr(0x400d8000)))

	// XTALOSC24M
	XTALOSC24M = (*XTALOSC24M_Type)(unsafe.Pointer(uintptr(0x400d8000)))

	// USBPHY Register Reference Index
	USBPHY = (*USBPHY_Type)(unsafe.Pointer(uintptr(0x400d9000)))

	// CSU registers
	CSU = (*CSU_Type)(unsafe.Pointer(uintptr(0x400dc000)))

	// USB
	USB = (*USB_Type)(unsafe.Pointer(uintptr(0x400e4000)))

	// USB
	USBNC = (*USBNC_Type)(unsafe.Pointer(uintptr(0x400e4000)))

	// DMA
	DMA0 = (*DMA_Type)(unsafe.Pointer(uintptr(0x400e8000)))

	// DMAMUX
	DMAMUX = (*DMAMUX_Type)(unsafe.Pointer(uintptr(0x400ec000)))

	// DCP register reference index
	DCP = (*DCP_Type)(unsafe.Pointer(uintptr(0x400f0000)))

	// GPC
	GPC = (*GPC_Type)(unsafe.Pointer(uintptr(0x400f4000)))

	// PGC
	PGC = (*PGC_Type)(unsafe.Pointer(uintptr(0x400f4000)))

	// SRC
	SRC = (*SRC_Type)(unsafe.Pointer(uintptr(0x400f8000)))

	// CCM
	CCM = (*CCM_Type)(unsafe.Pointer(uintptr(0x400fc000)))

	// ROMC
	ROMC = (*ROMC_Type)(unsafe.Pointer(uintptr(0x40180000)))

	// LPUART
	LPUART1 = (*LPUART_Type)(unsafe.Pointer(uintptr(0x40184000)))

	// LPSPI
	LPSPI1 = (*LPSPI_Type)(unsafe.Pointer(uintptr(0x40194000)))

	// LPI2C
	LPI2C1 = (*LPI2C_Type)(unsafe.Pointer(uintptr(0x401a4000)))

	// FLEXIO
	FLEXIO1 = (*FLEXIO_Type)(unsafe.Pointer(uintptr(0x401ac000)))

	// GPIO
	GPIO1 = (*GPIO_Type)(unsafe.Pointer(uintptr(0x401b8000)))

	// PWM
	PWM1 = (*PWM_Type)(unsafe.Pointer(uintptr(0x401cc000)))

	// SPDIF
	SPDIF = (*SPDIF_Type)(unsafe.Pointer(uintptr(0x401dc000)))

	// I2S
	SAI1 = (*I2S_Type)(unsafe.Pointer(uintptr(0x401e0000)))

	// GPT
	GPT1 = (*GPT_Type)(unsafe.Pointer(uintptr(0x401ec000)))

	// no description available
	OCOTP = (*OCOTP_Type)(unsafe.Pointer(uintptr(0x401f4000)))

	// IOMUXC
	IOMUXC = (*IOMUXC_Type)(unsafe.Pointer(uintptr(0x401f8000)))

	// KPP Registers
	KPP = (*KPP_Type)(unsafe.Pointer(uintptr(0x401fc000)))

	// System Control Block
	SystemControl = (*SCB_Type)(unsafe.Pointer(uintptr(0xe000e000)))

	// Nested Vectored Interrupt Controller
	NVIC = (*NVIC_Type)(unsafe.Pointer(uintptr(0xe000e100)))

	// AIPSTZ Control Registers
	AIPSTZ2 = (*AIPSTZ_Type)(unsafe.Pointer(uintptr(0x4017c000)))

	// WDOG
	WDOG2 = (*WDOG_Type)(unsafe.Pointer(uintptr(0x400d0000)))

	// LPUART
	LPUART2 = (*LPUART_Type)(unsafe.Pointer(uintptr(0x40188000)))

	// LPUART
	LPUART3 = (*LPUART_Type)(unsafe.Pointer(uintptr(0x4018c000)))

	// LPUART
	LPUART4 = (*LPUART_Type)(unsafe.Pointer(uintptr(0x40190000)))

	// LPSPI
	LPSPI2 = (*LPSPI_Type)(unsafe.Pointer(uintptr(0x40198000)))

	// LPI2C
	LPI2C2 = (*LPI2C_Type)(unsafe.Pointer(uintptr(0x401a8000)))

	// GPIO
	GPIO5 = (*GPIO_Type)(unsafe.Pointer(uintptr(0x400c0000)))

	// GPIO
	GPIO2 = (*GPIO_Type)(unsafe.Pointer(uintptr(0x42000000)))

	// I2S
	SAI3 = (*I2S_Type)(unsafe.Pointer(uintptr(0x401e8000)))

	// GPT
	GPT2 = (*GPT_Type)(unsafe.Pointer(uintptr(0x401f0000)))
)

// AIPSTZ Control Registers
type AIPSTZ_Type struct {
	MPR    volatile.Register32 // 0x0
	_      [60]byte
	OPACR  volatile.Register32 // 0x40
	OPACR1 volatile.Register32 // 0x44
	OPACR2 volatile.Register32 // 0x48
	OPACR3 volatile.Register32 // 0x4C
	OPACR4 volatile.Register32 // 0x50
}

// AIPSTZ.MPR: Master Priviledge Registers
func (o *AIPSTZ_Type) SetMPR_MPROT5(value uint32) {
	volatile.StoreUint32(&o.MPR.Reg, volatile.LoadUint32(&o.MPR.Reg)&^(0xf00)|value<<8)
}
func (o *AIPSTZ_Type) GetMPR_MPROT5() uint32 {
	return (volatile.LoadUint32(&o.MPR.Reg) & 0xf00) >> 8
}
func (o *AIPSTZ_Type) SetMPR_MPROT3(value uint32) {
	volatile.StoreUint32(&o.MPR.Reg, volatile.LoadUint32(&o.MPR.Reg)&^(0xf0000)|value<<16)
}
func (o *AIPSTZ_Type) GetMPR_MPROT3() uint32 {
	return (volatile.LoadUint32(&o.MPR.Reg) & 0xf0000) >> 16
}
func (o *AIPSTZ_Type) SetMPR_MPROT2(value uint32) {
	volatile.StoreUint32(&o.MPR.Reg, volatile.LoadUint32(&o.MPR.Reg)&^(0xf00000)|value<<20)
}
func (o *AIPSTZ_Type) GetMPR_MPROT2() uint32 {
	return (volatile.LoadUint32(&o.MPR.Reg) & 0xf00000) >> 20
}
func (o *AIPSTZ_Type) SetMPR_MPROT1(value uint32) {
	volatile.StoreUint32(&o.MPR.Reg, volatile.LoadUint32(&o.MPR.Reg)&^(0xf000000)|value<<24)
}
func (o *AIPSTZ_Type) GetMPR_MPROT1() uint32 {
	return (volatile.LoadUint32(&o.MPR.Reg) & 0xf000000) >> 24
}
func (o *AIPSTZ_Type) SetMPR_MPROT0(value uint32) {
	volatile.StoreUint32(&o.MPR.Reg, volatile.LoadUint32(&o.MPR.Reg)&^(0xf0000000)|value<<28)
}
func (o *AIPSTZ_Type) GetMPR_MPROT0() uint32 {
	return (volatile.LoadUint32(&o.MPR.Reg) & 0xf0000000) >> 28
}

// AIPSTZ.OPACR: Off-Platform Peripheral Access Control Registers
func (o *AIPSTZ_Type) SetOPACR_OPAC7(value uint32) {
	volatile.StoreUint32(&o.OPACR.Reg, volatile.LoadUint32(&o.OPACR.Reg)&^(0xf)|value)
}
func (o *AIPSTZ_Type) GetOPACR_OPAC7() uint32 {
	return volatile.LoadUint32(&o.OPACR.Reg) & 0xf
}
func (o *AIPSTZ_Type) SetOPACR_OPAC6(value uint32) {
	volatile.StoreUint32(&o.OPACR.Reg, volatile.LoadUint32(&o.OPACR.Reg)&^(0xf0)|value<<4)
}
func (o *AIPSTZ_Type) GetOPACR_OPAC6() uint32 {
	return (volatile.LoadUint32(&o.OPACR.Reg) & 0xf0) >> 4
}
func (o *AIPSTZ_Type) SetOPACR_OPAC5(value uint32) {
	volatile.StoreUint32(&o.OPACR.Reg, volatile.LoadUint32(&o.OPACR.Reg)&^(0xf00)|value<<8)
}
func (o *AIPSTZ_Type) GetOPACR_OPAC5() uint32 {
	return (volatile.LoadUint32(&o.OPACR.Reg) & 0xf00) >> 8
}
func (o *AIPSTZ_Type) SetOPACR_OPAC4(value uint32) {
	volatile.StoreUint32(&o.OPACR.Reg, volatile.LoadUint32(&o.OPACR.Reg)&^(0xf000)|value<<12)
}
func (o *AIPSTZ_Type) GetOPACR_OPAC4() uint32 {
	return (volatile.LoadUint32(&o.OPACR.Reg) & 0xf000) >> 12
}
func (o *AIPSTZ_Type) SetOPACR_OPAC3(value uint32) {
	volatile.StoreUint32(&o.OPACR.Reg, volatile.LoadUint32(&o.OPACR.Reg)&^(0xf0000)|value<<16)
}
func (o *AIPSTZ_Type) GetOPACR_OPAC3() uint32 {
	return (volatile.LoadUint32(&o.OPACR.Reg) & 0xf0000) >> 16
}
func (o *AIPSTZ_Type) SetOPACR_OPAC2(value uint32) {
	volatile.StoreUint32(&o.OPACR.Reg, volatile.LoadUint32(&o.OPACR.Reg)&^(0xf00000)|value<<20)
}
func (o *AIPSTZ_Type) GetOPACR_OPAC2() uint32 {
	return (volatile.LoadUint32(&o.OPACR.Reg) & 0xf00000) >> 20
}
func (o *AIPSTZ_Type) SetOPACR_OPAC1(value uint32) {
	volatile.StoreUint32(&o.OPACR.Reg, volatile.LoadUint32(&o.OPACR.Reg)&^(0xf000000)|value<<24)
}
func (o *AIPSTZ_Type) GetOPACR_OPAC1() uint32 {
	return (volatile.LoadUint32(&o.OPACR.Reg) & 0xf000000) >> 24
}
func (o *AIPSTZ_Type) SetOPACR_OPAC0(value uint32) {
	volatile.StoreUint32(&o.OPACR.Reg, volatile.LoadUint32(&o.OPACR.Reg)&^(0xf0000000)|value<<28)
}
func (o *AIPSTZ_Type) GetOPACR_OPAC0() uint32 {
	return (volatile.LoadUint32(&o.OPACR.Reg) & 0xf0000000) >> 28
}

// AIPSTZ.OPACR1: Off-Platform Peripheral Access Control Registers
func (o *AIPSTZ_Type) SetOPACR1_OPAC15(value uint32) {
	volatile.StoreUint32(&o.OPACR1.Reg, volatile.LoadUint32(&o.OPACR1.Reg)&^(0xf)|value)
}
func (o *AIPSTZ_Type) GetOPACR1_OPAC15() uint32 {
	return volatile.LoadUint32(&o.OPACR1.Reg) & 0xf
}
func (o *AIPSTZ_Type) SetOPACR1_OPAC14(value uint32) {
	volatile.StoreUint32(&o.OPACR1.Reg, volatile.LoadUint32(&o.OPACR1.Reg)&^(0xf0)|value<<4)
}
func (o *AIPSTZ_Type) GetOPACR1_OPAC14() uint32 {
	return (volatile.LoadUint32(&o.OPACR1.Reg) & 0xf0) >> 4
}
func (o *AIPSTZ_Type) SetOPACR1_OPAC13(value uint32) {
	volatile.StoreUint32(&o.OPACR1.Reg, volatile.LoadUint32(&o.OPACR1.Reg)&^(0xf00)|value<<8)
}
func (o *AIPSTZ_Type) GetOPACR1_OPAC13() uint32 {
	return (volatile.LoadUint32(&o.OPACR1.Reg) & 0xf00) >> 8
}
func (o *AIPSTZ_Type) SetOPACR1_OPAC12(value uint32) {
	volatile.StoreUint32(&o.OPACR1.Reg, volatile.LoadUint32(&o.OPACR1.Reg)&^(0xf000)|value<<12)
}
func (o *AIPSTZ_Type) GetOPACR1_OPAC12() uint32 {
	return (volatile.LoadUint32(&o.OPACR1.Reg) & 0xf000) >> 12
}
func (o *AIPSTZ_Type) SetOPACR1_OPAC11(value uint32) {
	volatile.StoreUint32(&o.OPACR1.Reg, volatile.LoadUint32(&o.OPACR1.Reg)&^(0xf0000)|value<<16)
}
func (o *AIPSTZ_Type) GetOPACR1_OPAC11() uint32 {
	return (volatile.LoadUint32(&o.OPACR1.Reg) & 0xf0000) >> 16
}
func (o *AIPSTZ_Type) SetOPACR1_OPAC10(value uint32) {
	volatile.StoreUint32(&o.OPACR1.Reg, volatile.LoadUint32(&o.OPACR1.Reg)&^(0xf00000)|value<<20)
}
func (o *AIPSTZ_Type) GetOPACR1_OPAC10() uint32 {
	return (volatile.LoadUint32(&o.OPACR1.Reg) & 0xf00000) >> 20
}
func (o *AIPSTZ_Type) SetOPACR1_OPAC9(value uint32) {
	volatile.StoreUint32(&o.OPACR1.Reg, volatile.LoadUint32(&o.OPACR1.Reg)&^(0xf000000)|value<<24)
}
func (o *AIPSTZ_Type) GetOPACR1_OPAC9() uint32 {
	return (volatile.LoadUint32(&o.OPACR1.Reg) & 0xf000000) >> 24
}
func (o *AIPSTZ_Type) SetOPACR1_OPAC8(value uint32) {
	volatile.StoreUint32(&o.OPACR1.Reg, volatile.LoadUint32(&o.OPACR1.Reg)&^(0xf0000000)|value<<28)
}
func (o *AIPSTZ_Type) GetOPACR1_OPAC8() uint32 {
	return (volatile.LoadUint32(&o.OPACR1.Reg) & 0xf0000000) >> 28
}

// AIPSTZ.OPACR2: Off-Platform Peripheral Access Control Registers
func (o *AIPSTZ_Type) SetOPACR2_OPAC23(value uint32) {
	volatile.StoreUint32(&o.OPACR2.Reg, volatile.LoadUint32(&o.OPACR2.Reg)&^(0xf)|value)
}
func (o *AIPSTZ_Type) GetOPACR2_OPAC23() uint32 {
	return volatile.LoadUint32(&o.OPACR2.Reg) & 0xf
}
func (o *AIPSTZ_Type) SetOPACR2_OPAC22(value uint32) {
	volatile.StoreUint32(&o.OPACR2.Reg, volatile.LoadUint32(&o.OPACR2.Reg)&^(0xf0)|value<<4)
}
func (o *AIPSTZ_Type) GetOPACR2_OPAC22() uint32 {
	return (volatile.LoadUint32(&o.OPACR2.Reg) & 0xf0) >> 4
}
func (o *AIPSTZ_Type) SetOPACR2_OPAC21(value uint32) {
	volatile.StoreUint32(&o.OPACR2.Reg, volatile.LoadUint32(&o.OPACR2.Reg)&^(0xf00)|value<<8)
}
func (o *AIPSTZ_Type) GetOPACR2_OPAC21() uint32 {
	return (volatile.LoadUint32(&o.OPACR2.Reg) & 0xf00) >> 8
}
func (o *AIPSTZ_Type) SetOPACR2_OPAC20(value uint32) {
	volatile.StoreUint32(&o.OPACR2.Reg, volatile.LoadUint32(&o.OPACR2.Reg)&^(0xf000)|value<<12)
}
func (o *AIPSTZ_Type) GetOPACR2_OPAC20() uint32 {
	return (volatile.LoadUint32(&o.OPACR2.Reg) & 0xf000) >> 12
}
func (o *AIPSTZ_Type) SetOPACR2_OPAC19(value uint32) {
	volatile.StoreUint32(&o.OPACR2.Reg, volatile.LoadUint32(&o.OPACR2.Reg)&^(0xf0000)|value<<16)
}
func (o *AIPSTZ_Type) GetOPACR2_OPAC19() uint32 {
	return (volatile.LoadUint32(&o.OPACR2.Reg) & 0xf0000) >> 16
}
func (o *AIPSTZ_Type) SetOPACR2_OPAC18(value uint32) {
	volatile.StoreUint32(&o.OPACR2.Reg, volatile.LoadUint32(&o.OPACR2.Reg)&^(0xf00000)|value<<20)
}
func (o *AIPSTZ_Type) GetOPACR2_OPAC18() uint32 {
	return (volatile.LoadUint32(&o.OPACR2.Reg) & 0xf00000) >> 20
}
func (o *AIPSTZ_Type) SetOPACR2_OPAC17(value uint32) {
	volatile.StoreUint32(&o.OPACR2.Reg, volatile.LoadUint32(&o.OPACR2.Reg)&^(0xf000000)|value<<24)
}
func (o *AIPSTZ_Type) GetOPACR2_OPAC17() uint32 {
	return (volatile.LoadUint32(&o.OPACR2.Reg) & 0xf000000) >> 24
}
func (o *AIPSTZ_Type) SetOPACR2_OPAC16(value uint32) {
	volatile.StoreUint32(&o.OPACR2.Reg, volatile.LoadUint32(&o.OPACR2.Reg)&^(0xf0000000)|value<<28)
}
func (o *AIPSTZ_Type) GetOPACR2_OPAC16() uint32 {
	return (volatile.LoadUint32(&o.OPACR2.Reg) & 0xf0000000) >> 28
}

// AIPSTZ.OPACR3: Off-Platform Peripheral Access Control Registers
func (o *AIPSTZ_Type) SetOPACR3_OPAC31(value uint32) {
	volatile.StoreUint32(&o.OPACR3.Reg, volatile.LoadUint32(&o.OPACR3.Reg)&^(0xf)|value)
}
func (o *AIPSTZ_Type) GetOPACR3_OPAC31() uint32 {
	return volatile.LoadUint32(&o.OPACR3.Reg) & 0xf
}
func (o *AIPSTZ_Type) SetOPACR3_OPAC30(value uint32) {
	volatile.StoreUint32(&o.OPACR3.Reg, volatile.LoadUint32(&o.OPACR3.Reg)&^(0xf0)|value<<4)
}
func (o *AIPSTZ_Type) GetOPACR3_OPAC30() uint32 {
	return (volatile.LoadUint32(&o.OPACR3.Reg) & 0xf0) >> 4
}
func (o *AIPSTZ_Type) SetOPACR3_OPAC29(value uint32) {
	volatile.StoreUint32(&o.OPACR3.Reg, volatile.LoadUint32(&o.OPACR3.Reg)&^(0xf00)|value<<8)
}
func (o *AIPSTZ_Type) GetOPACR3_OPAC29() uint32 {
	return (volatile.LoadUint32(&o.OPACR3.Reg) & 0xf00) >> 8
}
func (o *AIPSTZ_Type) SetOPACR3_OPAC28(value uint32) {
	volatile.StoreUint32(&o.OPACR3.Reg, volatile.LoadUint32(&o.OPACR3.Reg)&^(0xf000)|value<<12)
}
func (o *AIPSTZ_Type) GetOPACR3_OPAC28() uint32 {
	return (volatile.LoadUint32(&o.OPACR3.Reg) & 0xf000) >> 12
}
func (o *AIPSTZ_Type) SetOPACR3_OPAC27(value uint32) {
	volatile.StoreUint32(&o.OPACR3.Reg, volatile.LoadUint32(&o.OPACR3.Reg)&^(0xf0000)|value<<16)
}
func (o *AIPSTZ_Type) GetOPACR3_OPAC27() uint32 {
	return (volatile.LoadUint32(&o.OPACR3.Reg) & 0xf0000) >> 16
}
func (o *AIPSTZ_Type) SetOPACR3_OPAC26(value uint32) {
	volatile.StoreUint32(&o.OPACR3.Reg, volatile.LoadUint32(&o.OPACR3.Reg)&^(0xf00000)|value<<20)
}
func (o *AIPSTZ_Type) GetOPACR3_OPAC26() uint32 {
	return (volatile.LoadUint32(&o.OPACR3.Reg) & 0xf00000) >> 20
}
func (o *AIPSTZ_Type) SetOPACR3_OPAC25(value uint32) {
	volatile.StoreUint32(&o.OPACR3.Reg, volatile.LoadUint32(&o.OPACR3.Reg)&^(0xf000000)|value<<24)
}
func (o *AIPSTZ_Type) GetOPACR3_OPAC25() uint32 {
	return (volatile.LoadUint32(&o.OPACR3.Reg) & 0xf000000) >> 24
}
func (o *AIPSTZ_Type) SetOPACR3_OPAC24(value uint32) {
	volatile.StoreUint32(&o.OPACR3.Reg, volatile.LoadUint32(&o.OPACR3.Reg)&^(0xf0000000)|value<<28)
}
func (o *AIPSTZ_Type) GetOPACR3_OPAC24() uint32 {
	return (volatile.LoadUint32(&o.OPACR3.Reg) & 0xf0000000) >> 28
}

// AIPSTZ.OPACR4: Off-Platform Peripheral Access Control Registers
func (o *AIPSTZ_Type) SetOPACR4_OPAC33(value uint32) {
	volatile.StoreUint32(&o.OPACR4.Reg, volatile.LoadUint32(&o.OPACR4.Reg)&^(0xf000000)|value<<24)
}
func (o *AIPSTZ_Type) GetOPACR4_OPAC33() uint32 {
	return (volatile.LoadUint32(&o.OPACR4.Reg) & 0xf000000) >> 24
}
func (o *AIPSTZ_Type) SetOPACR4_OPAC32(value uint32) {
	volatile.StoreUint32(&o.OPACR4.Reg, volatile.LoadUint32(&o.OPACR4.Reg)&^(0xf0000000)|value<<28)
}
func (o *AIPSTZ_Type) GetOPACR4_OPAC32() uint32 {
	return (volatile.LoadUint32(&o.OPACR4.Reg) & 0xf0000000) >> 28
}

// DCDC
type DCDC_Type struct {
	REG0 volatile.Register32 // 0x0
	REG1 volatile.Register32 // 0x4
	REG2 volatile.Register32 // 0x8
	REG3 volatile.Register32 // 0xC
}

// DCDC.REG0: DCDC Register 0
func (o *DCDC_Type) SetREG0_PWD_ZCD(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0x1)|value)
}
func (o *DCDC_Type) GetREG0_PWD_ZCD() uint32 {
	return volatile.LoadUint32(&o.REG0.Reg) & 0x1
}
func (o *DCDC_Type) SetREG0_DISABLE_AUTO_CLK_SWITCH(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0x2)|value<<1)
}
func (o *DCDC_Type) GetREG0_DISABLE_AUTO_CLK_SWITCH() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0x2) >> 1
}
func (o *DCDC_Type) SetREG0_SEL_CLK(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0x4)|value<<2)
}
func (o *DCDC_Type) GetREG0_SEL_CLK() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0x4) >> 2
}
func (o *DCDC_Type) SetREG0_PWD_OSC_INT(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0x8)|value<<3)
}
func (o *DCDC_Type) GetREG0_PWD_OSC_INT() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0x8) >> 3
}
func (o *DCDC_Type) SetREG0_PWD_CUR_SNS_CMP(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0x10)|value<<4)
}
func (o *DCDC_Type) GetREG0_PWD_CUR_SNS_CMP() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0x10) >> 4
}
func (o *DCDC_Type) SetREG0_CUR_SNS_THRSH(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0xe0)|value<<5)
}
func (o *DCDC_Type) GetREG0_CUR_SNS_THRSH() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0xe0) >> 5
}
func (o *DCDC_Type) SetREG0_PWD_OVERCUR_DET(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0x100)|value<<8)
}
func (o *DCDC_Type) GetREG0_PWD_OVERCUR_DET() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0x100) >> 8
}
func (o *DCDC_Type) SetREG0_OVERCUR_TRIG_ADJ(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0x600)|value<<9)
}
func (o *DCDC_Type) GetREG0_OVERCUR_TRIG_ADJ() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0x600) >> 9
}
func (o *DCDC_Type) SetREG0_PWD_CMP_BATT_DET(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0x800)|value<<11)
}
func (o *DCDC_Type) GetREG0_PWD_CMP_BATT_DET() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0x800) >> 11
}
func (o *DCDC_Type) SetREG0_ADJ_POSLIMIT_BUCK(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0xf000)|value<<12)
}
func (o *DCDC_Type) GetREG0_ADJ_POSLIMIT_BUCK() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0xf000) >> 12
}
func (o *DCDC_Type) SetREG0_EN_LP_OVERLOAD_SNS(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0x10000)|value<<16)
}
func (o *DCDC_Type) GetREG0_EN_LP_OVERLOAD_SNS() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0x10000) >> 16
}
func (o *DCDC_Type) SetREG0_PWD_HIGH_VOLT_DET(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0x20000)|value<<17)
}
func (o *DCDC_Type) GetREG0_PWD_HIGH_VOLT_DET() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0x20000) >> 17
}
func (o *DCDC_Type) SetREG0_LP_OVERLOAD_THRSH(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0xc0000)|value<<18)
}
func (o *DCDC_Type) GetREG0_LP_OVERLOAD_THRSH() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0xc0000) >> 18
}
func (o *DCDC_Type) SetREG0_LP_OVERLOAD_FREQ_SEL(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0x100000)|value<<20)
}
func (o *DCDC_Type) GetREG0_LP_OVERLOAD_FREQ_SEL() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0x100000) >> 20
}
func (o *DCDC_Type) SetREG0_LP_HIGH_HYS(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0x200000)|value<<21)
}
func (o *DCDC_Type) GetREG0_LP_HIGH_HYS() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0x200000) >> 21
}
func (o *DCDC_Type) SetREG0_PWD_CMP_OFFSET(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0x4000000)|value<<26)
}
func (o *DCDC_Type) GetREG0_PWD_CMP_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0x4000000) >> 26
}
func (o *DCDC_Type) SetREG0_XTALOK_DISABLE(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0x8000000)|value<<27)
}
func (o *DCDC_Type) GetREG0_XTALOK_DISABLE() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0x8000000) >> 27
}
func (o *DCDC_Type) SetREG0_CURRENT_ALERT_RESET(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0x10000000)|value<<28)
}
func (o *DCDC_Type) GetREG0_CURRENT_ALERT_RESET() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0x10000000) >> 28
}
func (o *DCDC_Type) SetREG0_XTAL_24M_OK(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0x20000000)|value<<29)
}
func (o *DCDC_Type) GetREG0_XTAL_24M_OK() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0x20000000) >> 29
}
func (o *DCDC_Type) SetREG0_STS_DC_OK(value uint32) {
	volatile.StoreUint32(&o.REG0.Reg, volatile.LoadUint32(&o.REG0.Reg)&^(0x80000000)|value<<31)
}
func (o *DCDC_Type) GetREG0_STS_DC_OK() uint32 {
	return (volatile.LoadUint32(&o.REG0.Reg) & 0x80000000) >> 31
}

// DCDC.REG1: DCDC Register 1
func (o *DCDC_Type) SetREG1_REG_FBK_SEL(value uint32) {
	volatile.StoreUint32(&o.REG1.Reg, volatile.LoadUint32(&o.REG1.Reg)&^(0x180)|value<<7)
}
func (o *DCDC_Type) GetREG1_REG_FBK_SEL() uint32 {
	return (volatile.LoadUint32(&o.REG1.Reg) & 0x180) >> 7
}
func (o *DCDC_Type) SetREG1_REG_RLOAD_SW(value uint32) {
	volatile.StoreUint32(&o.REG1.Reg, volatile.LoadUint32(&o.REG1.Reg)&^(0x200)|value<<9)
}
func (o *DCDC_Type) GetREG1_REG_RLOAD_SW() uint32 {
	return (volatile.LoadUint32(&o.REG1.Reg) & 0x200) >> 9
}
func (o *DCDC_Type) SetREG1_LP_CMP_ISRC_SEL(value uint32) {
	volatile.StoreUint32(&o.REG1.Reg, volatile.LoadUint32(&o.REG1.Reg)&^(0x3000)|value<<12)
}
func (o *DCDC_Type) GetREG1_LP_CMP_ISRC_SEL() uint32 {
	return (volatile.LoadUint32(&o.REG1.Reg) & 0x3000) >> 12
}
func (o *DCDC_Type) SetREG1_LOOPCTRL_HST_THRESH(value uint32) {
	volatile.StoreUint32(&o.REG1.Reg, volatile.LoadUint32(&o.REG1.Reg)&^(0x200000)|value<<21)
}
func (o *DCDC_Type) GetREG1_LOOPCTRL_HST_THRESH() uint32 {
	return (volatile.LoadUint32(&o.REG1.Reg) & 0x200000) >> 21
}
func (o *DCDC_Type) SetREG1_LOOPCTRL_EN_HYST(value uint32) {
	volatile.StoreUint32(&o.REG1.Reg, volatile.LoadUint32(&o.REG1.Reg)&^(0x800000)|value<<23)
}
func (o *DCDC_Type) GetREG1_LOOPCTRL_EN_HYST() uint32 {
	return (volatile.LoadUint32(&o.REG1.Reg) & 0x800000) >> 23
}
func (o *DCDC_Type) SetREG1_VBG_TRIM(value uint32) {
	volatile.StoreUint32(&o.REG1.Reg, volatile.LoadUint32(&o.REG1.Reg)&^(0x1f000000)|value<<24)
}
func (o *DCDC_Type) GetREG1_VBG_TRIM() uint32 {
	return (volatile.LoadUint32(&o.REG1.Reg) & 0x1f000000) >> 24
}

// DCDC.REG2: DCDC Register 2
func (o *DCDC_Type) SetREG2_LOOPCTRL_DC_C(value uint32) {
	volatile.StoreUint32(&o.REG2.Reg, volatile.LoadUint32(&o.REG2.Reg)&^(0x3)|value)
}
func (o *DCDC_Type) GetREG2_LOOPCTRL_DC_C() uint32 {
	return volatile.LoadUint32(&o.REG2.Reg) & 0x3
}
func (o *DCDC_Type) SetREG2_LOOPCTRL_DC_R(value uint32) {
	volatile.StoreUint32(&o.REG2.Reg, volatile.LoadUint32(&o.REG2.Reg)&^(0x3c)|value<<2)
}
func (o *DCDC_Type) GetREG2_LOOPCTRL_DC_R() uint32 {
	return (volatile.LoadUint32(&o.REG2.Reg) & 0x3c) >> 2
}
func (o *DCDC_Type) SetREG2_LOOPCTRL_DC_FF(value uint32) {
	volatile.StoreUint32(&o.REG2.Reg, volatile.LoadUint32(&o.REG2.Reg)&^(0x1c0)|value<<6)
}
func (o *DCDC_Type) GetREG2_LOOPCTRL_DC_FF() uint32 {
	return (volatile.LoadUint32(&o.REG2.Reg) & 0x1c0) >> 6
}
func (o *DCDC_Type) SetREG2_LOOPCTRL_EN_RCSCALE(value uint32) {
	volatile.StoreUint32(&o.REG2.Reg, volatile.LoadUint32(&o.REG2.Reg)&^(0xe00)|value<<9)
}
func (o *DCDC_Type) GetREG2_LOOPCTRL_EN_RCSCALE() uint32 {
	return (volatile.LoadUint32(&o.REG2.Reg) & 0xe00) >> 9
}
func (o *DCDC_Type) SetREG2_LOOPCTRL_RCSCALE_THRSH(value uint32) {
	volatile.StoreUint32(&o.REG2.Reg, volatile.LoadUint32(&o.REG2.Reg)&^(0x1000)|value<<12)
}
func (o *DCDC_Type) GetREG2_LOOPCTRL_RCSCALE_THRSH() uint32 {
	return (volatile.LoadUint32(&o.REG2.Reg) & 0x1000) >> 12
}
func (o *DCDC_Type) SetREG2_LOOPCTRL_HYST_SIGN(value uint32) {
	volatile.StoreUint32(&o.REG2.Reg, volatile.LoadUint32(&o.REG2.Reg)&^(0x2000)|value<<13)
}
func (o *DCDC_Type) GetREG2_LOOPCTRL_HYST_SIGN() uint32 {
	return (volatile.LoadUint32(&o.REG2.Reg) & 0x2000) >> 13
}
func (o *DCDC_Type) SetREG2_BATTMONITOR_EN_BATADJ(value uint32) {
	volatile.StoreUint32(&o.REG2.Reg, volatile.LoadUint32(&o.REG2.Reg)&^(0x8000)|value<<15)
}
func (o *DCDC_Type) GetREG2_BATTMONITOR_EN_BATADJ() uint32 {
	return (volatile.LoadUint32(&o.REG2.Reg) & 0x8000) >> 15
}
func (o *DCDC_Type) SetREG2_DISABLE_PULSE_SKIP(value uint32) {
	volatile.StoreUint32(&o.REG2.Reg, volatile.LoadUint32(&o.REG2.Reg)&^(0x8000000)|value<<27)
}
func (o *DCDC_Type) GetREG2_DISABLE_PULSE_SKIP() uint32 {
	return (volatile.LoadUint32(&o.REG2.Reg) & 0x8000000) >> 27
}
func (o *DCDC_Type) SetREG2_DCM_SET_CTRL(value uint32) {
	volatile.StoreUint32(&o.REG2.Reg, volatile.LoadUint32(&o.REG2.Reg)&^(0x10000000)|value<<28)
}
func (o *DCDC_Type) GetREG2_DCM_SET_CTRL() uint32 {
	return (volatile.LoadUint32(&o.REG2.Reg) & 0x10000000) >> 28
}

// DCDC.REG3: DCDC Register 3
func (o *DCDC_Type) SetREG3_TRG(value uint32) {
	volatile.StoreUint32(&o.REG3.Reg, volatile.LoadUint32(&o.REG3.Reg)&^(0x1f)|value)
}
func (o *DCDC_Type) GetREG3_TRG() uint32 {
	return volatile.LoadUint32(&o.REG3.Reg) & 0x1f
}
func (o *DCDC_Type) SetREG3_TARGET_LP(value uint32) {
	volatile.StoreUint32(&o.REG3.Reg, volatile.LoadUint32(&o.REG3.Reg)&^(0x700)|value<<8)
}
func (o *DCDC_Type) GetREG3_TARGET_LP() uint32 {
	return (volatile.LoadUint32(&o.REG3.Reg) & 0x700) >> 8
}
func (o *DCDC_Type) SetREG3_MINPWR_DC_HALFCLK(value uint32) {
	volatile.StoreUint32(&o.REG3.Reg, volatile.LoadUint32(&o.REG3.Reg)&^(0x1000000)|value<<24)
}
func (o *DCDC_Type) GetREG3_MINPWR_DC_HALFCLK() uint32 {
	return (volatile.LoadUint32(&o.REG3.Reg) & 0x1000000) >> 24
}
func (o *DCDC_Type) SetREG3_MISC_DELAY_TIMING(value uint32) {
	volatile.StoreUint32(&o.REG3.Reg, volatile.LoadUint32(&o.REG3.Reg)&^(0x8000000)|value<<27)
}
func (o *DCDC_Type) GetREG3_MISC_DELAY_TIMING() uint32 {
	return (volatile.LoadUint32(&o.REG3.Reg) & 0x8000000) >> 27
}
func (o *DCDC_Type) SetREG3_MISC_DISABLEFET_LOGIC(value uint32) {
	volatile.StoreUint32(&o.REG3.Reg, volatile.LoadUint32(&o.REG3.Reg)&^(0x10000000)|value<<28)
}
func (o *DCDC_Type) GetREG3_MISC_DISABLEFET_LOGIC() uint32 {
	return (volatile.LoadUint32(&o.REG3.Reg) & 0x10000000) >> 28
}
func (o *DCDC_Type) SetREG3_DISABLE_STEP(value uint32) {
	volatile.StoreUint32(&o.REG3.Reg, volatile.LoadUint32(&o.REG3.Reg)&^(0x40000000)|value<<30)
}
func (o *DCDC_Type) GetREG3_DISABLE_STEP() uint32 {
	return (volatile.LoadUint32(&o.REG3.Reg) & 0x40000000) >> 30
}

// PIT
type PIT_Type struct {
	MCR     volatile.Register32 // 0x0
	_       [220]byte
	LTMR64H volatile.Register32 // 0xE0
	LTMR64L volatile.Register32 // 0xE4
	_       [24]byte
	TIMER   [4]PIT_TIMER_Type // 0x100
}

// PIT.MCR: PIT Module Control Register
func (o *PIT_Type) SetMCR_FRZ(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x1)|value)
}
func (o *PIT_Type) GetMCR_FRZ() uint32 {
	return volatile.LoadUint32(&o.MCR.Reg) & 0x1
}
func (o *PIT_Type) SetMCR_MDIS(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x2)|value<<1)
}
func (o *PIT_Type) GetMCR_MDIS() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x2) >> 1
}

// PIT.LTMR64H: PIT Upper Lifetime Timer Register
func (o *PIT_Type) SetLTMR64H(value uint32) {
	volatile.StoreUint32(&o.LTMR64H.Reg, value)
}
func (o *PIT_Type) GetLTMR64H() uint32 {
	return volatile.LoadUint32(&o.LTMR64H.Reg)
}

// PIT.LTMR64L: PIT Lower Lifetime Timer Register
func (o *PIT_Type) SetLTMR64L(value uint32) {
	volatile.StoreUint32(&o.LTMR64L.Reg, value)
}
func (o *PIT_Type) GetLTMR64L() uint32 {
	return volatile.LoadUint32(&o.LTMR64L.Reg)
}

// no description available
type PIT_TIMER_Type struct {
	LDVAL volatile.Register32 // 0x100
	CVAL  volatile.Register32 // 0x104
	TCTRL volatile.Register32 // 0x108
	TFLG  volatile.Register32 // 0x10C
}

// PIT_TIMER.LDVAL: Timer Load Value Register
func (o *PIT_TIMER_Type) SetLDVAL(value uint32) {
	volatile.StoreUint32(&o.LDVAL.Reg, value)
}
func (o *PIT_TIMER_Type) GetLDVAL() uint32 {
	return volatile.LoadUint32(&o.LDVAL.Reg)
}

// PIT_TIMER.CVAL: Current Timer Value Register
func (o *PIT_TIMER_Type) SetCVAL(value uint32) {
	volatile.StoreUint32(&o.CVAL.Reg, value)
}
func (o *PIT_TIMER_Type) GetCVAL() uint32 {
	return volatile.LoadUint32(&o.CVAL.Reg)
}

// PIT_TIMER.TCTRL: Timer Control Register
func (o *PIT_TIMER_Type) SetTCTRL_TEN(value uint32) {
	volatile.StoreUint32(&o.TCTRL.Reg, volatile.LoadUint32(&o.TCTRL.Reg)&^(0x1)|value)
}
func (o *PIT_TIMER_Type) GetTCTRL_TEN() uint32 {
	return volatile.LoadUint32(&o.TCTRL.Reg) & 0x1
}
func (o *PIT_TIMER_Type) SetTCTRL_TIE(value uint32) {
	volatile.StoreUint32(&o.TCTRL.Reg, volatile.LoadUint32(&o.TCTRL.Reg)&^(0x2)|value<<1)
}
func (o *PIT_TIMER_Type) GetTCTRL_TIE() uint32 {
	return (volatile.LoadUint32(&o.TCTRL.Reg) & 0x2) >> 1
}
func (o *PIT_TIMER_Type) SetTCTRL_CHN(value uint32) {
	volatile.StoreUint32(&o.TCTRL.Reg, volatile.LoadUint32(&o.TCTRL.Reg)&^(0x4)|value<<2)
}
func (o *PIT_TIMER_Type) GetTCTRL_CHN() uint32 {
	return (volatile.LoadUint32(&o.TCTRL.Reg) & 0x4) >> 2
}

// PIT_TIMER.TFLG: Timer Flag Register
func (o *PIT_TIMER_Type) SetTFLG_TIF(value uint32) {
	volatile.StoreUint32(&o.TFLG.Reg, volatile.LoadUint32(&o.TFLG.Reg)&^(0x1)|value)
}
func (o *PIT_TIMER_Type) GetTFLG_TIF() uint32 {
	return volatile.LoadUint32(&o.TFLG.Reg) & 0x1
}

// ADC_ETC
type ADC_ETC_Type struct {
	CTRL             volatile.Register32 // 0x0
	DONE0_1_IRQ      volatile.Register32 // 0x4
	DONE2_ERR_IRQ    volatile.Register32 // 0x8
	DMA_CTRL         volatile.Register32 // 0xC
	TRIG0_CTRL       volatile.Register32 // 0x10
	TRIG0_COUNTER    volatile.Register32 // 0x14
	TRIG0_CHAIN_1_0  volatile.Register32 // 0x18
	TRIG0_CHAIN_3_2  volatile.Register32 // 0x1C
	TRIG0_CHAIN_5_4  volatile.Register32 // 0x20
	TRIG0_CHAIN_7_6  volatile.Register32 // 0x24
	TRIG0_RESULT_1_0 volatile.Register32 // 0x28
	TRIG0_RESULT_3_2 volatile.Register32 // 0x2C
	TRIG0_RESULT_5_4 volatile.Register32 // 0x30
	TRIG0_RESULT_7_6 volatile.Register32 // 0x34
	TRIG1_CTRL       volatile.Register32 // 0x38
	TRIG1_COUNTER    volatile.Register32 // 0x3C
	TRIG1_CHAIN_1_0  volatile.Register32 // 0x40
	TRIG1_CHAIN_3_2  volatile.Register32 // 0x44
	TRIG1_CHAIN_5_4  volatile.Register32 // 0x48
	TRIG1_CHAIN_7_6  volatile.Register32 // 0x4C
	TRIG1_RESULT_1_0 volatile.Register32 // 0x50
	TRIG1_RESULT_3_2 volatile.Register32 // 0x54
	TRIG1_RESULT_5_4 volatile.Register32 // 0x58
	TRIG1_RESULT_7_6 volatile.Register32 // 0x5C
	TRIG2_CTRL       volatile.Register32 // 0x60
	TRIG2_COUNTER    volatile.Register32 // 0x64
	TRIG2_CHAIN_1_0  volatile.Register32 // 0x68
	TRIG2_CHAIN_3_2  volatile.Register32 // 0x6C
	TRIG2_CHAIN_5_4  volatile.Register32 // 0x70
	TRIG2_CHAIN_7_6  volatile.Register32 // 0x74
	TRIG2_RESULT_1_0 volatile.Register32 // 0x78
	TRIG2_RESULT_3_2 volatile.Register32 // 0x7C
	TRIG2_RESULT_5_4 volatile.Register32 // 0x80
	TRIG2_RESULT_7_6 volatile.Register32 // 0x84
	TRIG3_CTRL       volatile.Register32 // 0x88
	TRIG3_COUNTER    volatile.Register32 // 0x8C
	TRIG3_CHAIN_1_0  volatile.Register32 // 0x90
	TRIG3_CHAIN_3_2  volatile.Register32 // 0x94
	TRIG3_CHAIN_5_4  volatile.Register32 // 0x98
	TRIG3_CHAIN_7_6  volatile.Register32 // 0x9C
	TRIG3_RESULT_1_0 volatile.Register32 // 0xA0
	TRIG3_RESULT_3_2 volatile.Register32 // 0xA4
	TRIG3_RESULT_5_4 volatile.Register32 // 0xA8
	TRIG3_RESULT_7_6 volatile.Register32 // 0xAC
}

// ADC_ETC.CTRL: ADC_ETC Global Control Register
func (o *ADC_ETC_Type) SetCTRL_TRIG_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xff)|value)
}
func (o *ADC_ETC_Type) GetCTRL_TRIG_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0xff
}
func (o *ADC_ETC_Type) SetCTRL_EXT0_TRIG_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x100)|value<<8)
}
func (o *ADC_ETC_Type) GetCTRL_EXT0_TRIG_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x100) >> 8
}
func (o *ADC_ETC_Type) SetCTRL_EXT0_TRIG_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xe00)|value<<9)
}
func (o *ADC_ETC_Type) GetCTRL_EXT0_TRIG_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xe00) >> 9
}
func (o *ADC_ETC_Type) SetCTRL_EXT1_TRIG_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_ETC_Type) GetCTRL_EXT1_TRIG_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x1000) >> 12
}
func (o *ADC_ETC_Type) SetCTRL_EXT1_TRIG_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xe000)|value<<13)
}
func (o *ADC_ETC_Type) GetCTRL_EXT1_TRIG_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xe000) >> 13
}
func (o *ADC_ETC_Type) SetCTRL_PRE_DIVIDER(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xff0000)|value<<16)
}
func (o *ADC_ETC_Type) GetCTRL_PRE_DIVIDER() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0xff0000) >> 16
}
func (o *ADC_ETC_Type) SetCTRL_DMA_MODE_SEL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *ADC_ETC_Type) GetCTRL_DMA_MODE_SEL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20000000) >> 29
}
func (o *ADC_ETC_Type) SetCTRL_TSC_BYPASS(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *ADC_ETC_Type) GetCTRL_TSC_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40000000) >> 30
}
func (o *ADC_ETC_Type) SetCTRL_SOFTRST(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_ETC_Type) GetCTRL_SOFTRST() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80000000) >> 31
}

// ADC_ETC.DONE0_1_IRQ: ETC DONE0 and DONE1 IRQ State Register
func (o *ADC_ETC_Type) SetDONE0_1_IRQ_TRIG0_DONE0(value uint32) {
	volatile.StoreUint32(&o.DONE0_1_IRQ.Reg, volatile.LoadUint32(&o.DONE0_1_IRQ.Reg)&^(0x1)|value)
}
func (o *ADC_ETC_Type) GetDONE0_1_IRQ_TRIG0_DONE0() uint32 {
	return volatile.LoadUint32(&o.DONE0_1_IRQ.Reg) & 0x1
}
func (o *ADC_ETC_Type) SetDONE0_1_IRQ_TRIG1_DONE0(value uint32) {
	volatile.StoreUint32(&o.DONE0_1_IRQ.Reg, volatile.LoadUint32(&o.DONE0_1_IRQ.Reg)&^(0x2)|value<<1)
}
func (o *ADC_ETC_Type) GetDONE0_1_IRQ_TRIG1_DONE0() uint32 {
	return (volatile.LoadUint32(&o.DONE0_1_IRQ.Reg) & 0x2) >> 1
}
func (o *ADC_ETC_Type) SetDONE0_1_IRQ_TRIG2_DONE0(value uint32) {
	volatile.StoreUint32(&o.DONE0_1_IRQ.Reg, volatile.LoadUint32(&o.DONE0_1_IRQ.Reg)&^(0x4)|value<<2)
}
func (o *ADC_ETC_Type) GetDONE0_1_IRQ_TRIG2_DONE0() uint32 {
	return (volatile.LoadUint32(&o.DONE0_1_IRQ.Reg) & 0x4) >> 2
}
func (o *ADC_ETC_Type) SetDONE0_1_IRQ_TRIG3_DONE0(value uint32) {
	volatile.StoreUint32(&o.DONE0_1_IRQ.Reg, volatile.LoadUint32(&o.DONE0_1_IRQ.Reg)&^(0x8)|value<<3)
}
func (o *ADC_ETC_Type) GetDONE0_1_IRQ_TRIG3_DONE0() uint32 {
	return (volatile.LoadUint32(&o.DONE0_1_IRQ.Reg) & 0x8) >> 3
}
func (o *ADC_ETC_Type) SetDONE0_1_IRQ_TRIG4_DONE0(value uint32) {
	volatile.StoreUint32(&o.DONE0_1_IRQ.Reg, volatile.LoadUint32(&o.DONE0_1_IRQ.Reg)&^(0x10)|value<<4)
}
func (o *ADC_ETC_Type) GetDONE0_1_IRQ_TRIG4_DONE0() uint32 {
	return (volatile.LoadUint32(&o.DONE0_1_IRQ.Reg) & 0x10) >> 4
}
func (o *ADC_ETC_Type) SetDONE0_1_IRQ_TRIG5_DONE0(value uint32) {
	volatile.StoreUint32(&o.DONE0_1_IRQ.Reg, volatile.LoadUint32(&o.DONE0_1_IRQ.Reg)&^(0x20)|value<<5)
}
func (o *ADC_ETC_Type) GetDONE0_1_IRQ_TRIG5_DONE0() uint32 {
	return (volatile.LoadUint32(&o.DONE0_1_IRQ.Reg) & 0x20) >> 5
}
func (o *ADC_ETC_Type) SetDONE0_1_IRQ_TRIG6_DONE0(value uint32) {
	volatile.StoreUint32(&o.DONE0_1_IRQ.Reg, volatile.LoadUint32(&o.DONE0_1_IRQ.Reg)&^(0x40)|value<<6)
}
func (o *ADC_ETC_Type) GetDONE0_1_IRQ_TRIG6_DONE0() uint32 {
	return (volatile.LoadUint32(&o.DONE0_1_IRQ.Reg) & 0x40) >> 6
}
func (o *ADC_ETC_Type) SetDONE0_1_IRQ_TRIG7_DONE0(value uint32) {
	volatile.StoreUint32(&o.DONE0_1_IRQ.Reg, volatile.LoadUint32(&o.DONE0_1_IRQ.Reg)&^(0x80)|value<<7)
}
func (o *ADC_ETC_Type) GetDONE0_1_IRQ_TRIG7_DONE0() uint32 {
	return (volatile.LoadUint32(&o.DONE0_1_IRQ.Reg) & 0x80) >> 7
}
func (o *ADC_ETC_Type) SetDONE0_1_IRQ_TRIG0_DONE1(value uint32) {
	volatile.StoreUint32(&o.DONE0_1_IRQ.Reg, volatile.LoadUint32(&o.DONE0_1_IRQ.Reg)&^(0x10000)|value<<16)
}
func (o *ADC_ETC_Type) GetDONE0_1_IRQ_TRIG0_DONE1() uint32 {
	return (volatile.LoadUint32(&o.DONE0_1_IRQ.Reg) & 0x10000) >> 16
}
func (o *ADC_ETC_Type) SetDONE0_1_IRQ_TRIG1_DONE1(value uint32) {
	volatile.StoreUint32(&o.DONE0_1_IRQ.Reg, volatile.LoadUint32(&o.DONE0_1_IRQ.Reg)&^(0x20000)|value<<17)
}
func (o *ADC_ETC_Type) GetDONE0_1_IRQ_TRIG1_DONE1() uint32 {
	return (volatile.LoadUint32(&o.DONE0_1_IRQ.Reg) & 0x20000) >> 17
}
func (o *ADC_ETC_Type) SetDONE0_1_IRQ_TRIG2_DONE1(value uint32) {
	volatile.StoreUint32(&o.DONE0_1_IRQ.Reg, volatile.LoadUint32(&o.DONE0_1_IRQ.Reg)&^(0x40000)|value<<18)
}
func (o *ADC_ETC_Type) GetDONE0_1_IRQ_TRIG2_DONE1() uint32 {
	return (volatile.LoadUint32(&o.DONE0_1_IRQ.Reg) & 0x40000) >> 18
}
func (o *ADC_ETC_Type) SetDONE0_1_IRQ_TRIG3_DONE1(value uint32) {
	volatile.StoreUint32(&o.DONE0_1_IRQ.Reg, volatile.LoadUint32(&o.DONE0_1_IRQ.Reg)&^(0x80000)|value<<19)
}
func (o *ADC_ETC_Type) GetDONE0_1_IRQ_TRIG3_DONE1() uint32 {
	return (volatile.LoadUint32(&o.DONE0_1_IRQ.Reg) & 0x80000) >> 19
}
func (o *ADC_ETC_Type) SetDONE0_1_IRQ_TRIG4_DONE1(value uint32) {
	volatile.StoreUint32(&o.DONE0_1_IRQ.Reg, volatile.LoadUint32(&o.DONE0_1_IRQ.Reg)&^(0x100000)|value<<20)
}
func (o *ADC_ETC_Type) GetDONE0_1_IRQ_TRIG4_DONE1() uint32 {
	return (volatile.LoadUint32(&o.DONE0_1_IRQ.Reg) & 0x100000) >> 20
}
func (o *ADC_ETC_Type) SetDONE0_1_IRQ_TRIG5_DONE1(value uint32) {
	volatile.StoreUint32(&o.DONE0_1_IRQ.Reg, volatile.LoadUint32(&o.DONE0_1_IRQ.Reg)&^(0x200000)|value<<21)
}
func (o *ADC_ETC_Type) GetDONE0_1_IRQ_TRIG5_DONE1() uint32 {
	return (volatile.LoadUint32(&o.DONE0_1_IRQ.Reg) & 0x200000) >> 21
}
func (o *ADC_ETC_Type) SetDONE0_1_IRQ_TRIG6_DONE1(value uint32) {
	volatile.StoreUint32(&o.DONE0_1_IRQ.Reg, volatile.LoadUint32(&o.DONE0_1_IRQ.Reg)&^(0x400000)|value<<22)
}
func (o *ADC_ETC_Type) GetDONE0_1_IRQ_TRIG6_DONE1() uint32 {
	return (volatile.LoadUint32(&o.DONE0_1_IRQ.Reg) & 0x400000) >> 22
}
func (o *ADC_ETC_Type) SetDONE0_1_IRQ_TRIG7_DONE1(value uint32) {
	volatile.StoreUint32(&o.DONE0_1_IRQ.Reg, volatile.LoadUint32(&o.DONE0_1_IRQ.Reg)&^(0x800000)|value<<23)
}
func (o *ADC_ETC_Type) GetDONE0_1_IRQ_TRIG7_DONE1() uint32 {
	return (volatile.LoadUint32(&o.DONE0_1_IRQ.Reg) & 0x800000) >> 23
}

// ADC_ETC.DONE2_ERR_IRQ: ETC DONE_2 and DONE_ERR IRQ State Register
func (o *ADC_ETC_Type) SetDONE2_ERR_IRQ_TRIG0_DONE2(value uint32) {
	volatile.StoreUint32(&o.DONE2_ERR_IRQ.Reg, volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg)&^(0x1)|value)
}
func (o *ADC_ETC_Type) GetDONE2_ERR_IRQ_TRIG0_DONE2() uint32 {
	return volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg) & 0x1
}
func (o *ADC_ETC_Type) SetDONE2_ERR_IRQ_TRIG1_DONE2(value uint32) {
	volatile.StoreUint32(&o.DONE2_ERR_IRQ.Reg, volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg)&^(0x2)|value<<1)
}
func (o *ADC_ETC_Type) GetDONE2_ERR_IRQ_TRIG1_DONE2() uint32 {
	return (volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg) & 0x2) >> 1
}
func (o *ADC_ETC_Type) SetDONE2_ERR_IRQ_TRIG2_DONE2(value uint32) {
	volatile.StoreUint32(&o.DONE2_ERR_IRQ.Reg, volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg)&^(0x4)|value<<2)
}
func (o *ADC_ETC_Type) GetDONE2_ERR_IRQ_TRIG2_DONE2() uint32 {
	return (volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg) & 0x4) >> 2
}
func (o *ADC_ETC_Type) SetDONE2_ERR_IRQ_TRIG3_DONE2(value uint32) {
	volatile.StoreUint32(&o.DONE2_ERR_IRQ.Reg, volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg)&^(0x8)|value<<3)
}
func (o *ADC_ETC_Type) GetDONE2_ERR_IRQ_TRIG3_DONE2() uint32 {
	return (volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg) & 0x8) >> 3
}
func (o *ADC_ETC_Type) SetDONE2_ERR_IRQ_TRIG4_DONE2(value uint32) {
	volatile.StoreUint32(&o.DONE2_ERR_IRQ.Reg, volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg)&^(0x10)|value<<4)
}
func (o *ADC_ETC_Type) GetDONE2_ERR_IRQ_TRIG4_DONE2() uint32 {
	return (volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg) & 0x10) >> 4
}
func (o *ADC_ETC_Type) SetDONE2_ERR_IRQ_TRIG5_DONE2(value uint32) {
	volatile.StoreUint32(&o.DONE2_ERR_IRQ.Reg, volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg)&^(0x20)|value<<5)
}
func (o *ADC_ETC_Type) GetDONE2_ERR_IRQ_TRIG5_DONE2() uint32 {
	return (volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg) & 0x20) >> 5
}
func (o *ADC_ETC_Type) SetDONE2_ERR_IRQ_TRIG6_DONE2(value uint32) {
	volatile.StoreUint32(&o.DONE2_ERR_IRQ.Reg, volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg)&^(0x40)|value<<6)
}
func (o *ADC_ETC_Type) GetDONE2_ERR_IRQ_TRIG6_DONE2() uint32 {
	return (volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg) & 0x40) >> 6
}
func (o *ADC_ETC_Type) SetDONE2_ERR_IRQ_TRIG7_DONE2(value uint32) {
	volatile.StoreUint32(&o.DONE2_ERR_IRQ.Reg, volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg)&^(0x80)|value<<7)
}
func (o *ADC_ETC_Type) GetDONE2_ERR_IRQ_TRIG7_DONE2() uint32 {
	return (volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg) & 0x80) >> 7
}
func (o *ADC_ETC_Type) SetDONE2_ERR_IRQ_TRIG0_DONE3(value uint32) {
	volatile.StoreUint32(&o.DONE2_ERR_IRQ.Reg, volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg)&^(0x100)|value<<8)
}
func (o *ADC_ETC_Type) GetDONE2_ERR_IRQ_TRIG0_DONE3() uint32 {
	return (volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg) & 0x100) >> 8
}
func (o *ADC_ETC_Type) SetDONE2_ERR_IRQ_TRIG1_DONE3(value uint32) {
	volatile.StoreUint32(&o.DONE2_ERR_IRQ.Reg, volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg)&^(0x200)|value<<9)
}
func (o *ADC_ETC_Type) GetDONE2_ERR_IRQ_TRIG1_DONE3() uint32 {
	return (volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg) & 0x200) >> 9
}
func (o *ADC_ETC_Type) SetDONE2_ERR_IRQ_TRIG2_DONE3(value uint32) {
	volatile.StoreUint32(&o.DONE2_ERR_IRQ.Reg, volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg)&^(0x400)|value<<10)
}
func (o *ADC_ETC_Type) GetDONE2_ERR_IRQ_TRIG2_DONE3() uint32 {
	return (volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg) & 0x400) >> 10
}
func (o *ADC_ETC_Type) SetDONE2_ERR_IRQ_TRIG3_DONE3(value uint32) {
	volatile.StoreUint32(&o.DONE2_ERR_IRQ.Reg, volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg)&^(0x800)|value<<11)
}
func (o *ADC_ETC_Type) GetDONE2_ERR_IRQ_TRIG3_DONE3() uint32 {
	return (volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg) & 0x800) >> 11
}
func (o *ADC_ETC_Type) SetDONE2_ERR_IRQ_TRIG4_DONE3(value uint32) {
	volatile.StoreUint32(&o.DONE2_ERR_IRQ.Reg, volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_ETC_Type) GetDONE2_ERR_IRQ_TRIG4_DONE3() uint32 {
	return (volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg) & 0x1000) >> 12
}
func (o *ADC_ETC_Type) SetDONE2_ERR_IRQ_TRIG5_DONE3(value uint32) {
	volatile.StoreUint32(&o.DONE2_ERR_IRQ.Reg, volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg)&^(0x2000)|value<<13)
}
func (o *ADC_ETC_Type) GetDONE2_ERR_IRQ_TRIG5_DONE3() uint32 {
	return (volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg) & 0x2000) >> 13
}
func (o *ADC_ETC_Type) SetDONE2_ERR_IRQ_TRIG6_DONE3(value uint32) {
	volatile.StoreUint32(&o.DONE2_ERR_IRQ.Reg, volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg)&^(0x4000)|value<<14)
}
func (o *ADC_ETC_Type) GetDONE2_ERR_IRQ_TRIG6_DONE3() uint32 {
	return (volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg) & 0x4000) >> 14
}
func (o *ADC_ETC_Type) SetDONE2_ERR_IRQ_TRIG7_DONE3(value uint32) {
	volatile.StoreUint32(&o.DONE2_ERR_IRQ.Reg, volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg)&^(0x8000)|value<<15)
}
func (o *ADC_ETC_Type) GetDONE2_ERR_IRQ_TRIG7_DONE3() uint32 {
	return (volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg) & 0x8000) >> 15
}
func (o *ADC_ETC_Type) SetDONE2_ERR_IRQ_TRIG0_ERR(value uint32) {
	volatile.StoreUint32(&o.DONE2_ERR_IRQ.Reg, volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg)&^(0x10000)|value<<16)
}
func (o *ADC_ETC_Type) GetDONE2_ERR_IRQ_TRIG0_ERR() uint32 {
	return (volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg) & 0x10000) >> 16
}
func (o *ADC_ETC_Type) SetDONE2_ERR_IRQ_TRIG1_ERR(value uint32) {
	volatile.StoreUint32(&o.DONE2_ERR_IRQ.Reg, volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg)&^(0x20000)|value<<17)
}
func (o *ADC_ETC_Type) GetDONE2_ERR_IRQ_TRIG1_ERR() uint32 {
	return (volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg) & 0x20000) >> 17
}
func (o *ADC_ETC_Type) SetDONE2_ERR_IRQ_TRIG2_ERR(value uint32) {
	volatile.StoreUint32(&o.DONE2_ERR_IRQ.Reg, volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg)&^(0x40000)|value<<18)
}
func (o *ADC_ETC_Type) GetDONE2_ERR_IRQ_TRIG2_ERR() uint32 {
	return (volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg) & 0x40000) >> 18
}
func (o *ADC_ETC_Type) SetDONE2_ERR_IRQ_TRIG3_ERR(value uint32) {
	volatile.StoreUint32(&o.DONE2_ERR_IRQ.Reg, volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg)&^(0x80000)|value<<19)
}
func (o *ADC_ETC_Type) GetDONE2_ERR_IRQ_TRIG3_ERR() uint32 {
	return (volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg) & 0x80000) >> 19
}
func (o *ADC_ETC_Type) SetDONE2_ERR_IRQ_TRIG4_ERR(value uint32) {
	volatile.StoreUint32(&o.DONE2_ERR_IRQ.Reg, volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg)&^(0x100000)|value<<20)
}
func (o *ADC_ETC_Type) GetDONE2_ERR_IRQ_TRIG4_ERR() uint32 {
	return (volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg) & 0x100000) >> 20
}
func (o *ADC_ETC_Type) SetDONE2_ERR_IRQ_TRIG5_ERR(value uint32) {
	volatile.StoreUint32(&o.DONE2_ERR_IRQ.Reg, volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg)&^(0x200000)|value<<21)
}
func (o *ADC_ETC_Type) GetDONE2_ERR_IRQ_TRIG5_ERR() uint32 {
	return (volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg) & 0x200000) >> 21
}
func (o *ADC_ETC_Type) SetDONE2_ERR_IRQ_TRIG6_ERR(value uint32) {
	volatile.StoreUint32(&o.DONE2_ERR_IRQ.Reg, volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg)&^(0x400000)|value<<22)
}
func (o *ADC_ETC_Type) GetDONE2_ERR_IRQ_TRIG6_ERR() uint32 {
	return (volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg) & 0x400000) >> 22
}
func (o *ADC_ETC_Type) SetDONE2_ERR_IRQ_TRIG7_ERR(value uint32) {
	volatile.StoreUint32(&o.DONE2_ERR_IRQ.Reg, volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg)&^(0x800000)|value<<23)
}
func (o *ADC_ETC_Type) GetDONE2_ERR_IRQ_TRIG7_ERR() uint32 {
	return (volatile.LoadUint32(&o.DONE2_ERR_IRQ.Reg) & 0x800000) >> 23
}

// ADC_ETC.DMA_CTRL: ETC DMA control Register
func (o *ADC_ETC_Type) SetDMA_CTRL_TRIG0_ENABLE(value uint32) {
	volatile.StoreUint32(&o.DMA_CTRL.Reg, volatile.LoadUint32(&o.DMA_CTRL.Reg)&^(0x1)|value)
}
func (o *ADC_ETC_Type) GetDMA_CTRL_TRIG0_ENABLE() uint32 {
	return volatile.LoadUint32(&o.DMA_CTRL.Reg) & 0x1
}
func (o *ADC_ETC_Type) SetDMA_CTRL_TRIG1_ENABLE(value uint32) {
	volatile.StoreUint32(&o.DMA_CTRL.Reg, volatile.LoadUint32(&o.DMA_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *ADC_ETC_Type) GetDMA_CTRL_TRIG1_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.DMA_CTRL.Reg) & 0x2) >> 1
}
func (o *ADC_ETC_Type) SetDMA_CTRL_TRIG2_ENABLE(value uint32) {
	volatile.StoreUint32(&o.DMA_CTRL.Reg, volatile.LoadUint32(&o.DMA_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *ADC_ETC_Type) GetDMA_CTRL_TRIG2_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.DMA_CTRL.Reg) & 0x4) >> 2
}
func (o *ADC_ETC_Type) SetDMA_CTRL_TRIG3_ENABLE(value uint32) {
	volatile.StoreUint32(&o.DMA_CTRL.Reg, volatile.LoadUint32(&o.DMA_CTRL.Reg)&^(0x8)|value<<3)
}
func (o *ADC_ETC_Type) GetDMA_CTRL_TRIG3_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.DMA_CTRL.Reg) & 0x8) >> 3
}
func (o *ADC_ETC_Type) SetDMA_CTRL_TRIG4_ENABLE(value uint32) {
	volatile.StoreUint32(&o.DMA_CTRL.Reg, volatile.LoadUint32(&o.DMA_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *ADC_ETC_Type) GetDMA_CTRL_TRIG4_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.DMA_CTRL.Reg) & 0x10) >> 4
}
func (o *ADC_ETC_Type) SetDMA_CTRL_TRIG5_ENABLE(value uint32) {
	volatile.StoreUint32(&o.DMA_CTRL.Reg, volatile.LoadUint32(&o.DMA_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *ADC_ETC_Type) GetDMA_CTRL_TRIG5_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.DMA_CTRL.Reg) & 0x20) >> 5
}
func (o *ADC_ETC_Type) SetDMA_CTRL_TRIG6_ENABLE(value uint32) {
	volatile.StoreUint32(&o.DMA_CTRL.Reg, volatile.LoadUint32(&o.DMA_CTRL.Reg)&^(0x40)|value<<6)
}
func (o *ADC_ETC_Type) GetDMA_CTRL_TRIG6_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.DMA_CTRL.Reg) & 0x40) >> 6
}
func (o *ADC_ETC_Type) SetDMA_CTRL_TRIG7_ENABLE(value uint32) {
	volatile.StoreUint32(&o.DMA_CTRL.Reg, volatile.LoadUint32(&o.DMA_CTRL.Reg)&^(0x80)|value<<7)
}
func (o *ADC_ETC_Type) GetDMA_CTRL_TRIG7_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.DMA_CTRL.Reg) & 0x80) >> 7
}
func (o *ADC_ETC_Type) SetDMA_CTRL_TRIG0_REQ(value uint32) {
	volatile.StoreUint32(&o.DMA_CTRL.Reg, volatile.LoadUint32(&o.DMA_CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *ADC_ETC_Type) GetDMA_CTRL_TRIG0_REQ() uint32 {
	return (volatile.LoadUint32(&o.DMA_CTRL.Reg) & 0x10000) >> 16
}
func (o *ADC_ETC_Type) SetDMA_CTRL_TRIG1_REQ(value uint32) {
	volatile.StoreUint32(&o.DMA_CTRL.Reg, volatile.LoadUint32(&o.DMA_CTRL.Reg)&^(0x20000)|value<<17)
}
func (o *ADC_ETC_Type) GetDMA_CTRL_TRIG1_REQ() uint32 {
	return (volatile.LoadUint32(&o.DMA_CTRL.Reg) & 0x20000) >> 17
}
func (o *ADC_ETC_Type) SetDMA_CTRL_TRIG2_REQ(value uint32) {
	volatile.StoreUint32(&o.DMA_CTRL.Reg, volatile.LoadUint32(&o.DMA_CTRL.Reg)&^(0x40000)|value<<18)
}
func (o *ADC_ETC_Type) GetDMA_CTRL_TRIG2_REQ() uint32 {
	return (volatile.LoadUint32(&o.DMA_CTRL.Reg) & 0x40000) >> 18
}
func (o *ADC_ETC_Type) SetDMA_CTRL_TRIG3_REQ(value uint32) {
	volatile.StoreUint32(&o.DMA_CTRL.Reg, volatile.LoadUint32(&o.DMA_CTRL.Reg)&^(0x80000)|value<<19)
}
func (o *ADC_ETC_Type) GetDMA_CTRL_TRIG3_REQ() uint32 {
	return (volatile.LoadUint32(&o.DMA_CTRL.Reg) & 0x80000) >> 19
}
func (o *ADC_ETC_Type) SetDMA_CTRL_TRIG4_REQ(value uint32) {
	volatile.StoreUint32(&o.DMA_CTRL.Reg, volatile.LoadUint32(&o.DMA_CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *ADC_ETC_Type) GetDMA_CTRL_TRIG4_REQ() uint32 {
	return (volatile.LoadUint32(&o.DMA_CTRL.Reg) & 0x100000) >> 20
}
func (o *ADC_ETC_Type) SetDMA_CTRL_TRIG5_REQ(value uint32) {
	volatile.StoreUint32(&o.DMA_CTRL.Reg, volatile.LoadUint32(&o.DMA_CTRL.Reg)&^(0x200000)|value<<21)
}
func (o *ADC_ETC_Type) GetDMA_CTRL_TRIG5_REQ() uint32 {
	return (volatile.LoadUint32(&o.DMA_CTRL.Reg) & 0x200000) >> 21
}
func (o *ADC_ETC_Type) SetDMA_CTRL_TRIG6_REQ(value uint32) {
	volatile.StoreUint32(&o.DMA_CTRL.Reg, volatile.LoadUint32(&o.DMA_CTRL.Reg)&^(0x400000)|value<<22)
}
func (o *ADC_ETC_Type) GetDMA_CTRL_TRIG6_REQ() uint32 {
	return (volatile.LoadUint32(&o.DMA_CTRL.Reg) & 0x400000) >> 22
}
func (o *ADC_ETC_Type) SetDMA_CTRL_TRIG7_REQ(value uint32) {
	volatile.StoreUint32(&o.DMA_CTRL.Reg, volatile.LoadUint32(&o.DMA_CTRL.Reg)&^(0x800000)|value<<23)
}
func (o *ADC_ETC_Type) GetDMA_CTRL_TRIG7_REQ() uint32 {
	return (volatile.LoadUint32(&o.DMA_CTRL.Reg) & 0x800000) >> 23
}

// ADC_ETC.TRIG0_CTRL: ETC_TRIG Control Register
func (o *ADC_ETC_Type) SetTRIG0_CTRL_SW_TRIG(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CTRL.Reg, volatile.LoadUint32(&o.TRIG0_CTRL.Reg)&^(0x1)|value)
}
func (o *ADC_ETC_Type) GetTRIG0_CTRL_SW_TRIG() uint32 {
	return volatile.LoadUint32(&o.TRIG0_CTRL.Reg) & 0x1
}
func (o *ADC_ETC_Type) SetTRIG0_CTRL_TRIG_MODE(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CTRL.Reg, volatile.LoadUint32(&o.TRIG0_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *ADC_ETC_Type) GetTRIG0_CTRL_TRIG_MODE() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CTRL.Reg) & 0x10) >> 4
}
func (o *ADC_ETC_Type) SetTRIG0_CTRL_TRIG_CHAIN(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CTRL.Reg, volatile.LoadUint32(&o.TRIG0_CTRL.Reg)&^(0x700)|value<<8)
}
func (o *ADC_ETC_Type) GetTRIG0_CTRL_TRIG_CHAIN() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CTRL.Reg) & 0x700) >> 8
}
func (o *ADC_ETC_Type) SetTRIG0_CTRL_TRIG_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CTRL.Reg, volatile.LoadUint32(&o.TRIG0_CTRL.Reg)&^(0x7000)|value<<12)
}
func (o *ADC_ETC_Type) GetTRIG0_CTRL_TRIG_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CTRL.Reg) & 0x7000) >> 12
}
func (o *ADC_ETC_Type) SetTRIG0_CTRL_SYNC_MODE(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CTRL.Reg, volatile.LoadUint32(&o.TRIG0_CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG0_CTRL_SYNC_MODE() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CTRL.Reg) & 0x10000) >> 16
}
func (o *ADC_ETC_Type) SetTRIG0_CTRL_CHAINx_DONE(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CTRL.Reg, volatile.LoadUint32(&o.TRIG0_CTRL.Reg)&^(0xff000000)|value<<24)
}
func (o *ADC_ETC_Type) GetTRIG0_CTRL_CHAINx_DONE() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CTRL.Reg) & 0xff000000) >> 24
}

// ADC_ETC.TRIG0_COUNTER: ETC_TRIG Counter Register
func (o *ADC_ETC_Type) SetTRIG0_COUNTER_INIT_DELAY(value uint32) {
	volatile.StoreUint32(&o.TRIG0_COUNTER.Reg, volatile.LoadUint32(&o.TRIG0_COUNTER.Reg)&^(0xffff)|value)
}
func (o *ADC_ETC_Type) GetTRIG0_COUNTER_INIT_DELAY() uint32 {
	return volatile.LoadUint32(&o.TRIG0_COUNTER.Reg) & 0xffff
}
func (o *ADC_ETC_Type) SetTRIG0_COUNTER_SAMPLE_INTERVAL(value uint32) {
	volatile.StoreUint32(&o.TRIG0_COUNTER.Reg, volatile.LoadUint32(&o.TRIG0_COUNTER.Reg)&^(0xffff0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG0_COUNTER_SAMPLE_INTERVAL() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_COUNTER.Reg) & 0xffff0000) >> 16
}

// ADC_ETC.TRIG0_CHAIN_1_0: ETC_TRIG Chain 0/1 Register
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_1_0_CSEL0(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_1_0.Reg)&^(0xf)|value)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_1_0_CSEL0() uint32 {
	return volatile.LoadUint32(&o.TRIG0_CHAIN_1_0.Reg) & 0xf
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_1_0_HWTS0(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_1_0.Reg)&^(0xff0)|value<<4)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_1_0_HWTS0() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_1_0.Reg) & 0xff0) >> 4
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_1_0_B2B0(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_1_0.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_1_0_B2B0() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_1_0.Reg) & 0x1000) >> 12
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_1_0_IE0(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_1_0.Reg)&^(0x6000)|value<<13)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_1_0_IE0() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_1_0.Reg) & 0x6000) >> 13
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_1_0_IE0_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_1_0.Reg)&^(0x8000)|value<<15)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_1_0_IE0_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_1_0.Reg) & 0x8000) >> 15
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_1_0_CSEL1(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_1_0.Reg)&^(0xf0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_1_0_CSEL1() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_1_0.Reg) & 0xf0000) >> 16
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_1_0_HWTS1(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_1_0.Reg)&^(0xff00000)|value<<20)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_1_0_HWTS1() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_1_0.Reg) & 0xff00000) >> 20
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_1_0_B2B1(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_1_0.Reg)&^(0x10000000)|value<<28)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_1_0_B2B1() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_1_0.Reg) & 0x10000000) >> 28
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_1_0_IE1(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_1_0.Reg)&^(0x60000000)|value<<29)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_1_0_IE1() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_1_0.Reg) & 0x60000000) >> 29
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_1_0_IE1_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_1_0.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_1_0_IE1_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_1_0.Reg) & 0x80000000) >> 31
}

// ADC_ETC.TRIG0_CHAIN_3_2: ETC_TRIG Chain 2/3 Register
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_3_2_CSEL2(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_3_2.Reg)&^(0xf)|value)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_3_2_CSEL2() uint32 {
	return volatile.LoadUint32(&o.TRIG0_CHAIN_3_2.Reg) & 0xf
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_3_2_HWTS2(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_3_2.Reg)&^(0xff0)|value<<4)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_3_2_HWTS2() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_3_2.Reg) & 0xff0) >> 4
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_3_2_B2B2(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_3_2.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_3_2_B2B2() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_3_2.Reg) & 0x1000) >> 12
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_3_2_IE2(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_3_2.Reg)&^(0x6000)|value<<13)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_3_2_IE2() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_3_2.Reg) & 0x6000) >> 13
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_3_2_IE2_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_3_2.Reg)&^(0x8000)|value<<15)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_3_2_IE2_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_3_2.Reg) & 0x8000) >> 15
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_3_2_CSEL3(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_3_2.Reg)&^(0xf0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_3_2_CSEL3() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_3_2.Reg) & 0xf0000) >> 16
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_3_2_HWTS3(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_3_2.Reg)&^(0xff00000)|value<<20)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_3_2_HWTS3() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_3_2.Reg) & 0xff00000) >> 20
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_3_2_B2B3(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_3_2.Reg)&^(0x10000000)|value<<28)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_3_2_B2B3() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_3_2.Reg) & 0x10000000) >> 28
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_3_2_IE3(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_3_2.Reg)&^(0x60000000)|value<<29)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_3_2_IE3() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_3_2.Reg) & 0x60000000) >> 29
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_3_2_IE3_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_3_2.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_3_2_IE3_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_3_2.Reg) & 0x80000000) >> 31
}

// ADC_ETC.TRIG0_CHAIN_5_4: ETC_TRIG Chain 4/5 Register
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_5_4_CSEL4(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_5_4.Reg)&^(0xf)|value)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_5_4_CSEL4() uint32 {
	return volatile.LoadUint32(&o.TRIG0_CHAIN_5_4.Reg) & 0xf
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_5_4_HWTS4(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_5_4.Reg)&^(0xff0)|value<<4)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_5_4_HWTS4() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_5_4.Reg) & 0xff0) >> 4
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_5_4_B2B4(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_5_4.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_5_4_B2B4() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_5_4.Reg) & 0x1000) >> 12
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_5_4_IE4(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_5_4.Reg)&^(0x6000)|value<<13)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_5_4_IE4() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_5_4.Reg) & 0x6000) >> 13
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_5_4_IE4_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_5_4.Reg)&^(0x8000)|value<<15)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_5_4_IE4_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_5_4.Reg) & 0x8000) >> 15
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_5_4_CSEL5(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_5_4.Reg)&^(0xf0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_5_4_CSEL5() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_5_4.Reg) & 0xf0000) >> 16
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_5_4_HWTS5(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_5_4.Reg)&^(0xff00000)|value<<20)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_5_4_HWTS5() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_5_4.Reg) & 0xff00000) >> 20
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_5_4_B2B5(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_5_4.Reg)&^(0x10000000)|value<<28)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_5_4_B2B5() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_5_4.Reg) & 0x10000000) >> 28
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_5_4_IE5(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_5_4.Reg)&^(0x60000000)|value<<29)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_5_4_IE5() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_5_4.Reg) & 0x60000000) >> 29
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_5_4_IE5_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_5_4.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_5_4_IE5_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_5_4.Reg) & 0x80000000) >> 31
}

// ADC_ETC.TRIG0_CHAIN_7_6: ETC_TRIG Chain 6/7 Register
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_7_6_CSEL6(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_7_6.Reg)&^(0xf)|value)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_7_6_CSEL6() uint32 {
	return volatile.LoadUint32(&o.TRIG0_CHAIN_7_6.Reg) & 0xf
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_7_6_HWTS6(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_7_6.Reg)&^(0xff0)|value<<4)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_7_6_HWTS6() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_7_6.Reg) & 0xff0) >> 4
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_7_6_B2B6(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_7_6.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_7_6_B2B6() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_7_6.Reg) & 0x1000) >> 12
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_7_6_IE6(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_7_6.Reg)&^(0x6000)|value<<13)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_7_6_IE6() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_7_6.Reg) & 0x6000) >> 13
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_7_6_IE6_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_7_6.Reg)&^(0x8000)|value<<15)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_7_6_IE6_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_7_6.Reg) & 0x8000) >> 15
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_7_6_CSEL7(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_7_6.Reg)&^(0xf0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_7_6_CSEL7() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_7_6.Reg) & 0xf0000) >> 16
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_7_6_HWTS7(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_7_6.Reg)&^(0xff00000)|value<<20)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_7_6_HWTS7() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_7_6.Reg) & 0xff00000) >> 20
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_7_6_B2B7(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_7_6.Reg)&^(0x10000000)|value<<28)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_7_6_B2B7() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_7_6.Reg) & 0x10000000) >> 28
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_7_6_IE7(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_7_6.Reg)&^(0x60000000)|value<<29)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_7_6_IE7() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_7_6.Reg) & 0x60000000) >> 29
}
func (o *ADC_ETC_Type) SetTRIG0_CHAIN_7_6_IE7_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG0_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG0_CHAIN_7_6.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_ETC_Type) GetTRIG0_CHAIN_7_6_IE7_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_CHAIN_7_6.Reg) & 0x80000000) >> 31
}

// ADC_ETC.TRIG0_RESULT_1_0: ETC_TRIG Result Data 1/0 Register
func (o *ADC_ETC_Type) SetTRIG0_RESULT_1_0_DATA0(value uint32) {
	volatile.StoreUint32(&o.TRIG0_RESULT_1_0.Reg, volatile.LoadUint32(&o.TRIG0_RESULT_1_0.Reg)&^(0xfff)|value)
}
func (o *ADC_ETC_Type) GetTRIG0_RESULT_1_0_DATA0() uint32 {
	return volatile.LoadUint32(&o.TRIG0_RESULT_1_0.Reg) & 0xfff
}
func (o *ADC_ETC_Type) SetTRIG0_RESULT_1_0_DATA1(value uint32) {
	volatile.StoreUint32(&o.TRIG0_RESULT_1_0.Reg, volatile.LoadUint32(&o.TRIG0_RESULT_1_0.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG0_RESULT_1_0_DATA1() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_RESULT_1_0.Reg) & 0xfff0000) >> 16
}

// ADC_ETC.TRIG0_RESULT_3_2: ETC_TRIG Result Data 3/2 Register
func (o *ADC_ETC_Type) SetTRIG0_RESULT_3_2_DATA2(value uint32) {
	volatile.StoreUint32(&o.TRIG0_RESULT_3_2.Reg, volatile.LoadUint32(&o.TRIG0_RESULT_3_2.Reg)&^(0xfff)|value)
}
func (o *ADC_ETC_Type) GetTRIG0_RESULT_3_2_DATA2() uint32 {
	return volatile.LoadUint32(&o.TRIG0_RESULT_3_2.Reg) & 0xfff
}
func (o *ADC_ETC_Type) SetTRIG0_RESULT_3_2_DATA3(value uint32) {
	volatile.StoreUint32(&o.TRIG0_RESULT_3_2.Reg, volatile.LoadUint32(&o.TRIG0_RESULT_3_2.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG0_RESULT_3_2_DATA3() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_RESULT_3_2.Reg) & 0xfff0000) >> 16
}

// ADC_ETC.TRIG0_RESULT_5_4: ETC_TRIG Result Data 5/4 Register
func (o *ADC_ETC_Type) SetTRIG0_RESULT_5_4_DATA4(value uint32) {
	volatile.StoreUint32(&o.TRIG0_RESULT_5_4.Reg, volatile.LoadUint32(&o.TRIG0_RESULT_5_4.Reg)&^(0xfff)|value)
}
func (o *ADC_ETC_Type) GetTRIG0_RESULT_5_4_DATA4() uint32 {
	return volatile.LoadUint32(&o.TRIG0_RESULT_5_4.Reg) & 0xfff
}
func (o *ADC_ETC_Type) SetTRIG0_RESULT_5_4_DATA5(value uint32) {
	volatile.StoreUint32(&o.TRIG0_RESULT_5_4.Reg, volatile.LoadUint32(&o.TRIG0_RESULT_5_4.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG0_RESULT_5_4_DATA5() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_RESULT_5_4.Reg) & 0xfff0000) >> 16
}

// ADC_ETC.TRIG0_RESULT_7_6: ETC_TRIG Result Data 7/6 Register
func (o *ADC_ETC_Type) SetTRIG0_RESULT_7_6_DATA6(value uint32) {
	volatile.StoreUint32(&o.TRIG0_RESULT_7_6.Reg, volatile.LoadUint32(&o.TRIG0_RESULT_7_6.Reg)&^(0xfff)|value)
}
func (o *ADC_ETC_Type) GetTRIG0_RESULT_7_6_DATA6() uint32 {
	return volatile.LoadUint32(&o.TRIG0_RESULT_7_6.Reg) & 0xfff
}
func (o *ADC_ETC_Type) SetTRIG0_RESULT_7_6_DATA7(value uint32) {
	volatile.StoreUint32(&o.TRIG0_RESULT_7_6.Reg, volatile.LoadUint32(&o.TRIG0_RESULT_7_6.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG0_RESULT_7_6_DATA7() uint32 {
	return (volatile.LoadUint32(&o.TRIG0_RESULT_7_6.Reg) & 0xfff0000) >> 16
}

// ADC_ETC.TRIG1_CTRL: ETC_TRIG Control Register
func (o *ADC_ETC_Type) SetTRIG1_CTRL_SW_TRIG(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CTRL.Reg, volatile.LoadUint32(&o.TRIG1_CTRL.Reg)&^(0x1)|value)
}
func (o *ADC_ETC_Type) GetTRIG1_CTRL_SW_TRIG() uint32 {
	return volatile.LoadUint32(&o.TRIG1_CTRL.Reg) & 0x1
}
func (o *ADC_ETC_Type) SetTRIG1_CTRL_TRIG_MODE(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CTRL.Reg, volatile.LoadUint32(&o.TRIG1_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *ADC_ETC_Type) GetTRIG1_CTRL_TRIG_MODE() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CTRL.Reg) & 0x10) >> 4
}
func (o *ADC_ETC_Type) SetTRIG1_CTRL_TRIG_CHAIN(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CTRL.Reg, volatile.LoadUint32(&o.TRIG1_CTRL.Reg)&^(0x700)|value<<8)
}
func (o *ADC_ETC_Type) GetTRIG1_CTRL_TRIG_CHAIN() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CTRL.Reg) & 0x700) >> 8
}
func (o *ADC_ETC_Type) SetTRIG1_CTRL_TRIG_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CTRL.Reg, volatile.LoadUint32(&o.TRIG1_CTRL.Reg)&^(0x7000)|value<<12)
}
func (o *ADC_ETC_Type) GetTRIG1_CTRL_TRIG_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CTRL.Reg) & 0x7000) >> 12
}
func (o *ADC_ETC_Type) SetTRIG1_CTRL_SYNC_MODE(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CTRL.Reg, volatile.LoadUint32(&o.TRIG1_CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG1_CTRL_SYNC_MODE() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CTRL.Reg) & 0x10000) >> 16
}
func (o *ADC_ETC_Type) SetTRIG1_CTRL_CHAINx_DONE(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CTRL.Reg, volatile.LoadUint32(&o.TRIG1_CTRL.Reg)&^(0xff000000)|value<<24)
}
func (o *ADC_ETC_Type) GetTRIG1_CTRL_CHAINx_DONE() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CTRL.Reg) & 0xff000000) >> 24
}

// ADC_ETC.TRIG1_COUNTER: ETC_TRIG Counter Register
func (o *ADC_ETC_Type) SetTRIG1_COUNTER_INIT_DELAY(value uint32) {
	volatile.StoreUint32(&o.TRIG1_COUNTER.Reg, volatile.LoadUint32(&o.TRIG1_COUNTER.Reg)&^(0xffff)|value)
}
func (o *ADC_ETC_Type) GetTRIG1_COUNTER_INIT_DELAY() uint32 {
	return volatile.LoadUint32(&o.TRIG1_COUNTER.Reg) & 0xffff
}
func (o *ADC_ETC_Type) SetTRIG1_COUNTER_SAMPLE_INTERVAL(value uint32) {
	volatile.StoreUint32(&o.TRIG1_COUNTER.Reg, volatile.LoadUint32(&o.TRIG1_COUNTER.Reg)&^(0xffff0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG1_COUNTER_SAMPLE_INTERVAL() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_COUNTER.Reg) & 0xffff0000) >> 16
}

// ADC_ETC.TRIG1_CHAIN_1_0: ETC_TRIG Chain 0/1 Register
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_1_0_CSEL0(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_1_0.Reg)&^(0xf)|value)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_1_0_CSEL0() uint32 {
	return volatile.LoadUint32(&o.TRIG1_CHAIN_1_0.Reg) & 0xf
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_1_0_HWTS0(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_1_0.Reg)&^(0xff0)|value<<4)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_1_0_HWTS0() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_1_0.Reg) & 0xff0) >> 4
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_1_0_B2B0(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_1_0.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_1_0_B2B0() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_1_0.Reg) & 0x1000) >> 12
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_1_0_IE0(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_1_0.Reg)&^(0x6000)|value<<13)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_1_0_IE0() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_1_0.Reg) & 0x6000) >> 13
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_1_0_IE0_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_1_0.Reg)&^(0x8000)|value<<15)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_1_0_IE0_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_1_0.Reg) & 0x8000) >> 15
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_1_0_CSEL1(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_1_0.Reg)&^(0xf0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_1_0_CSEL1() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_1_0.Reg) & 0xf0000) >> 16
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_1_0_HWTS1(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_1_0.Reg)&^(0xff00000)|value<<20)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_1_0_HWTS1() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_1_0.Reg) & 0xff00000) >> 20
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_1_0_B2B1(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_1_0.Reg)&^(0x10000000)|value<<28)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_1_0_B2B1() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_1_0.Reg) & 0x10000000) >> 28
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_1_0_IE1(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_1_0.Reg)&^(0x60000000)|value<<29)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_1_0_IE1() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_1_0.Reg) & 0x60000000) >> 29
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_1_0_IE1_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_1_0.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_1_0_IE1_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_1_0.Reg) & 0x80000000) >> 31
}

// ADC_ETC.TRIG1_CHAIN_3_2: ETC_TRIG Chain 2/3 Register
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_3_2_CSEL2(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_3_2.Reg)&^(0xf)|value)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_3_2_CSEL2() uint32 {
	return volatile.LoadUint32(&o.TRIG1_CHAIN_3_2.Reg) & 0xf
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_3_2_HWTS2(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_3_2.Reg)&^(0xff0)|value<<4)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_3_2_HWTS2() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_3_2.Reg) & 0xff0) >> 4
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_3_2_B2B2(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_3_2.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_3_2_B2B2() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_3_2.Reg) & 0x1000) >> 12
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_3_2_IE2(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_3_2.Reg)&^(0x6000)|value<<13)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_3_2_IE2() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_3_2.Reg) & 0x6000) >> 13
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_3_2_IE2_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_3_2.Reg)&^(0x8000)|value<<15)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_3_2_IE2_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_3_2.Reg) & 0x8000) >> 15
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_3_2_CSEL3(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_3_2.Reg)&^(0xf0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_3_2_CSEL3() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_3_2.Reg) & 0xf0000) >> 16
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_3_2_HWTS3(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_3_2.Reg)&^(0xff00000)|value<<20)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_3_2_HWTS3() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_3_2.Reg) & 0xff00000) >> 20
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_3_2_B2B3(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_3_2.Reg)&^(0x10000000)|value<<28)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_3_2_B2B3() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_3_2.Reg) & 0x10000000) >> 28
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_3_2_IE3(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_3_2.Reg)&^(0x60000000)|value<<29)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_3_2_IE3() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_3_2.Reg) & 0x60000000) >> 29
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_3_2_IE3_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_3_2.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_3_2_IE3_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_3_2.Reg) & 0x80000000) >> 31
}

// ADC_ETC.TRIG1_CHAIN_5_4: ETC_TRIG Chain 4/5 Register
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_5_4_CSEL4(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_5_4.Reg)&^(0xf)|value)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_5_4_CSEL4() uint32 {
	return volatile.LoadUint32(&o.TRIG1_CHAIN_5_4.Reg) & 0xf
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_5_4_HWTS4(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_5_4.Reg)&^(0xff0)|value<<4)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_5_4_HWTS4() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_5_4.Reg) & 0xff0) >> 4
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_5_4_B2B4(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_5_4.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_5_4_B2B4() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_5_4.Reg) & 0x1000) >> 12
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_5_4_IE4(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_5_4.Reg)&^(0x6000)|value<<13)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_5_4_IE4() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_5_4.Reg) & 0x6000) >> 13
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_5_4_IE4_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_5_4.Reg)&^(0x8000)|value<<15)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_5_4_IE4_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_5_4.Reg) & 0x8000) >> 15
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_5_4_CSEL5(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_5_4.Reg)&^(0xf0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_5_4_CSEL5() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_5_4.Reg) & 0xf0000) >> 16
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_5_4_HWTS5(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_5_4.Reg)&^(0xff00000)|value<<20)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_5_4_HWTS5() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_5_4.Reg) & 0xff00000) >> 20
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_5_4_B2B5(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_5_4.Reg)&^(0x10000000)|value<<28)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_5_4_B2B5() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_5_4.Reg) & 0x10000000) >> 28
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_5_4_IE5(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_5_4.Reg)&^(0x60000000)|value<<29)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_5_4_IE5() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_5_4.Reg) & 0x60000000) >> 29
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_5_4_IE5_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_5_4.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_5_4_IE5_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_5_4.Reg) & 0x80000000) >> 31
}

// ADC_ETC.TRIG1_CHAIN_7_6: ETC_TRIG Chain 6/7 Register
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_7_6_CSEL6(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_7_6.Reg)&^(0xf)|value)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_7_6_CSEL6() uint32 {
	return volatile.LoadUint32(&o.TRIG1_CHAIN_7_6.Reg) & 0xf
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_7_6_HWTS6(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_7_6.Reg)&^(0xff0)|value<<4)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_7_6_HWTS6() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_7_6.Reg) & 0xff0) >> 4
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_7_6_B2B6(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_7_6.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_7_6_B2B6() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_7_6.Reg) & 0x1000) >> 12
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_7_6_IE6(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_7_6.Reg)&^(0x6000)|value<<13)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_7_6_IE6() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_7_6.Reg) & 0x6000) >> 13
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_7_6_IE6_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_7_6.Reg)&^(0x8000)|value<<15)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_7_6_IE6_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_7_6.Reg) & 0x8000) >> 15
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_7_6_CSEL7(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_7_6.Reg)&^(0xf0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_7_6_CSEL7() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_7_6.Reg) & 0xf0000) >> 16
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_7_6_HWTS7(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_7_6.Reg)&^(0xff00000)|value<<20)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_7_6_HWTS7() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_7_6.Reg) & 0xff00000) >> 20
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_7_6_B2B7(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_7_6.Reg)&^(0x10000000)|value<<28)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_7_6_B2B7() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_7_6.Reg) & 0x10000000) >> 28
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_7_6_IE7(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_7_6.Reg)&^(0x60000000)|value<<29)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_7_6_IE7() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_7_6.Reg) & 0x60000000) >> 29
}
func (o *ADC_ETC_Type) SetTRIG1_CHAIN_7_6_IE7_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG1_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG1_CHAIN_7_6.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_ETC_Type) GetTRIG1_CHAIN_7_6_IE7_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_CHAIN_7_6.Reg) & 0x80000000) >> 31
}

// ADC_ETC.TRIG1_RESULT_1_0: ETC_TRIG Result Data 1/0 Register
func (o *ADC_ETC_Type) SetTRIG1_RESULT_1_0_DATA0(value uint32) {
	volatile.StoreUint32(&o.TRIG1_RESULT_1_0.Reg, volatile.LoadUint32(&o.TRIG1_RESULT_1_0.Reg)&^(0xfff)|value)
}
func (o *ADC_ETC_Type) GetTRIG1_RESULT_1_0_DATA0() uint32 {
	return volatile.LoadUint32(&o.TRIG1_RESULT_1_0.Reg) & 0xfff
}
func (o *ADC_ETC_Type) SetTRIG1_RESULT_1_0_DATA1(value uint32) {
	volatile.StoreUint32(&o.TRIG1_RESULT_1_0.Reg, volatile.LoadUint32(&o.TRIG1_RESULT_1_0.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG1_RESULT_1_0_DATA1() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_RESULT_1_0.Reg) & 0xfff0000) >> 16
}

// ADC_ETC.TRIG1_RESULT_3_2: ETC_TRIG Result Data 3/2 Register
func (o *ADC_ETC_Type) SetTRIG1_RESULT_3_2_DATA2(value uint32) {
	volatile.StoreUint32(&o.TRIG1_RESULT_3_2.Reg, volatile.LoadUint32(&o.TRIG1_RESULT_3_2.Reg)&^(0xfff)|value)
}
func (o *ADC_ETC_Type) GetTRIG1_RESULT_3_2_DATA2() uint32 {
	return volatile.LoadUint32(&o.TRIG1_RESULT_3_2.Reg) & 0xfff
}
func (o *ADC_ETC_Type) SetTRIG1_RESULT_3_2_DATA3(value uint32) {
	volatile.StoreUint32(&o.TRIG1_RESULT_3_2.Reg, volatile.LoadUint32(&o.TRIG1_RESULT_3_2.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG1_RESULT_3_2_DATA3() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_RESULT_3_2.Reg) & 0xfff0000) >> 16
}

// ADC_ETC.TRIG1_RESULT_5_4: ETC_TRIG Result Data 5/4 Register
func (o *ADC_ETC_Type) SetTRIG1_RESULT_5_4_DATA4(value uint32) {
	volatile.StoreUint32(&o.TRIG1_RESULT_5_4.Reg, volatile.LoadUint32(&o.TRIG1_RESULT_5_4.Reg)&^(0xfff)|value)
}
func (o *ADC_ETC_Type) GetTRIG1_RESULT_5_4_DATA4() uint32 {
	return volatile.LoadUint32(&o.TRIG1_RESULT_5_4.Reg) & 0xfff
}
func (o *ADC_ETC_Type) SetTRIG1_RESULT_5_4_DATA5(value uint32) {
	volatile.StoreUint32(&o.TRIG1_RESULT_5_4.Reg, volatile.LoadUint32(&o.TRIG1_RESULT_5_4.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG1_RESULT_5_4_DATA5() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_RESULT_5_4.Reg) & 0xfff0000) >> 16
}

// ADC_ETC.TRIG1_RESULT_7_6: ETC_TRIG Result Data 7/6 Register
func (o *ADC_ETC_Type) SetTRIG1_RESULT_7_6_DATA6(value uint32) {
	volatile.StoreUint32(&o.TRIG1_RESULT_7_6.Reg, volatile.LoadUint32(&o.TRIG1_RESULT_7_6.Reg)&^(0xfff)|value)
}
func (o *ADC_ETC_Type) GetTRIG1_RESULT_7_6_DATA6() uint32 {
	return volatile.LoadUint32(&o.TRIG1_RESULT_7_6.Reg) & 0xfff
}
func (o *ADC_ETC_Type) SetTRIG1_RESULT_7_6_DATA7(value uint32) {
	volatile.StoreUint32(&o.TRIG1_RESULT_7_6.Reg, volatile.LoadUint32(&o.TRIG1_RESULT_7_6.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG1_RESULT_7_6_DATA7() uint32 {
	return (volatile.LoadUint32(&o.TRIG1_RESULT_7_6.Reg) & 0xfff0000) >> 16
}

// ADC_ETC.TRIG2_CTRL: ETC_TRIG Control Register
func (o *ADC_ETC_Type) SetTRIG2_CTRL_SW_TRIG(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CTRL.Reg, volatile.LoadUint32(&o.TRIG2_CTRL.Reg)&^(0x1)|value)
}
func (o *ADC_ETC_Type) GetTRIG2_CTRL_SW_TRIG() uint32 {
	return volatile.LoadUint32(&o.TRIG2_CTRL.Reg) & 0x1
}
func (o *ADC_ETC_Type) SetTRIG2_CTRL_TRIG_MODE(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CTRL.Reg, volatile.LoadUint32(&o.TRIG2_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *ADC_ETC_Type) GetTRIG2_CTRL_TRIG_MODE() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CTRL.Reg) & 0x10) >> 4
}
func (o *ADC_ETC_Type) SetTRIG2_CTRL_TRIG_CHAIN(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CTRL.Reg, volatile.LoadUint32(&o.TRIG2_CTRL.Reg)&^(0x700)|value<<8)
}
func (o *ADC_ETC_Type) GetTRIG2_CTRL_TRIG_CHAIN() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CTRL.Reg) & 0x700) >> 8
}
func (o *ADC_ETC_Type) SetTRIG2_CTRL_TRIG_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CTRL.Reg, volatile.LoadUint32(&o.TRIG2_CTRL.Reg)&^(0x7000)|value<<12)
}
func (o *ADC_ETC_Type) GetTRIG2_CTRL_TRIG_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CTRL.Reg) & 0x7000) >> 12
}
func (o *ADC_ETC_Type) SetTRIG2_CTRL_SYNC_MODE(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CTRL.Reg, volatile.LoadUint32(&o.TRIG2_CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG2_CTRL_SYNC_MODE() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CTRL.Reg) & 0x10000) >> 16
}
func (o *ADC_ETC_Type) SetTRIG2_CTRL_CHAINx_DONE(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CTRL.Reg, volatile.LoadUint32(&o.TRIG2_CTRL.Reg)&^(0xff000000)|value<<24)
}
func (o *ADC_ETC_Type) GetTRIG2_CTRL_CHAINx_DONE() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CTRL.Reg) & 0xff000000) >> 24
}

// ADC_ETC.TRIG2_COUNTER: ETC_TRIG Counter Register
func (o *ADC_ETC_Type) SetTRIG2_COUNTER_INIT_DELAY(value uint32) {
	volatile.StoreUint32(&o.TRIG2_COUNTER.Reg, volatile.LoadUint32(&o.TRIG2_COUNTER.Reg)&^(0xffff)|value)
}
func (o *ADC_ETC_Type) GetTRIG2_COUNTER_INIT_DELAY() uint32 {
	return volatile.LoadUint32(&o.TRIG2_COUNTER.Reg) & 0xffff
}
func (o *ADC_ETC_Type) SetTRIG2_COUNTER_SAMPLE_INTERVAL(value uint32) {
	volatile.StoreUint32(&o.TRIG2_COUNTER.Reg, volatile.LoadUint32(&o.TRIG2_COUNTER.Reg)&^(0xffff0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG2_COUNTER_SAMPLE_INTERVAL() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_COUNTER.Reg) & 0xffff0000) >> 16
}

// ADC_ETC.TRIG2_CHAIN_1_0: ETC_TRIG Chain 0/1 Register
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_1_0_CSEL0(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_1_0.Reg)&^(0xf)|value)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_1_0_CSEL0() uint32 {
	return volatile.LoadUint32(&o.TRIG2_CHAIN_1_0.Reg) & 0xf
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_1_0_HWTS0(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_1_0.Reg)&^(0xff0)|value<<4)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_1_0_HWTS0() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_1_0.Reg) & 0xff0) >> 4
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_1_0_B2B0(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_1_0.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_1_0_B2B0() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_1_0.Reg) & 0x1000) >> 12
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_1_0_IE0(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_1_0.Reg)&^(0x6000)|value<<13)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_1_0_IE0() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_1_0.Reg) & 0x6000) >> 13
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_1_0_IE0_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_1_0.Reg)&^(0x8000)|value<<15)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_1_0_IE0_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_1_0.Reg) & 0x8000) >> 15
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_1_0_CSEL1(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_1_0.Reg)&^(0xf0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_1_0_CSEL1() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_1_0.Reg) & 0xf0000) >> 16
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_1_0_HWTS1(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_1_0.Reg)&^(0xff00000)|value<<20)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_1_0_HWTS1() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_1_0.Reg) & 0xff00000) >> 20
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_1_0_B2B1(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_1_0.Reg)&^(0x10000000)|value<<28)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_1_0_B2B1() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_1_0.Reg) & 0x10000000) >> 28
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_1_0_IE1(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_1_0.Reg)&^(0x60000000)|value<<29)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_1_0_IE1() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_1_0.Reg) & 0x60000000) >> 29
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_1_0_IE1_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_1_0.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_1_0_IE1_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_1_0.Reg) & 0x80000000) >> 31
}

// ADC_ETC.TRIG2_CHAIN_3_2: ETC_TRIG Chain 2/3 Register
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_3_2_CSEL2(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_3_2.Reg)&^(0xf)|value)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_3_2_CSEL2() uint32 {
	return volatile.LoadUint32(&o.TRIG2_CHAIN_3_2.Reg) & 0xf
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_3_2_HWTS2(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_3_2.Reg)&^(0xff0)|value<<4)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_3_2_HWTS2() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_3_2.Reg) & 0xff0) >> 4
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_3_2_B2B2(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_3_2.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_3_2_B2B2() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_3_2.Reg) & 0x1000) >> 12
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_3_2_IE2(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_3_2.Reg)&^(0x6000)|value<<13)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_3_2_IE2() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_3_2.Reg) & 0x6000) >> 13
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_3_2_IE2_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_3_2.Reg)&^(0x8000)|value<<15)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_3_2_IE2_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_3_2.Reg) & 0x8000) >> 15
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_3_2_CSEL3(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_3_2.Reg)&^(0xf0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_3_2_CSEL3() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_3_2.Reg) & 0xf0000) >> 16
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_3_2_HWTS3(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_3_2.Reg)&^(0xff00000)|value<<20)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_3_2_HWTS3() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_3_2.Reg) & 0xff00000) >> 20
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_3_2_B2B3(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_3_2.Reg)&^(0x10000000)|value<<28)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_3_2_B2B3() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_3_2.Reg) & 0x10000000) >> 28
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_3_2_IE3(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_3_2.Reg)&^(0x60000000)|value<<29)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_3_2_IE3() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_3_2.Reg) & 0x60000000) >> 29
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_3_2_IE3_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_3_2.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_3_2_IE3_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_3_2.Reg) & 0x80000000) >> 31
}

// ADC_ETC.TRIG2_CHAIN_5_4: ETC_TRIG Chain 4/5 Register
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_5_4_CSEL4(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_5_4.Reg)&^(0xf)|value)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_5_4_CSEL4() uint32 {
	return volatile.LoadUint32(&o.TRIG2_CHAIN_5_4.Reg) & 0xf
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_5_4_HWTS4(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_5_4.Reg)&^(0xff0)|value<<4)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_5_4_HWTS4() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_5_4.Reg) & 0xff0) >> 4
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_5_4_B2B4(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_5_4.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_5_4_B2B4() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_5_4.Reg) & 0x1000) >> 12
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_5_4_IE4(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_5_4.Reg)&^(0x6000)|value<<13)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_5_4_IE4() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_5_4.Reg) & 0x6000) >> 13
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_5_4_IE4_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_5_4.Reg)&^(0x8000)|value<<15)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_5_4_IE4_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_5_4.Reg) & 0x8000) >> 15
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_5_4_CSEL5(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_5_4.Reg)&^(0xf0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_5_4_CSEL5() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_5_4.Reg) & 0xf0000) >> 16
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_5_4_HWTS5(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_5_4.Reg)&^(0xff00000)|value<<20)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_5_4_HWTS5() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_5_4.Reg) & 0xff00000) >> 20
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_5_4_B2B5(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_5_4.Reg)&^(0x10000000)|value<<28)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_5_4_B2B5() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_5_4.Reg) & 0x10000000) >> 28
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_5_4_IE5(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_5_4.Reg)&^(0x60000000)|value<<29)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_5_4_IE5() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_5_4.Reg) & 0x60000000) >> 29
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_5_4_IE5_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_5_4.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_5_4_IE5_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_5_4.Reg) & 0x80000000) >> 31
}

// ADC_ETC.TRIG2_CHAIN_7_6: ETC_TRIG Chain 6/7 Register
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_7_6_CSEL6(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_7_6.Reg)&^(0xf)|value)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_7_6_CSEL6() uint32 {
	return volatile.LoadUint32(&o.TRIG2_CHAIN_7_6.Reg) & 0xf
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_7_6_HWTS6(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_7_6.Reg)&^(0xff0)|value<<4)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_7_6_HWTS6() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_7_6.Reg) & 0xff0) >> 4
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_7_6_B2B6(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_7_6.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_7_6_B2B6() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_7_6.Reg) & 0x1000) >> 12
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_7_6_IE6(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_7_6.Reg)&^(0x6000)|value<<13)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_7_6_IE6() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_7_6.Reg) & 0x6000) >> 13
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_7_6_IE6_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_7_6.Reg)&^(0x8000)|value<<15)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_7_6_IE6_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_7_6.Reg) & 0x8000) >> 15
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_7_6_CSEL7(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_7_6.Reg)&^(0xf0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_7_6_CSEL7() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_7_6.Reg) & 0xf0000) >> 16
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_7_6_HWTS7(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_7_6.Reg)&^(0xff00000)|value<<20)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_7_6_HWTS7() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_7_6.Reg) & 0xff00000) >> 20
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_7_6_B2B7(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_7_6.Reg)&^(0x10000000)|value<<28)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_7_6_B2B7() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_7_6.Reg) & 0x10000000) >> 28
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_7_6_IE7(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_7_6.Reg)&^(0x60000000)|value<<29)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_7_6_IE7() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_7_6.Reg) & 0x60000000) >> 29
}
func (o *ADC_ETC_Type) SetTRIG2_CHAIN_7_6_IE7_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG2_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG2_CHAIN_7_6.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_ETC_Type) GetTRIG2_CHAIN_7_6_IE7_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_CHAIN_7_6.Reg) & 0x80000000) >> 31
}

// ADC_ETC.TRIG2_RESULT_1_0: ETC_TRIG Result Data 1/0 Register
func (o *ADC_ETC_Type) SetTRIG2_RESULT_1_0_DATA0(value uint32) {
	volatile.StoreUint32(&o.TRIG2_RESULT_1_0.Reg, volatile.LoadUint32(&o.TRIG2_RESULT_1_0.Reg)&^(0xfff)|value)
}
func (o *ADC_ETC_Type) GetTRIG2_RESULT_1_0_DATA0() uint32 {
	return volatile.LoadUint32(&o.TRIG2_RESULT_1_0.Reg) & 0xfff
}
func (o *ADC_ETC_Type) SetTRIG2_RESULT_1_0_DATA1(value uint32) {
	volatile.StoreUint32(&o.TRIG2_RESULT_1_0.Reg, volatile.LoadUint32(&o.TRIG2_RESULT_1_0.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG2_RESULT_1_0_DATA1() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_RESULT_1_0.Reg) & 0xfff0000) >> 16
}

// ADC_ETC.TRIG2_RESULT_3_2: ETC_TRIG Result Data 3/2 Register
func (o *ADC_ETC_Type) SetTRIG2_RESULT_3_2_DATA2(value uint32) {
	volatile.StoreUint32(&o.TRIG2_RESULT_3_2.Reg, volatile.LoadUint32(&o.TRIG2_RESULT_3_2.Reg)&^(0xfff)|value)
}
func (o *ADC_ETC_Type) GetTRIG2_RESULT_3_2_DATA2() uint32 {
	return volatile.LoadUint32(&o.TRIG2_RESULT_3_2.Reg) & 0xfff
}
func (o *ADC_ETC_Type) SetTRIG2_RESULT_3_2_DATA3(value uint32) {
	volatile.StoreUint32(&o.TRIG2_RESULT_3_2.Reg, volatile.LoadUint32(&o.TRIG2_RESULT_3_2.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG2_RESULT_3_2_DATA3() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_RESULT_3_2.Reg) & 0xfff0000) >> 16
}

// ADC_ETC.TRIG2_RESULT_5_4: ETC_TRIG Result Data 5/4 Register
func (o *ADC_ETC_Type) SetTRIG2_RESULT_5_4_DATA4(value uint32) {
	volatile.StoreUint32(&o.TRIG2_RESULT_5_4.Reg, volatile.LoadUint32(&o.TRIG2_RESULT_5_4.Reg)&^(0xfff)|value)
}
func (o *ADC_ETC_Type) GetTRIG2_RESULT_5_4_DATA4() uint32 {
	return volatile.LoadUint32(&o.TRIG2_RESULT_5_4.Reg) & 0xfff
}
func (o *ADC_ETC_Type) SetTRIG2_RESULT_5_4_DATA5(value uint32) {
	volatile.StoreUint32(&o.TRIG2_RESULT_5_4.Reg, volatile.LoadUint32(&o.TRIG2_RESULT_5_4.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG2_RESULT_5_4_DATA5() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_RESULT_5_4.Reg) & 0xfff0000) >> 16
}

// ADC_ETC.TRIG2_RESULT_7_6: ETC_TRIG Result Data 7/6 Register
func (o *ADC_ETC_Type) SetTRIG2_RESULT_7_6_DATA6(value uint32) {
	volatile.StoreUint32(&o.TRIG2_RESULT_7_6.Reg, volatile.LoadUint32(&o.TRIG2_RESULT_7_6.Reg)&^(0xfff)|value)
}
func (o *ADC_ETC_Type) GetTRIG2_RESULT_7_6_DATA6() uint32 {
	return volatile.LoadUint32(&o.TRIG2_RESULT_7_6.Reg) & 0xfff
}
func (o *ADC_ETC_Type) SetTRIG2_RESULT_7_6_DATA7(value uint32) {
	volatile.StoreUint32(&o.TRIG2_RESULT_7_6.Reg, volatile.LoadUint32(&o.TRIG2_RESULT_7_6.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG2_RESULT_7_6_DATA7() uint32 {
	return (volatile.LoadUint32(&o.TRIG2_RESULT_7_6.Reg) & 0xfff0000) >> 16
}

// ADC_ETC.TRIG3_CTRL: ETC_TRIG Control Register
func (o *ADC_ETC_Type) SetTRIG3_CTRL_SW_TRIG(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CTRL.Reg, volatile.LoadUint32(&o.TRIG3_CTRL.Reg)&^(0x1)|value)
}
func (o *ADC_ETC_Type) GetTRIG3_CTRL_SW_TRIG() uint32 {
	return volatile.LoadUint32(&o.TRIG3_CTRL.Reg) & 0x1
}
func (o *ADC_ETC_Type) SetTRIG3_CTRL_TRIG_MODE(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CTRL.Reg, volatile.LoadUint32(&o.TRIG3_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *ADC_ETC_Type) GetTRIG3_CTRL_TRIG_MODE() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CTRL.Reg) & 0x10) >> 4
}
func (o *ADC_ETC_Type) SetTRIG3_CTRL_TRIG_CHAIN(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CTRL.Reg, volatile.LoadUint32(&o.TRIG3_CTRL.Reg)&^(0x700)|value<<8)
}
func (o *ADC_ETC_Type) GetTRIG3_CTRL_TRIG_CHAIN() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CTRL.Reg) & 0x700) >> 8
}
func (o *ADC_ETC_Type) SetTRIG3_CTRL_TRIG_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CTRL.Reg, volatile.LoadUint32(&o.TRIG3_CTRL.Reg)&^(0x7000)|value<<12)
}
func (o *ADC_ETC_Type) GetTRIG3_CTRL_TRIG_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CTRL.Reg) & 0x7000) >> 12
}
func (o *ADC_ETC_Type) SetTRIG3_CTRL_SYNC_MODE(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CTRL.Reg, volatile.LoadUint32(&o.TRIG3_CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG3_CTRL_SYNC_MODE() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CTRL.Reg) & 0x10000) >> 16
}
func (o *ADC_ETC_Type) SetTRIG3_CTRL_CHAINx_DONE(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CTRL.Reg, volatile.LoadUint32(&o.TRIG3_CTRL.Reg)&^(0xff000000)|value<<24)
}
func (o *ADC_ETC_Type) GetTRIG3_CTRL_CHAINx_DONE() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CTRL.Reg) & 0xff000000) >> 24
}

// ADC_ETC.TRIG3_COUNTER: ETC_TRIG Counter Register
func (o *ADC_ETC_Type) SetTRIG3_COUNTER_INIT_DELAY(value uint32) {
	volatile.StoreUint32(&o.TRIG3_COUNTER.Reg, volatile.LoadUint32(&o.TRIG3_COUNTER.Reg)&^(0xffff)|value)
}
func (o *ADC_ETC_Type) GetTRIG3_COUNTER_INIT_DELAY() uint32 {
	return volatile.LoadUint32(&o.TRIG3_COUNTER.Reg) & 0xffff
}
func (o *ADC_ETC_Type) SetTRIG3_COUNTER_SAMPLE_INTERVAL(value uint32) {
	volatile.StoreUint32(&o.TRIG3_COUNTER.Reg, volatile.LoadUint32(&o.TRIG3_COUNTER.Reg)&^(0xffff0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG3_COUNTER_SAMPLE_INTERVAL() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_COUNTER.Reg) & 0xffff0000) >> 16
}

// ADC_ETC.TRIG3_CHAIN_1_0: ETC_TRIG Chain 0/1 Register
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_1_0_CSEL0(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_1_0.Reg)&^(0xf)|value)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_1_0_CSEL0() uint32 {
	return volatile.LoadUint32(&o.TRIG3_CHAIN_1_0.Reg) & 0xf
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_1_0_HWTS0(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_1_0.Reg)&^(0xff0)|value<<4)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_1_0_HWTS0() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_1_0.Reg) & 0xff0) >> 4
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_1_0_B2B0(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_1_0.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_1_0_B2B0() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_1_0.Reg) & 0x1000) >> 12
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_1_0_IE0(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_1_0.Reg)&^(0x6000)|value<<13)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_1_0_IE0() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_1_0.Reg) & 0x6000) >> 13
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_1_0_IE0_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_1_0.Reg)&^(0x8000)|value<<15)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_1_0_IE0_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_1_0.Reg) & 0x8000) >> 15
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_1_0_CSEL1(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_1_0.Reg)&^(0xf0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_1_0_CSEL1() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_1_0.Reg) & 0xf0000) >> 16
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_1_0_HWTS1(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_1_0.Reg)&^(0xff00000)|value<<20)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_1_0_HWTS1() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_1_0.Reg) & 0xff00000) >> 20
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_1_0_B2B1(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_1_0.Reg)&^(0x10000000)|value<<28)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_1_0_B2B1() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_1_0.Reg) & 0x10000000) >> 28
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_1_0_IE1(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_1_0.Reg)&^(0x60000000)|value<<29)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_1_0_IE1() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_1_0.Reg) & 0x60000000) >> 29
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_1_0_IE1_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_1_0.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_1_0.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_1_0_IE1_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_1_0.Reg) & 0x80000000) >> 31
}

// ADC_ETC.TRIG3_CHAIN_3_2: ETC_TRIG Chain 2/3 Register
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_3_2_CSEL2(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_3_2.Reg)&^(0xf)|value)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_3_2_CSEL2() uint32 {
	return volatile.LoadUint32(&o.TRIG3_CHAIN_3_2.Reg) & 0xf
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_3_2_HWTS2(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_3_2.Reg)&^(0xff0)|value<<4)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_3_2_HWTS2() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_3_2.Reg) & 0xff0) >> 4
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_3_2_B2B2(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_3_2.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_3_2_B2B2() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_3_2.Reg) & 0x1000) >> 12
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_3_2_IE2(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_3_2.Reg)&^(0x6000)|value<<13)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_3_2_IE2() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_3_2.Reg) & 0x6000) >> 13
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_3_2_IE2_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_3_2.Reg)&^(0x8000)|value<<15)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_3_2_IE2_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_3_2.Reg) & 0x8000) >> 15
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_3_2_CSEL3(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_3_2.Reg)&^(0xf0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_3_2_CSEL3() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_3_2.Reg) & 0xf0000) >> 16
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_3_2_HWTS3(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_3_2.Reg)&^(0xff00000)|value<<20)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_3_2_HWTS3() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_3_2.Reg) & 0xff00000) >> 20
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_3_2_B2B3(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_3_2.Reg)&^(0x10000000)|value<<28)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_3_2_B2B3() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_3_2.Reg) & 0x10000000) >> 28
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_3_2_IE3(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_3_2.Reg)&^(0x60000000)|value<<29)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_3_2_IE3() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_3_2.Reg) & 0x60000000) >> 29
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_3_2_IE3_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_3_2.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_3_2.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_3_2_IE3_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_3_2.Reg) & 0x80000000) >> 31
}

// ADC_ETC.TRIG3_CHAIN_5_4: ETC_TRIG Chain 4/5 Register
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_5_4_CSEL4(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_5_4.Reg)&^(0xf)|value)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_5_4_CSEL4() uint32 {
	return volatile.LoadUint32(&o.TRIG3_CHAIN_5_4.Reg) & 0xf
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_5_4_HWTS4(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_5_4.Reg)&^(0xff0)|value<<4)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_5_4_HWTS4() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_5_4.Reg) & 0xff0) >> 4
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_5_4_B2B4(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_5_4.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_5_4_B2B4() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_5_4.Reg) & 0x1000) >> 12
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_5_4_IE4(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_5_4.Reg)&^(0x6000)|value<<13)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_5_4_IE4() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_5_4.Reg) & 0x6000) >> 13
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_5_4_IE4_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_5_4.Reg)&^(0x8000)|value<<15)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_5_4_IE4_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_5_4.Reg) & 0x8000) >> 15
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_5_4_CSEL5(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_5_4.Reg)&^(0xf0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_5_4_CSEL5() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_5_4.Reg) & 0xf0000) >> 16
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_5_4_HWTS5(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_5_4.Reg)&^(0xff00000)|value<<20)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_5_4_HWTS5() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_5_4.Reg) & 0xff00000) >> 20
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_5_4_B2B5(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_5_4.Reg)&^(0x10000000)|value<<28)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_5_4_B2B5() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_5_4.Reg) & 0x10000000) >> 28
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_5_4_IE5(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_5_4.Reg)&^(0x60000000)|value<<29)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_5_4_IE5() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_5_4.Reg) & 0x60000000) >> 29
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_5_4_IE5_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_5_4.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_5_4.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_5_4_IE5_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_5_4.Reg) & 0x80000000) >> 31
}

// ADC_ETC.TRIG3_CHAIN_7_6: ETC_TRIG Chain 6/7 Register
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_7_6_CSEL6(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_7_6.Reg)&^(0xf)|value)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_7_6_CSEL6() uint32 {
	return volatile.LoadUint32(&o.TRIG3_CHAIN_7_6.Reg) & 0xf
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_7_6_HWTS6(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_7_6.Reg)&^(0xff0)|value<<4)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_7_6_HWTS6() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_7_6.Reg) & 0xff0) >> 4
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_7_6_B2B6(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_7_6.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_7_6_B2B6() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_7_6.Reg) & 0x1000) >> 12
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_7_6_IE6(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_7_6.Reg)&^(0x6000)|value<<13)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_7_6_IE6() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_7_6.Reg) & 0x6000) >> 13
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_7_6_IE6_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_7_6.Reg)&^(0x8000)|value<<15)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_7_6_IE6_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_7_6.Reg) & 0x8000) >> 15
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_7_6_CSEL7(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_7_6.Reg)&^(0xf0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_7_6_CSEL7() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_7_6.Reg) & 0xf0000) >> 16
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_7_6_HWTS7(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_7_6.Reg)&^(0xff00000)|value<<20)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_7_6_HWTS7() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_7_6.Reg) & 0xff00000) >> 20
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_7_6_B2B7(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_7_6.Reg)&^(0x10000000)|value<<28)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_7_6_B2B7() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_7_6.Reg) & 0x10000000) >> 28
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_7_6_IE7(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_7_6.Reg)&^(0x60000000)|value<<29)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_7_6_IE7() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_7_6.Reg) & 0x60000000) >> 29
}
func (o *ADC_ETC_Type) SetTRIG3_CHAIN_7_6_IE7_EN(value uint32) {
	volatile.StoreUint32(&o.TRIG3_CHAIN_7_6.Reg, volatile.LoadUint32(&o.TRIG3_CHAIN_7_6.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_ETC_Type) GetTRIG3_CHAIN_7_6_IE7_EN() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_CHAIN_7_6.Reg) & 0x80000000) >> 31
}

// ADC_ETC.TRIG3_RESULT_1_0: ETC_TRIG Result Data 1/0 Register
func (o *ADC_ETC_Type) SetTRIG3_RESULT_1_0_DATA0(value uint32) {
	volatile.StoreUint32(&o.TRIG3_RESULT_1_0.Reg, volatile.LoadUint32(&o.TRIG3_RESULT_1_0.Reg)&^(0xfff)|value)
}
func (o *ADC_ETC_Type) GetTRIG3_RESULT_1_0_DATA0() uint32 {
	return volatile.LoadUint32(&o.TRIG3_RESULT_1_0.Reg) & 0xfff
}
func (o *ADC_ETC_Type) SetTRIG3_RESULT_1_0_DATA1(value uint32) {
	volatile.StoreUint32(&o.TRIG3_RESULT_1_0.Reg, volatile.LoadUint32(&o.TRIG3_RESULT_1_0.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG3_RESULT_1_0_DATA1() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_RESULT_1_0.Reg) & 0xfff0000) >> 16
}

// ADC_ETC.TRIG3_RESULT_3_2: ETC_TRIG Result Data 3/2 Register
func (o *ADC_ETC_Type) SetTRIG3_RESULT_3_2_DATA2(value uint32) {
	volatile.StoreUint32(&o.TRIG3_RESULT_3_2.Reg, volatile.LoadUint32(&o.TRIG3_RESULT_3_2.Reg)&^(0xfff)|value)
}
func (o *ADC_ETC_Type) GetTRIG3_RESULT_3_2_DATA2() uint32 {
	return volatile.LoadUint32(&o.TRIG3_RESULT_3_2.Reg) & 0xfff
}
func (o *ADC_ETC_Type) SetTRIG3_RESULT_3_2_DATA3(value uint32) {
	volatile.StoreUint32(&o.TRIG3_RESULT_3_2.Reg, volatile.LoadUint32(&o.TRIG3_RESULT_3_2.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG3_RESULT_3_2_DATA3() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_RESULT_3_2.Reg) & 0xfff0000) >> 16
}

// ADC_ETC.TRIG3_RESULT_5_4: ETC_TRIG Result Data 5/4 Register
func (o *ADC_ETC_Type) SetTRIG3_RESULT_5_4_DATA4(value uint32) {
	volatile.StoreUint32(&o.TRIG3_RESULT_5_4.Reg, volatile.LoadUint32(&o.TRIG3_RESULT_5_4.Reg)&^(0xfff)|value)
}
func (o *ADC_ETC_Type) GetTRIG3_RESULT_5_4_DATA4() uint32 {
	return volatile.LoadUint32(&o.TRIG3_RESULT_5_4.Reg) & 0xfff
}
func (o *ADC_ETC_Type) SetTRIG3_RESULT_5_4_DATA5(value uint32) {
	volatile.StoreUint32(&o.TRIG3_RESULT_5_4.Reg, volatile.LoadUint32(&o.TRIG3_RESULT_5_4.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG3_RESULT_5_4_DATA5() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_RESULT_5_4.Reg) & 0xfff0000) >> 16
}

// ADC_ETC.TRIG3_RESULT_7_6: ETC_TRIG Result Data 7/6 Register
func (o *ADC_ETC_Type) SetTRIG3_RESULT_7_6_DATA6(value uint32) {
	volatile.StoreUint32(&o.TRIG3_RESULT_7_6.Reg, volatile.LoadUint32(&o.TRIG3_RESULT_7_6.Reg)&^(0xfff)|value)
}
func (o *ADC_ETC_Type) GetTRIG3_RESULT_7_6_DATA6() uint32 {
	return volatile.LoadUint32(&o.TRIG3_RESULT_7_6.Reg) & 0xfff
}
func (o *ADC_ETC_Type) SetTRIG3_RESULT_7_6_DATA7(value uint32) {
	volatile.StoreUint32(&o.TRIG3_RESULT_7_6.Reg, volatile.LoadUint32(&o.TRIG3_RESULT_7_6.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_ETC_Type) GetTRIG3_RESULT_7_6_DATA7() uint32 {
	return (volatile.LoadUint32(&o.TRIG3_RESULT_7_6.Reg) & 0xfff0000) >> 16
}

// AND/OR/INVERT module
type AOI_Type struct {
	BFCRT010 volatile.Register16 // 0x0
	BFCRT230 volatile.Register16 // 0x2
	BFCRT011 volatile.Register16 // 0x4
	BFCRT231 volatile.Register16 // 0x6
	BFCRT012 volatile.Register16 // 0x8
	BFCRT232 volatile.Register16 // 0xA
	BFCRT013 volatile.Register16 // 0xC
	BFCRT233 volatile.Register16 // 0xE
}

// AOI.BFCRT010: Boolean Function Term 0 and 1 Configuration Register for EVENTn
func (o *AOI_Type) SetBFCRT010_PT1_DC(value uint16) {
	volatile.StoreUint16(&o.BFCRT010.Reg, volatile.LoadUint16(&o.BFCRT010.Reg)&^(0x3)|value)
}
func (o *AOI_Type) GetBFCRT010_PT1_DC() uint16 {
	return volatile.LoadUint16(&o.BFCRT010.Reg) & 0x3
}
func (o *AOI_Type) SetBFCRT010_PT1_CC(value uint16) {
	volatile.StoreUint16(&o.BFCRT010.Reg, volatile.LoadUint16(&o.BFCRT010.Reg)&^(0xc)|value<<2)
}
func (o *AOI_Type) GetBFCRT010_PT1_CC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT010.Reg) & 0xc) >> 2
}
func (o *AOI_Type) SetBFCRT010_PT1_BC(value uint16) {
	volatile.StoreUint16(&o.BFCRT010.Reg, volatile.LoadUint16(&o.BFCRT010.Reg)&^(0x30)|value<<4)
}
func (o *AOI_Type) GetBFCRT010_PT1_BC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT010.Reg) & 0x30) >> 4
}
func (o *AOI_Type) SetBFCRT010_PT1_AC(value uint16) {
	volatile.StoreUint16(&o.BFCRT010.Reg, volatile.LoadUint16(&o.BFCRT010.Reg)&^(0xc0)|value<<6)
}
func (o *AOI_Type) GetBFCRT010_PT1_AC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT010.Reg) & 0xc0) >> 6
}
func (o *AOI_Type) SetBFCRT010_PT0_DC(value uint16) {
	volatile.StoreUint16(&o.BFCRT010.Reg, volatile.LoadUint16(&o.BFCRT010.Reg)&^(0x300)|value<<8)
}
func (o *AOI_Type) GetBFCRT010_PT0_DC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT010.Reg) & 0x300) >> 8
}
func (o *AOI_Type) SetBFCRT010_PT0_CC(value uint16) {
	volatile.StoreUint16(&o.BFCRT010.Reg, volatile.LoadUint16(&o.BFCRT010.Reg)&^(0xc00)|value<<10)
}
func (o *AOI_Type) GetBFCRT010_PT0_CC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT010.Reg) & 0xc00) >> 10
}
func (o *AOI_Type) SetBFCRT010_PT0_BC(value uint16) {
	volatile.StoreUint16(&o.BFCRT010.Reg, volatile.LoadUint16(&o.BFCRT010.Reg)&^(0x3000)|value<<12)
}
func (o *AOI_Type) GetBFCRT010_PT0_BC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT010.Reg) & 0x3000) >> 12
}
func (o *AOI_Type) SetBFCRT010_PT0_AC(value uint16) {
	volatile.StoreUint16(&o.BFCRT010.Reg, volatile.LoadUint16(&o.BFCRT010.Reg)&^(0xc000)|value<<14)
}
func (o *AOI_Type) GetBFCRT010_PT0_AC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT010.Reg) & 0xc000) >> 14
}

// AOI.BFCRT230: Boolean Function Term 2 and 3 Configuration Register for EVENTn
func (o *AOI_Type) SetBFCRT230_PT3_DC(value uint16) {
	volatile.StoreUint16(&o.BFCRT230.Reg, volatile.LoadUint16(&o.BFCRT230.Reg)&^(0x3)|value)
}
func (o *AOI_Type) GetBFCRT230_PT3_DC() uint16 {
	return volatile.LoadUint16(&o.BFCRT230.Reg) & 0x3
}
func (o *AOI_Type) SetBFCRT230_PT3_CC(value uint16) {
	volatile.StoreUint16(&o.BFCRT230.Reg, volatile.LoadUint16(&o.BFCRT230.Reg)&^(0xc)|value<<2)
}
func (o *AOI_Type) GetBFCRT230_PT3_CC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT230.Reg) & 0xc) >> 2
}
func (o *AOI_Type) SetBFCRT230_PT3_BC(value uint16) {
	volatile.StoreUint16(&o.BFCRT230.Reg, volatile.LoadUint16(&o.BFCRT230.Reg)&^(0x30)|value<<4)
}
func (o *AOI_Type) GetBFCRT230_PT3_BC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT230.Reg) & 0x30) >> 4
}
func (o *AOI_Type) SetBFCRT230_PT3_AC(value uint16) {
	volatile.StoreUint16(&o.BFCRT230.Reg, volatile.LoadUint16(&o.BFCRT230.Reg)&^(0xc0)|value<<6)
}
func (o *AOI_Type) GetBFCRT230_PT3_AC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT230.Reg) & 0xc0) >> 6
}
func (o *AOI_Type) SetBFCRT230_PT2_DC(value uint16) {
	volatile.StoreUint16(&o.BFCRT230.Reg, volatile.LoadUint16(&o.BFCRT230.Reg)&^(0x300)|value<<8)
}
func (o *AOI_Type) GetBFCRT230_PT2_DC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT230.Reg) & 0x300) >> 8
}
func (o *AOI_Type) SetBFCRT230_PT2_CC(value uint16) {
	volatile.StoreUint16(&o.BFCRT230.Reg, volatile.LoadUint16(&o.BFCRT230.Reg)&^(0xc00)|value<<10)
}
func (o *AOI_Type) GetBFCRT230_PT2_CC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT230.Reg) & 0xc00) >> 10
}
func (o *AOI_Type) SetBFCRT230_PT2_BC(value uint16) {
	volatile.StoreUint16(&o.BFCRT230.Reg, volatile.LoadUint16(&o.BFCRT230.Reg)&^(0x3000)|value<<12)
}
func (o *AOI_Type) GetBFCRT230_PT2_BC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT230.Reg) & 0x3000) >> 12
}
func (o *AOI_Type) SetBFCRT230_PT2_AC(value uint16) {
	volatile.StoreUint16(&o.BFCRT230.Reg, volatile.LoadUint16(&o.BFCRT230.Reg)&^(0xc000)|value<<14)
}
func (o *AOI_Type) GetBFCRT230_PT2_AC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT230.Reg) & 0xc000) >> 14
}

// AOI.BFCRT011: Boolean Function Term 0 and 1 Configuration Register for EVENTn
func (o *AOI_Type) SetBFCRT011_PT1_DC(value uint16) {
	volatile.StoreUint16(&o.BFCRT011.Reg, volatile.LoadUint16(&o.BFCRT011.Reg)&^(0x3)|value)
}
func (o *AOI_Type) GetBFCRT011_PT1_DC() uint16 {
	return volatile.LoadUint16(&o.BFCRT011.Reg) & 0x3
}
func (o *AOI_Type) SetBFCRT011_PT1_CC(value uint16) {
	volatile.StoreUint16(&o.BFCRT011.Reg, volatile.LoadUint16(&o.BFCRT011.Reg)&^(0xc)|value<<2)
}
func (o *AOI_Type) GetBFCRT011_PT1_CC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT011.Reg) & 0xc) >> 2
}
func (o *AOI_Type) SetBFCRT011_PT1_BC(value uint16) {
	volatile.StoreUint16(&o.BFCRT011.Reg, volatile.LoadUint16(&o.BFCRT011.Reg)&^(0x30)|value<<4)
}
func (o *AOI_Type) GetBFCRT011_PT1_BC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT011.Reg) & 0x30) >> 4
}
func (o *AOI_Type) SetBFCRT011_PT1_AC(value uint16) {
	volatile.StoreUint16(&o.BFCRT011.Reg, volatile.LoadUint16(&o.BFCRT011.Reg)&^(0xc0)|value<<6)
}
func (o *AOI_Type) GetBFCRT011_PT1_AC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT011.Reg) & 0xc0) >> 6
}
func (o *AOI_Type) SetBFCRT011_PT0_DC(value uint16) {
	volatile.StoreUint16(&o.BFCRT011.Reg, volatile.LoadUint16(&o.BFCRT011.Reg)&^(0x300)|value<<8)
}
func (o *AOI_Type) GetBFCRT011_PT0_DC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT011.Reg) & 0x300) >> 8
}
func (o *AOI_Type) SetBFCRT011_PT0_CC(value uint16) {
	volatile.StoreUint16(&o.BFCRT011.Reg, volatile.LoadUint16(&o.BFCRT011.Reg)&^(0xc00)|value<<10)
}
func (o *AOI_Type) GetBFCRT011_PT0_CC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT011.Reg) & 0xc00) >> 10
}
func (o *AOI_Type) SetBFCRT011_PT0_BC(value uint16) {
	volatile.StoreUint16(&o.BFCRT011.Reg, volatile.LoadUint16(&o.BFCRT011.Reg)&^(0x3000)|value<<12)
}
func (o *AOI_Type) GetBFCRT011_PT0_BC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT011.Reg) & 0x3000) >> 12
}
func (o *AOI_Type) SetBFCRT011_PT0_AC(value uint16) {
	volatile.StoreUint16(&o.BFCRT011.Reg, volatile.LoadUint16(&o.BFCRT011.Reg)&^(0xc000)|value<<14)
}
func (o *AOI_Type) GetBFCRT011_PT0_AC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT011.Reg) & 0xc000) >> 14
}

// AOI.BFCRT231: Boolean Function Term 2 and 3 Configuration Register for EVENTn
func (o *AOI_Type) SetBFCRT231_PT3_DC(value uint16) {
	volatile.StoreUint16(&o.BFCRT231.Reg, volatile.LoadUint16(&o.BFCRT231.Reg)&^(0x3)|value)
}
func (o *AOI_Type) GetBFCRT231_PT3_DC() uint16 {
	return volatile.LoadUint16(&o.BFCRT231.Reg) & 0x3
}
func (o *AOI_Type) SetBFCRT231_PT3_CC(value uint16) {
	volatile.StoreUint16(&o.BFCRT231.Reg, volatile.LoadUint16(&o.BFCRT231.Reg)&^(0xc)|value<<2)
}
func (o *AOI_Type) GetBFCRT231_PT3_CC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT231.Reg) & 0xc) >> 2
}
func (o *AOI_Type) SetBFCRT231_PT3_BC(value uint16) {
	volatile.StoreUint16(&o.BFCRT231.Reg, volatile.LoadUint16(&o.BFCRT231.Reg)&^(0x30)|value<<4)
}
func (o *AOI_Type) GetBFCRT231_PT3_BC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT231.Reg) & 0x30) >> 4
}
func (o *AOI_Type) SetBFCRT231_PT3_AC(value uint16) {
	volatile.StoreUint16(&o.BFCRT231.Reg, volatile.LoadUint16(&o.BFCRT231.Reg)&^(0xc0)|value<<6)
}
func (o *AOI_Type) GetBFCRT231_PT3_AC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT231.Reg) & 0xc0) >> 6
}
func (o *AOI_Type) SetBFCRT231_PT2_DC(value uint16) {
	volatile.StoreUint16(&o.BFCRT231.Reg, volatile.LoadUint16(&o.BFCRT231.Reg)&^(0x300)|value<<8)
}
func (o *AOI_Type) GetBFCRT231_PT2_DC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT231.Reg) & 0x300) >> 8
}
func (o *AOI_Type) SetBFCRT231_PT2_CC(value uint16) {
	volatile.StoreUint16(&o.BFCRT231.Reg, volatile.LoadUint16(&o.BFCRT231.Reg)&^(0xc00)|value<<10)
}
func (o *AOI_Type) GetBFCRT231_PT2_CC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT231.Reg) & 0xc00) >> 10
}
func (o *AOI_Type) SetBFCRT231_PT2_BC(value uint16) {
	volatile.StoreUint16(&o.BFCRT231.Reg, volatile.LoadUint16(&o.BFCRT231.Reg)&^(0x3000)|value<<12)
}
func (o *AOI_Type) GetBFCRT231_PT2_BC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT231.Reg) & 0x3000) >> 12
}
func (o *AOI_Type) SetBFCRT231_PT2_AC(value uint16) {
	volatile.StoreUint16(&o.BFCRT231.Reg, volatile.LoadUint16(&o.BFCRT231.Reg)&^(0xc000)|value<<14)
}
func (o *AOI_Type) GetBFCRT231_PT2_AC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT231.Reg) & 0xc000) >> 14
}

// AOI.BFCRT012: Boolean Function Term 0 and 1 Configuration Register for EVENTn
func (o *AOI_Type) SetBFCRT012_PT1_DC(value uint16) {
	volatile.StoreUint16(&o.BFCRT012.Reg, volatile.LoadUint16(&o.BFCRT012.Reg)&^(0x3)|value)
}
func (o *AOI_Type) GetBFCRT012_PT1_DC() uint16 {
	return volatile.LoadUint16(&o.BFCRT012.Reg) & 0x3
}
func (o *AOI_Type) SetBFCRT012_PT1_CC(value uint16) {
	volatile.StoreUint16(&o.BFCRT012.Reg, volatile.LoadUint16(&o.BFCRT012.Reg)&^(0xc)|value<<2)
}
func (o *AOI_Type) GetBFCRT012_PT1_CC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT012.Reg) & 0xc) >> 2
}
func (o *AOI_Type) SetBFCRT012_PT1_BC(value uint16) {
	volatile.StoreUint16(&o.BFCRT012.Reg, volatile.LoadUint16(&o.BFCRT012.Reg)&^(0x30)|value<<4)
}
func (o *AOI_Type) GetBFCRT012_PT1_BC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT012.Reg) & 0x30) >> 4
}
func (o *AOI_Type) SetBFCRT012_PT1_AC(value uint16) {
	volatile.StoreUint16(&o.BFCRT012.Reg, volatile.LoadUint16(&o.BFCRT012.Reg)&^(0xc0)|value<<6)
}
func (o *AOI_Type) GetBFCRT012_PT1_AC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT012.Reg) & 0xc0) >> 6
}
func (o *AOI_Type) SetBFCRT012_PT0_DC(value uint16) {
	volatile.StoreUint16(&o.BFCRT012.Reg, volatile.LoadUint16(&o.BFCRT012.Reg)&^(0x300)|value<<8)
}
func (o *AOI_Type) GetBFCRT012_PT0_DC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT012.Reg) & 0x300) >> 8
}
func (o *AOI_Type) SetBFCRT012_PT0_CC(value uint16) {
	volatile.StoreUint16(&o.BFCRT012.Reg, volatile.LoadUint16(&o.BFCRT012.Reg)&^(0xc00)|value<<10)
}
func (o *AOI_Type) GetBFCRT012_PT0_CC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT012.Reg) & 0xc00) >> 10
}
func (o *AOI_Type) SetBFCRT012_PT0_BC(value uint16) {
	volatile.StoreUint16(&o.BFCRT012.Reg, volatile.LoadUint16(&o.BFCRT012.Reg)&^(0x3000)|value<<12)
}
func (o *AOI_Type) GetBFCRT012_PT0_BC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT012.Reg) & 0x3000) >> 12
}
func (o *AOI_Type) SetBFCRT012_PT0_AC(value uint16) {
	volatile.StoreUint16(&o.BFCRT012.Reg, volatile.LoadUint16(&o.BFCRT012.Reg)&^(0xc000)|value<<14)
}
func (o *AOI_Type) GetBFCRT012_PT0_AC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT012.Reg) & 0xc000) >> 14
}

// AOI.BFCRT232: Boolean Function Term 2 and 3 Configuration Register for EVENTn
func (o *AOI_Type) SetBFCRT232_PT3_DC(value uint16) {
	volatile.StoreUint16(&o.BFCRT232.Reg, volatile.LoadUint16(&o.BFCRT232.Reg)&^(0x3)|value)
}
func (o *AOI_Type) GetBFCRT232_PT3_DC() uint16 {
	return volatile.LoadUint16(&o.BFCRT232.Reg) & 0x3
}
func (o *AOI_Type) SetBFCRT232_PT3_CC(value uint16) {
	volatile.StoreUint16(&o.BFCRT232.Reg, volatile.LoadUint16(&o.BFCRT232.Reg)&^(0xc)|value<<2)
}
func (o *AOI_Type) GetBFCRT232_PT3_CC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT232.Reg) & 0xc) >> 2
}
func (o *AOI_Type) SetBFCRT232_PT3_BC(value uint16) {
	volatile.StoreUint16(&o.BFCRT232.Reg, volatile.LoadUint16(&o.BFCRT232.Reg)&^(0x30)|value<<4)
}
func (o *AOI_Type) GetBFCRT232_PT3_BC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT232.Reg) & 0x30) >> 4
}
func (o *AOI_Type) SetBFCRT232_PT3_AC(value uint16) {
	volatile.StoreUint16(&o.BFCRT232.Reg, volatile.LoadUint16(&o.BFCRT232.Reg)&^(0xc0)|value<<6)
}
func (o *AOI_Type) GetBFCRT232_PT3_AC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT232.Reg) & 0xc0) >> 6
}
func (o *AOI_Type) SetBFCRT232_PT2_DC(value uint16) {
	volatile.StoreUint16(&o.BFCRT232.Reg, volatile.LoadUint16(&o.BFCRT232.Reg)&^(0x300)|value<<8)
}
func (o *AOI_Type) GetBFCRT232_PT2_DC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT232.Reg) & 0x300) >> 8
}
func (o *AOI_Type) SetBFCRT232_PT2_CC(value uint16) {
	volatile.StoreUint16(&o.BFCRT232.Reg, volatile.LoadUint16(&o.BFCRT232.Reg)&^(0xc00)|value<<10)
}
func (o *AOI_Type) GetBFCRT232_PT2_CC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT232.Reg) & 0xc00) >> 10
}
func (o *AOI_Type) SetBFCRT232_PT2_BC(value uint16) {
	volatile.StoreUint16(&o.BFCRT232.Reg, volatile.LoadUint16(&o.BFCRT232.Reg)&^(0x3000)|value<<12)
}
func (o *AOI_Type) GetBFCRT232_PT2_BC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT232.Reg) & 0x3000) >> 12
}
func (o *AOI_Type) SetBFCRT232_PT2_AC(value uint16) {
	volatile.StoreUint16(&o.BFCRT232.Reg, volatile.LoadUint16(&o.BFCRT232.Reg)&^(0xc000)|value<<14)
}
func (o *AOI_Type) GetBFCRT232_PT2_AC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT232.Reg) & 0xc000) >> 14
}

// AOI.BFCRT013: Boolean Function Term 0 and 1 Configuration Register for EVENTn
func (o *AOI_Type) SetBFCRT013_PT1_DC(value uint16) {
	volatile.StoreUint16(&o.BFCRT013.Reg, volatile.LoadUint16(&o.BFCRT013.Reg)&^(0x3)|value)
}
func (o *AOI_Type) GetBFCRT013_PT1_DC() uint16 {
	return volatile.LoadUint16(&o.BFCRT013.Reg) & 0x3
}
func (o *AOI_Type) SetBFCRT013_PT1_CC(value uint16) {
	volatile.StoreUint16(&o.BFCRT013.Reg, volatile.LoadUint16(&o.BFCRT013.Reg)&^(0xc)|value<<2)
}
func (o *AOI_Type) GetBFCRT013_PT1_CC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT013.Reg) & 0xc) >> 2
}
func (o *AOI_Type) SetBFCRT013_PT1_BC(value uint16) {
	volatile.StoreUint16(&o.BFCRT013.Reg, volatile.LoadUint16(&o.BFCRT013.Reg)&^(0x30)|value<<4)
}
func (o *AOI_Type) GetBFCRT013_PT1_BC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT013.Reg) & 0x30) >> 4
}
func (o *AOI_Type) SetBFCRT013_PT1_AC(value uint16) {
	volatile.StoreUint16(&o.BFCRT013.Reg, volatile.LoadUint16(&o.BFCRT013.Reg)&^(0xc0)|value<<6)
}
func (o *AOI_Type) GetBFCRT013_PT1_AC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT013.Reg) & 0xc0) >> 6
}
func (o *AOI_Type) SetBFCRT013_PT0_DC(value uint16) {
	volatile.StoreUint16(&o.BFCRT013.Reg, volatile.LoadUint16(&o.BFCRT013.Reg)&^(0x300)|value<<8)
}
func (o *AOI_Type) GetBFCRT013_PT0_DC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT013.Reg) & 0x300) >> 8
}
func (o *AOI_Type) SetBFCRT013_PT0_CC(value uint16) {
	volatile.StoreUint16(&o.BFCRT013.Reg, volatile.LoadUint16(&o.BFCRT013.Reg)&^(0xc00)|value<<10)
}
func (o *AOI_Type) GetBFCRT013_PT0_CC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT013.Reg) & 0xc00) >> 10
}
func (o *AOI_Type) SetBFCRT013_PT0_BC(value uint16) {
	volatile.StoreUint16(&o.BFCRT013.Reg, volatile.LoadUint16(&o.BFCRT013.Reg)&^(0x3000)|value<<12)
}
func (o *AOI_Type) GetBFCRT013_PT0_BC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT013.Reg) & 0x3000) >> 12
}
func (o *AOI_Type) SetBFCRT013_PT0_AC(value uint16) {
	volatile.StoreUint16(&o.BFCRT013.Reg, volatile.LoadUint16(&o.BFCRT013.Reg)&^(0xc000)|value<<14)
}
func (o *AOI_Type) GetBFCRT013_PT0_AC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT013.Reg) & 0xc000) >> 14
}

// AOI.BFCRT233: Boolean Function Term 2 and 3 Configuration Register for EVENTn
func (o *AOI_Type) SetBFCRT233_PT3_DC(value uint16) {
	volatile.StoreUint16(&o.BFCRT233.Reg, volatile.LoadUint16(&o.BFCRT233.Reg)&^(0x3)|value)
}
func (o *AOI_Type) GetBFCRT233_PT3_DC() uint16 {
	return volatile.LoadUint16(&o.BFCRT233.Reg) & 0x3
}
func (o *AOI_Type) SetBFCRT233_PT3_CC(value uint16) {
	volatile.StoreUint16(&o.BFCRT233.Reg, volatile.LoadUint16(&o.BFCRT233.Reg)&^(0xc)|value<<2)
}
func (o *AOI_Type) GetBFCRT233_PT3_CC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT233.Reg) & 0xc) >> 2
}
func (o *AOI_Type) SetBFCRT233_PT3_BC(value uint16) {
	volatile.StoreUint16(&o.BFCRT233.Reg, volatile.LoadUint16(&o.BFCRT233.Reg)&^(0x30)|value<<4)
}
func (o *AOI_Type) GetBFCRT233_PT3_BC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT233.Reg) & 0x30) >> 4
}
func (o *AOI_Type) SetBFCRT233_PT3_AC(value uint16) {
	volatile.StoreUint16(&o.BFCRT233.Reg, volatile.LoadUint16(&o.BFCRT233.Reg)&^(0xc0)|value<<6)
}
func (o *AOI_Type) GetBFCRT233_PT3_AC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT233.Reg) & 0xc0) >> 6
}
func (o *AOI_Type) SetBFCRT233_PT2_DC(value uint16) {
	volatile.StoreUint16(&o.BFCRT233.Reg, volatile.LoadUint16(&o.BFCRT233.Reg)&^(0x300)|value<<8)
}
func (o *AOI_Type) GetBFCRT233_PT2_DC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT233.Reg) & 0x300) >> 8
}
func (o *AOI_Type) SetBFCRT233_PT2_CC(value uint16) {
	volatile.StoreUint16(&o.BFCRT233.Reg, volatile.LoadUint16(&o.BFCRT233.Reg)&^(0xc00)|value<<10)
}
func (o *AOI_Type) GetBFCRT233_PT2_CC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT233.Reg) & 0xc00) >> 10
}
func (o *AOI_Type) SetBFCRT233_PT2_BC(value uint16) {
	volatile.StoreUint16(&o.BFCRT233.Reg, volatile.LoadUint16(&o.BFCRT233.Reg)&^(0x3000)|value<<12)
}
func (o *AOI_Type) GetBFCRT233_PT2_BC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT233.Reg) & 0x3000) >> 12
}
func (o *AOI_Type) SetBFCRT233_PT2_AC(value uint16) {
	volatile.StoreUint16(&o.BFCRT233.Reg, volatile.LoadUint16(&o.BFCRT233.Reg)&^(0xc000)|value<<14)
}
func (o *AOI_Type) GetBFCRT233_PT2_AC() uint16 {
	return (volatile.LoadUint16(&o.BFCRT233.Reg) & 0xc000) >> 14
}

// Crossbar Switch
type XBARA_Type struct {
	SEL0  volatile.Register16 // 0x0
	SEL1  volatile.Register16 // 0x2
	SEL2  volatile.Register16 // 0x4
	SEL3  volatile.Register16 // 0x6
	SEL4  volatile.Register16 // 0x8
	SEL5  volatile.Register16 // 0xA
	SEL6  volatile.Register16 // 0xC
	SEL7  volatile.Register16 // 0xE
	SEL8  volatile.Register16 // 0x10
	SEL9  volatile.Register16 // 0x12
	SEL10 volatile.Register16 // 0x14
	SEL11 volatile.Register16 // 0x16
	SEL12 volatile.Register16 // 0x18
	SEL13 volatile.Register16 // 0x1A
	SEL14 volatile.Register16 // 0x1C
	SEL15 volatile.Register16 // 0x1E
	SEL16 volatile.Register16 // 0x20
	SEL17 volatile.Register16 // 0x22
	SEL18 volatile.Register16 // 0x24
	SEL19 volatile.Register16 // 0x26
	SEL20 volatile.Register16 // 0x28
	SEL21 volatile.Register16 // 0x2A
	SEL22 volatile.Register16 // 0x2C
	SEL23 volatile.Register16 // 0x2E
	SEL24 volatile.Register16 // 0x30
	SEL25 volatile.Register16 // 0x32
	SEL26 volatile.Register16 // 0x34
	SEL27 volatile.Register16 // 0x36
	SEL28 volatile.Register16 // 0x38
	SEL29 volatile.Register16 // 0x3A
	SEL30 volatile.Register16 // 0x3C
	SEL31 volatile.Register16 // 0x3E
	SEL32 volatile.Register16 // 0x40
	SEL33 volatile.Register16 // 0x42
	SEL34 volatile.Register16 // 0x44
	SEL35 volatile.Register16 // 0x46
	SEL36 volatile.Register16 // 0x48
	SEL37 volatile.Register16 // 0x4A
	SEL38 volatile.Register16 // 0x4C
	SEL39 volatile.Register16 // 0x4E
	SEL40 volatile.Register16 // 0x50
	SEL41 volatile.Register16 // 0x52
	SEL42 volatile.Register16 // 0x54
	SEL43 volatile.Register16 // 0x56
	SEL44 volatile.Register16 // 0x58
	SEL45 volatile.Register16 // 0x5A
	SEL46 volatile.Register16 // 0x5C
	SEL47 volatile.Register16 // 0x5E
	SEL48 volatile.Register16 // 0x60
	SEL49 volatile.Register16 // 0x62
	SEL50 volatile.Register16 // 0x64
	SEL51 volatile.Register16 // 0x66
	SEL52 volatile.Register16 // 0x68
	SEL53 volatile.Register16 // 0x6A
	SEL54 volatile.Register16 // 0x6C
	SEL55 volatile.Register16 // 0x6E
	SEL56 volatile.Register16 // 0x70
	SEL57 volatile.Register16 // 0x72
	SEL58 volatile.Register16 // 0x74
	SEL59 volatile.Register16 // 0x76
	SEL60 volatile.Register16 // 0x78
	SEL61 volatile.Register16 // 0x7A
	SEL62 volatile.Register16 // 0x7C
	SEL63 volatile.Register16 // 0x7E
	SEL64 volatile.Register16 // 0x80
	SEL65 volatile.Register16 // 0x82
	CTRL0 volatile.Register16 // 0x84
	CTRL1 volatile.Register16 // 0x86
}

// XBARA.SEL0: Crossbar A Select Register 0
func (o *XBARA_Type) SetSEL0(value uint16) {
	volatile.StoreUint16(&o.SEL0.Reg, volatile.LoadUint16(&o.SEL0.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL0() uint16 {
	return volatile.LoadUint16(&o.SEL0.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL0_SEL1(value uint16) {
	volatile.StoreUint16(&o.SEL0.Reg, volatile.LoadUint16(&o.SEL0.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL0_SEL1() uint16 {
	return (volatile.LoadUint16(&o.SEL0.Reg) & 0x7f00) >> 8
}

// XBARA.SEL1: Crossbar A Select Register 1
func (o *XBARA_Type) SetSEL1_SEL2(value uint16) {
	volatile.StoreUint16(&o.SEL1.Reg, volatile.LoadUint16(&o.SEL1.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL1_SEL2() uint16 {
	return volatile.LoadUint16(&o.SEL1.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL1_SEL3(value uint16) {
	volatile.StoreUint16(&o.SEL1.Reg, volatile.LoadUint16(&o.SEL1.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL1_SEL3() uint16 {
	return (volatile.LoadUint16(&o.SEL1.Reg) & 0x7f00) >> 8
}

// XBARA.SEL2: Crossbar A Select Register 2
func (o *XBARA_Type) SetSEL2_SEL4(value uint16) {
	volatile.StoreUint16(&o.SEL2.Reg, volatile.LoadUint16(&o.SEL2.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL2_SEL4() uint16 {
	return volatile.LoadUint16(&o.SEL2.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL2_SEL5(value uint16) {
	volatile.StoreUint16(&o.SEL2.Reg, volatile.LoadUint16(&o.SEL2.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL2_SEL5() uint16 {
	return (volatile.LoadUint16(&o.SEL2.Reg) & 0x7f00) >> 8
}

// XBARA.SEL3: Crossbar A Select Register 3
func (o *XBARA_Type) SetSEL3_SEL6(value uint16) {
	volatile.StoreUint16(&o.SEL3.Reg, volatile.LoadUint16(&o.SEL3.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL3_SEL6() uint16 {
	return volatile.LoadUint16(&o.SEL3.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL3_SEL7(value uint16) {
	volatile.StoreUint16(&o.SEL3.Reg, volatile.LoadUint16(&o.SEL3.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL3_SEL7() uint16 {
	return (volatile.LoadUint16(&o.SEL3.Reg) & 0x7f00) >> 8
}

// XBARA.SEL4: Crossbar A Select Register 4
func (o *XBARA_Type) SetSEL4_SEL8(value uint16) {
	volatile.StoreUint16(&o.SEL4.Reg, volatile.LoadUint16(&o.SEL4.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL4_SEL8() uint16 {
	return volatile.LoadUint16(&o.SEL4.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL4_SEL9(value uint16) {
	volatile.StoreUint16(&o.SEL4.Reg, volatile.LoadUint16(&o.SEL4.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL4_SEL9() uint16 {
	return (volatile.LoadUint16(&o.SEL4.Reg) & 0x7f00) >> 8
}

// XBARA.SEL5: Crossbar A Select Register 5
func (o *XBARA_Type) SetSEL5_SEL10(value uint16) {
	volatile.StoreUint16(&o.SEL5.Reg, volatile.LoadUint16(&o.SEL5.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL5_SEL10() uint16 {
	return volatile.LoadUint16(&o.SEL5.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL5_SEL11(value uint16) {
	volatile.StoreUint16(&o.SEL5.Reg, volatile.LoadUint16(&o.SEL5.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL5_SEL11() uint16 {
	return (volatile.LoadUint16(&o.SEL5.Reg) & 0x7f00) >> 8
}

// XBARA.SEL6: Crossbar A Select Register 6
func (o *XBARA_Type) SetSEL6_SEL12(value uint16) {
	volatile.StoreUint16(&o.SEL6.Reg, volatile.LoadUint16(&o.SEL6.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL6_SEL12() uint16 {
	return volatile.LoadUint16(&o.SEL6.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL6_SEL13(value uint16) {
	volatile.StoreUint16(&o.SEL6.Reg, volatile.LoadUint16(&o.SEL6.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL6_SEL13() uint16 {
	return (volatile.LoadUint16(&o.SEL6.Reg) & 0x7f00) >> 8
}

// XBARA.SEL7: Crossbar A Select Register 7
func (o *XBARA_Type) SetSEL7_SEL14(value uint16) {
	volatile.StoreUint16(&o.SEL7.Reg, volatile.LoadUint16(&o.SEL7.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL7_SEL14() uint16 {
	return volatile.LoadUint16(&o.SEL7.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL7_SEL15(value uint16) {
	volatile.StoreUint16(&o.SEL7.Reg, volatile.LoadUint16(&o.SEL7.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL7_SEL15() uint16 {
	return (volatile.LoadUint16(&o.SEL7.Reg) & 0x7f00) >> 8
}

// XBARA.SEL8: Crossbar A Select Register 8
func (o *XBARA_Type) SetSEL8_SEL16(value uint16) {
	volatile.StoreUint16(&o.SEL8.Reg, volatile.LoadUint16(&o.SEL8.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL8_SEL16() uint16 {
	return volatile.LoadUint16(&o.SEL8.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL8_SEL17(value uint16) {
	volatile.StoreUint16(&o.SEL8.Reg, volatile.LoadUint16(&o.SEL8.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL8_SEL17() uint16 {
	return (volatile.LoadUint16(&o.SEL8.Reg) & 0x7f00) >> 8
}

// XBARA.SEL9: Crossbar A Select Register 9
func (o *XBARA_Type) SetSEL9_SEL18(value uint16) {
	volatile.StoreUint16(&o.SEL9.Reg, volatile.LoadUint16(&o.SEL9.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL9_SEL18() uint16 {
	return volatile.LoadUint16(&o.SEL9.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL9_SEL19(value uint16) {
	volatile.StoreUint16(&o.SEL9.Reg, volatile.LoadUint16(&o.SEL9.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL9_SEL19() uint16 {
	return (volatile.LoadUint16(&o.SEL9.Reg) & 0x7f00) >> 8
}

// XBARA.SEL10: Crossbar A Select Register 10
func (o *XBARA_Type) SetSEL10_SEL20(value uint16) {
	volatile.StoreUint16(&o.SEL10.Reg, volatile.LoadUint16(&o.SEL10.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL10_SEL20() uint16 {
	return volatile.LoadUint16(&o.SEL10.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL10_SEL21(value uint16) {
	volatile.StoreUint16(&o.SEL10.Reg, volatile.LoadUint16(&o.SEL10.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL10_SEL21() uint16 {
	return (volatile.LoadUint16(&o.SEL10.Reg) & 0x7f00) >> 8
}

// XBARA.SEL11: Crossbar A Select Register 11
func (o *XBARA_Type) SetSEL11_SEL22(value uint16) {
	volatile.StoreUint16(&o.SEL11.Reg, volatile.LoadUint16(&o.SEL11.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL11_SEL22() uint16 {
	return volatile.LoadUint16(&o.SEL11.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL11_SEL23(value uint16) {
	volatile.StoreUint16(&o.SEL11.Reg, volatile.LoadUint16(&o.SEL11.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL11_SEL23() uint16 {
	return (volatile.LoadUint16(&o.SEL11.Reg) & 0x7f00) >> 8
}

// XBARA.SEL12: Crossbar A Select Register 12
func (o *XBARA_Type) SetSEL12_SEL24(value uint16) {
	volatile.StoreUint16(&o.SEL12.Reg, volatile.LoadUint16(&o.SEL12.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL12_SEL24() uint16 {
	return volatile.LoadUint16(&o.SEL12.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL12_SEL25(value uint16) {
	volatile.StoreUint16(&o.SEL12.Reg, volatile.LoadUint16(&o.SEL12.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL12_SEL25() uint16 {
	return (volatile.LoadUint16(&o.SEL12.Reg) & 0x7f00) >> 8
}

// XBARA.SEL13: Crossbar A Select Register 13
func (o *XBARA_Type) SetSEL13_SEL26(value uint16) {
	volatile.StoreUint16(&o.SEL13.Reg, volatile.LoadUint16(&o.SEL13.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL13_SEL26() uint16 {
	return volatile.LoadUint16(&o.SEL13.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL13_SEL27(value uint16) {
	volatile.StoreUint16(&o.SEL13.Reg, volatile.LoadUint16(&o.SEL13.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL13_SEL27() uint16 {
	return (volatile.LoadUint16(&o.SEL13.Reg) & 0x7f00) >> 8
}

// XBARA.SEL14: Crossbar A Select Register 14
func (o *XBARA_Type) SetSEL14_SEL28(value uint16) {
	volatile.StoreUint16(&o.SEL14.Reg, volatile.LoadUint16(&o.SEL14.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL14_SEL28() uint16 {
	return volatile.LoadUint16(&o.SEL14.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL14_SEL29(value uint16) {
	volatile.StoreUint16(&o.SEL14.Reg, volatile.LoadUint16(&o.SEL14.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL14_SEL29() uint16 {
	return (volatile.LoadUint16(&o.SEL14.Reg) & 0x7f00) >> 8
}

// XBARA.SEL15: Crossbar A Select Register 15
func (o *XBARA_Type) SetSEL15_SEL30(value uint16) {
	volatile.StoreUint16(&o.SEL15.Reg, volatile.LoadUint16(&o.SEL15.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL15_SEL30() uint16 {
	return volatile.LoadUint16(&o.SEL15.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL15_SEL31(value uint16) {
	volatile.StoreUint16(&o.SEL15.Reg, volatile.LoadUint16(&o.SEL15.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL15_SEL31() uint16 {
	return (volatile.LoadUint16(&o.SEL15.Reg) & 0x7f00) >> 8
}

// XBARA.SEL16: Crossbar A Select Register 16
func (o *XBARA_Type) SetSEL16_SEL32(value uint16) {
	volatile.StoreUint16(&o.SEL16.Reg, volatile.LoadUint16(&o.SEL16.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL16_SEL32() uint16 {
	return volatile.LoadUint16(&o.SEL16.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL16_SEL33(value uint16) {
	volatile.StoreUint16(&o.SEL16.Reg, volatile.LoadUint16(&o.SEL16.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL16_SEL33() uint16 {
	return (volatile.LoadUint16(&o.SEL16.Reg) & 0x7f00) >> 8
}

// XBARA.SEL17: Crossbar A Select Register 17
func (o *XBARA_Type) SetSEL17_SEL34(value uint16) {
	volatile.StoreUint16(&o.SEL17.Reg, volatile.LoadUint16(&o.SEL17.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL17_SEL34() uint16 {
	return volatile.LoadUint16(&o.SEL17.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL17_SEL35(value uint16) {
	volatile.StoreUint16(&o.SEL17.Reg, volatile.LoadUint16(&o.SEL17.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL17_SEL35() uint16 {
	return (volatile.LoadUint16(&o.SEL17.Reg) & 0x7f00) >> 8
}

// XBARA.SEL18: Crossbar A Select Register 18
func (o *XBARA_Type) SetSEL18_SEL36(value uint16) {
	volatile.StoreUint16(&o.SEL18.Reg, volatile.LoadUint16(&o.SEL18.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL18_SEL36() uint16 {
	return volatile.LoadUint16(&o.SEL18.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL18_SEL37(value uint16) {
	volatile.StoreUint16(&o.SEL18.Reg, volatile.LoadUint16(&o.SEL18.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL18_SEL37() uint16 {
	return (volatile.LoadUint16(&o.SEL18.Reg) & 0x7f00) >> 8
}

// XBARA.SEL19: Crossbar A Select Register 19
func (o *XBARA_Type) SetSEL19_SEL38(value uint16) {
	volatile.StoreUint16(&o.SEL19.Reg, volatile.LoadUint16(&o.SEL19.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL19_SEL38() uint16 {
	return volatile.LoadUint16(&o.SEL19.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL19_SEL39(value uint16) {
	volatile.StoreUint16(&o.SEL19.Reg, volatile.LoadUint16(&o.SEL19.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL19_SEL39() uint16 {
	return (volatile.LoadUint16(&o.SEL19.Reg) & 0x7f00) >> 8
}

// XBARA.SEL20: Crossbar A Select Register 20
func (o *XBARA_Type) SetSEL20_SEL40(value uint16) {
	volatile.StoreUint16(&o.SEL20.Reg, volatile.LoadUint16(&o.SEL20.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL20_SEL40() uint16 {
	return volatile.LoadUint16(&o.SEL20.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL20_SEL41(value uint16) {
	volatile.StoreUint16(&o.SEL20.Reg, volatile.LoadUint16(&o.SEL20.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL20_SEL41() uint16 {
	return (volatile.LoadUint16(&o.SEL20.Reg) & 0x7f00) >> 8
}

// XBARA.SEL21: Crossbar A Select Register 21
func (o *XBARA_Type) SetSEL21_SEL42(value uint16) {
	volatile.StoreUint16(&o.SEL21.Reg, volatile.LoadUint16(&o.SEL21.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL21_SEL42() uint16 {
	return volatile.LoadUint16(&o.SEL21.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL21_SEL43(value uint16) {
	volatile.StoreUint16(&o.SEL21.Reg, volatile.LoadUint16(&o.SEL21.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL21_SEL43() uint16 {
	return (volatile.LoadUint16(&o.SEL21.Reg) & 0x7f00) >> 8
}

// XBARA.SEL22: Crossbar A Select Register 22
func (o *XBARA_Type) SetSEL22_SEL44(value uint16) {
	volatile.StoreUint16(&o.SEL22.Reg, volatile.LoadUint16(&o.SEL22.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL22_SEL44() uint16 {
	return volatile.LoadUint16(&o.SEL22.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL22_SEL45(value uint16) {
	volatile.StoreUint16(&o.SEL22.Reg, volatile.LoadUint16(&o.SEL22.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL22_SEL45() uint16 {
	return (volatile.LoadUint16(&o.SEL22.Reg) & 0x7f00) >> 8
}

// XBARA.SEL23: Crossbar A Select Register 23
func (o *XBARA_Type) SetSEL23_SEL46(value uint16) {
	volatile.StoreUint16(&o.SEL23.Reg, volatile.LoadUint16(&o.SEL23.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL23_SEL46() uint16 {
	return volatile.LoadUint16(&o.SEL23.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL23_SEL47(value uint16) {
	volatile.StoreUint16(&o.SEL23.Reg, volatile.LoadUint16(&o.SEL23.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL23_SEL47() uint16 {
	return (volatile.LoadUint16(&o.SEL23.Reg) & 0x7f00) >> 8
}

// XBARA.SEL24: Crossbar A Select Register 24
func (o *XBARA_Type) SetSEL24_SEL48(value uint16) {
	volatile.StoreUint16(&o.SEL24.Reg, volatile.LoadUint16(&o.SEL24.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL24_SEL48() uint16 {
	return volatile.LoadUint16(&o.SEL24.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL24_SEL49(value uint16) {
	volatile.StoreUint16(&o.SEL24.Reg, volatile.LoadUint16(&o.SEL24.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL24_SEL49() uint16 {
	return (volatile.LoadUint16(&o.SEL24.Reg) & 0x7f00) >> 8
}

// XBARA.SEL25: Crossbar A Select Register 25
func (o *XBARA_Type) SetSEL25_SEL50(value uint16) {
	volatile.StoreUint16(&o.SEL25.Reg, volatile.LoadUint16(&o.SEL25.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL25_SEL50() uint16 {
	return volatile.LoadUint16(&o.SEL25.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL25_SEL51(value uint16) {
	volatile.StoreUint16(&o.SEL25.Reg, volatile.LoadUint16(&o.SEL25.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL25_SEL51() uint16 {
	return (volatile.LoadUint16(&o.SEL25.Reg) & 0x7f00) >> 8
}

// XBARA.SEL26: Crossbar A Select Register 26
func (o *XBARA_Type) SetSEL26_SEL52(value uint16) {
	volatile.StoreUint16(&o.SEL26.Reg, volatile.LoadUint16(&o.SEL26.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL26_SEL52() uint16 {
	return volatile.LoadUint16(&o.SEL26.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL26_SEL53(value uint16) {
	volatile.StoreUint16(&o.SEL26.Reg, volatile.LoadUint16(&o.SEL26.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL26_SEL53() uint16 {
	return (volatile.LoadUint16(&o.SEL26.Reg) & 0x7f00) >> 8
}

// XBARA.SEL27: Crossbar A Select Register 27
func (o *XBARA_Type) SetSEL27_SEL54(value uint16) {
	volatile.StoreUint16(&o.SEL27.Reg, volatile.LoadUint16(&o.SEL27.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL27_SEL54() uint16 {
	return volatile.LoadUint16(&o.SEL27.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL27_SEL55(value uint16) {
	volatile.StoreUint16(&o.SEL27.Reg, volatile.LoadUint16(&o.SEL27.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL27_SEL55() uint16 {
	return (volatile.LoadUint16(&o.SEL27.Reg) & 0x7f00) >> 8
}

// XBARA.SEL28: Crossbar A Select Register 28
func (o *XBARA_Type) SetSEL28_SEL56(value uint16) {
	volatile.StoreUint16(&o.SEL28.Reg, volatile.LoadUint16(&o.SEL28.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL28_SEL56() uint16 {
	return volatile.LoadUint16(&o.SEL28.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL28_SEL57(value uint16) {
	volatile.StoreUint16(&o.SEL28.Reg, volatile.LoadUint16(&o.SEL28.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL28_SEL57() uint16 {
	return (volatile.LoadUint16(&o.SEL28.Reg) & 0x7f00) >> 8
}

// XBARA.SEL29: Crossbar A Select Register 29
func (o *XBARA_Type) SetSEL29_SEL58(value uint16) {
	volatile.StoreUint16(&o.SEL29.Reg, volatile.LoadUint16(&o.SEL29.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL29_SEL58() uint16 {
	return volatile.LoadUint16(&o.SEL29.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL29_SEL59(value uint16) {
	volatile.StoreUint16(&o.SEL29.Reg, volatile.LoadUint16(&o.SEL29.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL29_SEL59() uint16 {
	return (volatile.LoadUint16(&o.SEL29.Reg) & 0x7f00) >> 8
}

// XBARA.SEL30: Crossbar A Select Register 30
func (o *XBARA_Type) SetSEL30_SEL60(value uint16) {
	volatile.StoreUint16(&o.SEL30.Reg, volatile.LoadUint16(&o.SEL30.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL30_SEL60() uint16 {
	return volatile.LoadUint16(&o.SEL30.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL30_SEL61(value uint16) {
	volatile.StoreUint16(&o.SEL30.Reg, volatile.LoadUint16(&o.SEL30.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL30_SEL61() uint16 {
	return (volatile.LoadUint16(&o.SEL30.Reg) & 0x7f00) >> 8
}

// XBARA.SEL31: Crossbar A Select Register 31
func (o *XBARA_Type) SetSEL31_SEL62(value uint16) {
	volatile.StoreUint16(&o.SEL31.Reg, volatile.LoadUint16(&o.SEL31.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL31_SEL62() uint16 {
	return volatile.LoadUint16(&o.SEL31.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL31_SEL63(value uint16) {
	volatile.StoreUint16(&o.SEL31.Reg, volatile.LoadUint16(&o.SEL31.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL31_SEL63() uint16 {
	return (volatile.LoadUint16(&o.SEL31.Reg) & 0x7f00) >> 8
}

// XBARA.SEL32: Crossbar A Select Register 32
func (o *XBARA_Type) SetSEL32_SEL64(value uint16) {
	volatile.StoreUint16(&o.SEL32.Reg, volatile.LoadUint16(&o.SEL32.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL32_SEL64() uint16 {
	return volatile.LoadUint16(&o.SEL32.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL32_SEL65(value uint16) {
	volatile.StoreUint16(&o.SEL32.Reg, volatile.LoadUint16(&o.SEL32.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL32_SEL65() uint16 {
	return (volatile.LoadUint16(&o.SEL32.Reg) & 0x7f00) >> 8
}

// XBARA.SEL33: Crossbar A Select Register 33
func (o *XBARA_Type) SetSEL33_SEL66(value uint16) {
	volatile.StoreUint16(&o.SEL33.Reg, volatile.LoadUint16(&o.SEL33.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL33_SEL66() uint16 {
	return volatile.LoadUint16(&o.SEL33.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL33_SEL67(value uint16) {
	volatile.StoreUint16(&o.SEL33.Reg, volatile.LoadUint16(&o.SEL33.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL33_SEL67() uint16 {
	return (volatile.LoadUint16(&o.SEL33.Reg) & 0x7f00) >> 8
}

// XBARA.SEL34: Crossbar A Select Register 34
func (o *XBARA_Type) SetSEL34_SEL68(value uint16) {
	volatile.StoreUint16(&o.SEL34.Reg, volatile.LoadUint16(&o.SEL34.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL34_SEL68() uint16 {
	return volatile.LoadUint16(&o.SEL34.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL34_SEL69(value uint16) {
	volatile.StoreUint16(&o.SEL34.Reg, volatile.LoadUint16(&o.SEL34.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL34_SEL69() uint16 {
	return (volatile.LoadUint16(&o.SEL34.Reg) & 0x7f00) >> 8
}

// XBARA.SEL35: Crossbar A Select Register 35
func (o *XBARA_Type) SetSEL35_SEL70(value uint16) {
	volatile.StoreUint16(&o.SEL35.Reg, volatile.LoadUint16(&o.SEL35.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL35_SEL70() uint16 {
	return volatile.LoadUint16(&o.SEL35.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL35_SEL71(value uint16) {
	volatile.StoreUint16(&o.SEL35.Reg, volatile.LoadUint16(&o.SEL35.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL35_SEL71() uint16 {
	return (volatile.LoadUint16(&o.SEL35.Reg) & 0x7f00) >> 8
}

// XBARA.SEL36: Crossbar A Select Register 36
func (o *XBARA_Type) SetSEL36_SEL72(value uint16) {
	volatile.StoreUint16(&o.SEL36.Reg, volatile.LoadUint16(&o.SEL36.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL36_SEL72() uint16 {
	return volatile.LoadUint16(&o.SEL36.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL36_SEL73(value uint16) {
	volatile.StoreUint16(&o.SEL36.Reg, volatile.LoadUint16(&o.SEL36.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL36_SEL73() uint16 {
	return (volatile.LoadUint16(&o.SEL36.Reg) & 0x7f00) >> 8
}

// XBARA.SEL37: Crossbar A Select Register 37
func (o *XBARA_Type) SetSEL37_SEL74(value uint16) {
	volatile.StoreUint16(&o.SEL37.Reg, volatile.LoadUint16(&o.SEL37.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL37_SEL74() uint16 {
	return volatile.LoadUint16(&o.SEL37.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL37_SEL75(value uint16) {
	volatile.StoreUint16(&o.SEL37.Reg, volatile.LoadUint16(&o.SEL37.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL37_SEL75() uint16 {
	return (volatile.LoadUint16(&o.SEL37.Reg) & 0x7f00) >> 8
}

// XBARA.SEL38: Crossbar A Select Register 38
func (o *XBARA_Type) SetSEL38_SEL76(value uint16) {
	volatile.StoreUint16(&o.SEL38.Reg, volatile.LoadUint16(&o.SEL38.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL38_SEL76() uint16 {
	return volatile.LoadUint16(&o.SEL38.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL38_SEL77(value uint16) {
	volatile.StoreUint16(&o.SEL38.Reg, volatile.LoadUint16(&o.SEL38.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL38_SEL77() uint16 {
	return (volatile.LoadUint16(&o.SEL38.Reg) & 0x7f00) >> 8
}

// XBARA.SEL39: Crossbar A Select Register 39
func (o *XBARA_Type) SetSEL39_SEL78(value uint16) {
	volatile.StoreUint16(&o.SEL39.Reg, volatile.LoadUint16(&o.SEL39.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL39_SEL78() uint16 {
	return volatile.LoadUint16(&o.SEL39.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL39_SEL79(value uint16) {
	volatile.StoreUint16(&o.SEL39.Reg, volatile.LoadUint16(&o.SEL39.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL39_SEL79() uint16 {
	return (volatile.LoadUint16(&o.SEL39.Reg) & 0x7f00) >> 8
}

// XBARA.SEL40: Crossbar A Select Register 40
func (o *XBARA_Type) SetSEL40_SEL80(value uint16) {
	volatile.StoreUint16(&o.SEL40.Reg, volatile.LoadUint16(&o.SEL40.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL40_SEL80() uint16 {
	return volatile.LoadUint16(&o.SEL40.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL40_SEL81(value uint16) {
	volatile.StoreUint16(&o.SEL40.Reg, volatile.LoadUint16(&o.SEL40.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL40_SEL81() uint16 {
	return (volatile.LoadUint16(&o.SEL40.Reg) & 0x7f00) >> 8
}

// XBARA.SEL41: Crossbar A Select Register 41
func (o *XBARA_Type) SetSEL41_SEL82(value uint16) {
	volatile.StoreUint16(&o.SEL41.Reg, volatile.LoadUint16(&o.SEL41.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL41_SEL82() uint16 {
	return volatile.LoadUint16(&o.SEL41.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL41_SEL83(value uint16) {
	volatile.StoreUint16(&o.SEL41.Reg, volatile.LoadUint16(&o.SEL41.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL41_SEL83() uint16 {
	return (volatile.LoadUint16(&o.SEL41.Reg) & 0x7f00) >> 8
}

// XBARA.SEL42: Crossbar A Select Register 42
func (o *XBARA_Type) SetSEL42_SEL84(value uint16) {
	volatile.StoreUint16(&o.SEL42.Reg, volatile.LoadUint16(&o.SEL42.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL42_SEL84() uint16 {
	return volatile.LoadUint16(&o.SEL42.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL42_SEL85(value uint16) {
	volatile.StoreUint16(&o.SEL42.Reg, volatile.LoadUint16(&o.SEL42.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL42_SEL85() uint16 {
	return (volatile.LoadUint16(&o.SEL42.Reg) & 0x7f00) >> 8
}

// XBARA.SEL43: Crossbar A Select Register 43
func (o *XBARA_Type) SetSEL43_SEL86(value uint16) {
	volatile.StoreUint16(&o.SEL43.Reg, volatile.LoadUint16(&o.SEL43.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL43_SEL86() uint16 {
	return volatile.LoadUint16(&o.SEL43.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL43_SEL87(value uint16) {
	volatile.StoreUint16(&o.SEL43.Reg, volatile.LoadUint16(&o.SEL43.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL43_SEL87() uint16 {
	return (volatile.LoadUint16(&o.SEL43.Reg) & 0x7f00) >> 8
}

// XBARA.SEL44: Crossbar A Select Register 44
func (o *XBARA_Type) SetSEL44_SEL88(value uint16) {
	volatile.StoreUint16(&o.SEL44.Reg, volatile.LoadUint16(&o.SEL44.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL44_SEL88() uint16 {
	return volatile.LoadUint16(&o.SEL44.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL44_SEL89(value uint16) {
	volatile.StoreUint16(&o.SEL44.Reg, volatile.LoadUint16(&o.SEL44.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL44_SEL89() uint16 {
	return (volatile.LoadUint16(&o.SEL44.Reg) & 0x7f00) >> 8
}

// XBARA.SEL45: Crossbar A Select Register 45
func (o *XBARA_Type) SetSEL45_SEL90(value uint16) {
	volatile.StoreUint16(&o.SEL45.Reg, volatile.LoadUint16(&o.SEL45.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL45_SEL90() uint16 {
	return volatile.LoadUint16(&o.SEL45.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL45_SEL91(value uint16) {
	volatile.StoreUint16(&o.SEL45.Reg, volatile.LoadUint16(&o.SEL45.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL45_SEL91() uint16 {
	return (volatile.LoadUint16(&o.SEL45.Reg) & 0x7f00) >> 8
}

// XBARA.SEL46: Crossbar A Select Register 46
func (o *XBARA_Type) SetSEL46_SEL92(value uint16) {
	volatile.StoreUint16(&o.SEL46.Reg, volatile.LoadUint16(&o.SEL46.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL46_SEL92() uint16 {
	return volatile.LoadUint16(&o.SEL46.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL46_SEL93(value uint16) {
	volatile.StoreUint16(&o.SEL46.Reg, volatile.LoadUint16(&o.SEL46.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL46_SEL93() uint16 {
	return (volatile.LoadUint16(&o.SEL46.Reg) & 0x7f00) >> 8
}

// XBARA.SEL47: Crossbar A Select Register 47
func (o *XBARA_Type) SetSEL47_SEL94(value uint16) {
	volatile.StoreUint16(&o.SEL47.Reg, volatile.LoadUint16(&o.SEL47.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL47_SEL94() uint16 {
	return volatile.LoadUint16(&o.SEL47.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL47_SEL95(value uint16) {
	volatile.StoreUint16(&o.SEL47.Reg, volatile.LoadUint16(&o.SEL47.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL47_SEL95() uint16 {
	return (volatile.LoadUint16(&o.SEL47.Reg) & 0x7f00) >> 8
}

// XBARA.SEL48: Crossbar A Select Register 48
func (o *XBARA_Type) SetSEL48_SEL96(value uint16) {
	volatile.StoreUint16(&o.SEL48.Reg, volatile.LoadUint16(&o.SEL48.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL48_SEL96() uint16 {
	return volatile.LoadUint16(&o.SEL48.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL48_SEL97(value uint16) {
	volatile.StoreUint16(&o.SEL48.Reg, volatile.LoadUint16(&o.SEL48.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL48_SEL97() uint16 {
	return (volatile.LoadUint16(&o.SEL48.Reg) & 0x7f00) >> 8
}

// XBARA.SEL49: Crossbar A Select Register 49
func (o *XBARA_Type) SetSEL49_SEL98(value uint16) {
	volatile.StoreUint16(&o.SEL49.Reg, volatile.LoadUint16(&o.SEL49.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL49_SEL98() uint16 {
	return volatile.LoadUint16(&o.SEL49.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL49_SEL99(value uint16) {
	volatile.StoreUint16(&o.SEL49.Reg, volatile.LoadUint16(&o.SEL49.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL49_SEL99() uint16 {
	return (volatile.LoadUint16(&o.SEL49.Reg) & 0x7f00) >> 8
}

// XBARA.SEL50: Crossbar A Select Register 50
func (o *XBARA_Type) SetSEL50_SEL100(value uint16) {
	volatile.StoreUint16(&o.SEL50.Reg, volatile.LoadUint16(&o.SEL50.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL50_SEL100() uint16 {
	return volatile.LoadUint16(&o.SEL50.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL50_SEL101(value uint16) {
	volatile.StoreUint16(&o.SEL50.Reg, volatile.LoadUint16(&o.SEL50.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL50_SEL101() uint16 {
	return (volatile.LoadUint16(&o.SEL50.Reg) & 0x7f00) >> 8
}

// XBARA.SEL51: Crossbar A Select Register 51
func (o *XBARA_Type) SetSEL51_SEL102(value uint16) {
	volatile.StoreUint16(&o.SEL51.Reg, volatile.LoadUint16(&o.SEL51.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL51_SEL102() uint16 {
	return volatile.LoadUint16(&o.SEL51.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL51_SEL103(value uint16) {
	volatile.StoreUint16(&o.SEL51.Reg, volatile.LoadUint16(&o.SEL51.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL51_SEL103() uint16 {
	return (volatile.LoadUint16(&o.SEL51.Reg) & 0x7f00) >> 8
}

// XBARA.SEL52: Crossbar A Select Register 52
func (o *XBARA_Type) SetSEL52_SEL104(value uint16) {
	volatile.StoreUint16(&o.SEL52.Reg, volatile.LoadUint16(&o.SEL52.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL52_SEL104() uint16 {
	return volatile.LoadUint16(&o.SEL52.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL52_SEL105(value uint16) {
	volatile.StoreUint16(&o.SEL52.Reg, volatile.LoadUint16(&o.SEL52.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL52_SEL105() uint16 {
	return (volatile.LoadUint16(&o.SEL52.Reg) & 0x7f00) >> 8
}

// XBARA.SEL53: Crossbar A Select Register 53
func (o *XBARA_Type) SetSEL53_SEL106(value uint16) {
	volatile.StoreUint16(&o.SEL53.Reg, volatile.LoadUint16(&o.SEL53.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL53_SEL106() uint16 {
	return volatile.LoadUint16(&o.SEL53.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL53_SEL107(value uint16) {
	volatile.StoreUint16(&o.SEL53.Reg, volatile.LoadUint16(&o.SEL53.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL53_SEL107() uint16 {
	return (volatile.LoadUint16(&o.SEL53.Reg) & 0x7f00) >> 8
}

// XBARA.SEL54: Crossbar A Select Register 54
func (o *XBARA_Type) SetSEL54_SEL108(value uint16) {
	volatile.StoreUint16(&o.SEL54.Reg, volatile.LoadUint16(&o.SEL54.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL54_SEL108() uint16 {
	return volatile.LoadUint16(&o.SEL54.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL54_SEL109(value uint16) {
	volatile.StoreUint16(&o.SEL54.Reg, volatile.LoadUint16(&o.SEL54.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL54_SEL109() uint16 {
	return (volatile.LoadUint16(&o.SEL54.Reg) & 0x7f00) >> 8
}

// XBARA.SEL55: Crossbar A Select Register 55
func (o *XBARA_Type) SetSEL55_SEL110(value uint16) {
	volatile.StoreUint16(&o.SEL55.Reg, volatile.LoadUint16(&o.SEL55.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL55_SEL110() uint16 {
	return volatile.LoadUint16(&o.SEL55.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL55_SEL111(value uint16) {
	volatile.StoreUint16(&o.SEL55.Reg, volatile.LoadUint16(&o.SEL55.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL55_SEL111() uint16 {
	return (volatile.LoadUint16(&o.SEL55.Reg) & 0x7f00) >> 8
}

// XBARA.SEL56: Crossbar A Select Register 56
func (o *XBARA_Type) SetSEL56_SEL112(value uint16) {
	volatile.StoreUint16(&o.SEL56.Reg, volatile.LoadUint16(&o.SEL56.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL56_SEL112() uint16 {
	return volatile.LoadUint16(&o.SEL56.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL56_SEL113(value uint16) {
	volatile.StoreUint16(&o.SEL56.Reg, volatile.LoadUint16(&o.SEL56.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL56_SEL113() uint16 {
	return (volatile.LoadUint16(&o.SEL56.Reg) & 0x7f00) >> 8
}

// XBARA.SEL57: Crossbar A Select Register 57
func (o *XBARA_Type) SetSEL57_SEL114(value uint16) {
	volatile.StoreUint16(&o.SEL57.Reg, volatile.LoadUint16(&o.SEL57.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL57_SEL114() uint16 {
	return volatile.LoadUint16(&o.SEL57.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL57_SEL115(value uint16) {
	volatile.StoreUint16(&o.SEL57.Reg, volatile.LoadUint16(&o.SEL57.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL57_SEL115() uint16 {
	return (volatile.LoadUint16(&o.SEL57.Reg) & 0x7f00) >> 8
}

// XBARA.SEL58: Crossbar A Select Register 58
func (o *XBARA_Type) SetSEL58_SEL116(value uint16) {
	volatile.StoreUint16(&o.SEL58.Reg, volatile.LoadUint16(&o.SEL58.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL58_SEL116() uint16 {
	return volatile.LoadUint16(&o.SEL58.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL58_SEL117(value uint16) {
	volatile.StoreUint16(&o.SEL58.Reg, volatile.LoadUint16(&o.SEL58.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL58_SEL117() uint16 {
	return (volatile.LoadUint16(&o.SEL58.Reg) & 0x7f00) >> 8
}

// XBARA.SEL59: Crossbar A Select Register 59
func (o *XBARA_Type) SetSEL59_SEL118(value uint16) {
	volatile.StoreUint16(&o.SEL59.Reg, volatile.LoadUint16(&o.SEL59.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL59_SEL118() uint16 {
	return volatile.LoadUint16(&o.SEL59.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL59_SEL119(value uint16) {
	volatile.StoreUint16(&o.SEL59.Reg, volatile.LoadUint16(&o.SEL59.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL59_SEL119() uint16 {
	return (volatile.LoadUint16(&o.SEL59.Reg) & 0x7f00) >> 8
}

// XBARA.SEL60: Crossbar A Select Register 60
func (o *XBARA_Type) SetSEL60_SEL120(value uint16) {
	volatile.StoreUint16(&o.SEL60.Reg, volatile.LoadUint16(&o.SEL60.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL60_SEL120() uint16 {
	return volatile.LoadUint16(&o.SEL60.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL60_SEL121(value uint16) {
	volatile.StoreUint16(&o.SEL60.Reg, volatile.LoadUint16(&o.SEL60.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL60_SEL121() uint16 {
	return (volatile.LoadUint16(&o.SEL60.Reg) & 0x7f00) >> 8
}

// XBARA.SEL61: Crossbar A Select Register 61
func (o *XBARA_Type) SetSEL61_SEL122(value uint16) {
	volatile.StoreUint16(&o.SEL61.Reg, volatile.LoadUint16(&o.SEL61.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL61_SEL122() uint16 {
	return volatile.LoadUint16(&o.SEL61.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL61_SEL123(value uint16) {
	volatile.StoreUint16(&o.SEL61.Reg, volatile.LoadUint16(&o.SEL61.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL61_SEL123() uint16 {
	return (volatile.LoadUint16(&o.SEL61.Reg) & 0x7f00) >> 8
}

// XBARA.SEL62: Crossbar A Select Register 62
func (o *XBARA_Type) SetSEL62_SEL124(value uint16) {
	volatile.StoreUint16(&o.SEL62.Reg, volatile.LoadUint16(&o.SEL62.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL62_SEL124() uint16 {
	return volatile.LoadUint16(&o.SEL62.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL62_SEL125(value uint16) {
	volatile.StoreUint16(&o.SEL62.Reg, volatile.LoadUint16(&o.SEL62.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL62_SEL125() uint16 {
	return (volatile.LoadUint16(&o.SEL62.Reg) & 0x7f00) >> 8
}

// XBARA.SEL63: Crossbar A Select Register 63
func (o *XBARA_Type) SetSEL63_SEL126(value uint16) {
	volatile.StoreUint16(&o.SEL63.Reg, volatile.LoadUint16(&o.SEL63.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL63_SEL126() uint16 {
	return volatile.LoadUint16(&o.SEL63.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL63_SEL127(value uint16) {
	volatile.StoreUint16(&o.SEL63.Reg, volatile.LoadUint16(&o.SEL63.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL63_SEL127() uint16 {
	return (volatile.LoadUint16(&o.SEL63.Reg) & 0x7f00) >> 8
}

// XBARA.SEL64: Crossbar A Select Register 64
func (o *XBARA_Type) SetSEL64_SEL128(value uint16) {
	volatile.StoreUint16(&o.SEL64.Reg, volatile.LoadUint16(&o.SEL64.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL64_SEL128() uint16 {
	return volatile.LoadUint16(&o.SEL64.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL64_SEL129(value uint16) {
	volatile.StoreUint16(&o.SEL64.Reg, volatile.LoadUint16(&o.SEL64.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL64_SEL129() uint16 {
	return (volatile.LoadUint16(&o.SEL64.Reg) & 0x7f00) >> 8
}

// XBARA.SEL65: Crossbar A Select Register 65
func (o *XBARA_Type) SetSEL65_SEL130(value uint16) {
	volatile.StoreUint16(&o.SEL65.Reg, volatile.LoadUint16(&o.SEL65.Reg)&^(0x7f)|value)
}
func (o *XBARA_Type) GetSEL65_SEL130() uint16 {
	return volatile.LoadUint16(&o.SEL65.Reg) & 0x7f
}
func (o *XBARA_Type) SetSEL65_SEL131(value uint16) {
	volatile.StoreUint16(&o.SEL65.Reg, volatile.LoadUint16(&o.SEL65.Reg)&^(0x7f00)|value<<8)
}
func (o *XBARA_Type) GetSEL65_SEL131() uint16 {
	return (volatile.LoadUint16(&o.SEL65.Reg) & 0x7f00) >> 8
}

// XBARA.CTRL0: Crossbar A Control Register 0
func (o *XBARA_Type) SetCTRL0_DEN0(value uint16) {
	volatile.StoreUint16(&o.CTRL0.Reg, volatile.LoadUint16(&o.CTRL0.Reg)&^(0x1)|value)
}
func (o *XBARA_Type) GetCTRL0_DEN0() uint16 {
	return volatile.LoadUint16(&o.CTRL0.Reg) & 0x1
}
func (o *XBARA_Type) SetCTRL0_IEN0(value uint16) {
	volatile.StoreUint16(&o.CTRL0.Reg, volatile.LoadUint16(&o.CTRL0.Reg)&^(0x2)|value<<1)
}
func (o *XBARA_Type) GetCTRL0_IEN0() uint16 {
	return (volatile.LoadUint16(&o.CTRL0.Reg) & 0x2) >> 1
}
func (o *XBARA_Type) SetCTRL0_EDGE0(value uint16) {
	volatile.StoreUint16(&o.CTRL0.Reg, volatile.LoadUint16(&o.CTRL0.Reg)&^(0xc)|value<<2)
}
func (o *XBARA_Type) GetCTRL0_EDGE0() uint16 {
	return (volatile.LoadUint16(&o.CTRL0.Reg) & 0xc) >> 2
}
func (o *XBARA_Type) SetCTRL0_STS0(value uint16) {
	volatile.StoreUint16(&o.CTRL0.Reg, volatile.LoadUint16(&o.CTRL0.Reg)&^(0x10)|value<<4)
}
func (o *XBARA_Type) GetCTRL0_STS0() uint16 {
	return (volatile.LoadUint16(&o.CTRL0.Reg) & 0x10) >> 4
}
func (o *XBARA_Type) SetCTRL0_DEN1(value uint16) {
	volatile.StoreUint16(&o.CTRL0.Reg, volatile.LoadUint16(&o.CTRL0.Reg)&^(0x100)|value<<8)
}
func (o *XBARA_Type) GetCTRL0_DEN1() uint16 {
	return (volatile.LoadUint16(&o.CTRL0.Reg) & 0x100) >> 8
}
func (o *XBARA_Type) SetCTRL0_IEN1(value uint16) {
	volatile.StoreUint16(&o.CTRL0.Reg, volatile.LoadUint16(&o.CTRL0.Reg)&^(0x200)|value<<9)
}
func (o *XBARA_Type) GetCTRL0_IEN1() uint16 {
	return (volatile.LoadUint16(&o.CTRL0.Reg) & 0x200) >> 9
}
func (o *XBARA_Type) SetCTRL0_EDGE1(value uint16) {
	volatile.StoreUint16(&o.CTRL0.Reg, volatile.LoadUint16(&o.CTRL0.Reg)&^(0xc00)|value<<10)
}
func (o *XBARA_Type) GetCTRL0_EDGE1() uint16 {
	return (volatile.LoadUint16(&o.CTRL0.Reg) & 0xc00) >> 10
}
func (o *XBARA_Type) SetCTRL0_STS1(value uint16) {
	volatile.StoreUint16(&o.CTRL0.Reg, volatile.LoadUint16(&o.CTRL0.Reg)&^(0x1000)|value<<12)
}
func (o *XBARA_Type) GetCTRL0_STS1() uint16 {
	return (volatile.LoadUint16(&o.CTRL0.Reg) & 0x1000) >> 12
}

// XBARA.CTRL1: Crossbar A Control Register 1
func (o *XBARA_Type) SetCTRL1_DEN2(value uint16) {
	volatile.StoreUint16(&o.CTRL1.Reg, volatile.LoadUint16(&o.CTRL1.Reg)&^(0x1)|value)
}
func (o *XBARA_Type) GetCTRL1_DEN2() uint16 {
	return volatile.LoadUint16(&o.CTRL1.Reg) & 0x1
}
func (o *XBARA_Type) SetCTRL1_IEN2(value uint16) {
	volatile.StoreUint16(&o.CTRL1.Reg, volatile.LoadUint16(&o.CTRL1.Reg)&^(0x2)|value<<1)
}
func (o *XBARA_Type) GetCTRL1_IEN2() uint16 {
	return (volatile.LoadUint16(&o.CTRL1.Reg) & 0x2) >> 1
}
func (o *XBARA_Type) SetCTRL1_EDGE2(value uint16) {
	volatile.StoreUint16(&o.CTRL1.Reg, volatile.LoadUint16(&o.CTRL1.Reg)&^(0xc)|value<<2)
}
func (o *XBARA_Type) GetCTRL1_EDGE2() uint16 {
	return (volatile.LoadUint16(&o.CTRL1.Reg) & 0xc) >> 2
}
func (o *XBARA_Type) SetCTRL1_STS2(value uint16) {
	volatile.StoreUint16(&o.CTRL1.Reg, volatile.LoadUint16(&o.CTRL1.Reg)&^(0x10)|value<<4)
}
func (o *XBARA_Type) GetCTRL1_STS2() uint16 {
	return (volatile.LoadUint16(&o.CTRL1.Reg) & 0x10) >> 4
}
func (o *XBARA_Type) SetCTRL1_DEN3(value uint16) {
	volatile.StoreUint16(&o.CTRL1.Reg, volatile.LoadUint16(&o.CTRL1.Reg)&^(0x100)|value<<8)
}
func (o *XBARA_Type) GetCTRL1_DEN3() uint16 {
	return (volatile.LoadUint16(&o.CTRL1.Reg) & 0x100) >> 8
}
func (o *XBARA_Type) SetCTRL1_IEN3(value uint16) {
	volatile.StoreUint16(&o.CTRL1.Reg, volatile.LoadUint16(&o.CTRL1.Reg)&^(0x200)|value<<9)
}
func (o *XBARA_Type) GetCTRL1_IEN3() uint16 {
	return (volatile.LoadUint16(&o.CTRL1.Reg) & 0x200) >> 9
}
func (o *XBARA_Type) SetCTRL1_EDGE3(value uint16) {
	volatile.StoreUint16(&o.CTRL1.Reg, volatile.LoadUint16(&o.CTRL1.Reg)&^(0xc00)|value<<10)
}
func (o *XBARA_Type) GetCTRL1_EDGE3() uint16 {
	return (volatile.LoadUint16(&o.CTRL1.Reg) & 0xc00) >> 10
}
func (o *XBARA_Type) SetCTRL1_STS3(value uint16) {
	volatile.StoreUint16(&o.CTRL1.Reg, volatile.LoadUint16(&o.CTRL1.Reg)&^(0x1000)|value<<12)
}
func (o *XBARA_Type) GetCTRL1_STS3() uint16 {
	return (volatile.LoadUint16(&o.CTRL1.Reg) & 0x1000) >> 12
}

// FlexSPI
type FlexSPI_Type struct {
	MCR0         volatile.Register32 // 0x0
	MCR1         volatile.Register32 // 0x4
	MCR2         volatile.Register32 // 0x8
	AHBCR        volatile.Register32 // 0xC
	INTEN        volatile.Register32 // 0x10
	INTR         volatile.Register32 // 0x14
	LUTKEY       volatile.Register32 // 0x18
	LUTCR        volatile.Register32 // 0x1C
	AHBRXBUF0CR0 volatile.Register32 // 0x20
	AHBRXBUF1CR0 volatile.Register32 // 0x24
	AHBRXBUF2CR0 volatile.Register32 // 0x28
	AHBRXBUF3CR0 volatile.Register32 // 0x2C
	_            [48]byte
	FLSHA1CR0    volatile.Register32 // 0x60
	FLSHA2CR0    volatile.Register32 // 0x64
	FLSHB1CR0    volatile.Register32 // 0x68
	FLSHB2CR0    volatile.Register32 // 0x6C
	FLSHCR1A1    volatile.Register32 // 0x70
	FLSHCR1A2    volatile.Register32 // 0x74
	FLSHCR1B1    volatile.Register32 // 0x78
	FLSHCR1B2    volatile.Register32 // 0x7C
	FLSHCR2A1    volatile.Register32 // 0x80
	FLSHCR2A2    volatile.Register32 // 0x84
	FLSHCR2B1    volatile.Register32 // 0x88
	FLSHCR2B2    volatile.Register32 // 0x8C
	_            [4]byte
	FLSHCR4      volatile.Register32 // 0x94
	_            [8]byte
	IPCR0        volatile.Register32 // 0xA0
	IPCR1        volatile.Register32 // 0xA4
	_            [8]byte
	IPCMD        volatile.Register32 // 0xB0
	_            [4]byte
	IPRXFCR      volatile.Register32 // 0xB8
	IPTXFCR      volatile.Register32 // 0xBC
	DLLCRA       volatile.Register32 // 0xC0
	DLLCRB       volatile.Register32 // 0xC4
	_            [24]byte
	STS0         volatile.Register32 // 0xE0
	STS1         volatile.Register32 // 0xE4
	STS2         volatile.Register32 // 0xE8
	AHBSPNDSTS   volatile.Register32 // 0xEC
	IPRXFSTS     volatile.Register32 // 0xF0
	IPTXFSTS     volatile.Register32 // 0xF4
	_            [8]byte
	RFDR         [32]volatile.Register32 // 0x100
	TFDR         [32]volatile.Register32 // 0x180
	LUT          [64]volatile.Register32 // 0x200
}

// FlexSPI.MCR0: Module Control Register 0
func (o *FlexSPI_Type) SetMCR0_SWRESET(value uint32) {
	volatile.StoreUint32(&o.MCR0.Reg, volatile.LoadUint32(&o.MCR0.Reg)&^(0x1)|value)
}
func (o *FlexSPI_Type) GetMCR0_SWRESET() uint32 {
	return volatile.LoadUint32(&o.MCR0.Reg) & 0x1
}
func (o *FlexSPI_Type) SetMCR0_MDIS(value uint32) {
	volatile.StoreUint32(&o.MCR0.Reg, volatile.LoadUint32(&o.MCR0.Reg)&^(0x2)|value<<1)
}
func (o *FlexSPI_Type) GetMCR0_MDIS() uint32 {
	return (volatile.LoadUint32(&o.MCR0.Reg) & 0x2) >> 1
}
func (o *FlexSPI_Type) SetMCR0_RXCLKSRC(value uint32) {
	volatile.StoreUint32(&o.MCR0.Reg, volatile.LoadUint32(&o.MCR0.Reg)&^(0x30)|value<<4)
}
func (o *FlexSPI_Type) GetMCR0_RXCLKSRC() uint32 {
	return (volatile.LoadUint32(&o.MCR0.Reg) & 0x30) >> 4
}
func (o *FlexSPI_Type) SetMCR0_ARDFEN(value uint32) {
	volatile.StoreUint32(&o.MCR0.Reg, volatile.LoadUint32(&o.MCR0.Reg)&^(0x40)|value<<6)
}
func (o *FlexSPI_Type) GetMCR0_ARDFEN() uint32 {
	return (volatile.LoadUint32(&o.MCR0.Reg) & 0x40) >> 6
}
func (o *FlexSPI_Type) SetMCR0_ATDFEN(value uint32) {
	volatile.StoreUint32(&o.MCR0.Reg, volatile.LoadUint32(&o.MCR0.Reg)&^(0x80)|value<<7)
}
func (o *FlexSPI_Type) GetMCR0_ATDFEN() uint32 {
	return (volatile.LoadUint32(&o.MCR0.Reg) & 0x80) >> 7
}
func (o *FlexSPI_Type) SetMCR0_SERCLKDIV(value uint32) {
	volatile.StoreUint32(&o.MCR0.Reg, volatile.LoadUint32(&o.MCR0.Reg)&^(0x700)|value<<8)
}
func (o *FlexSPI_Type) GetMCR0_SERCLKDIV() uint32 {
	return (volatile.LoadUint32(&o.MCR0.Reg) & 0x700) >> 8
}
func (o *FlexSPI_Type) SetMCR0_HSEN(value uint32) {
	volatile.StoreUint32(&o.MCR0.Reg, volatile.LoadUint32(&o.MCR0.Reg)&^(0x800)|value<<11)
}
func (o *FlexSPI_Type) GetMCR0_HSEN() uint32 {
	return (volatile.LoadUint32(&o.MCR0.Reg) & 0x800) >> 11
}
func (o *FlexSPI_Type) SetMCR0_DOZEEN(value uint32) {
	volatile.StoreUint32(&o.MCR0.Reg, volatile.LoadUint32(&o.MCR0.Reg)&^(0x1000)|value<<12)
}
func (o *FlexSPI_Type) GetMCR0_DOZEEN() uint32 {
	return (volatile.LoadUint32(&o.MCR0.Reg) & 0x1000) >> 12
}
func (o *FlexSPI_Type) SetMCR0_COMBINATIONEN(value uint32) {
	volatile.StoreUint32(&o.MCR0.Reg, volatile.LoadUint32(&o.MCR0.Reg)&^(0x2000)|value<<13)
}
func (o *FlexSPI_Type) GetMCR0_COMBINATIONEN() uint32 {
	return (volatile.LoadUint32(&o.MCR0.Reg) & 0x2000) >> 13
}
func (o *FlexSPI_Type) SetMCR0_SCKFREERUNEN(value uint32) {
	volatile.StoreUint32(&o.MCR0.Reg, volatile.LoadUint32(&o.MCR0.Reg)&^(0x4000)|value<<14)
}
func (o *FlexSPI_Type) GetMCR0_SCKFREERUNEN() uint32 {
	return (volatile.LoadUint32(&o.MCR0.Reg) & 0x4000) >> 14
}
func (o *FlexSPI_Type) SetMCR0_IPGRANTWAIT(value uint32) {
	volatile.StoreUint32(&o.MCR0.Reg, volatile.LoadUint32(&o.MCR0.Reg)&^(0xff0000)|value<<16)
}
func (o *FlexSPI_Type) GetMCR0_IPGRANTWAIT() uint32 {
	return (volatile.LoadUint32(&o.MCR0.Reg) & 0xff0000) >> 16
}
func (o *FlexSPI_Type) SetMCR0_AHBGRANTWAIT(value uint32) {
	volatile.StoreUint32(&o.MCR0.Reg, volatile.LoadUint32(&o.MCR0.Reg)&^(0xff000000)|value<<24)
}
func (o *FlexSPI_Type) GetMCR0_AHBGRANTWAIT() uint32 {
	return (volatile.LoadUint32(&o.MCR0.Reg) & 0xff000000) >> 24
}

// FlexSPI.MCR1: Module Control Register 1
func (o *FlexSPI_Type) SetMCR1_AHBBUSWAIT(value uint32) {
	volatile.StoreUint32(&o.MCR1.Reg, volatile.LoadUint32(&o.MCR1.Reg)&^(0xffff)|value)
}
func (o *FlexSPI_Type) GetMCR1_AHBBUSWAIT() uint32 {
	return volatile.LoadUint32(&o.MCR1.Reg) & 0xffff
}
func (o *FlexSPI_Type) SetMCR1_SEQWAIT(value uint32) {
	volatile.StoreUint32(&o.MCR1.Reg, volatile.LoadUint32(&o.MCR1.Reg)&^(0xffff0000)|value<<16)
}
func (o *FlexSPI_Type) GetMCR1_SEQWAIT() uint32 {
	return (volatile.LoadUint32(&o.MCR1.Reg) & 0xffff0000) >> 16
}

// FlexSPI.MCR2: Module Control Register 2
func (o *FlexSPI_Type) SetMCR2_CLRAHBBUFOPT(value uint32) {
	volatile.StoreUint32(&o.MCR2.Reg, volatile.LoadUint32(&o.MCR2.Reg)&^(0x800)|value<<11)
}
func (o *FlexSPI_Type) GetMCR2_CLRAHBBUFOPT() uint32 {
	return (volatile.LoadUint32(&o.MCR2.Reg) & 0x800) >> 11
}
func (o *FlexSPI_Type) SetMCR2_CLRLEARNPHASE(value uint32) {
	volatile.StoreUint32(&o.MCR2.Reg, volatile.LoadUint32(&o.MCR2.Reg)&^(0x4000)|value<<14)
}
func (o *FlexSPI_Type) GetMCR2_CLRLEARNPHASE() uint32 {
	return (volatile.LoadUint32(&o.MCR2.Reg) & 0x4000) >> 14
}
func (o *FlexSPI_Type) SetMCR2_SAMEDEVICEEN(value uint32) {
	volatile.StoreUint32(&o.MCR2.Reg, volatile.LoadUint32(&o.MCR2.Reg)&^(0x8000)|value<<15)
}
func (o *FlexSPI_Type) GetMCR2_SAMEDEVICEEN() uint32 {
	return (volatile.LoadUint32(&o.MCR2.Reg) & 0x8000) >> 15
}
func (o *FlexSPI_Type) SetMCR2_SCKBDIFFOPT(value uint32) {
	volatile.StoreUint32(&o.MCR2.Reg, volatile.LoadUint32(&o.MCR2.Reg)&^(0x80000)|value<<19)
}
func (o *FlexSPI_Type) GetMCR2_SCKBDIFFOPT() uint32 {
	return (volatile.LoadUint32(&o.MCR2.Reg) & 0x80000) >> 19
}
func (o *FlexSPI_Type) SetMCR2_RESUMEWAIT(value uint32) {
	volatile.StoreUint32(&o.MCR2.Reg, volatile.LoadUint32(&o.MCR2.Reg)&^(0xff000000)|value<<24)
}
func (o *FlexSPI_Type) GetMCR2_RESUMEWAIT() uint32 {
	return (volatile.LoadUint32(&o.MCR2.Reg) & 0xff000000) >> 24
}

// FlexSPI.AHBCR: AHB Bus Control Register
func (o *FlexSPI_Type) SetAHBCR_APAREN(value uint32) {
	volatile.StoreUint32(&o.AHBCR.Reg, volatile.LoadUint32(&o.AHBCR.Reg)&^(0x1)|value)
}
func (o *FlexSPI_Type) GetAHBCR_APAREN() uint32 {
	return volatile.LoadUint32(&o.AHBCR.Reg) & 0x1
}
func (o *FlexSPI_Type) SetAHBCR_CLRAHBRXBUF(value uint32) {
	volatile.StoreUint32(&o.AHBCR.Reg, volatile.LoadUint32(&o.AHBCR.Reg)&^(0x2)|value<<1)
}
func (o *FlexSPI_Type) GetAHBCR_CLRAHBRXBUF() uint32 {
	return (volatile.LoadUint32(&o.AHBCR.Reg) & 0x2) >> 1
}
func (o *FlexSPI_Type) SetAHBCR_CLRAHBTXBUF(value uint32) {
	volatile.StoreUint32(&o.AHBCR.Reg, volatile.LoadUint32(&o.AHBCR.Reg)&^(0x4)|value<<2)
}
func (o *FlexSPI_Type) GetAHBCR_CLRAHBTXBUF() uint32 {
	return (volatile.LoadUint32(&o.AHBCR.Reg) & 0x4) >> 2
}
func (o *FlexSPI_Type) SetAHBCR_CACHABLEEN(value uint32) {
	volatile.StoreUint32(&o.AHBCR.Reg, volatile.LoadUint32(&o.AHBCR.Reg)&^(0x8)|value<<3)
}
func (o *FlexSPI_Type) GetAHBCR_CACHABLEEN() uint32 {
	return (volatile.LoadUint32(&o.AHBCR.Reg) & 0x8) >> 3
}
func (o *FlexSPI_Type) SetAHBCR_BUFFERABLEEN(value uint32) {
	volatile.StoreUint32(&o.AHBCR.Reg, volatile.LoadUint32(&o.AHBCR.Reg)&^(0x10)|value<<4)
}
func (o *FlexSPI_Type) GetAHBCR_BUFFERABLEEN() uint32 {
	return (volatile.LoadUint32(&o.AHBCR.Reg) & 0x10) >> 4
}
func (o *FlexSPI_Type) SetAHBCR_PREFETCHEN(value uint32) {
	volatile.StoreUint32(&o.AHBCR.Reg, volatile.LoadUint32(&o.AHBCR.Reg)&^(0x20)|value<<5)
}
func (o *FlexSPI_Type) GetAHBCR_PREFETCHEN() uint32 {
	return (volatile.LoadUint32(&o.AHBCR.Reg) & 0x20) >> 5
}
func (o *FlexSPI_Type) SetAHBCR_READADDROPT(value uint32) {
	volatile.StoreUint32(&o.AHBCR.Reg, volatile.LoadUint32(&o.AHBCR.Reg)&^(0x40)|value<<6)
}
func (o *FlexSPI_Type) GetAHBCR_READADDROPT() uint32 {
	return (volatile.LoadUint32(&o.AHBCR.Reg) & 0x40) >> 6
}
func (o *FlexSPI_Type) SetAHBCR_READSZALIGN(value uint32) {
	volatile.StoreUint32(&o.AHBCR.Reg, volatile.LoadUint32(&o.AHBCR.Reg)&^(0x400)|value<<10)
}
func (o *FlexSPI_Type) GetAHBCR_READSZALIGN() uint32 {
	return (volatile.LoadUint32(&o.AHBCR.Reg) & 0x400) >> 10
}

// FlexSPI.INTEN: Interrupt Enable Register
func (o *FlexSPI_Type) SetINTEN_IPCMDDONEEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1)|value)
}
func (o *FlexSPI_Type) GetINTEN_IPCMDDONEEN() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0x1
}
func (o *FlexSPI_Type) SetINTEN_IPCMDGEEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2)|value<<1)
}
func (o *FlexSPI_Type) GetINTEN_IPCMDGEEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2) >> 1
}
func (o *FlexSPI_Type) SetINTEN_AHBCMDGEEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x4)|value<<2)
}
func (o *FlexSPI_Type) GetINTEN_AHBCMDGEEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x4) >> 2
}
func (o *FlexSPI_Type) SetINTEN_IPCMDERREN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x8)|value<<3)
}
func (o *FlexSPI_Type) GetINTEN_IPCMDERREN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x8) >> 3
}
func (o *FlexSPI_Type) SetINTEN_AHBCMDERREN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x10)|value<<4)
}
func (o *FlexSPI_Type) GetINTEN_AHBCMDERREN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x10) >> 4
}
func (o *FlexSPI_Type) SetINTEN_IPRXWAEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x20)|value<<5)
}
func (o *FlexSPI_Type) GetINTEN_IPRXWAEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x20) >> 5
}
func (o *FlexSPI_Type) SetINTEN_IPTXWEEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x40)|value<<6)
}
func (o *FlexSPI_Type) GetINTEN_IPTXWEEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x40) >> 6
}
func (o *FlexSPI_Type) SetINTEN_SCKSTOPBYRDEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100)|value<<8)
}
func (o *FlexSPI_Type) GetINTEN_SCKSTOPBYRDEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100) >> 8
}
func (o *FlexSPI_Type) SetINTEN_SCKSTOPBYWREN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x200)|value<<9)
}
func (o *FlexSPI_Type) GetINTEN_SCKSTOPBYWREN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x200) >> 9
}
func (o *FlexSPI_Type) SetINTEN_AHBBUSERROREN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x400)|value<<10)
}
func (o *FlexSPI_Type) GetINTEN_AHBBUSERROREN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x400) >> 10
}
func (o *FlexSPI_Type) SetINTEN_SEQTIMEOUTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x800)|value<<11)
}
func (o *FlexSPI_Type) GetINTEN_SEQTIMEOUTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x800) >> 11
}
func (o *FlexSPI_Type) SetINTEN_KEYDONEEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x1000)|value<<12)
}
func (o *FlexSPI_Type) GetINTEN_KEYDONEEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x1000) >> 12
}
func (o *FlexSPI_Type) SetINTEN_KEYERROREN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x2000)|value<<13)
}
func (o *FlexSPI_Type) GetINTEN_KEYERROREN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x2000) >> 13
}

// FlexSPI.INTR: Interrupt Register
func (o *FlexSPI_Type) SetINTR_IPCMDDONE(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x1)|value)
}
func (o *FlexSPI_Type) GetINTR_IPCMDDONE() uint32 {
	return volatile.LoadUint32(&o.INTR.Reg) & 0x1
}
func (o *FlexSPI_Type) SetINTR_IPCMDGE(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x2)|value<<1)
}
func (o *FlexSPI_Type) GetINTR_IPCMDGE() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x2) >> 1
}
func (o *FlexSPI_Type) SetINTR_AHBCMDGE(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x4)|value<<2)
}
func (o *FlexSPI_Type) GetINTR_AHBCMDGE() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x4) >> 2
}
func (o *FlexSPI_Type) SetINTR_IPCMDERR(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x8)|value<<3)
}
func (o *FlexSPI_Type) GetINTR_IPCMDERR() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x8) >> 3
}
func (o *FlexSPI_Type) SetINTR_AHBCMDERR(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x10)|value<<4)
}
func (o *FlexSPI_Type) GetINTR_AHBCMDERR() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x10) >> 4
}
func (o *FlexSPI_Type) SetINTR_IPRXWA(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x20)|value<<5)
}
func (o *FlexSPI_Type) GetINTR_IPRXWA() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x20) >> 5
}
func (o *FlexSPI_Type) SetINTR_IPTXWE(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x40)|value<<6)
}
func (o *FlexSPI_Type) GetINTR_IPTXWE() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x40) >> 6
}
func (o *FlexSPI_Type) SetINTR_SCKSTOPBYRD(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x100)|value<<8)
}
func (o *FlexSPI_Type) GetINTR_SCKSTOPBYRD() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x100) >> 8
}
func (o *FlexSPI_Type) SetINTR_SCKSTOPBYWR(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x200)|value<<9)
}
func (o *FlexSPI_Type) GetINTR_SCKSTOPBYWR() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x200) >> 9
}
func (o *FlexSPI_Type) SetINTR_AHBBUSERROR(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x400)|value<<10)
}
func (o *FlexSPI_Type) GetINTR_AHBBUSERROR() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x400) >> 10
}
func (o *FlexSPI_Type) SetINTR_SEQTIMEOUT(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x800)|value<<11)
}
func (o *FlexSPI_Type) GetINTR_SEQTIMEOUT() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x800) >> 11
}
func (o *FlexSPI_Type) SetINTR_KEYDONE(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x1000)|value<<12)
}
func (o *FlexSPI_Type) GetINTR_KEYDONE() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x1000) >> 12
}
func (o *FlexSPI_Type) SetINTR_KEYERROR(value uint32) {
	volatile.StoreUint32(&o.INTR.Reg, volatile.LoadUint32(&o.INTR.Reg)&^(0x2000)|value<<13)
}
func (o *FlexSPI_Type) GetINTR_KEYERROR() uint32 {
	return (volatile.LoadUint32(&o.INTR.Reg) & 0x2000) >> 13
}

// FlexSPI.LUTKEY: LUT Key Register
func (o *FlexSPI_Type) SetLUTKEY(value uint32) {
	volatile.StoreUint32(&o.LUTKEY.Reg, value)
}
func (o *FlexSPI_Type) GetLUTKEY() uint32 {
	return volatile.LoadUint32(&o.LUTKEY.Reg)
}

// FlexSPI.LUTCR: LUT Control Register
func (o *FlexSPI_Type) SetLUTCR_LOCK(value uint32) {
	volatile.StoreUint32(&o.LUTCR.Reg, volatile.LoadUint32(&o.LUTCR.Reg)&^(0x1)|value)
}
func (o *FlexSPI_Type) GetLUTCR_LOCK() uint32 {
	return volatile.LoadUint32(&o.LUTCR.Reg) & 0x1
}
func (o *FlexSPI_Type) SetLUTCR_UNLOCK(value uint32) {
	volatile.StoreUint32(&o.LUTCR.Reg, volatile.LoadUint32(&o.LUTCR.Reg)&^(0x2)|value<<1)
}
func (o *FlexSPI_Type) GetLUTCR_UNLOCK() uint32 {
	return (volatile.LoadUint32(&o.LUTCR.Reg) & 0x2) >> 1
}

// FlexSPI.AHBRXBUF0CR0: AHB RX Buffer 0 Control Register 0
func (o *FlexSPI_Type) SetAHBRXBUF0CR0_BUFSZ(value uint32) {
	volatile.StoreUint32(&o.AHBRXBUF0CR0.Reg, volatile.LoadUint32(&o.AHBRXBUF0CR0.Reg)&^(0xff)|value)
}
func (o *FlexSPI_Type) GetAHBRXBUF0CR0_BUFSZ() uint32 {
	return volatile.LoadUint32(&o.AHBRXBUF0CR0.Reg) & 0xff
}
func (o *FlexSPI_Type) SetAHBRXBUF0CR0_MSTRID(value uint32) {
	volatile.StoreUint32(&o.AHBRXBUF0CR0.Reg, volatile.LoadUint32(&o.AHBRXBUF0CR0.Reg)&^(0xf0000)|value<<16)
}
func (o *FlexSPI_Type) GetAHBRXBUF0CR0_MSTRID() uint32 {
	return (volatile.LoadUint32(&o.AHBRXBUF0CR0.Reg) & 0xf0000) >> 16
}
func (o *FlexSPI_Type) SetAHBRXBUF0CR0_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.AHBRXBUF0CR0.Reg, volatile.LoadUint32(&o.AHBRXBUF0CR0.Reg)&^(0x3000000)|value<<24)
}
func (o *FlexSPI_Type) GetAHBRXBUF0CR0_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.AHBRXBUF0CR0.Reg) & 0x3000000) >> 24
}
func (o *FlexSPI_Type) SetAHBRXBUF0CR0_PREFETCHEN(value uint32) {
	volatile.StoreUint32(&o.AHBRXBUF0CR0.Reg, volatile.LoadUint32(&o.AHBRXBUF0CR0.Reg)&^(0x80000000)|value<<31)
}
func (o *FlexSPI_Type) GetAHBRXBUF0CR0_PREFETCHEN() uint32 {
	return (volatile.LoadUint32(&o.AHBRXBUF0CR0.Reg) & 0x80000000) >> 31
}

// FlexSPI.AHBRXBUF1CR0: AHB RX Buffer 1 Control Register 0
func (o *FlexSPI_Type) SetAHBRXBUF1CR0_BUFSZ(value uint32) {
	volatile.StoreUint32(&o.AHBRXBUF1CR0.Reg, volatile.LoadUint32(&o.AHBRXBUF1CR0.Reg)&^(0xff)|value)
}
func (o *FlexSPI_Type) GetAHBRXBUF1CR0_BUFSZ() uint32 {
	return volatile.LoadUint32(&o.AHBRXBUF1CR0.Reg) & 0xff
}
func (o *FlexSPI_Type) SetAHBRXBUF1CR0_MSTRID(value uint32) {
	volatile.StoreUint32(&o.AHBRXBUF1CR0.Reg, volatile.LoadUint32(&o.AHBRXBUF1CR0.Reg)&^(0xf0000)|value<<16)
}
func (o *FlexSPI_Type) GetAHBRXBUF1CR0_MSTRID() uint32 {
	return (volatile.LoadUint32(&o.AHBRXBUF1CR0.Reg) & 0xf0000) >> 16
}
func (o *FlexSPI_Type) SetAHBRXBUF1CR0_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.AHBRXBUF1CR0.Reg, volatile.LoadUint32(&o.AHBRXBUF1CR0.Reg)&^(0x3000000)|value<<24)
}
func (o *FlexSPI_Type) GetAHBRXBUF1CR0_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.AHBRXBUF1CR0.Reg) & 0x3000000) >> 24
}
func (o *FlexSPI_Type) SetAHBRXBUF1CR0_PREFETCHEN(value uint32) {
	volatile.StoreUint32(&o.AHBRXBUF1CR0.Reg, volatile.LoadUint32(&o.AHBRXBUF1CR0.Reg)&^(0x80000000)|value<<31)
}
func (o *FlexSPI_Type) GetAHBRXBUF1CR0_PREFETCHEN() uint32 {
	return (volatile.LoadUint32(&o.AHBRXBUF1CR0.Reg) & 0x80000000) >> 31
}

// FlexSPI.AHBRXBUF2CR0: AHB RX Buffer 2 Control Register 0
func (o *FlexSPI_Type) SetAHBRXBUF2CR0_BUFSZ(value uint32) {
	volatile.StoreUint32(&o.AHBRXBUF2CR0.Reg, volatile.LoadUint32(&o.AHBRXBUF2CR0.Reg)&^(0xff)|value)
}
func (o *FlexSPI_Type) GetAHBRXBUF2CR0_BUFSZ() uint32 {
	return volatile.LoadUint32(&o.AHBRXBUF2CR0.Reg) & 0xff
}
func (o *FlexSPI_Type) SetAHBRXBUF2CR0_MSTRID(value uint32) {
	volatile.StoreUint32(&o.AHBRXBUF2CR0.Reg, volatile.LoadUint32(&o.AHBRXBUF2CR0.Reg)&^(0xf0000)|value<<16)
}
func (o *FlexSPI_Type) GetAHBRXBUF2CR0_MSTRID() uint32 {
	return (volatile.LoadUint32(&o.AHBRXBUF2CR0.Reg) & 0xf0000) >> 16
}
func (o *FlexSPI_Type) SetAHBRXBUF2CR0_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.AHBRXBUF2CR0.Reg, volatile.LoadUint32(&o.AHBRXBUF2CR0.Reg)&^(0x3000000)|value<<24)
}
func (o *FlexSPI_Type) GetAHBRXBUF2CR0_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.AHBRXBUF2CR0.Reg) & 0x3000000) >> 24
}
func (o *FlexSPI_Type) SetAHBRXBUF2CR0_PREFETCHEN(value uint32) {
	volatile.StoreUint32(&o.AHBRXBUF2CR0.Reg, volatile.LoadUint32(&o.AHBRXBUF2CR0.Reg)&^(0x80000000)|value<<31)
}
func (o *FlexSPI_Type) GetAHBRXBUF2CR0_PREFETCHEN() uint32 {
	return (volatile.LoadUint32(&o.AHBRXBUF2CR0.Reg) & 0x80000000) >> 31
}

// FlexSPI.AHBRXBUF3CR0: AHB RX Buffer 3 Control Register 0
func (o *FlexSPI_Type) SetAHBRXBUF3CR0_BUFSZ(value uint32) {
	volatile.StoreUint32(&o.AHBRXBUF3CR0.Reg, volatile.LoadUint32(&o.AHBRXBUF3CR0.Reg)&^(0xff)|value)
}
func (o *FlexSPI_Type) GetAHBRXBUF3CR0_BUFSZ() uint32 {
	return volatile.LoadUint32(&o.AHBRXBUF3CR0.Reg) & 0xff
}
func (o *FlexSPI_Type) SetAHBRXBUF3CR0_MSTRID(value uint32) {
	volatile.StoreUint32(&o.AHBRXBUF3CR0.Reg, volatile.LoadUint32(&o.AHBRXBUF3CR0.Reg)&^(0xf0000)|value<<16)
}
func (o *FlexSPI_Type) GetAHBRXBUF3CR0_MSTRID() uint32 {
	return (volatile.LoadUint32(&o.AHBRXBUF3CR0.Reg) & 0xf0000) >> 16
}
func (o *FlexSPI_Type) SetAHBRXBUF3CR0_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.AHBRXBUF3CR0.Reg, volatile.LoadUint32(&o.AHBRXBUF3CR0.Reg)&^(0x3000000)|value<<24)
}
func (o *FlexSPI_Type) GetAHBRXBUF3CR0_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.AHBRXBUF3CR0.Reg) & 0x3000000) >> 24
}
func (o *FlexSPI_Type) SetAHBRXBUF3CR0_PREFETCHEN(value uint32) {
	volatile.StoreUint32(&o.AHBRXBUF3CR0.Reg, volatile.LoadUint32(&o.AHBRXBUF3CR0.Reg)&^(0x80000000)|value<<31)
}
func (o *FlexSPI_Type) GetAHBRXBUF3CR0_PREFETCHEN() uint32 {
	return (volatile.LoadUint32(&o.AHBRXBUF3CR0.Reg) & 0x80000000) >> 31
}

// FlexSPI.FLSHA1CR0: Flash Control Register 0
func (o *FlexSPI_Type) SetFLSHA1CR0_FLSHSZ(value uint32) {
	volatile.StoreUint32(&o.FLSHA1CR0.Reg, volatile.LoadUint32(&o.FLSHA1CR0.Reg)&^(0x7fffff)|value)
}
func (o *FlexSPI_Type) GetFLSHA1CR0_FLSHSZ() uint32 {
	return volatile.LoadUint32(&o.FLSHA1CR0.Reg) & 0x7fffff
}

// FlexSPI.FLSHA2CR0: Flash Control Register 0
func (o *FlexSPI_Type) SetFLSHA2CR0_FLSHSZ(value uint32) {
	volatile.StoreUint32(&o.FLSHA2CR0.Reg, volatile.LoadUint32(&o.FLSHA2CR0.Reg)&^(0x7fffff)|value)
}
func (o *FlexSPI_Type) GetFLSHA2CR0_FLSHSZ() uint32 {
	return volatile.LoadUint32(&o.FLSHA2CR0.Reg) & 0x7fffff
}

// FlexSPI.FLSHB1CR0: Flash Control Register 0
func (o *FlexSPI_Type) SetFLSHB1CR0_FLSHSZ(value uint32) {
	volatile.StoreUint32(&o.FLSHB1CR0.Reg, volatile.LoadUint32(&o.FLSHB1CR0.Reg)&^(0x7fffff)|value)
}
func (o *FlexSPI_Type) GetFLSHB1CR0_FLSHSZ() uint32 {
	return volatile.LoadUint32(&o.FLSHB1CR0.Reg) & 0x7fffff
}

// FlexSPI.FLSHB2CR0: Flash Control Register 0
func (o *FlexSPI_Type) SetFLSHB2CR0_FLSHSZ(value uint32) {
	volatile.StoreUint32(&o.FLSHB2CR0.Reg, volatile.LoadUint32(&o.FLSHB2CR0.Reg)&^(0x7fffff)|value)
}
func (o *FlexSPI_Type) GetFLSHB2CR0_FLSHSZ() uint32 {
	return volatile.LoadUint32(&o.FLSHB2CR0.Reg) & 0x7fffff
}

// FlexSPI.FLSHCR1A1: Flash Control Register 1
func (o *FlexSPI_Type) SetFLSHCR1A1_TCSS(value uint32) {
	volatile.StoreUint32(&o.FLSHCR1A1.Reg, volatile.LoadUint32(&o.FLSHCR1A1.Reg)&^(0x1f)|value)
}
func (o *FlexSPI_Type) GetFLSHCR1A1_TCSS() uint32 {
	return volatile.LoadUint32(&o.FLSHCR1A1.Reg) & 0x1f
}
func (o *FlexSPI_Type) SetFLSHCR1A1_TCSH(value uint32) {
	volatile.StoreUint32(&o.FLSHCR1A1.Reg, volatile.LoadUint32(&o.FLSHCR1A1.Reg)&^(0x3e0)|value<<5)
}
func (o *FlexSPI_Type) GetFLSHCR1A1_TCSH() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR1A1.Reg) & 0x3e0) >> 5
}
func (o *FlexSPI_Type) SetFLSHCR1A1_WA(value uint32) {
	volatile.StoreUint32(&o.FLSHCR1A1.Reg, volatile.LoadUint32(&o.FLSHCR1A1.Reg)&^(0x400)|value<<10)
}
func (o *FlexSPI_Type) GetFLSHCR1A1_WA() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR1A1.Reg) & 0x400) >> 10
}
func (o *FlexSPI_Type) SetFLSHCR1A1_CAS(value uint32) {
	volatile.StoreUint32(&o.FLSHCR1A1.Reg, volatile.LoadUint32(&o.FLSHCR1A1.Reg)&^(0x7800)|value<<11)
}
func (o *FlexSPI_Type) GetFLSHCR1A1_CAS() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR1A1.Reg) & 0x7800) >> 11
}
func (o *FlexSPI_Type) SetFLSHCR1A1_CSINTERVALUNIT(value uint32) {
	volatile.StoreUint32(&o.FLSHCR1A1.Reg, volatile.LoadUint32(&o.FLSHCR1A1.Reg)&^(0x8000)|value<<15)
}
func (o *FlexSPI_Type) GetFLSHCR1A1_CSINTERVALUNIT() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR1A1.Reg) & 0x8000) >> 15
}
func (o *FlexSPI_Type) SetFLSHCR1A1_CSINTERVAL(value uint32) {
	volatile.StoreUint32(&o.FLSHCR1A1.Reg, volatile.LoadUint32(&o.FLSHCR1A1.Reg)&^(0xffff0000)|value<<16)
}
func (o *FlexSPI_Type) GetFLSHCR1A1_CSINTERVAL() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR1A1.Reg) & 0xffff0000) >> 16
}

// FlexSPI.FLSHCR1A2: Flash Control Register 1
func (o *FlexSPI_Type) SetFLSHCR1A2_TCSS(value uint32) {
	volatile.StoreUint32(&o.FLSHCR1A2.Reg, volatile.LoadUint32(&o.FLSHCR1A2.Reg)&^(0x1f)|value)
}
func (o *FlexSPI_Type) GetFLSHCR1A2_TCSS() uint32 {
	return volatile.LoadUint32(&o.FLSHCR1A2.Reg) & 0x1f
}
func (o *FlexSPI_Type) SetFLSHCR1A2_TCSH(value uint32) {
	volatile.StoreUint32(&o.FLSHCR1A2.Reg, volatile.LoadUint32(&o.FLSHCR1A2.Reg)&^(0x3e0)|value<<5)
}
func (o *FlexSPI_Type) GetFLSHCR1A2_TCSH() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR1A2.Reg) & 0x3e0) >> 5
}
func (o *FlexSPI_Type) SetFLSHCR1A2_WA(value uint32) {
	volatile.StoreUint32(&o.FLSHCR1A2.Reg, volatile.LoadUint32(&o.FLSHCR1A2.Reg)&^(0x400)|value<<10)
}
func (o *FlexSPI_Type) GetFLSHCR1A2_WA() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR1A2.Reg) & 0x400) >> 10
}
func (o *FlexSPI_Type) SetFLSHCR1A2_CAS(value uint32) {
	volatile.StoreUint32(&o.FLSHCR1A2.Reg, volatile.LoadUint32(&o.FLSHCR1A2.Reg)&^(0x7800)|value<<11)
}
func (o *FlexSPI_Type) GetFLSHCR1A2_CAS() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR1A2.Reg) & 0x7800) >> 11
}
func (o *FlexSPI_Type) SetFLSHCR1A2_CSINTERVALUNIT(value uint32) {
	volatile.StoreUint32(&o.FLSHCR1A2.Reg, volatile.LoadUint32(&o.FLSHCR1A2.Reg)&^(0x8000)|value<<15)
}
func (o *FlexSPI_Type) GetFLSHCR1A2_CSINTERVALUNIT() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR1A2.Reg) & 0x8000) >> 15
}
func (o *FlexSPI_Type) SetFLSHCR1A2_CSINTERVAL(value uint32) {
	volatile.StoreUint32(&o.FLSHCR1A2.Reg, volatile.LoadUint32(&o.FLSHCR1A2.Reg)&^(0xffff0000)|value<<16)
}
func (o *FlexSPI_Type) GetFLSHCR1A2_CSINTERVAL() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR1A2.Reg) & 0xffff0000) >> 16
}

// FlexSPI.FLSHCR1B1: Flash Control Register 1
func (o *FlexSPI_Type) SetFLSHCR1B1_TCSS(value uint32) {
	volatile.StoreUint32(&o.FLSHCR1B1.Reg, volatile.LoadUint32(&o.FLSHCR1B1.Reg)&^(0x1f)|value)
}
func (o *FlexSPI_Type) GetFLSHCR1B1_TCSS() uint32 {
	return volatile.LoadUint32(&o.FLSHCR1B1.Reg) & 0x1f
}
func (o *FlexSPI_Type) SetFLSHCR1B1_TCSH(value uint32) {
	volatile.StoreUint32(&o.FLSHCR1B1.Reg, volatile.LoadUint32(&o.FLSHCR1B1.Reg)&^(0x3e0)|value<<5)
}
func (o *FlexSPI_Type) GetFLSHCR1B1_TCSH() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR1B1.Reg) & 0x3e0) >> 5
}
func (o *FlexSPI_Type) SetFLSHCR1B1_WA(value uint32) {
	volatile.StoreUint32(&o.FLSHCR1B1.Reg, volatile.LoadUint32(&o.FLSHCR1B1.Reg)&^(0x400)|value<<10)
}
func (o *FlexSPI_Type) GetFLSHCR1B1_WA() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR1B1.Reg) & 0x400) >> 10
}
func (o *FlexSPI_Type) SetFLSHCR1B1_CAS(value uint32) {
	volatile.StoreUint32(&o.FLSHCR1B1.Reg, volatile.LoadUint32(&o.FLSHCR1B1.Reg)&^(0x7800)|value<<11)
}
func (o *FlexSPI_Type) GetFLSHCR1B1_CAS() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR1B1.Reg) & 0x7800) >> 11
}
func (o *FlexSPI_Type) SetFLSHCR1B1_CSINTERVALUNIT(value uint32) {
	volatile.StoreUint32(&o.FLSHCR1B1.Reg, volatile.LoadUint32(&o.FLSHCR1B1.Reg)&^(0x8000)|value<<15)
}
func (o *FlexSPI_Type) GetFLSHCR1B1_CSINTERVALUNIT() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR1B1.Reg) & 0x8000) >> 15
}
func (o *FlexSPI_Type) SetFLSHCR1B1_CSINTERVAL(value uint32) {
	volatile.StoreUint32(&o.FLSHCR1B1.Reg, volatile.LoadUint32(&o.FLSHCR1B1.Reg)&^(0xffff0000)|value<<16)
}
func (o *FlexSPI_Type) GetFLSHCR1B1_CSINTERVAL() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR1B1.Reg) & 0xffff0000) >> 16
}

// FlexSPI.FLSHCR1B2: Flash Control Register 1
func (o *FlexSPI_Type) SetFLSHCR1B2_TCSS(value uint32) {
	volatile.StoreUint32(&o.FLSHCR1B2.Reg, volatile.LoadUint32(&o.FLSHCR1B2.Reg)&^(0x1f)|value)
}
func (o *FlexSPI_Type) GetFLSHCR1B2_TCSS() uint32 {
	return volatile.LoadUint32(&o.FLSHCR1B2.Reg) & 0x1f
}
func (o *FlexSPI_Type) SetFLSHCR1B2_TCSH(value uint32) {
	volatile.StoreUint32(&o.FLSHCR1B2.Reg, volatile.LoadUint32(&o.FLSHCR1B2.Reg)&^(0x3e0)|value<<5)
}
func (o *FlexSPI_Type) GetFLSHCR1B2_TCSH() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR1B2.Reg) & 0x3e0) >> 5
}
func (o *FlexSPI_Type) SetFLSHCR1B2_WA(value uint32) {
	volatile.StoreUint32(&o.FLSHCR1B2.Reg, volatile.LoadUint32(&o.FLSHCR1B2.Reg)&^(0x400)|value<<10)
}
func (o *FlexSPI_Type) GetFLSHCR1B2_WA() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR1B2.Reg) & 0x400) >> 10
}
func (o *FlexSPI_Type) SetFLSHCR1B2_CAS(value uint32) {
	volatile.StoreUint32(&o.FLSHCR1B2.Reg, volatile.LoadUint32(&o.FLSHCR1B2.Reg)&^(0x7800)|value<<11)
}
func (o *FlexSPI_Type) GetFLSHCR1B2_CAS() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR1B2.Reg) & 0x7800) >> 11
}
func (o *FlexSPI_Type) SetFLSHCR1B2_CSINTERVALUNIT(value uint32) {
	volatile.StoreUint32(&o.FLSHCR1B2.Reg, volatile.LoadUint32(&o.FLSHCR1B2.Reg)&^(0x8000)|value<<15)
}
func (o *FlexSPI_Type) GetFLSHCR1B2_CSINTERVALUNIT() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR1B2.Reg) & 0x8000) >> 15
}
func (o *FlexSPI_Type) SetFLSHCR1B2_CSINTERVAL(value uint32) {
	volatile.StoreUint32(&o.FLSHCR1B2.Reg, volatile.LoadUint32(&o.FLSHCR1B2.Reg)&^(0xffff0000)|value<<16)
}
func (o *FlexSPI_Type) GetFLSHCR1B2_CSINTERVAL() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR1B2.Reg) & 0xffff0000) >> 16
}

// FlexSPI.FLSHCR2A1: Flash Control Register 2
func (o *FlexSPI_Type) SetFLSHCR2A1_ARDSEQID(value uint32) {
	volatile.StoreUint32(&o.FLSHCR2A1.Reg, volatile.LoadUint32(&o.FLSHCR2A1.Reg)&^(0xf)|value)
}
func (o *FlexSPI_Type) GetFLSHCR2A1_ARDSEQID() uint32 {
	return volatile.LoadUint32(&o.FLSHCR2A1.Reg) & 0xf
}
func (o *FlexSPI_Type) SetFLSHCR2A1_ARDSEQNUM(value uint32) {
	volatile.StoreUint32(&o.FLSHCR2A1.Reg, volatile.LoadUint32(&o.FLSHCR2A1.Reg)&^(0xe0)|value<<5)
}
func (o *FlexSPI_Type) GetFLSHCR2A1_ARDSEQNUM() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR2A1.Reg) & 0xe0) >> 5
}
func (o *FlexSPI_Type) SetFLSHCR2A1_AWRSEQID(value uint32) {
	volatile.StoreUint32(&o.FLSHCR2A1.Reg, volatile.LoadUint32(&o.FLSHCR2A1.Reg)&^(0xf00)|value<<8)
}
func (o *FlexSPI_Type) GetFLSHCR2A1_AWRSEQID() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR2A1.Reg) & 0xf00) >> 8
}
func (o *FlexSPI_Type) SetFLSHCR2A1_AWRSEQNUM(value uint32) {
	volatile.StoreUint32(&o.FLSHCR2A1.Reg, volatile.LoadUint32(&o.FLSHCR2A1.Reg)&^(0xe000)|value<<13)
}
func (o *FlexSPI_Type) GetFLSHCR2A1_AWRSEQNUM() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR2A1.Reg) & 0xe000) >> 13
}
func (o *FlexSPI_Type) SetFLSHCR2A1_AWRWAIT(value uint32) {
	volatile.StoreUint32(&o.FLSHCR2A1.Reg, volatile.LoadUint32(&o.FLSHCR2A1.Reg)&^(0xfff0000)|value<<16)
}
func (o *FlexSPI_Type) GetFLSHCR2A1_AWRWAIT() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR2A1.Reg) & 0xfff0000) >> 16
}
func (o *FlexSPI_Type) SetFLSHCR2A1_AWRWAITUNIT(value uint32) {
	volatile.StoreUint32(&o.FLSHCR2A1.Reg, volatile.LoadUint32(&o.FLSHCR2A1.Reg)&^(0x70000000)|value<<28)
}
func (o *FlexSPI_Type) GetFLSHCR2A1_AWRWAITUNIT() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR2A1.Reg) & 0x70000000) >> 28
}
func (o *FlexSPI_Type) SetFLSHCR2A1_CLRINSTRPTR(value uint32) {
	volatile.StoreUint32(&o.FLSHCR2A1.Reg, volatile.LoadUint32(&o.FLSHCR2A1.Reg)&^(0x80000000)|value<<31)
}
func (o *FlexSPI_Type) GetFLSHCR2A1_CLRINSTRPTR() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR2A1.Reg) & 0x80000000) >> 31
}

// FlexSPI.FLSHCR2A2: Flash Control Register 2
func (o *FlexSPI_Type) SetFLSHCR2A2_ARDSEQID(value uint32) {
	volatile.StoreUint32(&o.FLSHCR2A2.Reg, volatile.LoadUint32(&o.FLSHCR2A2.Reg)&^(0xf)|value)
}
func (o *FlexSPI_Type) GetFLSHCR2A2_ARDSEQID() uint32 {
	return volatile.LoadUint32(&o.FLSHCR2A2.Reg) & 0xf
}
func (o *FlexSPI_Type) SetFLSHCR2A2_ARDSEQNUM(value uint32) {
	volatile.StoreUint32(&o.FLSHCR2A2.Reg, volatile.LoadUint32(&o.FLSHCR2A2.Reg)&^(0xe0)|value<<5)
}
func (o *FlexSPI_Type) GetFLSHCR2A2_ARDSEQNUM() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR2A2.Reg) & 0xe0) >> 5
}
func (o *FlexSPI_Type) SetFLSHCR2A2_AWRSEQID(value uint32) {
	volatile.StoreUint32(&o.FLSHCR2A2.Reg, volatile.LoadUint32(&o.FLSHCR2A2.Reg)&^(0xf00)|value<<8)
}
func (o *FlexSPI_Type) GetFLSHCR2A2_AWRSEQID() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR2A2.Reg) & 0xf00) >> 8
}
func (o *FlexSPI_Type) SetFLSHCR2A2_AWRSEQNUM(value uint32) {
	volatile.StoreUint32(&o.FLSHCR2A2.Reg, volatile.LoadUint32(&o.FLSHCR2A2.Reg)&^(0xe000)|value<<13)
}
func (o *FlexSPI_Type) GetFLSHCR2A2_AWRSEQNUM() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR2A2.Reg) & 0xe000) >> 13
}
func (o *FlexSPI_Type) SetFLSHCR2A2_AWRWAIT(value uint32) {
	volatile.StoreUint32(&o.FLSHCR2A2.Reg, volatile.LoadUint32(&o.FLSHCR2A2.Reg)&^(0xfff0000)|value<<16)
}
func (o *FlexSPI_Type) GetFLSHCR2A2_AWRWAIT() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR2A2.Reg) & 0xfff0000) >> 16
}
func (o *FlexSPI_Type) SetFLSHCR2A2_AWRWAITUNIT(value uint32) {
	volatile.StoreUint32(&o.FLSHCR2A2.Reg, volatile.LoadUint32(&o.FLSHCR2A2.Reg)&^(0x70000000)|value<<28)
}
func (o *FlexSPI_Type) GetFLSHCR2A2_AWRWAITUNIT() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR2A2.Reg) & 0x70000000) >> 28
}
func (o *FlexSPI_Type) SetFLSHCR2A2_CLRINSTRPTR(value uint32) {
	volatile.StoreUint32(&o.FLSHCR2A2.Reg, volatile.LoadUint32(&o.FLSHCR2A2.Reg)&^(0x80000000)|value<<31)
}
func (o *FlexSPI_Type) GetFLSHCR2A2_CLRINSTRPTR() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR2A2.Reg) & 0x80000000) >> 31
}

// FlexSPI.FLSHCR2B1: Flash Control Register 2
func (o *FlexSPI_Type) SetFLSHCR2B1_ARDSEQID(value uint32) {
	volatile.StoreUint32(&o.FLSHCR2B1.Reg, volatile.LoadUint32(&o.FLSHCR2B1.Reg)&^(0xf)|value)
}
func (o *FlexSPI_Type) GetFLSHCR2B1_ARDSEQID() uint32 {
	return volatile.LoadUint32(&o.FLSHCR2B1.Reg) & 0xf
}
func (o *FlexSPI_Type) SetFLSHCR2B1_ARDSEQNUM(value uint32) {
	volatile.StoreUint32(&o.FLSHCR2B1.Reg, volatile.LoadUint32(&o.FLSHCR2B1.Reg)&^(0xe0)|value<<5)
}
func (o *FlexSPI_Type) GetFLSHCR2B1_ARDSEQNUM() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR2B1.Reg) & 0xe0) >> 5
}
func (o *FlexSPI_Type) SetFLSHCR2B1_AWRSEQID(value uint32) {
	volatile.StoreUint32(&o.FLSHCR2B1.Reg, volatile.LoadUint32(&o.FLSHCR2B1.Reg)&^(0xf00)|value<<8)
}
func (o *FlexSPI_Type) GetFLSHCR2B1_AWRSEQID() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR2B1.Reg) & 0xf00) >> 8
}
func (o *FlexSPI_Type) SetFLSHCR2B1_AWRSEQNUM(value uint32) {
	volatile.StoreUint32(&o.FLSHCR2B1.Reg, volatile.LoadUint32(&o.FLSHCR2B1.Reg)&^(0xe000)|value<<13)
}
func (o *FlexSPI_Type) GetFLSHCR2B1_AWRSEQNUM() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR2B1.Reg) & 0xe000) >> 13
}
func (o *FlexSPI_Type) SetFLSHCR2B1_AWRWAIT(value uint32) {
	volatile.StoreUint32(&o.FLSHCR2B1.Reg, volatile.LoadUint32(&o.FLSHCR2B1.Reg)&^(0xfff0000)|value<<16)
}
func (o *FlexSPI_Type) GetFLSHCR2B1_AWRWAIT() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR2B1.Reg) & 0xfff0000) >> 16
}
func (o *FlexSPI_Type) SetFLSHCR2B1_AWRWAITUNIT(value uint32) {
	volatile.StoreUint32(&o.FLSHCR2B1.Reg, volatile.LoadUint32(&o.FLSHCR2B1.Reg)&^(0x70000000)|value<<28)
}
func (o *FlexSPI_Type) GetFLSHCR2B1_AWRWAITUNIT() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR2B1.Reg) & 0x70000000) >> 28
}
func (o *FlexSPI_Type) SetFLSHCR2B1_CLRINSTRPTR(value uint32) {
	volatile.StoreUint32(&o.FLSHCR2B1.Reg, volatile.LoadUint32(&o.FLSHCR2B1.Reg)&^(0x80000000)|value<<31)
}
func (o *FlexSPI_Type) GetFLSHCR2B1_CLRINSTRPTR() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR2B1.Reg) & 0x80000000) >> 31
}

// FlexSPI.FLSHCR2B2: Flash Control Register 2
func (o *FlexSPI_Type) SetFLSHCR2B2_ARDSEQID(value uint32) {
	volatile.StoreUint32(&o.FLSHCR2B2.Reg, volatile.LoadUint32(&o.FLSHCR2B2.Reg)&^(0xf)|value)
}
func (o *FlexSPI_Type) GetFLSHCR2B2_ARDSEQID() uint32 {
	return volatile.LoadUint32(&o.FLSHCR2B2.Reg) & 0xf
}
func (o *FlexSPI_Type) SetFLSHCR2B2_ARDSEQNUM(value uint32) {
	volatile.StoreUint32(&o.FLSHCR2B2.Reg, volatile.LoadUint32(&o.FLSHCR2B2.Reg)&^(0xe0)|value<<5)
}
func (o *FlexSPI_Type) GetFLSHCR2B2_ARDSEQNUM() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR2B2.Reg) & 0xe0) >> 5
}
func (o *FlexSPI_Type) SetFLSHCR2B2_AWRSEQID(value uint32) {
	volatile.StoreUint32(&o.FLSHCR2B2.Reg, volatile.LoadUint32(&o.FLSHCR2B2.Reg)&^(0xf00)|value<<8)
}
func (o *FlexSPI_Type) GetFLSHCR2B2_AWRSEQID() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR2B2.Reg) & 0xf00) >> 8
}
func (o *FlexSPI_Type) SetFLSHCR2B2_AWRSEQNUM(value uint32) {
	volatile.StoreUint32(&o.FLSHCR2B2.Reg, volatile.LoadUint32(&o.FLSHCR2B2.Reg)&^(0xe000)|value<<13)
}
func (o *FlexSPI_Type) GetFLSHCR2B2_AWRSEQNUM() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR2B2.Reg) & 0xe000) >> 13
}
func (o *FlexSPI_Type) SetFLSHCR2B2_AWRWAIT(value uint32) {
	volatile.StoreUint32(&o.FLSHCR2B2.Reg, volatile.LoadUint32(&o.FLSHCR2B2.Reg)&^(0xfff0000)|value<<16)
}
func (o *FlexSPI_Type) GetFLSHCR2B2_AWRWAIT() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR2B2.Reg) & 0xfff0000) >> 16
}
func (o *FlexSPI_Type) SetFLSHCR2B2_AWRWAITUNIT(value uint32) {
	volatile.StoreUint32(&o.FLSHCR2B2.Reg, volatile.LoadUint32(&o.FLSHCR2B2.Reg)&^(0x70000000)|value<<28)
}
func (o *FlexSPI_Type) GetFLSHCR2B2_AWRWAITUNIT() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR2B2.Reg) & 0x70000000) >> 28
}
func (o *FlexSPI_Type) SetFLSHCR2B2_CLRINSTRPTR(value uint32) {
	volatile.StoreUint32(&o.FLSHCR2B2.Reg, volatile.LoadUint32(&o.FLSHCR2B2.Reg)&^(0x80000000)|value<<31)
}
func (o *FlexSPI_Type) GetFLSHCR2B2_CLRINSTRPTR() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR2B2.Reg) & 0x80000000) >> 31
}

// FlexSPI.FLSHCR4: Flash Control Register 4
func (o *FlexSPI_Type) SetFLSHCR4_WMOPT1(value uint32) {
	volatile.StoreUint32(&o.FLSHCR4.Reg, volatile.LoadUint32(&o.FLSHCR4.Reg)&^(0x1)|value)
}
func (o *FlexSPI_Type) GetFLSHCR4_WMOPT1() uint32 {
	return volatile.LoadUint32(&o.FLSHCR4.Reg) & 0x1
}
func (o *FlexSPI_Type) SetFLSHCR4_WMENA(value uint32) {
	volatile.StoreUint32(&o.FLSHCR4.Reg, volatile.LoadUint32(&o.FLSHCR4.Reg)&^(0x4)|value<<2)
}
func (o *FlexSPI_Type) GetFLSHCR4_WMENA() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR4.Reg) & 0x4) >> 2
}
func (o *FlexSPI_Type) SetFLSHCR4_WMENB(value uint32) {
	volatile.StoreUint32(&o.FLSHCR4.Reg, volatile.LoadUint32(&o.FLSHCR4.Reg)&^(0x8)|value<<3)
}
func (o *FlexSPI_Type) GetFLSHCR4_WMENB() uint32 {
	return (volatile.LoadUint32(&o.FLSHCR4.Reg) & 0x8) >> 3
}

// FlexSPI.IPCR0: IP Control Register 0
func (o *FlexSPI_Type) SetIPCR0(value uint32) {
	volatile.StoreUint32(&o.IPCR0.Reg, value)
}
func (o *FlexSPI_Type) GetIPCR0() uint32 {
	return volatile.LoadUint32(&o.IPCR0.Reg)
}

// FlexSPI.IPCR1: IP Control Register 1
func (o *FlexSPI_Type) SetIPCR1_IDATSZ(value uint32) {
	volatile.StoreUint32(&o.IPCR1.Reg, volatile.LoadUint32(&o.IPCR1.Reg)&^(0xffff)|value)
}
func (o *FlexSPI_Type) GetIPCR1_IDATSZ() uint32 {
	return volatile.LoadUint32(&o.IPCR1.Reg) & 0xffff
}
func (o *FlexSPI_Type) SetIPCR1_ISEQID(value uint32) {
	volatile.StoreUint32(&o.IPCR1.Reg, volatile.LoadUint32(&o.IPCR1.Reg)&^(0xf0000)|value<<16)
}
func (o *FlexSPI_Type) GetIPCR1_ISEQID() uint32 {
	return (volatile.LoadUint32(&o.IPCR1.Reg) & 0xf0000) >> 16
}
func (o *FlexSPI_Type) SetIPCR1_ISEQNUM(value uint32) {
	volatile.StoreUint32(&o.IPCR1.Reg, volatile.LoadUint32(&o.IPCR1.Reg)&^(0x7000000)|value<<24)
}
func (o *FlexSPI_Type) GetIPCR1_ISEQNUM() uint32 {
	return (volatile.LoadUint32(&o.IPCR1.Reg) & 0x7000000) >> 24
}
func (o *FlexSPI_Type) SetIPCR1_IPAREN(value uint32) {
	volatile.StoreUint32(&o.IPCR1.Reg, volatile.LoadUint32(&o.IPCR1.Reg)&^(0x80000000)|value<<31)
}
func (o *FlexSPI_Type) GetIPCR1_IPAREN() uint32 {
	return (volatile.LoadUint32(&o.IPCR1.Reg) & 0x80000000) >> 31
}

// FlexSPI.IPCMD: IP Command Register
func (o *FlexSPI_Type) SetIPCMD_TRG(value uint32) {
	volatile.StoreUint32(&o.IPCMD.Reg, volatile.LoadUint32(&o.IPCMD.Reg)&^(0x1)|value)
}
func (o *FlexSPI_Type) GetIPCMD_TRG() uint32 {
	return volatile.LoadUint32(&o.IPCMD.Reg) & 0x1
}

// FlexSPI.IPRXFCR: IP RX FIFO Control Register
func (o *FlexSPI_Type) SetIPRXFCR_CLRIPRXF(value uint32) {
	volatile.StoreUint32(&o.IPRXFCR.Reg, volatile.LoadUint32(&o.IPRXFCR.Reg)&^(0x1)|value)
}
func (o *FlexSPI_Type) GetIPRXFCR_CLRIPRXF() uint32 {
	return volatile.LoadUint32(&o.IPRXFCR.Reg) & 0x1
}
func (o *FlexSPI_Type) SetIPRXFCR_RXDMAEN(value uint32) {
	volatile.StoreUint32(&o.IPRXFCR.Reg, volatile.LoadUint32(&o.IPRXFCR.Reg)&^(0x2)|value<<1)
}
func (o *FlexSPI_Type) GetIPRXFCR_RXDMAEN() uint32 {
	return (volatile.LoadUint32(&o.IPRXFCR.Reg) & 0x2) >> 1
}
func (o *FlexSPI_Type) SetIPRXFCR_RXWMRK(value uint32) {
	volatile.StoreUint32(&o.IPRXFCR.Reg, volatile.LoadUint32(&o.IPRXFCR.Reg)&^(0x3c)|value<<2)
}
func (o *FlexSPI_Type) GetIPRXFCR_RXWMRK() uint32 {
	return (volatile.LoadUint32(&o.IPRXFCR.Reg) & 0x3c) >> 2
}

// FlexSPI.IPTXFCR: IP TX FIFO Control Register
func (o *FlexSPI_Type) SetIPTXFCR_CLRIPTXF(value uint32) {
	volatile.StoreUint32(&o.IPTXFCR.Reg, volatile.LoadUint32(&o.IPTXFCR.Reg)&^(0x1)|value)
}
func (o *FlexSPI_Type) GetIPTXFCR_CLRIPTXF() uint32 {
	return volatile.LoadUint32(&o.IPTXFCR.Reg) & 0x1
}
func (o *FlexSPI_Type) SetIPTXFCR_TXDMAEN(value uint32) {
	volatile.StoreUint32(&o.IPTXFCR.Reg, volatile.LoadUint32(&o.IPTXFCR.Reg)&^(0x2)|value<<1)
}
func (o *FlexSPI_Type) GetIPTXFCR_TXDMAEN() uint32 {
	return (volatile.LoadUint32(&o.IPTXFCR.Reg) & 0x2) >> 1
}
func (o *FlexSPI_Type) SetIPTXFCR_TXWMRK(value uint32) {
	volatile.StoreUint32(&o.IPTXFCR.Reg, volatile.LoadUint32(&o.IPTXFCR.Reg)&^(0x3c)|value<<2)
}
func (o *FlexSPI_Type) GetIPTXFCR_TXWMRK() uint32 {
	return (volatile.LoadUint32(&o.IPTXFCR.Reg) & 0x3c) >> 2
}

// FlexSPI.DLLCRA: DLL Control Register 0
func (o *FlexSPI_Type) SetDLLCRA_DLLEN(value uint32) {
	volatile.StoreUint32(&o.DLLCRA.Reg, volatile.LoadUint32(&o.DLLCRA.Reg)&^(0x1)|value)
}
func (o *FlexSPI_Type) GetDLLCRA_DLLEN() uint32 {
	return volatile.LoadUint32(&o.DLLCRA.Reg) & 0x1
}
func (o *FlexSPI_Type) SetDLLCRA_DLLRESET(value uint32) {
	volatile.StoreUint32(&o.DLLCRA.Reg, volatile.LoadUint32(&o.DLLCRA.Reg)&^(0x2)|value<<1)
}
func (o *FlexSPI_Type) GetDLLCRA_DLLRESET() uint32 {
	return (volatile.LoadUint32(&o.DLLCRA.Reg) & 0x2) >> 1
}
func (o *FlexSPI_Type) SetDLLCRA_SLVDLYTARGET(value uint32) {
	volatile.StoreUint32(&o.DLLCRA.Reg, volatile.LoadUint32(&o.DLLCRA.Reg)&^(0x78)|value<<3)
}
func (o *FlexSPI_Type) GetDLLCRA_SLVDLYTARGET() uint32 {
	return (volatile.LoadUint32(&o.DLLCRA.Reg) & 0x78) >> 3
}
func (o *FlexSPI_Type) SetDLLCRA_OVRDEN(value uint32) {
	volatile.StoreUint32(&o.DLLCRA.Reg, volatile.LoadUint32(&o.DLLCRA.Reg)&^(0x100)|value<<8)
}
func (o *FlexSPI_Type) GetDLLCRA_OVRDEN() uint32 {
	return (volatile.LoadUint32(&o.DLLCRA.Reg) & 0x100) >> 8
}
func (o *FlexSPI_Type) SetDLLCRA_OVRDVAL(value uint32) {
	volatile.StoreUint32(&o.DLLCRA.Reg, volatile.LoadUint32(&o.DLLCRA.Reg)&^(0x7e00)|value<<9)
}
func (o *FlexSPI_Type) GetDLLCRA_OVRDVAL() uint32 {
	return (volatile.LoadUint32(&o.DLLCRA.Reg) & 0x7e00) >> 9
}

// FlexSPI.DLLCRB: DLL Control Register 0
func (o *FlexSPI_Type) SetDLLCRB_DLLEN(value uint32) {
	volatile.StoreUint32(&o.DLLCRB.Reg, volatile.LoadUint32(&o.DLLCRB.Reg)&^(0x1)|value)
}
func (o *FlexSPI_Type) GetDLLCRB_DLLEN() uint32 {
	return volatile.LoadUint32(&o.DLLCRB.Reg) & 0x1
}
func (o *FlexSPI_Type) SetDLLCRB_DLLRESET(value uint32) {
	volatile.StoreUint32(&o.DLLCRB.Reg, volatile.LoadUint32(&o.DLLCRB.Reg)&^(0x2)|value<<1)
}
func (o *FlexSPI_Type) GetDLLCRB_DLLRESET() uint32 {
	return (volatile.LoadUint32(&o.DLLCRB.Reg) & 0x2) >> 1
}
func (o *FlexSPI_Type) SetDLLCRB_SLVDLYTARGET(value uint32) {
	volatile.StoreUint32(&o.DLLCRB.Reg, volatile.LoadUint32(&o.DLLCRB.Reg)&^(0x78)|value<<3)
}
func (o *FlexSPI_Type) GetDLLCRB_SLVDLYTARGET() uint32 {
	return (volatile.LoadUint32(&o.DLLCRB.Reg) & 0x78) >> 3
}
func (o *FlexSPI_Type) SetDLLCRB_OVRDEN(value uint32) {
	volatile.StoreUint32(&o.DLLCRB.Reg, volatile.LoadUint32(&o.DLLCRB.Reg)&^(0x100)|value<<8)
}
func (o *FlexSPI_Type) GetDLLCRB_OVRDEN() uint32 {
	return (volatile.LoadUint32(&o.DLLCRB.Reg) & 0x100) >> 8
}
func (o *FlexSPI_Type) SetDLLCRB_OVRDVAL(value uint32) {
	volatile.StoreUint32(&o.DLLCRB.Reg, volatile.LoadUint32(&o.DLLCRB.Reg)&^(0x7e00)|value<<9)
}
func (o *FlexSPI_Type) GetDLLCRB_OVRDVAL() uint32 {
	return (volatile.LoadUint32(&o.DLLCRB.Reg) & 0x7e00) >> 9
}

// FlexSPI.STS0: Status Register 0
func (o *FlexSPI_Type) SetSTS0_SEQIDLE(value uint32) {
	volatile.StoreUint32(&o.STS0.Reg, volatile.LoadUint32(&o.STS0.Reg)&^(0x1)|value)
}
func (o *FlexSPI_Type) GetSTS0_SEQIDLE() uint32 {
	return volatile.LoadUint32(&o.STS0.Reg) & 0x1
}
func (o *FlexSPI_Type) SetSTS0_ARBIDLE(value uint32) {
	volatile.StoreUint32(&o.STS0.Reg, volatile.LoadUint32(&o.STS0.Reg)&^(0x2)|value<<1)
}
func (o *FlexSPI_Type) GetSTS0_ARBIDLE() uint32 {
	return (volatile.LoadUint32(&o.STS0.Reg) & 0x2) >> 1
}
func (o *FlexSPI_Type) SetSTS0_ARBCMDSRC(value uint32) {
	volatile.StoreUint32(&o.STS0.Reg, volatile.LoadUint32(&o.STS0.Reg)&^(0xc)|value<<2)
}
func (o *FlexSPI_Type) GetSTS0_ARBCMDSRC() uint32 {
	return (volatile.LoadUint32(&o.STS0.Reg) & 0xc) >> 2
}

// FlexSPI.STS1: Status Register 1
func (o *FlexSPI_Type) SetSTS1_AHBCMDERRID(value uint32) {
	volatile.StoreUint32(&o.STS1.Reg, volatile.LoadUint32(&o.STS1.Reg)&^(0xf)|value)
}
func (o *FlexSPI_Type) GetSTS1_AHBCMDERRID() uint32 {
	return volatile.LoadUint32(&o.STS1.Reg) & 0xf
}
func (o *FlexSPI_Type) SetSTS1_AHBCMDERRCODE(value uint32) {
	volatile.StoreUint32(&o.STS1.Reg, volatile.LoadUint32(&o.STS1.Reg)&^(0xf00)|value<<8)
}
func (o *FlexSPI_Type) GetSTS1_AHBCMDERRCODE() uint32 {
	return (volatile.LoadUint32(&o.STS1.Reg) & 0xf00) >> 8
}
func (o *FlexSPI_Type) SetSTS1_IPCMDERRID(value uint32) {
	volatile.StoreUint32(&o.STS1.Reg, volatile.LoadUint32(&o.STS1.Reg)&^(0xf0000)|value<<16)
}
func (o *FlexSPI_Type) GetSTS1_IPCMDERRID() uint32 {
	return (volatile.LoadUint32(&o.STS1.Reg) & 0xf0000) >> 16
}
func (o *FlexSPI_Type) SetSTS1_IPCMDERRCODE(value uint32) {
	volatile.StoreUint32(&o.STS1.Reg, volatile.LoadUint32(&o.STS1.Reg)&^(0xf000000)|value<<24)
}
func (o *FlexSPI_Type) GetSTS1_IPCMDERRCODE() uint32 {
	return (volatile.LoadUint32(&o.STS1.Reg) & 0xf000000) >> 24
}

// FlexSPI.STS2: Status Register 2
func (o *FlexSPI_Type) SetSTS2_ASLVLOCK(value uint32) {
	volatile.StoreUint32(&o.STS2.Reg, volatile.LoadUint32(&o.STS2.Reg)&^(0x1)|value)
}
func (o *FlexSPI_Type) GetSTS2_ASLVLOCK() uint32 {
	return volatile.LoadUint32(&o.STS2.Reg) & 0x1
}
func (o *FlexSPI_Type) SetSTS2_AREFLOCK(value uint32) {
	volatile.StoreUint32(&o.STS2.Reg, volatile.LoadUint32(&o.STS2.Reg)&^(0x2)|value<<1)
}
func (o *FlexSPI_Type) GetSTS2_AREFLOCK() uint32 {
	return (volatile.LoadUint32(&o.STS2.Reg) & 0x2) >> 1
}
func (o *FlexSPI_Type) SetSTS2_ASLVSEL(value uint32) {
	volatile.StoreUint32(&o.STS2.Reg, volatile.LoadUint32(&o.STS2.Reg)&^(0xfc)|value<<2)
}
func (o *FlexSPI_Type) GetSTS2_ASLVSEL() uint32 {
	return (volatile.LoadUint32(&o.STS2.Reg) & 0xfc) >> 2
}
func (o *FlexSPI_Type) SetSTS2_AREFSEL(value uint32) {
	volatile.StoreUint32(&o.STS2.Reg, volatile.LoadUint32(&o.STS2.Reg)&^(0x3f00)|value<<8)
}
func (o *FlexSPI_Type) GetSTS2_AREFSEL() uint32 {
	return (volatile.LoadUint32(&o.STS2.Reg) & 0x3f00) >> 8
}
func (o *FlexSPI_Type) SetSTS2_BSLVLOCK(value uint32) {
	volatile.StoreUint32(&o.STS2.Reg, volatile.LoadUint32(&o.STS2.Reg)&^(0x10000)|value<<16)
}
func (o *FlexSPI_Type) GetSTS2_BSLVLOCK() uint32 {
	return (volatile.LoadUint32(&o.STS2.Reg) & 0x10000) >> 16
}
func (o *FlexSPI_Type) SetSTS2_BREFLOCK(value uint32) {
	volatile.StoreUint32(&o.STS2.Reg, volatile.LoadUint32(&o.STS2.Reg)&^(0x20000)|value<<17)
}
func (o *FlexSPI_Type) GetSTS2_BREFLOCK() uint32 {
	return (volatile.LoadUint32(&o.STS2.Reg) & 0x20000) >> 17
}
func (o *FlexSPI_Type) SetSTS2_BSLVSEL(value uint32) {
	volatile.StoreUint32(&o.STS2.Reg, volatile.LoadUint32(&o.STS2.Reg)&^(0xfc0000)|value<<18)
}
func (o *FlexSPI_Type) GetSTS2_BSLVSEL() uint32 {
	return (volatile.LoadUint32(&o.STS2.Reg) & 0xfc0000) >> 18
}
func (o *FlexSPI_Type) SetSTS2_BREFSEL(value uint32) {
	volatile.StoreUint32(&o.STS2.Reg, volatile.LoadUint32(&o.STS2.Reg)&^(0x3f000000)|value<<24)
}
func (o *FlexSPI_Type) GetSTS2_BREFSEL() uint32 {
	return (volatile.LoadUint32(&o.STS2.Reg) & 0x3f000000) >> 24
}

// FlexSPI.AHBSPNDSTS: AHB Suspend Status Register
func (o *FlexSPI_Type) SetAHBSPNDSTS_ACTIVE(value uint32) {
	volatile.StoreUint32(&o.AHBSPNDSTS.Reg, volatile.LoadUint32(&o.AHBSPNDSTS.Reg)&^(0x1)|value)
}
func (o *FlexSPI_Type) GetAHBSPNDSTS_ACTIVE() uint32 {
	return volatile.LoadUint32(&o.AHBSPNDSTS.Reg) & 0x1
}
func (o *FlexSPI_Type) SetAHBSPNDSTS_BUFID(value uint32) {
	volatile.StoreUint32(&o.AHBSPNDSTS.Reg, volatile.LoadUint32(&o.AHBSPNDSTS.Reg)&^(0xe)|value<<1)
}
func (o *FlexSPI_Type) GetAHBSPNDSTS_BUFID() uint32 {
	return (volatile.LoadUint32(&o.AHBSPNDSTS.Reg) & 0xe) >> 1
}
func (o *FlexSPI_Type) SetAHBSPNDSTS_DATLFT(value uint32) {
	volatile.StoreUint32(&o.AHBSPNDSTS.Reg, volatile.LoadUint32(&o.AHBSPNDSTS.Reg)&^(0xffff0000)|value<<16)
}
func (o *FlexSPI_Type) GetAHBSPNDSTS_DATLFT() uint32 {
	return (volatile.LoadUint32(&o.AHBSPNDSTS.Reg) & 0xffff0000) >> 16
}

// FlexSPI.IPRXFSTS: IP RX FIFO Status Register
func (o *FlexSPI_Type) SetIPRXFSTS_FILL(value uint32) {
	volatile.StoreUint32(&o.IPRXFSTS.Reg, volatile.LoadUint32(&o.IPRXFSTS.Reg)&^(0xff)|value)
}
func (o *FlexSPI_Type) GetIPRXFSTS_FILL() uint32 {
	return volatile.LoadUint32(&o.IPRXFSTS.Reg) & 0xff
}
func (o *FlexSPI_Type) SetIPRXFSTS_RDCNTR(value uint32) {
	volatile.StoreUint32(&o.IPRXFSTS.Reg, volatile.LoadUint32(&o.IPRXFSTS.Reg)&^(0xffff0000)|value<<16)
}
func (o *FlexSPI_Type) GetIPRXFSTS_RDCNTR() uint32 {
	return (volatile.LoadUint32(&o.IPRXFSTS.Reg) & 0xffff0000) >> 16
}

// FlexSPI.IPTXFSTS: IP TX FIFO Status Register
func (o *FlexSPI_Type) SetIPTXFSTS_FILL(value uint32) {
	volatile.StoreUint32(&o.IPTXFSTS.Reg, volatile.LoadUint32(&o.IPTXFSTS.Reg)&^(0xff)|value)
}
func (o *FlexSPI_Type) GetIPTXFSTS_FILL() uint32 {
	return volatile.LoadUint32(&o.IPTXFSTS.Reg) & 0xff
}
func (o *FlexSPI_Type) SetIPTXFSTS_WRCNTR(value uint32) {
	volatile.StoreUint32(&o.IPTXFSTS.Reg, volatile.LoadUint32(&o.IPTXFSTS.Reg)&^(0xffff0000)|value<<16)
}
func (o *FlexSPI_Type) GetIPTXFSTS_WRCNTR() uint32 {
	return (volatile.LoadUint32(&o.IPTXFSTS.Reg) & 0xffff0000) >> 16
}

// FlexSPI.RFDR: IP RX FIFO Data Register 0
func (o *FlexSPI_Type) SetRFDR(idx int, value uint32) {
	volatile.StoreUint32(&o.RFDR[idx].Reg, value)
}
func (o *FlexSPI_Type) GetRFDR(idx int) uint32 {
	return volatile.LoadUint32(&o.RFDR[idx].Reg)
}

// FlexSPI.TFDR: IP TX FIFO Data Register 0
func (o *FlexSPI_Type) SetTFDR(idx int, value uint32) {
	volatile.StoreUint32(&o.TFDR[idx].Reg, value)
}
func (o *FlexSPI_Type) GetTFDR(idx int) uint32 {
	return volatile.LoadUint32(&o.TFDR[idx].Reg)
}

// FlexSPI.LUT: LUT 0
func (o *FlexSPI_Type) SetLUT_OPERAND0(idx int, value uint32) {
	volatile.StoreUint32(&o.LUT[idx].Reg, volatile.LoadUint32(&o.LUT[idx].Reg)&^(0xff)|value)
}
func (o *FlexSPI_Type) GetLUT_OPERAND0(idx int) uint32 {
	return volatile.LoadUint32(&o.LUT[idx].Reg) & 0xff
}
func (o *FlexSPI_Type) SetLUT_NUM_PADS0(idx int, value uint32) {
	volatile.StoreUint32(&o.LUT[idx].Reg, volatile.LoadUint32(&o.LUT[idx].Reg)&^(0x300)|value<<8)
}
func (o *FlexSPI_Type) GetLUT_NUM_PADS0(idx int) uint32 {
	return (volatile.LoadUint32(&o.LUT[idx].Reg) & 0x300) >> 8
}
func (o *FlexSPI_Type) SetLUT_OPCODE0(idx int, value uint32) {
	volatile.StoreUint32(&o.LUT[idx].Reg, volatile.LoadUint32(&o.LUT[idx].Reg)&^(0xfc00)|value<<10)
}
func (o *FlexSPI_Type) GetLUT_OPCODE0(idx int) uint32 {
	return (volatile.LoadUint32(&o.LUT[idx].Reg) & 0xfc00) >> 10
}
func (o *FlexSPI_Type) SetLUT_OPERAND1(idx int, value uint32) {
	volatile.StoreUint32(&o.LUT[idx].Reg, volatile.LoadUint32(&o.LUT[idx].Reg)&^(0xff0000)|value<<16)
}
func (o *FlexSPI_Type) GetLUT_OPERAND1(idx int) uint32 {
	return (volatile.LoadUint32(&o.LUT[idx].Reg) & 0xff0000) >> 16
}
func (o *FlexSPI_Type) SetLUT_NUM_PADS1(idx int, value uint32) {
	volatile.StoreUint32(&o.LUT[idx].Reg, volatile.LoadUint32(&o.LUT[idx].Reg)&^(0x3000000)|value<<24)
}
func (o *FlexSPI_Type) GetLUT_NUM_PADS1(idx int) uint32 {
	return (volatile.LoadUint32(&o.LUT[idx].Reg) & 0x3000000) >> 24
}
func (o *FlexSPI_Type) SetLUT_OPCODE1(idx int, value uint32) {
	volatile.StoreUint32(&o.LUT[idx].Reg, volatile.LoadUint32(&o.LUT[idx].Reg)&^(0xfc000000)|value<<26)
}
func (o *FlexSPI_Type) GetLUT_OPCODE1(idx int) uint32 {
	return (volatile.LoadUint32(&o.LUT[idx].Reg) & 0xfc000000) >> 26
}

// OTFAD
type OTFAD_Type struct {
	_   [3072]byte
	CR  volatile.Register32 // 0xC00
	SR  volatile.Register32 // 0xC04
	_   [248]byte
	CTX [4]OTFAD_CTX_Type // 0xD00
}

// OTFAD.CR: Control Register
func (o *OTFAD_Type) SetCR_IRQE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *OTFAD_Type) GetCR_IRQE() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *OTFAD_Type) SetCR_FERR(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *OTFAD_Type) GetCR_FERR() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *OTFAD_Type) SetCR_FSVM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *OTFAD_Type) GetCR_FSVM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *OTFAD_Type) SetCR_FLDM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *OTFAD_Type) GetCR_FLDM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *OTFAD_Type) SetCR_KBSE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *OTFAD_Type) GetCR_KBSE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *OTFAD_Type) SetCR_KBPE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *OTFAD_Type) GetCR_KBPE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *OTFAD_Type) SetCR_KBCE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *OTFAD_Type) GetCR_KBCE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *OTFAD_Type) SetCR_RRAE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *OTFAD_Type) GetCR_RRAE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *OTFAD_Type) SetCR_SKBP(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000000)|value<<30)
}
func (o *OTFAD_Type) GetCR_SKBP() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000000) >> 30
}
func (o *OTFAD_Type) SetCR_GE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000000)|value<<31)
}
func (o *OTFAD_Type) GetCR_GE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000000) >> 31
}

// OTFAD.SR: Status Register
func (o *OTFAD_Type) SetSR_KBERR(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *OTFAD_Type) GetSR_KBERR() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *OTFAD_Type) SetSR_MDPCP(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *OTFAD_Type) GetSR_MDPCP() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *OTFAD_Type) SetSR_MODE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xc)|value<<2)
}
func (o *OTFAD_Type) GetSR_MODE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0xc) >> 2
}
func (o *OTFAD_Type) SetSR_NCTX(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xf0)|value<<4)
}
func (o *OTFAD_Type) GetSR_NCTX() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0xf0) >> 4
}
func (o *OTFAD_Type) SetSR_CTXER0(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *OTFAD_Type) GetSR_CTXER0() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *OTFAD_Type) SetSR_CTXER1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *OTFAD_Type) GetSR_CTXER1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *OTFAD_Type) SetSR_CTXER2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400)|value<<10)
}
func (o *OTFAD_Type) GetSR_CTXER2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400) >> 10
}
func (o *OTFAD_Type) SetSR_CTXER3(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x800)|value<<11)
}
func (o *OTFAD_Type) GetSR_CTXER3() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x800) >> 11
}
func (o *OTFAD_Type) SetSR_CTXIE0(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000)|value<<16)
}
func (o *OTFAD_Type) GetSR_CTXIE0() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000) >> 16
}
func (o *OTFAD_Type) SetSR_CTXIE1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000)|value<<17)
}
func (o *OTFAD_Type) GetSR_CTXIE1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000) >> 17
}
func (o *OTFAD_Type) SetSR_CTXIE2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000)|value<<18)
}
func (o *OTFAD_Type) GetSR_CTXIE2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000) >> 18
}
func (o *OTFAD_Type) SetSR_CTXIE3(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000)|value<<19)
}
func (o *OTFAD_Type) GetSR_CTXIE3() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000) >> 19
}
func (o *OTFAD_Type) SetSR_HRL(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xf000000)|value<<24)
}
func (o *OTFAD_Type) GetSR_HRL() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0xf000000) >> 24
}
func (o *OTFAD_Type) SetSR_RRAM(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10000000)|value<<28)
}
func (o *OTFAD_Type) GetSR_RRAM() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10000000) >> 28
}
func (o *OTFAD_Type) SetSR_GEM(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20000000)|value<<29)
}
func (o *OTFAD_Type) GetSR_GEM() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20000000) >> 29
}
func (o *OTFAD_Type) SetSR_KBPE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x40000000)|value<<30)
}
func (o *OTFAD_Type) GetSR_KBPE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x40000000) >> 30
}
func (o *OTFAD_Type) SetSR_KBD(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x80000000)|value<<31)
}
func (o *OTFAD_Type) GetSR_KBD() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x80000000) >> 31
}

// no description available
type OTFAD_CTX_Type struct {
	CTX_KEY0   volatile.Register32 // 0xD00
	CTX_KEY1   volatile.Register32 // 0xD04
	CTX_KEY2   volatile.Register32 // 0xD08
	CTX_KEY3   volatile.Register32 // 0xD0C
	CTX_CTR0   volatile.Register32 // 0xD10
	CTX_CTR1   volatile.Register32 // 0xD14
	CTX_RGD_W0 volatile.Register32 // 0xD18
	CTX_RGD_W1 volatile.Register32 // 0xD1C
	_          [32]byte
}

// OTFAD_CTX.CTX_KEY0: AES Key Word
func (o *OTFAD_CTX_Type) SetCTX_KEY0(value uint32) {
	volatile.StoreUint32(&o.CTX_KEY0.Reg, value)
}
func (o *OTFAD_CTX_Type) GetCTX_KEY0() uint32 {
	return volatile.LoadUint32(&o.CTX_KEY0.Reg)
}

// OTFAD_CTX.CTX_KEY1: AES Key Word
func (o *OTFAD_CTX_Type) SetCTX_KEY1(value uint32) {
	volatile.StoreUint32(&o.CTX_KEY1.Reg, value)
}
func (o *OTFAD_CTX_Type) GetCTX_KEY1() uint32 {
	return volatile.LoadUint32(&o.CTX_KEY1.Reg)
}

// OTFAD_CTX.CTX_KEY2: AES Key Word
func (o *OTFAD_CTX_Type) SetCTX_KEY2(value uint32) {
	volatile.StoreUint32(&o.CTX_KEY2.Reg, value)
}
func (o *OTFAD_CTX_Type) GetCTX_KEY2() uint32 {
	return volatile.LoadUint32(&o.CTX_KEY2.Reg)
}

// OTFAD_CTX.CTX_KEY3: AES Key Word
func (o *OTFAD_CTX_Type) SetCTX_KEY3(value uint32) {
	volatile.StoreUint32(&o.CTX_KEY3.Reg, value)
}
func (o *OTFAD_CTX_Type) GetCTX_KEY3() uint32 {
	return volatile.LoadUint32(&o.CTX_KEY3.Reg)
}

// OTFAD_CTX.CTX_CTR0: AES Counter Word
func (o *OTFAD_CTX_Type) SetCTX_CTR0(value uint32) {
	volatile.StoreUint32(&o.CTX_CTR0.Reg, value)
}
func (o *OTFAD_CTX_Type) GetCTX_CTR0() uint32 {
	return volatile.LoadUint32(&o.CTX_CTR0.Reg)
}

// OTFAD_CTX.CTX_CTR1: AES Counter Word
func (o *OTFAD_CTX_Type) SetCTX_CTR1(value uint32) {
	volatile.StoreUint32(&o.CTX_CTR1.Reg, value)
}
func (o *OTFAD_CTX_Type) GetCTX_CTR1() uint32 {
	return volatile.LoadUint32(&o.CTX_CTR1.Reg)
}

// OTFAD_CTX.CTX_RGD_W0: AES Region Descriptor Word0
func (o *OTFAD_CTX_Type) SetCTX_RGD_W0_SRTADDR(value uint32) {
	volatile.StoreUint32(&o.CTX_RGD_W0.Reg, volatile.LoadUint32(&o.CTX_RGD_W0.Reg)&^(0xfffffc00)|value<<10)
}
func (o *OTFAD_CTX_Type) GetCTX_RGD_W0_SRTADDR() uint32 {
	return (volatile.LoadUint32(&o.CTX_RGD_W0.Reg) & 0xfffffc00) >> 10
}

// OTFAD_CTX.CTX_RGD_W1: AES Region Descriptor Word1
func (o *OTFAD_CTX_Type) SetCTX_RGD_W1_VLD(value uint32) {
	volatile.StoreUint32(&o.CTX_RGD_W1.Reg, volatile.LoadUint32(&o.CTX_RGD_W1.Reg)&^(0x1)|value)
}
func (o *OTFAD_CTX_Type) GetCTX_RGD_W1_VLD() uint32 {
	return volatile.LoadUint32(&o.CTX_RGD_W1.Reg) & 0x1
}
func (o *OTFAD_CTX_Type) SetCTX_RGD_W1_ADE(value uint32) {
	volatile.StoreUint32(&o.CTX_RGD_W1.Reg, volatile.LoadUint32(&o.CTX_RGD_W1.Reg)&^(0x2)|value<<1)
}
func (o *OTFAD_CTX_Type) GetCTX_RGD_W1_ADE() uint32 {
	return (volatile.LoadUint32(&o.CTX_RGD_W1.Reg) & 0x2) >> 1
}
func (o *OTFAD_CTX_Type) SetCTX_RGD_W1_RO(value uint32) {
	volatile.StoreUint32(&o.CTX_RGD_W1.Reg, volatile.LoadUint32(&o.CTX_RGD_W1.Reg)&^(0x4)|value<<2)
}
func (o *OTFAD_CTX_Type) GetCTX_RGD_W1_RO() uint32 {
	return (volatile.LoadUint32(&o.CTX_RGD_W1.Reg) & 0x4) >> 2
}
func (o *OTFAD_CTX_Type) SetCTX_RGD_W1_ENDADDR(value uint32) {
	volatile.StoreUint32(&o.CTX_RGD_W1.Reg, volatile.LoadUint32(&o.CTX_RGD_W1.Reg)&^(0xfffffc00)|value<<10)
}
func (o *OTFAD_CTX_Type) GetCTX_RGD_W1_ENDADDR() uint32 {
	return (volatile.LoadUint32(&o.CTX_RGD_W1.Reg) & 0xfffffc00) >> 10
}

// IOMUXC
type IOMUXC_SNVS_GPR_Type struct {
	GPR0 volatile.Register32 // 0x0
	GPR1 volatile.Register32 // 0x4
	GPR2 volatile.Register32 // 0x8
	GPR3 volatile.Register32 // 0xC
}

// IOMUXC_SNVS_GPR.GPR3: GPR3 General Purpose Register
func (o *IOMUXC_SNVS_GPR_Type) SetGPR3_LPSR_MODE_ENABLE(value uint32) {
	volatile.StoreUint32(&o.GPR3.Reg, volatile.LoadUint32(&o.GPR3.Reg)&^(0x1)|value)
}
func (o *IOMUXC_SNVS_GPR_Type) GetGPR3_LPSR_MODE_ENABLE() uint32 {
	return volatile.LoadUint32(&o.GPR3.Reg) & 0x1
}
func (o *IOMUXC_SNVS_GPR_Type) SetGPR3_DCDC_STATUS_CAPT_CLR(value uint32) {
	volatile.StoreUint32(&o.GPR3.Reg, volatile.LoadUint32(&o.GPR3.Reg)&^(0x2)|value<<1)
}
func (o *IOMUXC_SNVS_GPR_Type) GetGPR3_DCDC_STATUS_CAPT_CLR() uint32 {
	return (volatile.LoadUint32(&o.GPR3.Reg) & 0x2) >> 1
}
func (o *IOMUXC_SNVS_GPR_Type) SetGPR3_POR_PULL_TYPE(value uint32) {
	volatile.StoreUint32(&o.GPR3.Reg, volatile.LoadUint32(&o.GPR3.Reg)&^(0xc)|value<<2)
}
func (o *IOMUXC_SNVS_GPR_Type) GetGPR3_POR_PULL_TYPE() uint32 {
	return (volatile.LoadUint32(&o.GPR3.Reg) & 0xc) >> 2
}
func (o *IOMUXC_SNVS_GPR_Type) SetGPR3_DCDC_IN_LOW_VOL(value uint32) {
	volatile.StoreUint32(&o.GPR3.Reg, volatile.LoadUint32(&o.GPR3.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_SNVS_GPR_Type) GetGPR3_DCDC_IN_LOW_VOL() uint32 {
	return (volatile.LoadUint32(&o.GPR3.Reg) & 0x10000) >> 16
}
func (o *IOMUXC_SNVS_GPR_Type) SetGPR3_DCDC_OVER_CUR(value uint32) {
	volatile.StoreUint32(&o.GPR3.Reg, volatile.LoadUint32(&o.GPR3.Reg)&^(0x20000)|value<<17)
}
func (o *IOMUXC_SNVS_GPR_Type) GetGPR3_DCDC_OVER_CUR() uint32 {
	return (volatile.LoadUint32(&o.GPR3.Reg) & 0x20000) >> 17
}
func (o *IOMUXC_SNVS_GPR_Type) SetGPR3_DCDC_OVER_VOL(value uint32) {
	volatile.StoreUint32(&o.GPR3.Reg, volatile.LoadUint32(&o.GPR3.Reg)&^(0x40000)|value<<18)
}
func (o *IOMUXC_SNVS_GPR_Type) GetGPR3_DCDC_OVER_VOL() uint32 {
	return (volatile.LoadUint32(&o.GPR3.Reg) & 0x40000) >> 18
}
func (o *IOMUXC_SNVS_GPR_Type) SetGPR3_DCDC_STS_DC_OK(value uint32) {
	volatile.StoreUint32(&o.GPR3.Reg, volatile.LoadUint32(&o.GPR3.Reg)&^(0x80000)|value<<19)
}
func (o *IOMUXC_SNVS_GPR_Type) GetGPR3_DCDC_STS_DC_OK() uint32 {
	return (volatile.LoadUint32(&o.GPR3.Reg) & 0x80000) >> 19
}

// IOMUXC_SNVS
type IOMUXC_SNVS_Type struct {
	SW_MUX_CTL_PAD_PMIC_ON_REQ volatile.Register32 // 0x0
	SW_PAD_CTL_PAD_TEST_MODE   volatile.Register32 // 0x4
	SW_PAD_CTL_PAD_POR_B       volatile.Register32 // 0x8
	SW_PAD_CTL_PAD_ONOFF       volatile.Register32 // 0xC
	SW_PAD_CTL_PAD_PMIC_ON_REQ volatile.Register32 // 0x10
}

// IOMUXC_SNVS.SW_MUX_CTL_PAD_PMIC_ON_REQ: SW_MUX_CTL_PAD_PMIC_ON_REQ SW MUX Control Register
func (o *IOMUXC_SNVS_Type) SetSW_MUX_CTL_PAD_PMIC_ON_REQ_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_PMIC_ON_REQ.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_PMIC_ON_REQ.Reg)&^(0x7)|value)
}
func (o *IOMUXC_SNVS_Type) GetSW_MUX_CTL_PAD_PMIC_ON_REQ_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_PMIC_ON_REQ.Reg) & 0x7
}
func (o *IOMUXC_SNVS_Type) SetSW_MUX_CTL_PAD_PMIC_ON_REQ_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_PMIC_ON_REQ.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_PMIC_ON_REQ.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_SNVS_Type) GetSW_MUX_CTL_PAD_PMIC_ON_REQ_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_PMIC_ON_REQ.Reg) & 0x10) >> 4
}

// IOMUXC_SNVS.SW_PAD_CTL_PAD_TEST_MODE: SW_PAD_CTL_PAD_TEST_MODE SW PAD Control Register
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_TEST_MODE_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_TEST_MODE.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_TEST_MODE.Reg)&^(0x1)|value)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_TEST_MODE_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_TEST_MODE.Reg) & 0x1
}
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_TEST_MODE_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_TEST_MODE.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_TEST_MODE.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_TEST_MODE_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_TEST_MODE.Reg) & 0x38) >> 3
}
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_TEST_MODE_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_TEST_MODE.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_TEST_MODE.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_TEST_MODE_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_TEST_MODE.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_TEST_MODE_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_TEST_MODE.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_TEST_MODE.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_TEST_MODE_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_TEST_MODE.Reg) & 0x800) >> 11
}
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_TEST_MODE_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_TEST_MODE.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_TEST_MODE.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_TEST_MODE_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_TEST_MODE.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_TEST_MODE_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_TEST_MODE.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_TEST_MODE.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_TEST_MODE_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_TEST_MODE.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_TEST_MODE_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_TEST_MODE.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_TEST_MODE.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_TEST_MODE_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_TEST_MODE.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_TEST_MODE_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_TEST_MODE.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_TEST_MODE.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_TEST_MODE_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_TEST_MODE.Reg) & 0x10000) >> 16
}

// IOMUXC_SNVS.SW_PAD_CTL_PAD_POR_B: SW_PAD_CTL_PAD_POR_B SW PAD Control Register
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_POR_B_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_POR_B.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_POR_B.Reg)&^(0x1)|value)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_POR_B_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_POR_B.Reg) & 0x1
}
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_POR_B_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_POR_B.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_POR_B.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_POR_B_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_POR_B.Reg) & 0x38) >> 3
}
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_POR_B_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_POR_B.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_POR_B.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_POR_B_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_POR_B.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_POR_B_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_POR_B.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_POR_B.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_POR_B_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_POR_B.Reg) & 0x800) >> 11
}
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_POR_B_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_POR_B.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_POR_B.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_POR_B_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_POR_B.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_POR_B_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_POR_B.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_POR_B.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_POR_B_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_POR_B.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_POR_B_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_POR_B.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_POR_B.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_POR_B_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_POR_B.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_POR_B_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_POR_B.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_POR_B.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_POR_B_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_POR_B.Reg) & 0x10000) >> 16
}

// IOMUXC_SNVS.SW_PAD_CTL_PAD_ONOFF: SW_PAD_CTL_PAD_ONOFF SW PAD Control Register
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_ONOFF_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_ONOFF.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_ONOFF.Reg)&^(0x1)|value)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_ONOFF_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_ONOFF.Reg) & 0x1
}
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_ONOFF_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_ONOFF.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_ONOFF.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_ONOFF_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_ONOFF.Reg) & 0x38) >> 3
}
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_ONOFF_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_ONOFF.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_ONOFF.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_ONOFF_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_ONOFF.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_ONOFF_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_ONOFF.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_ONOFF.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_ONOFF_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_ONOFF.Reg) & 0x800) >> 11
}
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_ONOFF_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_ONOFF.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_ONOFF.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_ONOFF_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_ONOFF.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_ONOFF_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_ONOFF.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_ONOFF.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_ONOFF_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_ONOFF.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_ONOFF_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_ONOFF.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_ONOFF.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_ONOFF_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_ONOFF.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_ONOFF_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_ONOFF.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_ONOFF.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_ONOFF_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_ONOFF.Reg) & 0x10000) >> 16
}

// IOMUXC_SNVS.SW_PAD_CTL_PAD_PMIC_ON_REQ: SW_PAD_CTL_PAD_PMIC_ON_REQ SW PAD Control Register
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_PMIC_ON_REQ_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_PMIC_ON_REQ.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_PMIC_ON_REQ.Reg)&^(0x1)|value)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_PMIC_ON_REQ_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_PMIC_ON_REQ.Reg) & 0x1
}
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_PMIC_ON_REQ_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_PMIC_ON_REQ.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_PMIC_ON_REQ.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_PMIC_ON_REQ_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_PMIC_ON_REQ.Reg) & 0x38) >> 3
}
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_PMIC_ON_REQ_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_PMIC_ON_REQ.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_PMIC_ON_REQ.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_PMIC_ON_REQ_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_PMIC_ON_REQ.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_PMIC_ON_REQ_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_PMIC_ON_REQ.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_PMIC_ON_REQ.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_PMIC_ON_REQ_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_PMIC_ON_REQ.Reg) & 0x800) >> 11
}
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_PMIC_ON_REQ_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_PMIC_ON_REQ.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_PMIC_ON_REQ.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_PMIC_ON_REQ_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_PMIC_ON_REQ.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_PMIC_ON_REQ_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_PMIC_ON_REQ.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_PMIC_ON_REQ.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_PMIC_ON_REQ_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_PMIC_ON_REQ.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_PMIC_ON_REQ_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_PMIC_ON_REQ.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_PMIC_ON_REQ.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_PMIC_ON_REQ_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_PMIC_ON_REQ.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_SNVS_Type) SetSW_PAD_CTL_PAD_PMIC_ON_REQ_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_PMIC_ON_REQ.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_PMIC_ON_REQ.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_SNVS_Type) GetSW_PAD_CTL_PAD_PMIC_ON_REQ_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_PMIC_ON_REQ.Reg) & 0x10000) >> 16
}

// IOMUXC_GPR
type IOMUXC_GPR_Type struct {
	GPR0  volatile.Register32 // 0x0
	GPR1  volatile.Register32 // 0x4
	GPR2  volatile.Register32 // 0x8
	GPR3  volatile.Register32 // 0xC
	GPR4  volatile.Register32 // 0x10
	GPR5  volatile.Register32 // 0x14
	GPR6  volatile.Register32 // 0x18
	GPR7  volatile.Register32 // 0x1C
	GPR8  volatile.Register32 // 0x20
	GPR9  volatile.Register32 // 0x24
	GPR10 volatile.Register32 // 0x28
	GPR11 volatile.Register32 // 0x2C
	GPR12 volatile.Register32 // 0x30
	GPR13 volatile.Register32 // 0x34
	GPR14 volatile.Register32 // 0x38
	GPR15 volatile.Register32 // 0x3C
	GPR16 volatile.Register32 // 0x40
	GPR17 volatile.Register32 // 0x44
	GPR18 volatile.Register32 // 0x48
	GPR19 volatile.Register32 // 0x4C
	GPR20 volatile.Register32 // 0x50
	GPR21 volatile.Register32 // 0x54
	GPR22 volatile.Register32 // 0x58
	GPR23 volatile.Register32 // 0x5C
	GPR24 volatile.Register32 // 0x60
	GPR25 volatile.Register32 // 0x64
	GPR26 volatile.Register32 // 0x68
	GPR27 volatile.Register32 // 0x6C
	GPR28 volatile.Register32 // 0x70
	GPR29 volatile.Register32 // 0x74
}

// IOMUXC_GPR.GPR1: GPR1 General Purpose Register
func (o *IOMUXC_GPR_Type) SetGPR1_SAI1_MCLK1_SEL(value uint32) {
	volatile.StoreUint32(&o.GPR1.Reg, volatile.LoadUint32(&o.GPR1.Reg)&^(0x7)|value)
}
func (o *IOMUXC_GPR_Type) GetGPR1_SAI1_MCLK1_SEL() uint32 {
	return volatile.LoadUint32(&o.GPR1.Reg) & 0x7
}
func (o *IOMUXC_GPR_Type) SetGPR1_SAI1_MCLK2_SEL(value uint32) {
	volatile.StoreUint32(&o.GPR1.Reg, volatile.LoadUint32(&o.GPR1.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_GPR_Type) GetGPR1_SAI1_MCLK2_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPR1.Reg) & 0x38) >> 3
}
func (o *IOMUXC_GPR_Type) SetGPR1_SAI1_MCLK3_SEL(value uint32) {
	volatile.StoreUint32(&o.GPR1.Reg, volatile.LoadUint32(&o.GPR1.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_GPR_Type) GetGPR1_SAI1_MCLK3_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPR1.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_GPR_Type) SetGPR1_SAI3_MCLK3_SEL(value uint32) {
	volatile.StoreUint32(&o.GPR1.Reg, volatile.LoadUint32(&o.GPR1.Reg)&^(0xc00)|value<<10)
}
func (o *IOMUXC_GPR_Type) GetGPR1_SAI3_MCLK3_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPR1.Reg) & 0xc00) >> 10
}
func (o *IOMUXC_GPR_Type) SetGPR1_GINT(value uint32) {
	volatile.StoreUint32(&o.GPR1.Reg, volatile.LoadUint32(&o.GPR1.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_GPR_Type) GetGPR1_GINT() uint32 {
	return (volatile.LoadUint32(&o.GPR1.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_GPR_Type) SetGPR1_SAI1_MCLK_DIR(value uint32) {
	volatile.StoreUint32(&o.GPR1.Reg, volatile.LoadUint32(&o.GPR1.Reg)&^(0x80000)|value<<19)
}
func (o *IOMUXC_GPR_Type) GetGPR1_SAI1_MCLK_DIR() uint32 {
	return (volatile.LoadUint32(&o.GPR1.Reg) & 0x80000) >> 19
}
func (o *IOMUXC_GPR_Type) SetGPR1_SAI3_MCLK_DIR(value uint32) {
	volatile.StoreUint32(&o.GPR1.Reg, volatile.LoadUint32(&o.GPR1.Reg)&^(0x200000)|value<<21)
}
func (o *IOMUXC_GPR_Type) GetGPR1_SAI3_MCLK_DIR() uint32 {
	return (volatile.LoadUint32(&o.GPR1.Reg) & 0x200000) >> 21
}
func (o *IOMUXC_GPR_Type) SetGPR1_EXC_MON(value uint32) {
	volatile.StoreUint32(&o.GPR1.Reg, volatile.LoadUint32(&o.GPR1.Reg)&^(0x400000)|value<<22)
}
func (o *IOMUXC_GPR_Type) GetGPR1_EXC_MON() uint32 {
	return (volatile.LoadUint32(&o.GPR1.Reg) & 0x400000) >> 22
}
func (o *IOMUXC_GPR_Type) SetGPR1_CM7_FORCE_HCLK_EN(value uint32) {
	volatile.StoreUint32(&o.GPR1.Reg, volatile.LoadUint32(&o.GPR1.Reg)&^(0x80000000)|value<<31)
}
func (o *IOMUXC_GPR_Type) GetGPR1_CM7_FORCE_HCLK_EN() uint32 {
	return (volatile.LoadUint32(&o.GPR1.Reg) & 0x80000000) >> 31
}

// IOMUXC_GPR.GPR2: GPR2 General Purpose Register
func (o *IOMUXC_GPR_Type) SetGPR2_AXBS_P_M0_HIGH_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.GPR2.Reg, volatile.LoadUint32(&o.GPR2.Reg)&^(0x8)|value<<3)
}
func (o *IOMUXC_GPR_Type) GetGPR2_AXBS_P_M0_HIGH_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.GPR2.Reg) & 0x8) >> 3
}
func (o *IOMUXC_GPR_Type) SetGPR2_AXBS_P_M1_HIGH_PRIORITY(value uint32) {
	volatile.StoreUint32(&o.GPR2.Reg, volatile.LoadUint32(&o.GPR2.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_GPR_Type) GetGPR2_AXBS_P_M1_HIGH_PRIORITY() uint32 {
	return (volatile.LoadUint32(&o.GPR2.Reg) & 0x10) >> 4
}
func (o *IOMUXC_GPR_Type) SetGPR2_AXBS_P_FORCE_ROUND_ROBIN(value uint32) {
	volatile.StoreUint32(&o.GPR2.Reg, volatile.LoadUint32(&o.GPR2.Reg)&^(0x20)|value<<5)
}
func (o *IOMUXC_GPR_Type) GetGPR2_AXBS_P_FORCE_ROUND_ROBIN() uint32 {
	return (volatile.LoadUint32(&o.GPR2.Reg) & 0x20) >> 5
}
func (o *IOMUXC_GPR_Type) SetGPR2_L2_MEM_EN_POWERSAVING(value uint32) {
	volatile.StoreUint32(&o.GPR2.Reg, volatile.LoadUint32(&o.GPR2.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_GPR_Type) GetGPR2_L2_MEM_EN_POWERSAVING() uint32 {
	return (volatile.LoadUint32(&o.GPR2.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_GPR_Type) SetGPR2_RAM_AUTO_CLK_GATING_EN(value uint32) {
	volatile.StoreUint32(&o.GPR2.Reg, volatile.LoadUint32(&o.GPR2.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_GPR_Type) GetGPR2_RAM_AUTO_CLK_GATING_EN() uint32 {
	return (volatile.LoadUint32(&o.GPR2.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_GPR_Type) SetGPR2_L2_MEM_DEEPSLEEP(value uint32) {
	volatile.StoreUint32(&o.GPR2.Reg, volatile.LoadUint32(&o.GPR2.Reg)&^(0x4000)|value<<14)
}
func (o *IOMUXC_GPR_Type) GetGPR2_L2_MEM_DEEPSLEEP() uint32 {
	return (volatile.LoadUint32(&o.GPR2.Reg) & 0x4000) >> 14
}
func (o *IOMUXC_GPR_Type) SetGPR2_MQS_CLK_DIV(value uint32) {
	volatile.StoreUint32(&o.GPR2.Reg, volatile.LoadUint32(&o.GPR2.Reg)&^(0xff0000)|value<<16)
}
func (o *IOMUXC_GPR_Type) GetGPR2_MQS_CLK_DIV() uint32 {
	return (volatile.LoadUint32(&o.GPR2.Reg) & 0xff0000) >> 16
}
func (o *IOMUXC_GPR_Type) SetGPR2_MQS_SW_RST(value uint32) {
	volatile.StoreUint32(&o.GPR2.Reg, volatile.LoadUint32(&o.GPR2.Reg)&^(0x1000000)|value<<24)
}
func (o *IOMUXC_GPR_Type) GetGPR2_MQS_SW_RST() uint32 {
	return (volatile.LoadUint32(&o.GPR2.Reg) & 0x1000000) >> 24
}
func (o *IOMUXC_GPR_Type) SetGPR2_MQS_EN(value uint32) {
	volatile.StoreUint32(&o.GPR2.Reg, volatile.LoadUint32(&o.GPR2.Reg)&^(0x2000000)|value<<25)
}
func (o *IOMUXC_GPR_Type) GetGPR2_MQS_EN() uint32 {
	return (volatile.LoadUint32(&o.GPR2.Reg) & 0x2000000) >> 25
}
func (o *IOMUXC_GPR_Type) SetGPR2_MQS_OVERSAMPLE(value uint32) {
	volatile.StoreUint32(&o.GPR2.Reg, volatile.LoadUint32(&o.GPR2.Reg)&^(0x4000000)|value<<26)
}
func (o *IOMUXC_GPR_Type) GetGPR2_MQS_OVERSAMPLE() uint32 {
	return (volatile.LoadUint32(&o.GPR2.Reg) & 0x4000000) >> 26
}

// IOMUXC_GPR.GPR3: GPR3 General Purpose Register
func (o *IOMUXC_GPR_Type) SetGPR3_DCP_KEY_SEL(value uint32) {
	volatile.StoreUint32(&o.GPR3.Reg, volatile.LoadUint32(&o.GPR3.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_GPR_Type) GetGPR3_DCP_KEY_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPR3.Reg) & 0x10) >> 4
}

// IOMUXC_GPR.GPR4: GPR4 General Purpose Register
func (o *IOMUXC_GPR_Type) SetGPR4_EDMA_STOP_REQ(value uint32) {
	volatile.StoreUint32(&o.GPR4.Reg, volatile.LoadUint32(&o.GPR4.Reg)&^(0x1)|value)
}
func (o *IOMUXC_GPR_Type) GetGPR4_EDMA_STOP_REQ() uint32 {
	return volatile.LoadUint32(&o.GPR4.Reg) & 0x1
}
func (o *IOMUXC_GPR_Type) SetGPR4_TRNG_STOP_REQ(value uint32) {
	volatile.StoreUint32(&o.GPR4.Reg, volatile.LoadUint32(&o.GPR4.Reg)&^(0x8)|value<<3)
}
func (o *IOMUXC_GPR_Type) GetGPR4_TRNG_STOP_REQ() uint32 {
	return (volatile.LoadUint32(&o.GPR4.Reg) & 0x8) >> 3
}
func (o *IOMUXC_GPR_Type) SetGPR4_SAI1_STOP_REQ(value uint32) {
	volatile.StoreUint32(&o.GPR4.Reg, volatile.LoadUint32(&o.GPR4.Reg)&^(0x20)|value<<5)
}
func (o *IOMUXC_GPR_Type) GetGPR4_SAI1_STOP_REQ() uint32 {
	return (volatile.LoadUint32(&o.GPR4.Reg) & 0x20) >> 5
}
func (o *IOMUXC_GPR_Type) SetGPR4_SAI3_STOP_REQ(value uint32) {
	volatile.StoreUint32(&o.GPR4.Reg, volatile.LoadUint32(&o.GPR4.Reg)&^(0x80)|value<<7)
}
func (o *IOMUXC_GPR_Type) GetGPR4_SAI3_STOP_REQ() uint32 {
	return (volatile.LoadUint32(&o.GPR4.Reg) & 0x80) >> 7
}
func (o *IOMUXC_GPR_Type) SetGPR4_PIT_STOP_REQ(value uint32) {
	volatile.StoreUint32(&o.GPR4.Reg, volatile.LoadUint32(&o.GPR4.Reg)&^(0x400)|value<<10)
}
func (o *IOMUXC_GPR_Type) GetGPR4_PIT_STOP_REQ() uint32 {
	return (volatile.LoadUint32(&o.GPR4.Reg) & 0x400) >> 10
}
func (o *IOMUXC_GPR_Type) SetGPR4_FLEXSPI_STOP_REQ(value uint32) {
	volatile.StoreUint32(&o.GPR4.Reg, volatile.LoadUint32(&o.GPR4.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_GPR_Type) GetGPR4_FLEXSPI_STOP_REQ() uint32 {
	return (volatile.LoadUint32(&o.GPR4.Reg) & 0x800) >> 11
}
func (o *IOMUXC_GPR_Type) SetGPR4_FLEXIO1_STOP_REQ(value uint32) {
	volatile.StoreUint32(&o.GPR4.Reg, volatile.LoadUint32(&o.GPR4.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_GPR_Type) GetGPR4_FLEXIO1_STOP_REQ() uint32 {
	return (volatile.LoadUint32(&o.GPR4.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_GPR_Type) SetGPR4_EDMA_STOP_ACK(value uint32) {
	volatile.StoreUint32(&o.GPR4.Reg, volatile.LoadUint32(&o.GPR4.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_GPR_Type) GetGPR4_EDMA_STOP_ACK() uint32 {
	return (volatile.LoadUint32(&o.GPR4.Reg) & 0x10000) >> 16
}
func (o *IOMUXC_GPR_Type) SetGPR4_TRNG_STOP_ACK(value uint32) {
	volatile.StoreUint32(&o.GPR4.Reg, volatile.LoadUint32(&o.GPR4.Reg)&^(0x80000)|value<<19)
}
func (o *IOMUXC_GPR_Type) GetGPR4_TRNG_STOP_ACK() uint32 {
	return (volatile.LoadUint32(&o.GPR4.Reg) & 0x80000) >> 19
}
func (o *IOMUXC_GPR_Type) SetGPR4_SAI1_STOP_ACK(value uint32) {
	volatile.StoreUint32(&o.GPR4.Reg, volatile.LoadUint32(&o.GPR4.Reg)&^(0x200000)|value<<21)
}
func (o *IOMUXC_GPR_Type) GetGPR4_SAI1_STOP_ACK() uint32 {
	return (volatile.LoadUint32(&o.GPR4.Reg) & 0x200000) >> 21
}
func (o *IOMUXC_GPR_Type) SetGPR4_SAI3_STOP_ACK(value uint32) {
	volatile.StoreUint32(&o.GPR4.Reg, volatile.LoadUint32(&o.GPR4.Reg)&^(0x800000)|value<<23)
}
func (o *IOMUXC_GPR_Type) GetGPR4_SAI3_STOP_ACK() uint32 {
	return (volatile.LoadUint32(&o.GPR4.Reg) & 0x800000) >> 23
}
func (o *IOMUXC_GPR_Type) SetGPR4_PIT_STOP_ACK(value uint32) {
	volatile.StoreUint32(&o.GPR4.Reg, volatile.LoadUint32(&o.GPR4.Reg)&^(0x4000000)|value<<26)
}
func (o *IOMUXC_GPR_Type) GetGPR4_PIT_STOP_ACK() uint32 {
	return (volatile.LoadUint32(&o.GPR4.Reg) & 0x4000000) >> 26
}
func (o *IOMUXC_GPR_Type) SetGPR4_FLEXSPI_STOP_ACK(value uint32) {
	volatile.StoreUint32(&o.GPR4.Reg, volatile.LoadUint32(&o.GPR4.Reg)&^(0x8000000)|value<<27)
}
func (o *IOMUXC_GPR_Type) GetGPR4_FLEXSPI_STOP_ACK() uint32 {
	return (volatile.LoadUint32(&o.GPR4.Reg) & 0x8000000) >> 27
}
func (o *IOMUXC_GPR_Type) SetGPR4_FLEXIO1_STOP_ACK(value uint32) {
	volatile.StoreUint32(&o.GPR4.Reg, volatile.LoadUint32(&o.GPR4.Reg)&^(0x10000000)|value<<28)
}
func (o *IOMUXC_GPR_Type) GetGPR4_FLEXIO1_STOP_ACK() uint32 {
	return (volatile.LoadUint32(&o.GPR4.Reg) & 0x10000000) >> 28
}

// IOMUXC_GPR.GPR5: GPR5 General Purpose Register
func (o *IOMUXC_GPR_Type) SetGPR5_WDOG1_MASK(value uint32) {
	volatile.StoreUint32(&o.GPR5.Reg, volatile.LoadUint32(&o.GPR5.Reg)&^(0x40)|value<<6)
}
func (o *IOMUXC_GPR_Type) GetGPR5_WDOG1_MASK() uint32 {
	return (volatile.LoadUint32(&o.GPR5.Reg) & 0x40) >> 6
}
func (o *IOMUXC_GPR_Type) SetGPR5_WDOG2_MASK(value uint32) {
	volatile.StoreUint32(&o.GPR5.Reg, volatile.LoadUint32(&o.GPR5.Reg)&^(0x80)|value<<7)
}
func (o *IOMUXC_GPR_Type) GetGPR5_WDOG2_MASK() uint32 {
	return (volatile.LoadUint32(&o.GPR5.Reg) & 0x80) >> 7
}
func (o *IOMUXC_GPR_Type) SetGPR5_VREF_1M_CLK_GPT1(value uint32) {
	volatile.StoreUint32(&o.GPR5.Reg, volatile.LoadUint32(&o.GPR5.Reg)&^(0x10000000)|value<<28)
}
func (o *IOMUXC_GPR_Type) GetGPR5_VREF_1M_CLK_GPT1() uint32 {
	return (volatile.LoadUint32(&o.GPR5.Reg) & 0x10000000) >> 28
}
func (o *IOMUXC_GPR_Type) SetGPR5_VREF_1M_CLK_GPT2(value uint32) {
	volatile.StoreUint32(&o.GPR5.Reg, volatile.LoadUint32(&o.GPR5.Reg)&^(0x20000000)|value<<29)
}
func (o *IOMUXC_GPR_Type) GetGPR5_VREF_1M_CLK_GPT2() uint32 {
	return (volatile.LoadUint32(&o.GPR5.Reg) & 0x20000000) >> 29
}

// IOMUXC_GPR.GPR6: GPR6 General Purpose Register
func (o *IOMUXC_GPR_Type) SetGPR6_IOMUXC_XBAR_DIR_SEL_2(value uint32) {
	volatile.StoreUint32(&o.GPR6.Reg, volatile.LoadUint32(&o.GPR6.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_GPR_Type) GetGPR6_IOMUXC_XBAR_DIR_SEL_2() uint32 {
	return (volatile.LoadUint32(&o.GPR6.Reg) & 0x10000) >> 16
}
func (o *IOMUXC_GPR_Type) SetGPR6_IOMUXC_XBAR_DIR_SEL_3(value uint32) {
	volatile.StoreUint32(&o.GPR6.Reg, volatile.LoadUint32(&o.GPR6.Reg)&^(0x20000)|value<<17)
}
func (o *IOMUXC_GPR_Type) GetGPR6_IOMUXC_XBAR_DIR_SEL_3() uint32 {
	return (volatile.LoadUint32(&o.GPR6.Reg) & 0x20000) >> 17
}

// IOMUXC_GPR.GPR7: GPR7 General Purpose Register
func (o *IOMUXC_GPR_Type) SetGPR7_LPI2C1_STOP_REQ(value uint32) {
	volatile.StoreUint32(&o.GPR7.Reg, volatile.LoadUint32(&o.GPR7.Reg)&^(0x1)|value)
}
func (o *IOMUXC_GPR_Type) GetGPR7_LPI2C1_STOP_REQ() uint32 {
	return volatile.LoadUint32(&o.GPR7.Reg) & 0x1
}
func (o *IOMUXC_GPR_Type) SetGPR7_LPI2C2_STOP_REQ(value uint32) {
	volatile.StoreUint32(&o.GPR7.Reg, volatile.LoadUint32(&o.GPR7.Reg)&^(0x2)|value<<1)
}
func (o *IOMUXC_GPR_Type) GetGPR7_LPI2C2_STOP_REQ() uint32 {
	return (volatile.LoadUint32(&o.GPR7.Reg) & 0x2) >> 1
}
func (o *IOMUXC_GPR_Type) SetGPR7_LPSPI1_STOP_REQ(value uint32) {
	volatile.StoreUint32(&o.GPR7.Reg, volatile.LoadUint32(&o.GPR7.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_GPR_Type) GetGPR7_LPSPI1_STOP_REQ() uint32 {
	return (volatile.LoadUint32(&o.GPR7.Reg) & 0x10) >> 4
}
func (o *IOMUXC_GPR_Type) SetGPR7_LPSPI2_STOP_REQ(value uint32) {
	volatile.StoreUint32(&o.GPR7.Reg, volatile.LoadUint32(&o.GPR7.Reg)&^(0x20)|value<<5)
}
func (o *IOMUXC_GPR_Type) GetGPR7_LPSPI2_STOP_REQ() uint32 {
	return (volatile.LoadUint32(&o.GPR7.Reg) & 0x20) >> 5
}
func (o *IOMUXC_GPR_Type) SetGPR7_LPUART1_STOP_REQ(value uint32) {
	volatile.StoreUint32(&o.GPR7.Reg, volatile.LoadUint32(&o.GPR7.Reg)&^(0x100)|value<<8)
}
func (o *IOMUXC_GPR_Type) GetGPR7_LPUART1_STOP_REQ() uint32 {
	return (volatile.LoadUint32(&o.GPR7.Reg) & 0x100) >> 8
}
func (o *IOMUXC_GPR_Type) SetGPR7_LPUART2_STOP_REQ(value uint32) {
	volatile.StoreUint32(&o.GPR7.Reg, volatile.LoadUint32(&o.GPR7.Reg)&^(0x200)|value<<9)
}
func (o *IOMUXC_GPR_Type) GetGPR7_LPUART2_STOP_REQ() uint32 {
	return (volatile.LoadUint32(&o.GPR7.Reg) & 0x200) >> 9
}
func (o *IOMUXC_GPR_Type) SetGPR7_LPUART3_STOP_REQ(value uint32) {
	volatile.StoreUint32(&o.GPR7.Reg, volatile.LoadUint32(&o.GPR7.Reg)&^(0x400)|value<<10)
}
func (o *IOMUXC_GPR_Type) GetGPR7_LPUART3_STOP_REQ() uint32 {
	return (volatile.LoadUint32(&o.GPR7.Reg) & 0x400) >> 10
}
func (o *IOMUXC_GPR_Type) SetGPR7_LPUART4_STOP_REQ(value uint32) {
	volatile.StoreUint32(&o.GPR7.Reg, volatile.LoadUint32(&o.GPR7.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_GPR_Type) GetGPR7_LPUART4_STOP_REQ() uint32 {
	return (volatile.LoadUint32(&o.GPR7.Reg) & 0x800) >> 11
}
func (o *IOMUXC_GPR_Type) SetGPR7_LPI2C1_STOP_ACK(value uint32) {
	volatile.StoreUint32(&o.GPR7.Reg, volatile.LoadUint32(&o.GPR7.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_GPR_Type) GetGPR7_LPI2C1_STOP_ACK() uint32 {
	return (volatile.LoadUint32(&o.GPR7.Reg) & 0x10000) >> 16
}
func (o *IOMUXC_GPR_Type) SetGPR7_LPI2C2_STOP_ACK(value uint32) {
	volatile.StoreUint32(&o.GPR7.Reg, volatile.LoadUint32(&o.GPR7.Reg)&^(0x20000)|value<<17)
}
func (o *IOMUXC_GPR_Type) GetGPR7_LPI2C2_STOP_ACK() uint32 {
	return (volatile.LoadUint32(&o.GPR7.Reg) & 0x20000) >> 17
}
func (o *IOMUXC_GPR_Type) SetGPR7_LPSPI1_STOP_ACK(value uint32) {
	volatile.StoreUint32(&o.GPR7.Reg, volatile.LoadUint32(&o.GPR7.Reg)&^(0x100000)|value<<20)
}
func (o *IOMUXC_GPR_Type) GetGPR7_LPSPI1_STOP_ACK() uint32 {
	return (volatile.LoadUint32(&o.GPR7.Reg) & 0x100000) >> 20
}
func (o *IOMUXC_GPR_Type) SetGPR7_LPSPI2_STOP_ACK(value uint32) {
	volatile.StoreUint32(&o.GPR7.Reg, volatile.LoadUint32(&o.GPR7.Reg)&^(0x200000)|value<<21)
}
func (o *IOMUXC_GPR_Type) GetGPR7_LPSPI2_STOP_ACK() uint32 {
	return (volatile.LoadUint32(&o.GPR7.Reg) & 0x200000) >> 21
}
func (o *IOMUXC_GPR_Type) SetGPR7_LPUART1_STOP_ACK(value uint32) {
	volatile.StoreUint32(&o.GPR7.Reg, volatile.LoadUint32(&o.GPR7.Reg)&^(0x1000000)|value<<24)
}
func (o *IOMUXC_GPR_Type) GetGPR7_LPUART1_STOP_ACK() uint32 {
	return (volatile.LoadUint32(&o.GPR7.Reg) & 0x1000000) >> 24
}
func (o *IOMUXC_GPR_Type) SetGPR7_LPUART2_STOP_ACK(value uint32) {
	volatile.StoreUint32(&o.GPR7.Reg, volatile.LoadUint32(&o.GPR7.Reg)&^(0x2000000)|value<<25)
}
func (o *IOMUXC_GPR_Type) GetGPR7_LPUART2_STOP_ACK() uint32 {
	return (volatile.LoadUint32(&o.GPR7.Reg) & 0x2000000) >> 25
}
func (o *IOMUXC_GPR_Type) SetGPR7_LPUART3_STOP_ACK(value uint32) {
	volatile.StoreUint32(&o.GPR7.Reg, volatile.LoadUint32(&o.GPR7.Reg)&^(0x4000000)|value<<26)
}
func (o *IOMUXC_GPR_Type) GetGPR7_LPUART3_STOP_ACK() uint32 {
	return (volatile.LoadUint32(&o.GPR7.Reg) & 0x4000000) >> 26
}
func (o *IOMUXC_GPR_Type) SetGPR7_LPUART4_STOP_ACK(value uint32) {
	volatile.StoreUint32(&o.GPR7.Reg, volatile.LoadUint32(&o.GPR7.Reg)&^(0x8000000)|value<<27)
}
func (o *IOMUXC_GPR_Type) GetGPR7_LPUART4_STOP_ACK() uint32 {
	return (volatile.LoadUint32(&o.GPR7.Reg) & 0x8000000) >> 27
}

// IOMUXC_GPR.GPR8: GPR8 General Purpose Register
func (o *IOMUXC_GPR_Type) SetGPR8_LPI2C1_IPG_STOP_MODE(value uint32) {
	volatile.StoreUint32(&o.GPR8.Reg, volatile.LoadUint32(&o.GPR8.Reg)&^(0x1)|value)
}
func (o *IOMUXC_GPR_Type) GetGPR8_LPI2C1_IPG_STOP_MODE() uint32 {
	return volatile.LoadUint32(&o.GPR8.Reg) & 0x1
}
func (o *IOMUXC_GPR_Type) SetGPR8_LPI2C1_IPG_DOZE(value uint32) {
	volatile.StoreUint32(&o.GPR8.Reg, volatile.LoadUint32(&o.GPR8.Reg)&^(0x2)|value<<1)
}
func (o *IOMUXC_GPR_Type) GetGPR8_LPI2C1_IPG_DOZE() uint32 {
	return (volatile.LoadUint32(&o.GPR8.Reg) & 0x2) >> 1
}
func (o *IOMUXC_GPR_Type) SetGPR8_LPI2C2_IPG_STOP_MODE(value uint32) {
	volatile.StoreUint32(&o.GPR8.Reg, volatile.LoadUint32(&o.GPR8.Reg)&^(0x4)|value<<2)
}
func (o *IOMUXC_GPR_Type) GetGPR8_LPI2C2_IPG_STOP_MODE() uint32 {
	return (volatile.LoadUint32(&o.GPR8.Reg) & 0x4) >> 2
}
func (o *IOMUXC_GPR_Type) SetGPR8_LPI2C2_IPG_DOZE(value uint32) {
	volatile.StoreUint32(&o.GPR8.Reg, volatile.LoadUint32(&o.GPR8.Reg)&^(0x8)|value<<3)
}
func (o *IOMUXC_GPR_Type) GetGPR8_LPI2C2_IPG_DOZE() uint32 {
	return (volatile.LoadUint32(&o.GPR8.Reg) & 0x8) >> 3
}
func (o *IOMUXC_GPR_Type) SetGPR8_LPSPI1_IPG_STOP_MODE(value uint32) {
	volatile.StoreUint32(&o.GPR8.Reg, volatile.LoadUint32(&o.GPR8.Reg)&^(0x100)|value<<8)
}
func (o *IOMUXC_GPR_Type) GetGPR8_LPSPI1_IPG_STOP_MODE() uint32 {
	return (volatile.LoadUint32(&o.GPR8.Reg) & 0x100) >> 8
}
func (o *IOMUXC_GPR_Type) SetGPR8_LPSPI1_IPG_DOZE(value uint32) {
	volatile.StoreUint32(&o.GPR8.Reg, volatile.LoadUint32(&o.GPR8.Reg)&^(0x200)|value<<9)
}
func (o *IOMUXC_GPR_Type) GetGPR8_LPSPI1_IPG_DOZE() uint32 {
	return (volatile.LoadUint32(&o.GPR8.Reg) & 0x200) >> 9
}
func (o *IOMUXC_GPR_Type) SetGPR8_LPSPI2_IPG_STOP_MODE(value uint32) {
	volatile.StoreUint32(&o.GPR8.Reg, volatile.LoadUint32(&o.GPR8.Reg)&^(0x400)|value<<10)
}
func (o *IOMUXC_GPR_Type) GetGPR8_LPSPI2_IPG_STOP_MODE() uint32 {
	return (volatile.LoadUint32(&o.GPR8.Reg) & 0x400) >> 10
}
func (o *IOMUXC_GPR_Type) SetGPR8_LPSPI2_IPG_DOZE(value uint32) {
	volatile.StoreUint32(&o.GPR8.Reg, volatile.LoadUint32(&o.GPR8.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_GPR_Type) GetGPR8_LPSPI2_IPG_DOZE() uint32 {
	return (volatile.LoadUint32(&o.GPR8.Reg) & 0x800) >> 11
}
func (o *IOMUXC_GPR_Type) SetGPR8_LPUART1_IPG_STOP_MODE(value uint32) {
	volatile.StoreUint32(&o.GPR8.Reg, volatile.LoadUint32(&o.GPR8.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_GPR_Type) GetGPR8_LPUART1_IPG_STOP_MODE() uint32 {
	return (volatile.LoadUint32(&o.GPR8.Reg) & 0x10000) >> 16
}
func (o *IOMUXC_GPR_Type) SetGPR8_LPUART1_IPG_DOZE(value uint32) {
	volatile.StoreUint32(&o.GPR8.Reg, volatile.LoadUint32(&o.GPR8.Reg)&^(0x20000)|value<<17)
}
func (o *IOMUXC_GPR_Type) GetGPR8_LPUART1_IPG_DOZE() uint32 {
	return (volatile.LoadUint32(&o.GPR8.Reg) & 0x20000) >> 17
}
func (o *IOMUXC_GPR_Type) SetGPR8_LPUART2_IPG_STOP_MODE(value uint32) {
	volatile.StoreUint32(&o.GPR8.Reg, volatile.LoadUint32(&o.GPR8.Reg)&^(0x40000)|value<<18)
}
func (o *IOMUXC_GPR_Type) GetGPR8_LPUART2_IPG_STOP_MODE() uint32 {
	return (volatile.LoadUint32(&o.GPR8.Reg) & 0x40000) >> 18
}
func (o *IOMUXC_GPR_Type) SetGPR8_LPUART2_IPG_DOZE(value uint32) {
	volatile.StoreUint32(&o.GPR8.Reg, volatile.LoadUint32(&o.GPR8.Reg)&^(0x80000)|value<<19)
}
func (o *IOMUXC_GPR_Type) GetGPR8_LPUART2_IPG_DOZE() uint32 {
	return (volatile.LoadUint32(&o.GPR8.Reg) & 0x80000) >> 19
}
func (o *IOMUXC_GPR_Type) SetGPR8_LPUART3_IPG_STOP_MODE(value uint32) {
	volatile.StoreUint32(&o.GPR8.Reg, volatile.LoadUint32(&o.GPR8.Reg)&^(0x100000)|value<<20)
}
func (o *IOMUXC_GPR_Type) GetGPR8_LPUART3_IPG_STOP_MODE() uint32 {
	return (volatile.LoadUint32(&o.GPR8.Reg) & 0x100000) >> 20
}
func (o *IOMUXC_GPR_Type) SetGPR8_LPUART3_IPG_DOZE(value uint32) {
	volatile.StoreUint32(&o.GPR8.Reg, volatile.LoadUint32(&o.GPR8.Reg)&^(0x200000)|value<<21)
}
func (o *IOMUXC_GPR_Type) GetGPR8_LPUART3_IPG_DOZE() uint32 {
	return (volatile.LoadUint32(&o.GPR8.Reg) & 0x200000) >> 21
}
func (o *IOMUXC_GPR_Type) SetGPR8_LPUART4_IPG_STOP_MODE(value uint32) {
	volatile.StoreUint32(&o.GPR8.Reg, volatile.LoadUint32(&o.GPR8.Reg)&^(0x400000)|value<<22)
}
func (o *IOMUXC_GPR_Type) GetGPR8_LPUART4_IPG_STOP_MODE() uint32 {
	return (volatile.LoadUint32(&o.GPR8.Reg) & 0x400000) >> 22
}
func (o *IOMUXC_GPR_Type) SetGPR8_LPUART4_IPG_DOZE(value uint32) {
	volatile.StoreUint32(&o.GPR8.Reg, volatile.LoadUint32(&o.GPR8.Reg)&^(0x800000)|value<<23)
}
func (o *IOMUXC_GPR_Type) GetGPR8_LPUART4_IPG_DOZE() uint32 {
	return (volatile.LoadUint32(&o.GPR8.Reg) & 0x800000) >> 23
}

// IOMUXC_GPR.GPR10: GPR10 General Purpose Register
func (o *IOMUXC_GPR_Type) SetGPR10_NIDEN(value uint32) {
	volatile.StoreUint32(&o.GPR10.Reg, volatile.LoadUint32(&o.GPR10.Reg)&^(0x1)|value)
}
func (o *IOMUXC_GPR_Type) GetGPR10_NIDEN() uint32 {
	return volatile.LoadUint32(&o.GPR10.Reg) & 0x1
}
func (o *IOMUXC_GPR_Type) SetGPR10_DBG_EN(value uint32) {
	volatile.StoreUint32(&o.GPR10.Reg, volatile.LoadUint32(&o.GPR10.Reg)&^(0x2)|value<<1)
}
func (o *IOMUXC_GPR_Type) GetGPR10_DBG_EN() uint32 {
	return (volatile.LoadUint32(&o.GPR10.Reg) & 0x2) >> 1
}
func (o *IOMUXC_GPR_Type) SetGPR10_SEC_ERR_RESP(value uint32) {
	volatile.StoreUint32(&o.GPR10.Reg, volatile.LoadUint32(&o.GPR10.Reg)&^(0x4)|value<<2)
}
func (o *IOMUXC_GPR_Type) GetGPR10_SEC_ERR_RESP() uint32 {
	return (volatile.LoadUint32(&o.GPR10.Reg) & 0x4) >> 2
}
func (o *IOMUXC_GPR_Type) SetGPR10_DCPKEY_OCOTP_OR_KEYMUX(value uint32) {
	volatile.StoreUint32(&o.GPR10.Reg, volatile.LoadUint32(&o.GPR10.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_GPR_Type) GetGPR10_DCPKEY_OCOTP_OR_KEYMUX() uint32 {
	return (volatile.LoadUint32(&o.GPR10.Reg) & 0x10) >> 4
}
func (o *IOMUXC_GPR_Type) SetGPR10_OCRAM_TZ_EN(value uint32) {
	volatile.StoreUint32(&o.GPR10.Reg, volatile.LoadUint32(&o.GPR10.Reg)&^(0x100)|value<<8)
}
func (o *IOMUXC_GPR_Type) GetGPR10_OCRAM_TZ_EN() uint32 {
	return (volatile.LoadUint32(&o.GPR10.Reg) & 0x100) >> 8
}
func (o *IOMUXC_GPR_Type) SetGPR10_OCRAM_TZ_ADDR(value uint32) {
	volatile.StoreUint32(&o.GPR10.Reg, volatile.LoadUint32(&o.GPR10.Reg)&^(0x3e00)|value<<9)
}
func (o *IOMUXC_GPR_Type) GetGPR10_OCRAM_TZ_ADDR() uint32 {
	return (volatile.LoadUint32(&o.GPR10.Reg) & 0x3e00) >> 9
}
func (o *IOMUXC_GPR_Type) SetGPR10_LOCK_NIDEN(value uint32) {
	volatile.StoreUint32(&o.GPR10.Reg, volatile.LoadUint32(&o.GPR10.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_GPR_Type) GetGPR10_LOCK_NIDEN() uint32 {
	return (volatile.LoadUint32(&o.GPR10.Reg) & 0x10000) >> 16
}
func (o *IOMUXC_GPR_Type) SetGPR10_LOCK_DBG_EN(value uint32) {
	volatile.StoreUint32(&o.GPR10.Reg, volatile.LoadUint32(&o.GPR10.Reg)&^(0x20000)|value<<17)
}
func (o *IOMUXC_GPR_Type) GetGPR10_LOCK_DBG_EN() uint32 {
	return (volatile.LoadUint32(&o.GPR10.Reg) & 0x20000) >> 17
}
func (o *IOMUXC_GPR_Type) SetGPR10_LOCK_SEC_ERR_RESP(value uint32) {
	volatile.StoreUint32(&o.GPR10.Reg, volatile.LoadUint32(&o.GPR10.Reg)&^(0x40000)|value<<18)
}
func (o *IOMUXC_GPR_Type) GetGPR10_LOCK_SEC_ERR_RESP() uint32 {
	return (volatile.LoadUint32(&o.GPR10.Reg) & 0x40000) >> 18
}
func (o *IOMUXC_GPR_Type) SetGPR10_LOCK_DCPKEY_OCOTP_OR_KEYMUX(value uint32) {
	volatile.StoreUint32(&o.GPR10.Reg, volatile.LoadUint32(&o.GPR10.Reg)&^(0x100000)|value<<20)
}
func (o *IOMUXC_GPR_Type) GetGPR10_LOCK_DCPKEY_OCOTP_OR_KEYMUX() uint32 {
	return (volatile.LoadUint32(&o.GPR10.Reg) & 0x100000) >> 20
}
func (o *IOMUXC_GPR_Type) SetGPR10_LOCK_OCRAM_TZ_EN(value uint32) {
	volatile.StoreUint32(&o.GPR10.Reg, volatile.LoadUint32(&o.GPR10.Reg)&^(0x1000000)|value<<24)
}
func (o *IOMUXC_GPR_Type) GetGPR10_LOCK_OCRAM_TZ_EN() uint32 {
	return (volatile.LoadUint32(&o.GPR10.Reg) & 0x1000000) >> 24
}
func (o *IOMUXC_GPR_Type) SetGPR10_LOCK_OCRAM_TZ_ADDR(value uint32) {
	volatile.StoreUint32(&o.GPR10.Reg, volatile.LoadUint32(&o.GPR10.Reg)&^(0x3e000000)|value<<25)
}
func (o *IOMUXC_GPR_Type) GetGPR10_LOCK_OCRAM_TZ_ADDR() uint32 {
	return (volatile.LoadUint32(&o.GPR10.Reg) & 0x3e000000) >> 25
}

// IOMUXC_GPR.GPR11: GPR11 General Purpose Register
func (o *IOMUXC_GPR_Type) SetGPR11_M7_APC_AC_R0_CTRL(value uint32) {
	volatile.StoreUint32(&o.GPR11.Reg, volatile.LoadUint32(&o.GPR11.Reg)&^(0x3)|value)
}
func (o *IOMUXC_GPR_Type) GetGPR11_M7_APC_AC_R0_CTRL() uint32 {
	return volatile.LoadUint32(&o.GPR11.Reg) & 0x3
}
func (o *IOMUXC_GPR_Type) SetGPR11_M7_APC_AC_R1_CTRL(value uint32) {
	volatile.StoreUint32(&o.GPR11.Reg, volatile.LoadUint32(&o.GPR11.Reg)&^(0xc)|value<<2)
}
func (o *IOMUXC_GPR_Type) GetGPR11_M7_APC_AC_R1_CTRL() uint32 {
	return (volatile.LoadUint32(&o.GPR11.Reg) & 0xc) >> 2
}
func (o *IOMUXC_GPR_Type) SetGPR11_M7_APC_AC_R2_CTRL(value uint32) {
	volatile.StoreUint32(&o.GPR11.Reg, volatile.LoadUint32(&o.GPR11.Reg)&^(0x30)|value<<4)
}
func (o *IOMUXC_GPR_Type) GetGPR11_M7_APC_AC_R2_CTRL() uint32 {
	return (volatile.LoadUint32(&o.GPR11.Reg) & 0x30) >> 4
}
func (o *IOMUXC_GPR_Type) SetGPR11_M7_APC_AC_R3_CTRL(value uint32) {
	volatile.StoreUint32(&o.GPR11.Reg, volatile.LoadUint32(&o.GPR11.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_GPR_Type) GetGPR11_M7_APC_AC_R3_CTRL() uint32 {
	return (volatile.LoadUint32(&o.GPR11.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_GPR_Type) SetGPR11_LOCK_M7_APC_AC_R0_CTRL(value uint32) {
	volatile.StoreUint32(&o.GPR11.Reg, volatile.LoadUint32(&o.GPR11.Reg)&^(0x30000)|value<<16)
}
func (o *IOMUXC_GPR_Type) GetGPR11_LOCK_M7_APC_AC_R0_CTRL() uint32 {
	return (volatile.LoadUint32(&o.GPR11.Reg) & 0x30000) >> 16
}
func (o *IOMUXC_GPR_Type) SetGPR11_LOCK_M7_APC_AC_R1_CTRL(value uint32) {
	volatile.StoreUint32(&o.GPR11.Reg, volatile.LoadUint32(&o.GPR11.Reg)&^(0xc0000)|value<<18)
}
func (o *IOMUXC_GPR_Type) GetGPR11_LOCK_M7_APC_AC_R1_CTRL() uint32 {
	return (volatile.LoadUint32(&o.GPR11.Reg) & 0xc0000) >> 18
}
func (o *IOMUXC_GPR_Type) SetGPR11_LOCK_M7_APC_AC_R2_CTRL(value uint32) {
	volatile.StoreUint32(&o.GPR11.Reg, volatile.LoadUint32(&o.GPR11.Reg)&^(0x300000)|value<<20)
}
func (o *IOMUXC_GPR_Type) GetGPR11_LOCK_M7_APC_AC_R2_CTRL() uint32 {
	return (volatile.LoadUint32(&o.GPR11.Reg) & 0x300000) >> 20
}
func (o *IOMUXC_GPR_Type) SetGPR11_LOCK_M7_APC_AC_R3_CTRL(value uint32) {
	volatile.StoreUint32(&o.GPR11.Reg, volatile.LoadUint32(&o.GPR11.Reg)&^(0xc00000)|value<<22)
}
func (o *IOMUXC_GPR_Type) GetGPR11_LOCK_M7_APC_AC_R3_CTRL() uint32 {
	return (volatile.LoadUint32(&o.GPR11.Reg) & 0xc00000) >> 22
}

// IOMUXC_GPR.GPR12: GPR12 General Purpose Register
func (o *IOMUXC_GPR_Type) SetGPR12_FLEXIO1_IPG_STOP_MODE(value uint32) {
	volatile.StoreUint32(&o.GPR12.Reg, volatile.LoadUint32(&o.GPR12.Reg)&^(0x1)|value)
}
func (o *IOMUXC_GPR_Type) GetGPR12_FLEXIO1_IPG_STOP_MODE() uint32 {
	return volatile.LoadUint32(&o.GPR12.Reg) & 0x1
}
func (o *IOMUXC_GPR_Type) SetGPR12_FLEXIO1_IPG_DOZE(value uint32) {
	volatile.StoreUint32(&o.GPR12.Reg, volatile.LoadUint32(&o.GPR12.Reg)&^(0x2)|value<<1)
}
func (o *IOMUXC_GPR_Type) GetGPR12_FLEXIO1_IPG_DOZE() uint32 {
	return (volatile.LoadUint32(&o.GPR12.Reg) & 0x2) >> 1
}

// IOMUXC_GPR.GPR13: GPR13 General Purpose Register
func (o *IOMUXC_GPR_Type) SetGPR13_CACHE_USB(value uint32) {
	volatile.StoreUint32(&o.GPR13.Reg, volatile.LoadUint32(&o.GPR13.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_GPR_Type) GetGPR13_CACHE_USB() uint32 {
	return (volatile.LoadUint32(&o.GPR13.Reg) & 0x2000) >> 13
}

// IOMUXC_GPR.GPR14: GPR14 General Purpose Register
func (o *IOMUXC_GPR_Type) SetGPR14_CM7_CFGITCMSZ(value uint32) {
	volatile.StoreUint32(&o.GPR14.Reg, volatile.LoadUint32(&o.GPR14.Reg)&^(0xf0000)|value<<16)
}
func (o *IOMUXC_GPR_Type) GetGPR14_CM7_CFGITCMSZ() uint32 {
	return (volatile.LoadUint32(&o.GPR14.Reg) & 0xf0000) >> 16
}
func (o *IOMUXC_GPR_Type) SetGPR14_CM7_CFGDTCMSZ(value uint32) {
	volatile.StoreUint32(&o.GPR14.Reg, volatile.LoadUint32(&o.GPR14.Reg)&^(0xf00000)|value<<20)
}
func (o *IOMUXC_GPR_Type) GetGPR14_CM7_CFGDTCMSZ() uint32 {
	return (volatile.LoadUint32(&o.GPR14.Reg) & 0xf00000) >> 20
}

// IOMUXC_GPR.GPR16: GPR16 General Purpose Register
func (o *IOMUXC_GPR_Type) SetGPR16_INIT_ITCM_EN(value uint32) {
	volatile.StoreUint32(&o.GPR16.Reg, volatile.LoadUint32(&o.GPR16.Reg)&^(0x1)|value)
}
func (o *IOMUXC_GPR_Type) GetGPR16_INIT_ITCM_EN() uint32 {
	return volatile.LoadUint32(&o.GPR16.Reg) & 0x1
}
func (o *IOMUXC_GPR_Type) SetGPR16_INIT_DTCM_EN(value uint32) {
	volatile.StoreUint32(&o.GPR16.Reg, volatile.LoadUint32(&o.GPR16.Reg)&^(0x2)|value<<1)
}
func (o *IOMUXC_GPR_Type) GetGPR16_INIT_DTCM_EN() uint32 {
	return (volatile.LoadUint32(&o.GPR16.Reg) & 0x2) >> 1
}
func (o *IOMUXC_GPR_Type) SetGPR16_FLEXRAM_BANK_CFG_SEL(value uint32) {
	volatile.StoreUint32(&o.GPR16.Reg, volatile.LoadUint32(&o.GPR16.Reg)&^(0x4)|value<<2)
}
func (o *IOMUXC_GPR_Type) GetGPR16_FLEXRAM_BANK_CFG_SEL() uint32 {
	return (volatile.LoadUint32(&o.GPR16.Reg) & 0x4) >> 2
}
func (o *IOMUXC_GPR_Type) SetGPR16_LOCK_VTOR(value uint32) {
	volatile.StoreUint32(&o.GPR16.Reg, volatile.LoadUint32(&o.GPR16.Reg)&^(0x40)|value<<6)
}
func (o *IOMUXC_GPR_Type) GetGPR16_LOCK_VTOR() uint32 {
	return (volatile.LoadUint32(&o.GPR16.Reg) & 0x40) >> 6
}
func (o *IOMUXC_GPR_Type) SetGPR16_CM7_INIT_VTOR(value uint32) {
	volatile.StoreUint32(&o.GPR16.Reg, volatile.LoadUint32(&o.GPR16.Reg)&^(0xffffff80)|value<<7)
}
func (o *IOMUXC_GPR_Type) GetGPR16_CM7_INIT_VTOR() uint32 {
	return (volatile.LoadUint32(&o.GPR16.Reg) & 0xffffff80) >> 7
}

// IOMUXC_GPR.GPR17: GPR17 General Purpose Register
func (o *IOMUXC_GPR_Type) SetGPR17_FLEXRAM_BANK_CFG(value uint32) {
	volatile.StoreUint32(&o.GPR17.Reg, volatile.LoadUint32(&o.GPR17.Reg)&^(0xff)|value)
}
func (o *IOMUXC_GPR_Type) GetGPR17_FLEXRAM_BANK_CFG() uint32 {
	return volatile.LoadUint32(&o.GPR17.Reg) & 0xff
}

// IOMUXC_GPR.GPR18: GPR18 General Purpose Register
func (o *IOMUXC_GPR_Type) SetGPR18_LOCK_M7_APC_AC_R0_BOT(value uint32) {
	volatile.StoreUint32(&o.GPR18.Reg, volatile.LoadUint32(&o.GPR18.Reg)&^(0x1)|value)
}
func (o *IOMUXC_GPR_Type) GetGPR18_LOCK_M7_APC_AC_R0_BOT() uint32 {
	return volatile.LoadUint32(&o.GPR18.Reg) & 0x1
}
func (o *IOMUXC_GPR_Type) SetGPR18_M7_APC_AC_R0_BOT(value uint32) {
	volatile.StoreUint32(&o.GPR18.Reg, volatile.LoadUint32(&o.GPR18.Reg)&^(0xfffffff8)|value<<3)
}
func (o *IOMUXC_GPR_Type) GetGPR18_M7_APC_AC_R0_BOT() uint32 {
	return (volatile.LoadUint32(&o.GPR18.Reg) & 0xfffffff8) >> 3
}

// IOMUXC_GPR.GPR19: GPR19 General Purpose Register
func (o *IOMUXC_GPR_Type) SetGPR19_LOCK_M7_APC_AC_R0_TOP(value uint32) {
	volatile.StoreUint32(&o.GPR19.Reg, volatile.LoadUint32(&o.GPR19.Reg)&^(0x1)|value)
}
func (o *IOMUXC_GPR_Type) GetGPR19_LOCK_M7_APC_AC_R0_TOP() uint32 {
	return volatile.LoadUint32(&o.GPR19.Reg) & 0x1
}
func (o *IOMUXC_GPR_Type) SetGPR19_M7_APC_AC_R0_TOP(value uint32) {
	volatile.StoreUint32(&o.GPR19.Reg, volatile.LoadUint32(&o.GPR19.Reg)&^(0xfffffff8)|value<<3)
}
func (o *IOMUXC_GPR_Type) GetGPR19_M7_APC_AC_R0_TOP() uint32 {
	return (volatile.LoadUint32(&o.GPR19.Reg) & 0xfffffff8) >> 3
}

// IOMUXC_GPR.GPR20: GPR20 General Purpose Register
func (o *IOMUXC_GPR_Type) SetGPR20_LOCK_M7_APC_AC_R1_BOT(value uint32) {
	volatile.StoreUint32(&o.GPR20.Reg, volatile.LoadUint32(&o.GPR20.Reg)&^(0x1)|value)
}
func (o *IOMUXC_GPR_Type) GetGPR20_LOCK_M7_APC_AC_R1_BOT() uint32 {
	return volatile.LoadUint32(&o.GPR20.Reg) & 0x1
}
func (o *IOMUXC_GPR_Type) SetGPR20_M7_APC_AC_R1_BOT(value uint32) {
	volatile.StoreUint32(&o.GPR20.Reg, volatile.LoadUint32(&o.GPR20.Reg)&^(0xfffffff8)|value<<3)
}
func (o *IOMUXC_GPR_Type) GetGPR20_M7_APC_AC_R1_BOT() uint32 {
	return (volatile.LoadUint32(&o.GPR20.Reg) & 0xfffffff8) >> 3
}

// IOMUXC_GPR.GPR21: GPR21 General Purpose Register
func (o *IOMUXC_GPR_Type) SetGPR21_LOCK_M7_APC_AC_R1_TOP(value uint32) {
	volatile.StoreUint32(&o.GPR21.Reg, volatile.LoadUint32(&o.GPR21.Reg)&^(0x1)|value)
}
func (o *IOMUXC_GPR_Type) GetGPR21_LOCK_M7_APC_AC_R1_TOP() uint32 {
	return volatile.LoadUint32(&o.GPR21.Reg) & 0x1
}
func (o *IOMUXC_GPR_Type) SetGPR21_M7_APC_AC_R1_TOP(value uint32) {
	volatile.StoreUint32(&o.GPR21.Reg, volatile.LoadUint32(&o.GPR21.Reg)&^(0xfffffff8)|value<<3)
}
func (o *IOMUXC_GPR_Type) GetGPR21_M7_APC_AC_R1_TOP() uint32 {
	return (volatile.LoadUint32(&o.GPR21.Reg) & 0xfffffff8) >> 3
}

// IOMUXC_GPR.GPR22: GPR22 General Purpose Register
func (o *IOMUXC_GPR_Type) SetGPR22_LOCK_M7_APC_AC_R2_BOT(value uint32) {
	volatile.StoreUint32(&o.GPR22.Reg, volatile.LoadUint32(&o.GPR22.Reg)&^(0x1)|value)
}
func (o *IOMUXC_GPR_Type) GetGPR22_LOCK_M7_APC_AC_R2_BOT() uint32 {
	return volatile.LoadUint32(&o.GPR22.Reg) & 0x1
}
func (o *IOMUXC_GPR_Type) SetGPR22_M7_APC_AC_R2_BOT(value uint32) {
	volatile.StoreUint32(&o.GPR22.Reg, volatile.LoadUint32(&o.GPR22.Reg)&^(0xfffffff8)|value<<3)
}
func (o *IOMUXC_GPR_Type) GetGPR22_M7_APC_AC_R2_BOT() uint32 {
	return (volatile.LoadUint32(&o.GPR22.Reg) & 0xfffffff8) >> 3
}

// IOMUXC_GPR.GPR23: GPR23 General Purpose Register
func (o *IOMUXC_GPR_Type) SetGPR23_LOCK_M7_APC_AC_R2_TOP(value uint32) {
	volatile.StoreUint32(&o.GPR23.Reg, volatile.LoadUint32(&o.GPR23.Reg)&^(0x1)|value)
}
func (o *IOMUXC_GPR_Type) GetGPR23_LOCK_M7_APC_AC_R2_TOP() uint32 {
	return volatile.LoadUint32(&o.GPR23.Reg) & 0x1
}
func (o *IOMUXC_GPR_Type) SetGPR23_M7_APC_AC_R2_TOP(value uint32) {
	volatile.StoreUint32(&o.GPR23.Reg, volatile.LoadUint32(&o.GPR23.Reg)&^(0xfffffff8)|value<<3)
}
func (o *IOMUXC_GPR_Type) GetGPR23_M7_APC_AC_R2_TOP() uint32 {
	return (volatile.LoadUint32(&o.GPR23.Reg) & 0xfffffff8) >> 3
}

// IOMUXC_GPR.GPR24: GPR24 General Purpose Register
func (o *IOMUXC_GPR_Type) SetGPR24_LOCK_M7_APC_AC_R3_BOT(value uint32) {
	volatile.StoreUint32(&o.GPR24.Reg, volatile.LoadUint32(&o.GPR24.Reg)&^(0x1)|value)
}
func (o *IOMUXC_GPR_Type) GetGPR24_LOCK_M7_APC_AC_R3_BOT() uint32 {
	return volatile.LoadUint32(&o.GPR24.Reg) & 0x1
}
func (o *IOMUXC_GPR_Type) SetGPR24_M7_APC_AC_R3_BOT(value uint32) {
	volatile.StoreUint32(&o.GPR24.Reg, volatile.LoadUint32(&o.GPR24.Reg)&^(0xfffffff8)|value<<3)
}
func (o *IOMUXC_GPR_Type) GetGPR24_M7_APC_AC_R3_BOT() uint32 {
	return (volatile.LoadUint32(&o.GPR24.Reg) & 0xfffffff8) >> 3
}

// IOMUXC_GPR.GPR25: GPR25 General Purpose Register
func (o *IOMUXC_GPR_Type) SetGPR25_LOCK_M7_APC_AC_R3_TOP(value uint32) {
	volatile.StoreUint32(&o.GPR25.Reg, volatile.LoadUint32(&o.GPR25.Reg)&^(0x1)|value)
}
func (o *IOMUXC_GPR_Type) GetGPR25_LOCK_M7_APC_AC_R3_TOP() uint32 {
	return volatile.LoadUint32(&o.GPR25.Reg) & 0x1
}
func (o *IOMUXC_GPR_Type) SetGPR25_M7_APC_AC_R3_TOP(value uint32) {
	volatile.StoreUint32(&o.GPR25.Reg, volatile.LoadUint32(&o.GPR25.Reg)&^(0xfffffff8)|value<<3)
}
func (o *IOMUXC_GPR_Type) GetGPR25_M7_APC_AC_R3_TOP() uint32 {
	return (volatile.LoadUint32(&o.GPR25.Reg) & 0xfffffff8) >> 3
}

// IOMUXC_GPR.GPR26: GPR26 General Purpose Register
func (o *IOMUXC_GPR_Type) SetGPR26(value uint32) {
	volatile.StoreUint32(&o.GPR26.Reg, value)
}
func (o *IOMUXC_GPR_Type) GetGPR26() uint32 {
	return volatile.LoadUint32(&o.GPR26.Reg)
}

// IOMUXC_GPR.GPR27: GPR27 General Purpose Register
func (o *IOMUXC_GPR_Type) SetGPR27_FLEXSPI_REMAP_ADDR_START(value uint32) {
	volatile.StoreUint32(&o.GPR27.Reg, volatile.LoadUint32(&o.GPR27.Reg)&^(0xfffff000)|value<<12)
}
func (o *IOMUXC_GPR_Type) GetGPR27_FLEXSPI_REMAP_ADDR_START() uint32 {
	return (volatile.LoadUint32(&o.GPR27.Reg) & 0xfffff000) >> 12
}

// IOMUXC_GPR.GPR28: GPR28 General Purpose Register
func (o *IOMUXC_GPR_Type) SetGPR28_FLEXSPI_REMAP_ADDR_END(value uint32) {
	volatile.StoreUint32(&o.GPR28.Reg, volatile.LoadUint32(&o.GPR28.Reg)&^(0xfffff000)|value<<12)
}
func (o *IOMUXC_GPR_Type) GetGPR28_FLEXSPI_REMAP_ADDR_END() uint32 {
	return (volatile.LoadUint32(&o.GPR28.Reg) & 0xfffff000) >> 12
}

// IOMUXC_GPR.GPR29: GPR29 General Purpose Register
func (o *IOMUXC_GPR_Type) SetGPR29_FLEXSPI_REMAP_ADDR_OFFSET(value uint32) {
	volatile.StoreUint32(&o.GPR29.Reg, volatile.LoadUint32(&o.GPR29.Reg)&^(0xfffff000)|value<<12)
}
func (o *IOMUXC_GPR_Type) GetGPR29_FLEXSPI_REMAP_ADDR_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.GPR29.Reg) & 0xfffff000) >> 12
}

// FLEXRAM
type FLEXRAM_Type struct {
	TCM_CTRL         volatile.Register32 // 0x0
	OCRAM_MAGIC_ADDR volatile.Register32 // 0x4
	DTCM_MAGIC_ADDR  volatile.Register32 // 0x8
	ITCM_MAGIC_ADDR  volatile.Register32 // 0xC
	INT_STATUS       volatile.Register32 // 0x10
	INT_STAT_EN      volatile.Register32 // 0x14
	INT_SIG_EN       volatile.Register32 // 0x18
}

// FLEXRAM.TCM_CTRL: TCM CRTL Register
func (o *FLEXRAM_Type) SetTCM_CTRL_TCM_WWAIT_EN(value uint32) {
	volatile.StoreUint32(&o.TCM_CTRL.Reg, volatile.LoadUint32(&o.TCM_CTRL.Reg)&^(0x1)|value)
}
func (o *FLEXRAM_Type) GetTCM_CTRL_TCM_WWAIT_EN() uint32 {
	return volatile.LoadUint32(&o.TCM_CTRL.Reg) & 0x1
}
func (o *FLEXRAM_Type) SetTCM_CTRL_TCM_RWAIT_EN(value uint32) {
	volatile.StoreUint32(&o.TCM_CTRL.Reg, volatile.LoadUint32(&o.TCM_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *FLEXRAM_Type) GetTCM_CTRL_TCM_RWAIT_EN() uint32 {
	return (volatile.LoadUint32(&o.TCM_CTRL.Reg) & 0x2) >> 1
}
func (o *FLEXRAM_Type) SetTCM_CTRL_FORCE_CLK_ON(value uint32) {
	volatile.StoreUint32(&o.TCM_CTRL.Reg, volatile.LoadUint32(&o.TCM_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *FLEXRAM_Type) GetTCM_CTRL_FORCE_CLK_ON() uint32 {
	return (volatile.LoadUint32(&o.TCM_CTRL.Reg) & 0x4) >> 2
}

// FLEXRAM.OCRAM_MAGIC_ADDR: OCRAM Magic Address Register
func (o *FLEXRAM_Type) SetOCRAM_MAGIC_ADDR_OCRAM_WR_RD_SEL(value uint32) {
	volatile.StoreUint32(&o.OCRAM_MAGIC_ADDR.Reg, volatile.LoadUint32(&o.OCRAM_MAGIC_ADDR.Reg)&^(0x1)|value)
}
func (o *FLEXRAM_Type) GetOCRAM_MAGIC_ADDR_OCRAM_WR_RD_SEL() uint32 {
	return volatile.LoadUint32(&o.OCRAM_MAGIC_ADDR.Reg) & 0x1
}
func (o *FLEXRAM_Type) SetOCRAM_MAGIC_ADDR(value uint32) {
	volatile.StoreUint32(&o.OCRAM_MAGIC_ADDR.Reg, volatile.LoadUint32(&o.OCRAM_MAGIC_ADDR.Reg)&^(0x7ffe)|value<<1)
}
func (o *FLEXRAM_Type) GetOCRAM_MAGIC_ADDR() uint32 {
	return (volatile.LoadUint32(&o.OCRAM_MAGIC_ADDR.Reg) & 0x7ffe) >> 1
}

// FLEXRAM.DTCM_MAGIC_ADDR: DTCM Magic Address Register
func (o *FLEXRAM_Type) SetDTCM_MAGIC_ADDR_DTCM_WR_RD_SEL(value uint32) {
	volatile.StoreUint32(&o.DTCM_MAGIC_ADDR.Reg, volatile.LoadUint32(&o.DTCM_MAGIC_ADDR.Reg)&^(0x1)|value)
}
func (o *FLEXRAM_Type) GetDTCM_MAGIC_ADDR_DTCM_WR_RD_SEL() uint32 {
	return volatile.LoadUint32(&o.DTCM_MAGIC_ADDR.Reg) & 0x1
}
func (o *FLEXRAM_Type) SetDTCM_MAGIC_ADDR(value uint32) {
	volatile.StoreUint32(&o.DTCM_MAGIC_ADDR.Reg, volatile.LoadUint32(&o.DTCM_MAGIC_ADDR.Reg)&^(0x7ffe)|value<<1)
}
func (o *FLEXRAM_Type) GetDTCM_MAGIC_ADDR() uint32 {
	return (volatile.LoadUint32(&o.DTCM_MAGIC_ADDR.Reg) & 0x7ffe) >> 1
}

// FLEXRAM.ITCM_MAGIC_ADDR: ITCM Magic Address Register
func (o *FLEXRAM_Type) SetITCM_MAGIC_ADDR_ITCM_WR_RD_SEL(value uint32) {
	volatile.StoreUint32(&o.ITCM_MAGIC_ADDR.Reg, volatile.LoadUint32(&o.ITCM_MAGIC_ADDR.Reg)&^(0x1)|value)
}
func (o *FLEXRAM_Type) GetITCM_MAGIC_ADDR_ITCM_WR_RD_SEL() uint32 {
	return volatile.LoadUint32(&o.ITCM_MAGIC_ADDR.Reg) & 0x1
}
func (o *FLEXRAM_Type) SetITCM_MAGIC_ADDR(value uint32) {
	volatile.StoreUint32(&o.ITCM_MAGIC_ADDR.Reg, volatile.LoadUint32(&o.ITCM_MAGIC_ADDR.Reg)&^(0x7ffe)|value<<1)
}
func (o *FLEXRAM_Type) GetITCM_MAGIC_ADDR() uint32 {
	return (volatile.LoadUint32(&o.ITCM_MAGIC_ADDR.Reg) & 0x7ffe) >> 1
}

// FLEXRAM.INT_STATUS: Interrupt Status Register
func (o *FLEXRAM_Type) SetINT_STATUS_ITCM_MAM_STATUS(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x1)|value)
}
func (o *FLEXRAM_Type) GetINT_STATUS_ITCM_MAM_STATUS() uint32 {
	return volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x1
}
func (o *FLEXRAM_Type) SetINT_STATUS_DTCM_MAM_STATUS(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x2)|value<<1)
}
func (o *FLEXRAM_Type) GetINT_STATUS_DTCM_MAM_STATUS() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x2) >> 1
}
func (o *FLEXRAM_Type) SetINT_STATUS_OCRAM_MAM_STATUS(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x4)|value<<2)
}
func (o *FLEXRAM_Type) GetINT_STATUS_OCRAM_MAM_STATUS() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x4) >> 2
}
func (o *FLEXRAM_Type) SetINT_STATUS_ITCM_ERR_STATUS(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x8)|value<<3)
}
func (o *FLEXRAM_Type) GetINT_STATUS_ITCM_ERR_STATUS() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x8) >> 3
}
func (o *FLEXRAM_Type) SetINT_STATUS_DTCM_ERR_STATUS(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x10)|value<<4)
}
func (o *FLEXRAM_Type) GetINT_STATUS_DTCM_ERR_STATUS() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x10) >> 4
}
func (o *FLEXRAM_Type) SetINT_STATUS_OCRAM_ERR_STATUS(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x20)|value<<5)
}
func (o *FLEXRAM_Type) GetINT_STATUS_OCRAM_ERR_STATUS() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x20) >> 5
}

// FLEXRAM.INT_STAT_EN: Interrupt Status Enable Register
func (o *FLEXRAM_Type) SetINT_STAT_EN_ITCM_MAM_STAT_EN(value uint32) {
	volatile.StoreUint32(&o.INT_STAT_EN.Reg, volatile.LoadUint32(&o.INT_STAT_EN.Reg)&^(0x1)|value)
}
func (o *FLEXRAM_Type) GetINT_STAT_EN_ITCM_MAM_STAT_EN() uint32 {
	return volatile.LoadUint32(&o.INT_STAT_EN.Reg) & 0x1
}
func (o *FLEXRAM_Type) SetINT_STAT_EN_DTCM_MAM_STAT_EN(value uint32) {
	volatile.StoreUint32(&o.INT_STAT_EN.Reg, volatile.LoadUint32(&o.INT_STAT_EN.Reg)&^(0x2)|value<<1)
}
func (o *FLEXRAM_Type) GetINT_STAT_EN_DTCM_MAM_STAT_EN() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT_EN.Reg) & 0x2) >> 1
}
func (o *FLEXRAM_Type) SetINT_STAT_EN_OCRAM_MAM_STAT_EN(value uint32) {
	volatile.StoreUint32(&o.INT_STAT_EN.Reg, volatile.LoadUint32(&o.INT_STAT_EN.Reg)&^(0x4)|value<<2)
}
func (o *FLEXRAM_Type) GetINT_STAT_EN_OCRAM_MAM_STAT_EN() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT_EN.Reg) & 0x4) >> 2
}
func (o *FLEXRAM_Type) SetINT_STAT_EN_ITCM_ERR_STAT_EN(value uint32) {
	volatile.StoreUint32(&o.INT_STAT_EN.Reg, volatile.LoadUint32(&o.INT_STAT_EN.Reg)&^(0x8)|value<<3)
}
func (o *FLEXRAM_Type) GetINT_STAT_EN_ITCM_ERR_STAT_EN() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT_EN.Reg) & 0x8) >> 3
}
func (o *FLEXRAM_Type) SetINT_STAT_EN_DTCM_ERR_STAT_EN(value uint32) {
	volatile.StoreUint32(&o.INT_STAT_EN.Reg, volatile.LoadUint32(&o.INT_STAT_EN.Reg)&^(0x10)|value<<4)
}
func (o *FLEXRAM_Type) GetINT_STAT_EN_DTCM_ERR_STAT_EN() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT_EN.Reg) & 0x10) >> 4
}
func (o *FLEXRAM_Type) SetINT_STAT_EN_OCRAM_ERR_STAT_EN(value uint32) {
	volatile.StoreUint32(&o.INT_STAT_EN.Reg, volatile.LoadUint32(&o.INT_STAT_EN.Reg)&^(0x20)|value<<5)
}
func (o *FLEXRAM_Type) GetINT_STAT_EN_OCRAM_ERR_STAT_EN() uint32 {
	return (volatile.LoadUint32(&o.INT_STAT_EN.Reg) & 0x20) >> 5
}

// FLEXRAM.INT_SIG_EN: Interrupt Enable Register
func (o *FLEXRAM_Type) SetINT_SIG_EN_ITCM_MAM_SIG_EN(value uint32) {
	volatile.StoreUint32(&o.INT_SIG_EN.Reg, volatile.LoadUint32(&o.INT_SIG_EN.Reg)&^(0x1)|value)
}
func (o *FLEXRAM_Type) GetINT_SIG_EN_ITCM_MAM_SIG_EN() uint32 {
	return volatile.LoadUint32(&o.INT_SIG_EN.Reg) & 0x1
}
func (o *FLEXRAM_Type) SetINT_SIG_EN_DTCM_MAM_SIG_EN(value uint32) {
	volatile.StoreUint32(&o.INT_SIG_EN.Reg, volatile.LoadUint32(&o.INT_SIG_EN.Reg)&^(0x2)|value<<1)
}
func (o *FLEXRAM_Type) GetINT_SIG_EN_DTCM_MAM_SIG_EN() uint32 {
	return (volatile.LoadUint32(&o.INT_SIG_EN.Reg) & 0x2) >> 1
}
func (o *FLEXRAM_Type) SetINT_SIG_EN_OCRAM_MAM_SIG_EN(value uint32) {
	volatile.StoreUint32(&o.INT_SIG_EN.Reg, volatile.LoadUint32(&o.INT_SIG_EN.Reg)&^(0x4)|value<<2)
}
func (o *FLEXRAM_Type) GetINT_SIG_EN_OCRAM_MAM_SIG_EN() uint32 {
	return (volatile.LoadUint32(&o.INT_SIG_EN.Reg) & 0x4) >> 2
}
func (o *FLEXRAM_Type) SetINT_SIG_EN_ITCM_ERR_SIG_EN(value uint32) {
	volatile.StoreUint32(&o.INT_SIG_EN.Reg, volatile.LoadUint32(&o.INT_SIG_EN.Reg)&^(0x8)|value<<3)
}
func (o *FLEXRAM_Type) GetINT_SIG_EN_ITCM_ERR_SIG_EN() uint32 {
	return (volatile.LoadUint32(&o.INT_SIG_EN.Reg) & 0x8) >> 3
}
func (o *FLEXRAM_Type) SetINT_SIG_EN_DTCM_ERR_SIG_EN(value uint32) {
	volatile.StoreUint32(&o.INT_SIG_EN.Reg, volatile.LoadUint32(&o.INT_SIG_EN.Reg)&^(0x10)|value<<4)
}
func (o *FLEXRAM_Type) GetINT_SIG_EN_DTCM_ERR_SIG_EN() uint32 {
	return (volatile.LoadUint32(&o.INT_SIG_EN.Reg) & 0x10) >> 4
}
func (o *FLEXRAM_Type) SetINT_SIG_EN_OCRAM_ERR_SIG_EN(value uint32) {
	volatile.StoreUint32(&o.INT_SIG_EN.Reg, volatile.LoadUint32(&o.INT_SIG_EN.Reg)&^(0x20)|value<<5)
}
func (o *FLEXRAM_Type) GetINT_SIG_EN_OCRAM_ERR_SIG_EN() uint32 {
	return (volatile.LoadUint32(&o.INT_SIG_EN.Reg) & 0x20) >> 5
}

// EWM
type EWM_Type struct {
	CTRL         volatile.Register8 // 0x0
	SERV         volatile.Register8 // 0x1
	CMPL         volatile.Register8 // 0x2
	CMPH         volatile.Register8 // 0x3
	CLKCTRL      volatile.Register8 // 0x4
	CLKPRESCALER volatile.Register8 // 0x5
}

// EWM.CTRL: Control Register
func (o *EWM_Type) SetCTRL_EWMEN(value uint8) {
	volatile.StoreUint8(&o.CTRL.Reg, volatile.LoadUint8(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *EWM_Type) GetCTRL_EWMEN() uint8 {
	return volatile.LoadUint8(&o.CTRL.Reg) & 0x1
}
func (o *EWM_Type) SetCTRL_ASSIN(value uint8) {
	volatile.StoreUint8(&o.CTRL.Reg, volatile.LoadUint8(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *EWM_Type) GetCTRL_ASSIN() uint8 {
	return (volatile.LoadUint8(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *EWM_Type) SetCTRL_INEN(value uint8) {
	volatile.StoreUint8(&o.CTRL.Reg, volatile.LoadUint8(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *EWM_Type) GetCTRL_INEN() uint8 {
	return (volatile.LoadUint8(&o.CTRL.Reg) & 0x4) >> 2
}
func (o *EWM_Type) SetCTRL_INTEN(value uint8) {
	volatile.StoreUint8(&o.CTRL.Reg, volatile.LoadUint8(&o.CTRL.Reg)&^(0x8)|value<<3)
}
func (o *EWM_Type) GetCTRL_INTEN() uint8 {
	return (volatile.LoadUint8(&o.CTRL.Reg) & 0x8) >> 3
}

// EWM.SERV: Service Register
func (o *EWM_Type) SetSERV(value uint8) {
	volatile.StoreUint8(&o.SERV.Reg, value)
}
func (o *EWM_Type) GetSERV() uint8 {
	return volatile.LoadUint8(&o.SERV.Reg)
}

// EWM.CMPL: Compare Low Register
func (o *EWM_Type) SetCMPL(value uint8) {
	volatile.StoreUint8(&o.CMPL.Reg, value)
}
func (o *EWM_Type) GetCMPL() uint8 {
	return volatile.LoadUint8(&o.CMPL.Reg)
}

// EWM.CMPH: Compare High Register
func (o *EWM_Type) SetCMPH(value uint8) {
	volatile.StoreUint8(&o.CMPH.Reg, value)
}
func (o *EWM_Type) GetCMPH() uint8 {
	return volatile.LoadUint8(&o.CMPH.Reg)
}

// EWM.CLKCTRL: Clock Control Register
func (o *EWM_Type) SetCLKCTRL_CLKSEL(value uint8) {
	volatile.StoreUint8(&o.CLKCTRL.Reg, volatile.LoadUint8(&o.CLKCTRL.Reg)&^(0x3)|value)
}
func (o *EWM_Type) GetCLKCTRL_CLKSEL() uint8 {
	return volatile.LoadUint8(&o.CLKCTRL.Reg) & 0x3
}

// EWM.CLKPRESCALER: Clock Prescaler Register
func (o *EWM_Type) SetCLKPRESCALER(value uint8) {
	volatile.StoreUint8(&o.CLKPRESCALER.Reg, value)
}
func (o *EWM_Type) GetCLKPRESCALER() uint8 {
	return volatile.LoadUint8(&o.CLKPRESCALER.Reg)
}

// WDOG
type WDOG_Type struct {
	WCR  volatile.Register16 // 0x0
	WSR  volatile.Register16 // 0x2
	WRSR volatile.Register16 // 0x4
	WICR volatile.Register16 // 0x6
	WMCR volatile.Register16 // 0x8
}

// WDOG.WCR: Watchdog Control Register
func (o *WDOG_Type) SetWCR_WDZST(value uint16) {
	volatile.StoreUint16(&o.WCR.Reg, volatile.LoadUint16(&o.WCR.Reg)&^(0x1)|value)
}
func (o *WDOG_Type) GetWCR_WDZST() uint16 {
	return volatile.LoadUint16(&o.WCR.Reg) & 0x1
}
func (o *WDOG_Type) SetWCR_WDBG(value uint16) {
	volatile.StoreUint16(&o.WCR.Reg, volatile.LoadUint16(&o.WCR.Reg)&^(0x2)|value<<1)
}
func (o *WDOG_Type) GetWCR_WDBG() uint16 {
	return (volatile.LoadUint16(&o.WCR.Reg) & 0x2) >> 1
}
func (o *WDOG_Type) SetWCR_WDE(value uint16) {
	volatile.StoreUint16(&o.WCR.Reg, volatile.LoadUint16(&o.WCR.Reg)&^(0x4)|value<<2)
}
func (o *WDOG_Type) GetWCR_WDE() uint16 {
	return (volatile.LoadUint16(&o.WCR.Reg) & 0x4) >> 2
}
func (o *WDOG_Type) SetWCR_WDT(value uint16) {
	volatile.StoreUint16(&o.WCR.Reg, volatile.LoadUint16(&o.WCR.Reg)&^(0x8)|value<<3)
}
func (o *WDOG_Type) GetWCR_WDT() uint16 {
	return (volatile.LoadUint16(&o.WCR.Reg) & 0x8) >> 3
}
func (o *WDOG_Type) SetWCR_SRS(value uint16) {
	volatile.StoreUint16(&o.WCR.Reg, volatile.LoadUint16(&o.WCR.Reg)&^(0x10)|value<<4)
}
func (o *WDOG_Type) GetWCR_SRS() uint16 {
	return (volatile.LoadUint16(&o.WCR.Reg) & 0x10) >> 4
}
func (o *WDOG_Type) SetWCR_WDA(value uint16) {
	volatile.StoreUint16(&o.WCR.Reg, volatile.LoadUint16(&o.WCR.Reg)&^(0x20)|value<<5)
}
func (o *WDOG_Type) GetWCR_WDA() uint16 {
	return (volatile.LoadUint16(&o.WCR.Reg) & 0x20) >> 5
}
func (o *WDOG_Type) SetWCR_SRE(value uint16) {
	volatile.StoreUint16(&o.WCR.Reg, volatile.LoadUint16(&o.WCR.Reg)&^(0x40)|value<<6)
}
func (o *WDOG_Type) GetWCR_SRE() uint16 {
	return (volatile.LoadUint16(&o.WCR.Reg) & 0x40) >> 6
}
func (o *WDOG_Type) SetWCR_WDW(value uint16) {
	volatile.StoreUint16(&o.WCR.Reg, volatile.LoadUint16(&o.WCR.Reg)&^(0x80)|value<<7)
}
func (o *WDOG_Type) GetWCR_WDW() uint16 {
	return (volatile.LoadUint16(&o.WCR.Reg) & 0x80) >> 7
}
func (o *WDOG_Type) SetWCR_WT(value uint16) {
	volatile.StoreUint16(&o.WCR.Reg, volatile.LoadUint16(&o.WCR.Reg)&^(0xff00)|value<<8)
}
func (o *WDOG_Type) GetWCR_WT() uint16 {
	return (volatile.LoadUint16(&o.WCR.Reg) & 0xff00) >> 8
}

// WDOG.WSR: Watchdog Service Register
func (o *WDOG_Type) SetWSR(value uint16) {
	volatile.StoreUint16(&o.WSR.Reg, value)
}
func (o *WDOG_Type) GetWSR() uint16 {
	return volatile.LoadUint16(&o.WSR.Reg)
}

// WDOG.WRSR: Watchdog Reset Status Register
func (o *WDOG_Type) SetWRSR_SFTW(value uint16) {
	volatile.StoreUint16(&o.WRSR.Reg, volatile.LoadUint16(&o.WRSR.Reg)&^(0x1)|value)
}
func (o *WDOG_Type) GetWRSR_SFTW() uint16 {
	return volatile.LoadUint16(&o.WRSR.Reg) & 0x1
}
func (o *WDOG_Type) SetWRSR_TOUT(value uint16) {
	volatile.StoreUint16(&o.WRSR.Reg, volatile.LoadUint16(&o.WRSR.Reg)&^(0x2)|value<<1)
}
func (o *WDOG_Type) GetWRSR_TOUT() uint16 {
	return (volatile.LoadUint16(&o.WRSR.Reg) & 0x2) >> 1
}
func (o *WDOG_Type) SetWRSR_POR(value uint16) {
	volatile.StoreUint16(&o.WRSR.Reg, volatile.LoadUint16(&o.WRSR.Reg)&^(0x10)|value<<4)
}
func (o *WDOG_Type) GetWRSR_POR() uint16 {
	return (volatile.LoadUint16(&o.WRSR.Reg) & 0x10) >> 4
}

// WDOG.WICR: Watchdog Interrupt Control Register
func (o *WDOG_Type) SetWICR_WICT(value uint16) {
	volatile.StoreUint16(&o.WICR.Reg, volatile.LoadUint16(&o.WICR.Reg)&^(0xff)|value)
}
func (o *WDOG_Type) GetWICR_WICT() uint16 {
	return volatile.LoadUint16(&o.WICR.Reg) & 0xff
}
func (o *WDOG_Type) SetWICR_WTIS(value uint16) {
	volatile.StoreUint16(&o.WICR.Reg, volatile.LoadUint16(&o.WICR.Reg)&^(0x4000)|value<<14)
}
func (o *WDOG_Type) GetWICR_WTIS() uint16 {
	return (volatile.LoadUint16(&o.WICR.Reg) & 0x4000) >> 14
}
func (o *WDOG_Type) SetWICR_WIE(value uint16) {
	volatile.StoreUint16(&o.WICR.Reg, volatile.LoadUint16(&o.WICR.Reg)&^(0x8000)|value<<15)
}
func (o *WDOG_Type) GetWICR_WIE() uint16 {
	return (volatile.LoadUint16(&o.WICR.Reg) & 0x8000) >> 15
}

// WDOG.WMCR: Watchdog Miscellaneous Control Register
func (o *WDOG_Type) SetWMCR_PDE(value uint16) {
	volatile.StoreUint16(&o.WMCR.Reg, volatile.LoadUint16(&o.WMCR.Reg)&^(0x1)|value)
}
func (o *WDOG_Type) GetWMCR_PDE() uint16 {
	return volatile.LoadUint16(&o.WMCR.Reg) & 0x1
}

// WDOG
type RTWDOG_Type struct {
	CS    volatile.Register32 // 0x0
	CNT   volatile.Register32 // 0x4
	TOVAL volatile.Register32 // 0x8
	WIN   volatile.Register32 // 0xC
}

// RTWDOG.CS: Watchdog Control and Status Register
func (o *RTWDOG_Type) SetCS_STOP(value uint32) {
	volatile.StoreUint32(&o.CS.Reg, volatile.LoadUint32(&o.CS.Reg)&^(0x1)|value)
}
func (o *RTWDOG_Type) GetCS_STOP() uint32 {
	return volatile.LoadUint32(&o.CS.Reg) & 0x1
}
func (o *RTWDOG_Type) SetCS_WAIT(value uint32) {
	volatile.StoreUint32(&o.CS.Reg, volatile.LoadUint32(&o.CS.Reg)&^(0x2)|value<<1)
}
func (o *RTWDOG_Type) GetCS_WAIT() uint32 {
	return (volatile.LoadUint32(&o.CS.Reg) & 0x2) >> 1
}
func (o *RTWDOG_Type) SetCS_DBG(value uint32) {
	volatile.StoreUint32(&o.CS.Reg, volatile.LoadUint32(&o.CS.Reg)&^(0x4)|value<<2)
}
func (o *RTWDOG_Type) GetCS_DBG() uint32 {
	return (volatile.LoadUint32(&o.CS.Reg) & 0x4) >> 2
}
func (o *RTWDOG_Type) SetCS_TST(value uint32) {
	volatile.StoreUint32(&o.CS.Reg, volatile.LoadUint32(&o.CS.Reg)&^(0x18)|value<<3)
}
func (o *RTWDOG_Type) GetCS_TST() uint32 {
	return (volatile.LoadUint32(&o.CS.Reg) & 0x18) >> 3
}
func (o *RTWDOG_Type) SetCS_UPDATE(value uint32) {
	volatile.StoreUint32(&o.CS.Reg, volatile.LoadUint32(&o.CS.Reg)&^(0x20)|value<<5)
}
func (o *RTWDOG_Type) GetCS_UPDATE() uint32 {
	return (volatile.LoadUint32(&o.CS.Reg) & 0x20) >> 5
}
func (o *RTWDOG_Type) SetCS_INT(value uint32) {
	volatile.StoreUint32(&o.CS.Reg, volatile.LoadUint32(&o.CS.Reg)&^(0x40)|value<<6)
}
func (o *RTWDOG_Type) GetCS_INT() uint32 {
	return (volatile.LoadUint32(&o.CS.Reg) & 0x40) >> 6
}
func (o *RTWDOG_Type) SetCS_EN(value uint32) {
	volatile.StoreUint32(&o.CS.Reg, volatile.LoadUint32(&o.CS.Reg)&^(0x80)|value<<7)
}
func (o *RTWDOG_Type) GetCS_EN() uint32 {
	return (volatile.LoadUint32(&o.CS.Reg) & 0x80) >> 7
}
func (o *RTWDOG_Type) SetCS_CLK(value uint32) {
	volatile.StoreUint32(&o.CS.Reg, volatile.LoadUint32(&o.CS.Reg)&^(0x300)|value<<8)
}
func (o *RTWDOG_Type) GetCS_CLK() uint32 {
	return (volatile.LoadUint32(&o.CS.Reg) & 0x300) >> 8
}
func (o *RTWDOG_Type) SetCS_RCS(value uint32) {
	volatile.StoreUint32(&o.CS.Reg, volatile.LoadUint32(&o.CS.Reg)&^(0x400)|value<<10)
}
func (o *RTWDOG_Type) GetCS_RCS() uint32 {
	return (volatile.LoadUint32(&o.CS.Reg) & 0x400) >> 10
}
func (o *RTWDOG_Type) SetCS_ULK(value uint32) {
	volatile.StoreUint32(&o.CS.Reg, volatile.LoadUint32(&o.CS.Reg)&^(0x800)|value<<11)
}
func (o *RTWDOG_Type) GetCS_ULK() uint32 {
	return (volatile.LoadUint32(&o.CS.Reg) & 0x800) >> 11
}
func (o *RTWDOG_Type) SetCS_PRES(value uint32) {
	volatile.StoreUint32(&o.CS.Reg, volatile.LoadUint32(&o.CS.Reg)&^(0x1000)|value<<12)
}
func (o *RTWDOG_Type) GetCS_PRES() uint32 {
	return (volatile.LoadUint32(&o.CS.Reg) & 0x1000) >> 12
}
func (o *RTWDOG_Type) SetCS_CMD32EN(value uint32) {
	volatile.StoreUint32(&o.CS.Reg, volatile.LoadUint32(&o.CS.Reg)&^(0x2000)|value<<13)
}
func (o *RTWDOG_Type) GetCS_CMD32EN() uint32 {
	return (volatile.LoadUint32(&o.CS.Reg) & 0x2000) >> 13
}
func (o *RTWDOG_Type) SetCS_FLG(value uint32) {
	volatile.StoreUint32(&o.CS.Reg, volatile.LoadUint32(&o.CS.Reg)&^(0x4000)|value<<14)
}
func (o *RTWDOG_Type) GetCS_FLG() uint32 {
	return (volatile.LoadUint32(&o.CS.Reg) & 0x4000) >> 14
}
func (o *RTWDOG_Type) SetCS_WIN(value uint32) {
	volatile.StoreUint32(&o.CS.Reg, volatile.LoadUint32(&o.CS.Reg)&^(0x8000)|value<<15)
}
func (o *RTWDOG_Type) GetCS_WIN() uint32 {
	return (volatile.LoadUint32(&o.CS.Reg) & 0x8000) >> 15
}

// RTWDOG.CNT: Watchdog Counter Register
func (o *RTWDOG_Type) SetCNT_CNTLOW(value uint32) {
	volatile.StoreUint32(&o.CNT.Reg, volatile.LoadUint32(&o.CNT.Reg)&^(0xff)|value)
}
func (o *RTWDOG_Type) GetCNT_CNTLOW() uint32 {
	return volatile.LoadUint32(&o.CNT.Reg) & 0xff
}
func (o *RTWDOG_Type) SetCNT_CNTHIGH(value uint32) {
	volatile.StoreUint32(&o.CNT.Reg, volatile.LoadUint32(&o.CNT.Reg)&^(0xff00)|value<<8)
}
func (o *RTWDOG_Type) GetCNT_CNTHIGH() uint32 {
	return (volatile.LoadUint32(&o.CNT.Reg) & 0xff00) >> 8
}

// RTWDOG.TOVAL: Watchdog Timeout Value Register
func (o *RTWDOG_Type) SetTOVAL_TOVALLOW(value uint32) {
	volatile.StoreUint32(&o.TOVAL.Reg, volatile.LoadUint32(&o.TOVAL.Reg)&^(0xff)|value)
}
func (o *RTWDOG_Type) GetTOVAL_TOVALLOW() uint32 {
	return volatile.LoadUint32(&o.TOVAL.Reg) & 0xff
}
func (o *RTWDOG_Type) SetTOVAL_TOVALHIGH(value uint32) {
	volatile.StoreUint32(&o.TOVAL.Reg, volatile.LoadUint32(&o.TOVAL.Reg)&^(0xff00)|value<<8)
}
func (o *RTWDOG_Type) GetTOVAL_TOVALHIGH() uint32 {
	return (volatile.LoadUint32(&o.TOVAL.Reg) & 0xff00) >> 8
}

// RTWDOG.WIN: Watchdog Window Register
func (o *RTWDOG_Type) SetWIN_WINLOW(value uint32) {
	volatile.StoreUint32(&o.WIN.Reg, volatile.LoadUint32(&o.WIN.Reg)&^(0xff)|value)
}
func (o *RTWDOG_Type) GetWIN_WINLOW() uint32 {
	return volatile.LoadUint32(&o.WIN.Reg) & 0xff
}
func (o *RTWDOG_Type) SetWIN_WINHIGH(value uint32) {
	volatile.StoreUint32(&o.WIN.Reg, volatile.LoadUint32(&o.WIN.Reg)&^(0xff00)|value<<8)
}
func (o *RTWDOG_Type) GetWIN_WINHIGH() uint32 {
	return (volatile.LoadUint32(&o.WIN.Reg) & 0xff00) >> 8
}

// Analog-to-Digital Converter
type ADC_Type struct {
	HC0 volatile.Register32 // 0x0
	HC1 volatile.Register32 // 0x4
	HC2 volatile.Register32 // 0x8
	HC3 volatile.Register32 // 0xC
	HC4 volatile.Register32 // 0x10
	HC5 volatile.Register32 // 0x14
	HC6 volatile.Register32 // 0x18
	HC7 volatile.Register32 // 0x1C
	HS  volatile.Register32 // 0x20
	R0  volatile.Register32 // 0x24
	R1  volatile.Register32 // 0x28
	R2  volatile.Register32 // 0x2C
	R3  volatile.Register32 // 0x30
	R4  volatile.Register32 // 0x34
	R5  volatile.Register32 // 0x38
	R6  volatile.Register32 // 0x3C
	R7  volatile.Register32 // 0x40
	CFG volatile.Register32 // 0x44
	GC  volatile.Register32 // 0x48
	GS  volatile.Register32 // 0x4C
	CV  volatile.Register32 // 0x50
	OFS volatile.Register32 // 0x54
	CAL volatile.Register32 // 0x58
}

// ADC.HC0: Control register for hardware triggers
func (o *ADC_Type) SetHC0_ADCH(value uint32) {
	volatile.StoreUint32(&o.HC0.Reg, volatile.LoadUint32(&o.HC0.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetHC0_ADCH() uint32 {
	return volatile.LoadUint32(&o.HC0.Reg) & 0x1f
}
func (o *ADC_Type) SetHC0_AIEN(value uint32) {
	volatile.StoreUint32(&o.HC0.Reg, volatile.LoadUint32(&o.HC0.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetHC0_AIEN() uint32 {
	return (volatile.LoadUint32(&o.HC0.Reg) & 0x80) >> 7
}

// ADC.HC1: Control register for hardware triggers
func (o *ADC_Type) SetHC1_ADCH(value uint32) {
	volatile.StoreUint32(&o.HC1.Reg, volatile.LoadUint32(&o.HC1.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetHC1_ADCH() uint32 {
	return volatile.LoadUint32(&o.HC1.Reg) & 0x1f
}
func (o *ADC_Type) SetHC1_AIEN(value uint32) {
	volatile.StoreUint32(&o.HC1.Reg, volatile.LoadUint32(&o.HC1.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetHC1_AIEN() uint32 {
	return (volatile.LoadUint32(&o.HC1.Reg) & 0x80) >> 7
}

// ADC.HC2: Control register for hardware triggers
func (o *ADC_Type) SetHC2_ADCH(value uint32) {
	volatile.StoreUint32(&o.HC2.Reg, volatile.LoadUint32(&o.HC2.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetHC2_ADCH() uint32 {
	return volatile.LoadUint32(&o.HC2.Reg) & 0x1f
}
func (o *ADC_Type) SetHC2_AIEN(value uint32) {
	volatile.StoreUint32(&o.HC2.Reg, volatile.LoadUint32(&o.HC2.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetHC2_AIEN() uint32 {
	return (volatile.LoadUint32(&o.HC2.Reg) & 0x80) >> 7
}

// ADC.HC3: Control register for hardware triggers
func (o *ADC_Type) SetHC3_ADCH(value uint32) {
	volatile.StoreUint32(&o.HC3.Reg, volatile.LoadUint32(&o.HC3.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetHC3_ADCH() uint32 {
	return volatile.LoadUint32(&o.HC3.Reg) & 0x1f
}
func (o *ADC_Type) SetHC3_AIEN(value uint32) {
	volatile.StoreUint32(&o.HC3.Reg, volatile.LoadUint32(&o.HC3.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetHC3_AIEN() uint32 {
	return (volatile.LoadUint32(&o.HC3.Reg) & 0x80) >> 7
}

// ADC.HC4: Control register for hardware triggers
func (o *ADC_Type) SetHC4_ADCH(value uint32) {
	volatile.StoreUint32(&o.HC4.Reg, volatile.LoadUint32(&o.HC4.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetHC4_ADCH() uint32 {
	return volatile.LoadUint32(&o.HC4.Reg) & 0x1f
}
func (o *ADC_Type) SetHC4_AIEN(value uint32) {
	volatile.StoreUint32(&o.HC4.Reg, volatile.LoadUint32(&o.HC4.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetHC4_AIEN() uint32 {
	return (volatile.LoadUint32(&o.HC4.Reg) & 0x80) >> 7
}

// ADC.HC5: Control register for hardware triggers
func (o *ADC_Type) SetHC5_ADCH(value uint32) {
	volatile.StoreUint32(&o.HC5.Reg, volatile.LoadUint32(&o.HC5.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetHC5_ADCH() uint32 {
	return volatile.LoadUint32(&o.HC5.Reg) & 0x1f
}
func (o *ADC_Type) SetHC5_AIEN(value uint32) {
	volatile.StoreUint32(&o.HC5.Reg, volatile.LoadUint32(&o.HC5.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetHC5_AIEN() uint32 {
	return (volatile.LoadUint32(&o.HC5.Reg) & 0x80) >> 7
}

// ADC.HC6: Control register for hardware triggers
func (o *ADC_Type) SetHC6_ADCH(value uint32) {
	volatile.StoreUint32(&o.HC6.Reg, volatile.LoadUint32(&o.HC6.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetHC6_ADCH() uint32 {
	return volatile.LoadUint32(&o.HC6.Reg) & 0x1f
}
func (o *ADC_Type) SetHC6_AIEN(value uint32) {
	volatile.StoreUint32(&o.HC6.Reg, volatile.LoadUint32(&o.HC6.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetHC6_AIEN() uint32 {
	return (volatile.LoadUint32(&o.HC6.Reg) & 0x80) >> 7
}

// ADC.HC7: Control register for hardware triggers
func (o *ADC_Type) SetHC7_ADCH(value uint32) {
	volatile.StoreUint32(&o.HC7.Reg, volatile.LoadUint32(&o.HC7.Reg)&^(0x1f)|value)
}
func (o *ADC_Type) GetHC7_ADCH() uint32 {
	return volatile.LoadUint32(&o.HC7.Reg) & 0x1f
}
func (o *ADC_Type) SetHC7_AIEN(value uint32) {
	volatile.StoreUint32(&o.HC7.Reg, volatile.LoadUint32(&o.HC7.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetHC7_AIEN() uint32 {
	return (volatile.LoadUint32(&o.HC7.Reg) & 0x80) >> 7
}

// ADC.HS: Status register for HW triggers
func (o *ADC_Type) SetHS_COCO0(value uint32) {
	volatile.StoreUint32(&o.HS.Reg, volatile.LoadUint32(&o.HS.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetHS_COCO0() uint32 {
	return volatile.LoadUint32(&o.HS.Reg) & 0x1
}

// ADC.R0: Data result register for HW triggers
func (o *ADC_Type) SetR0_CDATA(value uint32) {
	volatile.StoreUint32(&o.R0.Reg, volatile.LoadUint32(&o.R0.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetR0_CDATA() uint32 {
	return volatile.LoadUint32(&o.R0.Reg) & 0xfff
}

// ADC.R1: Data result register for HW triggers
func (o *ADC_Type) SetR1_CDATA(value uint32) {
	volatile.StoreUint32(&o.R1.Reg, volatile.LoadUint32(&o.R1.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetR1_CDATA() uint32 {
	return volatile.LoadUint32(&o.R1.Reg) & 0xfff
}

// ADC.R2: Data result register for HW triggers
func (o *ADC_Type) SetR2_CDATA(value uint32) {
	volatile.StoreUint32(&o.R2.Reg, volatile.LoadUint32(&o.R2.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetR2_CDATA() uint32 {
	return volatile.LoadUint32(&o.R2.Reg) & 0xfff
}

// ADC.R3: Data result register for HW triggers
func (o *ADC_Type) SetR3_CDATA(value uint32) {
	volatile.StoreUint32(&o.R3.Reg, volatile.LoadUint32(&o.R3.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetR3_CDATA() uint32 {
	return volatile.LoadUint32(&o.R3.Reg) & 0xfff
}

// ADC.R4: Data result register for HW triggers
func (o *ADC_Type) SetR4_CDATA(value uint32) {
	volatile.StoreUint32(&o.R4.Reg, volatile.LoadUint32(&o.R4.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetR4_CDATA() uint32 {
	return volatile.LoadUint32(&o.R4.Reg) & 0xfff
}

// ADC.R5: Data result register for HW triggers
func (o *ADC_Type) SetR5_CDATA(value uint32) {
	volatile.StoreUint32(&o.R5.Reg, volatile.LoadUint32(&o.R5.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetR5_CDATA() uint32 {
	return volatile.LoadUint32(&o.R5.Reg) & 0xfff
}

// ADC.R6: Data result register for HW triggers
func (o *ADC_Type) SetR6_CDATA(value uint32) {
	volatile.StoreUint32(&o.R6.Reg, volatile.LoadUint32(&o.R6.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetR6_CDATA() uint32 {
	return volatile.LoadUint32(&o.R6.Reg) & 0xfff
}

// ADC.R7: Data result register for HW triggers
func (o *ADC_Type) SetR7_CDATA(value uint32) {
	volatile.StoreUint32(&o.R7.Reg, volatile.LoadUint32(&o.R7.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetR7_CDATA() uint32 {
	return volatile.LoadUint32(&o.R7.Reg) & 0xfff
}

// ADC.CFG: Configuration register
func (o *ADC_Type) SetCFG_ADICLK(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x3)|value)
}
func (o *ADC_Type) GetCFG_ADICLK() uint32 {
	return volatile.LoadUint32(&o.CFG.Reg) & 0x3
}
func (o *ADC_Type) SetCFG_MODE(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0xc)|value<<2)
}
func (o *ADC_Type) GetCFG_MODE() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0xc) >> 2
}
func (o *ADC_Type) SetCFG_ADLSMP(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetCFG_ADLSMP() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetCFG_ADIV(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x60)|value<<5)
}
func (o *ADC_Type) GetCFG_ADIV() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x60) >> 5
}
func (o *ADC_Type) SetCFG_ADLPC(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetCFG_ADLPC() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x80) >> 7
}
func (o *ADC_Type) SetCFG_ADSTS(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x300)|value<<8)
}
func (o *ADC_Type) GetCFG_ADSTS() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x300) >> 8
}
func (o *ADC_Type) SetCFG_ADHSC(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x400)|value<<10)
}
func (o *ADC_Type) GetCFG_ADHSC() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x400) >> 10
}
func (o *ADC_Type) SetCFG_REFSEL(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x1800)|value<<11)
}
func (o *ADC_Type) GetCFG_REFSEL() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x1800) >> 11
}
func (o *ADC_Type) SetCFG_ADTRG(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x2000)|value<<13)
}
func (o *ADC_Type) GetCFG_ADTRG() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x2000) >> 13
}
func (o *ADC_Type) SetCFG_AVGS(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0xc000)|value<<14)
}
func (o *ADC_Type) GetCFG_AVGS() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0xc000) >> 14
}
func (o *ADC_Type) SetCFG_OVWREN(value uint32) {
	volatile.StoreUint32(&o.CFG.Reg, volatile.LoadUint32(&o.CFG.Reg)&^(0x10000)|value<<16)
}
func (o *ADC_Type) GetCFG_OVWREN() uint32 {
	return (volatile.LoadUint32(&o.CFG.Reg) & 0x10000) >> 16
}

// ADC.GC: General control register
func (o *ADC_Type) SetGC_ADACKEN(value uint32) {
	volatile.StoreUint32(&o.GC.Reg, volatile.LoadUint32(&o.GC.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetGC_ADACKEN() uint32 {
	return volatile.LoadUint32(&o.GC.Reg) & 0x1
}
func (o *ADC_Type) SetGC_DMAEN(value uint32) {
	volatile.StoreUint32(&o.GC.Reg, volatile.LoadUint32(&o.GC.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetGC_DMAEN() uint32 {
	return (volatile.LoadUint32(&o.GC.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetGC_ACREN(value uint32) {
	volatile.StoreUint32(&o.GC.Reg, volatile.LoadUint32(&o.GC.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetGC_ACREN() uint32 {
	return (volatile.LoadUint32(&o.GC.Reg) & 0x4) >> 2
}
func (o *ADC_Type) SetGC_ACFGT(value uint32) {
	volatile.StoreUint32(&o.GC.Reg, volatile.LoadUint32(&o.GC.Reg)&^(0x8)|value<<3)
}
func (o *ADC_Type) GetGC_ACFGT() uint32 {
	return (volatile.LoadUint32(&o.GC.Reg) & 0x8) >> 3
}
func (o *ADC_Type) SetGC_ACFE(value uint32) {
	volatile.StoreUint32(&o.GC.Reg, volatile.LoadUint32(&o.GC.Reg)&^(0x10)|value<<4)
}
func (o *ADC_Type) GetGC_ACFE() uint32 {
	return (volatile.LoadUint32(&o.GC.Reg) & 0x10) >> 4
}
func (o *ADC_Type) SetGC_AVGE(value uint32) {
	volatile.StoreUint32(&o.GC.Reg, volatile.LoadUint32(&o.GC.Reg)&^(0x20)|value<<5)
}
func (o *ADC_Type) GetGC_AVGE() uint32 {
	return (volatile.LoadUint32(&o.GC.Reg) & 0x20) >> 5
}
func (o *ADC_Type) SetGC_ADCO(value uint32) {
	volatile.StoreUint32(&o.GC.Reg, volatile.LoadUint32(&o.GC.Reg)&^(0x40)|value<<6)
}
func (o *ADC_Type) GetGC_ADCO() uint32 {
	return (volatile.LoadUint32(&o.GC.Reg) & 0x40) >> 6
}
func (o *ADC_Type) SetGC_CAL(value uint32) {
	volatile.StoreUint32(&o.GC.Reg, volatile.LoadUint32(&o.GC.Reg)&^(0x80)|value<<7)
}
func (o *ADC_Type) GetGC_CAL() uint32 {
	return (volatile.LoadUint32(&o.GC.Reg) & 0x80) >> 7
}

// ADC.GS: General status register
func (o *ADC_Type) SetGS_ADACT(value uint32) {
	volatile.StoreUint32(&o.GS.Reg, volatile.LoadUint32(&o.GS.Reg)&^(0x1)|value)
}
func (o *ADC_Type) GetGS_ADACT() uint32 {
	return volatile.LoadUint32(&o.GS.Reg) & 0x1
}
func (o *ADC_Type) SetGS_CALF(value uint32) {
	volatile.StoreUint32(&o.GS.Reg, volatile.LoadUint32(&o.GS.Reg)&^(0x2)|value<<1)
}
func (o *ADC_Type) GetGS_CALF() uint32 {
	return (volatile.LoadUint32(&o.GS.Reg) & 0x2) >> 1
}
func (o *ADC_Type) SetGS_AWKST(value uint32) {
	volatile.StoreUint32(&o.GS.Reg, volatile.LoadUint32(&o.GS.Reg)&^(0x4)|value<<2)
}
func (o *ADC_Type) GetGS_AWKST() uint32 {
	return (volatile.LoadUint32(&o.GS.Reg) & 0x4) >> 2
}

// ADC.CV: Compare value register
func (o *ADC_Type) SetCV_CV1(value uint32) {
	volatile.StoreUint32(&o.CV.Reg, volatile.LoadUint32(&o.CV.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetCV_CV1() uint32 {
	return volatile.LoadUint32(&o.CV.Reg) & 0xfff
}
func (o *ADC_Type) SetCV_CV2(value uint32) {
	volatile.StoreUint32(&o.CV.Reg, volatile.LoadUint32(&o.CV.Reg)&^(0xfff0000)|value<<16)
}
func (o *ADC_Type) GetCV_CV2() uint32 {
	return (volatile.LoadUint32(&o.CV.Reg) & 0xfff0000) >> 16
}

// ADC.OFS: Offset correction value register
func (o *ADC_Type) SetOFS(value uint32) {
	volatile.StoreUint32(&o.OFS.Reg, volatile.LoadUint32(&o.OFS.Reg)&^(0xfff)|value)
}
func (o *ADC_Type) GetOFS() uint32 {
	return volatile.LoadUint32(&o.OFS.Reg) & 0xfff
}
func (o *ADC_Type) SetOFS_SIGN(value uint32) {
	volatile.StoreUint32(&o.OFS.Reg, volatile.LoadUint32(&o.OFS.Reg)&^(0x1000)|value<<12)
}
func (o *ADC_Type) GetOFS_SIGN() uint32 {
	return (volatile.LoadUint32(&o.OFS.Reg) & 0x1000) >> 12
}

// ADC.CAL: Calibration value register
func (o *ADC_Type) SetCAL_CAL_CODE(value uint32) {
	volatile.StoreUint32(&o.CAL.Reg, volatile.LoadUint32(&o.CAL.Reg)&^(0xf)|value)
}
func (o *ADC_Type) GetCAL_CAL_CODE() uint32 {
	return volatile.LoadUint32(&o.CAL.Reg) & 0xf
}

// TRNG
type TRNG_Type struct {
	MCTL       volatile.Register32     // 0x0
	SCMISC     volatile.Register32     // 0x4
	PKRRNG     volatile.Register32     // 0x8
	PKRMAX     volatile.Register32     // 0xC
	SDCTL      volatile.Register32     // 0x10
	SBLIM      volatile.Register32     // 0x14
	FRQMIN     volatile.Register32     // 0x18
	FRQCNT     volatile.Register32     // 0x1C
	SCMC       volatile.Register32     // 0x20
	SCR1C      volatile.Register32     // 0x24
	SCR2C      volatile.Register32     // 0x28
	SCR3C      volatile.Register32     // 0x2C
	SCR4C      volatile.Register32     // 0x30
	SCR5C      volatile.Register32     // 0x34
	SCR6PC     volatile.Register32     // 0x38
	STATUS     volatile.Register32     // 0x3C
	ENT        [16]volatile.Register32 // 0x40
	PKRCNT10   volatile.Register32     // 0x80
	PKRCNT32   volatile.Register32     // 0x84
	PKRCNT54   volatile.Register32     // 0x88
	PKRCNT76   volatile.Register32     // 0x8C
	PKRCNT98   volatile.Register32     // 0x90
	PKRCNTBA   volatile.Register32     // 0x94
	PKRCNTDC   volatile.Register32     // 0x98
	PKRCNTFE   volatile.Register32     // 0x9C
	SEC_CFG    volatile.Register32     // 0xA0
	INT_CTRL   volatile.Register32     // 0xA4
	INT_MASK   volatile.Register32     // 0xA8
	INT_STATUS volatile.Register32     // 0xAC
	_          [64]byte
	VID1       volatile.Register32 // 0xF0
	VID2       volatile.Register32 // 0xF4
}

// TRNG.MCTL: Miscellaneous Control Register
func (o *TRNG_Type) SetMCTL_SAMP_MODE(value uint32) {
	volatile.StoreUint32(&o.MCTL.Reg, volatile.LoadUint32(&o.MCTL.Reg)&^(0x3)|value)
}
func (o *TRNG_Type) GetMCTL_SAMP_MODE() uint32 {
	return volatile.LoadUint32(&o.MCTL.Reg) & 0x3
}
func (o *TRNG_Type) SetMCTL_OSC_DIV(value uint32) {
	volatile.StoreUint32(&o.MCTL.Reg, volatile.LoadUint32(&o.MCTL.Reg)&^(0xc)|value<<2)
}
func (o *TRNG_Type) GetMCTL_OSC_DIV() uint32 {
	return (volatile.LoadUint32(&o.MCTL.Reg) & 0xc) >> 2
}
func (o *TRNG_Type) SetMCTL_UNUSED4(value uint32) {
	volatile.StoreUint32(&o.MCTL.Reg, volatile.LoadUint32(&o.MCTL.Reg)&^(0x10)|value<<4)
}
func (o *TRNG_Type) GetMCTL_UNUSED4() uint32 {
	return (volatile.LoadUint32(&o.MCTL.Reg) & 0x10) >> 4
}
func (o *TRNG_Type) SetMCTL_UNUSED5(value uint32) {
	volatile.StoreUint32(&o.MCTL.Reg, volatile.LoadUint32(&o.MCTL.Reg)&^(0x20)|value<<5)
}
func (o *TRNG_Type) GetMCTL_UNUSED5() uint32 {
	return (volatile.LoadUint32(&o.MCTL.Reg) & 0x20) >> 5
}
func (o *TRNG_Type) SetMCTL_RST_DEF(value uint32) {
	volatile.StoreUint32(&o.MCTL.Reg, volatile.LoadUint32(&o.MCTL.Reg)&^(0x40)|value<<6)
}
func (o *TRNG_Type) GetMCTL_RST_DEF() uint32 {
	return (volatile.LoadUint32(&o.MCTL.Reg) & 0x40) >> 6
}
func (o *TRNG_Type) SetMCTL_FOR_SCLK(value uint32) {
	volatile.StoreUint32(&o.MCTL.Reg, volatile.LoadUint32(&o.MCTL.Reg)&^(0x80)|value<<7)
}
func (o *TRNG_Type) GetMCTL_FOR_SCLK() uint32 {
	return (volatile.LoadUint32(&o.MCTL.Reg) & 0x80) >> 7
}
func (o *TRNG_Type) SetMCTL_FCT_FAIL(value uint32) {
	volatile.StoreUint32(&o.MCTL.Reg, volatile.LoadUint32(&o.MCTL.Reg)&^(0x100)|value<<8)
}
func (o *TRNG_Type) GetMCTL_FCT_FAIL() uint32 {
	return (volatile.LoadUint32(&o.MCTL.Reg) & 0x100) >> 8
}
func (o *TRNG_Type) SetMCTL_FCT_VAL(value uint32) {
	volatile.StoreUint32(&o.MCTL.Reg, volatile.LoadUint32(&o.MCTL.Reg)&^(0x200)|value<<9)
}
func (o *TRNG_Type) GetMCTL_FCT_VAL() uint32 {
	return (volatile.LoadUint32(&o.MCTL.Reg) & 0x200) >> 9
}
func (o *TRNG_Type) SetMCTL_ENT_VAL(value uint32) {
	volatile.StoreUint32(&o.MCTL.Reg, volatile.LoadUint32(&o.MCTL.Reg)&^(0x400)|value<<10)
}
func (o *TRNG_Type) GetMCTL_ENT_VAL() uint32 {
	return (volatile.LoadUint32(&o.MCTL.Reg) & 0x400) >> 10
}
func (o *TRNG_Type) SetMCTL_TST_OUT(value uint32) {
	volatile.StoreUint32(&o.MCTL.Reg, volatile.LoadUint32(&o.MCTL.Reg)&^(0x800)|value<<11)
}
func (o *TRNG_Type) GetMCTL_TST_OUT() uint32 {
	return (volatile.LoadUint32(&o.MCTL.Reg) & 0x800) >> 11
}
func (o *TRNG_Type) SetMCTL_ERR(value uint32) {
	volatile.StoreUint32(&o.MCTL.Reg, volatile.LoadUint32(&o.MCTL.Reg)&^(0x1000)|value<<12)
}
func (o *TRNG_Type) GetMCTL_ERR() uint32 {
	return (volatile.LoadUint32(&o.MCTL.Reg) & 0x1000) >> 12
}
func (o *TRNG_Type) SetMCTL_TSTOP_OK(value uint32) {
	volatile.StoreUint32(&o.MCTL.Reg, volatile.LoadUint32(&o.MCTL.Reg)&^(0x2000)|value<<13)
}
func (o *TRNG_Type) GetMCTL_TSTOP_OK() uint32 {
	return (volatile.LoadUint32(&o.MCTL.Reg) & 0x2000) >> 13
}
func (o *TRNG_Type) SetMCTL_LRUN_CONT(value uint32) {
	volatile.StoreUint32(&o.MCTL.Reg, volatile.LoadUint32(&o.MCTL.Reg)&^(0x4000)|value<<14)
}
func (o *TRNG_Type) GetMCTL_LRUN_CONT() uint32 {
	return (volatile.LoadUint32(&o.MCTL.Reg) & 0x4000) >> 14
}
func (o *TRNG_Type) SetMCTL_PRGM(value uint32) {
	volatile.StoreUint32(&o.MCTL.Reg, volatile.LoadUint32(&o.MCTL.Reg)&^(0x10000)|value<<16)
}
func (o *TRNG_Type) GetMCTL_PRGM() uint32 {
	return (volatile.LoadUint32(&o.MCTL.Reg) & 0x10000) >> 16
}

// TRNG.SCMISC: Statistical Check Miscellaneous Register
func (o *TRNG_Type) SetSCMISC_LRUN_MAX(value uint32) {
	volatile.StoreUint32(&o.SCMISC.Reg, volatile.LoadUint32(&o.SCMISC.Reg)&^(0xff)|value)
}
func (o *TRNG_Type) GetSCMISC_LRUN_MAX() uint32 {
	return volatile.LoadUint32(&o.SCMISC.Reg) & 0xff
}
func (o *TRNG_Type) SetSCMISC_RTY_CT(value uint32) {
	volatile.StoreUint32(&o.SCMISC.Reg, volatile.LoadUint32(&o.SCMISC.Reg)&^(0xf0000)|value<<16)
}
func (o *TRNG_Type) GetSCMISC_RTY_CT() uint32 {
	return (volatile.LoadUint32(&o.SCMISC.Reg) & 0xf0000) >> 16
}

// TRNG.PKRRNG: Poker Range Register
func (o *TRNG_Type) SetPKRRNG_PKR_RNG(value uint32) {
	volatile.StoreUint32(&o.PKRRNG.Reg, volatile.LoadUint32(&o.PKRRNG.Reg)&^(0xffff)|value)
}
func (o *TRNG_Type) GetPKRRNG_PKR_RNG() uint32 {
	return volatile.LoadUint32(&o.PKRRNG.Reg) & 0xffff
}

// TRNG.PKRMAX: Poker Maximum Limit Register
func (o *TRNG_Type) SetPKRMAX_PKR_MAX(value uint32) {
	volatile.StoreUint32(&o.PKRMAX.Reg, volatile.LoadUint32(&o.PKRMAX.Reg)&^(0xffffff)|value)
}
func (o *TRNG_Type) GetPKRMAX_PKR_MAX() uint32 {
	return volatile.LoadUint32(&o.PKRMAX.Reg) & 0xffffff
}

// TRNG.SDCTL: Seed Control Register
func (o *TRNG_Type) SetSDCTL_SAMP_SIZE(value uint32) {
	volatile.StoreUint32(&o.SDCTL.Reg, volatile.LoadUint32(&o.SDCTL.Reg)&^(0xffff)|value)
}
func (o *TRNG_Type) GetSDCTL_SAMP_SIZE() uint32 {
	return volatile.LoadUint32(&o.SDCTL.Reg) & 0xffff
}
func (o *TRNG_Type) SetSDCTL_ENT_DLY(value uint32) {
	volatile.StoreUint32(&o.SDCTL.Reg, volatile.LoadUint32(&o.SDCTL.Reg)&^(0xffff0000)|value<<16)
}
func (o *TRNG_Type) GetSDCTL_ENT_DLY() uint32 {
	return (volatile.LoadUint32(&o.SDCTL.Reg) & 0xffff0000) >> 16
}

// TRNG.SBLIM: Sparse Bit Limit Register
func (o *TRNG_Type) SetSBLIM_SB_LIM(value uint32) {
	volatile.StoreUint32(&o.SBLIM.Reg, volatile.LoadUint32(&o.SBLIM.Reg)&^(0x3ff)|value)
}
func (o *TRNG_Type) GetSBLIM_SB_LIM() uint32 {
	return volatile.LoadUint32(&o.SBLIM.Reg) & 0x3ff
}

// TRNG.FRQMIN: Frequency Count Minimum Limit Register
func (o *TRNG_Type) SetFRQMIN_FRQ_MIN(value uint32) {
	volatile.StoreUint32(&o.FRQMIN.Reg, volatile.LoadUint32(&o.FRQMIN.Reg)&^(0x3fffff)|value)
}
func (o *TRNG_Type) GetFRQMIN_FRQ_MIN() uint32 {
	return volatile.LoadUint32(&o.FRQMIN.Reg) & 0x3fffff
}

// TRNG.FRQCNT: Frequency Count Register
func (o *TRNG_Type) SetFRQCNT_FRQ_CT(value uint32) {
	volatile.StoreUint32(&o.FRQCNT.Reg, volatile.LoadUint32(&o.FRQCNT.Reg)&^(0x3fffff)|value)
}
func (o *TRNG_Type) GetFRQCNT_FRQ_CT() uint32 {
	return volatile.LoadUint32(&o.FRQCNT.Reg) & 0x3fffff
}

// TRNG.SCMC: Statistical Check Monobit Count Register
func (o *TRNG_Type) SetSCMC_MONO_CT(value uint32) {
	volatile.StoreUint32(&o.SCMC.Reg, volatile.LoadUint32(&o.SCMC.Reg)&^(0xffff)|value)
}
func (o *TRNG_Type) GetSCMC_MONO_CT() uint32 {
	return volatile.LoadUint32(&o.SCMC.Reg) & 0xffff
}

// TRNG.SCR1C: Statistical Check Run Length 1 Count Register
func (o *TRNG_Type) SetSCR1C_R1_0_CT(value uint32) {
	volatile.StoreUint32(&o.SCR1C.Reg, volatile.LoadUint32(&o.SCR1C.Reg)&^(0x7fff)|value)
}
func (o *TRNG_Type) GetSCR1C_R1_0_CT() uint32 {
	return volatile.LoadUint32(&o.SCR1C.Reg) & 0x7fff
}
func (o *TRNG_Type) SetSCR1C_R1_1_CT(value uint32) {
	volatile.StoreUint32(&o.SCR1C.Reg, volatile.LoadUint32(&o.SCR1C.Reg)&^(0x7fff0000)|value<<16)
}
func (o *TRNG_Type) GetSCR1C_R1_1_CT() uint32 {
	return (volatile.LoadUint32(&o.SCR1C.Reg) & 0x7fff0000) >> 16
}

// TRNG.SCR2C: Statistical Check Run Length 2 Count Register
func (o *TRNG_Type) SetSCR2C_R2_0_CT(value uint32) {
	volatile.StoreUint32(&o.SCR2C.Reg, volatile.LoadUint32(&o.SCR2C.Reg)&^(0x3fff)|value)
}
func (o *TRNG_Type) GetSCR2C_R2_0_CT() uint32 {
	return volatile.LoadUint32(&o.SCR2C.Reg) & 0x3fff
}
func (o *TRNG_Type) SetSCR2C_R2_1_CT(value uint32) {
	volatile.StoreUint32(&o.SCR2C.Reg, volatile.LoadUint32(&o.SCR2C.Reg)&^(0x3fff0000)|value<<16)
}
func (o *TRNG_Type) GetSCR2C_R2_1_CT() uint32 {
	return (volatile.LoadUint32(&o.SCR2C.Reg) & 0x3fff0000) >> 16
}

// TRNG.SCR3C: Statistical Check Run Length 3 Count Register
func (o *TRNG_Type) SetSCR3C_R3_0_CT(value uint32) {
	volatile.StoreUint32(&o.SCR3C.Reg, volatile.LoadUint32(&o.SCR3C.Reg)&^(0x1fff)|value)
}
func (o *TRNG_Type) GetSCR3C_R3_0_CT() uint32 {
	return volatile.LoadUint32(&o.SCR3C.Reg) & 0x1fff
}
func (o *TRNG_Type) SetSCR3C_R3_1_CT(value uint32) {
	volatile.StoreUint32(&o.SCR3C.Reg, volatile.LoadUint32(&o.SCR3C.Reg)&^(0x1fff0000)|value<<16)
}
func (o *TRNG_Type) GetSCR3C_R3_1_CT() uint32 {
	return (volatile.LoadUint32(&o.SCR3C.Reg) & 0x1fff0000) >> 16
}

// TRNG.SCR4C: Statistical Check Run Length 4 Count Register
func (o *TRNG_Type) SetSCR4C_R4_0_CT(value uint32) {
	volatile.StoreUint32(&o.SCR4C.Reg, volatile.LoadUint32(&o.SCR4C.Reg)&^(0xfff)|value)
}
func (o *TRNG_Type) GetSCR4C_R4_0_CT() uint32 {
	return volatile.LoadUint32(&o.SCR4C.Reg) & 0xfff
}
func (o *TRNG_Type) SetSCR4C_R4_1_CT(value uint32) {
	volatile.StoreUint32(&o.SCR4C.Reg, volatile.LoadUint32(&o.SCR4C.Reg)&^(0xfff0000)|value<<16)
}
func (o *TRNG_Type) GetSCR4C_R4_1_CT() uint32 {
	return (volatile.LoadUint32(&o.SCR4C.Reg) & 0xfff0000) >> 16
}

// TRNG.SCR5C: Statistical Check Run Length 5 Count Register
func (o *TRNG_Type) SetSCR5C_R5_0_CT(value uint32) {
	volatile.StoreUint32(&o.SCR5C.Reg, volatile.LoadUint32(&o.SCR5C.Reg)&^(0x7ff)|value)
}
func (o *TRNG_Type) GetSCR5C_R5_0_CT() uint32 {
	return volatile.LoadUint32(&o.SCR5C.Reg) & 0x7ff
}
func (o *TRNG_Type) SetSCR5C_R5_1_CT(value uint32) {
	volatile.StoreUint32(&o.SCR5C.Reg, volatile.LoadUint32(&o.SCR5C.Reg)&^(0x7ff0000)|value<<16)
}
func (o *TRNG_Type) GetSCR5C_R5_1_CT() uint32 {
	return (volatile.LoadUint32(&o.SCR5C.Reg) & 0x7ff0000) >> 16
}

// TRNG.SCR6PC: Statistical Check Run Length 6+ Count Register
func (o *TRNG_Type) SetSCR6PC_R6P_0_CT(value uint32) {
	volatile.StoreUint32(&o.SCR6PC.Reg, volatile.LoadUint32(&o.SCR6PC.Reg)&^(0x7ff)|value)
}
func (o *TRNG_Type) GetSCR6PC_R6P_0_CT() uint32 {
	return volatile.LoadUint32(&o.SCR6PC.Reg) & 0x7ff
}
func (o *TRNG_Type) SetSCR6PC_R6P_1_CT(value uint32) {
	volatile.StoreUint32(&o.SCR6PC.Reg, volatile.LoadUint32(&o.SCR6PC.Reg)&^(0x7ff0000)|value<<16)
}
func (o *TRNG_Type) GetSCR6PC_R6P_1_CT() uint32 {
	return (volatile.LoadUint32(&o.SCR6PC.Reg) & 0x7ff0000) >> 16
}

// TRNG.STATUS: Status Register
func (o *TRNG_Type) SetSTATUS_TF1BR0(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1)|value)
}
func (o *TRNG_Type) GetSTATUS_TF1BR0() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x1
}
func (o *TRNG_Type) SetSTATUS_TF1BR1(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2)|value<<1)
}
func (o *TRNG_Type) GetSTATUS_TF1BR1() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2) >> 1
}
func (o *TRNG_Type) SetSTATUS_TF2BR0(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x4)|value<<2)
}
func (o *TRNG_Type) GetSTATUS_TF2BR0() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x4) >> 2
}
func (o *TRNG_Type) SetSTATUS_TF2BR1(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x8)|value<<3)
}
func (o *TRNG_Type) GetSTATUS_TF2BR1() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x8) >> 3
}
func (o *TRNG_Type) SetSTATUS_TF3BR0(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x10)|value<<4)
}
func (o *TRNG_Type) GetSTATUS_TF3BR0() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x10) >> 4
}
func (o *TRNG_Type) SetSTATUS_TF3BR1(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x20)|value<<5)
}
func (o *TRNG_Type) GetSTATUS_TF3BR1() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x20) >> 5
}
func (o *TRNG_Type) SetSTATUS_TF4BR0(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x40)|value<<6)
}
func (o *TRNG_Type) GetSTATUS_TF4BR0() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x40) >> 6
}
func (o *TRNG_Type) SetSTATUS_TF4BR1(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x80)|value<<7)
}
func (o *TRNG_Type) GetSTATUS_TF4BR1() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x80) >> 7
}
func (o *TRNG_Type) SetSTATUS_TF5BR0(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x100)|value<<8)
}
func (o *TRNG_Type) GetSTATUS_TF5BR0() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x100) >> 8
}
func (o *TRNG_Type) SetSTATUS_TF5BR1(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x200)|value<<9)
}
func (o *TRNG_Type) GetSTATUS_TF5BR1() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x200) >> 9
}
func (o *TRNG_Type) SetSTATUS_TF6PBR0(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x400)|value<<10)
}
func (o *TRNG_Type) GetSTATUS_TF6PBR0() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x400) >> 10
}
func (o *TRNG_Type) SetSTATUS_TF6PBR1(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x800)|value<<11)
}
func (o *TRNG_Type) GetSTATUS_TF6PBR1() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x800) >> 11
}
func (o *TRNG_Type) SetSTATUS_TFSB(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x1000)|value<<12)
}
func (o *TRNG_Type) GetSTATUS_TFSB() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x1000) >> 12
}
func (o *TRNG_Type) SetSTATUS_TFLR(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x2000)|value<<13)
}
func (o *TRNG_Type) GetSTATUS_TFLR() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x2000) >> 13
}
func (o *TRNG_Type) SetSTATUS_TFP(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x4000)|value<<14)
}
func (o *TRNG_Type) GetSTATUS_TFP() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x4000) >> 14
}
func (o *TRNG_Type) SetSTATUS_TFMB(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x8000)|value<<15)
}
func (o *TRNG_Type) GetSTATUS_TFMB() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x8000) >> 15
}
func (o *TRNG_Type) SetSTATUS_RETRY_CT(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0xf0000)|value<<16)
}
func (o *TRNG_Type) GetSTATUS_RETRY_CT() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0xf0000) >> 16
}

// TRNG.ENT: Entropy Read Register
func (o *TRNG_Type) SetENT(idx int, value uint32) {
	volatile.StoreUint32(&o.ENT[idx].Reg, value)
}
func (o *TRNG_Type) GetENT(idx int) uint32 {
	return volatile.LoadUint32(&o.ENT[idx].Reg)
}

// TRNG.PKRCNT10: Statistical Check Poker Count 1 and 0 Register
func (o *TRNG_Type) SetPKRCNT10_PKR_0_CT(value uint32) {
	volatile.StoreUint32(&o.PKRCNT10.Reg, volatile.LoadUint32(&o.PKRCNT10.Reg)&^(0xffff)|value)
}
func (o *TRNG_Type) GetPKRCNT10_PKR_0_CT() uint32 {
	return volatile.LoadUint32(&o.PKRCNT10.Reg) & 0xffff
}
func (o *TRNG_Type) SetPKRCNT10_PKR_1_CT(value uint32) {
	volatile.StoreUint32(&o.PKRCNT10.Reg, volatile.LoadUint32(&o.PKRCNT10.Reg)&^(0xffff0000)|value<<16)
}
func (o *TRNG_Type) GetPKRCNT10_PKR_1_CT() uint32 {
	return (volatile.LoadUint32(&o.PKRCNT10.Reg) & 0xffff0000) >> 16
}

// TRNG.PKRCNT32: Statistical Check Poker Count 3 and 2 Register
func (o *TRNG_Type) SetPKRCNT32_PKR_2_CT(value uint32) {
	volatile.StoreUint32(&o.PKRCNT32.Reg, volatile.LoadUint32(&o.PKRCNT32.Reg)&^(0xffff)|value)
}
func (o *TRNG_Type) GetPKRCNT32_PKR_2_CT() uint32 {
	return volatile.LoadUint32(&o.PKRCNT32.Reg) & 0xffff
}
func (o *TRNG_Type) SetPKRCNT32_PKR_3_CT(value uint32) {
	volatile.StoreUint32(&o.PKRCNT32.Reg, volatile.LoadUint32(&o.PKRCNT32.Reg)&^(0xffff0000)|value<<16)
}
func (o *TRNG_Type) GetPKRCNT32_PKR_3_CT() uint32 {
	return (volatile.LoadUint32(&o.PKRCNT32.Reg) & 0xffff0000) >> 16
}

// TRNG.PKRCNT54: Statistical Check Poker Count 5 and 4 Register
func (o *TRNG_Type) SetPKRCNT54_PKR_4_CT(value uint32) {
	volatile.StoreUint32(&o.PKRCNT54.Reg, volatile.LoadUint32(&o.PKRCNT54.Reg)&^(0xffff)|value)
}
func (o *TRNG_Type) GetPKRCNT54_PKR_4_CT() uint32 {
	return volatile.LoadUint32(&o.PKRCNT54.Reg) & 0xffff
}
func (o *TRNG_Type) SetPKRCNT54_PKR_5_CT(value uint32) {
	volatile.StoreUint32(&o.PKRCNT54.Reg, volatile.LoadUint32(&o.PKRCNT54.Reg)&^(0xffff0000)|value<<16)
}
func (o *TRNG_Type) GetPKRCNT54_PKR_5_CT() uint32 {
	return (volatile.LoadUint32(&o.PKRCNT54.Reg) & 0xffff0000) >> 16
}

// TRNG.PKRCNT76: Statistical Check Poker Count 7 and 6 Register
func (o *TRNG_Type) SetPKRCNT76_PKR_6_CT(value uint32) {
	volatile.StoreUint32(&o.PKRCNT76.Reg, volatile.LoadUint32(&o.PKRCNT76.Reg)&^(0xffff)|value)
}
func (o *TRNG_Type) GetPKRCNT76_PKR_6_CT() uint32 {
	return volatile.LoadUint32(&o.PKRCNT76.Reg) & 0xffff
}
func (o *TRNG_Type) SetPKRCNT76_PKR_7_CT(value uint32) {
	volatile.StoreUint32(&o.PKRCNT76.Reg, volatile.LoadUint32(&o.PKRCNT76.Reg)&^(0xffff0000)|value<<16)
}
func (o *TRNG_Type) GetPKRCNT76_PKR_7_CT() uint32 {
	return (volatile.LoadUint32(&o.PKRCNT76.Reg) & 0xffff0000) >> 16
}

// TRNG.PKRCNT98: Statistical Check Poker Count 9 and 8 Register
func (o *TRNG_Type) SetPKRCNT98_PKR_8_CT(value uint32) {
	volatile.StoreUint32(&o.PKRCNT98.Reg, volatile.LoadUint32(&o.PKRCNT98.Reg)&^(0xffff)|value)
}
func (o *TRNG_Type) GetPKRCNT98_PKR_8_CT() uint32 {
	return volatile.LoadUint32(&o.PKRCNT98.Reg) & 0xffff
}
func (o *TRNG_Type) SetPKRCNT98_PKR_9_CT(value uint32) {
	volatile.StoreUint32(&o.PKRCNT98.Reg, volatile.LoadUint32(&o.PKRCNT98.Reg)&^(0xffff0000)|value<<16)
}
func (o *TRNG_Type) GetPKRCNT98_PKR_9_CT() uint32 {
	return (volatile.LoadUint32(&o.PKRCNT98.Reg) & 0xffff0000) >> 16
}

// TRNG.PKRCNTBA: Statistical Check Poker Count B and A Register
func (o *TRNG_Type) SetPKRCNTBA_PKR_A_CT(value uint32) {
	volatile.StoreUint32(&o.PKRCNTBA.Reg, volatile.LoadUint32(&o.PKRCNTBA.Reg)&^(0xffff)|value)
}
func (o *TRNG_Type) GetPKRCNTBA_PKR_A_CT() uint32 {
	return volatile.LoadUint32(&o.PKRCNTBA.Reg) & 0xffff
}
func (o *TRNG_Type) SetPKRCNTBA_PKR_B_CT(value uint32) {
	volatile.StoreUint32(&o.PKRCNTBA.Reg, volatile.LoadUint32(&o.PKRCNTBA.Reg)&^(0xffff0000)|value<<16)
}
func (o *TRNG_Type) GetPKRCNTBA_PKR_B_CT() uint32 {
	return (volatile.LoadUint32(&o.PKRCNTBA.Reg) & 0xffff0000) >> 16
}

// TRNG.PKRCNTDC: Statistical Check Poker Count D and C Register
func (o *TRNG_Type) SetPKRCNTDC_PKR_C_CT(value uint32) {
	volatile.StoreUint32(&o.PKRCNTDC.Reg, volatile.LoadUint32(&o.PKRCNTDC.Reg)&^(0xffff)|value)
}
func (o *TRNG_Type) GetPKRCNTDC_PKR_C_CT() uint32 {
	return volatile.LoadUint32(&o.PKRCNTDC.Reg) & 0xffff
}
func (o *TRNG_Type) SetPKRCNTDC_PKR_D_CT(value uint32) {
	volatile.StoreUint32(&o.PKRCNTDC.Reg, volatile.LoadUint32(&o.PKRCNTDC.Reg)&^(0xffff0000)|value<<16)
}
func (o *TRNG_Type) GetPKRCNTDC_PKR_D_CT() uint32 {
	return (volatile.LoadUint32(&o.PKRCNTDC.Reg) & 0xffff0000) >> 16
}

// TRNG.PKRCNTFE: Statistical Check Poker Count F and E Register
func (o *TRNG_Type) SetPKRCNTFE_PKR_E_CT(value uint32) {
	volatile.StoreUint32(&o.PKRCNTFE.Reg, volatile.LoadUint32(&o.PKRCNTFE.Reg)&^(0xffff)|value)
}
func (o *TRNG_Type) GetPKRCNTFE_PKR_E_CT() uint32 {
	return volatile.LoadUint32(&o.PKRCNTFE.Reg) & 0xffff
}
func (o *TRNG_Type) SetPKRCNTFE_PKR_F_CT(value uint32) {
	volatile.StoreUint32(&o.PKRCNTFE.Reg, volatile.LoadUint32(&o.PKRCNTFE.Reg)&^(0xffff0000)|value<<16)
}
func (o *TRNG_Type) GetPKRCNTFE_PKR_F_CT() uint32 {
	return (volatile.LoadUint32(&o.PKRCNTFE.Reg) & 0xffff0000) >> 16
}

// TRNG.SEC_CFG: Security Configuration Register
func (o *TRNG_Type) SetSEC_CFG_UNUSED0(value uint32) {
	volatile.StoreUint32(&o.SEC_CFG.Reg, volatile.LoadUint32(&o.SEC_CFG.Reg)&^(0x1)|value)
}
func (o *TRNG_Type) GetSEC_CFG_UNUSED0() uint32 {
	return volatile.LoadUint32(&o.SEC_CFG.Reg) & 0x1
}
func (o *TRNG_Type) SetSEC_CFG_NO_PRGM(value uint32) {
	volatile.StoreUint32(&o.SEC_CFG.Reg, volatile.LoadUint32(&o.SEC_CFG.Reg)&^(0x2)|value<<1)
}
func (o *TRNG_Type) GetSEC_CFG_NO_PRGM() uint32 {
	return (volatile.LoadUint32(&o.SEC_CFG.Reg) & 0x2) >> 1
}
func (o *TRNG_Type) SetSEC_CFG_UNUSED2(value uint32) {
	volatile.StoreUint32(&o.SEC_CFG.Reg, volatile.LoadUint32(&o.SEC_CFG.Reg)&^(0x4)|value<<2)
}
func (o *TRNG_Type) GetSEC_CFG_UNUSED2() uint32 {
	return (volatile.LoadUint32(&o.SEC_CFG.Reg) & 0x4) >> 2
}

// TRNG.INT_CTRL: Interrupt Control Register
func (o *TRNG_Type) SetINT_CTRL_HW_ERR(value uint32) {
	volatile.StoreUint32(&o.INT_CTRL.Reg, volatile.LoadUint32(&o.INT_CTRL.Reg)&^(0x1)|value)
}
func (o *TRNG_Type) GetINT_CTRL_HW_ERR() uint32 {
	return volatile.LoadUint32(&o.INT_CTRL.Reg) & 0x1
}
func (o *TRNG_Type) SetINT_CTRL_ENT_VAL(value uint32) {
	volatile.StoreUint32(&o.INT_CTRL.Reg, volatile.LoadUint32(&o.INT_CTRL.Reg)&^(0x2)|value<<1)
}
func (o *TRNG_Type) GetINT_CTRL_ENT_VAL() uint32 {
	return (volatile.LoadUint32(&o.INT_CTRL.Reg) & 0x2) >> 1
}
func (o *TRNG_Type) SetINT_CTRL_FRQ_CT_FAIL(value uint32) {
	volatile.StoreUint32(&o.INT_CTRL.Reg, volatile.LoadUint32(&o.INT_CTRL.Reg)&^(0x4)|value<<2)
}
func (o *TRNG_Type) GetINT_CTRL_FRQ_CT_FAIL() uint32 {
	return (volatile.LoadUint32(&o.INT_CTRL.Reg) & 0x4) >> 2
}

// TRNG.INT_MASK: Mask Register
func (o *TRNG_Type) SetINT_MASK_HW_ERR(value uint32) {
	volatile.StoreUint32(&o.INT_MASK.Reg, volatile.LoadUint32(&o.INT_MASK.Reg)&^(0x1)|value)
}
func (o *TRNG_Type) GetINT_MASK_HW_ERR() uint32 {
	return volatile.LoadUint32(&o.INT_MASK.Reg) & 0x1
}
func (o *TRNG_Type) SetINT_MASK_ENT_VAL(value uint32) {
	volatile.StoreUint32(&o.INT_MASK.Reg, volatile.LoadUint32(&o.INT_MASK.Reg)&^(0x2)|value<<1)
}
func (o *TRNG_Type) GetINT_MASK_ENT_VAL() uint32 {
	return (volatile.LoadUint32(&o.INT_MASK.Reg) & 0x2) >> 1
}
func (o *TRNG_Type) SetINT_MASK_FRQ_CT_FAIL(value uint32) {
	volatile.StoreUint32(&o.INT_MASK.Reg, volatile.LoadUint32(&o.INT_MASK.Reg)&^(0x4)|value<<2)
}
func (o *TRNG_Type) GetINT_MASK_FRQ_CT_FAIL() uint32 {
	return (volatile.LoadUint32(&o.INT_MASK.Reg) & 0x4) >> 2
}

// TRNG.INT_STATUS: Interrupt Status Register
func (o *TRNG_Type) SetINT_STATUS_HW_ERR(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x1)|value)
}
func (o *TRNG_Type) GetINT_STATUS_HW_ERR() uint32 {
	return volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x1
}
func (o *TRNG_Type) SetINT_STATUS_ENT_VAL(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x2)|value<<1)
}
func (o *TRNG_Type) GetINT_STATUS_ENT_VAL() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x2) >> 1
}
func (o *TRNG_Type) SetINT_STATUS_FRQ_CT_FAIL(value uint32) {
	volatile.StoreUint32(&o.INT_STATUS.Reg, volatile.LoadUint32(&o.INT_STATUS.Reg)&^(0x4)|value<<2)
}
func (o *TRNG_Type) GetINT_STATUS_FRQ_CT_FAIL() uint32 {
	return (volatile.LoadUint32(&o.INT_STATUS.Reg) & 0x4) >> 2
}

// TRNG.VID1: Version ID Register (MS)
func (o *TRNG_Type) SetVID1_MIN_REV(value uint32) {
	volatile.StoreUint32(&o.VID1.Reg, volatile.LoadUint32(&o.VID1.Reg)&^(0xff)|value)
}
func (o *TRNG_Type) GetVID1_MIN_REV() uint32 {
	return volatile.LoadUint32(&o.VID1.Reg) & 0xff
}
func (o *TRNG_Type) SetVID1_MAJ_REV(value uint32) {
	volatile.StoreUint32(&o.VID1.Reg, volatile.LoadUint32(&o.VID1.Reg)&^(0xff00)|value<<8)
}
func (o *TRNG_Type) GetVID1_MAJ_REV() uint32 {
	return (volatile.LoadUint32(&o.VID1.Reg) & 0xff00) >> 8
}
func (o *TRNG_Type) SetVID1_IP_ID(value uint32) {
	volatile.StoreUint32(&o.VID1.Reg, volatile.LoadUint32(&o.VID1.Reg)&^(0xffff0000)|value<<16)
}
func (o *TRNG_Type) GetVID1_IP_ID() uint32 {
	return (volatile.LoadUint32(&o.VID1.Reg) & 0xffff0000) >> 16
}

// TRNG.VID2: Version ID Register (LS)
func (o *TRNG_Type) SetVID2_CONFIG_OPT(value uint32) {
	volatile.StoreUint32(&o.VID2.Reg, volatile.LoadUint32(&o.VID2.Reg)&^(0xff)|value)
}
func (o *TRNG_Type) GetVID2_CONFIG_OPT() uint32 {
	return volatile.LoadUint32(&o.VID2.Reg) & 0xff
}
func (o *TRNG_Type) SetVID2_ECO_REV(value uint32) {
	volatile.StoreUint32(&o.VID2.Reg, volatile.LoadUint32(&o.VID2.Reg)&^(0xff00)|value<<8)
}
func (o *TRNG_Type) GetVID2_ECO_REV() uint32 {
	return (volatile.LoadUint32(&o.VID2.Reg) & 0xff00) >> 8
}
func (o *TRNG_Type) SetVID2_INTG_OPT(value uint32) {
	volatile.StoreUint32(&o.VID2.Reg, volatile.LoadUint32(&o.VID2.Reg)&^(0xff0000)|value<<16)
}
func (o *TRNG_Type) GetVID2_INTG_OPT() uint32 {
	return (volatile.LoadUint32(&o.VID2.Reg) & 0xff0000) >> 16
}
func (o *TRNG_Type) SetVID2_ERA(value uint32) {
	volatile.StoreUint32(&o.VID2.Reg, volatile.LoadUint32(&o.VID2.Reg)&^(0xff000000)|value<<24)
}
func (o *TRNG_Type) GetVID2_ERA() uint32 {
	return (volatile.LoadUint32(&o.VID2.Reg) & 0xff000000) >> 24
}

// SNVS
type SNVS_Type struct {
	HPLR                volatile.Register32 // 0x0
	HPCOMR              volatile.Register32 // 0x4
	HPCR                volatile.Register32 // 0x8
	HPSICR              volatile.Register32 // 0xC
	HPSVCR              volatile.Register32 // 0x10
	HPSR                volatile.Register32 // 0x14
	HPSVSR              volatile.Register32 // 0x18
	HPHACIVR            volatile.Register32 // 0x1C
	HPHACR              volatile.Register32 // 0x20
	HPRTCMR             volatile.Register32 // 0x24
	HPRTCLR             volatile.Register32 // 0x28
	HPTAMR              volatile.Register32 // 0x2C
	HPTALR              volatile.Register32 // 0x30
	LPLR                volatile.Register32 // 0x34
	LPCR                volatile.Register32 // 0x38
	LPMKCR              volatile.Register32 // 0x3C
	LPSVCR              volatile.Register32 // 0x40
	_                   [4]byte
	LPTDCR              volatile.Register32    // 0x48
	LPSR                volatile.Register32    // 0x4C
	LPSRTCMR            volatile.Register32    // 0x50
	LPSRTCLR            volatile.Register32    // 0x54
	LPTAR               volatile.Register32    // 0x58
	LPSMCMR             volatile.Register32    // 0x5C
	LPSMCLR             volatile.Register32    // 0x60
	LPPGDR              volatile.Register32    // 0x64
	LPGPR0_legacy_alias volatile.Register32    // 0x68
	LPZMKR              [8]volatile.Register32 // 0x6C
	_                   [4]byte
	LPGPR_alias         [4]volatile.Register32 // 0x90
	_                   [96]byte
	LPGPR               [4]volatile.Register32 // 0x100
	_                   [2792]byte
	HPVIDR1             volatile.Register32 // 0xBF8
	HPVIDR2             volatile.Register32 // 0xBFC
}

// SNVS.HPLR: SNVS_HP Lock Register
func (o *SNVS_Type) SetHPLR_ZMK_WSL(value uint32) {
	volatile.StoreUint32(&o.HPLR.Reg, volatile.LoadUint32(&o.HPLR.Reg)&^(0x1)|value)
}
func (o *SNVS_Type) GetHPLR_ZMK_WSL() uint32 {
	return volatile.LoadUint32(&o.HPLR.Reg) & 0x1
}
func (o *SNVS_Type) SetHPLR_ZMK_RSL(value uint32) {
	volatile.StoreUint32(&o.HPLR.Reg, volatile.LoadUint32(&o.HPLR.Reg)&^(0x2)|value<<1)
}
func (o *SNVS_Type) GetHPLR_ZMK_RSL() uint32 {
	return (volatile.LoadUint32(&o.HPLR.Reg) & 0x2) >> 1
}
func (o *SNVS_Type) SetHPLR_SRTC_SL(value uint32) {
	volatile.StoreUint32(&o.HPLR.Reg, volatile.LoadUint32(&o.HPLR.Reg)&^(0x4)|value<<2)
}
func (o *SNVS_Type) GetHPLR_SRTC_SL() uint32 {
	return (volatile.LoadUint32(&o.HPLR.Reg) & 0x4) >> 2
}
func (o *SNVS_Type) SetHPLR_LPCALB_SL(value uint32) {
	volatile.StoreUint32(&o.HPLR.Reg, volatile.LoadUint32(&o.HPLR.Reg)&^(0x8)|value<<3)
}
func (o *SNVS_Type) GetHPLR_LPCALB_SL() uint32 {
	return (volatile.LoadUint32(&o.HPLR.Reg) & 0x8) >> 3
}
func (o *SNVS_Type) SetHPLR_MC_SL(value uint32) {
	volatile.StoreUint32(&o.HPLR.Reg, volatile.LoadUint32(&o.HPLR.Reg)&^(0x10)|value<<4)
}
func (o *SNVS_Type) GetHPLR_MC_SL() uint32 {
	return (volatile.LoadUint32(&o.HPLR.Reg) & 0x10) >> 4
}
func (o *SNVS_Type) SetHPLR_GPR_SL(value uint32) {
	volatile.StoreUint32(&o.HPLR.Reg, volatile.LoadUint32(&o.HPLR.Reg)&^(0x20)|value<<5)
}
func (o *SNVS_Type) GetHPLR_GPR_SL() uint32 {
	return (volatile.LoadUint32(&o.HPLR.Reg) & 0x20) >> 5
}
func (o *SNVS_Type) SetHPLR_LPSVCR_SL(value uint32) {
	volatile.StoreUint32(&o.HPLR.Reg, volatile.LoadUint32(&o.HPLR.Reg)&^(0x40)|value<<6)
}
func (o *SNVS_Type) GetHPLR_LPSVCR_SL() uint32 {
	return (volatile.LoadUint32(&o.HPLR.Reg) & 0x40) >> 6
}
func (o *SNVS_Type) SetHPLR_LPTDCR_SL(value uint32) {
	volatile.StoreUint32(&o.HPLR.Reg, volatile.LoadUint32(&o.HPLR.Reg)&^(0x100)|value<<8)
}
func (o *SNVS_Type) GetHPLR_LPTDCR_SL() uint32 {
	return (volatile.LoadUint32(&o.HPLR.Reg) & 0x100) >> 8
}
func (o *SNVS_Type) SetHPLR_MKS_SL(value uint32) {
	volatile.StoreUint32(&o.HPLR.Reg, volatile.LoadUint32(&o.HPLR.Reg)&^(0x200)|value<<9)
}
func (o *SNVS_Type) GetHPLR_MKS_SL() uint32 {
	return (volatile.LoadUint32(&o.HPLR.Reg) & 0x200) >> 9
}
func (o *SNVS_Type) SetHPLR_HPSVCR_L(value uint32) {
	volatile.StoreUint32(&o.HPLR.Reg, volatile.LoadUint32(&o.HPLR.Reg)&^(0x10000)|value<<16)
}
func (o *SNVS_Type) GetHPLR_HPSVCR_L() uint32 {
	return (volatile.LoadUint32(&o.HPLR.Reg) & 0x10000) >> 16
}
func (o *SNVS_Type) SetHPLR_HPSICR_L(value uint32) {
	volatile.StoreUint32(&o.HPLR.Reg, volatile.LoadUint32(&o.HPLR.Reg)&^(0x20000)|value<<17)
}
func (o *SNVS_Type) GetHPLR_HPSICR_L() uint32 {
	return (volatile.LoadUint32(&o.HPLR.Reg) & 0x20000) >> 17
}
func (o *SNVS_Type) SetHPLR_HAC_L(value uint32) {
	volatile.StoreUint32(&o.HPLR.Reg, volatile.LoadUint32(&o.HPLR.Reg)&^(0x40000)|value<<18)
}
func (o *SNVS_Type) GetHPLR_HAC_L() uint32 {
	return (volatile.LoadUint32(&o.HPLR.Reg) & 0x40000) >> 18
}

// SNVS.HPCOMR: SNVS_HP Command Register
func (o *SNVS_Type) SetHPCOMR_SSM_ST(value uint32) {
	volatile.StoreUint32(&o.HPCOMR.Reg, volatile.LoadUint32(&o.HPCOMR.Reg)&^(0x1)|value)
}
func (o *SNVS_Type) GetHPCOMR_SSM_ST() uint32 {
	return volatile.LoadUint32(&o.HPCOMR.Reg) & 0x1
}
func (o *SNVS_Type) SetHPCOMR_SSM_ST_DIS(value uint32) {
	volatile.StoreUint32(&o.HPCOMR.Reg, volatile.LoadUint32(&o.HPCOMR.Reg)&^(0x2)|value<<1)
}
func (o *SNVS_Type) GetHPCOMR_SSM_ST_DIS() uint32 {
	return (volatile.LoadUint32(&o.HPCOMR.Reg) & 0x2) >> 1
}
func (o *SNVS_Type) SetHPCOMR_SSM_SFNS_DIS(value uint32) {
	volatile.StoreUint32(&o.HPCOMR.Reg, volatile.LoadUint32(&o.HPCOMR.Reg)&^(0x4)|value<<2)
}
func (o *SNVS_Type) GetHPCOMR_SSM_SFNS_DIS() uint32 {
	return (volatile.LoadUint32(&o.HPCOMR.Reg) & 0x4) >> 2
}
func (o *SNVS_Type) SetHPCOMR_LP_SWR(value uint32) {
	volatile.StoreUint32(&o.HPCOMR.Reg, volatile.LoadUint32(&o.HPCOMR.Reg)&^(0x10)|value<<4)
}
func (o *SNVS_Type) GetHPCOMR_LP_SWR() uint32 {
	return (volatile.LoadUint32(&o.HPCOMR.Reg) & 0x10) >> 4
}
func (o *SNVS_Type) SetHPCOMR_LP_SWR_DIS(value uint32) {
	volatile.StoreUint32(&o.HPCOMR.Reg, volatile.LoadUint32(&o.HPCOMR.Reg)&^(0x20)|value<<5)
}
func (o *SNVS_Type) GetHPCOMR_LP_SWR_DIS() uint32 {
	return (volatile.LoadUint32(&o.HPCOMR.Reg) & 0x20) >> 5
}
func (o *SNVS_Type) SetHPCOMR_SW_SV(value uint32) {
	volatile.StoreUint32(&o.HPCOMR.Reg, volatile.LoadUint32(&o.HPCOMR.Reg)&^(0x100)|value<<8)
}
func (o *SNVS_Type) GetHPCOMR_SW_SV() uint32 {
	return (volatile.LoadUint32(&o.HPCOMR.Reg) & 0x100) >> 8
}
func (o *SNVS_Type) SetHPCOMR_SW_FSV(value uint32) {
	volatile.StoreUint32(&o.HPCOMR.Reg, volatile.LoadUint32(&o.HPCOMR.Reg)&^(0x200)|value<<9)
}
func (o *SNVS_Type) GetHPCOMR_SW_FSV() uint32 {
	return (volatile.LoadUint32(&o.HPCOMR.Reg) & 0x200) >> 9
}
func (o *SNVS_Type) SetHPCOMR_SW_LPSV(value uint32) {
	volatile.StoreUint32(&o.HPCOMR.Reg, volatile.LoadUint32(&o.HPCOMR.Reg)&^(0x400)|value<<10)
}
func (o *SNVS_Type) GetHPCOMR_SW_LPSV() uint32 {
	return (volatile.LoadUint32(&o.HPCOMR.Reg) & 0x400) >> 10
}
func (o *SNVS_Type) SetHPCOMR_PROG_ZMK(value uint32) {
	volatile.StoreUint32(&o.HPCOMR.Reg, volatile.LoadUint32(&o.HPCOMR.Reg)&^(0x1000)|value<<12)
}
func (o *SNVS_Type) GetHPCOMR_PROG_ZMK() uint32 {
	return (volatile.LoadUint32(&o.HPCOMR.Reg) & 0x1000) >> 12
}
func (o *SNVS_Type) SetHPCOMR_MKS_EN(value uint32) {
	volatile.StoreUint32(&o.HPCOMR.Reg, volatile.LoadUint32(&o.HPCOMR.Reg)&^(0x2000)|value<<13)
}
func (o *SNVS_Type) GetHPCOMR_MKS_EN() uint32 {
	return (volatile.LoadUint32(&o.HPCOMR.Reg) & 0x2000) >> 13
}
func (o *SNVS_Type) SetHPCOMR_HAC_EN(value uint32) {
	volatile.StoreUint32(&o.HPCOMR.Reg, volatile.LoadUint32(&o.HPCOMR.Reg)&^(0x10000)|value<<16)
}
func (o *SNVS_Type) GetHPCOMR_HAC_EN() uint32 {
	return (volatile.LoadUint32(&o.HPCOMR.Reg) & 0x10000) >> 16
}
func (o *SNVS_Type) SetHPCOMR_HAC_LOAD(value uint32) {
	volatile.StoreUint32(&o.HPCOMR.Reg, volatile.LoadUint32(&o.HPCOMR.Reg)&^(0x20000)|value<<17)
}
func (o *SNVS_Type) GetHPCOMR_HAC_LOAD() uint32 {
	return (volatile.LoadUint32(&o.HPCOMR.Reg) & 0x20000) >> 17
}
func (o *SNVS_Type) SetHPCOMR_HAC_CLEAR(value uint32) {
	volatile.StoreUint32(&o.HPCOMR.Reg, volatile.LoadUint32(&o.HPCOMR.Reg)&^(0x40000)|value<<18)
}
func (o *SNVS_Type) GetHPCOMR_HAC_CLEAR() uint32 {
	return (volatile.LoadUint32(&o.HPCOMR.Reg) & 0x40000) >> 18
}
func (o *SNVS_Type) SetHPCOMR_HAC_STOP(value uint32) {
	volatile.StoreUint32(&o.HPCOMR.Reg, volatile.LoadUint32(&o.HPCOMR.Reg)&^(0x80000)|value<<19)
}
func (o *SNVS_Type) GetHPCOMR_HAC_STOP() uint32 {
	return (volatile.LoadUint32(&o.HPCOMR.Reg) & 0x80000) >> 19
}
func (o *SNVS_Type) SetHPCOMR_NPSWA_EN(value uint32) {
	volatile.StoreUint32(&o.HPCOMR.Reg, volatile.LoadUint32(&o.HPCOMR.Reg)&^(0x80000000)|value<<31)
}
func (o *SNVS_Type) GetHPCOMR_NPSWA_EN() uint32 {
	return (volatile.LoadUint32(&o.HPCOMR.Reg) & 0x80000000) >> 31
}

// SNVS.HPCR: SNVS_HP Control Register
func (o *SNVS_Type) SetHPCR_RTC_EN(value uint32) {
	volatile.StoreUint32(&o.HPCR.Reg, volatile.LoadUint32(&o.HPCR.Reg)&^(0x1)|value)
}
func (o *SNVS_Type) GetHPCR_RTC_EN() uint32 {
	return volatile.LoadUint32(&o.HPCR.Reg) & 0x1
}
func (o *SNVS_Type) SetHPCR_HPTA_EN(value uint32) {
	volatile.StoreUint32(&o.HPCR.Reg, volatile.LoadUint32(&o.HPCR.Reg)&^(0x2)|value<<1)
}
func (o *SNVS_Type) GetHPCR_HPTA_EN() uint32 {
	return (volatile.LoadUint32(&o.HPCR.Reg) & 0x2) >> 1
}
func (o *SNVS_Type) SetHPCR_DIS_PI(value uint32) {
	volatile.StoreUint32(&o.HPCR.Reg, volatile.LoadUint32(&o.HPCR.Reg)&^(0x4)|value<<2)
}
func (o *SNVS_Type) GetHPCR_DIS_PI() uint32 {
	return (volatile.LoadUint32(&o.HPCR.Reg) & 0x4) >> 2
}
func (o *SNVS_Type) SetHPCR_PI_EN(value uint32) {
	volatile.StoreUint32(&o.HPCR.Reg, volatile.LoadUint32(&o.HPCR.Reg)&^(0x8)|value<<3)
}
func (o *SNVS_Type) GetHPCR_PI_EN() uint32 {
	return (volatile.LoadUint32(&o.HPCR.Reg) & 0x8) >> 3
}
func (o *SNVS_Type) SetHPCR_PI_FREQ(value uint32) {
	volatile.StoreUint32(&o.HPCR.Reg, volatile.LoadUint32(&o.HPCR.Reg)&^(0xf0)|value<<4)
}
func (o *SNVS_Type) GetHPCR_PI_FREQ() uint32 {
	return (volatile.LoadUint32(&o.HPCR.Reg) & 0xf0) >> 4
}
func (o *SNVS_Type) SetHPCR_HPCALB_EN(value uint32) {
	volatile.StoreUint32(&o.HPCR.Reg, volatile.LoadUint32(&o.HPCR.Reg)&^(0x100)|value<<8)
}
func (o *SNVS_Type) GetHPCR_HPCALB_EN() uint32 {
	return (volatile.LoadUint32(&o.HPCR.Reg) & 0x100) >> 8
}
func (o *SNVS_Type) SetHPCR_HPCALB_VAL(value uint32) {
	volatile.StoreUint32(&o.HPCR.Reg, volatile.LoadUint32(&o.HPCR.Reg)&^(0x7c00)|value<<10)
}
func (o *SNVS_Type) GetHPCR_HPCALB_VAL() uint32 {
	return (volatile.LoadUint32(&o.HPCR.Reg) & 0x7c00) >> 10
}
func (o *SNVS_Type) SetHPCR_HP_TS(value uint32) {
	volatile.StoreUint32(&o.HPCR.Reg, volatile.LoadUint32(&o.HPCR.Reg)&^(0x10000)|value<<16)
}
func (o *SNVS_Type) GetHPCR_HP_TS() uint32 {
	return (volatile.LoadUint32(&o.HPCR.Reg) & 0x10000) >> 16
}
func (o *SNVS_Type) SetHPCR_BTN_CONFIG(value uint32) {
	volatile.StoreUint32(&o.HPCR.Reg, volatile.LoadUint32(&o.HPCR.Reg)&^(0x7000000)|value<<24)
}
func (o *SNVS_Type) GetHPCR_BTN_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.HPCR.Reg) & 0x7000000) >> 24
}
func (o *SNVS_Type) SetHPCR_BTN_MASK(value uint32) {
	volatile.StoreUint32(&o.HPCR.Reg, volatile.LoadUint32(&o.HPCR.Reg)&^(0x8000000)|value<<27)
}
func (o *SNVS_Type) GetHPCR_BTN_MASK() uint32 {
	return (volatile.LoadUint32(&o.HPCR.Reg) & 0x8000000) >> 27
}

// SNVS.HPSICR: SNVS_HP Security Interrupt Control Register
func (o *SNVS_Type) SetHPSICR_SV0_EN(value uint32) {
	volatile.StoreUint32(&o.HPSICR.Reg, volatile.LoadUint32(&o.HPSICR.Reg)&^(0x1)|value)
}
func (o *SNVS_Type) GetHPSICR_SV0_EN() uint32 {
	return volatile.LoadUint32(&o.HPSICR.Reg) & 0x1
}
func (o *SNVS_Type) SetHPSICR_SV1_EN(value uint32) {
	volatile.StoreUint32(&o.HPSICR.Reg, volatile.LoadUint32(&o.HPSICR.Reg)&^(0x2)|value<<1)
}
func (o *SNVS_Type) GetHPSICR_SV1_EN() uint32 {
	return (volatile.LoadUint32(&o.HPSICR.Reg) & 0x2) >> 1
}
func (o *SNVS_Type) SetHPSICR_SV2_EN(value uint32) {
	volatile.StoreUint32(&o.HPSICR.Reg, volatile.LoadUint32(&o.HPSICR.Reg)&^(0x4)|value<<2)
}
func (o *SNVS_Type) GetHPSICR_SV2_EN() uint32 {
	return (volatile.LoadUint32(&o.HPSICR.Reg) & 0x4) >> 2
}
func (o *SNVS_Type) SetHPSICR_SV3_EN(value uint32) {
	volatile.StoreUint32(&o.HPSICR.Reg, volatile.LoadUint32(&o.HPSICR.Reg)&^(0x8)|value<<3)
}
func (o *SNVS_Type) GetHPSICR_SV3_EN() uint32 {
	return (volatile.LoadUint32(&o.HPSICR.Reg) & 0x8) >> 3
}
func (o *SNVS_Type) SetHPSICR_SV4_EN(value uint32) {
	volatile.StoreUint32(&o.HPSICR.Reg, volatile.LoadUint32(&o.HPSICR.Reg)&^(0x10)|value<<4)
}
func (o *SNVS_Type) GetHPSICR_SV4_EN() uint32 {
	return (volatile.LoadUint32(&o.HPSICR.Reg) & 0x10) >> 4
}
func (o *SNVS_Type) SetHPSICR_SV5_EN(value uint32) {
	volatile.StoreUint32(&o.HPSICR.Reg, volatile.LoadUint32(&o.HPSICR.Reg)&^(0x20)|value<<5)
}
func (o *SNVS_Type) GetHPSICR_SV5_EN() uint32 {
	return (volatile.LoadUint32(&o.HPSICR.Reg) & 0x20) >> 5
}
func (o *SNVS_Type) SetHPSICR_LPSVI_EN(value uint32) {
	volatile.StoreUint32(&o.HPSICR.Reg, volatile.LoadUint32(&o.HPSICR.Reg)&^(0x80000000)|value<<31)
}
func (o *SNVS_Type) GetHPSICR_LPSVI_EN() uint32 {
	return (volatile.LoadUint32(&o.HPSICR.Reg) & 0x80000000) >> 31
}

// SNVS.HPSVCR: SNVS_HP Security Violation Control Register
func (o *SNVS_Type) SetHPSVCR_SV0_CFG(value uint32) {
	volatile.StoreUint32(&o.HPSVCR.Reg, volatile.LoadUint32(&o.HPSVCR.Reg)&^(0x1)|value)
}
func (o *SNVS_Type) GetHPSVCR_SV0_CFG() uint32 {
	return volatile.LoadUint32(&o.HPSVCR.Reg) & 0x1
}
func (o *SNVS_Type) SetHPSVCR_SV1_CFG(value uint32) {
	volatile.StoreUint32(&o.HPSVCR.Reg, volatile.LoadUint32(&o.HPSVCR.Reg)&^(0x2)|value<<1)
}
func (o *SNVS_Type) GetHPSVCR_SV1_CFG() uint32 {
	return (volatile.LoadUint32(&o.HPSVCR.Reg) & 0x2) >> 1
}
func (o *SNVS_Type) SetHPSVCR_SV2_CFG(value uint32) {
	volatile.StoreUint32(&o.HPSVCR.Reg, volatile.LoadUint32(&o.HPSVCR.Reg)&^(0x4)|value<<2)
}
func (o *SNVS_Type) GetHPSVCR_SV2_CFG() uint32 {
	return (volatile.LoadUint32(&o.HPSVCR.Reg) & 0x4) >> 2
}
func (o *SNVS_Type) SetHPSVCR_SV3_CFG(value uint32) {
	volatile.StoreUint32(&o.HPSVCR.Reg, volatile.LoadUint32(&o.HPSVCR.Reg)&^(0x8)|value<<3)
}
func (o *SNVS_Type) GetHPSVCR_SV3_CFG() uint32 {
	return (volatile.LoadUint32(&o.HPSVCR.Reg) & 0x8) >> 3
}
func (o *SNVS_Type) SetHPSVCR_SV4_CFG(value uint32) {
	volatile.StoreUint32(&o.HPSVCR.Reg, volatile.LoadUint32(&o.HPSVCR.Reg)&^(0x10)|value<<4)
}
func (o *SNVS_Type) GetHPSVCR_SV4_CFG() uint32 {
	return (volatile.LoadUint32(&o.HPSVCR.Reg) & 0x10) >> 4
}
func (o *SNVS_Type) SetHPSVCR_SV5_CFG(value uint32) {
	volatile.StoreUint32(&o.HPSVCR.Reg, volatile.LoadUint32(&o.HPSVCR.Reg)&^(0x60)|value<<5)
}
func (o *SNVS_Type) GetHPSVCR_SV5_CFG() uint32 {
	return (volatile.LoadUint32(&o.HPSVCR.Reg) & 0x60) >> 5
}
func (o *SNVS_Type) SetHPSVCR_LPSV_CFG(value uint32) {
	volatile.StoreUint32(&o.HPSVCR.Reg, volatile.LoadUint32(&o.HPSVCR.Reg)&^(0xc0000000)|value<<30)
}
func (o *SNVS_Type) GetHPSVCR_LPSV_CFG() uint32 {
	return (volatile.LoadUint32(&o.HPSVCR.Reg) & 0xc0000000) >> 30
}

// SNVS.HPSR: SNVS_HP Status Register
func (o *SNVS_Type) SetHPSR_HPTA(value uint32) {
	volatile.StoreUint32(&o.HPSR.Reg, volatile.LoadUint32(&o.HPSR.Reg)&^(0x1)|value)
}
func (o *SNVS_Type) GetHPSR_HPTA() uint32 {
	return volatile.LoadUint32(&o.HPSR.Reg) & 0x1
}
func (o *SNVS_Type) SetHPSR_PI(value uint32) {
	volatile.StoreUint32(&o.HPSR.Reg, volatile.LoadUint32(&o.HPSR.Reg)&^(0x2)|value<<1)
}
func (o *SNVS_Type) GetHPSR_PI() uint32 {
	return (volatile.LoadUint32(&o.HPSR.Reg) & 0x2) >> 1
}
func (o *SNVS_Type) SetHPSR_LPDIS(value uint32) {
	volatile.StoreUint32(&o.HPSR.Reg, volatile.LoadUint32(&o.HPSR.Reg)&^(0x10)|value<<4)
}
func (o *SNVS_Type) GetHPSR_LPDIS() uint32 {
	return (volatile.LoadUint32(&o.HPSR.Reg) & 0x10) >> 4
}
func (o *SNVS_Type) SetHPSR_BTN(value uint32) {
	volatile.StoreUint32(&o.HPSR.Reg, volatile.LoadUint32(&o.HPSR.Reg)&^(0x40)|value<<6)
}
func (o *SNVS_Type) GetHPSR_BTN() uint32 {
	return (volatile.LoadUint32(&o.HPSR.Reg) & 0x40) >> 6
}
func (o *SNVS_Type) SetHPSR_BI(value uint32) {
	volatile.StoreUint32(&o.HPSR.Reg, volatile.LoadUint32(&o.HPSR.Reg)&^(0x80)|value<<7)
}
func (o *SNVS_Type) GetHPSR_BI() uint32 {
	return (volatile.LoadUint32(&o.HPSR.Reg) & 0x80) >> 7
}
func (o *SNVS_Type) SetHPSR_SSM_STATE(value uint32) {
	volatile.StoreUint32(&o.HPSR.Reg, volatile.LoadUint32(&o.HPSR.Reg)&^(0xf00)|value<<8)
}
func (o *SNVS_Type) GetHPSR_SSM_STATE() uint32 {
	return (volatile.LoadUint32(&o.HPSR.Reg) & 0xf00) >> 8
}
func (o *SNVS_Type) SetHPSR_SECURITY_CONFIG(value uint32) {
	volatile.StoreUint32(&o.HPSR.Reg, volatile.LoadUint32(&o.HPSR.Reg)&^(0xf000)|value<<12)
}
func (o *SNVS_Type) GetHPSR_SECURITY_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.HPSR.Reg) & 0xf000) >> 12
}
func (o *SNVS_Type) SetHPSR_OTPMK_SYNDROME(value uint32) {
	volatile.StoreUint32(&o.HPSR.Reg, volatile.LoadUint32(&o.HPSR.Reg)&^(0x1ff0000)|value<<16)
}
func (o *SNVS_Type) GetHPSR_OTPMK_SYNDROME() uint32 {
	return (volatile.LoadUint32(&o.HPSR.Reg) & 0x1ff0000) >> 16
}
func (o *SNVS_Type) SetHPSR_OTPMK_ZERO(value uint32) {
	volatile.StoreUint32(&o.HPSR.Reg, volatile.LoadUint32(&o.HPSR.Reg)&^(0x8000000)|value<<27)
}
func (o *SNVS_Type) GetHPSR_OTPMK_ZERO() uint32 {
	return (volatile.LoadUint32(&o.HPSR.Reg) & 0x8000000) >> 27
}
func (o *SNVS_Type) SetHPSR_ZMK_ZERO(value uint32) {
	volatile.StoreUint32(&o.HPSR.Reg, volatile.LoadUint32(&o.HPSR.Reg)&^(0x80000000)|value<<31)
}
func (o *SNVS_Type) GetHPSR_ZMK_ZERO() uint32 {
	return (volatile.LoadUint32(&o.HPSR.Reg) & 0x80000000) >> 31
}

// SNVS.HPSVSR: SNVS_HP Security Violation Status Register
func (o *SNVS_Type) SetHPSVSR_SV0(value uint32) {
	volatile.StoreUint32(&o.HPSVSR.Reg, volatile.LoadUint32(&o.HPSVSR.Reg)&^(0x1)|value)
}
func (o *SNVS_Type) GetHPSVSR_SV0() uint32 {
	return volatile.LoadUint32(&o.HPSVSR.Reg) & 0x1
}
func (o *SNVS_Type) SetHPSVSR_SV1(value uint32) {
	volatile.StoreUint32(&o.HPSVSR.Reg, volatile.LoadUint32(&o.HPSVSR.Reg)&^(0x2)|value<<1)
}
func (o *SNVS_Type) GetHPSVSR_SV1() uint32 {
	return (volatile.LoadUint32(&o.HPSVSR.Reg) & 0x2) >> 1
}
func (o *SNVS_Type) SetHPSVSR_SV2(value uint32) {
	volatile.StoreUint32(&o.HPSVSR.Reg, volatile.LoadUint32(&o.HPSVSR.Reg)&^(0x4)|value<<2)
}
func (o *SNVS_Type) GetHPSVSR_SV2() uint32 {
	return (volatile.LoadUint32(&o.HPSVSR.Reg) & 0x4) >> 2
}
func (o *SNVS_Type) SetHPSVSR_SV3(value uint32) {
	volatile.StoreUint32(&o.HPSVSR.Reg, volatile.LoadUint32(&o.HPSVSR.Reg)&^(0x8)|value<<3)
}
func (o *SNVS_Type) GetHPSVSR_SV3() uint32 {
	return (volatile.LoadUint32(&o.HPSVSR.Reg) & 0x8) >> 3
}
func (o *SNVS_Type) SetHPSVSR_SV4(value uint32) {
	volatile.StoreUint32(&o.HPSVSR.Reg, volatile.LoadUint32(&o.HPSVSR.Reg)&^(0x10)|value<<4)
}
func (o *SNVS_Type) GetHPSVSR_SV4() uint32 {
	return (volatile.LoadUint32(&o.HPSVSR.Reg) & 0x10) >> 4
}
func (o *SNVS_Type) SetHPSVSR_SV5(value uint32) {
	volatile.StoreUint32(&o.HPSVSR.Reg, volatile.LoadUint32(&o.HPSVSR.Reg)&^(0x20)|value<<5)
}
func (o *SNVS_Type) GetHPSVSR_SV5() uint32 {
	return (volatile.LoadUint32(&o.HPSVSR.Reg) & 0x20) >> 5
}
func (o *SNVS_Type) SetHPSVSR_SW_SV(value uint32) {
	volatile.StoreUint32(&o.HPSVSR.Reg, volatile.LoadUint32(&o.HPSVSR.Reg)&^(0x2000)|value<<13)
}
func (o *SNVS_Type) GetHPSVSR_SW_SV() uint32 {
	return (volatile.LoadUint32(&o.HPSVSR.Reg) & 0x2000) >> 13
}
func (o *SNVS_Type) SetHPSVSR_SW_FSV(value uint32) {
	volatile.StoreUint32(&o.HPSVSR.Reg, volatile.LoadUint32(&o.HPSVSR.Reg)&^(0x4000)|value<<14)
}
func (o *SNVS_Type) GetHPSVSR_SW_FSV() uint32 {
	return (volatile.LoadUint32(&o.HPSVSR.Reg) & 0x4000) >> 14
}
func (o *SNVS_Type) SetHPSVSR_SW_LPSV(value uint32) {
	volatile.StoreUint32(&o.HPSVSR.Reg, volatile.LoadUint32(&o.HPSVSR.Reg)&^(0x8000)|value<<15)
}
func (o *SNVS_Type) GetHPSVSR_SW_LPSV() uint32 {
	return (volatile.LoadUint32(&o.HPSVSR.Reg) & 0x8000) >> 15
}
func (o *SNVS_Type) SetHPSVSR_ZMK_SYNDROME(value uint32) {
	volatile.StoreUint32(&o.HPSVSR.Reg, volatile.LoadUint32(&o.HPSVSR.Reg)&^(0x1ff0000)|value<<16)
}
func (o *SNVS_Type) GetHPSVSR_ZMK_SYNDROME() uint32 {
	return (volatile.LoadUint32(&o.HPSVSR.Reg) & 0x1ff0000) >> 16
}
func (o *SNVS_Type) SetHPSVSR_ZMK_ECC_FAIL(value uint32) {
	volatile.StoreUint32(&o.HPSVSR.Reg, volatile.LoadUint32(&o.HPSVSR.Reg)&^(0x8000000)|value<<27)
}
func (o *SNVS_Type) GetHPSVSR_ZMK_ECC_FAIL() uint32 {
	return (volatile.LoadUint32(&o.HPSVSR.Reg) & 0x8000000) >> 27
}
func (o *SNVS_Type) SetHPSVSR_LP_SEC_VIO(value uint32) {
	volatile.StoreUint32(&o.HPSVSR.Reg, volatile.LoadUint32(&o.HPSVSR.Reg)&^(0x80000000)|value<<31)
}
func (o *SNVS_Type) GetHPSVSR_LP_SEC_VIO() uint32 {
	return (volatile.LoadUint32(&o.HPSVSR.Reg) & 0x80000000) >> 31
}

// SNVS.HPHACIVR: SNVS_HP High Assurance Counter IV Register
func (o *SNVS_Type) SetHPHACIVR(value uint32) {
	volatile.StoreUint32(&o.HPHACIVR.Reg, value)
}
func (o *SNVS_Type) GetHPHACIVR() uint32 {
	return volatile.LoadUint32(&o.HPHACIVR.Reg)
}

// SNVS.HPHACR: SNVS_HP High Assurance Counter Register
func (o *SNVS_Type) SetHPHACR(value uint32) {
	volatile.StoreUint32(&o.HPHACR.Reg, value)
}
func (o *SNVS_Type) GetHPHACR() uint32 {
	return volatile.LoadUint32(&o.HPHACR.Reg)
}

// SNVS.HPRTCMR: SNVS_HP Real Time Counter MSB Register
func (o *SNVS_Type) SetHPRTCMR_RTC(value uint32) {
	volatile.StoreUint32(&o.HPRTCMR.Reg, volatile.LoadUint32(&o.HPRTCMR.Reg)&^(0x7fff)|value)
}
func (o *SNVS_Type) GetHPRTCMR_RTC() uint32 {
	return volatile.LoadUint32(&o.HPRTCMR.Reg) & 0x7fff
}

// SNVS.HPRTCLR: SNVS_HP Real Time Counter LSB Register
func (o *SNVS_Type) SetHPRTCLR(value uint32) {
	volatile.StoreUint32(&o.HPRTCLR.Reg, value)
}
func (o *SNVS_Type) GetHPRTCLR() uint32 {
	return volatile.LoadUint32(&o.HPRTCLR.Reg)
}

// SNVS.HPTAMR: SNVS_HP Time Alarm MSB Register
func (o *SNVS_Type) SetHPTAMR_HPTA_MS(value uint32) {
	volatile.StoreUint32(&o.HPTAMR.Reg, volatile.LoadUint32(&o.HPTAMR.Reg)&^(0x7fff)|value)
}
func (o *SNVS_Type) GetHPTAMR_HPTA_MS() uint32 {
	return volatile.LoadUint32(&o.HPTAMR.Reg) & 0x7fff
}

// SNVS.HPTALR: SNVS_HP Time Alarm LSB Register
func (o *SNVS_Type) SetHPTALR(value uint32) {
	volatile.StoreUint32(&o.HPTALR.Reg, value)
}
func (o *SNVS_Type) GetHPTALR() uint32 {
	return volatile.LoadUint32(&o.HPTALR.Reg)
}

// SNVS.LPLR: SNVS_LP Lock Register
func (o *SNVS_Type) SetLPLR_ZMK_WHL(value uint32) {
	volatile.StoreUint32(&o.LPLR.Reg, volatile.LoadUint32(&o.LPLR.Reg)&^(0x1)|value)
}
func (o *SNVS_Type) GetLPLR_ZMK_WHL() uint32 {
	return volatile.LoadUint32(&o.LPLR.Reg) & 0x1
}
func (o *SNVS_Type) SetLPLR_ZMK_RHL(value uint32) {
	volatile.StoreUint32(&o.LPLR.Reg, volatile.LoadUint32(&o.LPLR.Reg)&^(0x2)|value<<1)
}
func (o *SNVS_Type) GetLPLR_ZMK_RHL() uint32 {
	return (volatile.LoadUint32(&o.LPLR.Reg) & 0x2) >> 1
}
func (o *SNVS_Type) SetLPLR_SRTC_HL(value uint32) {
	volatile.StoreUint32(&o.LPLR.Reg, volatile.LoadUint32(&o.LPLR.Reg)&^(0x4)|value<<2)
}
func (o *SNVS_Type) GetLPLR_SRTC_HL() uint32 {
	return (volatile.LoadUint32(&o.LPLR.Reg) & 0x4) >> 2
}
func (o *SNVS_Type) SetLPLR_LPCALB_HL(value uint32) {
	volatile.StoreUint32(&o.LPLR.Reg, volatile.LoadUint32(&o.LPLR.Reg)&^(0x8)|value<<3)
}
func (o *SNVS_Type) GetLPLR_LPCALB_HL() uint32 {
	return (volatile.LoadUint32(&o.LPLR.Reg) & 0x8) >> 3
}
func (o *SNVS_Type) SetLPLR_MC_HL(value uint32) {
	volatile.StoreUint32(&o.LPLR.Reg, volatile.LoadUint32(&o.LPLR.Reg)&^(0x10)|value<<4)
}
func (o *SNVS_Type) GetLPLR_MC_HL() uint32 {
	return (volatile.LoadUint32(&o.LPLR.Reg) & 0x10) >> 4
}
func (o *SNVS_Type) SetLPLR_GPR_HL(value uint32) {
	volatile.StoreUint32(&o.LPLR.Reg, volatile.LoadUint32(&o.LPLR.Reg)&^(0x20)|value<<5)
}
func (o *SNVS_Type) GetLPLR_GPR_HL() uint32 {
	return (volatile.LoadUint32(&o.LPLR.Reg) & 0x20) >> 5
}
func (o *SNVS_Type) SetLPLR_LPSVCR_HL(value uint32) {
	volatile.StoreUint32(&o.LPLR.Reg, volatile.LoadUint32(&o.LPLR.Reg)&^(0x40)|value<<6)
}
func (o *SNVS_Type) GetLPLR_LPSVCR_HL() uint32 {
	return (volatile.LoadUint32(&o.LPLR.Reg) & 0x40) >> 6
}
func (o *SNVS_Type) SetLPLR_LPTDCR_HL(value uint32) {
	volatile.StoreUint32(&o.LPLR.Reg, volatile.LoadUint32(&o.LPLR.Reg)&^(0x100)|value<<8)
}
func (o *SNVS_Type) GetLPLR_LPTDCR_HL() uint32 {
	return (volatile.LoadUint32(&o.LPLR.Reg) & 0x100) >> 8
}
func (o *SNVS_Type) SetLPLR_MKS_HL(value uint32) {
	volatile.StoreUint32(&o.LPLR.Reg, volatile.LoadUint32(&o.LPLR.Reg)&^(0x200)|value<<9)
}
func (o *SNVS_Type) GetLPLR_MKS_HL() uint32 {
	return (volatile.LoadUint32(&o.LPLR.Reg) & 0x200) >> 9
}

// SNVS.LPCR: SNVS_LP Control Register
func (o *SNVS_Type) SetLPCR_SRTC_ENV(value uint32) {
	volatile.StoreUint32(&o.LPCR.Reg, volatile.LoadUint32(&o.LPCR.Reg)&^(0x1)|value)
}
func (o *SNVS_Type) GetLPCR_SRTC_ENV() uint32 {
	return volatile.LoadUint32(&o.LPCR.Reg) & 0x1
}
func (o *SNVS_Type) SetLPCR_LPTA_EN(value uint32) {
	volatile.StoreUint32(&o.LPCR.Reg, volatile.LoadUint32(&o.LPCR.Reg)&^(0x2)|value<<1)
}
func (o *SNVS_Type) GetLPCR_LPTA_EN() uint32 {
	return (volatile.LoadUint32(&o.LPCR.Reg) & 0x2) >> 1
}
func (o *SNVS_Type) SetLPCR_MC_ENV(value uint32) {
	volatile.StoreUint32(&o.LPCR.Reg, volatile.LoadUint32(&o.LPCR.Reg)&^(0x4)|value<<2)
}
func (o *SNVS_Type) GetLPCR_MC_ENV() uint32 {
	return (volatile.LoadUint32(&o.LPCR.Reg) & 0x4) >> 2
}
func (o *SNVS_Type) SetLPCR_LPWUI_EN(value uint32) {
	volatile.StoreUint32(&o.LPCR.Reg, volatile.LoadUint32(&o.LPCR.Reg)&^(0x8)|value<<3)
}
func (o *SNVS_Type) GetLPCR_LPWUI_EN() uint32 {
	return (volatile.LoadUint32(&o.LPCR.Reg) & 0x8) >> 3
}
func (o *SNVS_Type) SetLPCR_SRTC_INV_EN(value uint32) {
	volatile.StoreUint32(&o.LPCR.Reg, volatile.LoadUint32(&o.LPCR.Reg)&^(0x10)|value<<4)
}
func (o *SNVS_Type) GetLPCR_SRTC_INV_EN() uint32 {
	return (volatile.LoadUint32(&o.LPCR.Reg) & 0x10) >> 4
}
func (o *SNVS_Type) SetLPCR_DP_EN(value uint32) {
	volatile.StoreUint32(&o.LPCR.Reg, volatile.LoadUint32(&o.LPCR.Reg)&^(0x20)|value<<5)
}
func (o *SNVS_Type) GetLPCR_DP_EN() uint32 {
	return (volatile.LoadUint32(&o.LPCR.Reg) & 0x20) >> 5
}
func (o *SNVS_Type) SetLPCR_TOP(value uint32) {
	volatile.StoreUint32(&o.LPCR.Reg, volatile.LoadUint32(&o.LPCR.Reg)&^(0x40)|value<<6)
}
func (o *SNVS_Type) GetLPCR_TOP() uint32 {
	return (volatile.LoadUint32(&o.LPCR.Reg) & 0x40) >> 6
}
func (o *SNVS_Type) SetLPCR_PWR_GLITCH_EN(value uint32) {
	volatile.StoreUint32(&o.LPCR.Reg, volatile.LoadUint32(&o.LPCR.Reg)&^(0x80)|value<<7)
}
func (o *SNVS_Type) GetLPCR_PWR_GLITCH_EN() uint32 {
	return (volatile.LoadUint32(&o.LPCR.Reg) & 0x80) >> 7
}
func (o *SNVS_Type) SetLPCR_LPCALB_EN(value uint32) {
	volatile.StoreUint32(&o.LPCR.Reg, volatile.LoadUint32(&o.LPCR.Reg)&^(0x100)|value<<8)
}
func (o *SNVS_Type) GetLPCR_LPCALB_EN() uint32 {
	return (volatile.LoadUint32(&o.LPCR.Reg) & 0x100) >> 8
}
func (o *SNVS_Type) SetLPCR_LPCALB_VAL(value uint32) {
	volatile.StoreUint32(&o.LPCR.Reg, volatile.LoadUint32(&o.LPCR.Reg)&^(0x7c00)|value<<10)
}
func (o *SNVS_Type) GetLPCR_LPCALB_VAL() uint32 {
	return (volatile.LoadUint32(&o.LPCR.Reg) & 0x7c00) >> 10
}
func (o *SNVS_Type) SetLPCR_BTN_PRESS_TIME(value uint32) {
	volatile.StoreUint32(&o.LPCR.Reg, volatile.LoadUint32(&o.LPCR.Reg)&^(0x30000)|value<<16)
}
func (o *SNVS_Type) GetLPCR_BTN_PRESS_TIME() uint32 {
	return (volatile.LoadUint32(&o.LPCR.Reg) & 0x30000) >> 16
}
func (o *SNVS_Type) SetLPCR_DEBOUNCE(value uint32) {
	volatile.StoreUint32(&o.LPCR.Reg, volatile.LoadUint32(&o.LPCR.Reg)&^(0xc0000)|value<<18)
}
func (o *SNVS_Type) GetLPCR_DEBOUNCE() uint32 {
	return (volatile.LoadUint32(&o.LPCR.Reg) & 0xc0000) >> 18
}
func (o *SNVS_Type) SetLPCR_ON_TIME(value uint32) {
	volatile.StoreUint32(&o.LPCR.Reg, volatile.LoadUint32(&o.LPCR.Reg)&^(0x300000)|value<<20)
}
func (o *SNVS_Type) GetLPCR_ON_TIME() uint32 {
	return (volatile.LoadUint32(&o.LPCR.Reg) & 0x300000) >> 20
}
func (o *SNVS_Type) SetLPCR_PK_EN(value uint32) {
	volatile.StoreUint32(&o.LPCR.Reg, volatile.LoadUint32(&o.LPCR.Reg)&^(0x400000)|value<<22)
}
func (o *SNVS_Type) GetLPCR_PK_EN() uint32 {
	return (volatile.LoadUint32(&o.LPCR.Reg) & 0x400000) >> 22
}
func (o *SNVS_Type) SetLPCR_PK_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.LPCR.Reg, volatile.LoadUint32(&o.LPCR.Reg)&^(0x800000)|value<<23)
}
func (o *SNVS_Type) GetLPCR_PK_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.LPCR.Reg) & 0x800000) >> 23
}
func (o *SNVS_Type) SetLPCR_GPR_Z_DIS(value uint32) {
	volatile.StoreUint32(&o.LPCR.Reg, volatile.LoadUint32(&o.LPCR.Reg)&^(0x1000000)|value<<24)
}
func (o *SNVS_Type) GetLPCR_GPR_Z_DIS() uint32 {
	return (volatile.LoadUint32(&o.LPCR.Reg) & 0x1000000) >> 24
}

// SNVS.LPMKCR: SNVS_LP Master Key Control Register
func (o *SNVS_Type) SetLPMKCR_MASTER_KEY_SEL(value uint32) {
	volatile.StoreUint32(&o.LPMKCR.Reg, volatile.LoadUint32(&o.LPMKCR.Reg)&^(0x3)|value)
}
func (o *SNVS_Type) GetLPMKCR_MASTER_KEY_SEL() uint32 {
	return volatile.LoadUint32(&o.LPMKCR.Reg) & 0x3
}
func (o *SNVS_Type) SetLPMKCR_ZMK_HWP(value uint32) {
	volatile.StoreUint32(&o.LPMKCR.Reg, volatile.LoadUint32(&o.LPMKCR.Reg)&^(0x4)|value<<2)
}
func (o *SNVS_Type) GetLPMKCR_ZMK_HWP() uint32 {
	return (volatile.LoadUint32(&o.LPMKCR.Reg) & 0x4) >> 2
}
func (o *SNVS_Type) SetLPMKCR_ZMK_VAL(value uint32) {
	volatile.StoreUint32(&o.LPMKCR.Reg, volatile.LoadUint32(&o.LPMKCR.Reg)&^(0x8)|value<<3)
}
func (o *SNVS_Type) GetLPMKCR_ZMK_VAL() uint32 {
	return (volatile.LoadUint32(&o.LPMKCR.Reg) & 0x8) >> 3
}
func (o *SNVS_Type) SetLPMKCR_ZMK_ECC_EN(value uint32) {
	volatile.StoreUint32(&o.LPMKCR.Reg, volatile.LoadUint32(&o.LPMKCR.Reg)&^(0x10)|value<<4)
}
func (o *SNVS_Type) GetLPMKCR_ZMK_ECC_EN() uint32 {
	return (volatile.LoadUint32(&o.LPMKCR.Reg) & 0x10) >> 4
}
func (o *SNVS_Type) SetLPMKCR_ZMK_ECC_VALUE(value uint32) {
	volatile.StoreUint32(&o.LPMKCR.Reg, volatile.LoadUint32(&o.LPMKCR.Reg)&^(0xff80)|value<<7)
}
func (o *SNVS_Type) GetLPMKCR_ZMK_ECC_VALUE() uint32 {
	return (volatile.LoadUint32(&o.LPMKCR.Reg) & 0xff80) >> 7
}

// SNVS.LPSVCR: SNVS_LP Security Violation Control Register
func (o *SNVS_Type) SetLPSVCR_SV0_EN(value uint32) {
	volatile.StoreUint32(&o.LPSVCR.Reg, volatile.LoadUint32(&o.LPSVCR.Reg)&^(0x1)|value)
}
func (o *SNVS_Type) GetLPSVCR_SV0_EN() uint32 {
	return volatile.LoadUint32(&o.LPSVCR.Reg) & 0x1
}
func (o *SNVS_Type) SetLPSVCR_SV1_EN(value uint32) {
	volatile.StoreUint32(&o.LPSVCR.Reg, volatile.LoadUint32(&o.LPSVCR.Reg)&^(0x2)|value<<1)
}
func (o *SNVS_Type) GetLPSVCR_SV1_EN() uint32 {
	return (volatile.LoadUint32(&o.LPSVCR.Reg) & 0x2) >> 1
}
func (o *SNVS_Type) SetLPSVCR_SV2_EN(value uint32) {
	volatile.StoreUint32(&o.LPSVCR.Reg, volatile.LoadUint32(&o.LPSVCR.Reg)&^(0x4)|value<<2)
}
func (o *SNVS_Type) GetLPSVCR_SV2_EN() uint32 {
	return (volatile.LoadUint32(&o.LPSVCR.Reg) & 0x4) >> 2
}
func (o *SNVS_Type) SetLPSVCR_SV3_EN(value uint32) {
	volatile.StoreUint32(&o.LPSVCR.Reg, volatile.LoadUint32(&o.LPSVCR.Reg)&^(0x8)|value<<3)
}
func (o *SNVS_Type) GetLPSVCR_SV3_EN() uint32 {
	return (volatile.LoadUint32(&o.LPSVCR.Reg) & 0x8) >> 3
}
func (o *SNVS_Type) SetLPSVCR_SV4_EN(value uint32) {
	volatile.StoreUint32(&o.LPSVCR.Reg, volatile.LoadUint32(&o.LPSVCR.Reg)&^(0x10)|value<<4)
}
func (o *SNVS_Type) GetLPSVCR_SV4_EN() uint32 {
	return (volatile.LoadUint32(&o.LPSVCR.Reg) & 0x10) >> 4
}
func (o *SNVS_Type) SetLPSVCR_SV5_EN(value uint32) {
	volatile.StoreUint32(&o.LPSVCR.Reg, volatile.LoadUint32(&o.LPSVCR.Reg)&^(0x20)|value<<5)
}
func (o *SNVS_Type) GetLPSVCR_SV5_EN() uint32 {
	return (volatile.LoadUint32(&o.LPSVCR.Reg) & 0x20) >> 5
}

// SNVS.LPTDCR: SNVS_LP Tamper Detectors Configuration Register
func (o *SNVS_Type) SetLPTDCR_SRTCR_EN(value uint32) {
	volatile.StoreUint32(&o.LPTDCR.Reg, volatile.LoadUint32(&o.LPTDCR.Reg)&^(0x2)|value<<1)
}
func (o *SNVS_Type) GetLPTDCR_SRTCR_EN() uint32 {
	return (volatile.LoadUint32(&o.LPTDCR.Reg) & 0x2) >> 1
}
func (o *SNVS_Type) SetLPTDCR_MCR_EN(value uint32) {
	volatile.StoreUint32(&o.LPTDCR.Reg, volatile.LoadUint32(&o.LPTDCR.Reg)&^(0x4)|value<<2)
}
func (o *SNVS_Type) GetLPTDCR_MCR_EN() uint32 {
	return (volatile.LoadUint32(&o.LPTDCR.Reg) & 0x4) >> 2
}
func (o *SNVS_Type) SetLPTDCR_ET1_EN(value uint32) {
	volatile.StoreUint32(&o.LPTDCR.Reg, volatile.LoadUint32(&o.LPTDCR.Reg)&^(0x200)|value<<9)
}
func (o *SNVS_Type) GetLPTDCR_ET1_EN() uint32 {
	return (volatile.LoadUint32(&o.LPTDCR.Reg) & 0x200) >> 9
}
func (o *SNVS_Type) SetLPTDCR_ET1P(value uint32) {
	volatile.StoreUint32(&o.LPTDCR.Reg, volatile.LoadUint32(&o.LPTDCR.Reg)&^(0x800)|value<<11)
}
func (o *SNVS_Type) GetLPTDCR_ET1P() uint32 {
	return (volatile.LoadUint32(&o.LPTDCR.Reg) & 0x800) >> 11
}
func (o *SNVS_Type) SetLPTDCR_PFD_OBSERV(value uint32) {
	volatile.StoreUint32(&o.LPTDCR.Reg, volatile.LoadUint32(&o.LPTDCR.Reg)&^(0x4000)|value<<14)
}
func (o *SNVS_Type) GetLPTDCR_PFD_OBSERV() uint32 {
	return (volatile.LoadUint32(&o.LPTDCR.Reg) & 0x4000) >> 14
}
func (o *SNVS_Type) SetLPTDCR_POR_OBSERV(value uint32) {
	volatile.StoreUint32(&o.LPTDCR.Reg, volatile.LoadUint32(&o.LPTDCR.Reg)&^(0x8000)|value<<15)
}
func (o *SNVS_Type) GetLPTDCR_POR_OBSERV() uint32 {
	return (volatile.LoadUint32(&o.LPTDCR.Reg) & 0x8000) >> 15
}
func (o *SNVS_Type) SetLPTDCR_OSCB(value uint32) {
	volatile.StoreUint32(&o.LPTDCR.Reg, volatile.LoadUint32(&o.LPTDCR.Reg)&^(0x10000000)|value<<28)
}
func (o *SNVS_Type) GetLPTDCR_OSCB() uint32 {
	return (volatile.LoadUint32(&o.LPTDCR.Reg) & 0x10000000) >> 28
}

// SNVS.LPSR: SNVS_LP Status Register
func (o *SNVS_Type) SetLPSR_LPTA(value uint32) {
	volatile.StoreUint32(&o.LPSR.Reg, volatile.LoadUint32(&o.LPSR.Reg)&^(0x1)|value)
}
func (o *SNVS_Type) GetLPSR_LPTA() uint32 {
	return volatile.LoadUint32(&o.LPSR.Reg) & 0x1
}
func (o *SNVS_Type) SetLPSR_SRTCR(value uint32) {
	volatile.StoreUint32(&o.LPSR.Reg, volatile.LoadUint32(&o.LPSR.Reg)&^(0x2)|value<<1)
}
func (o *SNVS_Type) GetLPSR_SRTCR() uint32 {
	return (volatile.LoadUint32(&o.LPSR.Reg) & 0x2) >> 1
}
func (o *SNVS_Type) SetLPSR_MCR(value uint32) {
	volatile.StoreUint32(&o.LPSR.Reg, volatile.LoadUint32(&o.LPSR.Reg)&^(0x4)|value<<2)
}
func (o *SNVS_Type) GetLPSR_MCR() uint32 {
	return (volatile.LoadUint32(&o.LPSR.Reg) & 0x4) >> 2
}
func (o *SNVS_Type) SetLPSR_PGD(value uint32) {
	volatile.StoreUint32(&o.LPSR.Reg, volatile.LoadUint32(&o.LPSR.Reg)&^(0x8)|value<<3)
}
func (o *SNVS_Type) GetLPSR_PGD() uint32 {
	return (volatile.LoadUint32(&o.LPSR.Reg) & 0x8) >> 3
}
func (o *SNVS_Type) SetLPSR_ET1D(value uint32) {
	volatile.StoreUint32(&o.LPSR.Reg, volatile.LoadUint32(&o.LPSR.Reg)&^(0x200)|value<<9)
}
func (o *SNVS_Type) GetLPSR_ET1D() uint32 {
	return (volatile.LoadUint32(&o.LPSR.Reg) & 0x200) >> 9
}
func (o *SNVS_Type) SetLPSR_ESVD(value uint32) {
	volatile.StoreUint32(&o.LPSR.Reg, volatile.LoadUint32(&o.LPSR.Reg)&^(0x10000)|value<<16)
}
func (o *SNVS_Type) GetLPSR_ESVD() uint32 {
	return (volatile.LoadUint32(&o.LPSR.Reg) & 0x10000) >> 16
}
func (o *SNVS_Type) SetLPSR_EO(value uint32) {
	volatile.StoreUint32(&o.LPSR.Reg, volatile.LoadUint32(&o.LPSR.Reg)&^(0x20000)|value<<17)
}
func (o *SNVS_Type) GetLPSR_EO() uint32 {
	return (volatile.LoadUint32(&o.LPSR.Reg) & 0x20000) >> 17
}
func (o *SNVS_Type) SetLPSR_SPO(value uint32) {
	volatile.StoreUint32(&o.LPSR.Reg, volatile.LoadUint32(&o.LPSR.Reg)&^(0x40000)|value<<18)
}
func (o *SNVS_Type) GetLPSR_SPO() uint32 {
	return (volatile.LoadUint32(&o.LPSR.Reg) & 0x40000) >> 18
}
func (o *SNVS_Type) SetLPSR_SED(value uint32) {
	volatile.StoreUint32(&o.LPSR.Reg, volatile.LoadUint32(&o.LPSR.Reg)&^(0x100000)|value<<20)
}
func (o *SNVS_Type) GetLPSR_SED() uint32 {
	return (volatile.LoadUint32(&o.LPSR.Reg) & 0x100000) >> 20
}
func (o *SNVS_Type) SetLPSR_LPNS(value uint32) {
	volatile.StoreUint32(&o.LPSR.Reg, volatile.LoadUint32(&o.LPSR.Reg)&^(0x40000000)|value<<30)
}
func (o *SNVS_Type) GetLPSR_LPNS() uint32 {
	return (volatile.LoadUint32(&o.LPSR.Reg) & 0x40000000) >> 30
}
func (o *SNVS_Type) SetLPSR_LPS(value uint32) {
	volatile.StoreUint32(&o.LPSR.Reg, volatile.LoadUint32(&o.LPSR.Reg)&^(0x80000000)|value<<31)
}
func (o *SNVS_Type) GetLPSR_LPS() uint32 {
	return (volatile.LoadUint32(&o.LPSR.Reg) & 0x80000000) >> 31
}

// SNVS.LPSRTCMR: SNVS_LP Secure Real Time Counter MSB Register
func (o *SNVS_Type) SetLPSRTCMR_SRTC(value uint32) {
	volatile.StoreUint32(&o.LPSRTCMR.Reg, volatile.LoadUint32(&o.LPSRTCMR.Reg)&^(0x7fff)|value)
}
func (o *SNVS_Type) GetLPSRTCMR_SRTC() uint32 {
	return volatile.LoadUint32(&o.LPSRTCMR.Reg) & 0x7fff
}

// SNVS.LPSRTCLR: SNVS_LP Secure Real Time Counter LSB Register
func (o *SNVS_Type) SetLPSRTCLR(value uint32) {
	volatile.StoreUint32(&o.LPSRTCLR.Reg, value)
}
func (o *SNVS_Type) GetLPSRTCLR() uint32 {
	return volatile.LoadUint32(&o.LPSRTCLR.Reg)
}

// SNVS.LPTAR: SNVS_LP Time Alarm Register
func (o *SNVS_Type) SetLPTAR(value uint32) {
	volatile.StoreUint32(&o.LPTAR.Reg, value)
}
func (o *SNVS_Type) GetLPTAR() uint32 {
	return volatile.LoadUint32(&o.LPTAR.Reg)
}

// SNVS.LPSMCMR: SNVS_LP Secure Monotonic Counter MSB Register
func (o *SNVS_Type) SetLPSMCMR_MON_COUNTER(value uint32) {
	volatile.StoreUint32(&o.LPSMCMR.Reg, volatile.LoadUint32(&o.LPSMCMR.Reg)&^(0xffff)|value)
}
func (o *SNVS_Type) GetLPSMCMR_MON_COUNTER() uint32 {
	return volatile.LoadUint32(&o.LPSMCMR.Reg) & 0xffff
}
func (o *SNVS_Type) SetLPSMCMR_MC_ERA_BITS(value uint32) {
	volatile.StoreUint32(&o.LPSMCMR.Reg, volatile.LoadUint32(&o.LPSMCMR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SNVS_Type) GetLPSMCMR_MC_ERA_BITS() uint32 {
	return (volatile.LoadUint32(&o.LPSMCMR.Reg) & 0xffff0000) >> 16
}

// SNVS.LPSMCLR: SNVS_LP Secure Monotonic Counter LSB Register
func (o *SNVS_Type) SetLPSMCLR(value uint32) {
	volatile.StoreUint32(&o.LPSMCLR.Reg, value)
}
func (o *SNVS_Type) GetLPSMCLR() uint32 {
	return volatile.LoadUint32(&o.LPSMCLR.Reg)
}

// SNVS.LPPGDR: SNVS_LP Power Glitch Detector Register
func (o *SNVS_Type) SetLPPGDR(value uint32) {
	volatile.StoreUint32(&o.LPPGDR.Reg, value)
}
func (o *SNVS_Type) GetLPPGDR() uint32 {
	return volatile.LoadUint32(&o.LPPGDR.Reg)
}

// SNVS.LPGPR0_legacy_alias: SNVS_LP General Purpose Register 0 (legacy alias)
func (o *SNVS_Type) SetLPGPR0_legacy_alias(value uint32) {
	volatile.StoreUint32(&o.LPGPR0_legacy_alias.Reg, value)
}
func (o *SNVS_Type) GetLPGPR0_legacy_alias() uint32 {
	return volatile.LoadUint32(&o.LPGPR0_legacy_alias.Reg)
}

// SNVS.LPZMKR: SNVS_LP Zeroizable Master Key Register
func (o *SNVS_Type) SetLPZMKR(idx int, value uint32) {
	volatile.StoreUint32(&o.LPZMKR[idx].Reg, value)
}
func (o *SNVS_Type) GetLPZMKR(idx int) uint32 {
	return volatile.LoadUint32(&o.LPZMKR[idx].Reg)
}

// SNVS.LPGPR_alias: SNVS_LP General Purpose Registers 0 .. 3
func (o *SNVS_Type) SetLPGPR_alias(idx int, value uint32) {
	volatile.StoreUint32(&o.LPGPR_alias[idx].Reg, value)
}
func (o *SNVS_Type) GetLPGPR_alias(idx int) uint32 {
	return volatile.LoadUint32(&o.LPGPR_alias[idx].Reg)
}

// SNVS.LPGPR: SNVS_LP General Purpose Registers 0 .. 3
func (o *SNVS_Type) SetLPGPR(idx int, value uint32) {
	volatile.StoreUint32(&o.LPGPR[idx].Reg, value)
}
func (o *SNVS_Type) GetLPGPR(idx int) uint32 {
	return volatile.LoadUint32(&o.LPGPR[idx].Reg)
}

// SNVS.HPVIDR1: SNVS_HP Version ID Register 1
func (o *SNVS_Type) SetHPVIDR1_MINOR_REV(value uint32) {
	volatile.StoreUint32(&o.HPVIDR1.Reg, volatile.LoadUint32(&o.HPVIDR1.Reg)&^(0xff)|value)
}
func (o *SNVS_Type) GetHPVIDR1_MINOR_REV() uint32 {
	return volatile.LoadUint32(&o.HPVIDR1.Reg) & 0xff
}
func (o *SNVS_Type) SetHPVIDR1_MAJOR_REV(value uint32) {
	volatile.StoreUint32(&o.HPVIDR1.Reg, volatile.LoadUint32(&o.HPVIDR1.Reg)&^(0xff00)|value<<8)
}
func (o *SNVS_Type) GetHPVIDR1_MAJOR_REV() uint32 {
	return (volatile.LoadUint32(&o.HPVIDR1.Reg) & 0xff00) >> 8
}
func (o *SNVS_Type) SetHPVIDR1_IP_ID(value uint32) {
	volatile.StoreUint32(&o.HPVIDR1.Reg, volatile.LoadUint32(&o.HPVIDR1.Reg)&^(0xffff0000)|value<<16)
}
func (o *SNVS_Type) GetHPVIDR1_IP_ID() uint32 {
	return (volatile.LoadUint32(&o.HPVIDR1.Reg) & 0xffff0000) >> 16
}

// SNVS.HPVIDR2: SNVS_HP Version ID Register 2
func (o *SNVS_Type) SetHPVIDR2_CONFIG_OPT(value uint32) {
	volatile.StoreUint32(&o.HPVIDR2.Reg, volatile.LoadUint32(&o.HPVIDR2.Reg)&^(0xff)|value)
}
func (o *SNVS_Type) GetHPVIDR2_CONFIG_OPT() uint32 {
	return volatile.LoadUint32(&o.HPVIDR2.Reg) & 0xff
}
func (o *SNVS_Type) SetHPVIDR2_ECO_REV(value uint32) {
	volatile.StoreUint32(&o.HPVIDR2.Reg, volatile.LoadUint32(&o.HPVIDR2.Reg)&^(0xff00)|value<<8)
}
func (o *SNVS_Type) GetHPVIDR2_ECO_REV() uint32 {
	return (volatile.LoadUint32(&o.HPVIDR2.Reg) & 0xff00) >> 8
}
func (o *SNVS_Type) SetHPVIDR2_INTG_OPT(value uint32) {
	volatile.StoreUint32(&o.HPVIDR2.Reg, volatile.LoadUint32(&o.HPVIDR2.Reg)&^(0xff0000)|value<<16)
}
func (o *SNVS_Type) GetHPVIDR2_INTG_OPT() uint32 {
	return (volatile.LoadUint32(&o.HPVIDR2.Reg) & 0xff0000) >> 16
}
func (o *SNVS_Type) SetHPVIDR2_IP_ERA(value uint32) {
	volatile.StoreUint32(&o.HPVIDR2.Reg, volatile.LoadUint32(&o.HPVIDR2.Reg)&^(0xff000000)|value<<24)
}
func (o *SNVS_Type) GetHPVIDR2_IP_ERA() uint32 {
	return (volatile.LoadUint32(&o.HPVIDR2.Reg) & 0xff000000) >> 24
}

// CCM_ANALOG
type CCM_ANALOG_Type struct {
	_               [16]byte
	PLL_USB1        volatile.Register32 // 0x10
	PLL_USB1_SET    volatile.Register32 // 0x14
	PLL_USB1_CLR    volatile.Register32 // 0x18
	PLL_USB1_TOG    volatile.Register32 // 0x1C
	_               [16]byte
	PLL_SYS         volatile.Register32 // 0x30
	PLL_SYS_SET     volatile.Register32 // 0x34
	PLL_SYS_CLR     volatile.Register32 // 0x38
	PLL_SYS_TOG     volatile.Register32 // 0x3C
	PLL_SYS_SS      volatile.Register32 // 0x40
	_               [12]byte
	PLL_SYS_NUM     volatile.Register32 // 0x50
	_               [12]byte
	PLL_SYS_DENOM   volatile.Register32 // 0x60
	_               [12]byte
	PLL_AUDIO       volatile.Register32 // 0x70
	PLL_AUDIO_SET   volatile.Register32 // 0x74
	PLL_AUDIO_CLR   volatile.Register32 // 0x78
	PLL_AUDIO_TOG   volatile.Register32 // 0x7C
	PLL_AUDIO_NUM   volatile.Register32 // 0x80
	_               [12]byte
	PLL_AUDIO_DENOM volatile.Register32 // 0x90
	_               [76]byte
	PLL_ENET        volatile.Register32 // 0xE0
	PLL_ENET_SET    volatile.Register32 // 0xE4
	PLL_ENET_CLR    volatile.Register32 // 0xE8
	PLL_ENET_TOG    volatile.Register32 // 0xEC
	PFD_480         volatile.Register32 // 0xF0
	PFD_480_SET     volatile.Register32 // 0xF4
	PFD_480_CLR     volatile.Register32 // 0xF8
	PFD_480_TOG     volatile.Register32 // 0xFC
	PFD_528         volatile.Register32 // 0x100
	PFD_528_SET     volatile.Register32 // 0x104
	PFD_528_CLR     volatile.Register32 // 0x108
	PFD_528_TOG     volatile.Register32 // 0x10C
	_               [64]byte
	MISC0           volatile.Register32 // 0x150
	MISC0_SET       volatile.Register32 // 0x154
	MISC0_CLR       volatile.Register32 // 0x158
	MISC0_TOG       volatile.Register32 // 0x15C
	MISC1           volatile.Register32 // 0x160
	MISC1_SET       volatile.Register32 // 0x164
	MISC1_CLR       volatile.Register32 // 0x168
	MISC1_TOG       volatile.Register32 // 0x16C
	MISC2           volatile.Register32 // 0x170
	MISC2_SET       volatile.Register32 // 0x174
	MISC2_CLR       volatile.Register32 // 0x178
	MISC2_TOG       volatile.Register32 // 0x17C
}

// CCM_ANALOG.PLL_USB1: Analog USB1 480MHz PLL Control Register
func (o *CCM_ANALOG_Type) SetPLL_USB1_DIV_SELECT(value uint32) {
	volatile.StoreUint32(&o.PLL_USB1.Reg, volatile.LoadUint32(&o.PLL_USB1.Reg)&^(0x2)|value<<1)
}
func (o *CCM_ANALOG_Type) GetPLL_USB1_DIV_SELECT() uint32 {
	return (volatile.LoadUint32(&o.PLL_USB1.Reg) & 0x2) >> 1
}
func (o *CCM_ANALOG_Type) SetPLL_USB1_EN_USB_CLKS(value uint32) {
	volatile.StoreUint32(&o.PLL_USB1.Reg, volatile.LoadUint32(&o.PLL_USB1.Reg)&^(0x40)|value<<6)
}
func (o *CCM_ANALOG_Type) GetPLL_USB1_EN_USB_CLKS() uint32 {
	return (volatile.LoadUint32(&o.PLL_USB1.Reg) & 0x40) >> 6
}
func (o *CCM_ANALOG_Type) SetPLL_USB1_POWER(value uint32) {
	volatile.StoreUint32(&o.PLL_USB1.Reg, volatile.LoadUint32(&o.PLL_USB1.Reg)&^(0x1000)|value<<12)
}
func (o *CCM_ANALOG_Type) GetPLL_USB1_POWER() uint32 {
	return (volatile.LoadUint32(&o.PLL_USB1.Reg) & 0x1000) >> 12
}
func (o *CCM_ANALOG_Type) SetPLL_USB1_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PLL_USB1.Reg, volatile.LoadUint32(&o.PLL_USB1.Reg)&^(0x2000)|value<<13)
}
func (o *CCM_ANALOG_Type) GetPLL_USB1_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PLL_USB1.Reg) & 0x2000) >> 13
}
func (o *CCM_ANALOG_Type) SetPLL_USB1_BYPASS_CLK_SRC(value uint32) {
	volatile.StoreUint32(&o.PLL_USB1.Reg, volatile.LoadUint32(&o.PLL_USB1.Reg)&^(0xc000)|value<<14)
}
func (o *CCM_ANALOG_Type) GetPLL_USB1_BYPASS_CLK_SRC() uint32 {
	return (volatile.LoadUint32(&o.PLL_USB1.Reg) & 0xc000) >> 14
}
func (o *CCM_ANALOG_Type) SetPLL_USB1_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PLL_USB1.Reg, volatile.LoadUint32(&o.PLL_USB1.Reg)&^(0x10000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetPLL_USB1_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PLL_USB1.Reg) & 0x10000) >> 16
}
func (o *CCM_ANALOG_Type) SetPLL_USB1_LOCK(value uint32) {
	volatile.StoreUint32(&o.PLL_USB1.Reg, volatile.LoadUint32(&o.PLL_USB1.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_ANALOG_Type) GetPLL_USB1_LOCK() uint32 {
	return (volatile.LoadUint32(&o.PLL_USB1.Reg) & 0x80000000) >> 31
}

// CCM_ANALOG.PLL_USB1_SET: Analog USB1 480MHz PLL Control Register
func (o *CCM_ANALOG_Type) SetPLL_USB1_SET_DIV_SELECT(value uint32) {
	volatile.StoreUint32(&o.PLL_USB1_SET.Reg, volatile.LoadUint32(&o.PLL_USB1_SET.Reg)&^(0x2)|value<<1)
}
func (o *CCM_ANALOG_Type) GetPLL_USB1_SET_DIV_SELECT() uint32 {
	return (volatile.LoadUint32(&o.PLL_USB1_SET.Reg) & 0x2) >> 1
}
func (o *CCM_ANALOG_Type) SetPLL_USB1_SET_EN_USB_CLKS(value uint32) {
	volatile.StoreUint32(&o.PLL_USB1_SET.Reg, volatile.LoadUint32(&o.PLL_USB1_SET.Reg)&^(0x40)|value<<6)
}
func (o *CCM_ANALOG_Type) GetPLL_USB1_SET_EN_USB_CLKS() uint32 {
	return (volatile.LoadUint32(&o.PLL_USB1_SET.Reg) & 0x40) >> 6
}
func (o *CCM_ANALOG_Type) SetPLL_USB1_SET_POWER(value uint32) {
	volatile.StoreUint32(&o.PLL_USB1_SET.Reg, volatile.LoadUint32(&o.PLL_USB1_SET.Reg)&^(0x1000)|value<<12)
}
func (o *CCM_ANALOG_Type) GetPLL_USB1_SET_POWER() uint32 {
	return (volatile.LoadUint32(&o.PLL_USB1_SET.Reg) & 0x1000) >> 12
}
func (o *CCM_ANALOG_Type) SetPLL_USB1_SET_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PLL_USB1_SET.Reg, volatile.LoadUint32(&o.PLL_USB1_SET.Reg)&^(0x2000)|value<<13)
}
func (o *CCM_ANALOG_Type) GetPLL_USB1_SET_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PLL_USB1_SET.Reg) & 0x2000) >> 13
}
func (o *CCM_ANALOG_Type) SetPLL_USB1_SET_BYPASS_CLK_SRC(value uint32) {
	volatile.StoreUint32(&o.PLL_USB1_SET.Reg, volatile.LoadUint32(&o.PLL_USB1_SET.Reg)&^(0xc000)|value<<14)
}
func (o *CCM_ANALOG_Type) GetPLL_USB1_SET_BYPASS_CLK_SRC() uint32 {
	return (volatile.LoadUint32(&o.PLL_USB1_SET.Reg) & 0xc000) >> 14
}
func (o *CCM_ANALOG_Type) SetPLL_USB1_SET_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PLL_USB1_SET.Reg, volatile.LoadUint32(&o.PLL_USB1_SET.Reg)&^(0x10000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetPLL_USB1_SET_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PLL_USB1_SET.Reg) & 0x10000) >> 16
}
func (o *CCM_ANALOG_Type) SetPLL_USB1_SET_LOCK(value uint32) {
	volatile.StoreUint32(&o.PLL_USB1_SET.Reg, volatile.LoadUint32(&o.PLL_USB1_SET.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_ANALOG_Type) GetPLL_USB1_SET_LOCK() uint32 {
	return (volatile.LoadUint32(&o.PLL_USB1_SET.Reg) & 0x80000000) >> 31
}

// CCM_ANALOG.PLL_USB1_CLR: Analog USB1 480MHz PLL Control Register
func (o *CCM_ANALOG_Type) SetPLL_USB1_CLR_DIV_SELECT(value uint32) {
	volatile.StoreUint32(&o.PLL_USB1_CLR.Reg, volatile.LoadUint32(&o.PLL_USB1_CLR.Reg)&^(0x2)|value<<1)
}
func (o *CCM_ANALOG_Type) GetPLL_USB1_CLR_DIV_SELECT() uint32 {
	return (volatile.LoadUint32(&o.PLL_USB1_CLR.Reg) & 0x2) >> 1
}
func (o *CCM_ANALOG_Type) SetPLL_USB1_CLR_EN_USB_CLKS(value uint32) {
	volatile.StoreUint32(&o.PLL_USB1_CLR.Reg, volatile.LoadUint32(&o.PLL_USB1_CLR.Reg)&^(0x40)|value<<6)
}
func (o *CCM_ANALOG_Type) GetPLL_USB1_CLR_EN_USB_CLKS() uint32 {
	return (volatile.LoadUint32(&o.PLL_USB1_CLR.Reg) & 0x40) >> 6
}
func (o *CCM_ANALOG_Type) SetPLL_USB1_CLR_POWER(value uint32) {
	volatile.StoreUint32(&o.PLL_USB1_CLR.Reg, volatile.LoadUint32(&o.PLL_USB1_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *CCM_ANALOG_Type) GetPLL_USB1_CLR_POWER() uint32 {
	return (volatile.LoadUint32(&o.PLL_USB1_CLR.Reg) & 0x1000) >> 12
}
func (o *CCM_ANALOG_Type) SetPLL_USB1_CLR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PLL_USB1_CLR.Reg, volatile.LoadUint32(&o.PLL_USB1_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *CCM_ANALOG_Type) GetPLL_USB1_CLR_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PLL_USB1_CLR.Reg) & 0x2000) >> 13
}
func (o *CCM_ANALOG_Type) SetPLL_USB1_CLR_BYPASS_CLK_SRC(value uint32) {
	volatile.StoreUint32(&o.PLL_USB1_CLR.Reg, volatile.LoadUint32(&o.PLL_USB1_CLR.Reg)&^(0xc000)|value<<14)
}
func (o *CCM_ANALOG_Type) GetPLL_USB1_CLR_BYPASS_CLK_SRC() uint32 {
	return (volatile.LoadUint32(&o.PLL_USB1_CLR.Reg) & 0xc000) >> 14
}
func (o *CCM_ANALOG_Type) SetPLL_USB1_CLR_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PLL_USB1_CLR.Reg, volatile.LoadUint32(&o.PLL_USB1_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetPLL_USB1_CLR_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PLL_USB1_CLR.Reg) & 0x10000) >> 16
}
func (o *CCM_ANALOG_Type) SetPLL_USB1_CLR_LOCK(value uint32) {
	volatile.StoreUint32(&o.PLL_USB1_CLR.Reg, volatile.LoadUint32(&o.PLL_USB1_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_ANALOG_Type) GetPLL_USB1_CLR_LOCK() uint32 {
	return (volatile.LoadUint32(&o.PLL_USB1_CLR.Reg) & 0x80000000) >> 31
}

// CCM_ANALOG.PLL_USB1_TOG: Analog USB1 480MHz PLL Control Register
func (o *CCM_ANALOG_Type) SetPLL_USB1_TOG_DIV_SELECT(value uint32) {
	volatile.StoreUint32(&o.PLL_USB1_TOG.Reg, volatile.LoadUint32(&o.PLL_USB1_TOG.Reg)&^(0x2)|value<<1)
}
func (o *CCM_ANALOG_Type) GetPLL_USB1_TOG_DIV_SELECT() uint32 {
	return (volatile.LoadUint32(&o.PLL_USB1_TOG.Reg) & 0x2) >> 1
}
func (o *CCM_ANALOG_Type) SetPLL_USB1_TOG_EN_USB_CLKS(value uint32) {
	volatile.StoreUint32(&o.PLL_USB1_TOG.Reg, volatile.LoadUint32(&o.PLL_USB1_TOG.Reg)&^(0x40)|value<<6)
}
func (o *CCM_ANALOG_Type) GetPLL_USB1_TOG_EN_USB_CLKS() uint32 {
	return (volatile.LoadUint32(&o.PLL_USB1_TOG.Reg) & 0x40) >> 6
}
func (o *CCM_ANALOG_Type) SetPLL_USB1_TOG_POWER(value uint32) {
	volatile.StoreUint32(&o.PLL_USB1_TOG.Reg, volatile.LoadUint32(&o.PLL_USB1_TOG.Reg)&^(0x1000)|value<<12)
}
func (o *CCM_ANALOG_Type) GetPLL_USB1_TOG_POWER() uint32 {
	return (volatile.LoadUint32(&o.PLL_USB1_TOG.Reg) & 0x1000) >> 12
}
func (o *CCM_ANALOG_Type) SetPLL_USB1_TOG_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PLL_USB1_TOG.Reg, volatile.LoadUint32(&o.PLL_USB1_TOG.Reg)&^(0x2000)|value<<13)
}
func (o *CCM_ANALOG_Type) GetPLL_USB1_TOG_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PLL_USB1_TOG.Reg) & 0x2000) >> 13
}
func (o *CCM_ANALOG_Type) SetPLL_USB1_TOG_BYPASS_CLK_SRC(value uint32) {
	volatile.StoreUint32(&o.PLL_USB1_TOG.Reg, volatile.LoadUint32(&o.PLL_USB1_TOG.Reg)&^(0xc000)|value<<14)
}
func (o *CCM_ANALOG_Type) GetPLL_USB1_TOG_BYPASS_CLK_SRC() uint32 {
	return (volatile.LoadUint32(&o.PLL_USB1_TOG.Reg) & 0xc000) >> 14
}
func (o *CCM_ANALOG_Type) SetPLL_USB1_TOG_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PLL_USB1_TOG.Reg, volatile.LoadUint32(&o.PLL_USB1_TOG.Reg)&^(0x10000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetPLL_USB1_TOG_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PLL_USB1_TOG.Reg) & 0x10000) >> 16
}
func (o *CCM_ANALOG_Type) SetPLL_USB1_TOG_LOCK(value uint32) {
	volatile.StoreUint32(&o.PLL_USB1_TOG.Reg, volatile.LoadUint32(&o.PLL_USB1_TOG.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_ANALOG_Type) GetPLL_USB1_TOG_LOCK() uint32 {
	return (volatile.LoadUint32(&o.PLL_USB1_TOG.Reg) & 0x80000000) >> 31
}

// CCM_ANALOG.PLL_SYS: Analog System PLL Control Register
func (o *CCM_ANALOG_Type) SetPLL_SYS_DIV_SELECT(value uint32) {
	volatile.StoreUint32(&o.PLL_SYS.Reg, volatile.LoadUint32(&o.PLL_SYS.Reg)&^(0x1)|value)
}
func (o *CCM_ANALOG_Type) GetPLL_SYS_DIV_SELECT() uint32 {
	return volatile.LoadUint32(&o.PLL_SYS.Reg) & 0x1
}
func (o *CCM_ANALOG_Type) SetPLL_SYS_POWERDOWN(value uint32) {
	volatile.StoreUint32(&o.PLL_SYS.Reg, volatile.LoadUint32(&o.PLL_SYS.Reg)&^(0x1000)|value<<12)
}
func (o *CCM_ANALOG_Type) GetPLL_SYS_POWERDOWN() uint32 {
	return (volatile.LoadUint32(&o.PLL_SYS.Reg) & 0x1000) >> 12
}
func (o *CCM_ANALOG_Type) SetPLL_SYS_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PLL_SYS.Reg, volatile.LoadUint32(&o.PLL_SYS.Reg)&^(0x2000)|value<<13)
}
func (o *CCM_ANALOG_Type) GetPLL_SYS_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PLL_SYS.Reg) & 0x2000) >> 13
}
func (o *CCM_ANALOG_Type) SetPLL_SYS_BYPASS_CLK_SRC(value uint32) {
	volatile.StoreUint32(&o.PLL_SYS.Reg, volatile.LoadUint32(&o.PLL_SYS.Reg)&^(0xc000)|value<<14)
}
func (o *CCM_ANALOG_Type) GetPLL_SYS_BYPASS_CLK_SRC() uint32 {
	return (volatile.LoadUint32(&o.PLL_SYS.Reg) & 0xc000) >> 14
}
func (o *CCM_ANALOG_Type) SetPLL_SYS_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PLL_SYS.Reg, volatile.LoadUint32(&o.PLL_SYS.Reg)&^(0x10000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetPLL_SYS_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PLL_SYS.Reg) & 0x10000) >> 16
}
func (o *CCM_ANALOG_Type) SetPLL_SYS_LOCK(value uint32) {
	volatile.StoreUint32(&o.PLL_SYS.Reg, volatile.LoadUint32(&o.PLL_SYS.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_ANALOG_Type) GetPLL_SYS_LOCK() uint32 {
	return (volatile.LoadUint32(&o.PLL_SYS.Reg) & 0x80000000) >> 31
}

// CCM_ANALOG.PLL_SYS_SET: Analog System PLL Control Register
func (o *CCM_ANALOG_Type) SetPLL_SYS_SET_DIV_SELECT(value uint32) {
	volatile.StoreUint32(&o.PLL_SYS_SET.Reg, volatile.LoadUint32(&o.PLL_SYS_SET.Reg)&^(0x1)|value)
}
func (o *CCM_ANALOG_Type) GetPLL_SYS_SET_DIV_SELECT() uint32 {
	return volatile.LoadUint32(&o.PLL_SYS_SET.Reg) & 0x1
}
func (o *CCM_ANALOG_Type) SetPLL_SYS_SET_POWERDOWN(value uint32) {
	volatile.StoreUint32(&o.PLL_SYS_SET.Reg, volatile.LoadUint32(&o.PLL_SYS_SET.Reg)&^(0x1000)|value<<12)
}
func (o *CCM_ANALOG_Type) GetPLL_SYS_SET_POWERDOWN() uint32 {
	return (volatile.LoadUint32(&o.PLL_SYS_SET.Reg) & 0x1000) >> 12
}
func (o *CCM_ANALOG_Type) SetPLL_SYS_SET_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PLL_SYS_SET.Reg, volatile.LoadUint32(&o.PLL_SYS_SET.Reg)&^(0x2000)|value<<13)
}
func (o *CCM_ANALOG_Type) GetPLL_SYS_SET_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PLL_SYS_SET.Reg) & 0x2000) >> 13
}
func (o *CCM_ANALOG_Type) SetPLL_SYS_SET_BYPASS_CLK_SRC(value uint32) {
	volatile.StoreUint32(&o.PLL_SYS_SET.Reg, volatile.LoadUint32(&o.PLL_SYS_SET.Reg)&^(0xc000)|value<<14)
}
func (o *CCM_ANALOG_Type) GetPLL_SYS_SET_BYPASS_CLK_SRC() uint32 {
	return (volatile.LoadUint32(&o.PLL_SYS_SET.Reg) & 0xc000) >> 14
}
func (o *CCM_ANALOG_Type) SetPLL_SYS_SET_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PLL_SYS_SET.Reg, volatile.LoadUint32(&o.PLL_SYS_SET.Reg)&^(0x10000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetPLL_SYS_SET_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PLL_SYS_SET.Reg) & 0x10000) >> 16
}
func (o *CCM_ANALOG_Type) SetPLL_SYS_SET_LOCK(value uint32) {
	volatile.StoreUint32(&o.PLL_SYS_SET.Reg, volatile.LoadUint32(&o.PLL_SYS_SET.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_ANALOG_Type) GetPLL_SYS_SET_LOCK() uint32 {
	return (volatile.LoadUint32(&o.PLL_SYS_SET.Reg) & 0x80000000) >> 31
}

// CCM_ANALOG.PLL_SYS_CLR: Analog System PLL Control Register
func (o *CCM_ANALOG_Type) SetPLL_SYS_CLR_DIV_SELECT(value uint32) {
	volatile.StoreUint32(&o.PLL_SYS_CLR.Reg, volatile.LoadUint32(&o.PLL_SYS_CLR.Reg)&^(0x1)|value)
}
func (o *CCM_ANALOG_Type) GetPLL_SYS_CLR_DIV_SELECT() uint32 {
	return volatile.LoadUint32(&o.PLL_SYS_CLR.Reg) & 0x1
}
func (o *CCM_ANALOG_Type) SetPLL_SYS_CLR_POWERDOWN(value uint32) {
	volatile.StoreUint32(&o.PLL_SYS_CLR.Reg, volatile.LoadUint32(&o.PLL_SYS_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *CCM_ANALOG_Type) GetPLL_SYS_CLR_POWERDOWN() uint32 {
	return (volatile.LoadUint32(&o.PLL_SYS_CLR.Reg) & 0x1000) >> 12
}
func (o *CCM_ANALOG_Type) SetPLL_SYS_CLR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PLL_SYS_CLR.Reg, volatile.LoadUint32(&o.PLL_SYS_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *CCM_ANALOG_Type) GetPLL_SYS_CLR_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PLL_SYS_CLR.Reg) & 0x2000) >> 13
}
func (o *CCM_ANALOG_Type) SetPLL_SYS_CLR_BYPASS_CLK_SRC(value uint32) {
	volatile.StoreUint32(&o.PLL_SYS_CLR.Reg, volatile.LoadUint32(&o.PLL_SYS_CLR.Reg)&^(0xc000)|value<<14)
}
func (o *CCM_ANALOG_Type) GetPLL_SYS_CLR_BYPASS_CLK_SRC() uint32 {
	return (volatile.LoadUint32(&o.PLL_SYS_CLR.Reg) & 0xc000) >> 14
}
func (o *CCM_ANALOG_Type) SetPLL_SYS_CLR_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PLL_SYS_CLR.Reg, volatile.LoadUint32(&o.PLL_SYS_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetPLL_SYS_CLR_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PLL_SYS_CLR.Reg) & 0x10000) >> 16
}
func (o *CCM_ANALOG_Type) SetPLL_SYS_CLR_LOCK(value uint32) {
	volatile.StoreUint32(&o.PLL_SYS_CLR.Reg, volatile.LoadUint32(&o.PLL_SYS_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_ANALOG_Type) GetPLL_SYS_CLR_LOCK() uint32 {
	return (volatile.LoadUint32(&o.PLL_SYS_CLR.Reg) & 0x80000000) >> 31
}

// CCM_ANALOG.PLL_SYS_TOG: Analog System PLL Control Register
func (o *CCM_ANALOG_Type) SetPLL_SYS_TOG_DIV_SELECT(value uint32) {
	volatile.StoreUint32(&o.PLL_SYS_TOG.Reg, volatile.LoadUint32(&o.PLL_SYS_TOG.Reg)&^(0x1)|value)
}
func (o *CCM_ANALOG_Type) GetPLL_SYS_TOG_DIV_SELECT() uint32 {
	return volatile.LoadUint32(&o.PLL_SYS_TOG.Reg) & 0x1
}
func (o *CCM_ANALOG_Type) SetPLL_SYS_TOG_POWERDOWN(value uint32) {
	volatile.StoreUint32(&o.PLL_SYS_TOG.Reg, volatile.LoadUint32(&o.PLL_SYS_TOG.Reg)&^(0x1000)|value<<12)
}
func (o *CCM_ANALOG_Type) GetPLL_SYS_TOG_POWERDOWN() uint32 {
	return (volatile.LoadUint32(&o.PLL_SYS_TOG.Reg) & 0x1000) >> 12
}
func (o *CCM_ANALOG_Type) SetPLL_SYS_TOG_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PLL_SYS_TOG.Reg, volatile.LoadUint32(&o.PLL_SYS_TOG.Reg)&^(0x2000)|value<<13)
}
func (o *CCM_ANALOG_Type) GetPLL_SYS_TOG_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PLL_SYS_TOG.Reg) & 0x2000) >> 13
}
func (o *CCM_ANALOG_Type) SetPLL_SYS_TOG_BYPASS_CLK_SRC(value uint32) {
	volatile.StoreUint32(&o.PLL_SYS_TOG.Reg, volatile.LoadUint32(&o.PLL_SYS_TOG.Reg)&^(0xc000)|value<<14)
}
func (o *CCM_ANALOG_Type) GetPLL_SYS_TOG_BYPASS_CLK_SRC() uint32 {
	return (volatile.LoadUint32(&o.PLL_SYS_TOG.Reg) & 0xc000) >> 14
}
func (o *CCM_ANALOG_Type) SetPLL_SYS_TOG_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PLL_SYS_TOG.Reg, volatile.LoadUint32(&o.PLL_SYS_TOG.Reg)&^(0x10000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetPLL_SYS_TOG_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PLL_SYS_TOG.Reg) & 0x10000) >> 16
}
func (o *CCM_ANALOG_Type) SetPLL_SYS_TOG_LOCK(value uint32) {
	volatile.StoreUint32(&o.PLL_SYS_TOG.Reg, volatile.LoadUint32(&o.PLL_SYS_TOG.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_ANALOG_Type) GetPLL_SYS_TOG_LOCK() uint32 {
	return (volatile.LoadUint32(&o.PLL_SYS_TOG.Reg) & 0x80000000) >> 31
}

// CCM_ANALOG.PLL_SYS_SS: 528MHz System PLL Spread Spectrum Register
func (o *CCM_ANALOG_Type) SetPLL_SYS_SS_STEP(value uint32) {
	volatile.StoreUint32(&o.PLL_SYS_SS.Reg, volatile.LoadUint32(&o.PLL_SYS_SS.Reg)&^(0x7fff)|value)
}
func (o *CCM_ANALOG_Type) GetPLL_SYS_SS_STEP() uint32 {
	return volatile.LoadUint32(&o.PLL_SYS_SS.Reg) & 0x7fff
}
func (o *CCM_ANALOG_Type) SetPLL_SYS_SS_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PLL_SYS_SS.Reg, volatile.LoadUint32(&o.PLL_SYS_SS.Reg)&^(0x8000)|value<<15)
}
func (o *CCM_ANALOG_Type) GetPLL_SYS_SS_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PLL_SYS_SS.Reg) & 0x8000) >> 15
}
func (o *CCM_ANALOG_Type) SetPLL_SYS_SS_STOP(value uint32) {
	volatile.StoreUint32(&o.PLL_SYS_SS.Reg, volatile.LoadUint32(&o.PLL_SYS_SS.Reg)&^(0xffff0000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetPLL_SYS_SS_STOP() uint32 {
	return (volatile.LoadUint32(&o.PLL_SYS_SS.Reg) & 0xffff0000) >> 16
}

// CCM_ANALOG.PLL_SYS_NUM: Numerator of 528MHz System PLL Fractional Loop Divider Register
func (o *CCM_ANALOG_Type) SetPLL_SYS_NUM_A(value uint32) {
	volatile.StoreUint32(&o.PLL_SYS_NUM.Reg, volatile.LoadUint32(&o.PLL_SYS_NUM.Reg)&^(0x3fffffff)|value)
}
func (o *CCM_ANALOG_Type) GetPLL_SYS_NUM_A() uint32 {
	return volatile.LoadUint32(&o.PLL_SYS_NUM.Reg) & 0x3fffffff
}

// CCM_ANALOG.PLL_SYS_DENOM: Denominator of 528MHz System PLL Fractional Loop Divider Register
func (o *CCM_ANALOG_Type) SetPLL_SYS_DENOM_B(value uint32) {
	volatile.StoreUint32(&o.PLL_SYS_DENOM.Reg, volatile.LoadUint32(&o.PLL_SYS_DENOM.Reg)&^(0x3fffffff)|value)
}
func (o *CCM_ANALOG_Type) GetPLL_SYS_DENOM_B() uint32 {
	return volatile.LoadUint32(&o.PLL_SYS_DENOM.Reg) & 0x3fffffff
}

// CCM_ANALOG.PLL_AUDIO: Analog Audio PLL control Register
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_DIV_SELECT(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO.Reg, volatile.LoadUint32(&o.PLL_AUDIO.Reg)&^(0x7f)|value)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_DIV_SELECT() uint32 {
	return volatile.LoadUint32(&o.PLL_AUDIO.Reg) & 0x7f
}
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_POWERDOWN(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO.Reg, volatile.LoadUint32(&o.PLL_AUDIO.Reg)&^(0x1000)|value<<12)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_POWERDOWN() uint32 {
	return (volatile.LoadUint32(&o.PLL_AUDIO.Reg) & 0x1000) >> 12
}
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO.Reg, volatile.LoadUint32(&o.PLL_AUDIO.Reg)&^(0x2000)|value<<13)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PLL_AUDIO.Reg) & 0x2000) >> 13
}
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_BYPASS_CLK_SRC(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO.Reg, volatile.LoadUint32(&o.PLL_AUDIO.Reg)&^(0xc000)|value<<14)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_BYPASS_CLK_SRC() uint32 {
	return (volatile.LoadUint32(&o.PLL_AUDIO.Reg) & 0xc000) >> 14
}
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO.Reg, volatile.LoadUint32(&o.PLL_AUDIO.Reg)&^(0x10000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PLL_AUDIO.Reg) & 0x10000) >> 16
}
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_POST_DIV_SELECT(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO.Reg, volatile.LoadUint32(&o.PLL_AUDIO.Reg)&^(0x180000)|value<<19)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_POST_DIV_SELECT() uint32 {
	return (volatile.LoadUint32(&o.PLL_AUDIO.Reg) & 0x180000) >> 19
}
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_LOCK(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO.Reg, volatile.LoadUint32(&o.PLL_AUDIO.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_LOCK() uint32 {
	return (volatile.LoadUint32(&o.PLL_AUDIO.Reg) & 0x80000000) >> 31
}

// CCM_ANALOG.PLL_AUDIO_SET: Analog Audio PLL control Register
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_SET_DIV_SELECT(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO_SET.Reg, volatile.LoadUint32(&o.PLL_AUDIO_SET.Reg)&^(0x7f)|value)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_SET_DIV_SELECT() uint32 {
	return volatile.LoadUint32(&o.PLL_AUDIO_SET.Reg) & 0x7f
}
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_SET_POWERDOWN(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO_SET.Reg, volatile.LoadUint32(&o.PLL_AUDIO_SET.Reg)&^(0x1000)|value<<12)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_SET_POWERDOWN() uint32 {
	return (volatile.LoadUint32(&o.PLL_AUDIO_SET.Reg) & 0x1000) >> 12
}
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_SET_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO_SET.Reg, volatile.LoadUint32(&o.PLL_AUDIO_SET.Reg)&^(0x2000)|value<<13)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_SET_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PLL_AUDIO_SET.Reg) & 0x2000) >> 13
}
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_SET_BYPASS_CLK_SRC(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO_SET.Reg, volatile.LoadUint32(&o.PLL_AUDIO_SET.Reg)&^(0xc000)|value<<14)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_SET_BYPASS_CLK_SRC() uint32 {
	return (volatile.LoadUint32(&o.PLL_AUDIO_SET.Reg) & 0xc000) >> 14
}
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_SET_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO_SET.Reg, volatile.LoadUint32(&o.PLL_AUDIO_SET.Reg)&^(0x10000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_SET_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PLL_AUDIO_SET.Reg) & 0x10000) >> 16
}
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_SET_POST_DIV_SELECT(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO_SET.Reg, volatile.LoadUint32(&o.PLL_AUDIO_SET.Reg)&^(0x180000)|value<<19)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_SET_POST_DIV_SELECT() uint32 {
	return (volatile.LoadUint32(&o.PLL_AUDIO_SET.Reg) & 0x180000) >> 19
}
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_SET_LOCK(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO_SET.Reg, volatile.LoadUint32(&o.PLL_AUDIO_SET.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_SET_LOCK() uint32 {
	return (volatile.LoadUint32(&o.PLL_AUDIO_SET.Reg) & 0x80000000) >> 31
}

// CCM_ANALOG.PLL_AUDIO_CLR: Analog Audio PLL control Register
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_CLR_DIV_SELECT(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO_CLR.Reg, volatile.LoadUint32(&o.PLL_AUDIO_CLR.Reg)&^(0x7f)|value)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_CLR_DIV_SELECT() uint32 {
	return volatile.LoadUint32(&o.PLL_AUDIO_CLR.Reg) & 0x7f
}
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_CLR_POWERDOWN(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO_CLR.Reg, volatile.LoadUint32(&o.PLL_AUDIO_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_CLR_POWERDOWN() uint32 {
	return (volatile.LoadUint32(&o.PLL_AUDIO_CLR.Reg) & 0x1000) >> 12
}
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_CLR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO_CLR.Reg, volatile.LoadUint32(&o.PLL_AUDIO_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_CLR_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PLL_AUDIO_CLR.Reg) & 0x2000) >> 13
}
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_CLR_BYPASS_CLK_SRC(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO_CLR.Reg, volatile.LoadUint32(&o.PLL_AUDIO_CLR.Reg)&^(0xc000)|value<<14)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_CLR_BYPASS_CLK_SRC() uint32 {
	return (volatile.LoadUint32(&o.PLL_AUDIO_CLR.Reg) & 0xc000) >> 14
}
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_CLR_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO_CLR.Reg, volatile.LoadUint32(&o.PLL_AUDIO_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_CLR_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PLL_AUDIO_CLR.Reg) & 0x10000) >> 16
}
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_CLR_POST_DIV_SELECT(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO_CLR.Reg, volatile.LoadUint32(&o.PLL_AUDIO_CLR.Reg)&^(0x180000)|value<<19)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_CLR_POST_DIV_SELECT() uint32 {
	return (volatile.LoadUint32(&o.PLL_AUDIO_CLR.Reg) & 0x180000) >> 19
}
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_CLR_LOCK(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO_CLR.Reg, volatile.LoadUint32(&o.PLL_AUDIO_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_CLR_LOCK() uint32 {
	return (volatile.LoadUint32(&o.PLL_AUDIO_CLR.Reg) & 0x80000000) >> 31
}

// CCM_ANALOG.PLL_AUDIO_TOG: Analog Audio PLL control Register
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_TOG_DIV_SELECT(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO_TOG.Reg, volatile.LoadUint32(&o.PLL_AUDIO_TOG.Reg)&^(0x7f)|value)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_TOG_DIV_SELECT() uint32 {
	return volatile.LoadUint32(&o.PLL_AUDIO_TOG.Reg) & 0x7f
}
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_TOG_POWERDOWN(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO_TOG.Reg, volatile.LoadUint32(&o.PLL_AUDIO_TOG.Reg)&^(0x1000)|value<<12)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_TOG_POWERDOWN() uint32 {
	return (volatile.LoadUint32(&o.PLL_AUDIO_TOG.Reg) & 0x1000) >> 12
}
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_TOG_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO_TOG.Reg, volatile.LoadUint32(&o.PLL_AUDIO_TOG.Reg)&^(0x2000)|value<<13)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_TOG_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.PLL_AUDIO_TOG.Reg) & 0x2000) >> 13
}
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_TOG_BYPASS_CLK_SRC(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO_TOG.Reg, volatile.LoadUint32(&o.PLL_AUDIO_TOG.Reg)&^(0xc000)|value<<14)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_TOG_BYPASS_CLK_SRC() uint32 {
	return (volatile.LoadUint32(&o.PLL_AUDIO_TOG.Reg) & 0xc000) >> 14
}
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_TOG_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO_TOG.Reg, volatile.LoadUint32(&o.PLL_AUDIO_TOG.Reg)&^(0x10000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_TOG_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PLL_AUDIO_TOG.Reg) & 0x10000) >> 16
}
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_TOG_POST_DIV_SELECT(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO_TOG.Reg, volatile.LoadUint32(&o.PLL_AUDIO_TOG.Reg)&^(0x180000)|value<<19)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_TOG_POST_DIV_SELECT() uint32 {
	return (volatile.LoadUint32(&o.PLL_AUDIO_TOG.Reg) & 0x180000) >> 19
}
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_TOG_LOCK(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO_TOG.Reg, volatile.LoadUint32(&o.PLL_AUDIO_TOG.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_TOG_LOCK() uint32 {
	return (volatile.LoadUint32(&o.PLL_AUDIO_TOG.Reg) & 0x80000000) >> 31
}

// CCM_ANALOG.PLL_AUDIO_NUM: Numerator of Audio PLL Fractional Loop Divider Register
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_NUM_A(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO_NUM.Reg, volatile.LoadUint32(&o.PLL_AUDIO_NUM.Reg)&^(0x3fffffff)|value)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_NUM_A() uint32 {
	return volatile.LoadUint32(&o.PLL_AUDIO_NUM.Reg) & 0x3fffffff
}

// CCM_ANALOG.PLL_AUDIO_DENOM: Denominator of Audio PLL Fractional Loop Divider Register
func (o *CCM_ANALOG_Type) SetPLL_AUDIO_DENOM_B(value uint32) {
	volatile.StoreUint32(&o.PLL_AUDIO_DENOM.Reg, volatile.LoadUint32(&o.PLL_AUDIO_DENOM.Reg)&^(0x3fffffff)|value)
}
func (o *CCM_ANALOG_Type) GetPLL_AUDIO_DENOM_B() uint32 {
	return volatile.LoadUint32(&o.PLL_AUDIO_DENOM.Reg) & 0x3fffffff
}

// CCM_ANALOG.PLL_ENET: Analog ENET PLL Control Register
func (o *CCM_ANALOG_Type) SetPLL_ENET_POWERDOWN(value uint32) {
	volatile.StoreUint32(&o.PLL_ENET.Reg, volatile.LoadUint32(&o.PLL_ENET.Reg)&^(0x1000)|value<<12)
}
func (o *CCM_ANALOG_Type) GetPLL_ENET_POWERDOWN() uint32 {
	return (volatile.LoadUint32(&o.PLL_ENET.Reg) & 0x1000) >> 12
}
func (o *CCM_ANALOG_Type) SetPLL_ENET_BYPASS_CLK_SRC(value uint32) {
	volatile.StoreUint32(&o.PLL_ENET.Reg, volatile.LoadUint32(&o.PLL_ENET.Reg)&^(0xc000)|value<<14)
}
func (o *CCM_ANALOG_Type) GetPLL_ENET_BYPASS_CLK_SRC() uint32 {
	return (volatile.LoadUint32(&o.PLL_ENET.Reg) & 0xc000) >> 14
}
func (o *CCM_ANALOG_Type) SetPLL_ENET_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PLL_ENET.Reg, volatile.LoadUint32(&o.PLL_ENET.Reg)&^(0x10000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetPLL_ENET_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PLL_ENET.Reg) & 0x10000) >> 16
}
func (o *CCM_ANALOG_Type) SetPLL_ENET_ENET_500M_REF_EN(value uint32) {
	volatile.StoreUint32(&o.PLL_ENET.Reg, volatile.LoadUint32(&o.PLL_ENET.Reg)&^(0x400000)|value<<22)
}
func (o *CCM_ANALOG_Type) GetPLL_ENET_ENET_500M_REF_EN() uint32 {
	return (volatile.LoadUint32(&o.PLL_ENET.Reg) & 0x400000) >> 22
}
func (o *CCM_ANALOG_Type) SetPLL_ENET_LOCK(value uint32) {
	volatile.StoreUint32(&o.PLL_ENET.Reg, volatile.LoadUint32(&o.PLL_ENET.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_ANALOG_Type) GetPLL_ENET_LOCK() uint32 {
	return (volatile.LoadUint32(&o.PLL_ENET.Reg) & 0x80000000) >> 31
}

// CCM_ANALOG.PLL_ENET_SET: Analog ENET PLL Control Register
func (o *CCM_ANALOG_Type) SetPLL_ENET_SET_POWERDOWN(value uint32) {
	volatile.StoreUint32(&o.PLL_ENET_SET.Reg, volatile.LoadUint32(&o.PLL_ENET_SET.Reg)&^(0x1000)|value<<12)
}
func (o *CCM_ANALOG_Type) GetPLL_ENET_SET_POWERDOWN() uint32 {
	return (volatile.LoadUint32(&o.PLL_ENET_SET.Reg) & 0x1000) >> 12
}
func (o *CCM_ANALOG_Type) SetPLL_ENET_SET_BYPASS_CLK_SRC(value uint32) {
	volatile.StoreUint32(&o.PLL_ENET_SET.Reg, volatile.LoadUint32(&o.PLL_ENET_SET.Reg)&^(0xc000)|value<<14)
}
func (o *CCM_ANALOG_Type) GetPLL_ENET_SET_BYPASS_CLK_SRC() uint32 {
	return (volatile.LoadUint32(&o.PLL_ENET_SET.Reg) & 0xc000) >> 14
}
func (o *CCM_ANALOG_Type) SetPLL_ENET_SET_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PLL_ENET_SET.Reg, volatile.LoadUint32(&o.PLL_ENET_SET.Reg)&^(0x10000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetPLL_ENET_SET_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PLL_ENET_SET.Reg) & 0x10000) >> 16
}
func (o *CCM_ANALOG_Type) SetPLL_ENET_SET_ENET_500M_REF_EN(value uint32) {
	volatile.StoreUint32(&o.PLL_ENET_SET.Reg, volatile.LoadUint32(&o.PLL_ENET_SET.Reg)&^(0x400000)|value<<22)
}
func (o *CCM_ANALOG_Type) GetPLL_ENET_SET_ENET_500M_REF_EN() uint32 {
	return (volatile.LoadUint32(&o.PLL_ENET_SET.Reg) & 0x400000) >> 22
}
func (o *CCM_ANALOG_Type) SetPLL_ENET_SET_LOCK(value uint32) {
	volatile.StoreUint32(&o.PLL_ENET_SET.Reg, volatile.LoadUint32(&o.PLL_ENET_SET.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_ANALOG_Type) GetPLL_ENET_SET_LOCK() uint32 {
	return (volatile.LoadUint32(&o.PLL_ENET_SET.Reg) & 0x80000000) >> 31
}

// CCM_ANALOG.PLL_ENET_CLR: Analog ENET PLL Control Register
func (o *CCM_ANALOG_Type) SetPLL_ENET_CLR_POWERDOWN(value uint32) {
	volatile.StoreUint32(&o.PLL_ENET_CLR.Reg, volatile.LoadUint32(&o.PLL_ENET_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *CCM_ANALOG_Type) GetPLL_ENET_CLR_POWERDOWN() uint32 {
	return (volatile.LoadUint32(&o.PLL_ENET_CLR.Reg) & 0x1000) >> 12
}
func (o *CCM_ANALOG_Type) SetPLL_ENET_CLR_BYPASS_CLK_SRC(value uint32) {
	volatile.StoreUint32(&o.PLL_ENET_CLR.Reg, volatile.LoadUint32(&o.PLL_ENET_CLR.Reg)&^(0xc000)|value<<14)
}
func (o *CCM_ANALOG_Type) GetPLL_ENET_CLR_BYPASS_CLK_SRC() uint32 {
	return (volatile.LoadUint32(&o.PLL_ENET_CLR.Reg) & 0xc000) >> 14
}
func (o *CCM_ANALOG_Type) SetPLL_ENET_CLR_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PLL_ENET_CLR.Reg, volatile.LoadUint32(&o.PLL_ENET_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetPLL_ENET_CLR_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PLL_ENET_CLR.Reg) & 0x10000) >> 16
}
func (o *CCM_ANALOG_Type) SetPLL_ENET_CLR_ENET_500M_REF_EN(value uint32) {
	volatile.StoreUint32(&o.PLL_ENET_CLR.Reg, volatile.LoadUint32(&o.PLL_ENET_CLR.Reg)&^(0x400000)|value<<22)
}
func (o *CCM_ANALOG_Type) GetPLL_ENET_CLR_ENET_500M_REF_EN() uint32 {
	return (volatile.LoadUint32(&o.PLL_ENET_CLR.Reg) & 0x400000) >> 22
}
func (o *CCM_ANALOG_Type) SetPLL_ENET_CLR_LOCK(value uint32) {
	volatile.StoreUint32(&o.PLL_ENET_CLR.Reg, volatile.LoadUint32(&o.PLL_ENET_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_ANALOG_Type) GetPLL_ENET_CLR_LOCK() uint32 {
	return (volatile.LoadUint32(&o.PLL_ENET_CLR.Reg) & 0x80000000) >> 31
}

// CCM_ANALOG.PLL_ENET_TOG: Analog ENET PLL Control Register
func (o *CCM_ANALOG_Type) SetPLL_ENET_TOG_POWERDOWN(value uint32) {
	volatile.StoreUint32(&o.PLL_ENET_TOG.Reg, volatile.LoadUint32(&o.PLL_ENET_TOG.Reg)&^(0x1000)|value<<12)
}
func (o *CCM_ANALOG_Type) GetPLL_ENET_TOG_POWERDOWN() uint32 {
	return (volatile.LoadUint32(&o.PLL_ENET_TOG.Reg) & 0x1000) >> 12
}
func (o *CCM_ANALOG_Type) SetPLL_ENET_TOG_BYPASS_CLK_SRC(value uint32) {
	volatile.StoreUint32(&o.PLL_ENET_TOG.Reg, volatile.LoadUint32(&o.PLL_ENET_TOG.Reg)&^(0xc000)|value<<14)
}
func (o *CCM_ANALOG_Type) GetPLL_ENET_TOG_BYPASS_CLK_SRC() uint32 {
	return (volatile.LoadUint32(&o.PLL_ENET_TOG.Reg) & 0xc000) >> 14
}
func (o *CCM_ANALOG_Type) SetPLL_ENET_TOG_BYPASS(value uint32) {
	volatile.StoreUint32(&o.PLL_ENET_TOG.Reg, volatile.LoadUint32(&o.PLL_ENET_TOG.Reg)&^(0x10000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetPLL_ENET_TOG_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.PLL_ENET_TOG.Reg) & 0x10000) >> 16
}
func (o *CCM_ANALOG_Type) SetPLL_ENET_TOG_ENET_500M_REF_EN(value uint32) {
	volatile.StoreUint32(&o.PLL_ENET_TOG.Reg, volatile.LoadUint32(&o.PLL_ENET_TOG.Reg)&^(0x400000)|value<<22)
}
func (o *CCM_ANALOG_Type) GetPLL_ENET_TOG_ENET_500M_REF_EN() uint32 {
	return (volatile.LoadUint32(&o.PLL_ENET_TOG.Reg) & 0x400000) >> 22
}
func (o *CCM_ANALOG_Type) SetPLL_ENET_TOG_LOCK(value uint32) {
	volatile.StoreUint32(&o.PLL_ENET_TOG.Reg, volatile.LoadUint32(&o.PLL_ENET_TOG.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_ANALOG_Type) GetPLL_ENET_TOG_LOCK() uint32 {
	return (volatile.LoadUint32(&o.PLL_ENET_TOG.Reg) & 0x80000000) >> 31
}

// CCM_ANALOG.PFD_480: 480MHz Clock (PLL3) Phase Fractional Divider Control Register
func (o *CCM_ANALOG_Type) SetPFD_480_PFD0_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_480.Reg, volatile.LoadUint32(&o.PFD_480.Reg)&^(0x3f)|value)
}
func (o *CCM_ANALOG_Type) GetPFD_480_PFD0_FRAC() uint32 {
	return volatile.LoadUint32(&o.PFD_480.Reg) & 0x3f
}
func (o *CCM_ANALOG_Type) SetPFD_480_PFD0_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_480.Reg, volatile.LoadUint32(&o.PFD_480.Reg)&^(0x40)|value<<6)
}
func (o *CCM_ANALOG_Type) GetPFD_480_PFD0_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480.Reg) & 0x40) >> 6
}
func (o *CCM_ANALOG_Type) SetPFD_480_PFD0_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_480.Reg, volatile.LoadUint32(&o.PFD_480.Reg)&^(0x80)|value<<7)
}
func (o *CCM_ANALOG_Type) GetPFD_480_PFD0_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480.Reg) & 0x80) >> 7
}
func (o *CCM_ANALOG_Type) SetPFD_480_PFD1_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_480.Reg, volatile.LoadUint32(&o.PFD_480.Reg)&^(0x3f00)|value<<8)
}
func (o *CCM_ANALOG_Type) GetPFD_480_PFD1_FRAC() uint32 {
	return (volatile.LoadUint32(&o.PFD_480.Reg) & 0x3f00) >> 8
}
func (o *CCM_ANALOG_Type) SetPFD_480_PFD1_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_480.Reg, volatile.LoadUint32(&o.PFD_480.Reg)&^(0x4000)|value<<14)
}
func (o *CCM_ANALOG_Type) GetPFD_480_PFD1_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480.Reg) & 0x4000) >> 14
}
func (o *CCM_ANALOG_Type) SetPFD_480_PFD1_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_480.Reg, volatile.LoadUint32(&o.PFD_480.Reg)&^(0x8000)|value<<15)
}
func (o *CCM_ANALOG_Type) GetPFD_480_PFD1_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480.Reg) & 0x8000) >> 15
}
func (o *CCM_ANALOG_Type) SetPFD_480_PFD2_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_480.Reg, volatile.LoadUint32(&o.PFD_480.Reg)&^(0x3f0000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetPFD_480_PFD2_FRAC() uint32 {
	return (volatile.LoadUint32(&o.PFD_480.Reg) & 0x3f0000) >> 16
}
func (o *CCM_ANALOG_Type) SetPFD_480_PFD2_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_480.Reg, volatile.LoadUint32(&o.PFD_480.Reg)&^(0x400000)|value<<22)
}
func (o *CCM_ANALOG_Type) GetPFD_480_PFD2_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480.Reg) & 0x400000) >> 22
}
func (o *CCM_ANALOG_Type) SetPFD_480_PFD2_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_480.Reg, volatile.LoadUint32(&o.PFD_480.Reg)&^(0x800000)|value<<23)
}
func (o *CCM_ANALOG_Type) GetPFD_480_PFD2_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480.Reg) & 0x800000) >> 23
}
func (o *CCM_ANALOG_Type) SetPFD_480_PFD3_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_480.Reg, volatile.LoadUint32(&o.PFD_480.Reg)&^(0x3f000000)|value<<24)
}
func (o *CCM_ANALOG_Type) GetPFD_480_PFD3_FRAC() uint32 {
	return (volatile.LoadUint32(&o.PFD_480.Reg) & 0x3f000000) >> 24
}
func (o *CCM_ANALOG_Type) SetPFD_480_PFD3_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_480.Reg, volatile.LoadUint32(&o.PFD_480.Reg)&^(0x40000000)|value<<30)
}
func (o *CCM_ANALOG_Type) GetPFD_480_PFD3_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480.Reg) & 0x40000000) >> 30
}
func (o *CCM_ANALOG_Type) SetPFD_480_PFD3_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_480.Reg, volatile.LoadUint32(&o.PFD_480.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_ANALOG_Type) GetPFD_480_PFD3_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480.Reg) & 0x80000000) >> 31
}

// CCM_ANALOG.PFD_480_SET: 480MHz Clock (PLL3) Phase Fractional Divider Control Register
func (o *CCM_ANALOG_Type) SetPFD_480_SET_PFD0_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_480_SET.Reg, volatile.LoadUint32(&o.PFD_480_SET.Reg)&^(0x3f)|value)
}
func (o *CCM_ANALOG_Type) GetPFD_480_SET_PFD0_FRAC() uint32 {
	return volatile.LoadUint32(&o.PFD_480_SET.Reg) & 0x3f
}
func (o *CCM_ANALOG_Type) SetPFD_480_SET_PFD0_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_480_SET.Reg, volatile.LoadUint32(&o.PFD_480_SET.Reg)&^(0x40)|value<<6)
}
func (o *CCM_ANALOG_Type) GetPFD_480_SET_PFD0_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_SET.Reg) & 0x40) >> 6
}
func (o *CCM_ANALOG_Type) SetPFD_480_SET_PFD0_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_480_SET.Reg, volatile.LoadUint32(&o.PFD_480_SET.Reg)&^(0x80)|value<<7)
}
func (o *CCM_ANALOG_Type) GetPFD_480_SET_PFD0_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_SET.Reg) & 0x80) >> 7
}
func (o *CCM_ANALOG_Type) SetPFD_480_SET_PFD1_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_480_SET.Reg, volatile.LoadUint32(&o.PFD_480_SET.Reg)&^(0x3f00)|value<<8)
}
func (o *CCM_ANALOG_Type) GetPFD_480_SET_PFD1_FRAC() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_SET.Reg) & 0x3f00) >> 8
}
func (o *CCM_ANALOG_Type) SetPFD_480_SET_PFD1_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_480_SET.Reg, volatile.LoadUint32(&o.PFD_480_SET.Reg)&^(0x4000)|value<<14)
}
func (o *CCM_ANALOG_Type) GetPFD_480_SET_PFD1_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_SET.Reg) & 0x4000) >> 14
}
func (o *CCM_ANALOG_Type) SetPFD_480_SET_PFD1_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_480_SET.Reg, volatile.LoadUint32(&o.PFD_480_SET.Reg)&^(0x8000)|value<<15)
}
func (o *CCM_ANALOG_Type) GetPFD_480_SET_PFD1_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_SET.Reg) & 0x8000) >> 15
}
func (o *CCM_ANALOG_Type) SetPFD_480_SET_PFD2_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_480_SET.Reg, volatile.LoadUint32(&o.PFD_480_SET.Reg)&^(0x3f0000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetPFD_480_SET_PFD2_FRAC() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_SET.Reg) & 0x3f0000) >> 16
}
func (o *CCM_ANALOG_Type) SetPFD_480_SET_PFD2_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_480_SET.Reg, volatile.LoadUint32(&o.PFD_480_SET.Reg)&^(0x400000)|value<<22)
}
func (o *CCM_ANALOG_Type) GetPFD_480_SET_PFD2_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_SET.Reg) & 0x400000) >> 22
}
func (o *CCM_ANALOG_Type) SetPFD_480_SET_PFD2_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_480_SET.Reg, volatile.LoadUint32(&o.PFD_480_SET.Reg)&^(0x800000)|value<<23)
}
func (o *CCM_ANALOG_Type) GetPFD_480_SET_PFD2_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_SET.Reg) & 0x800000) >> 23
}
func (o *CCM_ANALOG_Type) SetPFD_480_SET_PFD3_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_480_SET.Reg, volatile.LoadUint32(&o.PFD_480_SET.Reg)&^(0x3f000000)|value<<24)
}
func (o *CCM_ANALOG_Type) GetPFD_480_SET_PFD3_FRAC() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_SET.Reg) & 0x3f000000) >> 24
}
func (o *CCM_ANALOG_Type) SetPFD_480_SET_PFD3_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_480_SET.Reg, volatile.LoadUint32(&o.PFD_480_SET.Reg)&^(0x40000000)|value<<30)
}
func (o *CCM_ANALOG_Type) GetPFD_480_SET_PFD3_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_SET.Reg) & 0x40000000) >> 30
}
func (o *CCM_ANALOG_Type) SetPFD_480_SET_PFD3_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_480_SET.Reg, volatile.LoadUint32(&o.PFD_480_SET.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_ANALOG_Type) GetPFD_480_SET_PFD3_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_SET.Reg) & 0x80000000) >> 31
}

// CCM_ANALOG.PFD_480_CLR: 480MHz Clock (PLL3) Phase Fractional Divider Control Register
func (o *CCM_ANALOG_Type) SetPFD_480_CLR_PFD0_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_480_CLR.Reg, volatile.LoadUint32(&o.PFD_480_CLR.Reg)&^(0x3f)|value)
}
func (o *CCM_ANALOG_Type) GetPFD_480_CLR_PFD0_FRAC() uint32 {
	return volatile.LoadUint32(&o.PFD_480_CLR.Reg) & 0x3f
}
func (o *CCM_ANALOG_Type) SetPFD_480_CLR_PFD0_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_480_CLR.Reg, volatile.LoadUint32(&o.PFD_480_CLR.Reg)&^(0x40)|value<<6)
}
func (o *CCM_ANALOG_Type) GetPFD_480_CLR_PFD0_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_CLR.Reg) & 0x40) >> 6
}
func (o *CCM_ANALOG_Type) SetPFD_480_CLR_PFD0_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_480_CLR.Reg, volatile.LoadUint32(&o.PFD_480_CLR.Reg)&^(0x80)|value<<7)
}
func (o *CCM_ANALOG_Type) GetPFD_480_CLR_PFD0_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_CLR.Reg) & 0x80) >> 7
}
func (o *CCM_ANALOG_Type) SetPFD_480_CLR_PFD1_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_480_CLR.Reg, volatile.LoadUint32(&o.PFD_480_CLR.Reg)&^(0x3f00)|value<<8)
}
func (o *CCM_ANALOG_Type) GetPFD_480_CLR_PFD1_FRAC() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_CLR.Reg) & 0x3f00) >> 8
}
func (o *CCM_ANALOG_Type) SetPFD_480_CLR_PFD1_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_480_CLR.Reg, volatile.LoadUint32(&o.PFD_480_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *CCM_ANALOG_Type) GetPFD_480_CLR_PFD1_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_CLR.Reg) & 0x4000) >> 14
}
func (o *CCM_ANALOG_Type) SetPFD_480_CLR_PFD1_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_480_CLR.Reg, volatile.LoadUint32(&o.PFD_480_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *CCM_ANALOG_Type) GetPFD_480_CLR_PFD1_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_CLR.Reg) & 0x8000) >> 15
}
func (o *CCM_ANALOG_Type) SetPFD_480_CLR_PFD2_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_480_CLR.Reg, volatile.LoadUint32(&o.PFD_480_CLR.Reg)&^(0x3f0000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetPFD_480_CLR_PFD2_FRAC() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_CLR.Reg) & 0x3f0000) >> 16
}
func (o *CCM_ANALOG_Type) SetPFD_480_CLR_PFD2_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_480_CLR.Reg, volatile.LoadUint32(&o.PFD_480_CLR.Reg)&^(0x400000)|value<<22)
}
func (o *CCM_ANALOG_Type) GetPFD_480_CLR_PFD2_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_CLR.Reg) & 0x400000) >> 22
}
func (o *CCM_ANALOG_Type) SetPFD_480_CLR_PFD2_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_480_CLR.Reg, volatile.LoadUint32(&o.PFD_480_CLR.Reg)&^(0x800000)|value<<23)
}
func (o *CCM_ANALOG_Type) GetPFD_480_CLR_PFD2_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_CLR.Reg) & 0x800000) >> 23
}
func (o *CCM_ANALOG_Type) SetPFD_480_CLR_PFD3_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_480_CLR.Reg, volatile.LoadUint32(&o.PFD_480_CLR.Reg)&^(0x3f000000)|value<<24)
}
func (o *CCM_ANALOG_Type) GetPFD_480_CLR_PFD3_FRAC() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_CLR.Reg) & 0x3f000000) >> 24
}
func (o *CCM_ANALOG_Type) SetPFD_480_CLR_PFD3_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_480_CLR.Reg, volatile.LoadUint32(&o.PFD_480_CLR.Reg)&^(0x40000000)|value<<30)
}
func (o *CCM_ANALOG_Type) GetPFD_480_CLR_PFD3_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_CLR.Reg) & 0x40000000) >> 30
}
func (o *CCM_ANALOG_Type) SetPFD_480_CLR_PFD3_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_480_CLR.Reg, volatile.LoadUint32(&o.PFD_480_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_ANALOG_Type) GetPFD_480_CLR_PFD3_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_CLR.Reg) & 0x80000000) >> 31
}

// CCM_ANALOG.PFD_480_TOG: 480MHz Clock (PLL3) Phase Fractional Divider Control Register
func (o *CCM_ANALOG_Type) SetPFD_480_TOG_PFD0_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_480_TOG.Reg, volatile.LoadUint32(&o.PFD_480_TOG.Reg)&^(0x3f)|value)
}
func (o *CCM_ANALOG_Type) GetPFD_480_TOG_PFD0_FRAC() uint32 {
	return volatile.LoadUint32(&o.PFD_480_TOG.Reg) & 0x3f
}
func (o *CCM_ANALOG_Type) SetPFD_480_TOG_PFD0_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_480_TOG.Reg, volatile.LoadUint32(&o.PFD_480_TOG.Reg)&^(0x40)|value<<6)
}
func (o *CCM_ANALOG_Type) GetPFD_480_TOG_PFD0_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_TOG.Reg) & 0x40) >> 6
}
func (o *CCM_ANALOG_Type) SetPFD_480_TOG_PFD0_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_480_TOG.Reg, volatile.LoadUint32(&o.PFD_480_TOG.Reg)&^(0x80)|value<<7)
}
func (o *CCM_ANALOG_Type) GetPFD_480_TOG_PFD0_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_TOG.Reg) & 0x80) >> 7
}
func (o *CCM_ANALOG_Type) SetPFD_480_TOG_PFD1_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_480_TOG.Reg, volatile.LoadUint32(&o.PFD_480_TOG.Reg)&^(0x3f00)|value<<8)
}
func (o *CCM_ANALOG_Type) GetPFD_480_TOG_PFD1_FRAC() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_TOG.Reg) & 0x3f00) >> 8
}
func (o *CCM_ANALOG_Type) SetPFD_480_TOG_PFD1_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_480_TOG.Reg, volatile.LoadUint32(&o.PFD_480_TOG.Reg)&^(0x4000)|value<<14)
}
func (o *CCM_ANALOG_Type) GetPFD_480_TOG_PFD1_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_TOG.Reg) & 0x4000) >> 14
}
func (o *CCM_ANALOG_Type) SetPFD_480_TOG_PFD1_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_480_TOG.Reg, volatile.LoadUint32(&o.PFD_480_TOG.Reg)&^(0x8000)|value<<15)
}
func (o *CCM_ANALOG_Type) GetPFD_480_TOG_PFD1_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_TOG.Reg) & 0x8000) >> 15
}
func (o *CCM_ANALOG_Type) SetPFD_480_TOG_PFD2_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_480_TOG.Reg, volatile.LoadUint32(&o.PFD_480_TOG.Reg)&^(0x3f0000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetPFD_480_TOG_PFD2_FRAC() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_TOG.Reg) & 0x3f0000) >> 16
}
func (o *CCM_ANALOG_Type) SetPFD_480_TOG_PFD2_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_480_TOG.Reg, volatile.LoadUint32(&o.PFD_480_TOG.Reg)&^(0x400000)|value<<22)
}
func (o *CCM_ANALOG_Type) GetPFD_480_TOG_PFD2_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_TOG.Reg) & 0x400000) >> 22
}
func (o *CCM_ANALOG_Type) SetPFD_480_TOG_PFD2_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_480_TOG.Reg, volatile.LoadUint32(&o.PFD_480_TOG.Reg)&^(0x800000)|value<<23)
}
func (o *CCM_ANALOG_Type) GetPFD_480_TOG_PFD2_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_TOG.Reg) & 0x800000) >> 23
}
func (o *CCM_ANALOG_Type) SetPFD_480_TOG_PFD3_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_480_TOG.Reg, volatile.LoadUint32(&o.PFD_480_TOG.Reg)&^(0x3f000000)|value<<24)
}
func (o *CCM_ANALOG_Type) GetPFD_480_TOG_PFD3_FRAC() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_TOG.Reg) & 0x3f000000) >> 24
}
func (o *CCM_ANALOG_Type) SetPFD_480_TOG_PFD3_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_480_TOG.Reg, volatile.LoadUint32(&o.PFD_480_TOG.Reg)&^(0x40000000)|value<<30)
}
func (o *CCM_ANALOG_Type) GetPFD_480_TOG_PFD3_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_TOG.Reg) & 0x40000000) >> 30
}
func (o *CCM_ANALOG_Type) SetPFD_480_TOG_PFD3_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_480_TOG.Reg, volatile.LoadUint32(&o.PFD_480_TOG.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_ANALOG_Type) GetPFD_480_TOG_PFD3_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_480_TOG.Reg) & 0x80000000) >> 31
}

// CCM_ANALOG.PFD_528: 528MHz Clock (PLL2) Phase Fractional Divider Control Register
func (o *CCM_ANALOG_Type) SetPFD_528_PFD0_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_528.Reg, volatile.LoadUint32(&o.PFD_528.Reg)&^(0x3f)|value)
}
func (o *CCM_ANALOG_Type) GetPFD_528_PFD0_FRAC() uint32 {
	return volatile.LoadUint32(&o.PFD_528.Reg) & 0x3f
}
func (o *CCM_ANALOG_Type) SetPFD_528_PFD0_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_528.Reg, volatile.LoadUint32(&o.PFD_528.Reg)&^(0x40)|value<<6)
}
func (o *CCM_ANALOG_Type) GetPFD_528_PFD0_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528.Reg) & 0x40) >> 6
}
func (o *CCM_ANALOG_Type) SetPFD_528_PFD0_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_528.Reg, volatile.LoadUint32(&o.PFD_528.Reg)&^(0x80)|value<<7)
}
func (o *CCM_ANALOG_Type) GetPFD_528_PFD0_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528.Reg) & 0x80) >> 7
}
func (o *CCM_ANALOG_Type) SetPFD_528_PFD1_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_528.Reg, volatile.LoadUint32(&o.PFD_528.Reg)&^(0x3f00)|value<<8)
}
func (o *CCM_ANALOG_Type) GetPFD_528_PFD1_FRAC() uint32 {
	return (volatile.LoadUint32(&o.PFD_528.Reg) & 0x3f00) >> 8
}
func (o *CCM_ANALOG_Type) SetPFD_528_PFD1_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_528.Reg, volatile.LoadUint32(&o.PFD_528.Reg)&^(0x4000)|value<<14)
}
func (o *CCM_ANALOG_Type) GetPFD_528_PFD1_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528.Reg) & 0x4000) >> 14
}
func (o *CCM_ANALOG_Type) SetPFD_528_PFD1_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_528.Reg, volatile.LoadUint32(&o.PFD_528.Reg)&^(0x8000)|value<<15)
}
func (o *CCM_ANALOG_Type) GetPFD_528_PFD1_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528.Reg) & 0x8000) >> 15
}
func (o *CCM_ANALOG_Type) SetPFD_528_PFD2_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_528.Reg, volatile.LoadUint32(&o.PFD_528.Reg)&^(0x3f0000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetPFD_528_PFD2_FRAC() uint32 {
	return (volatile.LoadUint32(&o.PFD_528.Reg) & 0x3f0000) >> 16
}
func (o *CCM_ANALOG_Type) SetPFD_528_PFD2_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_528.Reg, volatile.LoadUint32(&o.PFD_528.Reg)&^(0x400000)|value<<22)
}
func (o *CCM_ANALOG_Type) GetPFD_528_PFD2_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528.Reg) & 0x400000) >> 22
}
func (o *CCM_ANALOG_Type) SetPFD_528_PFD2_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_528.Reg, volatile.LoadUint32(&o.PFD_528.Reg)&^(0x800000)|value<<23)
}
func (o *CCM_ANALOG_Type) GetPFD_528_PFD2_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528.Reg) & 0x800000) >> 23
}
func (o *CCM_ANALOG_Type) SetPFD_528_PFD3_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_528.Reg, volatile.LoadUint32(&o.PFD_528.Reg)&^(0x3f000000)|value<<24)
}
func (o *CCM_ANALOG_Type) GetPFD_528_PFD3_FRAC() uint32 {
	return (volatile.LoadUint32(&o.PFD_528.Reg) & 0x3f000000) >> 24
}
func (o *CCM_ANALOG_Type) SetPFD_528_PFD3_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_528.Reg, volatile.LoadUint32(&o.PFD_528.Reg)&^(0x40000000)|value<<30)
}
func (o *CCM_ANALOG_Type) GetPFD_528_PFD3_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528.Reg) & 0x40000000) >> 30
}
func (o *CCM_ANALOG_Type) SetPFD_528_PFD3_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_528.Reg, volatile.LoadUint32(&o.PFD_528.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_ANALOG_Type) GetPFD_528_PFD3_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528.Reg) & 0x80000000) >> 31
}

// CCM_ANALOG.PFD_528_SET: 528MHz Clock (PLL2) Phase Fractional Divider Control Register
func (o *CCM_ANALOG_Type) SetPFD_528_SET_PFD0_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_528_SET.Reg, volatile.LoadUint32(&o.PFD_528_SET.Reg)&^(0x3f)|value)
}
func (o *CCM_ANALOG_Type) GetPFD_528_SET_PFD0_FRAC() uint32 {
	return volatile.LoadUint32(&o.PFD_528_SET.Reg) & 0x3f
}
func (o *CCM_ANALOG_Type) SetPFD_528_SET_PFD0_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_528_SET.Reg, volatile.LoadUint32(&o.PFD_528_SET.Reg)&^(0x40)|value<<6)
}
func (o *CCM_ANALOG_Type) GetPFD_528_SET_PFD0_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_SET.Reg) & 0x40) >> 6
}
func (o *CCM_ANALOG_Type) SetPFD_528_SET_PFD0_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_528_SET.Reg, volatile.LoadUint32(&o.PFD_528_SET.Reg)&^(0x80)|value<<7)
}
func (o *CCM_ANALOG_Type) GetPFD_528_SET_PFD0_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_SET.Reg) & 0x80) >> 7
}
func (o *CCM_ANALOG_Type) SetPFD_528_SET_PFD1_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_528_SET.Reg, volatile.LoadUint32(&o.PFD_528_SET.Reg)&^(0x3f00)|value<<8)
}
func (o *CCM_ANALOG_Type) GetPFD_528_SET_PFD1_FRAC() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_SET.Reg) & 0x3f00) >> 8
}
func (o *CCM_ANALOG_Type) SetPFD_528_SET_PFD1_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_528_SET.Reg, volatile.LoadUint32(&o.PFD_528_SET.Reg)&^(0x4000)|value<<14)
}
func (o *CCM_ANALOG_Type) GetPFD_528_SET_PFD1_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_SET.Reg) & 0x4000) >> 14
}
func (o *CCM_ANALOG_Type) SetPFD_528_SET_PFD1_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_528_SET.Reg, volatile.LoadUint32(&o.PFD_528_SET.Reg)&^(0x8000)|value<<15)
}
func (o *CCM_ANALOG_Type) GetPFD_528_SET_PFD1_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_SET.Reg) & 0x8000) >> 15
}
func (o *CCM_ANALOG_Type) SetPFD_528_SET_PFD2_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_528_SET.Reg, volatile.LoadUint32(&o.PFD_528_SET.Reg)&^(0x3f0000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetPFD_528_SET_PFD2_FRAC() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_SET.Reg) & 0x3f0000) >> 16
}
func (o *CCM_ANALOG_Type) SetPFD_528_SET_PFD2_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_528_SET.Reg, volatile.LoadUint32(&o.PFD_528_SET.Reg)&^(0x400000)|value<<22)
}
func (o *CCM_ANALOG_Type) GetPFD_528_SET_PFD2_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_SET.Reg) & 0x400000) >> 22
}
func (o *CCM_ANALOG_Type) SetPFD_528_SET_PFD2_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_528_SET.Reg, volatile.LoadUint32(&o.PFD_528_SET.Reg)&^(0x800000)|value<<23)
}
func (o *CCM_ANALOG_Type) GetPFD_528_SET_PFD2_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_SET.Reg) & 0x800000) >> 23
}
func (o *CCM_ANALOG_Type) SetPFD_528_SET_PFD3_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_528_SET.Reg, volatile.LoadUint32(&o.PFD_528_SET.Reg)&^(0x3f000000)|value<<24)
}
func (o *CCM_ANALOG_Type) GetPFD_528_SET_PFD3_FRAC() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_SET.Reg) & 0x3f000000) >> 24
}
func (o *CCM_ANALOG_Type) SetPFD_528_SET_PFD3_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_528_SET.Reg, volatile.LoadUint32(&o.PFD_528_SET.Reg)&^(0x40000000)|value<<30)
}
func (o *CCM_ANALOG_Type) GetPFD_528_SET_PFD3_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_SET.Reg) & 0x40000000) >> 30
}
func (o *CCM_ANALOG_Type) SetPFD_528_SET_PFD3_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_528_SET.Reg, volatile.LoadUint32(&o.PFD_528_SET.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_ANALOG_Type) GetPFD_528_SET_PFD3_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_SET.Reg) & 0x80000000) >> 31
}

// CCM_ANALOG.PFD_528_CLR: 528MHz Clock (PLL2) Phase Fractional Divider Control Register
func (o *CCM_ANALOG_Type) SetPFD_528_CLR_PFD0_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_528_CLR.Reg, volatile.LoadUint32(&o.PFD_528_CLR.Reg)&^(0x3f)|value)
}
func (o *CCM_ANALOG_Type) GetPFD_528_CLR_PFD0_FRAC() uint32 {
	return volatile.LoadUint32(&o.PFD_528_CLR.Reg) & 0x3f
}
func (o *CCM_ANALOG_Type) SetPFD_528_CLR_PFD0_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_528_CLR.Reg, volatile.LoadUint32(&o.PFD_528_CLR.Reg)&^(0x40)|value<<6)
}
func (o *CCM_ANALOG_Type) GetPFD_528_CLR_PFD0_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_CLR.Reg) & 0x40) >> 6
}
func (o *CCM_ANALOG_Type) SetPFD_528_CLR_PFD0_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_528_CLR.Reg, volatile.LoadUint32(&o.PFD_528_CLR.Reg)&^(0x80)|value<<7)
}
func (o *CCM_ANALOG_Type) GetPFD_528_CLR_PFD0_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_CLR.Reg) & 0x80) >> 7
}
func (o *CCM_ANALOG_Type) SetPFD_528_CLR_PFD1_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_528_CLR.Reg, volatile.LoadUint32(&o.PFD_528_CLR.Reg)&^(0x3f00)|value<<8)
}
func (o *CCM_ANALOG_Type) GetPFD_528_CLR_PFD1_FRAC() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_CLR.Reg) & 0x3f00) >> 8
}
func (o *CCM_ANALOG_Type) SetPFD_528_CLR_PFD1_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_528_CLR.Reg, volatile.LoadUint32(&o.PFD_528_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *CCM_ANALOG_Type) GetPFD_528_CLR_PFD1_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_CLR.Reg) & 0x4000) >> 14
}
func (o *CCM_ANALOG_Type) SetPFD_528_CLR_PFD1_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_528_CLR.Reg, volatile.LoadUint32(&o.PFD_528_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *CCM_ANALOG_Type) GetPFD_528_CLR_PFD1_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_CLR.Reg) & 0x8000) >> 15
}
func (o *CCM_ANALOG_Type) SetPFD_528_CLR_PFD2_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_528_CLR.Reg, volatile.LoadUint32(&o.PFD_528_CLR.Reg)&^(0x3f0000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetPFD_528_CLR_PFD2_FRAC() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_CLR.Reg) & 0x3f0000) >> 16
}
func (o *CCM_ANALOG_Type) SetPFD_528_CLR_PFD2_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_528_CLR.Reg, volatile.LoadUint32(&o.PFD_528_CLR.Reg)&^(0x400000)|value<<22)
}
func (o *CCM_ANALOG_Type) GetPFD_528_CLR_PFD2_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_CLR.Reg) & 0x400000) >> 22
}
func (o *CCM_ANALOG_Type) SetPFD_528_CLR_PFD2_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_528_CLR.Reg, volatile.LoadUint32(&o.PFD_528_CLR.Reg)&^(0x800000)|value<<23)
}
func (o *CCM_ANALOG_Type) GetPFD_528_CLR_PFD2_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_CLR.Reg) & 0x800000) >> 23
}
func (o *CCM_ANALOG_Type) SetPFD_528_CLR_PFD3_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_528_CLR.Reg, volatile.LoadUint32(&o.PFD_528_CLR.Reg)&^(0x3f000000)|value<<24)
}
func (o *CCM_ANALOG_Type) GetPFD_528_CLR_PFD3_FRAC() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_CLR.Reg) & 0x3f000000) >> 24
}
func (o *CCM_ANALOG_Type) SetPFD_528_CLR_PFD3_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_528_CLR.Reg, volatile.LoadUint32(&o.PFD_528_CLR.Reg)&^(0x40000000)|value<<30)
}
func (o *CCM_ANALOG_Type) GetPFD_528_CLR_PFD3_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_CLR.Reg) & 0x40000000) >> 30
}
func (o *CCM_ANALOG_Type) SetPFD_528_CLR_PFD3_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_528_CLR.Reg, volatile.LoadUint32(&o.PFD_528_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_ANALOG_Type) GetPFD_528_CLR_PFD3_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_CLR.Reg) & 0x80000000) >> 31
}

// CCM_ANALOG.PFD_528_TOG: 528MHz Clock (PLL2) Phase Fractional Divider Control Register
func (o *CCM_ANALOG_Type) SetPFD_528_TOG_PFD0_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_528_TOG.Reg, volatile.LoadUint32(&o.PFD_528_TOG.Reg)&^(0x3f)|value)
}
func (o *CCM_ANALOG_Type) GetPFD_528_TOG_PFD0_FRAC() uint32 {
	return volatile.LoadUint32(&o.PFD_528_TOG.Reg) & 0x3f
}
func (o *CCM_ANALOG_Type) SetPFD_528_TOG_PFD0_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_528_TOG.Reg, volatile.LoadUint32(&o.PFD_528_TOG.Reg)&^(0x40)|value<<6)
}
func (o *CCM_ANALOG_Type) GetPFD_528_TOG_PFD0_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_TOG.Reg) & 0x40) >> 6
}
func (o *CCM_ANALOG_Type) SetPFD_528_TOG_PFD0_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_528_TOG.Reg, volatile.LoadUint32(&o.PFD_528_TOG.Reg)&^(0x80)|value<<7)
}
func (o *CCM_ANALOG_Type) GetPFD_528_TOG_PFD0_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_TOG.Reg) & 0x80) >> 7
}
func (o *CCM_ANALOG_Type) SetPFD_528_TOG_PFD1_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_528_TOG.Reg, volatile.LoadUint32(&o.PFD_528_TOG.Reg)&^(0x3f00)|value<<8)
}
func (o *CCM_ANALOG_Type) GetPFD_528_TOG_PFD1_FRAC() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_TOG.Reg) & 0x3f00) >> 8
}
func (o *CCM_ANALOG_Type) SetPFD_528_TOG_PFD1_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_528_TOG.Reg, volatile.LoadUint32(&o.PFD_528_TOG.Reg)&^(0x4000)|value<<14)
}
func (o *CCM_ANALOG_Type) GetPFD_528_TOG_PFD1_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_TOG.Reg) & 0x4000) >> 14
}
func (o *CCM_ANALOG_Type) SetPFD_528_TOG_PFD1_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_528_TOG.Reg, volatile.LoadUint32(&o.PFD_528_TOG.Reg)&^(0x8000)|value<<15)
}
func (o *CCM_ANALOG_Type) GetPFD_528_TOG_PFD1_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_TOG.Reg) & 0x8000) >> 15
}
func (o *CCM_ANALOG_Type) SetPFD_528_TOG_PFD2_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_528_TOG.Reg, volatile.LoadUint32(&o.PFD_528_TOG.Reg)&^(0x3f0000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetPFD_528_TOG_PFD2_FRAC() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_TOG.Reg) & 0x3f0000) >> 16
}
func (o *CCM_ANALOG_Type) SetPFD_528_TOG_PFD2_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_528_TOG.Reg, volatile.LoadUint32(&o.PFD_528_TOG.Reg)&^(0x400000)|value<<22)
}
func (o *CCM_ANALOG_Type) GetPFD_528_TOG_PFD2_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_TOG.Reg) & 0x400000) >> 22
}
func (o *CCM_ANALOG_Type) SetPFD_528_TOG_PFD2_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_528_TOG.Reg, volatile.LoadUint32(&o.PFD_528_TOG.Reg)&^(0x800000)|value<<23)
}
func (o *CCM_ANALOG_Type) GetPFD_528_TOG_PFD2_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_TOG.Reg) & 0x800000) >> 23
}
func (o *CCM_ANALOG_Type) SetPFD_528_TOG_PFD3_FRAC(value uint32) {
	volatile.StoreUint32(&o.PFD_528_TOG.Reg, volatile.LoadUint32(&o.PFD_528_TOG.Reg)&^(0x3f000000)|value<<24)
}
func (o *CCM_ANALOG_Type) GetPFD_528_TOG_PFD3_FRAC() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_TOG.Reg) & 0x3f000000) >> 24
}
func (o *CCM_ANALOG_Type) SetPFD_528_TOG_PFD3_STABLE(value uint32) {
	volatile.StoreUint32(&o.PFD_528_TOG.Reg, volatile.LoadUint32(&o.PFD_528_TOG.Reg)&^(0x40000000)|value<<30)
}
func (o *CCM_ANALOG_Type) GetPFD_528_TOG_PFD3_STABLE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_TOG.Reg) & 0x40000000) >> 30
}
func (o *CCM_ANALOG_Type) SetPFD_528_TOG_PFD3_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.PFD_528_TOG.Reg, volatile.LoadUint32(&o.PFD_528_TOG.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_ANALOG_Type) GetPFD_528_TOG_PFD3_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.PFD_528_TOG.Reg) & 0x80000000) >> 31
}

// CCM_ANALOG.MISC0: Miscellaneous Register 0
func (o *CCM_ANALOG_Type) SetMISC0_REFTOP_PWD(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x1)|value)
}
func (o *CCM_ANALOG_Type) GetMISC0_REFTOP_PWD() uint32 {
	return volatile.LoadUint32(&o.MISC0.Reg) & 0x1
}
func (o *CCM_ANALOG_Type) SetMISC0_REFTOP_SELFBIASOFF(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x8)|value<<3)
}
func (o *CCM_ANALOG_Type) GetMISC0_REFTOP_SELFBIASOFF() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x8) >> 3
}
func (o *CCM_ANALOG_Type) SetMISC0_REFTOP_VBGADJ(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x70)|value<<4)
}
func (o *CCM_ANALOG_Type) GetMISC0_REFTOP_VBGADJ() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x70) >> 4
}
func (o *CCM_ANALOG_Type) SetMISC0_REFTOP_VBGUP(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x80)|value<<7)
}
func (o *CCM_ANALOG_Type) GetMISC0_REFTOP_VBGUP() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x80) >> 7
}
func (o *CCM_ANALOG_Type) SetMISC0_STOP_MODE_CONFIG(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0xc00)|value<<10)
}
func (o *CCM_ANALOG_Type) GetMISC0_STOP_MODE_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0xc00) >> 10
}
func (o *CCM_ANALOG_Type) SetMISC0_DISCON_HIGH_SNVS(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x1000)|value<<12)
}
func (o *CCM_ANALOG_Type) GetMISC0_DISCON_HIGH_SNVS() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x1000) >> 12
}
func (o *CCM_ANALOG_Type) SetMISC0_OSC_I(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x6000)|value<<13)
}
func (o *CCM_ANALOG_Type) GetMISC0_OSC_I() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x6000) >> 13
}
func (o *CCM_ANALOG_Type) SetMISC0_OSC_XTALOK(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x8000)|value<<15)
}
func (o *CCM_ANALOG_Type) GetMISC0_OSC_XTALOK() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x8000) >> 15
}
func (o *CCM_ANALOG_Type) SetMISC0_OSC_XTALOK_EN(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x10000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetMISC0_OSC_XTALOK_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x10000) >> 16
}
func (o *CCM_ANALOG_Type) SetMISC0_CLKGATE_CTRL(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x2000000)|value<<25)
}
func (o *CCM_ANALOG_Type) GetMISC0_CLKGATE_CTRL() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x2000000) >> 25
}
func (o *CCM_ANALOG_Type) SetMISC0_CLKGATE_DELAY(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x1c000000)|value<<26)
}
func (o *CCM_ANALOG_Type) GetMISC0_CLKGATE_DELAY() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x1c000000) >> 26
}
func (o *CCM_ANALOG_Type) SetMISC0_RTC_XTAL_SOURCE(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x20000000)|value<<29)
}
func (o *CCM_ANALOG_Type) GetMISC0_RTC_XTAL_SOURCE() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x20000000) >> 29
}
func (o *CCM_ANALOG_Type) SetMISC0_XTAL_24M_PWD(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x40000000)|value<<30)
}
func (o *CCM_ANALOG_Type) GetMISC0_XTAL_24M_PWD() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x40000000) >> 30
}

// CCM_ANALOG.MISC0_SET: Miscellaneous Register 0
func (o *CCM_ANALOG_Type) SetMISC0_SET_REFTOP_PWD(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x1)|value)
}
func (o *CCM_ANALOG_Type) GetMISC0_SET_REFTOP_PWD() uint32 {
	return volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x1
}
func (o *CCM_ANALOG_Type) SetMISC0_SET_REFTOP_SELFBIASOFF(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x8)|value<<3)
}
func (o *CCM_ANALOG_Type) GetMISC0_SET_REFTOP_SELFBIASOFF() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x8) >> 3
}
func (o *CCM_ANALOG_Type) SetMISC0_SET_REFTOP_VBGADJ(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x70)|value<<4)
}
func (o *CCM_ANALOG_Type) GetMISC0_SET_REFTOP_VBGADJ() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x70) >> 4
}
func (o *CCM_ANALOG_Type) SetMISC0_SET_REFTOP_VBGUP(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x80)|value<<7)
}
func (o *CCM_ANALOG_Type) GetMISC0_SET_REFTOP_VBGUP() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x80) >> 7
}
func (o *CCM_ANALOG_Type) SetMISC0_SET_STOP_MODE_CONFIG(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0xc00)|value<<10)
}
func (o *CCM_ANALOG_Type) GetMISC0_SET_STOP_MODE_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0xc00) >> 10
}
func (o *CCM_ANALOG_Type) SetMISC0_SET_DISCON_HIGH_SNVS(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x1000)|value<<12)
}
func (o *CCM_ANALOG_Type) GetMISC0_SET_DISCON_HIGH_SNVS() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x1000) >> 12
}
func (o *CCM_ANALOG_Type) SetMISC0_SET_OSC_I(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x6000)|value<<13)
}
func (o *CCM_ANALOG_Type) GetMISC0_SET_OSC_I() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x6000) >> 13
}
func (o *CCM_ANALOG_Type) SetMISC0_SET_OSC_XTALOK(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x8000)|value<<15)
}
func (o *CCM_ANALOG_Type) GetMISC0_SET_OSC_XTALOK() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x8000) >> 15
}
func (o *CCM_ANALOG_Type) SetMISC0_SET_OSC_XTALOK_EN(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x10000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetMISC0_SET_OSC_XTALOK_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x10000) >> 16
}
func (o *CCM_ANALOG_Type) SetMISC0_SET_CLKGATE_CTRL(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x2000000)|value<<25)
}
func (o *CCM_ANALOG_Type) GetMISC0_SET_CLKGATE_CTRL() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x2000000) >> 25
}
func (o *CCM_ANALOG_Type) SetMISC0_SET_CLKGATE_DELAY(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x1c000000)|value<<26)
}
func (o *CCM_ANALOG_Type) GetMISC0_SET_CLKGATE_DELAY() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x1c000000) >> 26
}
func (o *CCM_ANALOG_Type) SetMISC0_SET_RTC_XTAL_SOURCE(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x20000000)|value<<29)
}
func (o *CCM_ANALOG_Type) GetMISC0_SET_RTC_XTAL_SOURCE() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x20000000) >> 29
}
func (o *CCM_ANALOG_Type) SetMISC0_SET_XTAL_24M_PWD(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x40000000)|value<<30)
}
func (o *CCM_ANALOG_Type) GetMISC0_SET_XTAL_24M_PWD() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x40000000) >> 30
}

// CCM_ANALOG.MISC0_CLR: Miscellaneous Register 0
func (o *CCM_ANALOG_Type) SetMISC0_CLR_REFTOP_PWD(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x1)|value)
}
func (o *CCM_ANALOG_Type) GetMISC0_CLR_REFTOP_PWD() uint32 {
	return volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x1
}
func (o *CCM_ANALOG_Type) SetMISC0_CLR_REFTOP_SELFBIASOFF(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x8)|value<<3)
}
func (o *CCM_ANALOG_Type) GetMISC0_CLR_REFTOP_SELFBIASOFF() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x8) >> 3
}
func (o *CCM_ANALOG_Type) SetMISC0_CLR_REFTOP_VBGADJ(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x70)|value<<4)
}
func (o *CCM_ANALOG_Type) GetMISC0_CLR_REFTOP_VBGADJ() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x70) >> 4
}
func (o *CCM_ANALOG_Type) SetMISC0_CLR_REFTOP_VBGUP(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x80)|value<<7)
}
func (o *CCM_ANALOG_Type) GetMISC0_CLR_REFTOP_VBGUP() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x80) >> 7
}
func (o *CCM_ANALOG_Type) SetMISC0_CLR_STOP_MODE_CONFIG(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0xc00)|value<<10)
}
func (o *CCM_ANALOG_Type) GetMISC0_CLR_STOP_MODE_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0xc00) >> 10
}
func (o *CCM_ANALOG_Type) SetMISC0_CLR_DISCON_HIGH_SNVS(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *CCM_ANALOG_Type) GetMISC0_CLR_DISCON_HIGH_SNVS() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x1000) >> 12
}
func (o *CCM_ANALOG_Type) SetMISC0_CLR_OSC_I(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x6000)|value<<13)
}
func (o *CCM_ANALOG_Type) GetMISC0_CLR_OSC_I() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x6000) >> 13
}
func (o *CCM_ANALOG_Type) SetMISC0_CLR_OSC_XTALOK(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *CCM_ANALOG_Type) GetMISC0_CLR_OSC_XTALOK() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x8000) >> 15
}
func (o *CCM_ANALOG_Type) SetMISC0_CLR_OSC_XTALOK_EN(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetMISC0_CLR_OSC_XTALOK_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x10000) >> 16
}
func (o *CCM_ANALOG_Type) SetMISC0_CLR_CLKGATE_CTRL(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x2000000)|value<<25)
}
func (o *CCM_ANALOG_Type) GetMISC0_CLR_CLKGATE_CTRL() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x2000000) >> 25
}
func (o *CCM_ANALOG_Type) SetMISC0_CLR_CLKGATE_DELAY(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x1c000000)|value<<26)
}
func (o *CCM_ANALOG_Type) GetMISC0_CLR_CLKGATE_DELAY() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x1c000000) >> 26
}
func (o *CCM_ANALOG_Type) SetMISC0_CLR_RTC_XTAL_SOURCE(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x20000000)|value<<29)
}
func (o *CCM_ANALOG_Type) GetMISC0_CLR_RTC_XTAL_SOURCE() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x20000000) >> 29
}
func (o *CCM_ANALOG_Type) SetMISC0_CLR_XTAL_24M_PWD(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x40000000)|value<<30)
}
func (o *CCM_ANALOG_Type) GetMISC0_CLR_XTAL_24M_PWD() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x40000000) >> 30
}

// CCM_ANALOG.MISC0_TOG: Miscellaneous Register 0
func (o *CCM_ANALOG_Type) SetMISC0_TOG_REFTOP_PWD(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x1)|value)
}
func (o *CCM_ANALOG_Type) GetMISC0_TOG_REFTOP_PWD() uint32 {
	return volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x1
}
func (o *CCM_ANALOG_Type) SetMISC0_TOG_REFTOP_SELFBIASOFF(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x8)|value<<3)
}
func (o *CCM_ANALOG_Type) GetMISC0_TOG_REFTOP_SELFBIASOFF() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x8) >> 3
}
func (o *CCM_ANALOG_Type) SetMISC0_TOG_REFTOP_VBGADJ(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x70)|value<<4)
}
func (o *CCM_ANALOG_Type) GetMISC0_TOG_REFTOP_VBGADJ() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x70) >> 4
}
func (o *CCM_ANALOG_Type) SetMISC0_TOG_REFTOP_VBGUP(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x80)|value<<7)
}
func (o *CCM_ANALOG_Type) GetMISC0_TOG_REFTOP_VBGUP() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x80) >> 7
}
func (o *CCM_ANALOG_Type) SetMISC0_TOG_STOP_MODE_CONFIG(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0xc00)|value<<10)
}
func (o *CCM_ANALOG_Type) GetMISC0_TOG_STOP_MODE_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0xc00) >> 10
}
func (o *CCM_ANALOG_Type) SetMISC0_TOG_DISCON_HIGH_SNVS(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x1000)|value<<12)
}
func (o *CCM_ANALOG_Type) GetMISC0_TOG_DISCON_HIGH_SNVS() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x1000) >> 12
}
func (o *CCM_ANALOG_Type) SetMISC0_TOG_OSC_I(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x6000)|value<<13)
}
func (o *CCM_ANALOG_Type) GetMISC0_TOG_OSC_I() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x6000) >> 13
}
func (o *CCM_ANALOG_Type) SetMISC0_TOG_OSC_XTALOK(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x8000)|value<<15)
}
func (o *CCM_ANALOG_Type) GetMISC0_TOG_OSC_XTALOK() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x8000) >> 15
}
func (o *CCM_ANALOG_Type) SetMISC0_TOG_OSC_XTALOK_EN(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x10000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetMISC0_TOG_OSC_XTALOK_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x10000) >> 16
}
func (o *CCM_ANALOG_Type) SetMISC0_TOG_CLKGATE_CTRL(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x2000000)|value<<25)
}
func (o *CCM_ANALOG_Type) GetMISC0_TOG_CLKGATE_CTRL() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x2000000) >> 25
}
func (o *CCM_ANALOG_Type) SetMISC0_TOG_CLKGATE_DELAY(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x1c000000)|value<<26)
}
func (o *CCM_ANALOG_Type) GetMISC0_TOG_CLKGATE_DELAY() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x1c000000) >> 26
}
func (o *CCM_ANALOG_Type) SetMISC0_TOG_RTC_XTAL_SOURCE(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x20000000)|value<<29)
}
func (o *CCM_ANALOG_Type) GetMISC0_TOG_RTC_XTAL_SOURCE() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x20000000) >> 29
}
func (o *CCM_ANALOG_Type) SetMISC0_TOG_XTAL_24M_PWD(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x40000000)|value<<30)
}
func (o *CCM_ANALOG_Type) GetMISC0_TOG_XTAL_24M_PWD() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x40000000) >> 30
}

// CCM_ANALOG.MISC1: Miscellaneous Register 1
func (o *CCM_ANALOG_Type) SetMISC1_PFD_480_AUTOGATE_EN(value uint32) {
	volatile.StoreUint32(&o.MISC1.Reg, volatile.LoadUint32(&o.MISC1.Reg)&^(0x10000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetMISC1_PFD_480_AUTOGATE_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC1.Reg) & 0x10000) >> 16
}
func (o *CCM_ANALOG_Type) SetMISC1_PFD_528_AUTOGATE_EN(value uint32) {
	volatile.StoreUint32(&o.MISC1.Reg, volatile.LoadUint32(&o.MISC1.Reg)&^(0x20000)|value<<17)
}
func (o *CCM_ANALOG_Type) GetMISC1_PFD_528_AUTOGATE_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC1.Reg) & 0x20000) >> 17
}
func (o *CCM_ANALOG_Type) SetMISC1_IRQ_TEMPPANIC(value uint32) {
	volatile.StoreUint32(&o.MISC1.Reg, volatile.LoadUint32(&o.MISC1.Reg)&^(0x8000000)|value<<27)
}
func (o *CCM_ANALOG_Type) GetMISC1_IRQ_TEMPPANIC() uint32 {
	return (volatile.LoadUint32(&o.MISC1.Reg) & 0x8000000) >> 27
}
func (o *CCM_ANALOG_Type) SetMISC1_IRQ_TEMPLOW(value uint32) {
	volatile.StoreUint32(&o.MISC1.Reg, volatile.LoadUint32(&o.MISC1.Reg)&^(0x10000000)|value<<28)
}
func (o *CCM_ANALOG_Type) GetMISC1_IRQ_TEMPLOW() uint32 {
	return (volatile.LoadUint32(&o.MISC1.Reg) & 0x10000000) >> 28
}
func (o *CCM_ANALOG_Type) SetMISC1_IRQ_TEMPHIGH(value uint32) {
	volatile.StoreUint32(&o.MISC1.Reg, volatile.LoadUint32(&o.MISC1.Reg)&^(0x20000000)|value<<29)
}
func (o *CCM_ANALOG_Type) GetMISC1_IRQ_TEMPHIGH() uint32 {
	return (volatile.LoadUint32(&o.MISC1.Reg) & 0x20000000) >> 29
}
func (o *CCM_ANALOG_Type) SetMISC1_IRQ_ANA_BO(value uint32) {
	volatile.StoreUint32(&o.MISC1.Reg, volatile.LoadUint32(&o.MISC1.Reg)&^(0x40000000)|value<<30)
}
func (o *CCM_ANALOG_Type) GetMISC1_IRQ_ANA_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC1.Reg) & 0x40000000) >> 30
}
func (o *CCM_ANALOG_Type) SetMISC1_IRQ_DIG_BO(value uint32) {
	volatile.StoreUint32(&o.MISC1.Reg, volatile.LoadUint32(&o.MISC1.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_ANALOG_Type) GetMISC1_IRQ_DIG_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC1.Reg) & 0x80000000) >> 31
}

// CCM_ANALOG.MISC1_SET: Miscellaneous Register 1
func (o *CCM_ANALOG_Type) SetMISC1_SET_PFD_480_AUTOGATE_EN(value uint32) {
	volatile.StoreUint32(&o.MISC1_SET.Reg, volatile.LoadUint32(&o.MISC1_SET.Reg)&^(0x10000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetMISC1_SET_PFD_480_AUTOGATE_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC1_SET.Reg) & 0x10000) >> 16
}
func (o *CCM_ANALOG_Type) SetMISC1_SET_PFD_528_AUTOGATE_EN(value uint32) {
	volatile.StoreUint32(&o.MISC1_SET.Reg, volatile.LoadUint32(&o.MISC1_SET.Reg)&^(0x20000)|value<<17)
}
func (o *CCM_ANALOG_Type) GetMISC1_SET_PFD_528_AUTOGATE_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC1_SET.Reg) & 0x20000) >> 17
}
func (o *CCM_ANALOG_Type) SetMISC1_SET_IRQ_TEMPPANIC(value uint32) {
	volatile.StoreUint32(&o.MISC1_SET.Reg, volatile.LoadUint32(&o.MISC1_SET.Reg)&^(0x8000000)|value<<27)
}
func (o *CCM_ANALOG_Type) GetMISC1_SET_IRQ_TEMPPANIC() uint32 {
	return (volatile.LoadUint32(&o.MISC1_SET.Reg) & 0x8000000) >> 27
}
func (o *CCM_ANALOG_Type) SetMISC1_SET_IRQ_TEMPLOW(value uint32) {
	volatile.StoreUint32(&o.MISC1_SET.Reg, volatile.LoadUint32(&o.MISC1_SET.Reg)&^(0x10000000)|value<<28)
}
func (o *CCM_ANALOG_Type) GetMISC1_SET_IRQ_TEMPLOW() uint32 {
	return (volatile.LoadUint32(&o.MISC1_SET.Reg) & 0x10000000) >> 28
}
func (o *CCM_ANALOG_Type) SetMISC1_SET_IRQ_TEMPHIGH(value uint32) {
	volatile.StoreUint32(&o.MISC1_SET.Reg, volatile.LoadUint32(&o.MISC1_SET.Reg)&^(0x20000000)|value<<29)
}
func (o *CCM_ANALOG_Type) GetMISC1_SET_IRQ_TEMPHIGH() uint32 {
	return (volatile.LoadUint32(&o.MISC1_SET.Reg) & 0x20000000) >> 29
}
func (o *CCM_ANALOG_Type) SetMISC1_SET_IRQ_ANA_BO(value uint32) {
	volatile.StoreUint32(&o.MISC1_SET.Reg, volatile.LoadUint32(&o.MISC1_SET.Reg)&^(0x40000000)|value<<30)
}
func (o *CCM_ANALOG_Type) GetMISC1_SET_IRQ_ANA_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC1_SET.Reg) & 0x40000000) >> 30
}
func (o *CCM_ANALOG_Type) SetMISC1_SET_IRQ_DIG_BO(value uint32) {
	volatile.StoreUint32(&o.MISC1_SET.Reg, volatile.LoadUint32(&o.MISC1_SET.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_ANALOG_Type) GetMISC1_SET_IRQ_DIG_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC1_SET.Reg) & 0x80000000) >> 31
}

// CCM_ANALOG.MISC1_CLR: Miscellaneous Register 1
func (o *CCM_ANALOG_Type) SetMISC1_CLR_PFD_480_AUTOGATE_EN(value uint32) {
	volatile.StoreUint32(&o.MISC1_CLR.Reg, volatile.LoadUint32(&o.MISC1_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetMISC1_CLR_PFD_480_AUTOGATE_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC1_CLR.Reg) & 0x10000) >> 16
}
func (o *CCM_ANALOG_Type) SetMISC1_CLR_PFD_528_AUTOGATE_EN(value uint32) {
	volatile.StoreUint32(&o.MISC1_CLR.Reg, volatile.LoadUint32(&o.MISC1_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *CCM_ANALOG_Type) GetMISC1_CLR_PFD_528_AUTOGATE_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC1_CLR.Reg) & 0x20000) >> 17
}
func (o *CCM_ANALOG_Type) SetMISC1_CLR_IRQ_TEMPPANIC(value uint32) {
	volatile.StoreUint32(&o.MISC1_CLR.Reg, volatile.LoadUint32(&o.MISC1_CLR.Reg)&^(0x8000000)|value<<27)
}
func (o *CCM_ANALOG_Type) GetMISC1_CLR_IRQ_TEMPPANIC() uint32 {
	return (volatile.LoadUint32(&o.MISC1_CLR.Reg) & 0x8000000) >> 27
}
func (o *CCM_ANALOG_Type) SetMISC1_CLR_IRQ_TEMPLOW(value uint32) {
	volatile.StoreUint32(&o.MISC1_CLR.Reg, volatile.LoadUint32(&o.MISC1_CLR.Reg)&^(0x10000000)|value<<28)
}
func (o *CCM_ANALOG_Type) GetMISC1_CLR_IRQ_TEMPLOW() uint32 {
	return (volatile.LoadUint32(&o.MISC1_CLR.Reg) & 0x10000000) >> 28
}
func (o *CCM_ANALOG_Type) SetMISC1_CLR_IRQ_TEMPHIGH(value uint32) {
	volatile.StoreUint32(&o.MISC1_CLR.Reg, volatile.LoadUint32(&o.MISC1_CLR.Reg)&^(0x20000000)|value<<29)
}
func (o *CCM_ANALOG_Type) GetMISC1_CLR_IRQ_TEMPHIGH() uint32 {
	return (volatile.LoadUint32(&o.MISC1_CLR.Reg) & 0x20000000) >> 29
}
func (o *CCM_ANALOG_Type) SetMISC1_CLR_IRQ_ANA_BO(value uint32) {
	volatile.StoreUint32(&o.MISC1_CLR.Reg, volatile.LoadUint32(&o.MISC1_CLR.Reg)&^(0x40000000)|value<<30)
}
func (o *CCM_ANALOG_Type) GetMISC1_CLR_IRQ_ANA_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC1_CLR.Reg) & 0x40000000) >> 30
}
func (o *CCM_ANALOG_Type) SetMISC1_CLR_IRQ_DIG_BO(value uint32) {
	volatile.StoreUint32(&o.MISC1_CLR.Reg, volatile.LoadUint32(&o.MISC1_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_ANALOG_Type) GetMISC1_CLR_IRQ_DIG_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC1_CLR.Reg) & 0x80000000) >> 31
}

// CCM_ANALOG.MISC1_TOG: Miscellaneous Register 1
func (o *CCM_ANALOG_Type) SetMISC1_TOG_PFD_480_AUTOGATE_EN(value uint32) {
	volatile.StoreUint32(&o.MISC1_TOG.Reg, volatile.LoadUint32(&o.MISC1_TOG.Reg)&^(0x10000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetMISC1_TOG_PFD_480_AUTOGATE_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC1_TOG.Reg) & 0x10000) >> 16
}
func (o *CCM_ANALOG_Type) SetMISC1_TOG_PFD_528_AUTOGATE_EN(value uint32) {
	volatile.StoreUint32(&o.MISC1_TOG.Reg, volatile.LoadUint32(&o.MISC1_TOG.Reg)&^(0x20000)|value<<17)
}
func (o *CCM_ANALOG_Type) GetMISC1_TOG_PFD_528_AUTOGATE_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC1_TOG.Reg) & 0x20000) >> 17
}
func (o *CCM_ANALOG_Type) SetMISC1_TOG_IRQ_TEMPPANIC(value uint32) {
	volatile.StoreUint32(&o.MISC1_TOG.Reg, volatile.LoadUint32(&o.MISC1_TOG.Reg)&^(0x8000000)|value<<27)
}
func (o *CCM_ANALOG_Type) GetMISC1_TOG_IRQ_TEMPPANIC() uint32 {
	return (volatile.LoadUint32(&o.MISC1_TOG.Reg) & 0x8000000) >> 27
}
func (o *CCM_ANALOG_Type) SetMISC1_TOG_IRQ_TEMPLOW(value uint32) {
	volatile.StoreUint32(&o.MISC1_TOG.Reg, volatile.LoadUint32(&o.MISC1_TOG.Reg)&^(0x10000000)|value<<28)
}
func (o *CCM_ANALOG_Type) GetMISC1_TOG_IRQ_TEMPLOW() uint32 {
	return (volatile.LoadUint32(&o.MISC1_TOG.Reg) & 0x10000000) >> 28
}
func (o *CCM_ANALOG_Type) SetMISC1_TOG_IRQ_TEMPHIGH(value uint32) {
	volatile.StoreUint32(&o.MISC1_TOG.Reg, volatile.LoadUint32(&o.MISC1_TOG.Reg)&^(0x20000000)|value<<29)
}
func (o *CCM_ANALOG_Type) GetMISC1_TOG_IRQ_TEMPHIGH() uint32 {
	return (volatile.LoadUint32(&o.MISC1_TOG.Reg) & 0x20000000) >> 29
}
func (o *CCM_ANALOG_Type) SetMISC1_TOG_IRQ_ANA_BO(value uint32) {
	volatile.StoreUint32(&o.MISC1_TOG.Reg, volatile.LoadUint32(&o.MISC1_TOG.Reg)&^(0x40000000)|value<<30)
}
func (o *CCM_ANALOG_Type) GetMISC1_TOG_IRQ_ANA_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC1_TOG.Reg) & 0x40000000) >> 30
}
func (o *CCM_ANALOG_Type) SetMISC1_TOG_IRQ_DIG_BO(value uint32) {
	volatile.StoreUint32(&o.MISC1_TOG.Reg, volatile.LoadUint32(&o.MISC1_TOG.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_ANALOG_Type) GetMISC1_TOG_IRQ_DIG_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC1_TOG.Reg) & 0x80000000) >> 31
}

// CCM_ANALOG.MISC2: Miscellaneous Register 2
func (o *CCM_ANALOG_Type) SetMISC2_REG0_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x7)|value)
}
func (o *CCM_ANALOG_Type) GetMISC2_REG0_BO_OFFSET() uint32 {
	return volatile.LoadUint32(&o.MISC2.Reg) & 0x7
}
func (o *CCM_ANALOG_Type) SetMISC2_REG0_BO_STATUS(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x8)|value<<3)
}
func (o *CCM_ANALOG_Type) GetMISC2_REG0_BO_STATUS() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x8) >> 3
}
func (o *CCM_ANALOG_Type) SetMISC2_REG0_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x20)|value<<5)
}
func (o *CCM_ANALOG_Type) GetMISC2_REG0_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x20) >> 5
}
func (o *CCM_ANALOG_Type) SetMISC2_REG0_OK(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x40)|value<<6)
}
func (o *CCM_ANALOG_Type) GetMISC2_REG0_OK() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x40) >> 6
}
func (o *CCM_ANALOG_Type) SetMISC2_PLL3_DISABLE(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x80)|value<<7)
}
func (o *CCM_ANALOG_Type) GetMISC2_PLL3_DISABLE() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x80) >> 7
}
func (o *CCM_ANALOG_Type) SetMISC2_REG1_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x700)|value<<8)
}
func (o *CCM_ANALOG_Type) GetMISC2_REG1_BO_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x700) >> 8
}
func (o *CCM_ANALOG_Type) SetMISC2_REG1_BO_STATUS(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x800)|value<<11)
}
func (o *CCM_ANALOG_Type) GetMISC2_REG1_BO_STATUS() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x800) >> 11
}
func (o *CCM_ANALOG_Type) SetMISC2_REG1_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x2000)|value<<13)
}
func (o *CCM_ANALOG_Type) GetMISC2_REG1_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x2000) >> 13
}
func (o *CCM_ANALOG_Type) SetMISC2_REG1_OK(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x4000)|value<<14)
}
func (o *CCM_ANALOG_Type) GetMISC2_REG1_OK() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x4000) >> 14
}
func (o *CCM_ANALOG_Type) SetMISC2_AUDIO_DIV_LSB(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x8000)|value<<15)
}
func (o *CCM_ANALOG_Type) GetMISC2_AUDIO_DIV_LSB() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x8000) >> 15
}
func (o *CCM_ANALOG_Type) SetMISC2_REG2_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x70000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetMISC2_REG2_BO_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x70000) >> 16
}
func (o *CCM_ANALOG_Type) SetMISC2_REG2_BO_STATUS(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x80000)|value<<19)
}
func (o *CCM_ANALOG_Type) GetMISC2_REG2_BO_STATUS() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x80000) >> 19
}
func (o *CCM_ANALOG_Type) SetMISC2_REG2_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x200000)|value<<21)
}
func (o *CCM_ANALOG_Type) GetMISC2_REG2_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x200000) >> 21
}
func (o *CCM_ANALOG_Type) SetMISC2_REG2_OK(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x400000)|value<<22)
}
func (o *CCM_ANALOG_Type) GetMISC2_REG2_OK() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x400000) >> 22
}
func (o *CCM_ANALOG_Type) SetMISC2_AUDIO_DIV_MSB(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x800000)|value<<23)
}
func (o *CCM_ANALOG_Type) GetMISC2_AUDIO_DIV_MSB() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x800000) >> 23
}
func (o *CCM_ANALOG_Type) SetMISC2_REG0_STEP_TIME(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x3000000)|value<<24)
}
func (o *CCM_ANALOG_Type) GetMISC2_REG0_STEP_TIME() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x3000000) >> 24
}
func (o *CCM_ANALOG_Type) SetMISC2_REG1_STEP_TIME(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0xc000000)|value<<26)
}
func (o *CCM_ANALOG_Type) GetMISC2_REG1_STEP_TIME() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0xc000000) >> 26
}
func (o *CCM_ANALOG_Type) SetMISC2_REG2_STEP_TIME(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x30000000)|value<<28)
}
func (o *CCM_ANALOG_Type) GetMISC2_REG2_STEP_TIME() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x30000000) >> 28
}

// CCM_ANALOG.MISC2_SET: Miscellaneous Register 2
func (o *CCM_ANALOG_Type) SetMISC2_SET_REG0_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x7)|value)
}
func (o *CCM_ANALOG_Type) GetMISC2_SET_REG0_BO_OFFSET() uint32 {
	return volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x7
}
func (o *CCM_ANALOG_Type) SetMISC2_SET_REG0_BO_STATUS(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x8)|value<<3)
}
func (o *CCM_ANALOG_Type) GetMISC2_SET_REG0_BO_STATUS() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x8) >> 3
}
func (o *CCM_ANALOG_Type) SetMISC2_SET_REG0_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x20)|value<<5)
}
func (o *CCM_ANALOG_Type) GetMISC2_SET_REG0_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x20) >> 5
}
func (o *CCM_ANALOG_Type) SetMISC2_SET_REG0_OK(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x40)|value<<6)
}
func (o *CCM_ANALOG_Type) GetMISC2_SET_REG0_OK() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x40) >> 6
}
func (o *CCM_ANALOG_Type) SetMISC2_SET_PLL3_DISABLE(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x80)|value<<7)
}
func (o *CCM_ANALOG_Type) GetMISC2_SET_PLL3_DISABLE() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x80) >> 7
}
func (o *CCM_ANALOG_Type) SetMISC2_SET_REG1_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x700)|value<<8)
}
func (o *CCM_ANALOG_Type) GetMISC2_SET_REG1_BO_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x700) >> 8
}
func (o *CCM_ANALOG_Type) SetMISC2_SET_REG1_BO_STATUS(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x800)|value<<11)
}
func (o *CCM_ANALOG_Type) GetMISC2_SET_REG1_BO_STATUS() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x800) >> 11
}
func (o *CCM_ANALOG_Type) SetMISC2_SET_REG1_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x2000)|value<<13)
}
func (o *CCM_ANALOG_Type) GetMISC2_SET_REG1_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x2000) >> 13
}
func (o *CCM_ANALOG_Type) SetMISC2_SET_REG1_OK(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x4000)|value<<14)
}
func (o *CCM_ANALOG_Type) GetMISC2_SET_REG1_OK() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x4000) >> 14
}
func (o *CCM_ANALOG_Type) SetMISC2_SET_AUDIO_DIV_LSB(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x8000)|value<<15)
}
func (o *CCM_ANALOG_Type) GetMISC2_SET_AUDIO_DIV_LSB() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x8000) >> 15
}
func (o *CCM_ANALOG_Type) SetMISC2_SET_REG2_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x70000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetMISC2_SET_REG2_BO_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x70000) >> 16
}
func (o *CCM_ANALOG_Type) SetMISC2_SET_REG2_BO_STATUS(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x80000)|value<<19)
}
func (o *CCM_ANALOG_Type) GetMISC2_SET_REG2_BO_STATUS() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x80000) >> 19
}
func (o *CCM_ANALOG_Type) SetMISC2_SET_REG2_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x200000)|value<<21)
}
func (o *CCM_ANALOG_Type) GetMISC2_SET_REG2_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x200000) >> 21
}
func (o *CCM_ANALOG_Type) SetMISC2_SET_REG2_OK(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x400000)|value<<22)
}
func (o *CCM_ANALOG_Type) GetMISC2_SET_REG2_OK() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x400000) >> 22
}
func (o *CCM_ANALOG_Type) SetMISC2_SET_AUDIO_DIV_MSB(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x800000)|value<<23)
}
func (o *CCM_ANALOG_Type) GetMISC2_SET_AUDIO_DIV_MSB() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x800000) >> 23
}
func (o *CCM_ANALOG_Type) SetMISC2_SET_REG0_STEP_TIME(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x3000000)|value<<24)
}
func (o *CCM_ANALOG_Type) GetMISC2_SET_REG0_STEP_TIME() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x3000000) >> 24
}
func (o *CCM_ANALOG_Type) SetMISC2_SET_REG1_STEP_TIME(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0xc000000)|value<<26)
}
func (o *CCM_ANALOG_Type) GetMISC2_SET_REG1_STEP_TIME() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0xc000000) >> 26
}
func (o *CCM_ANALOG_Type) SetMISC2_SET_REG2_STEP_TIME(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x30000000)|value<<28)
}
func (o *CCM_ANALOG_Type) GetMISC2_SET_REG2_STEP_TIME() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x30000000) >> 28
}

// CCM_ANALOG.MISC2_CLR: Miscellaneous Register 2
func (o *CCM_ANALOG_Type) SetMISC2_CLR_REG0_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x7)|value)
}
func (o *CCM_ANALOG_Type) GetMISC2_CLR_REG0_BO_OFFSET() uint32 {
	return volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x7
}
func (o *CCM_ANALOG_Type) SetMISC2_CLR_REG0_BO_STATUS(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x8)|value<<3)
}
func (o *CCM_ANALOG_Type) GetMISC2_CLR_REG0_BO_STATUS() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x8) >> 3
}
func (o *CCM_ANALOG_Type) SetMISC2_CLR_REG0_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x20)|value<<5)
}
func (o *CCM_ANALOG_Type) GetMISC2_CLR_REG0_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x20) >> 5
}
func (o *CCM_ANALOG_Type) SetMISC2_CLR_REG0_OK(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x40)|value<<6)
}
func (o *CCM_ANALOG_Type) GetMISC2_CLR_REG0_OK() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x40) >> 6
}
func (o *CCM_ANALOG_Type) SetMISC2_CLR_PLL3_DISABLE(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x80)|value<<7)
}
func (o *CCM_ANALOG_Type) GetMISC2_CLR_PLL3_DISABLE() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x80) >> 7
}
func (o *CCM_ANALOG_Type) SetMISC2_CLR_REG1_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x700)|value<<8)
}
func (o *CCM_ANALOG_Type) GetMISC2_CLR_REG1_BO_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x700) >> 8
}
func (o *CCM_ANALOG_Type) SetMISC2_CLR_REG1_BO_STATUS(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x800)|value<<11)
}
func (o *CCM_ANALOG_Type) GetMISC2_CLR_REG1_BO_STATUS() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x800) >> 11
}
func (o *CCM_ANALOG_Type) SetMISC2_CLR_REG1_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *CCM_ANALOG_Type) GetMISC2_CLR_REG1_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x2000) >> 13
}
func (o *CCM_ANALOG_Type) SetMISC2_CLR_REG1_OK(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *CCM_ANALOG_Type) GetMISC2_CLR_REG1_OK() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x4000) >> 14
}
func (o *CCM_ANALOG_Type) SetMISC2_CLR_AUDIO_DIV_LSB(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *CCM_ANALOG_Type) GetMISC2_CLR_AUDIO_DIV_LSB() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x8000) >> 15
}
func (o *CCM_ANALOG_Type) SetMISC2_CLR_REG2_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x70000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetMISC2_CLR_REG2_BO_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x70000) >> 16
}
func (o *CCM_ANALOG_Type) SetMISC2_CLR_REG2_BO_STATUS(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x80000)|value<<19)
}
func (o *CCM_ANALOG_Type) GetMISC2_CLR_REG2_BO_STATUS() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x80000) >> 19
}
func (o *CCM_ANALOG_Type) SetMISC2_CLR_REG2_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x200000)|value<<21)
}
func (o *CCM_ANALOG_Type) GetMISC2_CLR_REG2_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x200000) >> 21
}
func (o *CCM_ANALOG_Type) SetMISC2_CLR_REG2_OK(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x400000)|value<<22)
}
func (o *CCM_ANALOG_Type) GetMISC2_CLR_REG2_OK() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x400000) >> 22
}
func (o *CCM_ANALOG_Type) SetMISC2_CLR_AUDIO_DIV_MSB(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x800000)|value<<23)
}
func (o *CCM_ANALOG_Type) GetMISC2_CLR_AUDIO_DIV_MSB() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x800000) >> 23
}
func (o *CCM_ANALOG_Type) SetMISC2_CLR_REG0_STEP_TIME(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x3000000)|value<<24)
}
func (o *CCM_ANALOG_Type) GetMISC2_CLR_REG0_STEP_TIME() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x3000000) >> 24
}
func (o *CCM_ANALOG_Type) SetMISC2_CLR_REG1_STEP_TIME(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0xc000000)|value<<26)
}
func (o *CCM_ANALOG_Type) GetMISC2_CLR_REG1_STEP_TIME() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0xc000000) >> 26
}
func (o *CCM_ANALOG_Type) SetMISC2_CLR_REG2_STEP_TIME(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x30000000)|value<<28)
}
func (o *CCM_ANALOG_Type) GetMISC2_CLR_REG2_STEP_TIME() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x30000000) >> 28
}

// CCM_ANALOG.MISC2_TOG: Miscellaneous Register 2
func (o *CCM_ANALOG_Type) SetMISC2_TOG_REG0_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x7)|value)
}
func (o *CCM_ANALOG_Type) GetMISC2_TOG_REG0_BO_OFFSET() uint32 {
	return volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x7
}
func (o *CCM_ANALOG_Type) SetMISC2_TOG_REG0_BO_STATUS(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x8)|value<<3)
}
func (o *CCM_ANALOG_Type) GetMISC2_TOG_REG0_BO_STATUS() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x8) >> 3
}
func (o *CCM_ANALOG_Type) SetMISC2_TOG_REG0_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x20)|value<<5)
}
func (o *CCM_ANALOG_Type) GetMISC2_TOG_REG0_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x20) >> 5
}
func (o *CCM_ANALOG_Type) SetMISC2_TOG_REG0_OK(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x40)|value<<6)
}
func (o *CCM_ANALOG_Type) GetMISC2_TOG_REG0_OK() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x40) >> 6
}
func (o *CCM_ANALOG_Type) SetMISC2_TOG_PLL3_DISABLE(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x80)|value<<7)
}
func (o *CCM_ANALOG_Type) GetMISC2_TOG_PLL3_DISABLE() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x80) >> 7
}
func (o *CCM_ANALOG_Type) SetMISC2_TOG_REG1_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x700)|value<<8)
}
func (o *CCM_ANALOG_Type) GetMISC2_TOG_REG1_BO_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x700) >> 8
}
func (o *CCM_ANALOG_Type) SetMISC2_TOG_REG1_BO_STATUS(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x800)|value<<11)
}
func (o *CCM_ANALOG_Type) GetMISC2_TOG_REG1_BO_STATUS() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x800) >> 11
}
func (o *CCM_ANALOG_Type) SetMISC2_TOG_REG1_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x2000)|value<<13)
}
func (o *CCM_ANALOG_Type) GetMISC2_TOG_REG1_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x2000) >> 13
}
func (o *CCM_ANALOG_Type) SetMISC2_TOG_REG1_OK(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x4000)|value<<14)
}
func (o *CCM_ANALOG_Type) GetMISC2_TOG_REG1_OK() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x4000) >> 14
}
func (o *CCM_ANALOG_Type) SetMISC2_TOG_AUDIO_DIV_LSB(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x8000)|value<<15)
}
func (o *CCM_ANALOG_Type) GetMISC2_TOG_AUDIO_DIV_LSB() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x8000) >> 15
}
func (o *CCM_ANALOG_Type) SetMISC2_TOG_REG2_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x70000)|value<<16)
}
func (o *CCM_ANALOG_Type) GetMISC2_TOG_REG2_BO_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x70000) >> 16
}
func (o *CCM_ANALOG_Type) SetMISC2_TOG_REG2_BO_STATUS(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x80000)|value<<19)
}
func (o *CCM_ANALOG_Type) GetMISC2_TOG_REG2_BO_STATUS() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x80000) >> 19
}
func (o *CCM_ANALOG_Type) SetMISC2_TOG_REG2_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x200000)|value<<21)
}
func (o *CCM_ANALOG_Type) GetMISC2_TOG_REG2_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x200000) >> 21
}
func (o *CCM_ANALOG_Type) SetMISC2_TOG_REG2_OK(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x400000)|value<<22)
}
func (o *CCM_ANALOG_Type) GetMISC2_TOG_REG2_OK() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x400000) >> 22
}
func (o *CCM_ANALOG_Type) SetMISC2_TOG_AUDIO_DIV_MSB(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x800000)|value<<23)
}
func (o *CCM_ANALOG_Type) GetMISC2_TOG_AUDIO_DIV_MSB() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x800000) >> 23
}
func (o *CCM_ANALOG_Type) SetMISC2_TOG_REG0_STEP_TIME(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x3000000)|value<<24)
}
func (o *CCM_ANALOG_Type) GetMISC2_TOG_REG0_STEP_TIME() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x3000000) >> 24
}
func (o *CCM_ANALOG_Type) SetMISC2_TOG_REG1_STEP_TIME(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0xc000000)|value<<26)
}
func (o *CCM_ANALOG_Type) GetMISC2_TOG_REG1_STEP_TIME() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0xc000000) >> 26
}
func (o *CCM_ANALOG_Type) SetMISC2_TOG_REG2_STEP_TIME(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x30000000)|value<<28)
}
func (o *CCM_ANALOG_Type) GetMISC2_TOG_REG2_STEP_TIME() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x30000000) >> 28
}

// PMU
type PMU_Type struct {
	_            [272]byte
	REG_1P1      volatile.Register32 // 0x110
	REG_1P1_SET  volatile.Register32 // 0x114
	REG_1P1_CLR  volatile.Register32 // 0x118
	REG_1P1_TOG  volatile.Register32 // 0x11C
	REG_3P0      volatile.Register32 // 0x120
	REG_3P0_SET  volatile.Register32 // 0x124
	REG_3P0_CLR  volatile.Register32 // 0x128
	REG_3P0_TOG  volatile.Register32 // 0x12C
	REG_2P5      volatile.Register32 // 0x130
	REG_2P5_SET  volatile.Register32 // 0x134
	REG_2P5_CLR  volatile.Register32 // 0x138
	REG_2P5_TOG  volatile.Register32 // 0x13C
	REG_CORE     volatile.Register32 // 0x140
	REG_CORE_SET volatile.Register32 // 0x144
	REG_CORE_CLR volatile.Register32 // 0x148
	REG_CORE_TOG volatile.Register32 // 0x14C
	MISC0        volatile.Register32 // 0x150
	MISC0_SET    volatile.Register32 // 0x154
	MISC0_CLR    volatile.Register32 // 0x158
	MISC0_TOG    volatile.Register32 // 0x15C
	MISC1        volatile.Register32 // 0x160
	MISC1_SET    volatile.Register32 // 0x164
	MISC1_CLR    volatile.Register32 // 0x168
	MISC1_TOG    volatile.Register32 // 0x16C
	MISC2        volatile.Register32 // 0x170
	MISC2_SET    volatile.Register32 // 0x174
	MISC2_CLR    volatile.Register32 // 0x178
	MISC2_TOG    volatile.Register32 // 0x17C
}

// PMU.REG_1P1: Regulator 1P1 Register
func (o *PMU_Type) SetREG_1P1_ENABLE_LINREG(value uint32) {
	volatile.StoreUint32(&o.REG_1P1.Reg, volatile.LoadUint32(&o.REG_1P1.Reg)&^(0x1)|value)
}
func (o *PMU_Type) GetREG_1P1_ENABLE_LINREG() uint32 {
	return volatile.LoadUint32(&o.REG_1P1.Reg) & 0x1
}
func (o *PMU_Type) SetREG_1P1_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.REG_1P1.Reg, volatile.LoadUint32(&o.REG_1P1.Reg)&^(0x2)|value<<1)
}
func (o *PMU_Type) GetREG_1P1_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1.Reg) & 0x2) >> 1
}
func (o *PMU_Type) SetREG_1P1_ENABLE_ILIMIT(value uint32) {
	volatile.StoreUint32(&o.REG_1P1.Reg, volatile.LoadUint32(&o.REG_1P1.Reg)&^(0x4)|value<<2)
}
func (o *PMU_Type) GetREG_1P1_ENABLE_ILIMIT() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1.Reg) & 0x4) >> 2
}
func (o *PMU_Type) SetREG_1P1_ENABLE_PULLDOWN(value uint32) {
	volatile.StoreUint32(&o.REG_1P1.Reg, volatile.LoadUint32(&o.REG_1P1.Reg)&^(0x8)|value<<3)
}
func (o *PMU_Type) GetREG_1P1_ENABLE_PULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1.Reg) & 0x8) >> 3
}
func (o *PMU_Type) SetREG_1P1_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.REG_1P1.Reg, volatile.LoadUint32(&o.REG_1P1.Reg)&^(0x70)|value<<4)
}
func (o *PMU_Type) GetREG_1P1_BO_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1.Reg) & 0x70) >> 4
}
func (o *PMU_Type) SetREG_1P1_OUTPUT_TRG(value uint32) {
	volatile.StoreUint32(&o.REG_1P1.Reg, volatile.LoadUint32(&o.REG_1P1.Reg)&^(0x1f00)|value<<8)
}
func (o *PMU_Type) GetREG_1P1_OUTPUT_TRG() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1.Reg) & 0x1f00) >> 8
}
func (o *PMU_Type) SetREG_1P1_BO_VDD1P1(value uint32) {
	volatile.StoreUint32(&o.REG_1P1.Reg, volatile.LoadUint32(&o.REG_1P1.Reg)&^(0x10000)|value<<16)
}
func (o *PMU_Type) GetREG_1P1_BO_VDD1P1() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1.Reg) & 0x10000) >> 16
}
func (o *PMU_Type) SetREG_1P1_OK_VDD1P1(value uint32) {
	volatile.StoreUint32(&o.REG_1P1.Reg, volatile.LoadUint32(&o.REG_1P1.Reg)&^(0x20000)|value<<17)
}
func (o *PMU_Type) GetREG_1P1_OK_VDD1P1() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1.Reg) & 0x20000) >> 17
}
func (o *PMU_Type) SetREG_1P1_ENABLE_WEAK_LINREG(value uint32) {
	volatile.StoreUint32(&o.REG_1P1.Reg, volatile.LoadUint32(&o.REG_1P1.Reg)&^(0x40000)|value<<18)
}
func (o *PMU_Type) GetREG_1P1_ENABLE_WEAK_LINREG() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1.Reg) & 0x40000) >> 18
}
func (o *PMU_Type) SetREG_1P1_SELREF_WEAK_LINREG(value uint32) {
	volatile.StoreUint32(&o.REG_1P1.Reg, volatile.LoadUint32(&o.REG_1P1.Reg)&^(0x80000)|value<<19)
}
func (o *PMU_Type) GetREG_1P1_SELREF_WEAK_LINREG() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1.Reg) & 0x80000) >> 19
}

// PMU.REG_1P1_SET: Regulator 1P1 Register
func (o *PMU_Type) SetREG_1P1_SET_ENABLE_LINREG(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_SET.Reg, volatile.LoadUint32(&o.REG_1P1_SET.Reg)&^(0x1)|value)
}
func (o *PMU_Type) GetREG_1P1_SET_ENABLE_LINREG() uint32 {
	return volatile.LoadUint32(&o.REG_1P1_SET.Reg) & 0x1
}
func (o *PMU_Type) SetREG_1P1_SET_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_SET.Reg, volatile.LoadUint32(&o.REG_1P1_SET.Reg)&^(0x2)|value<<1)
}
func (o *PMU_Type) GetREG_1P1_SET_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1_SET.Reg) & 0x2) >> 1
}
func (o *PMU_Type) SetREG_1P1_SET_ENABLE_ILIMIT(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_SET.Reg, volatile.LoadUint32(&o.REG_1P1_SET.Reg)&^(0x4)|value<<2)
}
func (o *PMU_Type) GetREG_1P1_SET_ENABLE_ILIMIT() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1_SET.Reg) & 0x4) >> 2
}
func (o *PMU_Type) SetREG_1P1_SET_ENABLE_PULLDOWN(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_SET.Reg, volatile.LoadUint32(&o.REG_1P1_SET.Reg)&^(0x8)|value<<3)
}
func (o *PMU_Type) GetREG_1P1_SET_ENABLE_PULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1_SET.Reg) & 0x8) >> 3
}
func (o *PMU_Type) SetREG_1P1_SET_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_SET.Reg, volatile.LoadUint32(&o.REG_1P1_SET.Reg)&^(0x70)|value<<4)
}
func (o *PMU_Type) GetREG_1P1_SET_BO_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1_SET.Reg) & 0x70) >> 4
}
func (o *PMU_Type) SetREG_1P1_SET_OUTPUT_TRG(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_SET.Reg, volatile.LoadUint32(&o.REG_1P1_SET.Reg)&^(0x1f00)|value<<8)
}
func (o *PMU_Type) GetREG_1P1_SET_OUTPUT_TRG() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1_SET.Reg) & 0x1f00) >> 8
}
func (o *PMU_Type) SetREG_1P1_SET_BO_VDD1P1(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_SET.Reg, volatile.LoadUint32(&o.REG_1P1_SET.Reg)&^(0x10000)|value<<16)
}
func (o *PMU_Type) GetREG_1P1_SET_BO_VDD1P1() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1_SET.Reg) & 0x10000) >> 16
}
func (o *PMU_Type) SetREG_1P1_SET_OK_VDD1P1(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_SET.Reg, volatile.LoadUint32(&o.REG_1P1_SET.Reg)&^(0x20000)|value<<17)
}
func (o *PMU_Type) GetREG_1P1_SET_OK_VDD1P1() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1_SET.Reg) & 0x20000) >> 17
}
func (o *PMU_Type) SetREG_1P1_SET_ENABLE_WEAK_LINREG(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_SET.Reg, volatile.LoadUint32(&o.REG_1P1_SET.Reg)&^(0x40000)|value<<18)
}
func (o *PMU_Type) GetREG_1P1_SET_ENABLE_WEAK_LINREG() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1_SET.Reg) & 0x40000) >> 18
}
func (o *PMU_Type) SetREG_1P1_SET_SELREF_WEAK_LINREG(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_SET.Reg, volatile.LoadUint32(&o.REG_1P1_SET.Reg)&^(0x80000)|value<<19)
}
func (o *PMU_Type) GetREG_1P1_SET_SELREF_WEAK_LINREG() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1_SET.Reg) & 0x80000) >> 19
}

// PMU.REG_1P1_CLR: Regulator 1P1 Register
func (o *PMU_Type) SetREG_1P1_CLR_ENABLE_LINREG(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_CLR.Reg, volatile.LoadUint32(&o.REG_1P1_CLR.Reg)&^(0x1)|value)
}
func (o *PMU_Type) GetREG_1P1_CLR_ENABLE_LINREG() uint32 {
	return volatile.LoadUint32(&o.REG_1P1_CLR.Reg) & 0x1
}
func (o *PMU_Type) SetREG_1P1_CLR_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_CLR.Reg, volatile.LoadUint32(&o.REG_1P1_CLR.Reg)&^(0x2)|value<<1)
}
func (o *PMU_Type) GetREG_1P1_CLR_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1_CLR.Reg) & 0x2) >> 1
}
func (o *PMU_Type) SetREG_1P1_CLR_ENABLE_ILIMIT(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_CLR.Reg, volatile.LoadUint32(&o.REG_1P1_CLR.Reg)&^(0x4)|value<<2)
}
func (o *PMU_Type) GetREG_1P1_CLR_ENABLE_ILIMIT() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1_CLR.Reg) & 0x4) >> 2
}
func (o *PMU_Type) SetREG_1P1_CLR_ENABLE_PULLDOWN(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_CLR.Reg, volatile.LoadUint32(&o.REG_1P1_CLR.Reg)&^(0x8)|value<<3)
}
func (o *PMU_Type) GetREG_1P1_CLR_ENABLE_PULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1_CLR.Reg) & 0x8) >> 3
}
func (o *PMU_Type) SetREG_1P1_CLR_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_CLR.Reg, volatile.LoadUint32(&o.REG_1P1_CLR.Reg)&^(0x70)|value<<4)
}
func (o *PMU_Type) GetREG_1P1_CLR_BO_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1_CLR.Reg) & 0x70) >> 4
}
func (o *PMU_Type) SetREG_1P1_CLR_OUTPUT_TRG(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_CLR.Reg, volatile.LoadUint32(&o.REG_1P1_CLR.Reg)&^(0x1f00)|value<<8)
}
func (o *PMU_Type) GetREG_1P1_CLR_OUTPUT_TRG() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1_CLR.Reg) & 0x1f00) >> 8
}
func (o *PMU_Type) SetREG_1P1_CLR_BO_VDD1P1(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_CLR.Reg, volatile.LoadUint32(&o.REG_1P1_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *PMU_Type) GetREG_1P1_CLR_BO_VDD1P1() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1_CLR.Reg) & 0x10000) >> 16
}
func (o *PMU_Type) SetREG_1P1_CLR_OK_VDD1P1(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_CLR.Reg, volatile.LoadUint32(&o.REG_1P1_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *PMU_Type) GetREG_1P1_CLR_OK_VDD1P1() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1_CLR.Reg) & 0x20000) >> 17
}
func (o *PMU_Type) SetREG_1P1_CLR_ENABLE_WEAK_LINREG(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_CLR.Reg, volatile.LoadUint32(&o.REG_1P1_CLR.Reg)&^(0x40000)|value<<18)
}
func (o *PMU_Type) GetREG_1P1_CLR_ENABLE_WEAK_LINREG() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1_CLR.Reg) & 0x40000) >> 18
}
func (o *PMU_Type) SetREG_1P1_CLR_SELREF_WEAK_LINREG(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_CLR.Reg, volatile.LoadUint32(&o.REG_1P1_CLR.Reg)&^(0x80000)|value<<19)
}
func (o *PMU_Type) GetREG_1P1_CLR_SELREF_WEAK_LINREG() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1_CLR.Reg) & 0x80000) >> 19
}

// PMU.REG_1P1_TOG: Regulator 1P1 Register
func (o *PMU_Type) SetREG_1P1_TOG_ENABLE_LINREG(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_TOG.Reg, volatile.LoadUint32(&o.REG_1P1_TOG.Reg)&^(0x1)|value)
}
func (o *PMU_Type) GetREG_1P1_TOG_ENABLE_LINREG() uint32 {
	return volatile.LoadUint32(&o.REG_1P1_TOG.Reg) & 0x1
}
func (o *PMU_Type) SetREG_1P1_TOG_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_TOG.Reg, volatile.LoadUint32(&o.REG_1P1_TOG.Reg)&^(0x2)|value<<1)
}
func (o *PMU_Type) GetREG_1P1_TOG_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1_TOG.Reg) & 0x2) >> 1
}
func (o *PMU_Type) SetREG_1P1_TOG_ENABLE_ILIMIT(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_TOG.Reg, volatile.LoadUint32(&o.REG_1P1_TOG.Reg)&^(0x4)|value<<2)
}
func (o *PMU_Type) GetREG_1P1_TOG_ENABLE_ILIMIT() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1_TOG.Reg) & 0x4) >> 2
}
func (o *PMU_Type) SetREG_1P1_TOG_ENABLE_PULLDOWN(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_TOG.Reg, volatile.LoadUint32(&o.REG_1P1_TOG.Reg)&^(0x8)|value<<3)
}
func (o *PMU_Type) GetREG_1P1_TOG_ENABLE_PULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1_TOG.Reg) & 0x8) >> 3
}
func (o *PMU_Type) SetREG_1P1_TOG_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_TOG.Reg, volatile.LoadUint32(&o.REG_1P1_TOG.Reg)&^(0x70)|value<<4)
}
func (o *PMU_Type) GetREG_1P1_TOG_BO_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1_TOG.Reg) & 0x70) >> 4
}
func (o *PMU_Type) SetREG_1P1_TOG_OUTPUT_TRG(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_TOG.Reg, volatile.LoadUint32(&o.REG_1P1_TOG.Reg)&^(0x1f00)|value<<8)
}
func (o *PMU_Type) GetREG_1P1_TOG_OUTPUT_TRG() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1_TOG.Reg) & 0x1f00) >> 8
}
func (o *PMU_Type) SetREG_1P1_TOG_BO_VDD1P1(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_TOG.Reg, volatile.LoadUint32(&o.REG_1P1_TOG.Reg)&^(0x10000)|value<<16)
}
func (o *PMU_Type) GetREG_1P1_TOG_BO_VDD1P1() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1_TOG.Reg) & 0x10000) >> 16
}
func (o *PMU_Type) SetREG_1P1_TOG_OK_VDD1P1(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_TOG.Reg, volatile.LoadUint32(&o.REG_1P1_TOG.Reg)&^(0x20000)|value<<17)
}
func (o *PMU_Type) GetREG_1P1_TOG_OK_VDD1P1() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1_TOG.Reg) & 0x20000) >> 17
}
func (o *PMU_Type) SetREG_1P1_TOG_ENABLE_WEAK_LINREG(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_TOG.Reg, volatile.LoadUint32(&o.REG_1P1_TOG.Reg)&^(0x40000)|value<<18)
}
func (o *PMU_Type) GetREG_1P1_TOG_ENABLE_WEAK_LINREG() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1_TOG.Reg) & 0x40000) >> 18
}
func (o *PMU_Type) SetREG_1P1_TOG_SELREF_WEAK_LINREG(value uint32) {
	volatile.StoreUint32(&o.REG_1P1_TOG.Reg, volatile.LoadUint32(&o.REG_1P1_TOG.Reg)&^(0x80000)|value<<19)
}
func (o *PMU_Type) GetREG_1P1_TOG_SELREF_WEAK_LINREG() uint32 {
	return (volatile.LoadUint32(&o.REG_1P1_TOG.Reg) & 0x80000) >> 19
}

// PMU.REG_3P0: Regulator 3P0 Register
func (o *PMU_Type) SetREG_3P0_ENABLE_LINREG(value uint32) {
	volatile.StoreUint32(&o.REG_3P0.Reg, volatile.LoadUint32(&o.REG_3P0.Reg)&^(0x1)|value)
}
func (o *PMU_Type) GetREG_3P0_ENABLE_LINREG() uint32 {
	return volatile.LoadUint32(&o.REG_3P0.Reg) & 0x1
}
func (o *PMU_Type) SetREG_3P0_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.REG_3P0.Reg, volatile.LoadUint32(&o.REG_3P0.Reg)&^(0x2)|value<<1)
}
func (o *PMU_Type) GetREG_3P0_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.REG_3P0.Reg) & 0x2) >> 1
}
func (o *PMU_Type) SetREG_3P0_ENABLE_ILIMIT(value uint32) {
	volatile.StoreUint32(&o.REG_3P0.Reg, volatile.LoadUint32(&o.REG_3P0.Reg)&^(0x4)|value<<2)
}
func (o *PMU_Type) GetREG_3P0_ENABLE_ILIMIT() uint32 {
	return (volatile.LoadUint32(&o.REG_3P0.Reg) & 0x4) >> 2
}
func (o *PMU_Type) SetREG_3P0_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.REG_3P0.Reg, volatile.LoadUint32(&o.REG_3P0.Reg)&^(0x70)|value<<4)
}
func (o *PMU_Type) GetREG_3P0_BO_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.REG_3P0.Reg) & 0x70) >> 4
}
func (o *PMU_Type) SetREG_3P0_VBUS_SEL(value uint32) {
	volatile.StoreUint32(&o.REG_3P0.Reg, volatile.LoadUint32(&o.REG_3P0.Reg)&^(0x80)|value<<7)
}
func (o *PMU_Type) GetREG_3P0_VBUS_SEL() uint32 {
	return (volatile.LoadUint32(&o.REG_3P0.Reg) & 0x80) >> 7
}
func (o *PMU_Type) SetREG_3P0_OUTPUT_TRG(value uint32) {
	volatile.StoreUint32(&o.REG_3P0.Reg, volatile.LoadUint32(&o.REG_3P0.Reg)&^(0x1f00)|value<<8)
}
func (o *PMU_Type) GetREG_3P0_OUTPUT_TRG() uint32 {
	return (volatile.LoadUint32(&o.REG_3P0.Reg) & 0x1f00) >> 8
}
func (o *PMU_Type) SetREG_3P0_BO_VDD3P0(value uint32) {
	volatile.StoreUint32(&o.REG_3P0.Reg, volatile.LoadUint32(&o.REG_3P0.Reg)&^(0x10000)|value<<16)
}
func (o *PMU_Type) GetREG_3P0_BO_VDD3P0() uint32 {
	return (volatile.LoadUint32(&o.REG_3P0.Reg) & 0x10000) >> 16
}
func (o *PMU_Type) SetREG_3P0_OK_VDD3P0(value uint32) {
	volatile.StoreUint32(&o.REG_3P0.Reg, volatile.LoadUint32(&o.REG_3P0.Reg)&^(0x20000)|value<<17)
}
func (o *PMU_Type) GetREG_3P0_OK_VDD3P0() uint32 {
	return (volatile.LoadUint32(&o.REG_3P0.Reg) & 0x20000) >> 17
}

// PMU.REG_3P0_SET: Regulator 3P0 Register
func (o *PMU_Type) SetREG_3P0_SET_ENABLE_LINREG(value uint32) {
	volatile.StoreUint32(&o.REG_3P0_SET.Reg, volatile.LoadUint32(&o.REG_3P0_SET.Reg)&^(0x1)|value)
}
func (o *PMU_Type) GetREG_3P0_SET_ENABLE_LINREG() uint32 {
	return volatile.LoadUint32(&o.REG_3P0_SET.Reg) & 0x1
}
func (o *PMU_Type) SetREG_3P0_SET_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.REG_3P0_SET.Reg, volatile.LoadUint32(&o.REG_3P0_SET.Reg)&^(0x2)|value<<1)
}
func (o *PMU_Type) GetREG_3P0_SET_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.REG_3P0_SET.Reg) & 0x2) >> 1
}
func (o *PMU_Type) SetREG_3P0_SET_ENABLE_ILIMIT(value uint32) {
	volatile.StoreUint32(&o.REG_3P0_SET.Reg, volatile.LoadUint32(&o.REG_3P0_SET.Reg)&^(0x4)|value<<2)
}
func (o *PMU_Type) GetREG_3P0_SET_ENABLE_ILIMIT() uint32 {
	return (volatile.LoadUint32(&o.REG_3P0_SET.Reg) & 0x4) >> 2
}
func (o *PMU_Type) SetREG_3P0_SET_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.REG_3P0_SET.Reg, volatile.LoadUint32(&o.REG_3P0_SET.Reg)&^(0x70)|value<<4)
}
func (o *PMU_Type) GetREG_3P0_SET_BO_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.REG_3P0_SET.Reg) & 0x70) >> 4
}
func (o *PMU_Type) SetREG_3P0_SET_VBUS_SEL(value uint32) {
	volatile.StoreUint32(&o.REG_3P0_SET.Reg, volatile.LoadUint32(&o.REG_3P0_SET.Reg)&^(0x80)|value<<7)
}
func (o *PMU_Type) GetREG_3P0_SET_VBUS_SEL() uint32 {
	return (volatile.LoadUint32(&o.REG_3P0_SET.Reg) & 0x80) >> 7
}
func (o *PMU_Type) SetREG_3P0_SET_OUTPUT_TRG(value uint32) {
	volatile.StoreUint32(&o.REG_3P0_SET.Reg, volatile.LoadUint32(&o.REG_3P0_SET.Reg)&^(0x1f00)|value<<8)
}
func (o *PMU_Type) GetREG_3P0_SET_OUTPUT_TRG() uint32 {
	return (volatile.LoadUint32(&o.REG_3P0_SET.Reg) & 0x1f00) >> 8
}
func (o *PMU_Type) SetREG_3P0_SET_BO_VDD3P0(value uint32) {
	volatile.StoreUint32(&o.REG_3P0_SET.Reg, volatile.LoadUint32(&o.REG_3P0_SET.Reg)&^(0x10000)|value<<16)
}
func (o *PMU_Type) GetREG_3P0_SET_BO_VDD3P0() uint32 {
	return (volatile.LoadUint32(&o.REG_3P0_SET.Reg) & 0x10000) >> 16
}
func (o *PMU_Type) SetREG_3P0_SET_OK_VDD3P0(value uint32) {
	volatile.StoreUint32(&o.REG_3P0_SET.Reg, volatile.LoadUint32(&o.REG_3P0_SET.Reg)&^(0x20000)|value<<17)
}
func (o *PMU_Type) GetREG_3P0_SET_OK_VDD3P0() uint32 {
	return (volatile.LoadUint32(&o.REG_3P0_SET.Reg) & 0x20000) >> 17
}

// PMU.REG_3P0_CLR: Regulator 3P0 Register
func (o *PMU_Type) SetREG_3P0_CLR_ENABLE_LINREG(value uint32) {
	volatile.StoreUint32(&o.REG_3P0_CLR.Reg, volatile.LoadUint32(&o.REG_3P0_CLR.Reg)&^(0x1)|value)
}
func (o *PMU_Type) GetREG_3P0_CLR_ENABLE_LINREG() uint32 {
	return volatile.LoadUint32(&o.REG_3P0_CLR.Reg) & 0x1
}
func (o *PMU_Type) SetREG_3P0_CLR_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.REG_3P0_CLR.Reg, volatile.LoadUint32(&o.REG_3P0_CLR.Reg)&^(0x2)|value<<1)
}
func (o *PMU_Type) GetREG_3P0_CLR_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.REG_3P0_CLR.Reg) & 0x2) >> 1
}
func (o *PMU_Type) SetREG_3P0_CLR_ENABLE_ILIMIT(value uint32) {
	volatile.StoreUint32(&o.REG_3P0_CLR.Reg, volatile.LoadUint32(&o.REG_3P0_CLR.Reg)&^(0x4)|value<<2)
}
func (o *PMU_Type) GetREG_3P0_CLR_ENABLE_ILIMIT() uint32 {
	return (volatile.LoadUint32(&o.REG_3P0_CLR.Reg) & 0x4) >> 2
}
func (o *PMU_Type) SetREG_3P0_CLR_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.REG_3P0_CLR.Reg, volatile.LoadUint32(&o.REG_3P0_CLR.Reg)&^(0x70)|value<<4)
}
func (o *PMU_Type) GetREG_3P0_CLR_BO_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.REG_3P0_CLR.Reg) & 0x70) >> 4
}
func (o *PMU_Type) SetREG_3P0_CLR_VBUS_SEL(value uint32) {
	volatile.StoreUint32(&o.REG_3P0_CLR.Reg, volatile.LoadUint32(&o.REG_3P0_CLR.Reg)&^(0x80)|value<<7)
}
func (o *PMU_Type) GetREG_3P0_CLR_VBUS_SEL() uint32 {
	return (volatile.LoadUint32(&o.REG_3P0_CLR.Reg) & 0x80) >> 7
}
func (o *PMU_Type) SetREG_3P0_CLR_OUTPUT_TRG(value uint32) {
	volatile.StoreUint32(&o.REG_3P0_CLR.Reg, volatile.LoadUint32(&o.REG_3P0_CLR.Reg)&^(0x1f00)|value<<8)
}
func (o *PMU_Type) GetREG_3P0_CLR_OUTPUT_TRG() uint32 {
	return (volatile.LoadUint32(&o.REG_3P0_CLR.Reg) & 0x1f00) >> 8
}
func (o *PMU_Type) SetREG_3P0_CLR_BO_VDD3P0(value uint32) {
	volatile.StoreUint32(&o.REG_3P0_CLR.Reg, volatile.LoadUint32(&o.REG_3P0_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *PMU_Type) GetREG_3P0_CLR_BO_VDD3P0() uint32 {
	return (volatile.LoadUint32(&o.REG_3P0_CLR.Reg) & 0x10000) >> 16
}
func (o *PMU_Type) SetREG_3P0_CLR_OK_VDD3P0(value uint32) {
	volatile.StoreUint32(&o.REG_3P0_CLR.Reg, volatile.LoadUint32(&o.REG_3P0_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *PMU_Type) GetREG_3P0_CLR_OK_VDD3P0() uint32 {
	return (volatile.LoadUint32(&o.REG_3P0_CLR.Reg) & 0x20000) >> 17
}

// PMU.REG_3P0_TOG: Regulator 3P0 Register
func (o *PMU_Type) SetREG_3P0_TOG_ENABLE_LINREG(value uint32) {
	volatile.StoreUint32(&o.REG_3P0_TOG.Reg, volatile.LoadUint32(&o.REG_3P0_TOG.Reg)&^(0x1)|value)
}
func (o *PMU_Type) GetREG_3P0_TOG_ENABLE_LINREG() uint32 {
	return volatile.LoadUint32(&o.REG_3P0_TOG.Reg) & 0x1
}
func (o *PMU_Type) SetREG_3P0_TOG_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.REG_3P0_TOG.Reg, volatile.LoadUint32(&o.REG_3P0_TOG.Reg)&^(0x2)|value<<1)
}
func (o *PMU_Type) GetREG_3P0_TOG_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.REG_3P0_TOG.Reg) & 0x2) >> 1
}
func (o *PMU_Type) SetREG_3P0_TOG_ENABLE_ILIMIT(value uint32) {
	volatile.StoreUint32(&o.REG_3P0_TOG.Reg, volatile.LoadUint32(&o.REG_3P0_TOG.Reg)&^(0x4)|value<<2)
}
func (o *PMU_Type) GetREG_3P0_TOG_ENABLE_ILIMIT() uint32 {
	return (volatile.LoadUint32(&o.REG_3P0_TOG.Reg) & 0x4) >> 2
}
func (o *PMU_Type) SetREG_3P0_TOG_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.REG_3P0_TOG.Reg, volatile.LoadUint32(&o.REG_3P0_TOG.Reg)&^(0x70)|value<<4)
}
func (o *PMU_Type) GetREG_3P0_TOG_BO_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.REG_3P0_TOG.Reg) & 0x70) >> 4
}
func (o *PMU_Type) SetREG_3P0_TOG_VBUS_SEL(value uint32) {
	volatile.StoreUint32(&o.REG_3P0_TOG.Reg, volatile.LoadUint32(&o.REG_3P0_TOG.Reg)&^(0x80)|value<<7)
}
func (o *PMU_Type) GetREG_3P0_TOG_VBUS_SEL() uint32 {
	return (volatile.LoadUint32(&o.REG_3P0_TOG.Reg) & 0x80) >> 7
}
func (o *PMU_Type) SetREG_3P0_TOG_OUTPUT_TRG(value uint32) {
	volatile.StoreUint32(&o.REG_3P0_TOG.Reg, volatile.LoadUint32(&o.REG_3P0_TOG.Reg)&^(0x1f00)|value<<8)
}
func (o *PMU_Type) GetREG_3P0_TOG_OUTPUT_TRG() uint32 {
	return (volatile.LoadUint32(&o.REG_3P0_TOG.Reg) & 0x1f00) >> 8
}
func (o *PMU_Type) SetREG_3P0_TOG_BO_VDD3P0(value uint32) {
	volatile.StoreUint32(&o.REG_3P0_TOG.Reg, volatile.LoadUint32(&o.REG_3P0_TOG.Reg)&^(0x10000)|value<<16)
}
func (o *PMU_Type) GetREG_3P0_TOG_BO_VDD3P0() uint32 {
	return (volatile.LoadUint32(&o.REG_3P0_TOG.Reg) & 0x10000) >> 16
}
func (o *PMU_Type) SetREG_3P0_TOG_OK_VDD3P0(value uint32) {
	volatile.StoreUint32(&o.REG_3P0_TOG.Reg, volatile.LoadUint32(&o.REG_3P0_TOG.Reg)&^(0x20000)|value<<17)
}
func (o *PMU_Type) GetREG_3P0_TOG_OK_VDD3P0() uint32 {
	return (volatile.LoadUint32(&o.REG_3P0_TOG.Reg) & 0x20000) >> 17
}

// PMU.REG_2P5: Regulator 2P5 Register
func (o *PMU_Type) SetREG_2P5_ENABLE_LINREG(value uint32) {
	volatile.StoreUint32(&o.REG_2P5.Reg, volatile.LoadUint32(&o.REG_2P5.Reg)&^(0x1)|value)
}
func (o *PMU_Type) GetREG_2P5_ENABLE_LINREG() uint32 {
	return volatile.LoadUint32(&o.REG_2P5.Reg) & 0x1
}
func (o *PMU_Type) SetREG_2P5_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.REG_2P5.Reg, volatile.LoadUint32(&o.REG_2P5.Reg)&^(0x2)|value<<1)
}
func (o *PMU_Type) GetREG_2P5_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5.Reg) & 0x2) >> 1
}
func (o *PMU_Type) SetREG_2P5_ENABLE_ILIMIT(value uint32) {
	volatile.StoreUint32(&o.REG_2P5.Reg, volatile.LoadUint32(&o.REG_2P5.Reg)&^(0x4)|value<<2)
}
func (o *PMU_Type) GetREG_2P5_ENABLE_ILIMIT() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5.Reg) & 0x4) >> 2
}
func (o *PMU_Type) SetREG_2P5_ENABLE_PULLDOWN(value uint32) {
	volatile.StoreUint32(&o.REG_2P5.Reg, volatile.LoadUint32(&o.REG_2P5.Reg)&^(0x8)|value<<3)
}
func (o *PMU_Type) GetREG_2P5_ENABLE_PULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5.Reg) & 0x8) >> 3
}
func (o *PMU_Type) SetREG_2P5_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.REG_2P5.Reg, volatile.LoadUint32(&o.REG_2P5.Reg)&^(0x70)|value<<4)
}
func (o *PMU_Type) GetREG_2P5_BO_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5.Reg) & 0x70) >> 4
}
func (o *PMU_Type) SetREG_2P5_OUTPUT_TRG(value uint32) {
	volatile.StoreUint32(&o.REG_2P5.Reg, volatile.LoadUint32(&o.REG_2P5.Reg)&^(0x1f00)|value<<8)
}
func (o *PMU_Type) GetREG_2P5_OUTPUT_TRG() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5.Reg) & 0x1f00) >> 8
}
func (o *PMU_Type) SetREG_2P5_BO_VDD2P5(value uint32) {
	volatile.StoreUint32(&o.REG_2P5.Reg, volatile.LoadUint32(&o.REG_2P5.Reg)&^(0x10000)|value<<16)
}
func (o *PMU_Type) GetREG_2P5_BO_VDD2P5() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5.Reg) & 0x10000) >> 16
}
func (o *PMU_Type) SetREG_2P5_OK_VDD2P5(value uint32) {
	volatile.StoreUint32(&o.REG_2P5.Reg, volatile.LoadUint32(&o.REG_2P5.Reg)&^(0x20000)|value<<17)
}
func (o *PMU_Type) GetREG_2P5_OK_VDD2P5() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5.Reg) & 0x20000) >> 17
}
func (o *PMU_Type) SetREG_2P5_ENABLE_WEAK_LINREG(value uint32) {
	volatile.StoreUint32(&o.REG_2P5.Reg, volatile.LoadUint32(&o.REG_2P5.Reg)&^(0x40000)|value<<18)
}
func (o *PMU_Type) GetREG_2P5_ENABLE_WEAK_LINREG() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5.Reg) & 0x40000) >> 18
}

// PMU.REG_2P5_SET: Regulator 2P5 Register
func (o *PMU_Type) SetREG_2P5_SET_ENABLE_LINREG(value uint32) {
	volatile.StoreUint32(&o.REG_2P5_SET.Reg, volatile.LoadUint32(&o.REG_2P5_SET.Reg)&^(0x1)|value)
}
func (o *PMU_Type) GetREG_2P5_SET_ENABLE_LINREG() uint32 {
	return volatile.LoadUint32(&o.REG_2P5_SET.Reg) & 0x1
}
func (o *PMU_Type) SetREG_2P5_SET_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.REG_2P5_SET.Reg, volatile.LoadUint32(&o.REG_2P5_SET.Reg)&^(0x2)|value<<1)
}
func (o *PMU_Type) GetREG_2P5_SET_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5_SET.Reg) & 0x2) >> 1
}
func (o *PMU_Type) SetREG_2P5_SET_ENABLE_ILIMIT(value uint32) {
	volatile.StoreUint32(&o.REG_2P5_SET.Reg, volatile.LoadUint32(&o.REG_2P5_SET.Reg)&^(0x4)|value<<2)
}
func (o *PMU_Type) GetREG_2P5_SET_ENABLE_ILIMIT() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5_SET.Reg) & 0x4) >> 2
}
func (o *PMU_Type) SetREG_2P5_SET_ENABLE_PULLDOWN(value uint32) {
	volatile.StoreUint32(&o.REG_2P5_SET.Reg, volatile.LoadUint32(&o.REG_2P5_SET.Reg)&^(0x8)|value<<3)
}
func (o *PMU_Type) GetREG_2P5_SET_ENABLE_PULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5_SET.Reg) & 0x8) >> 3
}
func (o *PMU_Type) SetREG_2P5_SET_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.REG_2P5_SET.Reg, volatile.LoadUint32(&o.REG_2P5_SET.Reg)&^(0x70)|value<<4)
}
func (o *PMU_Type) GetREG_2P5_SET_BO_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5_SET.Reg) & 0x70) >> 4
}
func (o *PMU_Type) SetREG_2P5_SET_OUTPUT_TRG(value uint32) {
	volatile.StoreUint32(&o.REG_2P5_SET.Reg, volatile.LoadUint32(&o.REG_2P5_SET.Reg)&^(0x1f00)|value<<8)
}
func (o *PMU_Type) GetREG_2P5_SET_OUTPUT_TRG() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5_SET.Reg) & 0x1f00) >> 8
}
func (o *PMU_Type) SetREG_2P5_SET_BO_VDD2P5(value uint32) {
	volatile.StoreUint32(&o.REG_2P5_SET.Reg, volatile.LoadUint32(&o.REG_2P5_SET.Reg)&^(0x10000)|value<<16)
}
func (o *PMU_Type) GetREG_2P5_SET_BO_VDD2P5() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5_SET.Reg) & 0x10000) >> 16
}
func (o *PMU_Type) SetREG_2P5_SET_OK_VDD2P5(value uint32) {
	volatile.StoreUint32(&o.REG_2P5_SET.Reg, volatile.LoadUint32(&o.REG_2P5_SET.Reg)&^(0x20000)|value<<17)
}
func (o *PMU_Type) GetREG_2P5_SET_OK_VDD2P5() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5_SET.Reg) & 0x20000) >> 17
}
func (o *PMU_Type) SetREG_2P5_SET_ENABLE_WEAK_LINREG(value uint32) {
	volatile.StoreUint32(&o.REG_2P5_SET.Reg, volatile.LoadUint32(&o.REG_2P5_SET.Reg)&^(0x40000)|value<<18)
}
func (o *PMU_Type) GetREG_2P5_SET_ENABLE_WEAK_LINREG() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5_SET.Reg) & 0x40000) >> 18
}

// PMU.REG_2P5_CLR: Regulator 2P5 Register
func (o *PMU_Type) SetREG_2P5_CLR_ENABLE_LINREG(value uint32) {
	volatile.StoreUint32(&o.REG_2P5_CLR.Reg, volatile.LoadUint32(&o.REG_2P5_CLR.Reg)&^(0x1)|value)
}
func (o *PMU_Type) GetREG_2P5_CLR_ENABLE_LINREG() uint32 {
	return volatile.LoadUint32(&o.REG_2P5_CLR.Reg) & 0x1
}
func (o *PMU_Type) SetREG_2P5_CLR_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.REG_2P5_CLR.Reg, volatile.LoadUint32(&o.REG_2P5_CLR.Reg)&^(0x2)|value<<1)
}
func (o *PMU_Type) GetREG_2P5_CLR_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5_CLR.Reg) & 0x2) >> 1
}
func (o *PMU_Type) SetREG_2P5_CLR_ENABLE_ILIMIT(value uint32) {
	volatile.StoreUint32(&o.REG_2P5_CLR.Reg, volatile.LoadUint32(&o.REG_2P5_CLR.Reg)&^(0x4)|value<<2)
}
func (o *PMU_Type) GetREG_2P5_CLR_ENABLE_ILIMIT() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5_CLR.Reg) & 0x4) >> 2
}
func (o *PMU_Type) SetREG_2P5_CLR_ENABLE_PULLDOWN(value uint32) {
	volatile.StoreUint32(&o.REG_2P5_CLR.Reg, volatile.LoadUint32(&o.REG_2P5_CLR.Reg)&^(0x8)|value<<3)
}
func (o *PMU_Type) GetREG_2P5_CLR_ENABLE_PULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5_CLR.Reg) & 0x8) >> 3
}
func (o *PMU_Type) SetREG_2P5_CLR_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.REG_2P5_CLR.Reg, volatile.LoadUint32(&o.REG_2P5_CLR.Reg)&^(0x70)|value<<4)
}
func (o *PMU_Type) GetREG_2P5_CLR_BO_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5_CLR.Reg) & 0x70) >> 4
}
func (o *PMU_Type) SetREG_2P5_CLR_OUTPUT_TRG(value uint32) {
	volatile.StoreUint32(&o.REG_2P5_CLR.Reg, volatile.LoadUint32(&o.REG_2P5_CLR.Reg)&^(0x1f00)|value<<8)
}
func (o *PMU_Type) GetREG_2P5_CLR_OUTPUT_TRG() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5_CLR.Reg) & 0x1f00) >> 8
}
func (o *PMU_Type) SetREG_2P5_CLR_BO_VDD2P5(value uint32) {
	volatile.StoreUint32(&o.REG_2P5_CLR.Reg, volatile.LoadUint32(&o.REG_2P5_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *PMU_Type) GetREG_2P5_CLR_BO_VDD2P5() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5_CLR.Reg) & 0x10000) >> 16
}
func (o *PMU_Type) SetREG_2P5_CLR_OK_VDD2P5(value uint32) {
	volatile.StoreUint32(&o.REG_2P5_CLR.Reg, volatile.LoadUint32(&o.REG_2P5_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *PMU_Type) GetREG_2P5_CLR_OK_VDD2P5() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5_CLR.Reg) & 0x20000) >> 17
}
func (o *PMU_Type) SetREG_2P5_CLR_ENABLE_WEAK_LINREG(value uint32) {
	volatile.StoreUint32(&o.REG_2P5_CLR.Reg, volatile.LoadUint32(&o.REG_2P5_CLR.Reg)&^(0x40000)|value<<18)
}
func (o *PMU_Type) GetREG_2P5_CLR_ENABLE_WEAK_LINREG() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5_CLR.Reg) & 0x40000) >> 18
}

// PMU.REG_2P5_TOG: Regulator 2P5 Register
func (o *PMU_Type) SetREG_2P5_TOG_ENABLE_LINREG(value uint32) {
	volatile.StoreUint32(&o.REG_2P5_TOG.Reg, volatile.LoadUint32(&o.REG_2P5_TOG.Reg)&^(0x1)|value)
}
func (o *PMU_Type) GetREG_2P5_TOG_ENABLE_LINREG() uint32 {
	return volatile.LoadUint32(&o.REG_2P5_TOG.Reg) & 0x1
}
func (o *PMU_Type) SetREG_2P5_TOG_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.REG_2P5_TOG.Reg, volatile.LoadUint32(&o.REG_2P5_TOG.Reg)&^(0x2)|value<<1)
}
func (o *PMU_Type) GetREG_2P5_TOG_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5_TOG.Reg) & 0x2) >> 1
}
func (o *PMU_Type) SetREG_2P5_TOG_ENABLE_ILIMIT(value uint32) {
	volatile.StoreUint32(&o.REG_2P5_TOG.Reg, volatile.LoadUint32(&o.REG_2P5_TOG.Reg)&^(0x4)|value<<2)
}
func (o *PMU_Type) GetREG_2P5_TOG_ENABLE_ILIMIT() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5_TOG.Reg) & 0x4) >> 2
}
func (o *PMU_Type) SetREG_2P5_TOG_ENABLE_PULLDOWN(value uint32) {
	volatile.StoreUint32(&o.REG_2P5_TOG.Reg, volatile.LoadUint32(&o.REG_2P5_TOG.Reg)&^(0x8)|value<<3)
}
func (o *PMU_Type) GetREG_2P5_TOG_ENABLE_PULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5_TOG.Reg) & 0x8) >> 3
}
func (o *PMU_Type) SetREG_2P5_TOG_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.REG_2P5_TOG.Reg, volatile.LoadUint32(&o.REG_2P5_TOG.Reg)&^(0x70)|value<<4)
}
func (o *PMU_Type) GetREG_2P5_TOG_BO_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5_TOG.Reg) & 0x70) >> 4
}
func (o *PMU_Type) SetREG_2P5_TOG_OUTPUT_TRG(value uint32) {
	volatile.StoreUint32(&o.REG_2P5_TOG.Reg, volatile.LoadUint32(&o.REG_2P5_TOG.Reg)&^(0x1f00)|value<<8)
}
func (o *PMU_Type) GetREG_2P5_TOG_OUTPUT_TRG() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5_TOG.Reg) & 0x1f00) >> 8
}
func (o *PMU_Type) SetREG_2P5_TOG_BO_VDD2P5(value uint32) {
	volatile.StoreUint32(&o.REG_2P5_TOG.Reg, volatile.LoadUint32(&o.REG_2P5_TOG.Reg)&^(0x10000)|value<<16)
}
func (o *PMU_Type) GetREG_2P5_TOG_BO_VDD2P5() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5_TOG.Reg) & 0x10000) >> 16
}
func (o *PMU_Type) SetREG_2P5_TOG_OK_VDD2P5(value uint32) {
	volatile.StoreUint32(&o.REG_2P5_TOG.Reg, volatile.LoadUint32(&o.REG_2P5_TOG.Reg)&^(0x20000)|value<<17)
}
func (o *PMU_Type) GetREG_2P5_TOG_OK_VDD2P5() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5_TOG.Reg) & 0x20000) >> 17
}
func (o *PMU_Type) SetREG_2P5_TOG_ENABLE_WEAK_LINREG(value uint32) {
	volatile.StoreUint32(&o.REG_2P5_TOG.Reg, volatile.LoadUint32(&o.REG_2P5_TOG.Reg)&^(0x40000)|value<<18)
}
func (o *PMU_Type) GetREG_2P5_TOG_ENABLE_WEAK_LINREG() uint32 {
	return (volatile.LoadUint32(&o.REG_2P5_TOG.Reg) & 0x40000) >> 18
}

// PMU.REG_CORE: Digital Regulator Core Register
func (o *PMU_Type) SetREG_CORE_REG0_TARG(value uint32) {
	volatile.StoreUint32(&o.REG_CORE.Reg, volatile.LoadUint32(&o.REG_CORE.Reg)&^(0x1f)|value)
}
func (o *PMU_Type) GetREG_CORE_REG0_TARG() uint32 {
	return volatile.LoadUint32(&o.REG_CORE.Reg) & 0x1f
}
func (o *PMU_Type) SetREG_CORE_REG0_ADJ(value uint32) {
	volatile.StoreUint32(&o.REG_CORE.Reg, volatile.LoadUint32(&o.REG_CORE.Reg)&^(0x1e0)|value<<5)
}
func (o *PMU_Type) GetREG_CORE_REG0_ADJ() uint32 {
	return (volatile.LoadUint32(&o.REG_CORE.Reg) & 0x1e0) >> 5
}
func (o *PMU_Type) SetREG_CORE_REG1_TARG(value uint32) {
	volatile.StoreUint32(&o.REG_CORE.Reg, volatile.LoadUint32(&o.REG_CORE.Reg)&^(0x3e00)|value<<9)
}
func (o *PMU_Type) GetREG_CORE_REG1_TARG() uint32 {
	return (volatile.LoadUint32(&o.REG_CORE.Reg) & 0x3e00) >> 9
}
func (o *PMU_Type) SetREG_CORE_REG1_ADJ(value uint32) {
	volatile.StoreUint32(&o.REG_CORE.Reg, volatile.LoadUint32(&o.REG_CORE.Reg)&^(0x3c000)|value<<14)
}
func (o *PMU_Type) GetREG_CORE_REG1_ADJ() uint32 {
	return (volatile.LoadUint32(&o.REG_CORE.Reg) & 0x3c000) >> 14
}
func (o *PMU_Type) SetREG_CORE_REG2_TARG(value uint32) {
	volatile.StoreUint32(&o.REG_CORE.Reg, volatile.LoadUint32(&o.REG_CORE.Reg)&^(0x7c0000)|value<<18)
}
func (o *PMU_Type) GetREG_CORE_REG2_TARG() uint32 {
	return (volatile.LoadUint32(&o.REG_CORE.Reg) & 0x7c0000) >> 18
}
func (o *PMU_Type) SetREG_CORE_REG2_ADJ(value uint32) {
	volatile.StoreUint32(&o.REG_CORE.Reg, volatile.LoadUint32(&o.REG_CORE.Reg)&^(0x7800000)|value<<23)
}
func (o *PMU_Type) GetREG_CORE_REG2_ADJ() uint32 {
	return (volatile.LoadUint32(&o.REG_CORE.Reg) & 0x7800000) >> 23
}
func (o *PMU_Type) SetREG_CORE_RAMP_RATE(value uint32) {
	volatile.StoreUint32(&o.REG_CORE.Reg, volatile.LoadUint32(&o.REG_CORE.Reg)&^(0x18000000)|value<<27)
}
func (o *PMU_Type) GetREG_CORE_RAMP_RATE() uint32 {
	return (volatile.LoadUint32(&o.REG_CORE.Reg) & 0x18000000) >> 27
}
func (o *PMU_Type) SetREG_CORE_FET_ODRIVE(value uint32) {
	volatile.StoreUint32(&o.REG_CORE.Reg, volatile.LoadUint32(&o.REG_CORE.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetREG_CORE_FET_ODRIVE() uint32 {
	return (volatile.LoadUint32(&o.REG_CORE.Reg) & 0x20000000) >> 29
}

// PMU.REG_CORE_SET: Digital Regulator Core Register
func (o *PMU_Type) SetREG_CORE_SET_REG0_TARG(value uint32) {
	volatile.StoreUint32(&o.REG_CORE_SET.Reg, volatile.LoadUint32(&o.REG_CORE_SET.Reg)&^(0x1f)|value)
}
func (o *PMU_Type) GetREG_CORE_SET_REG0_TARG() uint32 {
	return volatile.LoadUint32(&o.REG_CORE_SET.Reg) & 0x1f
}
func (o *PMU_Type) SetREG_CORE_SET_REG0_ADJ(value uint32) {
	volatile.StoreUint32(&o.REG_CORE_SET.Reg, volatile.LoadUint32(&o.REG_CORE_SET.Reg)&^(0x1e0)|value<<5)
}
func (o *PMU_Type) GetREG_CORE_SET_REG0_ADJ() uint32 {
	return (volatile.LoadUint32(&o.REG_CORE_SET.Reg) & 0x1e0) >> 5
}
func (o *PMU_Type) SetREG_CORE_SET_REG1_TARG(value uint32) {
	volatile.StoreUint32(&o.REG_CORE_SET.Reg, volatile.LoadUint32(&o.REG_CORE_SET.Reg)&^(0x3e00)|value<<9)
}
func (o *PMU_Type) GetREG_CORE_SET_REG1_TARG() uint32 {
	return (volatile.LoadUint32(&o.REG_CORE_SET.Reg) & 0x3e00) >> 9
}
func (o *PMU_Type) SetREG_CORE_SET_REG1_ADJ(value uint32) {
	volatile.StoreUint32(&o.REG_CORE_SET.Reg, volatile.LoadUint32(&o.REG_CORE_SET.Reg)&^(0x3c000)|value<<14)
}
func (o *PMU_Type) GetREG_CORE_SET_REG1_ADJ() uint32 {
	return (volatile.LoadUint32(&o.REG_CORE_SET.Reg) & 0x3c000) >> 14
}
func (o *PMU_Type) SetREG_CORE_SET_REG2_TARG(value uint32) {
	volatile.StoreUint32(&o.REG_CORE_SET.Reg, volatile.LoadUint32(&o.REG_CORE_SET.Reg)&^(0x7c0000)|value<<18)
}
func (o *PMU_Type) GetREG_CORE_SET_REG2_TARG() uint32 {
	return (volatile.LoadUint32(&o.REG_CORE_SET.Reg) & 0x7c0000) >> 18
}
func (o *PMU_Type) SetREG_CORE_SET_REG2_ADJ(value uint32) {
	volatile.StoreUint32(&o.REG_CORE_SET.Reg, volatile.LoadUint32(&o.REG_CORE_SET.Reg)&^(0x7800000)|value<<23)
}
func (o *PMU_Type) GetREG_CORE_SET_REG2_ADJ() uint32 {
	return (volatile.LoadUint32(&o.REG_CORE_SET.Reg) & 0x7800000) >> 23
}
func (o *PMU_Type) SetREG_CORE_SET_RAMP_RATE(value uint32) {
	volatile.StoreUint32(&o.REG_CORE_SET.Reg, volatile.LoadUint32(&o.REG_CORE_SET.Reg)&^(0x18000000)|value<<27)
}
func (o *PMU_Type) GetREG_CORE_SET_RAMP_RATE() uint32 {
	return (volatile.LoadUint32(&o.REG_CORE_SET.Reg) & 0x18000000) >> 27
}
func (o *PMU_Type) SetREG_CORE_SET_FET_ODRIVE(value uint32) {
	volatile.StoreUint32(&o.REG_CORE_SET.Reg, volatile.LoadUint32(&o.REG_CORE_SET.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetREG_CORE_SET_FET_ODRIVE() uint32 {
	return (volatile.LoadUint32(&o.REG_CORE_SET.Reg) & 0x20000000) >> 29
}

// PMU.REG_CORE_CLR: Digital Regulator Core Register
func (o *PMU_Type) SetREG_CORE_CLR_REG0_TARG(value uint32) {
	volatile.StoreUint32(&o.REG_CORE_CLR.Reg, volatile.LoadUint32(&o.REG_CORE_CLR.Reg)&^(0x1f)|value)
}
func (o *PMU_Type) GetREG_CORE_CLR_REG0_TARG() uint32 {
	return volatile.LoadUint32(&o.REG_CORE_CLR.Reg) & 0x1f
}
func (o *PMU_Type) SetREG_CORE_CLR_REG0_ADJ(value uint32) {
	volatile.StoreUint32(&o.REG_CORE_CLR.Reg, volatile.LoadUint32(&o.REG_CORE_CLR.Reg)&^(0x1e0)|value<<5)
}
func (o *PMU_Type) GetREG_CORE_CLR_REG0_ADJ() uint32 {
	return (volatile.LoadUint32(&o.REG_CORE_CLR.Reg) & 0x1e0) >> 5
}
func (o *PMU_Type) SetREG_CORE_CLR_REG1_TARG(value uint32) {
	volatile.StoreUint32(&o.REG_CORE_CLR.Reg, volatile.LoadUint32(&o.REG_CORE_CLR.Reg)&^(0x3e00)|value<<9)
}
func (o *PMU_Type) GetREG_CORE_CLR_REG1_TARG() uint32 {
	return (volatile.LoadUint32(&o.REG_CORE_CLR.Reg) & 0x3e00) >> 9
}
func (o *PMU_Type) SetREG_CORE_CLR_REG1_ADJ(value uint32) {
	volatile.StoreUint32(&o.REG_CORE_CLR.Reg, volatile.LoadUint32(&o.REG_CORE_CLR.Reg)&^(0x3c000)|value<<14)
}
func (o *PMU_Type) GetREG_CORE_CLR_REG1_ADJ() uint32 {
	return (volatile.LoadUint32(&o.REG_CORE_CLR.Reg) & 0x3c000) >> 14
}
func (o *PMU_Type) SetREG_CORE_CLR_REG2_TARG(value uint32) {
	volatile.StoreUint32(&o.REG_CORE_CLR.Reg, volatile.LoadUint32(&o.REG_CORE_CLR.Reg)&^(0x7c0000)|value<<18)
}
func (o *PMU_Type) GetREG_CORE_CLR_REG2_TARG() uint32 {
	return (volatile.LoadUint32(&o.REG_CORE_CLR.Reg) & 0x7c0000) >> 18
}
func (o *PMU_Type) SetREG_CORE_CLR_REG2_ADJ(value uint32) {
	volatile.StoreUint32(&o.REG_CORE_CLR.Reg, volatile.LoadUint32(&o.REG_CORE_CLR.Reg)&^(0x7800000)|value<<23)
}
func (o *PMU_Type) GetREG_CORE_CLR_REG2_ADJ() uint32 {
	return (volatile.LoadUint32(&o.REG_CORE_CLR.Reg) & 0x7800000) >> 23
}
func (o *PMU_Type) SetREG_CORE_CLR_RAMP_RATE(value uint32) {
	volatile.StoreUint32(&o.REG_CORE_CLR.Reg, volatile.LoadUint32(&o.REG_CORE_CLR.Reg)&^(0x18000000)|value<<27)
}
func (o *PMU_Type) GetREG_CORE_CLR_RAMP_RATE() uint32 {
	return (volatile.LoadUint32(&o.REG_CORE_CLR.Reg) & 0x18000000) >> 27
}
func (o *PMU_Type) SetREG_CORE_CLR_FET_ODRIVE(value uint32) {
	volatile.StoreUint32(&o.REG_CORE_CLR.Reg, volatile.LoadUint32(&o.REG_CORE_CLR.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetREG_CORE_CLR_FET_ODRIVE() uint32 {
	return (volatile.LoadUint32(&o.REG_CORE_CLR.Reg) & 0x20000000) >> 29
}

// PMU.REG_CORE_TOG: Digital Regulator Core Register
func (o *PMU_Type) SetREG_CORE_TOG_REG0_TARG(value uint32) {
	volatile.StoreUint32(&o.REG_CORE_TOG.Reg, volatile.LoadUint32(&o.REG_CORE_TOG.Reg)&^(0x1f)|value)
}
func (o *PMU_Type) GetREG_CORE_TOG_REG0_TARG() uint32 {
	return volatile.LoadUint32(&o.REG_CORE_TOG.Reg) & 0x1f
}
func (o *PMU_Type) SetREG_CORE_TOG_REG0_ADJ(value uint32) {
	volatile.StoreUint32(&o.REG_CORE_TOG.Reg, volatile.LoadUint32(&o.REG_CORE_TOG.Reg)&^(0x1e0)|value<<5)
}
func (o *PMU_Type) GetREG_CORE_TOG_REG0_ADJ() uint32 {
	return (volatile.LoadUint32(&o.REG_CORE_TOG.Reg) & 0x1e0) >> 5
}
func (o *PMU_Type) SetREG_CORE_TOG_REG1_TARG(value uint32) {
	volatile.StoreUint32(&o.REG_CORE_TOG.Reg, volatile.LoadUint32(&o.REG_CORE_TOG.Reg)&^(0x3e00)|value<<9)
}
func (o *PMU_Type) GetREG_CORE_TOG_REG1_TARG() uint32 {
	return (volatile.LoadUint32(&o.REG_CORE_TOG.Reg) & 0x3e00) >> 9
}
func (o *PMU_Type) SetREG_CORE_TOG_REG1_ADJ(value uint32) {
	volatile.StoreUint32(&o.REG_CORE_TOG.Reg, volatile.LoadUint32(&o.REG_CORE_TOG.Reg)&^(0x3c000)|value<<14)
}
func (o *PMU_Type) GetREG_CORE_TOG_REG1_ADJ() uint32 {
	return (volatile.LoadUint32(&o.REG_CORE_TOG.Reg) & 0x3c000) >> 14
}
func (o *PMU_Type) SetREG_CORE_TOG_REG2_TARG(value uint32) {
	volatile.StoreUint32(&o.REG_CORE_TOG.Reg, volatile.LoadUint32(&o.REG_CORE_TOG.Reg)&^(0x7c0000)|value<<18)
}
func (o *PMU_Type) GetREG_CORE_TOG_REG2_TARG() uint32 {
	return (volatile.LoadUint32(&o.REG_CORE_TOG.Reg) & 0x7c0000) >> 18
}
func (o *PMU_Type) SetREG_CORE_TOG_REG2_ADJ(value uint32) {
	volatile.StoreUint32(&o.REG_CORE_TOG.Reg, volatile.LoadUint32(&o.REG_CORE_TOG.Reg)&^(0x7800000)|value<<23)
}
func (o *PMU_Type) GetREG_CORE_TOG_REG2_ADJ() uint32 {
	return (volatile.LoadUint32(&o.REG_CORE_TOG.Reg) & 0x7800000) >> 23
}
func (o *PMU_Type) SetREG_CORE_TOG_RAMP_RATE(value uint32) {
	volatile.StoreUint32(&o.REG_CORE_TOG.Reg, volatile.LoadUint32(&o.REG_CORE_TOG.Reg)&^(0x18000000)|value<<27)
}
func (o *PMU_Type) GetREG_CORE_TOG_RAMP_RATE() uint32 {
	return (volatile.LoadUint32(&o.REG_CORE_TOG.Reg) & 0x18000000) >> 27
}
func (o *PMU_Type) SetREG_CORE_TOG_FET_ODRIVE(value uint32) {
	volatile.StoreUint32(&o.REG_CORE_TOG.Reg, volatile.LoadUint32(&o.REG_CORE_TOG.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetREG_CORE_TOG_FET_ODRIVE() uint32 {
	return (volatile.LoadUint32(&o.REG_CORE_TOG.Reg) & 0x20000000) >> 29
}

// PMU.MISC0: Miscellaneous Register 0
func (o *PMU_Type) SetMISC0_REFTOP_PWD(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x1)|value)
}
func (o *PMU_Type) GetMISC0_REFTOP_PWD() uint32 {
	return volatile.LoadUint32(&o.MISC0.Reg) & 0x1
}
func (o *PMU_Type) SetMISC0_REFTOP_PWDVBGUP(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x2)|value<<1)
}
func (o *PMU_Type) GetMISC0_REFTOP_PWDVBGUP() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x2) >> 1
}
func (o *PMU_Type) SetMISC0_REFTOP_LOWPOWER(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x4)|value<<2)
}
func (o *PMU_Type) GetMISC0_REFTOP_LOWPOWER() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x4) >> 2
}
func (o *PMU_Type) SetMISC0_REFTOP_SELFBIASOFF(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x8)|value<<3)
}
func (o *PMU_Type) GetMISC0_REFTOP_SELFBIASOFF() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x8) >> 3
}
func (o *PMU_Type) SetMISC0_REFTOP_VBGADJ(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x70)|value<<4)
}
func (o *PMU_Type) GetMISC0_REFTOP_VBGADJ() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x70) >> 4
}
func (o *PMU_Type) SetMISC0_REFTOP_VBGUP(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x80)|value<<7)
}
func (o *PMU_Type) GetMISC0_REFTOP_VBGUP() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x80) >> 7
}
func (o *PMU_Type) SetMISC0_STOP_MODE_CONFIG(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0xc00)|value<<10)
}
func (o *PMU_Type) GetMISC0_STOP_MODE_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0xc00) >> 10
}
func (o *PMU_Type) SetMISC0_DISCON_HIGH_SNVS(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x1000)|value<<12)
}
func (o *PMU_Type) GetMISC0_DISCON_HIGH_SNVS() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x1000) >> 12
}
func (o *PMU_Type) SetMISC0_OSC_I(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x6000)|value<<13)
}
func (o *PMU_Type) GetMISC0_OSC_I() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x6000) >> 13
}
func (o *PMU_Type) SetMISC0_OSC_XTALOK(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x8000)|value<<15)
}
func (o *PMU_Type) GetMISC0_OSC_XTALOK() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x8000) >> 15
}
func (o *PMU_Type) SetMISC0_OSC_XTALOK_EN(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x10000)|value<<16)
}
func (o *PMU_Type) GetMISC0_OSC_XTALOK_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x10000) >> 16
}
func (o *PMU_Type) SetMISC0_CLKGATE_CTRL(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x2000000)|value<<25)
}
func (o *PMU_Type) GetMISC0_CLKGATE_CTRL() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x2000000) >> 25
}
func (o *PMU_Type) SetMISC0_CLKGATE_DELAY(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x1c000000)|value<<26)
}
func (o *PMU_Type) GetMISC0_CLKGATE_DELAY() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x1c000000) >> 26
}
func (o *PMU_Type) SetMISC0_RTC_XTAL_SOURCE(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetMISC0_RTC_XTAL_SOURCE() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetMISC0_XTAL_24M_PWD(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetMISC0_XTAL_24M_PWD() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x40000000) >> 30
}

// PMU.MISC0_SET: Miscellaneous Register 0
func (o *PMU_Type) SetMISC0_SET_REFTOP_PWD(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x1)|value)
}
func (o *PMU_Type) GetMISC0_SET_REFTOP_PWD() uint32 {
	return volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x1
}
func (o *PMU_Type) SetMISC0_SET_REFTOP_PWDVBGUP(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x2)|value<<1)
}
func (o *PMU_Type) GetMISC0_SET_REFTOP_PWDVBGUP() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x2) >> 1
}
func (o *PMU_Type) SetMISC0_SET_REFTOP_LOWPOWER(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x4)|value<<2)
}
func (o *PMU_Type) GetMISC0_SET_REFTOP_LOWPOWER() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x4) >> 2
}
func (o *PMU_Type) SetMISC0_SET_REFTOP_SELFBIASOFF(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x8)|value<<3)
}
func (o *PMU_Type) GetMISC0_SET_REFTOP_SELFBIASOFF() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x8) >> 3
}
func (o *PMU_Type) SetMISC0_SET_REFTOP_VBGADJ(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x70)|value<<4)
}
func (o *PMU_Type) GetMISC0_SET_REFTOP_VBGADJ() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x70) >> 4
}
func (o *PMU_Type) SetMISC0_SET_REFTOP_VBGUP(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x80)|value<<7)
}
func (o *PMU_Type) GetMISC0_SET_REFTOP_VBGUP() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x80) >> 7
}
func (o *PMU_Type) SetMISC0_SET_STOP_MODE_CONFIG(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0xc00)|value<<10)
}
func (o *PMU_Type) GetMISC0_SET_STOP_MODE_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0xc00) >> 10
}
func (o *PMU_Type) SetMISC0_SET_DISCON_HIGH_SNVS(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x1000)|value<<12)
}
func (o *PMU_Type) GetMISC0_SET_DISCON_HIGH_SNVS() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x1000) >> 12
}
func (o *PMU_Type) SetMISC0_SET_OSC_I(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x6000)|value<<13)
}
func (o *PMU_Type) GetMISC0_SET_OSC_I() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x6000) >> 13
}
func (o *PMU_Type) SetMISC0_SET_OSC_XTALOK(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x8000)|value<<15)
}
func (o *PMU_Type) GetMISC0_SET_OSC_XTALOK() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x8000) >> 15
}
func (o *PMU_Type) SetMISC0_SET_OSC_XTALOK_EN(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x10000)|value<<16)
}
func (o *PMU_Type) GetMISC0_SET_OSC_XTALOK_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x10000) >> 16
}
func (o *PMU_Type) SetMISC0_SET_CLKGATE_CTRL(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x2000000)|value<<25)
}
func (o *PMU_Type) GetMISC0_SET_CLKGATE_CTRL() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x2000000) >> 25
}
func (o *PMU_Type) SetMISC0_SET_CLKGATE_DELAY(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x1c000000)|value<<26)
}
func (o *PMU_Type) GetMISC0_SET_CLKGATE_DELAY() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x1c000000) >> 26
}
func (o *PMU_Type) SetMISC0_SET_RTC_XTAL_SOURCE(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetMISC0_SET_RTC_XTAL_SOURCE() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetMISC0_SET_XTAL_24M_PWD(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetMISC0_SET_XTAL_24M_PWD() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x40000000) >> 30
}

// PMU.MISC0_CLR: Miscellaneous Register 0
func (o *PMU_Type) SetMISC0_CLR_REFTOP_PWD(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x1)|value)
}
func (o *PMU_Type) GetMISC0_CLR_REFTOP_PWD() uint32 {
	return volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x1
}
func (o *PMU_Type) SetMISC0_CLR_REFTOP_PWDVBGUP(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x2)|value<<1)
}
func (o *PMU_Type) GetMISC0_CLR_REFTOP_PWDVBGUP() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x2) >> 1
}
func (o *PMU_Type) SetMISC0_CLR_REFTOP_LOWPOWER(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x4)|value<<2)
}
func (o *PMU_Type) GetMISC0_CLR_REFTOP_LOWPOWER() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x4) >> 2
}
func (o *PMU_Type) SetMISC0_CLR_REFTOP_SELFBIASOFF(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x8)|value<<3)
}
func (o *PMU_Type) GetMISC0_CLR_REFTOP_SELFBIASOFF() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x8) >> 3
}
func (o *PMU_Type) SetMISC0_CLR_REFTOP_VBGADJ(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x70)|value<<4)
}
func (o *PMU_Type) GetMISC0_CLR_REFTOP_VBGADJ() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x70) >> 4
}
func (o *PMU_Type) SetMISC0_CLR_REFTOP_VBGUP(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x80)|value<<7)
}
func (o *PMU_Type) GetMISC0_CLR_REFTOP_VBGUP() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x80) >> 7
}
func (o *PMU_Type) SetMISC0_CLR_STOP_MODE_CONFIG(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0xc00)|value<<10)
}
func (o *PMU_Type) GetMISC0_CLR_STOP_MODE_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0xc00) >> 10
}
func (o *PMU_Type) SetMISC0_CLR_DISCON_HIGH_SNVS(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *PMU_Type) GetMISC0_CLR_DISCON_HIGH_SNVS() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x1000) >> 12
}
func (o *PMU_Type) SetMISC0_CLR_OSC_I(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x6000)|value<<13)
}
func (o *PMU_Type) GetMISC0_CLR_OSC_I() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x6000) >> 13
}
func (o *PMU_Type) SetMISC0_CLR_OSC_XTALOK(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *PMU_Type) GetMISC0_CLR_OSC_XTALOK() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x8000) >> 15
}
func (o *PMU_Type) SetMISC0_CLR_OSC_XTALOK_EN(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *PMU_Type) GetMISC0_CLR_OSC_XTALOK_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x10000) >> 16
}
func (o *PMU_Type) SetMISC0_CLR_CLKGATE_CTRL(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x2000000)|value<<25)
}
func (o *PMU_Type) GetMISC0_CLR_CLKGATE_CTRL() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x2000000) >> 25
}
func (o *PMU_Type) SetMISC0_CLR_CLKGATE_DELAY(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x1c000000)|value<<26)
}
func (o *PMU_Type) GetMISC0_CLR_CLKGATE_DELAY() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x1c000000) >> 26
}
func (o *PMU_Type) SetMISC0_CLR_RTC_XTAL_SOURCE(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetMISC0_CLR_RTC_XTAL_SOURCE() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetMISC0_CLR_XTAL_24M_PWD(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetMISC0_CLR_XTAL_24M_PWD() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x40000000) >> 30
}

// PMU.MISC0_TOG: Miscellaneous Register 0
func (o *PMU_Type) SetMISC0_TOG_REFTOP_PWD(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x1)|value)
}
func (o *PMU_Type) GetMISC0_TOG_REFTOP_PWD() uint32 {
	return volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x1
}
func (o *PMU_Type) SetMISC0_TOG_REFTOP_PWDVBGUP(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x2)|value<<1)
}
func (o *PMU_Type) GetMISC0_TOG_REFTOP_PWDVBGUP() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x2) >> 1
}
func (o *PMU_Type) SetMISC0_TOG_REFTOP_LOWPOWER(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x4)|value<<2)
}
func (o *PMU_Type) GetMISC0_TOG_REFTOP_LOWPOWER() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x4) >> 2
}
func (o *PMU_Type) SetMISC0_TOG_REFTOP_SELFBIASOFF(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x8)|value<<3)
}
func (o *PMU_Type) GetMISC0_TOG_REFTOP_SELFBIASOFF() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x8) >> 3
}
func (o *PMU_Type) SetMISC0_TOG_REFTOP_VBGADJ(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x70)|value<<4)
}
func (o *PMU_Type) GetMISC0_TOG_REFTOP_VBGADJ() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x70) >> 4
}
func (o *PMU_Type) SetMISC0_TOG_REFTOP_VBGUP(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x80)|value<<7)
}
func (o *PMU_Type) GetMISC0_TOG_REFTOP_VBGUP() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x80) >> 7
}
func (o *PMU_Type) SetMISC0_TOG_STOP_MODE_CONFIG(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0xc00)|value<<10)
}
func (o *PMU_Type) GetMISC0_TOG_STOP_MODE_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0xc00) >> 10
}
func (o *PMU_Type) SetMISC0_TOG_DISCON_HIGH_SNVS(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x1000)|value<<12)
}
func (o *PMU_Type) GetMISC0_TOG_DISCON_HIGH_SNVS() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x1000) >> 12
}
func (o *PMU_Type) SetMISC0_TOG_OSC_I(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x6000)|value<<13)
}
func (o *PMU_Type) GetMISC0_TOG_OSC_I() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x6000) >> 13
}
func (o *PMU_Type) SetMISC0_TOG_OSC_XTALOK(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x8000)|value<<15)
}
func (o *PMU_Type) GetMISC0_TOG_OSC_XTALOK() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x8000) >> 15
}
func (o *PMU_Type) SetMISC0_TOG_OSC_XTALOK_EN(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x10000)|value<<16)
}
func (o *PMU_Type) GetMISC0_TOG_OSC_XTALOK_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x10000) >> 16
}
func (o *PMU_Type) SetMISC0_TOG_CLKGATE_CTRL(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x2000000)|value<<25)
}
func (o *PMU_Type) GetMISC0_TOG_CLKGATE_CTRL() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x2000000) >> 25
}
func (o *PMU_Type) SetMISC0_TOG_CLKGATE_DELAY(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x1c000000)|value<<26)
}
func (o *PMU_Type) GetMISC0_TOG_CLKGATE_DELAY() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x1c000000) >> 26
}
func (o *PMU_Type) SetMISC0_TOG_RTC_XTAL_SOURCE(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetMISC0_TOG_RTC_XTAL_SOURCE() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetMISC0_TOG_XTAL_24M_PWD(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetMISC0_TOG_XTAL_24M_PWD() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x40000000) >> 30
}

// PMU.MISC1: Miscellaneous Register 1
func (o *PMU_Type) SetMISC1_PFD_480_AUTOGATE_EN(value uint32) {
	volatile.StoreUint32(&o.MISC1.Reg, volatile.LoadUint32(&o.MISC1.Reg)&^(0x10000)|value<<16)
}
func (o *PMU_Type) GetMISC1_PFD_480_AUTOGATE_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC1.Reg) & 0x10000) >> 16
}
func (o *PMU_Type) SetMISC1_PFD_528_AUTOGATE_EN(value uint32) {
	volatile.StoreUint32(&o.MISC1.Reg, volatile.LoadUint32(&o.MISC1.Reg)&^(0x20000)|value<<17)
}
func (o *PMU_Type) GetMISC1_PFD_528_AUTOGATE_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC1.Reg) & 0x20000) >> 17
}
func (o *PMU_Type) SetMISC1_IRQ_TEMPPANIC(value uint32) {
	volatile.StoreUint32(&o.MISC1.Reg, volatile.LoadUint32(&o.MISC1.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetMISC1_IRQ_TEMPPANIC() uint32 {
	return (volatile.LoadUint32(&o.MISC1.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetMISC1_IRQ_TEMPLOW(value uint32) {
	volatile.StoreUint32(&o.MISC1.Reg, volatile.LoadUint32(&o.MISC1.Reg)&^(0x10000000)|value<<28)
}
func (o *PMU_Type) GetMISC1_IRQ_TEMPLOW() uint32 {
	return (volatile.LoadUint32(&o.MISC1.Reg) & 0x10000000) >> 28
}
func (o *PMU_Type) SetMISC1_IRQ_TEMPHIGH(value uint32) {
	volatile.StoreUint32(&o.MISC1.Reg, volatile.LoadUint32(&o.MISC1.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetMISC1_IRQ_TEMPHIGH() uint32 {
	return (volatile.LoadUint32(&o.MISC1.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetMISC1_IRQ_ANA_BO(value uint32) {
	volatile.StoreUint32(&o.MISC1.Reg, volatile.LoadUint32(&o.MISC1.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetMISC1_IRQ_ANA_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC1.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetMISC1_IRQ_DIG_BO(value uint32) {
	volatile.StoreUint32(&o.MISC1.Reg, volatile.LoadUint32(&o.MISC1.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetMISC1_IRQ_DIG_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC1.Reg) & 0x80000000) >> 31
}

// PMU.MISC1_SET: Miscellaneous Register 1
func (o *PMU_Type) SetMISC1_SET_PFD_480_AUTOGATE_EN(value uint32) {
	volatile.StoreUint32(&o.MISC1_SET.Reg, volatile.LoadUint32(&o.MISC1_SET.Reg)&^(0x10000)|value<<16)
}
func (o *PMU_Type) GetMISC1_SET_PFD_480_AUTOGATE_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC1_SET.Reg) & 0x10000) >> 16
}
func (o *PMU_Type) SetMISC1_SET_PFD_528_AUTOGATE_EN(value uint32) {
	volatile.StoreUint32(&o.MISC1_SET.Reg, volatile.LoadUint32(&o.MISC1_SET.Reg)&^(0x20000)|value<<17)
}
func (o *PMU_Type) GetMISC1_SET_PFD_528_AUTOGATE_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC1_SET.Reg) & 0x20000) >> 17
}
func (o *PMU_Type) SetMISC1_SET_IRQ_TEMPPANIC(value uint32) {
	volatile.StoreUint32(&o.MISC1_SET.Reg, volatile.LoadUint32(&o.MISC1_SET.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetMISC1_SET_IRQ_TEMPPANIC() uint32 {
	return (volatile.LoadUint32(&o.MISC1_SET.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetMISC1_SET_IRQ_TEMPLOW(value uint32) {
	volatile.StoreUint32(&o.MISC1_SET.Reg, volatile.LoadUint32(&o.MISC1_SET.Reg)&^(0x10000000)|value<<28)
}
func (o *PMU_Type) GetMISC1_SET_IRQ_TEMPLOW() uint32 {
	return (volatile.LoadUint32(&o.MISC1_SET.Reg) & 0x10000000) >> 28
}
func (o *PMU_Type) SetMISC1_SET_IRQ_TEMPHIGH(value uint32) {
	volatile.StoreUint32(&o.MISC1_SET.Reg, volatile.LoadUint32(&o.MISC1_SET.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetMISC1_SET_IRQ_TEMPHIGH() uint32 {
	return (volatile.LoadUint32(&o.MISC1_SET.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetMISC1_SET_IRQ_ANA_BO(value uint32) {
	volatile.StoreUint32(&o.MISC1_SET.Reg, volatile.LoadUint32(&o.MISC1_SET.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetMISC1_SET_IRQ_ANA_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC1_SET.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetMISC1_SET_IRQ_DIG_BO(value uint32) {
	volatile.StoreUint32(&o.MISC1_SET.Reg, volatile.LoadUint32(&o.MISC1_SET.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetMISC1_SET_IRQ_DIG_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC1_SET.Reg) & 0x80000000) >> 31
}

// PMU.MISC1_CLR: Miscellaneous Register 1
func (o *PMU_Type) SetMISC1_CLR_PFD_480_AUTOGATE_EN(value uint32) {
	volatile.StoreUint32(&o.MISC1_CLR.Reg, volatile.LoadUint32(&o.MISC1_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *PMU_Type) GetMISC1_CLR_PFD_480_AUTOGATE_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC1_CLR.Reg) & 0x10000) >> 16
}
func (o *PMU_Type) SetMISC1_CLR_PFD_528_AUTOGATE_EN(value uint32) {
	volatile.StoreUint32(&o.MISC1_CLR.Reg, volatile.LoadUint32(&o.MISC1_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *PMU_Type) GetMISC1_CLR_PFD_528_AUTOGATE_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC1_CLR.Reg) & 0x20000) >> 17
}
func (o *PMU_Type) SetMISC1_CLR_IRQ_TEMPPANIC(value uint32) {
	volatile.StoreUint32(&o.MISC1_CLR.Reg, volatile.LoadUint32(&o.MISC1_CLR.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetMISC1_CLR_IRQ_TEMPPANIC() uint32 {
	return (volatile.LoadUint32(&o.MISC1_CLR.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetMISC1_CLR_IRQ_TEMPLOW(value uint32) {
	volatile.StoreUint32(&o.MISC1_CLR.Reg, volatile.LoadUint32(&o.MISC1_CLR.Reg)&^(0x10000000)|value<<28)
}
func (o *PMU_Type) GetMISC1_CLR_IRQ_TEMPLOW() uint32 {
	return (volatile.LoadUint32(&o.MISC1_CLR.Reg) & 0x10000000) >> 28
}
func (o *PMU_Type) SetMISC1_CLR_IRQ_TEMPHIGH(value uint32) {
	volatile.StoreUint32(&o.MISC1_CLR.Reg, volatile.LoadUint32(&o.MISC1_CLR.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetMISC1_CLR_IRQ_TEMPHIGH() uint32 {
	return (volatile.LoadUint32(&o.MISC1_CLR.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetMISC1_CLR_IRQ_ANA_BO(value uint32) {
	volatile.StoreUint32(&o.MISC1_CLR.Reg, volatile.LoadUint32(&o.MISC1_CLR.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetMISC1_CLR_IRQ_ANA_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC1_CLR.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetMISC1_CLR_IRQ_DIG_BO(value uint32) {
	volatile.StoreUint32(&o.MISC1_CLR.Reg, volatile.LoadUint32(&o.MISC1_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetMISC1_CLR_IRQ_DIG_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC1_CLR.Reg) & 0x80000000) >> 31
}

// PMU.MISC1_TOG: Miscellaneous Register 1
func (o *PMU_Type) SetMISC1_TOG_PFD_480_AUTOGATE_EN(value uint32) {
	volatile.StoreUint32(&o.MISC1_TOG.Reg, volatile.LoadUint32(&o.MISC1_TOG.Reg)&^(0x10000)|value<<16)
}
func (o *PMU_Type) GetMISC1_TOG_PFD_480_AUTOGATE_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC1_TOG.Reg) & 0x10000) >> 16
}
func (o *PMU_Type) SetMISC1_TOG_PFD_528_AUTOGATE_EN(value uint32) {
	volatile.StoreUint32(&o.MISC1_TOG.Reg, volatile.LoadUint32(&o.MISC1_TOG.Reg)&^(0x20000)|value<<17)
}
func (o *PMU_Type) GetMISC1_TOG_PFD_528_AUTOGATE_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC1_TOG.Reg) & 0x20000) >> 17
}
func (o *PMU_Type) SetMISC1_TOG_IRQ_TEMPPANIC(value uint32) {
	volatile.StoreUint32(&o.MISC1_TOG.Reg, volatile.LoadUint32(&o.MISC1_TOG.Reg)&^(0x8000000)|value<<27)
}
func (o *PMU_Type) GetMISC1_TOG_IRQ_TEMPPANIC() uint32 {
	return (volatile.LoadUint32(&o.MISC1_TOG.Reg) & 0x8000000) >> 27
}
func (o *PMU_Type) SetMISC1_TOG_IRQ_TEMPLOW(value uint32) {
	volatile.StoreUint32(&o.MISC1_TOG.Reg, volatile.LoadUint32(&o.MISC1_TOG.Reg)&^(0x10000000)|value<<28)
}
func (o *PMU_Type) GetMISC1_TOG_IRQ_TEMPLOW() uint32 {
	return (volatile.LoadUint32(&o.MISC1_TOG.Reg) & 0x10000000) >> 28
}
func (o *PMU_Type) SetMISC1_TOG_IRQ_TEMPHIGH(value uint32) {
	volatile.StoreUint32(&o.MISC1_TOG.Reg, volatile.LoadUint32(&o.MISC1_TOG.Reg)&^(0x20000000)|value<<29)
}
func (o *PMU_Type) GetMISC1_TOG_IRQ_TEMPHIGH() uint32 {
	return (volatile.LoadUint32(&o.MISC1_TOG.Reg) & 0x20000000) >> 29
}
func (o *PMU_Type) SetMISC1_TOG_IRQ_ANA_BO(value uint32) {
	volatile.StoreUint32(&o.MISC1_TOG.Reg, volatile.LoadUint32(&o.MISC1_TOG.Reg)&^(0x40000000)|value<<30)
}
func (o *PMU_Type) GetMISC1_TOG_IRQ_ANA_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC1_TOG.Reg) & 0x40000000) >> 30
}
func (o *PMU_Type) SetMISC1_TOG_IRQ_DIG_BO(value uint32) {
	volatile.StoreUint32(&o.MISC1_TOG.Reg, volatile.LoadUint32(&o.MISC1_TOG.Reg)&^(0x80000000)|value<<31)
}
func (o *PMU_Type) GetMISC1_TOG_IRQ_DIG_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC1_TOG.Reg) & 0x80000000) >> 31
}

// PMU.MISC2: Miscellaneous Control Register
func (o *PMU_Type) SetMISC2_REG0_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x7)|value)
}
func (o *PMU_Type) GetMISC2_REG0_BO_OFFSET() uint32 {
	return volatile.LoadUint32(&o.MISC2.Reg) & 0x7
}
func (o *PMU_Type) SetMISC2_REG0_BO_STATUS(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x8)|value<<3)
}
func (o *PMU_Type) GetMISC2_REG0_BO_STATUS() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x8) >> 3
}
func (o *PMU_Type) SetMISC2_REG0_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x20)|value<<5)
}
func (o *PMU_Type) GetMISC2_REG0_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x20) >> 5
}
func (o *PMU_Type) SetMISC2_PLL3_disable(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x80)|value<<7)
}
func (o *PMU_Type) GetMISC2_PLL3_disable() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x80) >> 7
}
func (o *PMU_Type) SetMISC2_REG1_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x700)|value<<8)
}
func (o *PMU_Type) GetMISC2_REG1_BO_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x700) >> 8
}
func (o *PMU_Type) SetMISC2_REG1_BO_STATUS(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x800)|value<<11)
}
func (o *PMU_Type) GetMISC2_REG1_BO_STATUS() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x800) >> 11
}
func (o *PMU_Type) SetMISC2_REG1_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x2000)|value<<13)
}
func (o *PMU_Type) GetMISC2_REG1_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x2000) >> 13
}
func (o *PMU_Type) SetMISC2_AUDIO_DIV_LSB(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x8000)|value<<15)
}
func (o *PMU_Type) GetMISC2_AUDIO_DIV_LSB() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x8000) >> 15
}
func (o *PMU_Type) SetMISC2_REG2_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x70000)|value<<16)
}
func (o *PMU_Type) GetMISC2_REG2_BO_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x70000) >> 16
}
func (o *PMU_Type) SetMISC2_REG2_BO_STATUS(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x80000)|value<<19)
}
func (o *PMU_Type) GetMISC2_REG2_BO_STATUS() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x80000) >> 19
}
func (o *PMU_Type) SetMISC2_REG2_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x200000)|value<<21)
}
func (o *PMU_Type) GetMISC2_REG2_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x200000) >> 21
}
func (o *PMU_Type) SetMISC2_REG2_OK(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x400000)|value<<22)
}
func (o *PMU_Type) GetMISC2_REG2_OK() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x400000) >> 22
}
func (o *PMU_Type) SetMISC2_AUDIO_DIV_MSB(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x800000)|value<<23)
}
func (o *PMU_Type) GetMISC2_AUDIO_DIV_MSB() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x800000) >> 23
}
func (o *PMU_Type) SetMISC2_REG0_STEP_TIME(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x3000000)|value<<24)
}
func (o *PMU_Type) GetMISC2_REG0_STEP_TIME() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x3000000) >> 24
}
func (o *PMU_Type) SetMISC2_REG1_STEP_TIME(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0xc000000)|value<<26)
}
func (o *PMU_Type) GetMISC2_REG1_STEP_TIME() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0xc000000) >> 26
}
func (o *PMU_Type) SetMISC2_REG2_STEP_TIME(value uint32) {
	volatile.StoreUint32(&o.MISC2.Reg, volatile.LoadUint32(&o.MISC2.Reg)&^(0x30000000)|value<<28)
}
func (o *PMU_Type) GetMISC2_REG2_STEP_TIME() uint32 {
	return (volatile.LoadUint32(&o.MISC2.Reg) & 0x30000000) >> 28
}

// PMU.MISC2_SET: Miscellaneous Control Register
func (o *PMU_Type) SetMISC2_SET_REG0_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x7)|value)
}
func (o *PMU_Type) GetMISC2_SET_REG0_BO_OFFSET() uint32 {
	return volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x7
}
func (o *PMU_Type) SetMISC2_SET_REG0_BO_STATUS(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x8)|value<<3)
}
func (o *PMU_Type) GetMISC2_SET_REG0_BO_STATUS() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x8) >> 3
}
func (o *PMU_Type) SetMISC2_SET_REG0_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x20)|value<<5)
}
func (o *PMU_Type) GetMISC2_SET_REG0_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x20) >> 5
}
func (o *PMU_Type) SetMISC2_SET_PLL3_disable(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x80)|value<<7)
}
func (o *PMU_Type) GetMISC2_SET_PLL3_disable() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x80) >> 7
}
func (o *PMU_Type) SetMISC2_SET_REG1_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x700)|value<<8)
}
func (o *PMU_Type) GetMISC2_SET_REG1_BO_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x700) >> 8
}
func (o *PMU_Type) SetMISC2_SET_REG1_BO_STATUS(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x800)|value<<11)
}
func (o *PMU_Type) GetMISC2_SET_REG1_BO_STATUS() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x800) >> 11
}
func (o *PMU_Type) SetMISC2_SET_REG1_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x2000)|value<<13)
}
func (o *PMU_Type) GetMISC2_SET_REG1_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x2000) >> 13
}
func (o *PMU_Type) SetMISC2_SET_AUDIO_DIV_LSB(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x8000)|value<<15)
}
func (o *PMU_Type) GetMISC2_SET_AUDIO_DIV_LSB() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x8000) >> 15
}
func (o *PMU_Type) SetMISC2_SET_REG2_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x70000)|value<<16)
}
func (o *PMU_Type) GetMISC2_SET_REG2_BO_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x70000) >> 16
}
func (o *PMU_Type) SetMISC2_SET_REG2_BO_STATUS(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x80000)|value<<19)
}
func (o *PMU_Type) GetMISC2_SET_REG2_BO_STATUS() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x80000) >> 19
}
func (o *PMU_Type) SetMISC2_SET_REG2_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x200000)|value<<21)
}
func (o *PMU_Type) GetMISC2_SET_REG2_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x200000) >> 21
}
func (o *PMU_Type) SetMISC2_SET_REG2_OK(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x400000)|value<<22)
}
func (o *PMU_Type) GetMISC2_SET_REG2_OK() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x400000) >> 22
}
func (o *PMU_Type) SetMISC2_SET_AUDIO_DIV_MSB(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x800000)|value<<23)
}
func (o *PMU_Type) GetMISC2_SET_AUDIO_DIV_MSB() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x800000) >> 23
}
func (o *PMU_Type) SetMISC2_SET_REG0_STEP_TIME(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x3000000)|value<<24)
}
func (o *PMU_Type) GetMISC2_SET_REG0_STEP_TIME() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x3000000) >> 24
}
func (o *PMU_Type) SetMISC2_SET_REG1_STEP_TIME(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0xc000000)|value<<26)
}
func (o *PMU_Type) GetMISC2_SET_REG1_STEP_TIME() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0xc000000) >> 26
}
func (o *PMU_Type) SetMISC2_SET_REG2_STEP_TIME(value uint32) {
	volatile.StoreUint32(&o.MISC2_SET.Reg, volatile.LoadUint32(&o.MISC2_SET.Reg)&^(0x30000000)|value<<28)
}
func (o *PMU_Type) GetMISC2_SET_REG2_STEP_TIME() uint32 {
	return (volatile.LoadUint32(&o.MISC2_SET.Reg) & 0x30000000) >> 28
}

// PMU.MISC2_CLR: Miscellaneous Control Register
func (o *PMU_Type) SetMISC2_CLR_REG0_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x7)|value)
}
func (o *PMU_Type) GetMISC2_CLR_REG0_BO_OFFSET() uint32 {
	return volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x7
}
func (o *PMU_Type) SetMISC2_CLR_REG0_BO_STATUS(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x8)|value<<3)
}
func (o *PMU_Type) GetMISC2_CLR_REG0_BO_STATUS() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x8) >> 3
}
func (o *PMU_Type) SetMISC2_CLR_REG0_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x20)|value<<5)
}
func (o *PMU_Type) GetMISC2_CLR_REG0_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x20) >> 5
}
func (o *PMU_Type) SetMISC2_CLR_PLL3_disable(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x80)|value<<7)
}
func (o *PMU_Type) GetMISC2_CLR_PLL3_disable() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x80) >> 7
}
func (o *PMU_Type) SetMISC2_CLR_REG1_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x700)|value<<8)
}
func (o *PMU_Type) GetMISC2_CLR_REG1_BO_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x700) >> 8
}
func (o *PMU_Type) SetMISC2_CLR_REG1_BO_STATUS(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x800)|value<<11)
}
func (o *PMU_Type) GetMISC2_CLR_REG1_BO_STATUS() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x800) >> 11
}
func (o *PMU_Type) SetMISC2_CLR_REG1_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *PMU_Type) GetMISC2_CLR_REG1_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x2000) >> 13
}
func (o *PMU_Type) SetMISC2_CLR_AUDIO_DIV_LSB(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *PMU_Type) GetMISC2_CLR_AUDIO_DIV_LSB() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x8000) >> 15
}
func (o *PMU_Type) SetMISC2_CLR_REG2_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x70000)|value<<16)
}
func (o *PMU_Type) GetMISC2_CLR_REG2_BO_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x70000) >> 16
}
func (o *PMU_Type) SetMISC2_CLR_REG2_BO_STATUS(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x80000)|value<<19)
}
func (o *PMU_Type) GetMISC2_CLR_REG2_BO_STATUS() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x80000) >> 19
}
func (o *PMU_Type) SetMISC2_CLR_REG2_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x200000)|value<<21)
}
func (o *PMU_Type) GetMISC2_CLR_REG2_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x200000) >> 21
}
func (o *PMU_Type) SetMISC2_CLR_REG2_OK(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x400000)|value<<22)
}
func (o *PMU_Type) GetMISC2_CLR_REG2_OK() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x400000) >> 22
}
func (o *PMU_Type) SetMISC2_CLR_AUDIO_DIV_MSB(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x800000)|value<<23)
}
func (o *PMU_Type) GetMISC2_CLR_AUDIO_DIV_MSB() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x800000) >> 23
}
func (o *PMU_Type) SetMISC2_CLR_REG0_STEP_TIME(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x3000000)|value<<24)
}
func (o *PMU_Type) GetMISC2_CLR_REG0_STEP_TIME() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x3000000) >> 24
}
func (o *PMU_Type) SetMISC2_CLR_REG1_STEP_TIME(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0xc000000)|value<<26)
}
func (o *PMU_Type) GetMISC2_CLR_REG1_STEP_TIME() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0xc000000) >> 26
}
func (o *PMU_Type) SetMISC2_CLR_REG2_STEP_TIME(value uint32) {
	volatile.StoreUint32(&o.MISC2_CLR.Reg, volatile.LoadUint32(&o.MISC2_CLR.Reg)&^(0x30000000)|value<<28)
}
func (o *PMU_Type) GetMISC2_CLR_REG2_STEP_TIME() uint32 {
	return (volatile.LoadUint32(&o.MISC2_CLR.Reg) & 0x30000000) >> 28
}

// PMU.MISC2_TOG: Miscellaneous Control Register
func (o *PMU_Type) SetMISC2_TOG_REG0_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x7)|value)
}
func (o *PMU_Type) GetMISC2_TOG_REG0_BO_OFFSET() uint32 {
	return volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x7
}
func (o *PMU_Type) SetMISC2_TOG_REG0_BO_STATUS(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x8)|value<<3)
}
func (o *PMU_Type) GetMISC2_TOG_REG0_BO_STATUS() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x8) >> 3
}
func (o *PMU_Type) SetMISC2_TOG_REG0_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x20)|value<<5)
}
func (o *PMU_Type) GetMISC2_TOG_REG0_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x20) >> 5
}
func (o *PMU_Type) SetMISC2_TOG_PLL3_disable(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x80)|value<<7)
}
func (o *PMU_Type) GetMISC2_TOG_PLL3_disable() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x80) >> 7
}
func (o *PMU_Type) SetMISC2_TOG_REG1_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x700)|value<<8)
}
func (o *PMU_Type) GetMISC2_TOG_REG1_BO_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x700) >> 8
}
func (o *PMU_Type) SetMISC2_TOG_REG1_BO_STATUS(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x800)|value<<11)
}
func (o *PMU_Type) GetMISC2_TOG_REG1_BO_STATUS() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x800) >> 11
}
func (o *PMU_Type) SetMISC2_TOG_REG1_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x2000)|value<<13)
}
func (o *PMU_Type) GetMISC2_TOG_REG1_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x2000) >> 13
}
func (o *PMU_Type) SetMISC2_TOG_AUDIO_DIV_LSB(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x8000)|value<<15)
}
func (o *PMU_Type) GetMISC2_TOG_AUDIO_DIV_LSB() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x8000) >> 15
}
func (o *PMU_Type) SetMISC2_TOG_REG2_BO_OFFSET(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x70000)|value<<16)
}
func (o *PMU_Type) GetMISC2_TOG_REG2_BO_OFFSET() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x70000) >> 16
}
func (o *PMU_Type) SetMISC2_TOG_REG2_BO_STATUS(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x80000)|value<<19)
}
func (o *PMU_Type) GetMISC2_TOG_REG2_BO_STATUS() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x80000) >> 19
}
func (o *PMU_Type) SetMISC2_TOG_REG2_ENABLE_BO(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x200000)|value<<21)
}
func (o *PMU_Type) GetMISC2_TOG_REG2_ENABLE_BO() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x200000) >> 21
}
func (o *PMU_Type) SetMISC2_TOG_REG2_OK(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x400000)|value<<22)
}
func (o *PMU_Type) GetMISC2_TOG_REG2_OK() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x400000) >> 22
}
func (o *PMU_Type) SetMISC2_TOG_AUDIO_DIV_MSB(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x800000)|value<<23)
}
func (o *PMU_Type) GetMISC2_TOG_AUDIO_DIV_MSB() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x800000) >> 23
}
func (o *PMU_Type) SetMISC2_TOG_REG0_STEP_TIME(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x3000000)|value<<24)
}
func (o *PMU_Type) GetMISC2_TOG_REG0_STEP_TIME() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x3000000) >> 24
}
func (o *PMU_Type) SetMISC2_TOG_REG1_STEP_TIME(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0xc000000)|value<<26)
}
func (o *PMU_Type) GetMISC2_TOG_REG1_STEP_TIME() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0xc000000) >> 26
}
func (o *PMU_Type) SetMISC2_TOG_REG2_STEP_TIME(value uint32) {
	volatile.StoreUint32(&o.MISC2_TOG.Reg, volatile.LoadUint32(&o.MISC2_TOG.Reg)&^(0x30000000)|value<<28)
}
func (o *PMU_Type) GetMISC2_TOG_REG2_STEP_TIME() uint32 {
	return (volatile.LoadUint32(&o.MISC2_TOG.Reg) & 0x30000000) >> 28
}

// Temperature Monitor
type TEMPMON_Type struct {
	_              [384]byte
	TEMPSENSE0     volatile.Register32 // 0x180
	TEMPSENSE0_SET volatile.Register32 // 0x184
	TEMPSENSE0_CLR volatile.Register32 // 0x188
	TEMPSENSE0_TOG volatile.Register32 // 0x18C
	TEMPSENSE1     volatile.Register32 // 0x190
	TEMPSENSE1_SET volatile.Register32 // 0x194
	TEMPSENSE1_CLR volatile.Register32 // 0x198
	TEMPSENSE1_TOG volatile.Register32 // 0x19C
	_              [240]byte
	TEMPSENSE2     volatile.Register32 // 0x290
	TEMPSENSE2_SET volatile.Register32 // 0x294
	TEMPSENSE2_CLR volatile.Register32 // 0x298
	TEMPSENSE2_TOG volatile.Register32 // 0x29C
}

// TEMPMON.TEMPSENSE0: Tempsensor Control Register 0
func (o *TEMPMON_Type) SetTEMPSENSE0_POWER_DOWN(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE0.Reg, volatile.LoadUint32(&o.TEMPSENSE0.Reg)&^(0x1)|value)
}
func (o *TEMPMON_Type) GetTEMPSENSE0_POWER_DOWN() uint32 {
	return volatile.LoadUint32(&o.TEMPSENSE0.Reg) & 0x1
}
func (o *TEMPMON_Type) SetTEMPSENSE0_MEASURE_TEMP(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE0.Reg, volatile.LoadUint32(&o.TEMPSENSE0.Reg)&^(0x2)|value<<1)
}
func (o *TEMPMON_Type) GetTEMPSENSE0_MEASURE_TEMP() uint32 {
	return (volatile.LoadUint32(&o.TEMPSENSE0.Reg) & 0x2) >> 1
}
func (o *TEMPMON_Type) SetTEMPSENSE0_FINISHED(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE0.Reg, volatile.LoadUint32(&o.TEMPSENSE0.Reg)&^(0x4)|value<<2)
}
func (o *TEMPMON_Type) GetTEMPSENSE0_FINISHED() uint32 {
	return (volatile.LoadUint32(&o.TEMPSENSE0.Reg) & 0x4) >> 2
}
func (o *TEMPMON_Type) SetTEMPSENSE0_TEMP_CNT(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE0.Reg, volatile.LoadUint32(&o.TEMPSENSE0.Reg)&^(0xfff00)|value<<8)
}
func (o *TEMPMON_Type) GetTEMPSENSE0_TEMP_CNT() uint32 {
	return (volatile.LoadUint32(&o.TEMPSENSE0.Reg) & 0xfff00) >> 8
}
func (o *TEMPMON_Type) SetTEMPSENSE0_ALARM_VALUE(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE0.Reg, volatile.LoadUint32(&o.TEMPSENSE0.Reg)&^(0xfff00000)|value<<20)
}
func (o *TEMPMON_Type) GetTEMPSENSE0_ALARM_VALUE() uint32 {
	return (volatile.LoadUint32(&o.TEMPSENSE0.Reg) & 0xfff00000) >> 20
}

// TEMPMON.TEMPSENSE0_SET: Tempsensor Control Register 0
func (o *TEMPMON_Type) SetTEMPSENSE0_SET_POWER_DOWN(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE0_SET.Reg, volatile.LoadUint32(&o.TEMPSENSE0_SET.Reg)&^(0x1)|value)
}
func (o *TEMPMON_Type) GetTEMPSENSE0_SET_POWER_DOWN() uint32 {
	return volatile.LoadUint32(&o.TEMPSENSE0_SET.Reg) & 0x1
}
func (o *TEMPMON_Type) SetTEMPSENSE0_SET_MEASURE_TEMP(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE0_SET.Reg, volatile.LoadUint32(&o.TEMPSENSE0_SET.Reg)&^(0x2)|value<<1)
}
func (o *TEMPMON_Type) GetTEMPSENSE0_SET_MEASURE_TEMP() uint32 {
	return (volatile.LoadUint32(&o.TEMPSENSE0_SET.Reg) & 0x2) >> 1
}
func (o *TEMPMON_Type) SetTEMPSENSE0_SET_FINISHED(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE0_SET.Reg, volatile.LoadUint32(&o.TEMPSENSE0_SET.Reg)&^(0x4)|value<<2)
}
func (o *TEMPMON_Type) GetTEMPSENSE0_SET_FINISHED() uint32 {
	return (volatile.LoadUint32(&o.TEMPSENSE0_SET.Reg) & 0x4) >> 2
}
func (o *TEMPMON_Type) SetTEMPSENSE0_SET_TEMP_CNT(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE0_SET.Reg, volatile.LoadUint32(&o.TEMPSENSE0_SET.Reg)&^(0xfff00)|value<<8)
}
func (o *TEMPMON_Type) GetTEMPSENSE0_SET_TEMP_CNT() uint32 {
	return (volatile.LoadUint32(&o.TEMPSENSE0_SET.Reg) & 0xfff00) >> 8
}
func (o *TEMPMON_Type) SetTEMPSENSE0_SET_ALARM_VALUE(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE0_SET.Reg, volatile.LoadUint32(&o.TEMPSENSE0_SET.Reg)&^(0xfff00000)|value<<20)
}
func (o *TEMPMON_Type) GetTEMPSENSE0_SET_ALARM_VALUE() uint32 {
	return (volatile.LoadUint32(&o.TEMPSENSE0_SET.Reg) & 0xfff00000) >> 20
}

// TEMPMON.TEMPSENSE0_CLR: Tempsensor Control Register 0
func (o *TEMPMON_Type) SetTEMPSENSE0_CLR_POWER_DOWN(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE0_CLR.Reg, volatile.LoadUint32(&o.TEMPSENSE0_CLR.Reg)&^(0x1)|value)
}
func (o *TEMPMON_Type) GetTEMPSENSE0_CLR_POWER_DOWN() uint32 {
	return volatile.LoadUint32(&o.TEMPSENSE0_CLR.Reg) & 0x1
}
func (o *TEMPMON_Type) SetTEMPSENSE0_CLR_MEASURE_TEMP(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE0_CLR.Reg, volatile.LoadUint32(&o.TEMPSENSE0_CLR.Reg)&^(0x2)|value<<1)
}
func (o *TEMPMON_Type) GetTEMPSENSE0_CLR_MEASURE_TEMP() uint32 {
	return (volatile.LoadUint32(&o.TEMPSENSE0_CLR.Reg) & 0x2) >> 1
}
func (o *TEMPMON_Type) SetTEMPSENSE0_CLR_FINISHED(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE0_CLR.Reg, volatile.LoadUint32(&o.TEMPSENSE0_CLR.Reg)&^(0x4)|value<<2)
}
func (o *TEMPMON_Type) GetTEMPSENSE0_CLR_FINISHED() uint32 {
	return (volatile.LoadUint32(&o.TEMPSENSE0_CLR.Reg) & 0x4) >> 2
}
func (o *TEMPMON_Type) SetTEMPSENSE0_CLR_TEMP_CNT(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE0_CLR.Reg, volatile.LoadUint32(&o.TEMPSENSE0_CLR.Reg)&^(0xfff00)|value<<8)
}
func (o *TEMPMON_Type) GetTEMPSENSE0_CLR_TEMP_CNT() uint32 {
	return (volatile.LoadUint32(&o.TEMPSENSE0_CLR.Reg) & 0xfff00) >> 8
}
func (o *TEMPMON_Type) SetTEMPSENSE0_CLR_ALARM_VALUE(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE0_CLR.Reg, volatile.LoadUint32(&o.TEMPSENSE0_CLR.Reg)&^(0xfff00000)|value<<20)
}
func (o *TEMPMON_Type) GetTEMPSENSE0_CLR_ALARM_VALUE() uint32 {
	return (volatile.LoadUint32(&o.TEMPSENSE0_CLR.Reg) & 0xfff00000) >> 20
}

// TEMPMON.TEMPSENSE0_TOG: Tempsensor Control Register 0
func (o *TEMPMON_Type) SetTEMPSENSE0_TOG_POWER_DOWN(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE0_TOG.Reg, volatile.LoadUint32(&o.TEMPSENSE0_TOG.Reg)&^(0x1)|value)
}
func (o *TEMPMON_Type) GetTEMPSENSE0_TOG_POWER_DOWN() uint32 {
	return volatile.LoadUint32(&o.TEMPSENSE0_TOG.Reg) & 0x1
}
func (o *TEMPMON_Type) SetTEMPSENSE0_TOG_MEASURE_TEMP(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE0_TOG.Reg, volatile.LoadUint32(&o.TEMPSENSE0_TOG.Reg)&^(0x2)|value<<1)
}
func (o *TEMPMON_Type) GetTEMPSENSE0_TOG_MEASURE_TEMP() uint32 {
	return (volatile.LoadUint32(&o.TEMPSENSE0_TOG.Reg) & 0x2) >> 1
}
func (o *TEMPMON_Type) SetTEMPSENSE0_TOG_FINISHED(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE0_TOG.Reg, volatile.LoadUint32(&o.TEMPSENSE0_TOG.Reg)&^(0x4)|value<<2)
}
func (o *TEMPMON_Type) GetTEMPSENSE0_TOG_FINISHED() uint32 {
	return (volatile.LoadUint32(&o.TEMPSENSE0_TOG.Reg) & 0x4) >> 2
}
func (o *TEMPMON_Type) SetTEMPSENSE0_TOG_TEMP_CNT(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE0_TOG.Reg, volatile.LoadUint32(&o.TEMPSENSE0_TOG.Reg)&^(0xfff00)|value<<8)
}
func (o *TEMPMON_Type) GetTEMPSENSE0_TOG_TEMP_CNT() uint32 {
	return (volatile.LoadUint32(&o.TEMPSENSE0_TOG.Reg) & 0xfff00) >> 8
}
func (o *TEMPMON_Type) SetTEMPSENSE0_TOG_ALARM_VALUE(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE0_TOG.Reg, volatile.LoadUint32(&o.TEMPSENSE0_TOG.Reg)&^(0xfff00000)|value<<20)
}
func (o *TEMPMON_Type) GetTEMPSENSE0_TOG_ALARM_VALUE() uint32 {
	return (volatile.LoadUint32(&o.TEMPSENSE0_TOG.Reg) & 0xfff00000) >> 20
}

// TEMPMON.TEMPSENSE1: Tempsensor Control Register 1
func (o *TEMPMON_Type) SetTEMPSENSE1_MEASURE_FREQ(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE1.Reg, volatile.LoadUint32(&o.TEMPSENSE1.Reg)&^(0xffff)|value)
}
func (o *TEMPMON_Type) GetTEMPSENSE1_MEASURE_FREQ() uint32 {
	return volatile.LoadUint32(&o.TEMPSENSE1.Reg) & 0xffff
}

// TEMPMON.TEMPSENSE1_SET: Tempsensor Control Register 1
func (o *TEMPMON_Type) SetTEMPSENSE1_SET_MEASURE_FREQ(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE1_SET.Reg, volatile.LoadUint32(&o.TEMPSENSE1_SET.Reg)&^(0xffff)|value)
}
func (o *TEMPMON_Type) GetTEMPSENSE1_SET_MEASURE_FREQ() uint32 {
	return volatile.LoadUint32(&o.TEMPSENSE1_SET.Reg) & 0xffff
}

// TEMPMON.TEMPSENSE1_CLR: Tempsensor Control Register 1
func (o *TEMPMON_Type) SetTEMPSENSE1_CLR_MEASURE_FREQ(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE1_CLR.Reg, volatile.LoadUint32(&o.TEMPSENSE1_CLR.Reg)&^(0xffff)|value)
}
func (o *TEMPMON_Type) GetTEMPSENSE1_CLR_MEASURE_FREQ() uint32 {
	return volatile.LoadUint32(&o.TEMPSENSE1_CLR.Reg) & 0xffff
}

// TEMPMON.TEMPSENSE1_TOG: Tempsensor Control Register 1
func (o *TEMPMON_Type) SetTEMPSENSE1_TOG_MEASURE_FREQ(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE1_TOG.Reg, volatile.LoadUint32(&o.TEMPSENSE1_TOG.Reg)&^(0xffff)|value)
}
func (o *TEMPMON_Type) GetTEMPSENSE1_TOG_MEASURE_FREQ() uint32 {
	return volatile.LoadUint32(&o.TEMPSENSE1_TOG.Reg) & 0xffff
}

// TEMPMON.TEMPSENSE2: Tempsensor Control Register 2
func (o *TEMPMON_Type) SetTEMPSENSE2_LOW_ALARM_VALUE(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE2.Reg, volatile.LoadUint32(&o.TEMPSENSE2.Reg)&^(0xfff)|value)
}
func (o *TEMPMON_Type) GetTEMPSENSE2_LOW_ALARM_VALUE() uint32 {
	return volatile.LoadUint32(&o.TEMPSENSE2.Reg) & 0xfff
}
func (o *TEMPMON_Type) SetTEMPSENSE2_PANIC_ALARM_VALUE(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE2.Reg, volatile.LoadUint32(&o.TEMPSENSE2.Reg)&^(0xfff0000)|value<<16)
}
func (o *TEMPMON_Type) GetTEMPSENSE2_PANIC_ALARM_VALUE() uint32 {
	return (volatile.LoadUint32(&o.TEMPSENSE2.Reg) & 0xfff0000) >> 16
}

// TEMPMON.TEMPSENSE2_SET: Tempsensor Control Register 2
func (o *TEMPMON_Type) SetTEMPSENSE2_SET_LOW_ALARM_VALUE(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE2_SET.Reg, volatile.LoadUint32(&o.TEMPSENSE2_SET.Reg)&^(0xfff)|value)
}
func (o *TEMPMON_Type) GetTEMPSENSE2_SET_LOW_ALARM_VALUE() uint32 {
	return volatile.LoadUint32(&o.TEMPSENSE2_SET.Reg) & 0xfff
}
func (o *TEMPMON_Type) SetTEMPSENSE2_SET_PANIC_ALARM_VALUE(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE2_SET.Reg, volatile.LoadUint32(&o.TEMPSENSE2_SET.Reg)&^(0xfff0000)|value<<16)
}
func (o *TEMPMON_Type) GetTEMPSENSE2_SET_PANIC_ALARM_VALUE() uint32 {
	return (volatile.LoadUint32(&o.TEMPSENSE2_SET.Reg) & 0xfff0000) >> 16
}

// TEMPMON.TEMPSENSE2_CLR: Tempsensor Control Register 2
func (o *TEMPMON_Type) SetTEMPSENSE2_CLR_LOW_ALARM_VALUE(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE2_CLR.Reg, volatile.LoadUint32(&o.TEMPSENSE2_CLR.Reg)&^(0xfff)|value)
}
func (o *TEMPMON_Type) GetTEMPSENSE2_CLR_LOW_ALARM_VALUE() uint32 {
	return volatile.LoadUint32(&o.TEMPSENSE2_CLR.Reg) & 0xfff
}
func (o *TEMPMON_Type) SetTEMPSENSE2_CLR_PANIC_ALARM_VALUE(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE2_CLR.Reg, volatile.LoadUint32(&o.TEMPSENSE2_CLR.Reg)&^(0xfff0000)|value<<16)
}
func (o *TEMPMON_Type) GetTEMPSENSE2_CLR_PANIC_ALARM_VALUE() uint32 {
	return (volatile.LoadUint32(&o.TEMPSENSE2_CLR.Reg) & 0xfff0000) >> 16
}

// TEMPMON.TEMPSENSE2_TOG: Tempsensor Control Register 2
func (o *TEMPMON_Type) SetTEMPSENSE2_TOG_LOW_ALARM_VALUE(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE2_TOG.Reg, volatile.LoadUint32(&o.TEMPSENSE2_TOG.Reg)&^(0xfff)|value)
}
func (o *TEMPMON_Type) GetTEMPSENSE2_TOG_LOW_ALARM_VALUE() uint32 {
	return volatile.LoadUint32(&o.TEMPSENSE2_TOG.Reg) & 0xfff
}
func (o *TEMPMON_Type) SetTEMPSENSE2_TOG_PANIC_ALARM_VALUE(value uint32) {
	volatile.StoreUint32(&o.TEMPSENSE2_TOG.Reg, volatile.LoadUint32(&o.TEMPSENSE2_TOG.Reg)&^(0xfff0000)|value<<16)
}
func (o *TEMPMON_Type) GetTEMPSENSE2_TOG_PANIC_ALARM_VALUE() uint32 {
	return (volatile.LoadUint32(&o.TEMPSENSE2_TOG.Reg) & 0xfff0000) >> 16
}

// USB Analog
type USB_ANALOG_Type struct {
	_                     [416]byte
	USB1_VBUS_DETECT      volatile.Register32 // 0x1A0
	USB1_VBUS_DETECT_SET  volatile.Register32 // 0x1A4
	USB1_VBUS_DETECT_CLR  volatile.Register32 // 0x1A8
	USB1_VBUS_DETECT_TOG  volatile.Register32 // 0x1AC
	USB1_CHRG_DETECT      volatile.Register32 // 0x1B0
	USB1_CHRG_DETECT_SET  volatile.Register32 // 0x1B4
	USB1_CHRG_DETECT_CLR  volatile.Register32 // 0x1B8
	USB1_CHRG_DETECT_TOG  volatile.Register32 // 0x1BC
	USB1_VBUS_DETECT_STAT volatile.Register32 // 0x1C0
	_                     [12]byte
	USB1_CHRG_DETECT_STAT volatile.Register32 // 0x1D0
	_                     [12]byte
	USB1_LOOPBACK         volatile.Register32 // 0x1E0
	USB1_LOOPBACK_SET     volatile.Register32 // 0x1E4
	USB1_LOOPBACK_CLR     volatile.Register32 // 0x1E8
	USB1_LOOPBACK_TOG     volatile.Register32 // 0x1EC
	USB1_MISC             volatile.Register32 // 0x1F0
	USB1_MISC_SET         volatile.Register32 // 0x1F4
	USB1_MISC_CLR         volatile.Register32 // 0x1F8
	USB1_MISC_TOG         volatile.Register32 // 0x1FC
	_                     [96]byte
	DIGPROG               volatile.Register32 // 0x260
}

// USB_ANALOG.USB1_VBUS_DETECT: USB VBUS Detect Register
func (o *USB_ANALOG_Type) SetUSB1_VBUS_DETECT_VBUSVALID_THRESH(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg)&^(0x7)|value)
}
func (o *USB_ANALOG_Type) GetUSB1_VBUS_DETECT_VBUSVALID_THRESH() uint32 {
	return volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg) & 0x7
}
func (o *USB_ANALOG_Type) SetUSB1_VBUS_DETECT_VBUSVALID_PWRUP_CMPS(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg)&^(0x100000)|value<<20)
}
func (o *USB_ANALOG_Type) GetUSB1_VBUS_DETECT_VBUSVALID_PWRUP_CMPS() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg) & 0x100000) >> 20
}
func (o *USB_ANALOG_Type) SetUSB1_VBUS_DETECT_DISCHARGE_VBUS(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_ANALOG_Type) GetUSB1_VBUS_DETECT_DISCHARGE_VBUS() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg) & 0x4000000) >> 26
}
func (o *USB_ANALOG_Type) SetUSB1_VBUS_DETECT_CHARGE_VBUS(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_ANALOG_Type) GetUSB1_VBUS_DETECT_CHARGE_VBUS() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT.Reg) & 0x8000000) >> 27
}

// USB_ANALOG.USB1_VBUS_DETECT_SET: USB VBUS Detect Register
func (o *USB_ANALOG_Type) SetUSB1_VBUS_DETECT_SET_VBUSVALID_THRESH(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_SET.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg)&^(0x7)|value)
}
func (o *USB_ANALOG_Type) GetUSB1_VBUS_DETECT_SET_VBUSVALID_THRESH() uint32 {
	return volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg) & 0x7
}
func (o *USB_ANALOG_Type) SetUSB1_VBUS_DETECT_SET_VBUSVALID_PWRUP_CMPS(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_SET.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg)&^(0x100000)|value<<20)
}
func (o *USB_ANALOG_Type) GetUSB1_VBUS_DETECT_SET_VBUSVALID_PWRUP_CMPS() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg) & 0x100000) >> 20
}
func (o *USB_ANALOG_Type) SetUSB1_VBUS_DETECT_SET_DISCHARGE_VBUS(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_SET.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_ANALOG_Type) GetUSB1_VBUS_DETECT_SET_DISCHARGE_VBUS() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg) & 0x4000000) >> 26
}
func (o *USB_ANALOG_Type) SetUSB1_VBUS_DETECT_SET_CHARGE_VBUS(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_SET.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_ANALOG_Type) GetUSB1_VBUS_DETECT_SET_CHARGE_VBUS() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_SET.Reg) & 0x8000000) >> 27
}

// USB_ANALOG.USB1_VBUS_DETECT_CLR: USB VBUS Detect Register
func (o *USB_ANALOG_Type) SetUSB1_VBUS_DETECT_CLR_VBUSVALID_THRESH(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_CLR.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg)&^(0x7)|value)
}
func (o *USB_ANALOG_Type) GetUSB1_VBUS_DETECT_CLR_VBUSVALID_THRESH() uint32 {
	return volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg) & 0x7
}
func (o *USB_ANALOG_Type) SetUSB1_VBUS_DETECT_CLR_VBUSVALID_PWRUP_CMPS(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_CLR.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg)&^(0x100000)|value<<20)
}
func (o *USB_ANALOG_Type) GetUSB1_VBUS_DETECT_CLR_VBUSVALID_PWRUP_CMPS() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg) & 0x100000) >> 20
}
func (o *USB_ANALOG_Type) SetUSB1_VBUS_DETECT_CLR_DISCHARGE_VBUS(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_CLR.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_ANALOG_Type) GetUSB1_VBUS_DETECT_CLR_DISCHARGE_VBUS() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg) & 0x4000000) >> 26
}
func (o *USB_ANALOG_Type) SetUSB1_VBUS_DETECT_CLR_CHARGE_VBUS(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_CLR.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_ANALOG_Type) GetUSB1_VBUS_DETECT_CLR_CHARGE_VBUS() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_CLR.Reg) & 0x8000000) >> 27
}

// USB_ANALOG.USB1_VBUS_DETECT_TOG: USB VBUS Detect Register
func (o *USB_ANALOG_Type) SetUSB1_VBUS_DETECT_TOG_VBUSVALID_THRESH(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_TOG.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg)&^(0x7)|value)
}
func (o *USB_ANALOG_Type) GetUSB1_VBUS_DETECT_TOG_VBUSVALID_THRESH() uint32 {
	return volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg) & 0x7
}
func (o *USB_ANALOG_Type) SetUSB1_VBUS_DETECT_TOG_VBUSVALID_PWRUP_CMPS(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_TOG.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg)&^(0x100000)|value<<20)
}
func (o *USB_ANALOG_Type) GetUSB1_VBUS_DETECT_TOG_VBUSVALID_PWRUP_CMPS() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg) & 0x100000) >> 20
}
func (o *USB_ANALOG_Type) SetUSB1_VBUS_DETECT_TOG_DISCHARGE_VBUS(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_TOG.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_ANALOG_Type) GetUSB1_VBUS_DETECT_TOG_DISCHARGE_VBUS() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg) & 0x4000000) >> 26
}
func (o *USB_ANALOG_Type) SetUSB1_VBUS_DETECT_TOG_CHARGE_VBUS(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_TOG.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_ANALOG_Type) GetUSB1_VBUS_DETECT_TOG_CHARGE_VBUS() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_TOG.Reg) & 0x8000000) >> 27
}

// USB_ANALOG.USB1_CHRG_DETECT: USB Charger Detect Register
func (o *USB_ANALOG_Type) SetUSB1_CHRG_DETECT_CHK_CONTACT(value uint32) {
	volatile.StoreUint32(&o.USB1_CHRG_DETECT.Reg, volatile.LoadUint32(&o.USB1_CHRG_DETECT.Reg)&^(0x40000)|value<<18)
}
func (o *USB_ANALOG_Type) GetUSB1_CHRG_DETECT_CHK_CONTACT() uint32 {
	return (volatile.LoadUint32(&o.USB1_CHRG_DETECT.Reg) & 0x40000) >> 18
}
func (o *USB_ANALOG_Type) SetUSB1_CHRG_DETECT_CHK_CHRG_B(value uint32) {
	volatile.StoreUint32(&o.USB1_CHRG_DETECT.Reg, volatile.LoadUint32(&o.USB1_CHRG_DETECT.Reg)&^(0x80000)|value<<19)
}
func (o *USB_ANALOG_Type) GetUSB1_CHRG_DETECT_CHK_CHRG_B() uint32 {
	return (volatile.LoadUint32(&o.USB1_CHRG_DETECT.Reg) & 0x80000) >> 19
}
func (o *USB_ANALOG_Type) SetUSB1_CHRG_DETECT_EN_B(value uint32) {
	volatile.StoreUint32(&o.USB1_CHRG_DETECT.Reg, volatile.LoadUint32(&o.USB1_CHRG_DETECT.Reg)&^(0x100000)|value<<20)
}
func (o *USB_ANALOG_Type) GetUSB1_CHRG_DETECT_EN_B() uint32 {
	return (volatile.LoadUint32(&o.USB1_CHRG_DETECT.Reg) & 0x100000) >> 20
}

// USB_ANALOG.USB1_CHRG_DETECT_SET: USB Charger Detect Register
func (o *USB_ANALOG_Type) SetUSB1_CHRG_DETECT_SET_CHK_CONTACT(value uint32) {
	volatile.StoreUint32(&o.USB1_CHRG_DETECT_SET.Reg, volatile.LoadUint32(&o.USB1_CHRG_DETECT_SET.Reg)&^(0x40000)|value<<18)
}
func (o *USB_ANALOG_Type) GetUSB1_CHRG_DETECT_SET_CHK_CONTACT() uint32 {
	return (volatile.LoadUint32(&o.USB1_CHRG_DETECT_SET.Reg) & 0x40000) >> 18
}
func (o *USB_ANALOG_Type) SetUSB1_CHRG_DETECT_SET_CHK_CHRG_B(value uint32) {
	volatile.StoreUint32(&o.USB1_CHRG_DETECT_SET.Reg, volatile.LoadUint32(&o.USB1_CHRG_DETECT_SET.Reg)&^(0x80000)|value<<19)
}
func (o *USB_ANALOG_Type) GetUSB1_CHRG_DETECT_SET_CHK_CHRG_B() uint32 {
	return (volatile.LoadUint32(&o.USB1_CHRG_DETECT_SET.Reg) & 0x80000) >> 19
}
func (o *USB_ANALOG_Type) SetUSB1_CHRG_DETECT_SET_EN_B(value uint32) {
	volatile.StoreUint32(&o.USB1_CHRG_DETECT_SET.Reg, volatile.LoadUint32(&o.USB1_CHRG_DETECT_SET.Reg)&^(0x100000)|value<<20)
}
func (o *USB_ANALOG_Type) GetUSB1_CHRG_DETECT_SET_EN_B() uint32 {
	return (volatile.LoadUint32(&o.USB1_CHRG_DETECT_SET.Reg) & 0x100000) >> 20
}

// USB_ANALOG.USB1_CHRG_DETECT_CLR: USB Charger Detect Register
func (o *USB_ANALOG_Type) SetUSB1_CHRG_DETECT_CLR_CHK_CONTACT(value uint32) {
	volatile.StoreUint32(&o.USB1_CHRG_DETECT_CLR.Reg, volatile.LoadUint32(&o.USB1_CHRG_DETECT_CLR.Reg)&^(0x40000)|value<<18)
}
func (o *USB_ANALOG_Type) GetUSB1_CHRG_DETECT_CLR_CHK_CONTACT() uint32 {
	return (volatile.LoadUint32(&o.USB1_CHRG_DETECT_CLR.Reg) & 0x40000) >> 18
}
func (o *USB_ANALOG_Type) SetUSB1_CHRG_DETECT_CLR_CHK_CHRG_B(value uint32) {
	volatile.StoreUint32(&o.USB1_CHRG_DETECT_CLR.Reg, volatile.LoadUint32(&o.USB1_CHRG_DETECT_CLR.Reg)&^(0x80000)|value<<19)
}
func (o *USB_ANALOG_Type) GetUSB1_CHRG_DETECT_CLR_CHK_CHRG_B() uint32 {
	return (volatile.LoadUint32(&o.USB1_CHRG_DETECT_CLR.Reg) & 0x80000) >> 19
}
func (o *USB_ANALOG_Type) SetUSB1_CHRG_DETECT_CLR_EN_B(value uint32) {
	volatile.StoreUint32(&o.USB1_CHRG_DETECT_CLR.Reg, volatile.LoadUint32(&o.USB1_CHRG_DETECT_CLR.Reg)&^(0x100000)|value<<20)
}
func (o *USB_ANALOG_Type) GetUSB1_CHRG_DETECT_CLR_EN_B() uint32 {
	return (volatile.LoadUint32(&o.USB1_CHRG_DETECT_CLR.Reg) & 0x100000) >> 20
}

// USB_ANALOG.USB1_CHRG_DETECT_TOG: USB Charger Detect Register
func (o *USB_ANALOG_Type) SetUSB1_CHRG_DETECT_TOG_CHK_CONTACT(value uint32) {
	volatile.StoreUint32(&o.USB1_CHRG_DETECT_TOG.Reg, volatile.LoadUint32(&o.USB1_CHRG_DETECT_TOG.Reg)&^(0x40000)|value<<18)
}
func (o *USB_ANALOG_Type) GetUSB1_CHRG_DETECT_TOG_CHK_CONTACT() uint32 {
	return (volatile.LoadUint32(&o.USB1_CHRG_DETECT_TOG.Reg) & 0x40000) >> 18
}
func (o *USB_ANALOG_Type) SetUSB1_CHRG_DETECT_TOG_CHK_CHRG_B(value uint32) {
	volatile.StoreUint32(&o.USB1_CHRG_DETECT_TOG.Reg, volatile.LoadUint32(&o.USB1_CHRG_DETECT_TOG.Reg)&^(0x80000)|value<<19)
}
func (o *USB_ANALOG_Type) GetUSB1_CHRG_DETECT_TOG_CHK_CHRG_B() uint32 {
	return (volatile.LoadUint32(&o.USB1_CHRG_DETECT_TOG.Reg) & 0x80000) >> 19
}
func (o *USB_ANALOG_Type) SetUSB1_CHRG_DETECT_TOG_EN_B(value uint32) {
	volatile.StoreUint32(&o.USB1_CHRG_DETECT_TOG.Reg, volatile.LoadUint32(&o.USB1_CHRG_DETECT_TOG.Reg)&^(0x100000)|value<<20)
}
func (o *USB_ANALOG_Type) GetUSB1_CHRG_DETECT_TOG_EN_B() uint32 {
	return (volatile.LoadUint32(&o.USB1_CHRG_DETECT_TOG.Reg) & 0x100000) >> 20
}

// USB_ANALOG.USB1_VBUS_DETECT_STAT: USB VBUS Detect Status Register
func (o *USB_ANALOG_Type) SetUSB1_VBUS_DETECT_STAT_SESSEND(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_STAT.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_STAT.Reg)&^(0x1)|value)
}
func (o *USB_ANALOG_Type) GetUSB1_VBUS_DETECT_STAT_SESSEND() uint32 {
	return volatile.LoadUint32(&o.USB1_VBUS_DETECT_STAT.Reg) & 0x1
}
func (o *USB_ANALOG_Type) SetUSB1_VBUS_DETECT_STAT_BVALID(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_STAT.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_STAT.Reg)&^(0x2)|value<<1)
}
func (o *USB_ANALOG_Type) GetUSB1_VBUS_DETECT_STAT_BVALID() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_STAT.Reg) & 0x2) >> 1
}
func (o *USB_ANALOG_Type) SetUSB1_VBUS_DETECT_STAT_AVALID(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_STAT.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_STAT.Reg)&^(0x4)|value<<2)
}
func (o *USB_ANALOG_Type) GetUSB1_VBUS_DETECT_STAT_AVALID() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_STAT.Reg) & 0x4) >> 2
}
func (o *USB_ANALOG_Type) SetUSB1_VBUS_DETECT_STAT_VBUS_VALID(value uint32) {
	volatile.StoreUint32(&o.USB1_VBUS_DETECT_STAT.Reg, volatile.LoadUint32(&o.USB1_VBUS_DETECT_STAT.Reg)&^(0x8)|value<<3)
}
func (o *USB_ANALOG_Type) GetUSB1_VBUS_DETECT_STAT_VBUS_VALID() uint32 {
	return (volatile.LoadUint32(&o.USB1_VBUS_DETECT_STAT.Reg) & 0x8) >> 3
}

// USB_ANALOG.USB1_CHRG_DETECT_STAT: USB Charger Detect Status Register
func (o *USB_ANALOG_Type) SetUSB1_CHRG_DETECT_STAT_PLUG_CONTACT(value uint32) {
	volatile.StoreUint32(&o.USB1_CHRG_DETECT_STAT.Reg, volatile.LoadUint32(&o.USB1_CHRG_DETECT_STAT.Reg)&^(0x1)|value)
}
func (o *USB_ANALOG_Type) GetUSB1_CHRG_DETECT_STAT_PLUG_CONTACT() uint32 {
	return volatile.LoadUint32(&o.USB1_CHRG_DETECT_STAT.Reg) & 0x1
}
func (o *USB_ANALOG_Type) SetUSB1_CHRG_DETECT_STAT_CHRG_DETECTED(value uint32) {
	volatile.StoreUint32(&o.USB1_CHRG_DETECT_STAT.Reg, volatile.LoadUint32(&o.USB1_CHRG_DETECT_STAT.Reg)&^(0x2)|value<<1)
}
func (o *USB_ANALOG_Type) GetUSB1_CHRG_DETECT_STAT_CHRG_DETECTED() uint32 {
	return (volatile.LoadUint32(&o.USB1_CHRG_DETECT_STAT.Reg) & 0x2) >> 1
}
func (o *USB_ANALOG_Type) SetUSB1_CHRG_DETECT_STAT_DM_STATE(value uint32) {
	volatile.StoreUint32(&o.USB1_CHRG_DETECT_STAT.Reg, volatile.LoadUint32(&o.USB1_CHRG_DETECT_STAT.Reg)&^(0x4)|value<<2)
}
func (o *USB_ANALOG_Type) GetUSB1_CHRG_DETECT_STAT_DM_STATE() uint32 {
	return (volatile.LoadUint32(&o.USB1_CHRG_DETECT_STAT.Reg) & 0x4) >> 2
}
func (o *USB_ANALOG_Type) SetUSB1_CHRG_DETECT_STAT_DP_STATE(value uint32) {
	volatile.StoreUint32(&o.USB1_CHRG_DETECT_STAT.Reg, volatile.LoadUint32(&o.USB1_CHRG_DETECT_STAT.Reg)&^(0x8)|value<<3)
}
func (o *USB_ANALOG_Type) GetUSB1_CHRG_DETECT_STAT_DP_STATE() uint32 {
	return (volatile.LoadUint32(&o.USB1_CHRG_DETECT_STAT.Reg) & 0x8) >> 3
}

// USB_ANALOG.USB1_LOOPBACK: USB Loopback Test Register
func (o *USB_ANALOG_Type) SetUSB1_LOOPBACK_UTMI_TESTSTART(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK.Reg)&^(0x1)|value)
}
func (o *USB_ANALOG_Type) GetUSB1_LOOPBACK_UTMI_TESTSTART() uint32 {
	return volatile.LoadUint32(&o.USB1_LOOPBACK.Reg) & 0x1
}

// USB_ANALOG.USB1_LOOPBACK_SET: USB Loopback Test Register
func (o *USB_ANALOG_Type) SetUSB1_LOOPBACK_SET_UTMI_TESTSTART(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_SET.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_SET.Reg)&^(0x1)|value)
}
func (o *USB_ANALOG_Type) GetUSB1_LOOPBACK_SET_UTMI_TESTSTART() uint32 {
	return volatile.LoadUint32(&o.USB1_LOOPBACK_SET.Reg) & 0x1
}

// USB_ANALOG.USB1_LOOPBACK_CLR: USB Loopback Test Register
func (o *USB_ANALOG_Type) SetUSB1_LOOPBACK_CLR_UTMI_TESTSTART(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_CLR.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_CLR.Reg)&^(0x1)|value)
}
func (o *USB_ANALOG_Type) GetUSB1_LOOPBACK_CLR_UTMI_TESTSTART() uint32 {
	return volatile.LoadUint32(&o.USB1_LOOPBACK_CLR.Reg) & 0x1
}

// USB_ANALOG.USB1_LOOPBACK_TOG: USB Loopback Test Register
func (o *USB_ANALOG_Type) SetUSB1_LOOPBACK_TOG_UTMI_TESTSTART(value uint32) {
	volatile.StoreUint32(&o.USB1_LOOPBACK_TOG.Reg, volatile.LoadUint32(&o.USB1_LOOPBACK_TOG.Reg)&^(0x1)|value)
}
func (o *USB_ANALOG_Type) GetUSB1_LOOPBACK_TOG_UTMI_TESTSTART() uint32 {
	return volatile.LoadUint32(&o.USB1_LOOPBACK_TOG.Reg) & 0x1
}

// USB_ANALOG.USB1_MISC: USB Misc Register
func (o *USB_ANALOG_Type) SetUSB1_MISC_HS_USE_EXTERNAL_R(value uint32) {
	volatile.StoreUint32(&o.USB1_MISC.Reg, volatile.LoadUint32(&o.USB1_MISC.Reg)&^(0x1)|value)
}
func (o *USB_ANALOG_Type) GetUSB1_MISC_HS_USE_EXTERNAL_R() uint32 {
	return volatile.LoadUint32(&o.USB1_MISC.Reg) & 0x1
}
func (o *USB_ANALOG_Type) SetUSB1_MISC_EN_DEGLITCH(value uint32) {
	volatile.StoreUint32(&o.USB1_MISC.Reg, volatile.LoadUint32(&o.USB1_MISC.Reg)&^(0x2)|value<<1)
}
func (o *USB_ANALOG_Type) GetUSB1_MISC_EN_DEGLITCH() uint32 {
	return (volatile.LoadUint32(&o.USB1_MISC.Reg) & 0x2) >> 1
}
func (o *USB_ANALOG_Type) SetUSB1_MISC_EN_CLK_UTMI(value uint32) {
	volatile.StoreUint32(&o.USB1_MISC.Reg, volatile.LoadUint32(&o.USB1_MISC.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_ANALOG_Type) GetUSB1_MISC_EN_CLK_UTMI() uint32 {
	return (volatile.LoadUint32(&o.USB1_MISC.Reg) & 0x40000000) >> 30
}

// USB_ANALOG.USB1_MISC_SET: USB Misc Register
func (o *USB_ANALOG_Type) SetUSB1_MISC_SET_HS_USE_EXTERNAL_R(value uint32) {
	volatile.StoreUint32(&o.USB1_MISC_SET.Reg, volatile.LoadUint32(&o.USB1_MISC_SET.Reg)&^(0x1)|value)
}
func (o *USB_ANALOG_Type) GetUSB1_MISC_SET_HS_USE_EXTERNAL_R() uint32 {
	return volatile.LoadUint32(&o.USB1_MISC_SET.Reg) & 0x1
}
func (o *USB_ANALOG_Type) SetUSB1_MISC_SET_EN_DEGLITCH(value uint32) {
	volatile.StoreUint32(&o.USB1_MISC_SET.Reg, volatile.LoadUint32(&o.USB1_MISC_SET.Reg)&^(0x2)|value<<1)
}
func (o *USB_ANALOG_Type) GetUSB1_MISC_SET_EN_DEGLITCH() uint32 {
	return (volatile.LoadUint32(&o.USB1_MISC_SET.Reg) & 0x2) >> 1
}
func (o *USB_ANALOG_Type) SetUSB1_MISC_SET_EN_CLK_UTMI(value uint32) {
	volatile.StoreUint32(&o.USB1_MISC_SET.Reg, volatile.LoadUint32(&o.USB1_MISC_SET.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_ANALOG_Type) GetUSB1_MISC_SET_EN_CLK_UTMI() uint32 {
	return (volatile.LoadUint32(&o.USB1_MISC_SET.Reg) & 0x40000000) >> 30
}

// USB_ANALOG.USB1_MISC_CLR: USB Misc Register
func (o *USB_ANALOG_Type) SetUSB1_MISC_CLR_HS_USE_EXTERNAL_R(value uint32) {
	volatile.StoreUint32(&o.USB1_MISC_CLR.Reg, volatile.LoadUint32(&o.USB1_MISC_CLR.Reg)&^(0x1)|value)
}
func (o *USB_ANALOG_Type) GetUSB1_MISC_CLR_HS_USE_EXTERNAL_R() uint32 {
	return volatile.LoadUint32(&o.USB1_MISC_CLR.Reg) & 0x1
}
func (o *USB_ANALOG_Type) SetUSB1_MISC_CLR_EN_DEGLITCH(value uint32) {
	volatile.StoreUint32(&o.USB1_MISC_CLR.Reg, volatile.LoadUint32(&o.USB1_MISC_CLR.Reg)&^(0x2)|value<<1)
}
func (o *USB_ANALOG_Type) GetUSB1_MISC_CLR_EN_DEGLITCH() uint32 {
	return (volatile.LoadUint32(&o.USB1_MISC_CLR.Reg) & 0x2) >> 1
}
func (o *USB_ANALOG_Type) SetUSB1_MISC_CLR_EN_CLK_UTMI(value uint32) {
	volatile.StoreUint32(&o.USB1_MISC_CLR.Reg, volatile.LoadUint32(&o.USB1_MISC_CLR.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_ANALOG_Type) GetUSB1_MISC_CLR_EN_CLK_UTMI() uint32 {
	return (volatile.LoadUint32(&o.USB1_MISC_CLR.Reg) & 0x40000000) >> 30
}

// USB_ANALOG.USB1_MISC_TOG: USB Misc Register
func (o *USB_ANALOG_Type) SetUSB1_MISC_TOG_HS_USE_EXTERNAL_R(value uint32) {
	volatile.StoreUint32(&o.USB1_MISC_TOG.Reg, volatile.LoadUint32(&o.USB1_MISC_TOG.Reg)&^(0x1)|value)
}
func (o *USB_ANALOG_Type) GetUSB1_MISC_TOG_HS_USE_EXTERNAL_R() uint32 {
	return volatile.LoadUint32(&o.USB1_MISC_TOG.Reg) & 0x1
}
func (o *USB_ANALOG_Type) SetUSB1_MISC_TOG_EN_DEGLITCH(value uint32) {
	volatile.StoreUint32(&o.USB1_MISC_TOG.Reg, volatile.LoadUint32(&o.USB1_MISC_TOG.Reg)&^(0x2)|value<<1)
}
func (o *USB_ANALOG_Type) GetUSB1_MISC_TOG_EN_DEGLITCH() uint32 {
	return (volatile.LoadUint32(&o.USB1_MISC_TOG.Reg) & 0x2) >> 1
}
func (o *USB_ANALOG_Type) SetUSB1_MISC_TOG_EN_CLK_UTMI(value uint32) {
	volatile.StoreUint32(&o.USB1_MISC_TOG.Reg, volatile.LoadUint32(&o.USB1_MISC_TOG.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_ANALOG_Type) GetUSB1_MISC_TOG_EN_CLK_UTMI() uint32 {
	return (volatile.LoadUint32(&o.USB1_MISC_TOG.Reg) & 0x40000000) >> 30
}

// USB_ANALOG.DIGPROG: Chip Silicon Version
func (o *USB_ANALOG_Type) SetDIGPROG(value uint32) {
	volatile.StoreUint32(&o.DIGPROG.Reg, value)
}
func (o *USB_ANALOG_Type) GetDIGPROG() uint32 {
	return volatile.LoadUint32(&o.DIGPROG.Reg)
}

// XTALOSC24M
type XTALOSC24M_Type struct {
	_               [336]byte
	MISC0           volatile.Register32 // 0x150
	MISC0_SET       volatile.Register32 // 0x154
	MISC0_CLR       volatile.Register32 // 0x158
	MISC0_TOG       volatile.Register32 // 0x15C
	_               [272]byte
	LOWPWR_CTRL     volatile.Register32 // 0x270
	LOWPWR_CTRL_SET volatile.Register32 // 0x274
	LOWPWR_CTRL_CLR volatile.Register32 // 0x278
	LOWPWR_CTRL_TOG volatile.Register32 // 0x27C
	_               [32]byte
	OSC_CONFIG0     volatile.Register32 // 0x2A0
	OSC_CONFIG0_SET volatile.Register32 // 0x2A4
	OSC_CONFIG0_CLR volatile.Register32 // 0x2A8
	OSC_CONFIG0_TOG volatile.Register32 // 0x2AC
	OSC_CONFIG1     volatile.Register32 // 0x2B0
	OSC_CONFIG1_SET volatile.Register32 // 0x2B4
	OSC_CONFIG1_CLR volatile.Register32 // 0x2B8
	OSC_CONFIG1_TOG volatile.Register32 // 0x2BC
	OSC_CONFIG2     volatile.Register32 // 0x2C0
	OSC_CONFIG2_SET volatile.Register32 // 0x2C4
	OSC_CONFIG2_CLR volatile.Register32 // 0x2C8
	OSC_CONFIG2_TOG volatile.Register32 // 0x2CC
}

// XTALOSC24M.MISC0: Miscellaneous Register 0
func (o *XTALOSC24M_Type) SetMISC0_REFTOP_PWD(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x1)|value)
}
func (o *XTALOSC24M_Type) GetMISC0_REFTOP_PWD() uint32 {
	return volatile.LoadUint32(&o.MISC0.Reg) & 0x1
}
func (o *XTALOSC24M_Type) SetMISC0_REFTOP_SELFBIASOFF(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x8)|value<<3)
}
func (o *XTALOSC24M_Type) GetMISC0_REFTOP_SELFBIASOFF() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x8) >> 3
}
func (o *XTALOSC24M_Type) SetMISC0_REFTOP_VBGADJ(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x70)|value<<4)
}
func (o *XTALOSC24M_Type) GetMISC0_REFTOP_VBGADJ() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x70) >> 4
}
func (o *XTALOSC24M_Type) SetMISC0_REFTOP_VBGUP(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x80)|value<<7)
}
func (o *XTALOSC24M_Type) GetMISC0_REFTOP_VBGUP() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x80) >> 7
}
func (o *XTALOSC24M_Type) SetMISC0_STOP_MODE_CONFIG(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0xc00)|value<<10)
}
func (o *XTALOSC24M_Type) GetMISC0_STOP_MODE_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0xc00) >> 10
}
func (o *XTALOSC24M_Type) SetMISC0_DISCON_HIGH_SNVS(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x1000)|value<<12)
}
func (o *XTALOSC24M_Type) GetMISC0_DISCON_HIGH_SNVS() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x1000) >> 12
}
func (o *XTALOSC24M_Type) SetMISC0_OSC_I(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x6000)|value<<13)
}
func (o *XTALOSC24M_Type) GetMISC0_OSC_I() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x6000) >> 13
}
func (o *XTALOSC24M_Type) SetMISC0_OSC_XTALOK(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x8000)|value<<15)
}
func (o *XTALOSC24M_Type) GetMISC0_OSC_XTALOK() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x8000) >> 15
}
func (o *XTALOSC24M_Type) SetMISC0_OSC_XTALOK_EN(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x10000)|value<<16)
}
func (o *XTALOSC24M_Type) GetMISC0_OSC_XTALOK_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x10000) >> 16
}
func (o *XTALOSC24M_Type) SetMISC0_CLKGATE_CTRL(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x2000000)|value<<25)
}
func (o *XTALOSC24M_Type) GetMISC0_CLKGATE_CTRL() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x2000000) >> 25
}
func (o *XTALOSC24M_Type) SetMISC0_CLKGATE_DELAY(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x1c000000)|value<<26)
}
func (o *XTALOSC24M_Type) GetMISC0_CLKGATE_DELAY() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x1c000000) >> 26
}
func (o *XTALOSC24M_Type) SetMISC0_RTC_XTAL_SOURCE(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x20000000)|value<<29)
}
func (o *XTALOSC24M_Type) GetMISC0_RTC_XTAL_SOURCE() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x20000000) >> 29
}
func (o *XTALOSC24M_Type) SetMISC0_XTAL_24M_PWD(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x40000000)|value<<30)
}
func (o *XTALOSC24M_Type) GetMISC0_XTAL_24M_PWD() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x40000000) >> 30
}
func (o *XTALOSC24M_Type) SetMISC0_VID_PLL_PREDIV(value uint32) {
	volatile.StoreUint32(&o.MISC0.Reg, volatile.LoadUint32(&o.MISC0.Reg)&^(0x80000000)|value<<31)
}
func (o *XTALOSC24M_Type) GetMISC0_VID_PLL_PREDIV() uint32 {
	return (volatile.LoadUint32(&o.MISC0.Reg) & 0x80000000) >> 31
}

// XTALOSC24M.MISC0_SET: Miscellaneous Register 0
func (o *XTALOSC24M_Type) SetMISC0_SET_REFTOP_PWD(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x1)|value)
}
func (o *XTALOSC24M_Type) GetMISC0_SET_REFTOP_PWD() uint32 {
	return volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x1
}
func (o *XTALOSC24M_Type) SetMISC0_SET_REFTOP_SELFBIASOFF(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x8)|value<<3)
}
func (o *XTALOSC24M_Type) GetMISC0_SET_REFTOP_SELFBIASOFF() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x8) >> 3
}
func (o *XTALOSC24M_Type) SetMISC0_SET_REFTOP_VBGADJ(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x70)|value<<4)
}
func (o *XTALOSC24M_Type) GetMISC0_SET_REFTOP_VBGADJ() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x70) >> 4
}
func (o *XTALOSC24M_Type) SetMISC0_SET_REFTOP_VBGUP(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x80)|value<<7)
}
func (o *XTALOSC24M_Type) GetMISC0_SET_REFTOP_VBGUP() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x80) >> 7
}
func (o *XTALOSC24M_Type) SetMISC0_SET_STOP_MODE_CONFIG(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0xc00)|value<<10)
}
func (o *XTALOSC24M_Type) GetMISC0_SET_STOP_MODE_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0xc00) >> 10
}
func (o *XTALOSC24M_Type) SetMISC0_SET_DISCON_HIGH_SNVS(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x1000)|value<<12)
}
func (o *XTALOSC24M_Type) GetMISC0_SET_DISCON_HIGH_SNVS() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x1000) >> 12
}
func (o *XTALOSC24M_Type) SetMISC0_SET_OSC_I(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x6000)|value<<13)
}
func (o *XTALOSC24M_Type) GetMISC0_SET_OSC_I() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x6000) >> 13
}
func (o *XTALOSC24M_Type) SetMISC0_SET_OSC_XTALOK(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x8000)|value<<15)
}
func (o *XTALOSC24M_Type) GetMISC0_SET_OSC_XTALOK() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x8000) >> 15
}
func (o *XTALOSC24M_Type) SetMISC0_SET_OSC_XTALOK_EN(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x10000)|value<<16)
}
func (o *XTALOSC24M_Type) GetMISC0_SET_OSC_XTALOK_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x10000) >> 16
}
func (o *XTALOSC24M_Type) SetMISC0_SET_CLKGATE_CTRL(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x2000000)|value<<25)
}
func (o *XTALOSC24M_Type) GetMISC0_SET_CLKGATE_CTRL() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x2000000) >> 25
}
func (o *XTALOSC24M_Type) SetMISC0_SET_CLKGATE_DELAY(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x1c000000)|value<<26)
}
func (o *XTALOSC24M_Type) GetMISC0_SET_CLKGATE_DELAY() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x1c000000) >> 26
}
func (o *XTALOSC24M_Type) SetMISC0_SET_RTC_XTAL_SOURCE(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x20000000)|value<<29)
}
func (o *XTALOSC24M_Type) GetMISC0_SET_RTC_XTAL_SOURCE() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x20000000) >> 29
}
func (o *XTALOSC24M_Type) SetMISC0_SET_XTAL_24M_PWD(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x40000000)|value<<30)
}
func (o *XTALOSC24M_Type) GetMISC0_SET_XTAL_24M_PWD() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x40000000) >> 30
}
func (o *XTALOSC24M_Type) SetMISC0_SET_VID_PLL_PREDIV(value uint32) {
	volatile.StoreUint32(&o.MISC0_SET.Reg, volatile.LoadUint32(&o.MISC0_SET.Reg)&^(0x80000000)|value<<31)
}
func (o *XTALOSC24M_Type) GetMISC0_SET_VID_PLL_PREDIV() uint32 {
	return (volatile.LoadUint32(&o.MISC0_SET.Reg) & 0x80000000) >> 31
}

// XTALOSC24M.MISC0_CLR: Miscellaneous Register 0
func (o *XTALOSC24M_Type) SetMISC0_CLR_REFTOP_PWD(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x1)|value)
}
func (o *XTALOSC24M_Type) GetMISC0_CLR_REFTOP_PWD() uint32 {
	return volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x1
}
func (o *XTALOSC24M_Type) SetMISC0_CLR_REFTOP_SELFBIASOFF(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x8)|value<<3)
}
func (o *XTALOSC24M_Type) GetMISC0_CLR_REFTOP_SELFBIASOFF() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x8) >> 3
}
func (o *XTALOSC24M_Type) SetMISC0_CLR_REFTOP_VBGADJ(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x70)|value<<4)
}
func (o *XTALOSC24M_Type) GetMISC0_CLR_REFTOP_VBGADJ() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x70) >> 4
}
func (o *XTALOSC24M_Type) SetMISC0_CLR_REFTOP_VBGUP(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x80)|value<<7)
}
func (o *XTALOSC24M_Type) GetMISC0_CLR_REFTOP_VBGUP() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x80) >> 7
}
func (o *XTALOSC24M_Type) SetMISC0_CLR_STOP_MODE_CONFIG(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0xc00)|value<<10)
}
func (o *XTALOSC24M_Type) GetMISC0_CLR_STOP_MODE_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0xc00) >> 10
}
func (o *XTALOSC24M_Type) SetMISC0_CLR_DISCON_HIGH_SNVS(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *XTALOSC24M_Type) GetMISC0_CLR_DISCON_HIGH_SNVS() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x1000) >> 12
}
func (o *XTALOSC24M_Type) SetMISC0_CLR_OSC_I(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x6000)|value<<13)
}
func (o *XTALOSC24M_Type) GetMISC0_CLR_OSC_I() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x6000) >> 13
}
func (o *XTALOSC24M_Type) SetMISC0_CLR_OSC_XTALOK(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *XTALOSC24M_Type) GetMISC0_CLR_OSC_XTALOK() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x8000) >> 15
}
func (o *XTALOSC24M_Type) SetMISC0_CLR_OSC_XTALOK_EN(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *XTALOSC24M_Type) GetMISC0_CLR_OSC_XTALOK_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x10000) >> 16
}
func (o *XTALOSC24M_Type) SetMISC0_CLR_CLKGATE_CTRL(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x2000000)|value<<25)
}
func (o *XTALOSC24M_Type) GetMISC0_CLR_CLKGATE_CTRL() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x2000000) >> 25
}
func (o *XTALOSC24M_Type) SetMISC0_CLR_CLKGATE_DELAY(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x1c000000)|value<<26)
}
func (o *XTALOSC24M_Type) GetMISC0_CLR_CLKGATE_DELAY() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x1c000000) >> 26
}
func (o *XTALOSC24M_Type) SetMISC0_CLR_RTC_XTAL_SOURCE(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x20000000)|value<<29)
}
func (o *XTALOSC24M_Type) GetMISC0_CLR_RTC_XTAL_SOURCE() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x20000000) >> 29
}
func (o *XTALOSC24M_Type) SetMISC0_CLR_XTAL_24M_PWD(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x40000000)|value<<30)
}
func (o *XTALOSC24M_Type) GetMISC0_CLR_XTAL_24M_PWD() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x40000000) >> 30
}
func (o *XTALOSC24M_Type) SetMISC0_CLR_VID_PLL_PREDIV(value uint32) {
	volatile.StoreUint32(&o.MISC0_CLR.Reg, volatile.LoadUint32(&o.MISC0_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *XTALOSC24M_Type) GetMISC0_CLR_VID_PLL_PREDIV() uint32 {
	return (volatile.LoadUint32(&o.MISC0_CLR.Reg) & 0x80000000) >> 31
}

// XTALOSC24M.MISC0_TOG: Miscellaneous Register 0
func (o *XTALOSC24M_Type) SetMISC0_TOG_REFTOP_PWD(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x1)|value)
}
func (o *XTALOSC24M_Type) GetMISC0_TOG_REFTOP_PWD() uint32 {
	return volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x1
}
func (o *XTALOSC24M_Type) SetMISC0_TOG_REFTOP_SELFBIASOFF(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x8)|value<<3)
}
func (o *XTALOSC24M_Type) GetMISC0_TOG_REFTOP_SELFBIASOFF() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x8) >> 3
}
func (o *XTALOSC24M_Type) SetMISC0_TOG_REFTOP_VBGADJ(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x70)|value<<4)
}
func (o *XTALOSC24M_Type) GetMISC0_TOG_REFTOP_VBGADJ() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x70) >> 4
}
func (o *XTALOSC24M_Type) SetMISC0_TOG_REFTOP_VBGUP(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x80)|value<<7)
}
func (o *XTALOSC24M_Type) GetMISC0_TOG_REFTOP_VBGUP() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x80) >> 7
}
func (o *XTALOSC24M_Type) SetMISC0_TOG_STOP_MODE_CONFIG(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0xc00)|value<<10)
}
func (o *XTALOSC24M_Type) GetMISC0_TOG_STOP_MODE_CONFIG() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0xc00) >> 10
}
func (o *XTALOSC24M_Type) SetMISC0_TOG_DISCON_HIGH_SNVS(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x1000)|value<<12)
}
func (o *XTALOSC24M_Type) GetMISC0_TOG_DISCON_HIGH_SNVS() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x1000) >> 12
}
func (o *XTALOSC24M_Type) SetMISC0_TOG_OSC_I(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x6000)|value<<13)
}
func (o *XTALOSC24M_Type) GetMISC0_TOG_OSC_I() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x6000) >> 13
}
func (o *XTALOSC24M_Type) SetMISC0_TOG_OSC_XTALOK(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x8000)|value<<15)
}
func (o *XTALOSC24M_Type) GetMISC0_TOG_OSC_XTALOK() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x8000) >> 15
}
func (o *XTALOSC24M_Type) SetMISC0_TOG_OSC_XTALOK_EN(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x10000)|value<<16)
}
func (o *XTALOSC24M_Type) GetMISC0_TOG_OSC_XTALOK_EN() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x10000) >> 16
}
func (o *XTALOSC24M_Type) SetMISC0_TOG_CLKGATE_CTRL(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x2000000)|value<<25)
}
func (o *XTALOSC24M_Type) GetMISC0_TOG_CLKGATE_CTRL() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x2000000) >> 25
}
func (o *XTALOSC24M_Type) SetMISC0_TOG_CLKGATE_DELAY(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x1c000000)|value<<26)
}
func (o *XTALOSC24M_Type) GetMISC0_TOG_CLKGATE_DELAY() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x1c000000) >> 26
}
func (o *XTALOSC24M_Type) SetMISC0_TOG_RTC_XTAL_SOURCE(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x20000000)|value<<29)
}
func (o *XTALOSC24M_Type) GetMISC0_TOG_RTC_XTAL_SOURCE() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x20000000) >> 29
}
func (o *XTALOSC24M_Type) SetMISC0_TOG_XTAL_24M_PWD(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x40000000)|value<<30)
}
func (o *XTALOSC24M_Type) GetMISC0_TOG_XTAL_24M_PWD() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x40000000) >> 30
}
func (o *XTALOSC24M_Type) SetMISC0_TOG_VID_PLL_PREDIV(value uint32) {
	volatile.StoreUint32(&o.MISC0_TOG.Reg, volatile.LoadUint32(&o.MISC0_TOG.Reg)&^(0x80000000)|value<<31)
}
func (o *XTALOSC24M_Type) GetMISC0_TOG_VID_PLL_PREDIV() uint32 {
	return (volatile.LoadUint32(&o.MISC0_TOG.Reg) & 0x80000000) >> 31
}

// XTALOSC24M.LOWPWR_CTRL: XTAL OSC (LP) Control Register
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_RC_OSC_EN(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL.Reg)&^(0x1)|value)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_RC_OSC_EN() uint32 {
	return volatile.LoadUint32(&o.LOWPWR_CTRL.Reg) & 0x1
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_OSC_SEL(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL.Reg)&^(0x10)|value<<4)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_OSC_SEL() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL.Reg) & 0x10) >> 4
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_LPBG_SEL(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL.Reg)&^(0x20)|value<<5)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_LPBG_SEL() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL.Reg) & 0x20) >> 5
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_LPBG_TEST(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL.Reg)&^(0x40)|value<<6)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_LPBG_TEST() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL.Reg) & 0x40) >> 6
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_REFTOP_IBIAS_OFF(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL.Reg)&^(0x80)|value<<7)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_REFTOP_IBIAS_OFF() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL.Reg) & 0x80) >> 7
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_L1_PWRGATE(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL.Reg)&^(0x100)|value<<8)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_L1_PWRGATE() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL.Reg) & 0x100) >> 8
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_L2_PWRGATE(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL.Reg)&^(0x200)|value<<9)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_L2_PWRGATE() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL.Reg) & 0x200) >> 9
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_CPU_PWRGATE(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL.Reg)&^(0x400)|value<<10)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_CPU_PWRGATE() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL.Reg) & 0x400) >> 10
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_DISPLAY_PWRGATE(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL.Reg)&^(0x800)|value<<11)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_DISPLAY_PWRGATE() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL.Reg) & 0x800) >> 11
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_RCOSC_CG_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL.Reg)&^(0x2000)|value<<13)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_RCOSC_CG_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL.Reg) & 0x2000) >> 13
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_XTALOSC_PWRUP_DELAY(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL.Reg)&^(0xc000)|value<<14)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_XTALOSC_PWRUP_DELAY() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL.Reg) & 0xc000) >> 14
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_XTALOSC_PWRUP_STAT(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_XTALOSC_PWRUP_STAT() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL.Reg) & 0x10000) >> 16
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_MIX_PWRGATE(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL.Reg)&^(0x20000)|value<<17)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_MIX_PWRGATE() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL.Reg) & 0x20000) >> 17
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_GPU_PWRGATE(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL.Reg)&^(0x40000)|value<<18)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_GPU_PWRGATE() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL.Reg) & 0x40000) >> 18
}

// XTALOSC24M.LOWPWR_CTRL_SET: XTAL OSC (LP) Control Register
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_SET_RC_OSC_EN(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_SET.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_SET.Reg)&^(0x1)|value)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_SET_RC_OSC_EN() uint32 {
	return volatile.LoadUint32(&o.LOWPWR_CTRL_SET.Reg) & 0x1
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_SET_OSC_SEL(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_SET.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_SET.Reg)&^(0x10)|value<<4)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_SET_OSC_SEL() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_SET.Reg) & 0x10) >> 4
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_SET_LPBG_SEL(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_SET.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_SET.Reg)&^(0x20)|value<<5)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_SET_LPBG_SEL() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_SET.Reg) & 0x20) >> 5
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_SET_LPBG_TEST(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_SET.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_SET.Reg)&^(0x40)|value<<6)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_SET_LPBG_TEST() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_SET.Reg) & 0x40) >> 6
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_SET_REFTOP_IBIAS_OFF(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_SET.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_SET.Reg)&^(0x80)|value<<7)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_SET_REFTOP_IBIAS_OFF() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_SET.Reg) & 0x80) >> 7
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_SET_L1_PWRGATE(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_SET.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_SET.Reg)&^(0x100)|value<<8)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_SET_L1_PWRGATE() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_SET.Reg) & 0x100) >> 8
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_SET_L2_PWRGATE(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_SET.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_SET.Reg)&^(0x200)|value<<9)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_SET_L2_PWRGATE() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_SET.Reg) & 0x200) >> 9
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_SET_CPU_PWRGATE(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_SET.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_SET.Reg)&^(0x400)|value<<10)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_SET_CPU_PWRGATE() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_SET.Reg) & 0x400) >> 10
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_SET_DISPLAY_PWRGATE(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_SET.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_SET.Reg)&^(0x800)|value<<11)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_SET_DISPLAY_PWRGATE() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_SET.Reg) & 0x800) >> 11
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_SET_RCOSC_CG_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_SET.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_SET.Reg)&^(0x2000)|value<<13)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_SET_RCOSC_CG_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_SET.Reg) & 0x2000) >> 13
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_SET_XTALOSC_PWRUP_DELAY(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_SET.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_SET.Reg)&^(0xc000)|value<<14)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_SET_XTALOSC_PWRUP_DELAY() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_SET.Reg) & 0xc000) >> 14
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_SET_XTALOSC_PWRUP_STAT(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_SET.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_SET.Reg)&^(0x10000)|value<<16)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_SET_XTALOSC_PWRUP_STAT() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_SET.Reg) & 0x10000) >> 16
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_SET_MIX_PWRGATE(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_SET.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_SET.Reg)&^(0x20000)|value<<17)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_SET_MIX_PWRGATE() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_SET.Reg) & 0x20000) >> 17
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_SET_GPU_PWRGATE(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_SET.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_SET.Reg)&^(0x40000)|value<<18)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_SET_GPU_PWRGATE() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_SET.Reg) & 0x40000) >> 18
}

// XTALOSC24M.LOWPWR_CTRL_CLR: XTAL OSC (LP) Control Register
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_CLR_RC_OSC_EN(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_CLR.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_CLR.Reg)&^(0x1)|value)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_CLR_RC_OSC_EN() uint32 {
	return volatile.LoadUint32(&o.LOWPWR_CTRL_CLR.Reg) & 0x1
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_CLR_OSC_SEL(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_CLR.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_CLR.Reg)&^(0x10)|value<<4)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_CLR_OSC_SEL() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_CLR.Reg) & 0x10) >> 4
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_CLR_LPBG_SEL(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_CLR.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_CLR.Reg)&^(0x20)|value<<5)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_CLR_LPBG_SEL() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_CLR.Reg) & 0x20) >> 5
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_CLR_LPBG_TEST(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_CLR.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_CLR.Reg)&^(0x40)|value<<6)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_CLR_LPBG_TEST() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_CLR.Reg) & 0x40) >> 6
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_CLR_REFTOP_IBIAS_OFF(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_CLR.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_CLR.Reg)&^(0x80)|value<<7)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_CLR_REFTOP_IBIAS_OFF() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_CLR.Reg) & 0x80) >> 7
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_CLR_L1_PWRGATE(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_CLR.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_CLR.Reg)&^(0x100)|value<<8)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_CLR_L1_PWRGATE() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_CLR.Reg) & 0x100) >> 8
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_CLR_L2_PWRGATE(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_CLR.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_CLR.Reg)&^(0x200)|value<<9)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_CLR_L2_PWRGATE() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_CLR.Reg) & 0x200) >> 9
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_CLR_CPU_PWRGATE(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_CLR.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_CLR.Reg)&^(0x400)|value<<10)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_CLR_CPU_PWRGATE() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_CLR.Reg) & 0x400) >> 10
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_CLR_DISPLAY_PWRGATE(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_CLR.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_CLR.Reg)&^(0x800)|value<<11)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_CLR_DISPLAY_PWRGATE() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_CLR.Reg) & 0x800) >> 11
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_CLR_RCOSC_CG_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_CLR.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_CLR_RCOSC_CG_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_CLR.Reg) & 0x2000) >> 13
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_CLR_XTALOSC_PWRUP_DELAY(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_CLR.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_CLR.Reg)&^(0xc000)|value<<14)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_CLR_XTALOSC_PWRUP_DELAY() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_CLR.Reg) & 0xc000) >> 14
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_CLR_XTALOSC_PWRUP_STAT(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_CLR.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_CLR_XTALOSC_PWRUP_STAT() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_CLR.Reg) & 0x10000) >> 16
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_CLR_MIX_PWRGATE(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_CLR.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_CLR_MIX_PWRGATE() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_CLR.Reg) & 0x20000) >> 17
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_CLR_GPU_PWRGATE(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_CLR.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_CLR.Reg)&^(0x40000)|value<<18)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_CLR_GPU_PWRGATE() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_CLR.Reg) & 0x40000) >> 18
}

// XTALOSC24M.LOWPWR_CTRL_TOG: XTAL OSC (LP) Control Register
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_TOG_RC_OSC_EN(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_TOG.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_TOG.Reg)&^(0x1)|value)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_TOG_RC_OSC_EN() uint32 {
	return volatile.LoadUint32(&o.LOWPWR_CTRL_TOG.Reg) & 0x1
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_TOG_OSC_SEL(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_TOG.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_TOG.Reg)&^(0x10)|value<<4)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_TOG_OSC_SEL() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_TOG.Reg) & 0x10) >> 4
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_TOG_LPBG_SEL(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_TOG.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_TOG.Reg)&^(0x20)|value<<5)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_TOG_LPBG_SEL() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_TOG.Reg) & 0x20) >> 5
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_TOG_LPBG_TEST(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_TOG.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_TOG.Reg)&^(0x40)|value<<6)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_TOG_LPBG_TEST() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_TOG.Reg) & 0x40) >> 6
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_TOG_REFTOP_IBIAS_OFF(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_TOG.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_TOG.Reg)&^(0x80)|value<<7)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_TOG_REFTOP_IBIAS_OFF() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_TOG.Reg) & 0x80) >> 7
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_TOG_L1_PWRGATE(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_TOG.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_TOG.Reg)&^(0x100)|value<<8)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_TOG_L1_PWRGATE() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_TOG.Reg) & 0x100) >> 8
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_TOG_L2_PWRGATE(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_TOG.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_TOG.Reg)&^(0x200)|value<<9)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_TOG_L2_PWRGATE() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_TOG.Reg) & 0x200) >> 9
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_TOG_CPU_PWRGATE(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_TOG.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_TOG.Reg)&^(0x400)|value<<10)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_TOG_CPU_PWRGATE() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_TOG.Reg) & 0x400) >> 10
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_TOG_DISPLAY_PWRGATE(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_TOG.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_TOG.Reg)&^(0x800)|value<<11)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_TOG_DISPLAY_PWRGATE() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_TOG.Reg) & 0x800) >> 11
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_TOG_RCOSC_CG_OVERRIDE(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_TOG.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_TOG.Reg)&^(0x2000)|value<<13)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_TOG_RCOSC_CG_OVERRIDE() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_TOG.Reg) & 0x2000) >> 13
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_TOG_XTALOSC_PWRUP_DELAY(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_TOG.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_TOG.Reg)&^(0xc000)|value<<14)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_TOG_XTALOSC_PWRUP_DELAY() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_TOG.Reg) & 0xc000) >> 14
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_TOG_XTALOSC_PWRUP_STAT(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_TOG.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_TOG.Reg)&^(0x10000)|value<<16)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_TOG_XTALOSC_PWRUP_STAT() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_TOG.Reg) & 0x10000) >> 16
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_TOG_MIX_PWRGATE(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_TOG.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_TOG.Reg)&^(0x20000)|value<<17)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_TOG_MIX_PWRGATE() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_TOG.Reg) & 0x20000) >> 17
}
func (o *XTALOSC24M_Type) SetLOWPWR_CTRL_TOG_GPU_PWRGATE(value uint32) {
	volatile.StoreUint32(&o.LOWPWR_CTRL_TOG.Reg, volatile.LoadUint32(&o.LOWPWR_CTRL_TOG.Reg)&^(0x40000)|value<<18)
}
func (o *XTALOSC24M_Type) GetLOWPWR_CTRL_TOG_GPU_PWRGATE() uint32 {
	return (volatile.LoadUint32(&o.LOWPWR_CTRL_TOG.Reg) & 0x40000) >> 18
}

// XTALOSC24M.OSC_CONFIG0: XTAL OSC Configuration 0 Register
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_START(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0.Reg, volatile.LoadUint32(&o.OSC_CONFIG0.Reg)&^(0x1)|value)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_START() uint32 {
	return volatile.LoadUint32(&o.OSC_CONFIG0.Reg) & 0x1
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_ENABLE(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0.Reg, volatile.LoadUint32(&o.OSC_CONFIG0.Reg)&^(0x2)|value<<1)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG0.Reg) & 0x2) >> 1
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_BYPASS(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0.Reg, volatile.LoadUint32(&o.OSC_CONFIG0.Reg)&^(0x4)|value<<2)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG0.Reg) & 0x4) >> 2
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_INVERT(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0.Reg, volatile.LoadUint32(&o.OSC_CONFIG0.Reg)&^(0x8)|value<<3)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_INVERT() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG0.Reg) & 0x8) >> 3
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_RC_OSC_PROG(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0.Reg, volatile.LoadUint32(&o.OSC_CONFIG0.Reg)&^(0xff0)|value<<4)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_RC_OSC_PROG() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG0.Reg) & 0xff0) >> 4
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_HYST_PLUS(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0.Reg, volatile.LoadUint32(&o.OSC_CONFIG0.Reg)&^(0xf000)|value<<12)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_HYST_PLUS() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG0.Reg) & 0xf000) >> 12
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_HYST_MINUS(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0.Reg, volatile.LoadUint32(&o.OSC_CONFIG0.Reg)&^(0xf0000)|value<<16)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_HYST_MINUS() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG0.Reg) & 0xf0000) >> 16
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_RC_OSC_PROG_CUR(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0.Reg, volatile.LoadUint32(&o.OSC_CONFIG0.Reg)&^(0xff000000)|value<<24)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_RC_OSC_PROG_CUR() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG0.Reg) & 0xff000000) >> 24
}

// XTALOSC24M.OSC_CONFIG0_SET: XTAL OSC Configuration 0 Register
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_SET_START(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0_SET.Reg, volatile.LoadUint32(&o.OSC_CONFIG0_SET.Reg)&^(0x1)|value)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_SET_START() uint32 {
	return volatile.LoadUint32(&o.OSC_CONFIG0_SET.Reg) & 0x1
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_SET_ENABLE(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0_SET.Reg, volatile.LoadUint32(&o.OSC_CONFIG0_SET.Reg)&^(0x2)|value<<1)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_SET_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG0_SET.Reg) & 0x2) >> 1
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_SET_BYPASS(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0_SET.Reg, volatile.LoadUint32(&o.OSC_CONFIG0_SET.Reg)&^(0x4)|value<<2)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_SET_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG0_SET.Reg) & 0x4) >> 2
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_SET_INVERT(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0_SET.Reg, volatile.LoadUint32(&o.OSC_CONFIG0_SET.Reg)&^(0x8)|value<<3)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_SET_INVERT() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG0_SET.Reg) & 0x8) >> 3
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_SET_RC_OSC_PROG(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0_SET.Reg, volatile.LoadUint32(&o.OSC_CONFIG0_SET.Reg)&^(0xff0)|value<<4)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_SET_RC_OSC_PROG() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG0_SET.Reg) & 0xff0) >> 4
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_SET_HYST_PLUS(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0_SET.Reg, volatile.LoadUint32(&o.OSC_CONFIG0_SET.Reg)&^(0xf000)|value<<12)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_SET_HYST_PLUS() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG0_SET.Reg) & 0xf000) >> 12
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_SET_HYST_MINUS(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0_SET.Reg, volatile.LoadUint32(&o.OSC_CONFIG0_SET.Reg)&^(0xf0000)|value<<16)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_SET_HYST_MINUS() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG0_SET.Reg) & 0xf0000) >> 16
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_SET_RC_OSC_PROG_CUR(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0_SET.Reg, volatile.LoadUint32(&o.OSC_CONFIG0_SET.Reg)&^(0xff000000)|value<<24)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_SET_RC_OSC_PROG_CUR() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG0_SET.Reg) & 0xff000000) >> 24
}

// XTALOSC24M.OSC_CONFIG0_CLR: XTAL OSC Configuration 0 Register
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_CLR_START(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0_CLR.Reg, volatile.LoadUint32(&o.OSC_CONFIG0_CLR.Reg)&^(0x1)|value)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_CLR_START() uint32 {
	return volatile.LoadUint32(&o.OSC_CONFIG0_CLR.Reg) & 0x1
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_CLR_ENABLE(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0_CLR.Reg, volatile.LoadUint32(&o.OSC_CONFIG0_CLR.Reg)&^(0x2)|value<<1)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_CLR_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG0_CLR.Reg) & 0x2) >> 1
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_CLR_BYPASS(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0_CLR.Reg, volatile.LoadUint32(&o.OSC_CONFIG0_CLR.Reg)&^(0x4)|value<<2)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_CLR_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG0_CLR.Reg) & 0x4) >> 2
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_CLR_INVERT(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0_CLR.Reg, volatile.LoadUint32(&o.OSC_CONFIG0_CLR.Reg)&^(0x8)|value<<3)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_CLR_INVERT() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG0_CLR.Reg) & 0x8) >> 3
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_CLR_RC_OSC_PROG(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0_CLR.Reg, volatile.LoadUint32(&o.OSC_CONFIG0_CLR.Reg)&^(0xff0)|value<<4)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_CLR_RC_OSC_PROG() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG0_CLR.Reg) & 0xff0) >> 4
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_CLR_HYST_PLUS(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0_CLR.Reg, volatile.LoadUint32(&o.OSC_CONFIG0_CLR.Reg)&^(0xf000)|value<<12)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_CLR_HYST_PLUS() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG0_CLR.Reg) & 0xf000) >> 12
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_CLR_HYST_MINUS(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0_CLR.Reg, volatile.LoadUint32(&o.OSC_CONFIG0_CLR.Reg)&^(0xf0000)|value<<16)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_CLR_HYST_MINUS() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG0_CLR.Reg) & 0xf0000) >> 16
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_CLR_RC_OSC_PROG_CUR(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0_CLR.Reg, volatile.LoadUint32(&o.OSC_CONFIG0_CLR.Reg)&^(0xff000000)|value<<24)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_CLR_RC_OSC_PROG_CUR() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG0_CLR.Reg) & 0xff000000) >> 24
}

// XTALOSC24M.OSC_CONFIG0_TOG: XTAL OSC Configuration 0 Register
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_TOG_START(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0_TOG.Reg, volatile.LoadUint32(&o.OSC_CONFIG0_TOG.Reg)&^(0x1)|value)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_TOG_START() uint32 {
	return volatile.LoadUint32(&o.OSC_CONFIG0_TOG.Reg) & 0x1
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_TOG_ENABLE(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0_TOG.Reg, volatile.LoadUint32(&o.OSC_CONFIG0_TOG.Reg)&^(0x2)|value<<1)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_TOG_ENABLE() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG0_TOG.Reg) & 0x2) >> 1
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_TOG_BYPASS(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0_TOG.Reg, volatile.LoadUint32(&o.OSC_CONFIG0_TOG.Reg)&^(0x4)|value<<2)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_TOG_BYPASS() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG0_TOG.Reg) & 0x4) >> 2
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_TOG_INVERT(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0_TOG.Reg, volatile.LoadUint32(&o.OSC_CONFIG0_TOG.Reg)&^(0x8)|value<<3)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_TOG_INVERT() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG0_TOG.Reg) & 0x8) >> 3
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_TOG_RC_OSC_PROG(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0_TOG.Reg, volatile.LoadUint32(&o.OSC_CONFIG0_TOG.Reg)&^(0xff0)|value<<4)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_TOG_RC_OSC_PROG() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG0_TOG.Reg) & 0xff0) >> 4
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_TOG_HYST_PLUS(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0_TOG.Reg, volatile.LoadUint32(&o.OSC_CONFIG0_TOG.Reg)&^(0xf000)|value<<12)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_TOG_HYST_PLUS() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG0_TOG.Reg) & 0xf000) >> 12
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_TOG_HYST_MINUS(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0_TOG.Reg, volatile.LoadUint32(&o.OSC_CONFIG0_TOG.Reg)&^(0xf0000)|value<<16)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_TOG_HYST_MINUS() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG0_TOG.Reg) & 0xf0000) >> 16
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG0_TOG_RC_OSC_PROG_CUR(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG0_TOG.Reg, volatile.LoadUint32(&o.OSC_CONFIG0_TOG.Reg)&^(0xff000000)|value<<24)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG0_TOG_RC_OSC_PROG_CUR() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG0_TOG.Reg) & 0xff000000) >> 24
}

// XTALOSC24M.OSC_CONFIG1: XTAL OSC Configuration 1 Register
func (o *XTALOSC24M_Type) SetOSC_CONFIG1_COUNT_RC_TRG(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG1.Reg, volatile.LoadUint32(&o.OSC_CONFIG1.Reg)&^(0xfff)|value)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG1_COUNT_RC_TRG() uint32 {
	return volatile.LoadUint32(&o.OSC_CONFIG1.Reg) & 0xfff
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG1_COUNT_RC_CUR(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG1.Reg, volatile.LoadUint32(&o.OSC_CONFIG1.Reg)&^(0xfff00000)|value<<20)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG1_COUNT_RC_CUR() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG1.Reg) & 0xfff00000) >> 20
}

// XTALOSC24M.OSC_CONFIG1_SET: XTAL OSC Configuration 1 Register
func (o *XTALOSC24M_Type) SetOSC_CONFIG1_SET_COUNT_RC_TRG(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG1_SET.Reg, volatile.LoadUint32(&o.OSC_CONFIG1_SET.Reg)&^(0xfff)|value)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG1_SET_COUNT_RC_TRG() uint32 {
	return volatile.LoadUint32(&o.OSC_CONFIG1_SET.Reg) & 0xfff
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG1_SET_COUNT_RC_CUR(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG1_SET.Reg, volatile.LoadUint32(&o.OSC_CONFIG1_SET.Reg)&^(0xfff00000)|value<<20)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG1_SET_COUNT_RC_CUR() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG1_SET.Reg) & 0xfff00000) >> 20
}

// XTALOSC24M.OSC_CONFIG1_CLR: XTAL OSC Configuration 1 Register
func (o *XTALOSC24M_Type) SetOSC_CONFIG1_CLR_COUNT_RC_TRG(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG1_CLR.Reg, volatile.LoadUint32(&o.OSC_CONFIG1_CLR.Reg)&^(0xfff)|value)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG1_CLR_COUNT_RC_TRG() uint32 {
	return volatile.LoadUint32(&o.OSC_CONFIG1_CLR.Reg) & 0xfff
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG1_CLR_COUNT_RC_CUR(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG1_CLR.Reg, volatile.LoadUint32(&o.OSC_CONFIG1_CLR.Reg)&^(0xfff00000)|value<<20)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG1_CLR_COUNT_RC_CUR() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG1_CLR.Reg) & 0xfff00000) >> 20
}

// XTALOSC24M.OSC_CONFIG1_TOG: XTAL OSC Configuration 1 Register
func (o *XTALOSC24M_Type) SetOSC_CONFIG1_TOG_COUNT_RC_TRG(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG1_TOG.Reg, volatile.LoadUint32(&o.OSC_CONFIG1_TOG.Reg)&^(0xfff)|value)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG1_TOG_COUNT_RC_TRG() uint32 {
	return volatile.LoadUint32(&o.OSC_CONFIG1_TOG.Reg) & 0xfff
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG1_TOG_COUNT_RC_CUR(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG1_TOG.Reg, volatile.LoadUint32(&o.OSC_CONFIG1_TOG.Reg)&^(0xfff00000)|value<<20)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG1_TOG_COUNT_RC_CUR() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG1_TOG.Reg) & 0xfff00000) >> 20
}

// XTALOSC24M.OSC_CONFIG2: XTAL OSC Configuration 2 Register
func (o *XTALOSC24M_Type) SetOSC_CONFIG2_COUNT_1M_TRG(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG2.Reg, volatile.LoadUint32(&o.OSC_CONFIG2.Reg)&^(0xfff)|value)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG2_COUNT_1M_TRG() uint32 {
	return volatile.LoadUint32(&o.OSC_CONFIG2.Reg) & 0xfff
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG2_ENABLE_1M(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG2.Reg, volatile.LoadUint32(&o.OSC_CONFIG2.Reg)&^(0x10000)|value<<16)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG2_ENABLE_1M() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG2.Reg) & 0x10000) >> 16
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG2_MUX_1M(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG2.Reg, volatile.LoadUint32(&o.OSC_CONFIG2.Reg)&^(0x20000)|value<<17)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG2_MUX_1M() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG2.Reg) & 0x20000) >> 17
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG2_CLK_1M_ERR_FL(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG2.Reg, volatile.LoadUint32(&o.OSC_CONFIG2.Reg)&^(0x80000000)|value<<31)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG2_CLK_1M_ERR_FL() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG2.Reg) & 0x80000000) >> 31
}

// XTALOSC24M.OSC_CONFIG2_SET: XTAL OSC Configuration 2 Register
func (o *XTALOSC24M_Type) SetOSC_CONFIG2_SET_COUNT_1M_TRG(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG2_SET.Reg, volatile.LoadUint32(&o.OSC_CONFIG2_SET.Reg)&^(0xfff)|value)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG2_SET_COUNT_1M_TRG() uint32 {
	return volatile.LoadUint32(&o.OSC_CONFIG2_SET.Reg) & 0xfff
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG2_SET_ENABLE_1M(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG2_SET.Reg, volatile.LoadUint32(&o.OSC_CONFIG2_SET.Reg)&^(0x10000)|value<<16)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG2_SET_ENABLE_1M() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG2_SET.Reg) & 0x10000) >> 16
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG2_SET_MUX_1M(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG2_SET.Reg, volatile.LoadUint32(&o.OSC_CONFIG2_SET.Reg)&^(0x20000)|value<<17)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG2_SET_MUX_1M() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG2_SET.Reg) & 0x20000) >> 17
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG2_SET_CLK_1M_ERR_FL(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG2_SET.Reg, volatile.LoadUint32(&o.OSC_CONFIG2_SET.Reg)&^(0x80000000)|value<<31)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG2_SET_CLK_1M_ERR_FL() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG2_SET.Reg) & 0x80000000) >> 31
}

// XTALOSC24M.OSC_CONFIG2_CLR: XTAL OSC Configuration 2 Register
func (o *XTALOSC24M_Type) SetOSC_CONFIG2_CLR_COUNT_1M_TRG(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG2_CLR.Reg, volatile.LoadUint32(&o.OSC_CONFIG2_CLR.Reg)&^(0xfff)|value)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG2_CLR_COUNT_1M_TRG() uint32 {
	return volatile.LoadUint32(&o.OSC_CONFIG2_CLR.Reg) & 0xfff
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG2_CLR_ENABLE_1M(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG2_CLR.Reg, volatile.LoadUint32(&o.OSC_CONFIG2_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG2_CLR_ENABLE_1M() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG2_CLR.Reg) & 0x10000) >> 16
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG2_CLR_MUX_1M(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG2_CLR.Reg, volatile.LoadUint32(&o.OSC_CONFIG2_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG2_CLR_MUX_1M() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG2_CLR.Reg) & 0x20000) >> 17
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG2_CLR_CLK_1M_ERR_FL(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG2_CLR.Reg, volatile.LoadUint32(&o.OSC_CONFIG2_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG2_CLR_CLK_1M_ERR_FL() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG2_CLR.Reg) & 0x80000000) >> 31
}

// XTALOSC24M.OSC_CONFIG2_TOG: XTAL OSC Configuration 2 Register
func (o *XTALOSC24M_Type) SetOSC_CONFIG2_TOG_COUNT_1M_TRG(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG2_TOG.Reg, volatile.LoadUint32(&o.OSC_CONFIG2_TOG.Reg)&^(0xfff)|value)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG2_TOG_COUNT_1M_TRG() uint32 {
	return volatile.LoadUint32(&o.OSC_CONFIG2_TOG.Reg) & 0xfff
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG2_TOG_ENABLE_1M(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG2_TOG.Reg, volatile.LoadUint32(&o.OSC_CONFIG2_TOG.Reg)&^(0x10000)|value<<16)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG2_TOG_ENABLE_1M() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG2_TOG.Reg) & 0x10000) >> 16
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG2_TOG_MUX_1M(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG2_TOG.Reg, volatile.LoadUint32(&o.OSC_CONFIG2_TOG.Reg)&^(0x20000)|value<<17)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG2_TOG_MUX_1M() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG2_TOG.Reg) & 0x20000) >> 17
}
func (o *XTALOSC24M_Type) SetOSC_CONFIG2_TOG_CLK_1M_ERR_FL(value uint32) {
	volatile.StoreUint32(&o.OSC_CONFIG2_TOG.Reg, volatile.LoadUint32(&o.OSC_CONFIG2_TOG.Reg)&^(0x80000000)|value<<31)
}
func (o *XTALOSC24M_Type) GetOSC_CONFIG2_TOG_CLK_1M_ERR_FL() uint32 {
	return (volatile.LoadUint32(&o.OSC_CONFIG2_TOG.Reg) & 0x80000000) >> 31
}

// USBPHY Register Reference Index
type USBPHY_Type struct {
	PWD           volatile.Register32 // 0x0
	PWD_SET       volatile.Register32 // 0x4
	PWD_CLR       volatile.Register32 // 0x8
	PWD_TOG       volatile.Register32 // 0xC
	TX            volatile.Register32 // 0x10
	TX_SET        volatile.Register32 // 0x14
	TX_CLR        volatile.Register32 // 0x18
	TX_TOG        volatile.Register32 // 0x1C
	RX            volatile.Register32 // 0x20
	RX_SET        volatile.Register32 // 0x24
	RX_CLR        volatile.Register32 // 0x28
	RX_TOG        volatile.Register32 // 0x2C
	CTRL          volatile.Register32 // 0x30
	CTRL_SET      volatile.Register32 // 0x34
	CTRL_CLR      volatile.Register32 // 0x38
	CTRL_TOG      volatile.Register32 // 0x3C
	STATUS        volatile.Register32 // 0x40
	_             [12]byte
	DEBUG         volatile.Register32 // 0x50
	DEBUG_SET     volatile.Register32 // 0x54
	DEBUG_CLR     volatile.Register32 // 0x58
	DEBUG_TOG     volatile.Register32 // 0x5C
	DEBUG0_STATUS volatile.Register32 // 0x60
	_             [12]byte
	DEBUG1        volatile.Register32 // 0x70
	DEBUG1_SET    volatile.Register32 // 0x74
	DEBUG1_CLR    volatile.Register32 // 0x78
	DEBUG1_TOG    volatile.Register32 // 0x7C
	VERSION       volatile.Register32 // 0x80
}

// USBPHY.PWD: USB PHY Power-Down Register
func (o *USBPHY_Type) SetPWD_RSVD0(value uint32) {
	volatile.StoreUint32(&o.PWD.Reg, volatile.LoadUint32(&o.PWD.Reg)&^(0x3ff)|value)
}
func (o *USBPHY_Type) GetPWD_RSVD0() uint32 {
	return volatile.LoadUint32(&o.PWD.Reg) & 0x3ff
}
func (o *USBPHY_Type) SetPWD_TXPWDFS(value uint32) {
	volatile.StoreUint32(&o.PWD.Reg, volatile.LoadUint32(&o.PWD.Reg)&^(0x400)|value<<10)
}
func (o *USBPHY_Type) GetPWD_TXPWDFS() uint32 {
	return (volatile.LoadUint32(&o.PWD.Reg) & 0x400) >> 10
}
func (o *USBPHY_Type) SetPWD_TXPWDIBIAS(value uint32) {
	volatile.StoreUint32(&o.PWD.Reg, volatile.LoadUint32(&o.PWD.Reg)&^(0x800)|value<<11)
}
func (o *USBPHY_Type) GetPWD_TXPWDIBIAS() uint32 {
	return (volatile.LoadUint32(&o.PWD.Reg) & 0x800) >> 11
}
func (o *USBPHY_Type) SetPWD_TXPWDV2I(value uint32) {
	volatile.StoreUint32(&o.PWD.Reg, volatile.LoadUint32(&o.PWD.Reg)&^(0x1000)|value<<12)
}
func (o *USBPHY_Type) GetPWD_TXPWDV2I() uint32 {
	return (volatile.LoadUint32(&o.PWD.Reg) & 0x1000) >> 12
}
func (o *USBPHY_Type) SetPWD_RSVD1(value uint32) {
	volatile.StoreUint32(&o.PWD.Reg, volatile.LoadUint32(&o.PWD.Reg)&^(0x1e000)|value<<13)
}
func (o *USBPHY_Type) GetPWD_RSVD1() uint32 {
	return (volatile.LoadUint32(&o.PWD.Reg) & 0x1e000) >> 13
}
func (o *USBPHY_Type) SetPWD_RXPWDENV(value uint32) {
	volatile.StoreUint32(&o.PWD.Reg, volatile.LoadUint32(&o.PWD.Reg)&^(0x20000)|value<<17)
}
func (o *USBPHY_Type) GetPWD_RXPWDENV() uint32 {
	return (volatile.LoadUint32(&o.PWD.Reg) & 0x20000) >> 17
}
func (o *USBPHY_Type) SetPWD_RXPWD1PT1(value uint32) {
	volatile.StoreUint32(&o.PWD.Reg, volatile.LoadUint32(&o.PWD.Reg)&^(0x40000)|value<<18)
}
func (o *USBPHY_Type) GetPWD_RXPWD1PT1() uint32 {
	return (volatile.LoadUint32(&o.PWD.Reg) & 0x40000) >> 18
}
func (o *USBPHY_Type) SetPWD_RXPWDDIFF(value uint32) {
	volatile.StoreUint32(&o.PWD.Reg, volatile.LoadUint32(&o.PWD.Reg)&^(0x80000)|value<<19)
}
func (o *USBPHY_Type) GetPWD_RXPWDDIFF() uint32 {
	return (volatile.LoadUint32(&o.PWD.Reg) & 0x80000) >> 19
}
func (o *USBPHY_Type) SetPWD_RXPWDRX(value uint32) {
	volatile.StoreUint32(&o.PWD.Reg, volatile.LoadUint32(&o.PWD.Reg)&^(0x100000)|value<<20)
}
func (o *USBPHY_Type) GetPWD_RXPWDRX() uint32 {
	return (volatile.LoadUint32(&o.PWD.Reg) & 0x100000) >> 20
}
func (o *USBPHY_Type) SetPWD_RSVD2(value uint32) {
	volatile.StoreUint32(&o.PWD.Reg, volatile.LoadUint32(&o.PWD.Reg)&^(0xffe00000)|value<<21)
}
func (o *USBPHY_Type) GetPWD_RSVD2() uint32 {
	return (volatile.LoadUint32(&o.PWD.Reg) & 0xffe00000) >> 21
}

// USBPHY.PWD_SET: USB PHY Power-Down Register
func (o *USBPHY_Type) SetPWD_SET_RSVD0(value uint32) {
	volatile.StoreUint32(&o.PWD_SET.Reg, volatile.LoadUint32(&o.PWD_SET.Reg)&^(0x3ff)|value)
}
func (o *USBPHY_Type) GetPWD_SET_RSVD0() uint32 {
	return volatile.LoadUint32(&o.PWD_SET.Reg) & 0x3ff
}
func (o *USBPHY_Type) SetPWD_SET_TXPWDFS(value uint32) {
	volatile.StoreUint32(&o.PWD_SET.Reg, volatile.LoadUint32(&o.PWD_SET.Reg)&^(0x400)|value<<10)
}
func (o *USBPHY_Type) GetPWD_SET_TXPWDFS() uint32 {
	return (volatile.LoadUint32(&o.PWD_SET.Reg) & 0x400) >> 10
}
func (o *USBPHY_Type) SetPWD_SET_TXPWDIBIAS(value uint32) {
	volatile.StoreUint32(&o.PWD_SET.Reg, volatile.LoadUint32(&o.PWD_SET.Reg)&^(0x800)|value<<11)
}
func (o *USBPHY_Type) GetPWD_SET_TXPWDIBIAS() uint32 {
	return (volatile.LoadUint32(&o.PWD_SET.Reg) & 0x800) >> 11
}
func (o *USBPHY_Type) SetPWD_SET_TXPWDV2I(value uint32) {
	volatile.StoreUint32(&o.PWD_SET.Reg, volatile.LoadUint32(&o.PWD_SET.Reg)&^(0x1000)|value<<12)
}
func (o *USBPHY_Type) GetPWD_SET_TXPWDV2I() uint32 {
	return (volatile.LoadUint32(&o.PWD_SET.Reg) & 0x1000) >> 12
}
func (o *USBPHY_Type) SetPWD_SET_RSVD1(value uint32) {
	volatile.StoreUint32(&o.PWD_SET.Reg, volatile.LoadUint32(&o.PWD_SET.Reg)&^(0x1e000)|value<<13)
}
func (o *USBPHY_Type) GetPWD_SET_RSVD1() uint32 {
	return (volatile.LoadUint32(&o.PWD_SET.Reg) & 0x1e000) >> 13
}
func (o *USBPHY_Type) SetPWD_SET_RXPWDENV(value uint32) {
	volatile.StoreUint32(&o.PWD_SET.Reg, volatile.LoadUint32(&o.PWD_SET.Reg)&^(0x20000)|value<<17)
}
func (o *USBPHY_Type) GetPWD_SET_RXPWDENV() uint32 {
	return (volatile.LoadUint32(&o.PWD_SET.Reg) & 0x20000) >> 17
}
func (o *USBPHY_Type) SetPWD_SET_RXPWD1PT1(value uint32) {
	volatile.StoreUint32(&o.PWD_SET.Reg, volatile.LoadUint32(&o.PWD_SET.Reg)&^(0x40000)|value<<18)
}
func (o *USBPHY_Type) GetPWD_SET_RXPWD1PT1() uint32 {
	return (volatile.LoadUint32(&o.PWD_SET.Reg) & 0x40000) >> 18
}
func (o *USBPHY_Type) SetPWD_SET_RXPWDDIFF(value uint32) {
	volatile.StoreUint32(&o.PWD_SET.Reg, volatile.LoadUint32(&o.PWD_SET.Reg)&^(0x80000)|value<<19)
}
func (o *USBPHY_Type) GetPWD_SET_RXPWDDIFF() uint32 {
	return (volatile.LoadUint32(&o.PWD_SET.Reg) & 0x80000) >> 19
}
func (o *USBPHY_Type) SetPWD_SET_RXPWDRX(value uint32) {
	volatile.StoreUint32(&o.PWD_SET.Reg, volatile.LoadUint32(&o.PWD_SET.Reg)&^(0x100000)|value<<20)
}
func (o *USBPHY_Type) GetPWD_SET_RXPWDRX() uint32 {
	return (volatile.LoadUint32(&o.PWD_SET.Reg) & 0x100000) >> 20
}
func (o *USBPHY_Type) SetPWD_SET_RSVD2(value uint32) {
	volatile.StoreUint32(&o.PWD_SET.Reg, volatile.LoadUint32(&o.PWD_SET.Reg)&^(0xffe00000)|value<<21)
}
func (o *USBPHY_Type) GetPWD_SET_RSVD2() uint32 {
	return (volatile.LoadUint32(&o.PWD_SET.Reg) & 0xffe00000) >> 21
}

// USBPHY.PWD_CLR: USB PHY Power-Down Register
func (o *USBPHY_Type) SetPWD_CLR_RSVD0(value uint32) {
	volatile.StoreUint32(&o.PWD_CLR.Reg, volatile.LoadUint32(&o.PWD_CLR.Reg)&^(0x3ff)|value)
}
func (o *USBPHY_Type) GetPWD_CLR_RSVD0() uint32 {
	return volatile.LoadUint32(&o.PWD_CLR.Reg) & 0x3ff
}
func (o *USBPHY_Type) SetPWD_CLR_TXPWDFS(value uint32) {
	volatile.StoreUint32(&o.PWD_CLR.Reg, volatile.LoadUint32(&o.PWD_CLR.Reg)&^(0x400)|value<<10)
}
func (o *USBPHY_Type) GetPWD_CLR_TXPWDFS() uint32 {
	return (volatile.LoadUint32(&o.PWD_CLR.Reg) & 0x400) >> 10
}
func (o *USBPHY_Type) SetPWD_CLR_TXPWDIBIAS(value uint32) {
	volatile.StoreUint32(&o.PWD_CLR.Reg, volatile.LoadUint32(&o.PWD_CLR.Reg)&^(0x800)|value<<11)
}
func (o *USBPHY_Type) GetPWD_CLR_TXPWDIBIAS() uint32 {
	return (volatile.LoadUint32(&o.PWD_CLR.Reg) & 0x800) >> 11
}
func (o *USBPHY_Type) SetPWD_CLR_TXPWDV2I(value uint32) {
	volatile.StoreUint32(&o.PWD_CLR.Reg, volatile.LoadUint32(&o.PWD_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *USBPHY_Type) GetPWD_CLR_TXPWDV2I() uint32 {
	return (volatile.LoadUint32(&o.PWD_CLR.Reg) & 0x1000) >> 12
}
func (o *USBPHY_Type) SetPWD_CLR_RSVD1(value uint32) {
	volatile.StoreUint32(&o.PWD_CLR.Reg, volatile.LoadUint32(&o.PWD_CLR.Reg)&^(0x1e000)|value<<13)
}
func (o *USBPHY_Type) GetPWD_CLR_RSVD1() uint32 {
	return (volatile.LoadUint32(&o.PWD_CLR.Reg) & 0x1e000) >> 13
}
func (o *USBPHY_Type) SetPWD_CLR_RXPWDENV(value uint32) {
	volatile.StoreUint32(&o.PWD_CLR.Reg, volatile.LoadUint32(&o.PWD_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *USBPHY_Type) GetPWD_CLR_RXPWDENV() uint32 {
	return (volatile.LoadUint32(&o.PWD_CLR.Reg) & 0x20000) >> 17
}
func (o *USBPHY_Type) SetPWD_CLR_RXPWD1PT1(value uint32) {
	volatile.StoreUint32(&o.PWD_CLR.Reg, volatile.LoadUint32(&o.PWD_CLR.Reg)&^(0x40000)|value<<18)
}
func (o *USBPHY_Type) GetPWD_CLR_RXPWD1PT1() uint32 {
	return (volatile.LoadUint32(&o.PWD_CLR.Reg) & 0x40000) >> 18
}
func (o *USBPHY_Type) SetPWD_CLR_RXPWDDIFF(value uint32) {
	volatile.StoreUint32(&o.PWD_CLR.Reg, volatile.LoadUint32(&o.PWD_CLR.Reg)&^(0x80000)|value<<19)
}
func (o *USBPHY_Type) GetPWD_CLR_RXPWDDIFF() uint32 {
	return (volatile.LoadUint32(&o.PWD_CLR.Reg) & 0x80000) >> 19
}
func (o *USBPHY_Type) SetPWD_CLR_RXPWDRX(value uint32) {
	volatile.StoreUint32(&o.PWD_CLR.Reg, volatile.LoadUint32(&o.PWD_CLR.Reg)&^(0x100000)|value<<20)
}
func (o *USBPHY_Type) GetPWD_CLR_RXPWDRX() uint32 {
	return (volatile.LoadUint32(&o.PWD_CLR.Reg) & 0x100000) >> 20
}
func (o *USBPHY_Type) SetPWD_CLR_RSVD2(value uint32) {
	volatile.StoreUint32(&o.PWD_CLR.Reg, volatile.LoadUint32(&o.PWD_CLR.Reg)&^(0xffe00000)|value<<21)
}
func (o *USBPHY_Type) GetPWD_CLR_RSVD2() uint32 {
	return (volatile.LoadUint32(&o.PWD_CLR.Reg) & 0xffe00000) >> 21
}

// USBPHY.PWD_TOG: USB PHY Power-Down Register
func (o *USBPHY_Type) SetPWD_TOG_RSVD0(value uint32) {
	volatile.StoreUint32(&o.PWD_TOG.Reg, volatile.LoadUint32(&o.PWD_TOG.Reg)&^(0x3ff)|value)
}
func (o *USBPHY_Type) GetPWD_TOG_RSVD0() uint32 {
	return volatile.LoadUint32(&o.PWD_TOG.Reg) & 0x3ff
}
func (o *USBPHY_Type) SetPWD_TOG_TXPWDFS(value uint32) {
	volatile.StoreUint32(&o.PWD_TOG.Reg, volatile.LoadUint32(&o.PWD_TOG.Reg)&^(0x400)|value<<10)
}
func (o *USBPHY_Type) GetPWD_TOG_TXPWDFS() uint32 {
	return (volatile.LoadUint32(&o.PWD_TOG.Reg) & 0x400) >> 10
}
func (o *USBPHY_Type) SetPWD_TOG_TXPWDIBIAS(value uint32) {
	volatile.StoreUint32(&o.PWD_TOG.Reg, volatile.LoadUint32(&o.PWD_TOG.Reg)&^(0x800)|value<<11)
}
func (o *USBPHY_Type) GetPWD_TOG_TXPWDIBIAS() uint32 {
	return (volatile.LoadUint32(&o.PWD_TOG.Reg) & 0x800) >> 11
}
func (o *USBPHY_Type) SetPWD_TOG_TXPWDV2I(value uint32) {
	volatile.StoreUint32(&o.PWD_TOG.Reg, volatile.LoadUint32(&o.PWD_TOG.Reg)&^(0x1000)|value<<12)
}
func (o *USBPHY_Type) GetPWD_TOG_TXPWDV2I() uint32 {
	return (volatile.LoadUint32(&o.PWD_TOG.Reg) & 0x1000) >> 12
}
func (o *USBPHY_Type) SetPWD_TOG_RSVD1(value uint32) {
	volatile.StoreUint32(&o.PWD_TOG.Reg, volatile.LoadUint32(&o.PWD_TOG.Reg)&^(0x1e000)|value<<13)
}
func (o *USBPHY_Type) GetPWD_TOG_RSVD1() uint32 {
	return (volatile.LoadUint32(&o.PWD_TOG.Reg) & 0x1e000) >> 13
}
func (o *USBPHY_Type) SetPWD_TOG_RXPWDENV(value uint32) {
	volatile.StoreUint32(&o.PWD_TOG.Reg, volatile.LoadUint32(&o.PWD_TOG.Reg)&^(0x20000)|value<<17)
}
func (o *USBPHY_Type) GetPWD_TOG_RXPWDENV() uint32 {
	return (volatile.LoadUint32(&o.PWD_TOG.Reg) & 0x20000) >> 17
}
func (o *USBPHY_Type) SetPWD_TOG_RXPWD1PT1(value uint32) {
	volatile.StoreUint32(&o.PWD_TOG.Reg, volatile.LoadUint32(&o.PWD_TOG.Reg)&^(0x40000)|value<<18)
}
func (o *USBPHY_Type) GetPWD_TOG_RXPWD1PT1() uint32 {
	return (volatile.LoadUint32(&o.PWD_TOG.Reg) & 0x40000) >> 18
}
func (o *USBPHY_Type) SetPWD_TOG_RXPWDDIFF(value uint32) {
	volatile.StoreUint32(&o.PWD_TOG.Reg, volatile.LoadUint32(&o.PWD_TOG.Reg)&^(0x80000)|value<<19)
}
func (o *USBPHY_Type) GetPWD_TOG_RXPWDDIFF() uint32 {
	return (volatile.LoadUint32(&o.PWD_TOG.Reg) & 0x80000) >> 19
}
func (o *USBPHY_Type) SetPWD_TOG_RXPWDRX(value uint32) {
	volatile.StoreUint32(&o.PWD_TOG.Reg, volatile.LoadUint32(&o.PWD_TOG.Reg)&^(0x100000)|value<<20)
}
func (o *USBPHY_Type) GetPWD_TOG_RXPWDRX() uint32 {
	return (volatile.LoadUint32(&o.PWD_TOG.Reg) & 0x100000) >> 20
}
func (o *USBPHY_Type) SetPWD_TOG_RSVD2(value uint32) {
	volatile.StoreUint32(&o.PWD_TOG.Reg, volatile.LoadUint32(&o.PWD_TOG.Reg)&^(0xffe00000)|value<<21)
}
func (o *USBPHY_Type) GetPWD_TOG_RSVD2() uint32 {
	return (volatile.LoadUint32(&o.PWD_TOG.Reg) & 0xffe00000) >> 21
}

// USBPHY.TX: USB PHY Transmitter Control Register
func (o *USBPHY_Type) SetTX_D_CAL(value uint32) {
	volatile.StoreUint32(&o.TX.Reg, volatile.LoadUint32(&o.TX.Reg)&^(0xf)|value)
}
func (o *USBPHY_Type) GetTX_D_CAL() uint32 {
	return volatile.LoadUint32(&o.TX.Reg) & 0xf
}
func (o *USBPHY_Type) SetTX_RSVD0(value uint32) {
	volatile.StoreUint32(&o.TX.Reg, volatile.LoadUint32(&o.TX.Reg)&^(0xf0)|value<<4)
}
func (o *USBPHY_Type) GetTX_RSVD0() uint32 {
	return (volatile.LoadUint32(&o.TX.Reg) & 0xf0) >> 4
}
func (o *USBPHY_Type) SetTX_TXCAL45DN(value uint32) {
	volatile.StoreUint32(&o.TX.Reg, volatile.LoadUint32(&o.TX.Reg)&^(0xf00)|value<<8)
}
func (o *USBPHY_Type) GetTX_TXCAL45DN() uint32 {
	return (volatile.LoadUint32(&o.TX.Reg) & 0xf00) >> 8
}
func (o *USBPHY_Type) SetTX_RSVD1(value uint32) {
	volatile.StoreUint32(&o.TX.Reg, volatile.LoadUint32(&o.TX.Reg)&^(0xf000)|value<<12)
}
func (o *USBPHY_Type) GetTX_RSVD1() uint32 {
	return (volatile.LoadUint32(&o.TX.Reg) & 0xf000) >> 12
}
func (o *USBPHY_Type) SetTX_TXCAL45DP(value uint32) {
	volatile.StoreUint32(&o.TX.Reg, volatile.LoadUint32(&o.TX.Reg)&^(0xf0000)|value<<16)
}
func (o *USBPHY_Type) GetTX_TXCAL45DP() uint32 {
	return (volatile.LoadUint32(&o.TX.Reg) & 0xf0000) >> 16
}
func (o *USBPHY_Type) SetTX_RSVD2(value uint32) {
	volatile.StoreUint32(&o.TX.Reg, volatile.LoadUint32(&o.TX.Reg)&^(0x3f00000)|value<<20)
}
func (o *USBPHY_Type) GetTX_RSVD2() uint32 {
	return (volatile.LoadUint32(&o.TX.Reg) & 0x3f00000) >> 20
}
func (o *USBPHY_Type) SetTX_USBPHY_TX_EDGECTRL(value uint32) {
	volatile.StoreUint32(&o.TX.Reg, volatile.LoadUint32(&o.TX.Reg)&^(0x1c000000)|value<<26)
}
func (o *USBPHY_Type) GetTX_USBPHY_TX_EDGECTRL() uint32 {
	return (volatile.LoadUint32(&o.TX.Reg) & 0x1c000000) >> 26
}
func (o *USBPHY_Type) SetTX_RSVD5(value uint32) {
	volatile.StoreUint32(&o.TX.Reg, volatile.LoadUint32(&o.TX.Reg)&^(0xe0000000)|value<<29)
}
func (o *USBPHY_Type) GetTX_RSVD5() uint32 {
	return (volatile.LoadUint32(&o.TX.Reg) & 0xe0000000) >> 29
}

// USBPHY.TX_SET: USB PHY Transmitter Control Register
func (o *USBPHY_Type) SetTX_SET_D_CAL(value uint32) {
	volatile.StoreUint32(&o.TX_SET.Reg, volatile.LoadUint32(&o.TX_SET.Reg)&^(0xf)|value)
}
func (o *USBPHY_Type) GetTX_SET_D_CAL() uint32 {
	return volatile.LoadUint32(&o.TX_SET.Reg) & 0xf
}
func (o *USBPHY_Type) SetTX_SET_RSVD0(value uint32) {
	volatile.StoreUint32(&o.TX_SET.Reg, volatile.LoadUint32(&o.TX_SET.Reg)&^(0xf0)|value<<4)
}
func (o *USBPHY_Type) GetTX_SET_RSVD0() uint32 {
	return (volatile.LoadUint32(&o.TX_SET.Reg) & 0xf0) >> 4
}
func (o *USBPHY_Type) SetTX_SET_TXCAL45DN(value uint32) {
	volatile.StoreUint32(&o.TX_SET.Reg, volatile.LoadUint32(&o.TX_SET.Reg)&^(0xf00)|value<<8)
}
func (o *USBPHY_Type) GetTX_SET_TXCAL45DN() uint32 {
	return (volatile.LoadUint32(&o.TX_SET.Reg) & 0xf00) >> 8
}
func (o *USBPHY_Type) SetTX_SET_RSVD1(value uint32) {
	volatile.StoreUint32(&o.TX_SET.Reg, volatile.LoadUint32(&o.TX_SET.Reg)&^(0xf000)|value<<12)
}
func (o *USBPHY_Type) GetTX_SET_RSVD1() uint32 {
	return (volatile.LoadUint32(&o.TX_SET.Reg) & 0xf000) >> 12
}
func (o *USBPHY_Type) SetTX_SET_TXCAL45DP(value uint32) {
	volatile.StoreUint32(&o.TX_SET.Reg, volatile.LoadUint32(&o.TX_SET.Reg)&^(0xf0000)|value<<16)
}
func (o *USBPHY_Type) GetTX_SET_TXCAL45DP() uint32 {
	return (volatile.LoadUint32(&o.TX_SET.Reg) & 0xf0000) >> 16
}
func (o *USBPHY_Type) SetTX_SET_RSVD2(value uint32) {
	volatile.StoreUint32(&o.TX_SET.Reg, volatile.LoadUint32(&o.TX_SET.Reg)&^(0x3f00000)|value<<20)
}
func (o *USBPHY_Type) GetTX_SET_RSVD2() uint32 {
	return (volatile.LoadUint32(&o.TX_SET.Reg) & 0x3f00000) >> 20
}
func (o *USBPHY_Type) SetTX_SET_USBPHY_TX_EDGECTRL(value uint32) {
	volatile.StoreUint32(&o.TX_SET.Reg, volatile.LoadUint32(&o.TX_SET.Reg)&^(0x1c000000)|value<<26)
}
func (o *USBPHY_Type) GetTX_SET_USBPHY_TX_EDGECTRL() uint32 {
	return (volatile.LoadUint32(&o.TX_SET.Reg) & 0x1c000000) >> 26
}
func (o *USBPHY_Type) SetTX_SET_RSVD5(value uint32) {
	volatile.StoreUint32(&o.TX_SET.Reg, volatile.LoadUint32(&o.TX_SET.Reg)&^(0xe0000000)|value<<29)
}
func (o *USBPHY_Type) GetTX_SET_RSVD5() uint32 {
	return (volatile.LoadUint32(&o.TX_SET.Reg) & 0xe0000000) >> 29
}

// USBPHY.TX_CLR: USB PHY Transmitter Control Register
func (o *USBPHY_Type) SetTX_CLR_D_CAL(value uint32) {
	volatile.StoreUint32(&o.TX_CLR.Reg, volatile.LoadUint32(&o.TX_CLR.Reg)&^(0xf)|value)
}
func (o *USBPHY_Type) GetTX_CLR_D_CAL() uint32 {
	return volatile.LoadUint32(&o.TX_CLR.Reg) & 0xf
}
func (o *USBPHY_Type) SetTX_CLR_RSVD0(value uint32) {
	volatile.StoreUint32(&o.TX_CLR.Reg, volatile.LoadUint32(&o.TX_CLR.Reg)&^(0xf0)|value<<4)
}
func (o *USBPHY_Type) GetTX_CLR_RSVD0() uint32 {
	return (volatile.LoadUint32(&o.TX_CLR.Reg) & 0xf0) >> 4
}
func (o *USBPHY_Type) SetTX_CLR_TXCAL45DN(value uint32) {
	volatile.StoreUint32(&o.TX_CLR.Reg, volatile.LoadUint32(&o.TX_CLR.Reg)&^(0xf00)|value<<8)
}
func (o *USBPHY_Type) GetTX_CLR_TXCAL45DN() uint32 {
	return (volatile.LoadUint32(&o.TX_CLR.Reg) & 0xf00) >> 8
}
func (o *USBPHY_Type) SetTX_CLR_RSVD1(value uint32) {
	volatile.StoreUint32(&o.TX_CLR.Reg, volatile.LoadUint32(&o.TX_CLR.Reg)&^(0xf000)|value<<12)
}
func (o *USBPHY_Type) GetTX_CLR_RSVD1() uint32 {
	return (volatile.LoadUint32(&o.TX_CLR.Reg) & 0xf000) >> 12
}
func (o *USBPHY_Type) SetTX_CLR_TXCAL45DP(value uint32) {
	volatile.StoreUint32(&o.TX_CLR.Reg, volatile.LoadUint32(&o.TX_CLR.Reg)&^(0xf0000)|value<<16)
}
func (o *USBPHY_Type) GetTX_CLR_TXCAL45DP() uint32 {
	return (volatile.LoadUint32(&o.TX_CLR.Reg) & 0xf0000) >> 16
}
func (o *USBPHY_Type) SetTX_CLR_RSVD2(value uint32) {
	volatile.StoreUint32(&o.TX_CLR.Reg, volatile.LoadUint32(&o.TX_CLR.Reg)&^(0x3f00000)|value<<20)
}
func (o *USBPHY_Type) GetTX_CLR_RSVD2() uint32 {
	return (volatile.LoadUint32(&o.TX_CLR.Reg) & 0x3f00000) >> 20
}
func (o *USBPHY_Type) SetTX_CLR_USBPHY_TX_EDGECTRL(value uint32) {
	volatile.StoreUint32(&o.TX_CLR.Reg, volatile.LoadUint32(&o.TX_CLR.Reg)&^(0x1c000000)|value<<26)
}
func (o *USBPHY_Type) GetTX_CLR_USBPHY_TX_EDGECTRL() uint32 {
	return (volatile.LoadUint32(&o.TX_CLR.Reg) & 0x1c000000) >> 26
}
func (o *USBPHY_Type) SetTX_CLR_RSVD5(value uint32) {
	volatile.StoreUint32(&o.TX_CLR.Reg, volatile.LoadUint32(&o.TX_CLR.Reg)&^(0xe0000000)|value<<29)
}
func (o *USBPHY_Type) GetTX_CLR_RSVD5() uint32 {
	return (volatile.LoadUint32(&o.TX_CLR.Reg) & 0xe0000000) >> 29
}

// USBPHY.TX_TOG: USB PHY Transmitter Control Register
func (o *USBPHY_Type) SetTX_TOG_D_CAL(value uint32) {
	volatile.StoreUint32(&o.TX_TOG.Reg, volatile.LoadUint32(&o.TX_TOG.Reg)&^(0xf)|value)
}
func (o *USBPHY_Type) GetTX_TOG_D_CAL() uint32 {
	return volatile.LoadUint32(&o.TX_TOG.Reg) & 0xf
}
func (o *USBPHY_Type) SetTX_TOG_RSVD0(value uint32) {
	volatile.StoreUint32(&o.TX_TOG.Reg, volatile.LoadUint32(&o.TX_TOG.Reg)&^(0xf0)|value<<4)
}
func (o *USBPHY_Type) GetTX_TOG_RSVD0() uint32 {
	return (volatile.LoadUint32(&o.TX_TOG.Reg) & 0xf0) >> 4
}
func (o *USBPHY_Type) SetTX_TOG_TXCAL45DN(value uint32) {
	volatile.StoreUint32(&o.TX_TOG.Reg, volatile.LoadUint32(&o.TX_TOG.Reg)&^(0xf00)|value<<8)
}
func (o *USBPHY_Type) GetTX_TOG_TXCAL45DN() uint32 {
	return (volatile.LoadUint32(&o.TX_TOG.Reg) & 0xf00) >> 8
}
func (o *USBPHY_Type) SetTX_TOG_RSVD1(value uint32) {
	volatile.StoreUint32(&o.TX_TOG.Reg, volatile.LoadUint32(&o.TX_TOG.Reg)&^(0xf000)|value<<12)
}
func (o *USBPHY_Type) GetTX_TOG_RSVD1() uint32 {
	return (volatile.LoadUint32(&o.TX_TOG.Reg) & 0xf000) >> 12
}
func (o *USBPHY_Type) SetTX_TOG_TXCAL45DP(value uint32) {
	volatile.StoreUint32(&o.TX_TOG.Reg, volatile.LoadUint32(&o.TX_TOG.Reg)&^(0xf0000)|value<<16)
}
func (o *USBPHY_Type) GetTX_TOG_TXCAL45DP() uint32 {
	return (volatile.LoadUint32(&o.TX_TOG.Reg) & 0xf0000) >> 16
}
func (o *USBPHY_Type) SetTX_TOG_RSVD2(value uint32) {
	volatile.StoreUint32(&o.TX_TOG.Reg, volatile.LoadUint32(&o.TX_TOG.Reg)&^(0x3f00000)|value<<20)
}
func (o *USBPHY_Type) GetTX_TOG_RSVD2() uint32 {
	return (volatile.LoadUint32(&o.TX_TOG.Reg) & 0x3f00000) >> 20
}
func (o *USBPHY_Type) SetTX_TOG_USBPHY_TX_EDGECTRL(value uint32) {
	volatile.StoreUint32(&o.TX_TOG.Reg, volatile.LoadUint32(&o.TX_TOG.Reg)&^(0x1c000000)|value<<26)
}
func (o *USBPHY_Type) GetTX_TOG_USBPHY_TX_EDGECTRL() uint32 {
	return (volatile.LoadUint32(&o.TX_TOG.Reg) & 0x1c000000) >> 26
}
func (o *USBPHY_Type) SetTX_TOG_RSVD5(value uint32) {
	volatile.StoreUint32(&o.TX_TOG.Reg, volatile.LoadUint32(&o.TX_TOG.Reg)&^(0xe0000000)|value<<29)
}
func (o *USBPHY_Type) GetTX_TOG_RSVD5() uint32 {
	return (volatile.LoadUint32(&o.TX_TOG.Reg) & 0xe0000000) >> 29
}

// USBPHY.RX: USB PHY Receiver Control Register
func (o *USBPHY_Type) SetRX_ENVADJ(value uint32) {
	volatile.StoreUint32(&o.RX.Reg, volatile.LoadUint32(&o.RX.Reg)&^(0x7)|value)
}
func (o *USBPHY_Type) GetRX_ENVADJ() uint32 {
	return volatile.LoadUint32(&o.RX.Reg) & 0x7
}
func (o *USBPHY_Type) SetRX_RSVD0(value uint32) {
	volatile.StoreUint32(&o.RX.Reg, volatile.LoadUint32(&o.RX.Reg)&^(0x8)|value<<3)
}
func (o *USBPHY_Type) GetRX_RSVD0() uint32 {
	return (volatile.LoadUint32(&o.RX.Reg) & 0x8) >> 3
}
func (o *USBPHY_Type) SetRX_DISCONADJ(value uint32) {
	volatile.StoreUint32(&o.RX.Reg, volatile.LoadUint32(&o.RX.Reg)&^(0x70)|value<<4)
}
func (o *USBPHY_Type) GetRX_DISCONADJ() uint32 {
	return (volatile.LoadUint32(&o.RX.Reg) & 0x70) >> 4
}
func (o *USBPHY_Type) SetRX_RSVD1(value uint32) {
	volatile.StoreUint32(&o.RX.Reg, volatile.LoadUint32(&o.RX.Reg)&^(0x3fff80)|value<<7)
}
func (o *USBPHY_Type) GetRX_RSVD1() uint32 {
	return (volatile.LoadUint32(&o.RX.Reg) & 0x3fff80) >> 7
}
func (o *USBPHY_Type) SetRX_RXDBYPASS(value uint32) {
	volatile.StoreUint32(&o.RX.Reg, volatile.LoadUint32(&o.RX.Reg)&^(0x400000)|value<<22)
}
func (o *USBPHY_Type) GetRX_RXDBYPASS() uint32 {
	return (volatile.LoadUint32(&o.RX.Reg) & 0x400000) >> 22
}
func (o *USBPHY_Type) SetRX_RSVD2(value uint32) {
	volatile.StoreUint32(&o.RX.Reg, volatile.LoadUint32(&o.RX.Reg)&^(0xff800000)|value<<23)
}
func (o *USBPHY_Type) GetRX_RSVD2() uint32 {
	return (volatile.LoadUint32(&o.RX.Reg) & 0xff800000) >> 23
}

// USBPHY.RX_SET: USB PHY Receiver Control Register
func (o *USBPHY_Type) SetRX_SET_ENVADJ(value uint32) {
	volatile.StoreUint32(&o.RX_SET.Reg, volatile.LoadUint32(&o.RX_SET.Reg)&^(0x7)|value)
}
func (o *USBPHY_Type) GetRX_SET_ENVADJ() uint32 {
	return volatile.LoadUint32(&o.RX_SET.Reg) & 0x7
}
func (o *USBPHY_Type) SetRX_SET_RSVD0(value uint32) {
	volatile.StoreUint32(&o.RX_SET.Reg, volatile.LoadUint32(&o.RX_SET.Reg)&^(0x8)|value<<3)
}
func (o *USBPHY_Type) GetRX_SET_RSVD0() uint32 {
	return (volatile.LoadUint32(&o.RX_SET.Reg) & 0x8) >> 3
}
func (o *USBPHY_Type) SetRX_SET_DISCONADJ(value uint32) {
	volatile.StoreUint32(&o.RX_SET.Reg, volatile.LoadUint32(&o.RX_SET.Reg)&^(0x70)|value<<4)
}
func (o *USBPHY_Type) GetRX_SET_DISCONADJ() uint32 {
	return (volatile.LoadUint32(&o.RX_SET.Reg) & 0x70) >> 4
}
func (o *USBPHY_Type) SetRX_SET_RSVD1(value uint32) {
	volatile.StoreUint32(&o.RX_SET.Reg, volatile.LoadUint32(&o.RX_SET.Reg)&^(0x3fff80)|value<<7)
}
func (o *USBPHY_Type) GetRX_SET_RSVD1() uint32 {
	return (volatile.LoadUint32(&o.RX_SET.Reg) & 0x3fff80) >> 7
}
func (o *USBPHY_Type) SetRX_SET_RXDBYPASS(value uint32) {
	volatile.StoreUint32(&o.RX_SET.Reg, volatile.LoadUint32(&o.RX_SET.Reg)&^(0x400000)|value<<22)
}
func (o *USBPHY_Type) GetRX_SET_RXDBYPASS() uint32 {
	return (volatile.LoadUint32(&o.RX_SET.Reg) & 0x400000) >> 22
}
func (o *USBPHY_Type) SetRX_SET_RSVD2(value uint32) {
	volatile.StoreUint32(&o.RX_SET.Reg, volatile.LoadUint32(&o.RX_SET.Reg)&^(0xff800000)|value<<23)
}
func (o *USBPHY_Type) GetRX_SET_RSVD2() uint32 {
	return (volatile.LoadUint32(&o.RX_SET.Reg) & 0xff800000) >> 23
}

// USBPHY.RX_CLR: USB PHY Receiver Control Register
func (o *USBPHY_Type) SetRX_CLR_ENVADJ(value uint32) {
	volatile.StoreUint32(&o.RX_CLR.Reg, volatile.LoadUint32(&o.RX_CLR.Reg)&^(0x7)|value)
}
func (o *USBPHY_Type) GetRX_CLR_ENVADJ() uint32 {
	return volatile.LoadUint32(&o.RX_CLR.Reg) & 0x7
}
func (o *USBPHY_Type) SetRX_CLR_RSVD0(value uint32) {
	volatile.StoreUint32(&o.RX_CLR.Reg, volatile.LoadUint32(&o.RX_CLR.Reg)&^(0x8)|value<<3)
}
func (o *USBPHY_Type) GetRX_CLR_RSVD0() uint32 {
	return (volatile.LoadUint32(&o.RX_CLR.Reg) & 0x8) >> 3
}
func (o *USBPHY_Type) SetRX_CLR_DISCONADJ(value uint32) {
	volatile.StoreUint32(&o.RX_CLR.Reg, volatile.LoadUint32(&o.RX_CLR.Reg)&^(0x70)|value<<4)
}
func (o *USBPHY_Type) GetRX_CLR_DISCONADJ() uint32 {
	return (volatile.LoadUint32(&o.RX_CLR.Reg) & 0x70) >> 4
}
func (o *USBPHY_Type) SetRX_CLR_RSVD1(value uint32) {
	volatile.StoreUint32(&o.RX_CLR.Reg, volatile.LoadUint32(&o.RX_CLR.Reg)&^(0x3fff80)|value<<7)
}
func (o *USBPHY_Type) GetRX_CLR_RSVD1() uint32 {
	return (volatile.LoadUint32(&o.RX_CLR.Reg) & 0x3fff80) >> 7
}
func (o *USBPHY_Type) SetRX_CLR_RXDBYPASS(value uint32) {
	volatile.StoreUint32(&o.RX_CLR.Reg, volatile.LoadUint32(&o.RX_CLR.Reg)&^(0x400000)|value<<22)
}
func (o *USBPHY_Type) GetRX_CLR_RXDBYPASS() uint32 {
	return (volatile.LoadUint32(&o.RX_CLR.Reg) & 0x400000) >> 22
}
func (o *USBPHY_Type) SetRX_CLR_RSVD2(value uint32) {
	volatile.StoreUint32(&o.RX_CLR.Reg, volatile.LoadUint32(&o.RX_CLR.Reg)&^(0xff800000)|value<<23)
}
func (o *USBPHY_Type) GetRX_CLR_RSVD2() uint32 {
	return (volatile.LoadUint32(&o.RX_CLR.Reg) & 0xff800000) >> 23
}

// USBPHY.RX_TOG: USB PHY Receiver Control Register
func (o *USBPHY_Type) SetRX_TOG_ENVADJ(value uint32) {
	volatile.StoreUint32(&o.RX_TOG.Reg, volatile.LoadUint32(&o.RX_TOG.Reg)&^(0x7)|value)
}
func (o *USBPHY_Type) GetRX_TOG_ENVADJ() uint32 {
	return volatile.LoadUint32(&o.RX_TOG.Reg) & 0x7
}
func (o *USBPHY_Type) SetRX_TOG_RSVD0(value uint32) {
	volatile.StoreUint32(&o.RX_TOG.Reg, volatile.LoadUint32(&o.RX_TOG.Reg)&^(0x8)|value<<3)
}
func (o *USBPHY_Type) GetRX_TOG_RSVD0() uint32 {
	return (volatile.LoadUint32(&o.RX_TOG.Reg) & 0x8) >> 3
}
func (o *USBPHY_Type) SetRX_TOG_DISCONADJ(value uint32) {
	volatile.StoreUint32(&o.RX_TOG.Reg, volatile.LoadUint32(&o.RX_TOG.Reg)&^(0x70)|value<<4)
}
func (o *USBPHY_Type) GetRX_TOG_DISCONADJ() uint32 {
	return (volatile.LoadUint32(&o.RX_TOG.Reg) & 0x70) >> 4
}
func (o *USBPHY_Type) SetRX_TOG_RSVD1(value uint32) {
	volatile.StoreUint32(&o.RX_TOG.Reg, volatile.LoadUint32(&o.RX_TOG.Reg)&^(0x3fff80)|value<<7)
}
func (o *USBPHY_Type) GetRX_TOG_RSVD1() uint32 {
	return (volatile.LoadUint32(&o.RX_TOG.Reg) & 0x3fff80) >> 7
}
func (o *USBPHY_Type) SetRX_TOG_RXDBYPASS(value uint32) {
	volatile.StoreUint32(&o.RX_TOG.Reg, volatile.LoadUint32(&o.RX_TOG.Reg)&^(0x400000)|value<<22)
}
func (o *USBPHY_Type) GetRX_TOG_RXDBYPASS() uint32 {
	return (volatile.LoadUint32(&o.RX_TOG.Reg) & 0x400000) >> 22
}
func (o *USBPHY_Type) SetRX_TOG_RSVD2(value uint32) {
	volatile.StoreUint32(&o.RX_TOG.Reg, volatile.LoadUint32(&o.RX_TOG.Reg)&^(0xff800000)|value<<23)
}
func (o *USBPHY_Type) GetRX_TOG_RSVD2() uint32 {
	return (volatile.LoadUint32(&o.RX_TOG.Reg) & 0xff800000) >> 23
}

// USBPHY.CTRL: USB PHY General Control Register
func (o *USBPHY_Type) SetCTRL_ENOTG_ID_CHG_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *USBPHY_Type) GetCTRL_ENOTG_ID_CHG_IRQ() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *USBPHY_Type) SetCTRL_ENHOSTDISCONDETECT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetCTRL_ENHOSTDISCONDETECT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetCTRL_ENIRQHOSTDISCON(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *USBPHY_Type) GetCTRL_ENIRQHOSTDISCON() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}
func (o *USBPHY_Type) SetCTRL_HOSTDISCONDETECT_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8)|value<<3)
}
func (o *USBPHY_Type) GetCTRL_HOSTDISCONDETECT_IRQ() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8) >> 3
}
func (o *USBPHY_Type) SetCTRL_ENDEVPLUGINDETECT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10)|value<<4)
}
func (o *USBPHY_Type) GetCTRL_ENDEVPLUGINDETECT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10) >> 4
}
func (o *USBPHY_Type) SetCTRL_DEVPLUGIN_POLARITY(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20)|value<<5)
}
func (o *USBPHY_Type) GetCTRL_DEVPLUGIN_POLARITY() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20) >> 5
}
func (o *USBPHY_Type) SetCTRL_OTG_ID_CHG_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40)|value<<6)
}
func (o *USBPHY_Type) GetCTRL_OTG_ID_CHG_IRQ() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40) >> 6
}
func (o *USBPHY_Type) SetCTRL_ENOTGIDDETECT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80)|value<<7)
}
func (o *USBPHY_Type) GetCTRL_ENOTGIDDETECT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80) >> 7
}
func (o *USBPHY_Type) SetCTRL_RESUMEIRQSTICKY(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x100)|value<<8)
}
func (o *USBPHY_Type) GetCTRL_RESUMEIRQSTICKY() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x100) >> 8
}
func (o *USBPHY_Type) SetCTRL_ENIRQRESUMEDETECT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x200)|value<<9)
}
func (o *USBPHY_Type) GetCTRL_ENIRQRESUMEDETECT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x200) >> 9
}
func (o *USBPHY_Type) SetCTRL_RESUME_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x400)|value<<10)
}
func (o *USBPHY_Type) GetCTRL_RESUME_IRQ() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x400) >> 10
}
func (o *USBPHY_Type) SetCTRL_ENIRQDEVPLUGIN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x800)|value<<11)
}
func (o *USBPHY_Type) GetCTRL_ENIRQDEVPLUGIN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x800) >> 11
}
func (o *USBPHY_Type) SetCTRL_DEVPLUGIN_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1000)|value<<12)
}
func (o *USBPHY_Type) GetCTRL_DEVPLUGIN_IRQ() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x1000) >> 12
}
func (o *USBPHY_Type) SetCTRL_DATA_ON_LRADC(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2000)|value<<13)
}
func (o *USBPHY_Type) GetCTRL_DATA_ON_LRADC() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2000) >> 13
}
func (o *USBPHY_Type) SetCTRL_ENUTMILEVEL2(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *USBPHY_Type) GetCTRL_ENUTMILEVEL2() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4000) >> 14
}
func (o *USBPHY_Type) SetCTRL_ENUTMILEVEL3(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8000)|value<<15)
}
func (o *USBPHY_Type) GetCTRL_ENUTMILEVEL3() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8000) >> 15
}
func (o *USBPHY_Type) SetCTRL_ENIRQWAKEUP(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *USBPHY_Type) GetCTRL_ENIRQWAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10000) >> 16
}
func (o *USBPHY_Type) SetCTRL_WAKEUP_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20000)|value<<17)
}
func (o *USBPHY_Type) GetCTRL_WAKEUP_IRQ() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20000) >> 17
}
func (o *USBPHY_Type) SetCTRL_ENAUTO_PWRON_PLL(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40000)|value<<18)
}
func (o *USBPHY_Type) GetCTRL_ENAUTO_PWRON_PLL() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40000) >> 18
}
func (o *USBPHY_Type) SetCTRL_ENAUTOCLR_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80000)|value<<19)
}
func (o *USBPHY_Type) GetCTRL_ENAUTOCLR_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80000) >> 19
}
func (o *USBPHY_Type) SetCTRL_ENAUTOCLR_PHY_PWD(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *USBPHY_Type) GetCTRL_ENAUTOCLR_PHY_PWD() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x100000) >> 20
}
func (o *USBPHY_Type) SetCTRL_ENDPDMCHG_WKUP(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x200000)|value<<21)
}
func (o *USBPHY_Type) GetCTRL_ENDPDMCHG_WKUP() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x200000) >> 21
}
func (o *USBPHY_Type) SetCTRL_ENIDCHG_WKUP(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x400000)|value<<22)
}
func (o *USBPHY_Type) GetCTRL_ENIDCHG_WKUP() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x400000) >> 22
}
func (o *USBPHY_Type) SetCTRL_ENVBUSCHG_WKUP(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x800000)|value<<23)
}
func (o *USBPHY_Type) GetCTRL_ENVBUSCHG_WKUP() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x800000) >> 23
}
func (o *USBPHY_Type) SetCTRL_FSDLL_RST_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *USBPHY_Type) GetCTRL_FSDLL_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x1000000) >> 24
}
func (o *USBPHY_Type) SetCTRL_RSVD1(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x6000000)|value<<25)
}
func (o *USBPHY_Type) GetCTRL_RSVD1() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x6000000) >> 25
}
func (o *USBPHY_Type) SetCTRL_OTG_ID_VALUE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8000000)|value<<27)
}
func (o *USBPHY_Type) GetCTRL_OTG_ID_VALUE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8000000) >> 27
}
func (o *USBPHY_Type) SetCTRL_HOST_FORCE_LS_SE0(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10000000)|value<<28)
}
func (o *USBPHY_Type) GetCTRL_HOST_FORCE_LS_SE0() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10000000) >> 28
}
func (o *USBPHY_Type) SetCTRL_UTMI_SUSPENDM(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *USBPHY_Type) GetCTRL_UTMI_SUSPENDM() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20000000) >> 29
}
func (o *USBPHY_Type) SetCTRL_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *USBPHY_Type) GetCTRL_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40000000) >> 30
}
func (o *USBPHY_Type) SetCTRL_SFTRST(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *USBPHY_Type) GetCTRL_SFTRST() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80000000) >> 31
}

// USBPHY.CTRL_SET: USB PHY General Control Register
func (o *USBPHY_Type) SetCTRL_SET_ENOTG_ID_CHG_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x1)|value)
}
func (o *USBPHY_Type) GetCTRL_SET_ENOTG_ID_CHG_IRQ() uint32 {
	return volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x1
}
func (o *USBPHY_Type) SetCTRL_SET_ENHOSTDISCONDETECT(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetCTRL_SET_ENHOSTDISCONDETECT() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetCTRL_SET_ENIRQHOSTDISCON(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x4)|value<<2)
}
func (o *USBPHY_Type) GetCTRL_SET_ENIRQHOSTDISCON() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x4) >> 2
}
func (o *USBPHY_Type) SetCTRL_SET_HOSTDISCONDETECT_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x8)|value<<3)
}
func (o *USBPHY_Type) GetCTRL_SET_HOSTDISCONDETECT_IRQ() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x8) >> 3
}
func (o *USBPHY_Type) SetCTRL_SET_ENDEVPLUGINDETECT(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x10)|value<<4)
}
func (o *USBPHY_Type) GetCTRL_SET_ENDEVPLUGINDETECT() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x10) >> 4
}
func (o *USBPHY_Type) SetCTRL_SET_DEVPLUGIN_POLARITY(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x20)|value<<5)
}
func (o *USBPHY_Type) GetCTRL_SET_DEVPLUGIN_POLARITY() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x20) >> 5
}
func (o *USBPHY_Type) SetCTRL_SET_OTG_ID_CHG_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x40)|value<<6)
}
func (o *USBPHY_Type) GetCTRL_SET_OTG_ID_CHG_IRQ() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x40) >> 6
}
func (o *USBPHY_Type) SetCTRL_SET_ENOTGIDDETECT(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x80)|value<<7)
}
func (o *USBPHY_Type) GetCTRL_SET_ENOTGIDDETECT() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x80) >> 7
}
func (o *USBPHY_Type) SetCTRL_SET_RESUMEIRQSTICKY(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x100)|value<<8)
}
func (o *USBPHY_Type) GetCTRL_SET_RESUMEIRQSTICKY() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x100) >> 8
}
func (o *USBPHY_Type) SetCTRL_SET_ENIRQRESUMEDETECT(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x200)|value<<9)
}
func (o *USBPHY_Type) GetCTRL_SET_ENIRQRESUMEDETECT() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x200) >> 9
}
func (o *USBPHY_Type) SetCTRL_SET_RESUME_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x400)|value<<10)
}
func (o *USBPHY_Type) GetCTRL_SET_RESUME_IRQ() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x400) >> 10
}
func (o *USBPHY_Type) SetCTRL_SET_ENIRQDEVPLUGIN(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x800)|value<<11)
}
func (o *USBPHY_Type) GetCTRL_SET_ENIRQDEVPLUGIN() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x800) >> 11
}
func (o *USBPHY_Type) SetCTRL_SET_DEVPLUGIN_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x1000)|value<<12)
}
func (o *USBPHY_Type) GetCTRL_SET_DEVPLUGIN_IRQ() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x1000) >> 12
}
func (o *USBPHY_Type) SetCTRL_SET_DATA_ON_LRADC(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x2000)|value<<13)
}
func (o *USBPHY_Type) GetCTRL_SET_DATA_ON_LRADC() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x2000) >> 13
}
func (o *USBPHY_Type) SetCTRL_SET_ENUTMILEVEL2(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x4000)|value<<14)
}
func (o *USBPHY_Type) GetCTRL_SET_ENUTMILEVEL2() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x4000) >> 14
}
func (o *USBPHY_Type) SetCTRL_SET_ENUTMILEVEL3(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x8000)|value<<15)
}
func (o *USBPHY_Type) GetCTRL_SET_ENUTMILEVEL3() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x8000) >> 15
}
func (o *USBPHY_Type) SetCTRL_SET_ENIRQWAKEUP(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x10000)|value<<16)
}
func (o *USBPHY_Type) GetCTRL_SET_ENIRQWAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x10000) >> 16
}
func (o *USBPHY_Type) SetCTRL_SET_WAKEUP_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x20000)|value<<17)
}
func (o *USBPHY_Type) GetCTRL_SET_WAKEUP_IRQ() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x20000) >> 17
}
func (o *USBPHY_Type) SetCTRL_SET_ENAUTO_PWRON_PLL(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x40000)|value<<18)
}
func (o *USBPHY_Type) GetCTRL_SET_ENAUTO_PWRON_PLL() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x40000) >> 18
}
func (o *USBPHY_Type) SetCTRL_SET_ENAUTOCLR_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x80000)|value<<19)
}
func (o *USBPHY_Type) GetCTRL_SET_ENAUTOCLR_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x80000) >> 19
}
func (o *USBPHY_Type) SetCTRL_SET_ENAUTOCLR_PHY_PWD(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x100000)|value<<20)
}
func (o *USBPHY_Type) GetCTRL_SET_ENAUTOCLR_PHY_PWD() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x100000) >> 20
}
func (o *USBPHY_Type) SetCTRL_SET_ENDPDMCHG_WKUP(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x200000)|value<<21)
}
func (o *USBPHY_Type) GetCTRL_SET_ENDPDMCHG_WKUP() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x200000) >> 21
}
func (o *USBPHY_Type) SetCTRL_SET_ENIDCHG_WKUP(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x400000)|value<<22)
}
func (o *USBPHY_Type) GetCTRL_SET_ENIDCHG_WKUP() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x400000) >> 22
}
func (o *USBPHY_Type) SetCTRL_SET_ENVBUSCHG_WKUP(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x800000)|value<<23)
}
func (o *USBPHY_Type) GetCTRL_SET_ENVBUSCHG_WKUP() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x800000) >> 23
}
func (o *USBPHY_Type) SetCTRL_SET_FSDLL_RST_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x1000000)|value<<24)
}
func (o *USBPHY_Type) GetCTRL_SET_FSDLL_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x1000000) >> 24
}
func (o *USBPHY_Type) SetCTRL_SET_RSVD1(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x6000000)|value<<25)
}
func (o *USBPHY_Type) GetCTRL_SET_RSVD1() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x6000000) >> 25
}
func (o *USBPHY_Type) SetCTRL_SET_OTG_ID_VALUE(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x8000000)|value<<27)
}
func (o *USBPHY_Type) GetCTRL_SET_OTG_ID_VALUE() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x8000000) >> 27
}
func (o *USBPHY_Type) SetCTRL_SET_HOST_FORCE_LS_SE0(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x10000000)|value<<28)
}
func (o *USBPHY_Type) GetCTRL_SET_HOST_FORCE_LS_SE0() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x10000000) >> 28
}
func (o *USBPHY_Type) SetCTRL_SET_UTMI_SUSPENDM(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x20000000)|value<<29)
}
func (o *USBPHY_Type) GetCTRL_SET_UTMI_SUSPENDM() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x20000000) >> 29
}
func (o *USBPHY_Type) SetCTRL_SET_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x40000000)|value<<30)
}
func (o *USBPHY_Type) GetCTRL_SET_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x40000000) >> 30
}
func (o *USBPHY_Type) SetCTRL_SET_SFTRST(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x80000000)|value<<31)
}
func (o *USBPHY_Type) GetCTRL_SET_SFTRST() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x80000000) >> 31
}

// USBPHY.CTRL_CLR: USB PHY General Control Register
func (o *USBPHY_Type) SetCTRL_CLR_ENOTG_ID_CHG_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x1)|value)
}
func (o *USBPHY_Type) GetCTRL_CLR_ENOTG_ID_CHG_IRQ() uint32 {
	return volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x1
}
func (o *USBPHY_Type) SetCTRL_CLR_ENHOSTDISCONDETECT(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetCTRL_CLR_ENHOSTDISCONDETECT() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetCTRL_CLR_ENIRQHOSTDISCON(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x4)|value<<2)
}
func (o *USBPHY_Type) GetCTRL_CLR_ENIRQHOSTDISCON() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x4) >> 2
}
func (o *USBPHY_Type) SetCTRL_CLR_HOSTDISCONDETECT_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x8)|value<<3)
}
func (o *USBPHY_Type) GetCTRL_CLR_HOSTDISCONDETECT_IRQ() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x8) >> 3
}
func (o *USBPHY_Type) SetCTRL_CLR_ENDEVPLUGINDETECT(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x10)|value<<4)
}
func (o *USBPHY_Type) GetCTRL_CLR_ENDEVPLUGINDETECT() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x10) >> 4
}
func (o *USBPHY_Type) SetCTRL_CLR_DEVPLUGIN_POLARITY(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x20)|value<<5)
}
func (o *USBPHY_Type) GetCTRL_CLR_DEVPLUGIN_POLARITY() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x20) >> 5
}
func (o *USBPHY_Type) SetCTRL_CLR_OTG_ID_CHG_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x40)|value<<6)
}
func (o *USBPHY_Type) GetCTRL_CLR_OTG_ID_CHG_IRQ() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x40) >> 6
}
func (o *USBPHY_Type) SetCTRL_CLR_ENOTGIDDETECT(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x80)|value<<7)
}
func (o *USBPHY_Type) GetCTRL_CLR_ENOTGIDDETECT() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x80) >> 7
}
func (o *USBPHY_Type) SetCTRL_CLR_RESUMEIRQSTICKY(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x100)|value<<8)
}
func (o *USBPHY_Type) GetCTRL_CLR_RESUMEIRQSTICKY() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x100) >> 8
}
func (o *USBPHY_Type) SetCTRL_CLR_ENIRQRESUMEDETECT(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x200)|value<<9)
}
func (o *USBPHY_Type) GetCTRL_CLR_ENIRQRESUMEDETECT() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x200) >> 9
}
func (o *USBPHY_Type) SetCTRL_CLR_RESUME_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x400)|value<<10)
}
func (o *USBPHY_Type) GetCTRL_CLR_RESUME_IRQ() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x400) >> 10
}
func (o *USBPHY_Type) SetCTRL_CLR_ENIRQDEVPLUGIN(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x800)|value<<11)
}
func (o *USBPHY_Type) GetCTRL_CLR_ENIRQDEVPLUGIN() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x800) >> 11
}
func (o *USBPHY_Type) SetCTRL_CLR_DEVPLUGIN_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *USBPHY_Type) GetCTRL_CLR_DEVPLUGIN_IRQ() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x1000) >> 12
}
func (o *USBPHY_Type) SetCTRL_CLR_DATA_ON_LRADC(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x2000)|value<<13)
}
func (o *USBPHY_Type) GetCTRL_CLR_DATA_ON_LRADC() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x2000) >> 13
}
func (o *USBPHY_Type) SetCTRL_CLR_ENUTMILEVEL2(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x4000)|value<<14)
}
func (o *USBPHY_Type) GetCTRL_CLR_ENUTMILEVEL2() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x4000) >> 14
}
func (o *USBPHY_Type) SetCTRL_CLR_ENUTMILEVEL3(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x8000)|value<<15)
}
func (o *USBPHY_Type) GetCTRL_CLR_ENUTMILEVEL3() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x8000) >> 15
}
func (o *USBPHY_Type) SetCTRL_CLR_ENIRQWAKEUP(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *USBPHY_Type) GetCTRL_CLR_ENIRQWAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x10000) >> 16
}
func (o *USBPHY_Type) SetCTRL_CLR_WAKEUP_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x20000)|value<<17)
}
func (o *USBPHY_Type) GetCTRL_CLR_WAKEUP_IRQ() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x20000) >> 17
}
func (o *USBPHY_Type) SetCTRL_CLR_ENAUTO_PWRON_PLL(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x40000)|value<<18)
}
func (o *USBPHY_Type) GetCTRL_CLR_ENAUTO_PWRON_PLL() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x40000) >> 18
}
func (o *USBPHY_Type) SetCTRL_CLR_ENAUTOCLR_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x80000)|value<<19)
}
func (o *USBPHY_Type) GetCTRL_CLR_ENAUTOCLR_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x80000) >> 19
}
func (o *USBPHY_Type) SetCTRL_CLR_ENAUTOCLR_PHY_PWD(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x100000)|value<<20)
}
func (o *USBPHY_Type) GetCTRL_CLR_ENAUTOCLR_PHY_PWD() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x100000) >> 20
}
func (o *USBPHY_Type) SetCTRL_CLR_ENDPDMCHG_WKUP(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x200000)|value<<21)
}
func (o *USBPHY_Type) GetCTRL_CLR_ENDPDMCHG_WKUP() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x200000) >> 21
}
func (o *USBPHY_Type) SetCTRL_CLR_ENIDCHG_WKUP(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x400000)|value<<22)
}
func (o *USBPHY_Type) GetCTRL_CLR_ENIDCHG_WKUP() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x400000) >> 22
}
func (o *USBPHY_Type) SetCTRL_CLR_ENVBUSCHG_WKUP(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x800000)|value<<23)
}
func (o *USBPHY_Type) GetCTRL_CLR_ENVBUSCHG_WKUP() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x800000) >> 23
}
func (o *USBPHY_Type) SetCTRL_CLR_FSDLL_RST_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x1000000)|value<<24)
}
func (o *USBPHY_Type) GetCTRL_CLR_FSDLL_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x1000000) >> 24
}
func (o *USBPHY_Type) SetCTRL_CLR_RSVD1(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x6000000)|value<<25)
}
func (o *USBPHY_Type) GetCTRL_CLR_RSVD1() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x6000000) >> 25
}
func (o *USBPHY_Type) SetCTRL_CLR_OTG_ID_VALUE(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x8000000)|value<<27)
}
func (o *USBPHY_Type) GetCTRL_CLR_OTG_ID_VALUE() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x8000000) >> 27
}
func (o *USBPHY_Type) SetCTRL_CLR_HOST_FORCE_LS_SE0(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x10000000)|value<<28)
}
func (o *USBPHY_Type) GetCTRL_CLR_HOST_FORCE_LS_SE0() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x10000000) >> 28
}
func (o *USBPHY_Type) SetCTRL_CLR_UTMI_SUSPENDM(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x20000000)|value<<29)
}
func (o *USBPHY_Type) GetCTRL_CLR_UTMI_SUSPENDM() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x20000000) >> 29
}
func (o *USBPHY_Type) SetCTRL_CLR_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x40000000)|value<<30)
}
func (o *USBPHY_Type) GetCTRL_CLR_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x40000000) >> 30
}
func (o *USBPHY_Type) SetCTRL_CLR_SFTRST(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *USBPHY_Type) GetCTRL_CLR_SFTRST() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x80000000) >> 31
}

// USBPHY.CTRL_TOG: USB PHY General Control Register
func (o *USBPHY_Type) SetCTRL_TOG_ENOTG_ID_CHG_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x1)|value)
}
func (o *USBPHY_Type) GetCTRL_TOG_ENOTG_ID_CHG_IRQ() uint32 {
	return volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x1
}
func (o *USBPHY_Type) SetCTRL_TOG_ENHOSTDISCONDETECT(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetCTRL_TOG_ENHOSTDISCONDETECT() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetCTRL_TOG_ENIRQHOSTDISCON(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x4)|value<<2)
}
func (o *USBPHY_Type) GetCTRL_TOG_ENIRQHOSTDISCON() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x4) >> 2
}
func (o *USBPHY_Type) SetCTRL_TOG_HOSTDISCONDETECT_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x8)|value<<3)
}
func (o *USBPHY_Type) GetCTRL_TOG_HOSTDISCONDETECT_IRQ() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x8) >> 3
}
func (o *USBPHY_Type) SetCTRL_TOG_ENDEVPLUGINDETECT(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x10)|value<<4)
}
func (o *USBPHY_Type) GetCTRL_TOG_ENDEVPLUGINDETECT() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x10) >> 4
}
func (o *USBPHY_Type) SetCTRL_TOG_DEVPLUGIN_POLARITY(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x20)|value<<5)
}
func (o *USBPHY_Type) GetCTRL_TOG_DEVPLUGIN_POLARITY() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x20) >> 5
}
func (o *USBPHY_Type) SetCTRL_TOG_OTG_ID_CHG_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x40)|value<<6)
}
func (o *USBPHY_Type) GetCTRL_TOG_OTG_ID_CHG_IRQ() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x40) >> 6
}
func (o *USBPHY_Type) SetCTRL_TOG_ENOTGIDDETECT(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x80)|value<<7)
}
func (o *USBPHY_Type) GetCTRL_TOG_ENOTGIDDETECT() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x80) >> 7
}
func (o *USBPHY_Type) SetCTRL_TOG_RESUMEIRQSTICKY(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x100)|value<<8)
}
func (o *USBPHY_Type) GetCTRL_TOG_RESUMEIRQSTICKY() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x100) >> 8
}
func (o *USBPHY_Type) SetCTRL_TOG_ENIRQRESUMEDETECT(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x200)|value<<9)
}
func (o *USBPHY_Type) GetCTRL_TOG_ENIRQRESUMEDETECT() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x200) >> 9
}
func (o *USBPHY_Type) SetCTRL_TOG_RESUME_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x400)|value<<10)
}
func (o *USBPHY_Type) GetCTRL_TOG_RESUME_IRQ() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x400) >> 10
}
func (o *USBPHY_Type) SetCTRL_TOG_ENIRQDEVPLUGIN(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x800)|value<<11)
}
func (o *USBPHY_Type) GetCTRL_TOG_ENIRQDEVPLUGIN() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x800) >> 11
}
func (o *USBPHY_Type) SetCTRL_TOG_DEVPLUGIN_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x1000)|value<<12)
}
func (o *USBPHY_Type) GetCTRL_TOG_DEVPLUGIN_IRQ() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x1000) >> 12
}
func (o *USBPHY_Type) SetCTRL_TOG_DATA_ON_LRADC(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x2000)|value<<13)
}
func (o *USBPHY_Type) GetCTRL_TOG_DATA_ON_LRADC() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x2000) >> 13
}
func (o *USBPHY_Type) SetCTRL_TOG_ENUTMILEVEL2(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x4000)|value<<14)
}
func (o *USBPHY_Type) GetCTRL_TOG_ENUTMILEVEL2() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x4000) >> 14
}
func (o *USBPHY_Type) SetCTRL_TOG_ENUTMILEVEL3(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x8000)|value<<15)
}
func (o *USBPHY_Type) GetCTRL_TOG_ENUTMILEVEL3() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x8000) >> 15
}
func (o *USBPHY_Type) SetCTRL_TOG_ENIRQWAKEUP(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x10000)|value<<16)
}
func (o *USBPHY_Type) GetCTRL_TOG_ENIRQWAKEUP() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x10000) >> 16
}
func (o *USBPHY_Type) SetCTRL_TOG_WAKEUP_IRQ(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x20000)|value<<17)
}
func (o *USBPHY_Type) GetCTRL_TOG_WAKEUP_IRQ() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x20000) >> 17
}
func (o *USBPHY_Type) SetCTRL_TOG_ENAUTO_PWRON_PLL(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x40000)|value<<18)
}
func (o *USBPHY_Type) GetCTRL_TOG_ENAUTO_PWRON_PLL() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x40000) >> 18
}
func (o *USBPHY_Type) SetCTRL_TOG_ENAUTOCLR_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x80000)|value<<19)
}
func (o *USBPHY_Type) GetCTRL_TOG_ENAUTOCLR_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x80000) >> 19
}
func (o *USBPHY_Type) SetCTRL_TOG_ENAUTOCLR_PHY_PWD(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x100000)|value<<20)
}
func (o *USBPHY_Type) GetCTRL_TOG_ENAUTOCLR_PHY_PWD() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x100000) >> 20
}
func (o *USBPHY_Type) SetCTRL_TOG_ENDPDMCHG_WKUP(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x200000)|value<<21)
}
func (o *USBPHY_Type) GetCTRL_TOG_ENDPDMCHG_WKUP() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x200000) >> 21
}
func (o *USBPHY_Type) SetCTRL_TOG_ENIDCHG_WKUP(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x400000)|value<<22)
}
func (o *USBPHY_Type) GetCTRL_TOG_ENIDCHG_WKUP() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x400000) >> 22
}
func (o *USBPHY_Type) SetCTRL_TOG_ENVBUSCHG_WKUP(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x800000)|value<<23)
}
func (o *USBPHY_Type) GetCTRL_TOG_ENVBUSCHG_WKUP() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x800000) >> 23
}
func (o *USBPHY_Type) SetCTRL_TOG_FSDLL_RST_EN(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x1000000)|value<<24)
}
func (o *USBPHY_Type) GetCTRL_TOG_FSDLL_RST_EN() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x1000000) >> 24
}
func (o *USBPHY_Type) SetCTRL_TOG_RSVD1(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x6000000)|value<<25)
}
func (o *USBPHY_Type) GetCTRL_TOG_RSVD1() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x6000000) >> 25
}
func (o *USBPHY_Type) SetCTRL_TOG_OTG_ID_VALUE(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x8000000)|value<<27)
}
func (o *USBPHY_Type) GetCTRL_TOG_OTG_ID_VALUE() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x8000000) >> 27
}
func (o *USBPHY_Type) SetCTRL_TOG_HOST_FORCE_LS_SE0(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x10000000)|value<<28)
}
func (o *USBPHY_Type) GetCTRL_TOG_HOST_FORCE_LS_SE0() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x10000000) >> 28
}
func (o *USBPHY_Type) SetCTRL_TOG_UTMI_SUSPENDM(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x20000000)|value<<29)
}
func (o *USBPHY_Type) GetCTRL_TOG_UTMI_SUSPENDM() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x20000000) >> 29
}
func (o *USBPHY_Type) SetCTRL_TOG_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x40000000)|value<<30)
}
func (o *USBPHY_Type) GetCTRL_TOG_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x40000000) >> 30
}
func (o *USBPHY_Type) SetCTRL_TOG_SFTRST(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x80000000)|value<<31)
}
func (o *USBPHY_Type) GetCTRL_TOG_SFTRST() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x80000000) >> 31
}

// USBPHY.STATUS: USB PHY Status Register
func (o *USBPHY_Type) SetSTATUS_RSVD0(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x7)|value)
}
func (o *USBPHY_Type) GetSTATUS_RSVD0() uint32 {
	return volatile.LoadUint32(&o.STATUS.Reg) & 0x7
}
func (o *USBPHY_Type) SetSTATUS_HOSTDISCONDETECT_STATUS(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x8)|value<<3)
}
func (o *USBPHY_Type) GetSTATUS_HOSTDISCONDETECT_STATUS() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x8) >> 3
}
func (o *USBPHY_Type) SetSTATUS_RSVD1(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x30)|value<<4)
}
func (o *USBPHY_Type) GetSTATUS_RSVD1() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x30) >> 4
}
func (o *USBPHY_Type) SetSTATUS_DEVPLUGIN_STATUS(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x40)|value<<6)
}
func (o *USBPHY_Type) GetSTATUS_DEVPLUGIN_STATUS() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x40) >> 6
}
func (o *USBPHY_Type) SetSTATUS_RSVD2(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x80)|value<<7)
}
func (o *USBPHY_Type) GetSTATUS_RSVD2() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x80) >> 7
}
func (o *USBPHY_Type) SetSTATUS_OTGID_STATUS(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x100)|value<<8)
}
func (o *USBPHY_Type) GetSTATUS_OTGID_STATUS() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x100) >> 8
}
func (o *USBPHY_Type) SetSTATUS_RSVD3(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x200)|value<<9)
}
func (o *USBPHY_Type) GetSTATUS_RSVD3() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x200) >> 9
}
func (o *USBPHY_Type) SetSTATUS_RESUME_STATUS(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0x400)|value<<10)
}
func (o *USBPHY_Type) GetSTATUS_RESUME_STATUS() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0x400) >> 10
}
func (o *USBPHY_Type) SetSTATUS_RSVD4(value uint32) {
	volatile.StoreUint32(&o.STATUS.Reg, volatile.LoadUint32(&o.STATUS.Reg)&^(0xfffff800)|value<<11)
}
func (o *USBPHY_Type) GetSTATUS_RSVD4() uint32 {
	return (volatile.LoadUint32(&o.STATUS.Reg) & 0xfffff800) >> 11
}

// USBPHY.DEBUG: USB PHY Debug Register
func (o *USBPHY_Type) SetDEBUG_OTGIDPIOLOCK(value uint32) {
	volatile.StoreUint32(&o.DEBUG.Reg, volatile.LoadUint32(&o.DEBUG.Reg)&^(0x1)|value)
}
func (o *USBPHY_Type) GetDEBUG_OTGIDPIOLOCK() uint32 {
	return volatile.LoadUint32(&o.DEBUG.Reg) & 0x1
}
func (o *USBPHY_Type) SetDEBUG_DEBUG_INTERFACE_HOLD(value uint32) {
	volatile.StoreUint32(&o.DEBUG.Reg, volatile.LoadUint32(&o.DEBUG.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetDEBUG_DEBUG_INTERFACE_HOLD() uint32 {
	return (volatile.LoadUint32(&o.DEBUG.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetDEBUG_HSTPULLDOWN(value uint32) {
	volatile.StoreUint32(&o.DEBUG.Reg, volatile.LoadUint32(&o.DEBUG.Reg)&^(0xc)|value<<2)
}
func (o *USBPHY_Type) GetDEBUG_HSTPULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.DEBUG.Reg) & 0xc) >> 2
}
func (o *USBPHY_Type) SetDEBUG_ENHSTPULLDOWN(value uint32) {
	volatile.StoreUint32(&o.DEBUG.Reg, volatile.LoadUint32(&o.DEBUG.Reg)&^(0x30)|value<<4)
}
func (o *USBPHY_Type) GetDEBUG_ENHSTPULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.DEBUG.Reg) & 0x30) >> 4
}
func (o *USBPHY_Type) SetDEBUG_RSVD0(value uint32) {
	volatile.StoreUint32(&o.DEBUG.Reg, volatile.LoadUint32(&o.DEBUG.Reg)&^(0xc0)|value<<6)
}
func (o *USBPHY_Type) GetDEBUG_RSVD0() uint32 {
	return (volatile.LoadUint32(&o.DEBUG.Reg) & 0xc0) >> 6
}
func (o *USBPHY_Type) SetDEBUG_TX2RXCOUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG.Reg, volatile.LoadUint32(&o.DEBUG.Reg)&^(0xf00)|value<<8)
}
func (o *USBPHY_Type) GetDEBUG_TX2RXCOUNT() uint32 {
	return (volatile.LoadUint32(&o.DEBUG.Reg) & 0xf00) >> 8
}
func (o *USBPHY_Type) SetDEBUG_ENTX2RXCOUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG.Reg, volatile.LoadUint32(&o.DEBUG.Reg)&^(0x1000)|value<<12)
}
func (o *USBPHY_Type) GetDEBUG_ENTX2RXCOUNT() uint32 {
	return (volatile.LoadUint32(&o.DEBUG.Reg) & 0x1000) >> 12
}
func (o *USBPHY_Type) SetDEBUG_RSVD1(value uint32) {
	volatile.StoreUint32(&o.DEBUG.Reg, volatile.LoadUint32(&o.DEBUG.Reg)&^(0xe000)|value<<13)
}
func (o *USBPHY_Type) GetDEBUG_RSVD1() uint32 {
	return (volatile.LoadUint32(&o.DEBUG.Reg) & 0xe000) >> 13
}
func (o *USBPHY_Type) SetDEBUG_SQUELCHRESETCOUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG.Reg, volatile.LoadUint32(&o.DEBUG.Reg)&^(0x1f0000)|value<<16)
}
func (o *USBPHY_Type) GetDEBUG_SQUELCHRESETCOUNT() uint32 {
	return (volatile.LoadUint32(&o.DEBUG.Reg) & 0x1f0000) >> 16
}
func (o *USBPHY_Type) SetDEBUG_RSVD2(value uint32) {
	volatile.StoreUint32(&o.DEBUG.Reg, volatile.LoadUint32(&o.DEBUG.Reg)&^(0xe00000)|value<<21)
}
func (o *USBPHY_Type) GetDEBUG_RSVD2() uint32 {
	return (volatile.LoadUint32(&o.DEBUG.Reg) & 0xe00000) >> 21
}
func (o *USBPHY_Type) SetDEBUG_ENSQUELCHRESET(value uint32) {
	volatile.StoreUint32(&o.DEBUG.Reg, volatile.LoadUint32(&o.DEBUG.Reg)&^(0x1000000)|value<<24)
}
func (o *USBPHY_Type) GetDEBUG_ENSQUELCHRESET() uint32 {
	return (volatile.LoadUint32(&o.DEBUG.Reg) & 0x1000000) >> 24
}
func (o *USBPHY_Type) SetDEBUG_SQUELCHRESETLENGTH(value uint32) {
	volatile.StoreUint32(&o.DEBUG.Reg, volatile.LoadUint32(&o.DEBUG.Reg)&^(0x1e000000)|value<<25)
}
func (o *USBPHY_Type) GetDEBUG_SQUELCHRESETLENGTH() uint32 {
	return (volatile.LoadUint32(&o.DEBUG.Reg) & 0x1e000000) >> 25
}
func (o *USBPHY_Type) SetDEBUG_HOST_RESUME_DEBUG(value uint32) {
	volatile.StoreUint32(&o.DEBUG.Reg, volatile.LoadUint32(&o.DEBUG.Reg)&^(0x20000000)|value<<29)
}
func (o *USBPHY_Type) GetDEBUG_HOST_RESUME_DEBUG() uint32 {
	return (volatile.LoadUint32(&o.DEBUG.Reg) & 0x20000000) >> 29
}
func (o *USBPHY_Type) SetDEBUG_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.DEBUG.Reg, volatile.LoadUint32(&o.DEBUG.Reg)&^(0x40000000)|value<<30)
}
func (o *USBPHY_Type) GetDEBUG_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.DEBUG.Reg) & 0x40000000) >> 30
}
func (o *USBPHY_Type) SetDEBUG_RSVD3(value uint32) {
	volatile.StoreUint32(&o.DEBUG.Reg, volatile.LoadUint32(&o.DEBUG.Reg)&^(0x80000000)|value<<31)
}
func (o *USBPHY_Type) GetDEBUG_RSVD3() uint32 {
	return (volatile.LoadUint32(&o.DEBUG.Reg) & 0x80000000) >> 31
}

// USBPHY.DEBUG_SET: USB PHY Debug Register
func (o *USBPHY_Type) SetDEBUG_SET_OTGIDPIOLOCK(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SET.Reg, volatile.LoadUint32(&o.DEBUG_SET.Reg)&^(0x1)|value)
}
func (o *USBPHY_Type) GetDEBUG_SET_OTGIDPIOLOCK() uint32 {
	return volatile.LoadUint32(&o.DEBUG_SET.Reg) & 0x1
}
func (o *USBPHY_Type) SetDEBUG_SET_DEBUG_INTERFACE_HOLD(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SET.Reg, volatile.LoadUint32(&o.DEBUG_SET.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetDEBUG_SET_DEBUG_INTERFACE_HOLD() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_SET.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetDEBUG_SET_HSTPULLDOWN(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SET.Reg, volatile.LoadUint32(&o.DEBUG_SET.Reg)&^(0xc)|value<<2)
}
func (o *USBPHY_Type) GetDEBUG_SET_HSTPULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_SET.Reg) & 0xc) >> 2
}
func (o *USBPHY_Type) SetDEBUG_SET_ENHSTPULLDOWN(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SET.Reg, volatile.LoadUint32(&o.DEBUG_SET.Reg)&^(0x30)|value<<4)
}
func (o *USBPHY_Type) GetDEBUG_SET_ENHSTPULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_SET.Reg) & 0x30) >> 4
}
func (o *USBPHY_Type) SetDEBUG_SET_RSVD0(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SET.Reg, volatile.LoadUint32(&o.DEBUG_SET.Reg)&^(0xc0)|value<<6)
}
func (o *USBPHY_Type) GetDEBUG_SET_RSVD0() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_SET.Reg) & 0xc0) >> 6
}
func (o *USBPHY_Type) SetDEBUG_SET_TX2RXCOUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SET.Reg, volatile.LoadUint32(&o.DEBUG_SET.Reg)&^(0xf00)|value<<8)
}
func (o *USBPHY_Type) GetDEBUG_SET_TX2RXCOUNT() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_SET.Reg) & 0xf00) >> 8
}
func (o *USBPHY_Type) SetDEBUG_SET_ENTX2RXCOUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SET.Reg, volatile.LoadUint32(&o.DEBUG_SET.Reg)&^(0x1000)|value<<12)
}
func (o *USBPHY_Type) GetDEBUG_SET_ENTX2RXCOUNT() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_SET.Reg) & 0x1000) >> 12
}
func (o *USBPHY_Type) SetDEBUG_SET_RSVD1(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SET.Reg, volatile.LoadUint32(&o.DEBUG_SET.Reg)&^(0xe000)|value<<13)
}
func (o *USBPHY_Type) GetDEBUG_SET_RSVD1() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_SET.Reg) & 0xe000) >> 13
}
func (o *USBPHY_Type) SetDEBUG_SET_SQUELCHRESETCOUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SET.Reg, volatile.LoadUint32(&o.DEBUG_SET.Reg)&^(0x1f0000)|value<<16)
}
func (o *USBPHY_Type) GetDEBUG_SET_SQUELCHRESETCOUNT() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_SET.Reg) & 0x1f0000) >> 16
}
func (o *USBPHY_Type) SetDEBUG_SET_RSVD2(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SET.Reg, volatile.LoadUint32(&o.DEBUG_SET.Reg)&^(0xe00000)|value<<21)
}
func (o *USBPHY_Type) GetDEBUG_SET_RSVD2() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_SET.Reg) & 0xe00000) >> 21
}
func (o *USBPHY_Type) SetDEBUG_SET_ENSQUELCHRESET(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SET.Reg, volatile.LoadUint32(&o.DEBUG_SET.Reg)&^(0x1000000)|value<<24)
}
func (o *USBPHY_Type) GetDEBUG_SET_ENSQUELCHRESET() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_SET.Reg) & 0x1000000) >> 24
}
func (o *USBPHY_Type) SetDEBUG_SET_SQUELCHRESETLENGTH(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SET.Reg, volatile.LoadUint32(&o.DEBUG_SET.Reg)&^(0x1e000000)|value<<25)
}
func (o *USBPHY_Type) GetDEBUG_SET_SQUELCHRESETLENGTH() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_SET.Reg) & 0x1e000000) >> 25
}
func (o *USBPHY_Type) SetDEBUG_SET_HOST_RESUME_DEBUG(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SET.Reg, volatile.LoadUint32(&o.DEBUG_SET.Reg)&^(0x20000000)|value<<29)
}
func (o *USBPHY_Type) GetDEBUG_SET_HOST_RESUME_DEBUG() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_SET.Reg) & 0x20000000) >> 29
}
func (o *USBPHY_Type) SetDEBUG_SET_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SET.Reg, volatile.LoadUint32(&o.DEBUG_SET.Reg)&^(0x40000000)|value<<30)
}
func (o *USBPHY_Type) GetDEBUG_SET_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_SET.Reg) & 0x40000000) >> 30
}
func (o *USBPHY_Type) SetDEBUG_SET_RSVD3(value uint32) {
	volatile.StoreUint32(&o.DEBUG_SET.Reg, volatile.LoadUint32(&o.DEBUG_SET.Reg)&^(0x80000000)|value<<31)
}
func (o *USBPHY_Type) GetDEBUG_SET_RSVD3() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_SET.Reg) & 0x80000000) >> 31
}

// USBPHY.DEBUG_CLR: USB PHY Debug Register
func (o *USBPHY_Type) SetDEBUG_CLR_OTGIDPIOLOCK(value uint32) {
	volatile.StoreUint32(&o.DEBUG_CLR.Reg, volatile.LoadUint32(&o.DEBUG_CLR.Reg)&^(0x1)|value)
}
func (o *USBPHY_Type) GetDEBUG_CLR_OTGIDPIOLOCK() uint32 {
	return volatile.LoadUint32(&o.DEBUG_CLR.Reg) & 0x1
}
func (o *USBPHY_Type) SetDEBUG_CLR_DEBUG_INTERFACE_HOLD(value uint32) {
	volatile.StoreUint32(&o.DEBUG_CLR.Reg, volatile.LoadUint32(&o.DEBUG_CLR.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetDEBUG_CLR_DEBUG_INTERFACE_HOLD() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_CLR.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetDEBUG_CLR_HSTPULLDOWN(value uint32) {
	volatile.StoreUint32(&o.DEBUG_CLR.Reg, volatile.LoadUint32(&o.DEBUG_CLR.Reg)&^(0xc)|value<<2)
}
func (o *USBPHY_Type) GetDEBUG_CLR_HSTPULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_CLR.Reg) & 0xc) >> 2
}
func (o *USBPHY_Type) SetDEBUG_CLR_ENHSTPULLDOWN(value uint32) {
	volatile.StoreUint32(&o.DEBUG_CLR.Reg, volatile.LoadUint32(&o.DEBUG_CLR.Reg)&^(0x30)|value<<4)
}
func (o *USBPHY_Type) GetDEBUG_CLR_ENHSTPULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_CLR.Reg) & 0x30) >> 4
}
func (o *USBPHY_Type) SetDEBUG_CLR_RSVD0(value uint32) {
	volatile.StoreUint32(&o.DEBUG_CLR.Reg, volatile.LoadUint32(&o.DEBUG_CLR.Reg)&^(0xc0)|value<<6)
}
func (o *USBPHY_Type) GetDEBUG_CLR_RSVD0() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_CLR.Reg) & 0xc0) >> 6
}
func (o *USBPHY_Type) SetDEBUG_CLR_TX2RXCOUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG_CLR.Reg, volatile.LoadUint32(&o.DEBUG_CLR.Reg)&^(0xf00)|value<<8)
}
func (o *USBPHY_Type) GetDEBUG_CLR_TX2RXCOUNT() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_CLR.Reg) & 0xf00) >> 8
}
func (o *USBPHY_Type) SetDEBUG_CLR_ENTX2RXCOUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG_CLR.Reg, volatile.LoadUint32(&o.DEBUG_CLR.Reg)&^(0x1000)|value<<12)
}
func (o *USBPHY_Type) GetDEBUG_CLR_ENTX2RXCOUNT() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_CLR.Reg) & 0x1000) >> 12
}
func (o *USBPHY_Type) SetDEBUG_CLR_RSVD1(value uint32) {
	volatile.StoreUint32(&o.DEBUG_CLR.Reg, volatile.LoadUint32(&o.DEBUG_CLR.Reg)&^(0xe000)|value<<13)
}
func (o *USBPHY_Type) GetDEBUG_CLR_RSVD1() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_CLR.Reg) & 0xe000) >> 13
}
func (o *USBPHY_Type) SetDEBUG_CLR_SQUELCHRESETCOUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG_CLR.Reg, volatile.LoadUint32(&o.DEBUG_CLR.Reg)&^(0x1f0000)|value<<16)
}
func (o *USBPHY_Type) GetDEBUG_CLR_SQUELCHRESETCOUNT() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_CLR.Reg) & 0x1f0000) >> 16
}
func (o *USBPHY_Type) SetDEBUG_CLR_RSVD2(value uint32) {
	volatile.StoreUint32(&o.DEBUG_CLR.Reg, volatile.LoadUint32(&o.DEBUG_CLR.Reg)&^(0xe00000)|value<<21)
}
func (o *USBPHY_Type) GetDEBUG_CLR_RSVD2() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_CLR.Reg) & 0xe00000) >> 21
}
func (o *USBPHY_Type) SetDEBUG_CLR_ENSQUELCHRESET(value uint32) {
	volatile.StoreUint32(&o.DEBUG_CLR.Reg, volatile.LoadUint32(&o.DEBUG_CLR.Reg)&^(0x1000000)|value<<24)
}
func (o *USBPHY_Type) GetDEBUG_CLR_ENSQUELCHRESET() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_CLR.Reg) & 0x1000000) >> 24
}
func (o *USBPHY_Type) SetDEBUG_CLR_SQUELCHRESETLENGTH(value uint32) {
	volatile.StoreUint32(&o.DEBUG_CLR.Reg, volatile.LoadUint32(&o.DEBUG_CLR.Reg)&^(0x1e000000)|value<<25)
}
func (o *USBPHY_Type) GetDEBUG_CLR_SQUELCHRESETLENGTH() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_CLR.Reg) & 0x1e000000) >> 25
}
func (o *USBPHY_Type) SetDEBUG_CLR_HOST_RESUME_DEBUG(value uint32) {
	volatile.StoreUint32(&o.DEBUG_CLR.Reg, volatile.LoadUint32(&o.DEBUG_CLR.Reg)&^(0x20000000)|value<<29)
}
func (o *USBPHY_Type) GetDEBUG_CLR_HOST_RESUME_DEBUG() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_CLR.Reg) & 0x20000000) >> 29
}
func (o *USBPHY_Type) SetDEBUG_CLR_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.DEBUG_CLR.Reg, volatile.LoadUint32(&o.DEBUG_CLR.Reg)&^(0x40000000)|value<<30)
}
func (o *USBPHY_Type) GetDEBUG_CLR_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_CLR.Reg) & 0x40000000) >> 30
}
func (o *USBPHY_Type) SetDEBUG_CLR_RSVD3(value uint32) {
	volatile.StoreUint32(&o.DEBUG_CLR.Reg, volatile.LoadUint32(&o.DEBUG_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *USBPHY_Type) GetDEBUG_CLR_RSVD3() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_CLR.Reg) & 0x80000000) >> 31
}

// USBPHY.DEBUG_TOG: USB PHY Debug Register
func (o *USBPHY_Type) SetDEBUG_TOG_OTGIDPIOLOCK(value uint32) {
	volatile.StoreUint32(&o.DEBUG_TOG.Reg, volatile.LoadUint32(&o.DEBUG_TOG.Reg)&^(0x1)|value)
}
func (o *USBPHY_Type) GetDEBUG_TOG_OTGIDPIOLOCK() uint32 {
	return volatile.LoadUint32(&o.DEBUG_TOG.Reg) & 0x1
}
func (o *USBPHY_Type) SetDEBUG_TOG_DEBUG_INTERFACE_HOLD(value uint32) {
	volatile.StoreUint32(&o.DEBUG_TOG.Reg, volatile.LoadUint32(&o.DEBUG_TOG.Reg)&^(0x2)|value<<1)
}
func (o *USBPHY_Type) GetDEBUG_TOG_DEBUG_INTERFACE_HOLD() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_TOG.Reg) & 0x2) >> 1
}
func (o *USBPHY_Type) SetDEBUG_TOG_HSTPULLDOWN(value uint32) {
	volatile.StoreUint32(&o.DEBUG_TOG.Reg, volatile.LoadUint32(&o.DEBUG_TOG.Reg)&^(0xc)|value<<2)
}
func (o *USBPHY_Type) GetDEBUG_TOG_HSTPULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_TOG.Reg) & 0xc) >> 2
}
func (o *USBPHY_Type) SetDEBUG_TOG_ENHSTPULLDOWN(value uint32) {
	volatile.StoreUint32(&o.DEBUG_TOG.Reg, volatile.LoadUint32(&o.DEBUG_TOG.Reg)&^(0x30)|value<<4)
}
func (o *USBPHY_Type) GetDEBUG_TOG_ENHSTPULLDOWN() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_TOG.Reg) & 0x30) >> 4
}
func (o *USBPHY_Type) SetDEBUG_TOG_RSVD0(value uint32) {
	volatile.StoreUint32(&o.DEBUG_TOG.Reg, volatile.LoadUint32(&o.DEBUG_TOG.Reg)&^(0xc0)|value<<6)
}
func (o *USBPHY_Type) GetDEBUG_TOG_RSVD0() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_TOG.Reg) & 0xc0) >> 6
}
func (o *USBPHY_Type) SetDEBUG_TOG_TX2RXCOUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG_TOG.Reg, volatile.LoadUint32(&o.DEBUG_TOG.Reg)&^(0xf00)|value<<8)
}
func (o *USBPHY_Type) GetDEBUG_TOG_TX2RXCOUNT() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_TOG.Reg) & 0xf00) >> 8
}
func (o *USBPHY_Type) SetDEBUG_TOG_ENTX2RXCOUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG_TOG.Reg, volatile.LoadUint32(&o.DEBUG_TOG.Reg)&^(0x1000)|value<<12)
}
func (o *USBPHY_Type) GetDEBUG_TOG_ENTX2RXCOUNT() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_TOG.Reg) & 0x1000) >> 12
}
func (o *USBPHY_Type) SetDEBUG_TOG_RSVD1(value uint32) {
	volatile.StoreUint32(&o.DEBUG_TOG.Reg, volatile.LoadUint32(&o.DEBUG_TOG.Reg)&^(0xe000)|value<<13)
}
func (o *USBPHY_Type) GetDEBUG_TOG_RSVD1() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_TOG.Reg) & 0xe000) >> 13
}
func (o *USBPHY_Type) SetDEBUG_TOG_SQUELCHRESETCOUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG_TOG.Reg, volatile.LoadUint32(&o.DEBUG_TOG.Reg)&^(0x1f0000)|value<<16)
}
func (o *USBPHY_Type) GetDEBUG_TOG_SQUELCHRESETCOUNT() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_TOG.Reg) & 0x1f0000) >> 16
}
func (o *USBPHY_Type) SetDEBUG_TOG_RSVD2(value uint32) {
	volatile.StoreUint32(&o.DEBUG_TOG.Reg, volatile.LoadUint32(&o.DEBUG_TOG.Reg)&^(0xe00000)|value<<21)
}
func (o *USBPHY_Type) GetDEBUG_TOG_RSVD2() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_TOG.Reg) & 0xe00000) >> 21
}
func (o *USBPHY_Type) SetDEBUG_TOG_ENSQUELCHRESET(value uint32) {
	volatile.StoreUint32(&o.DEBUG_TOG.Reg, volatile.LoadUint32(&o.DEBUG_TOG.Reg)&^(0x1000000)|value<<24)
}
func (o *USBPHY_Type) GetDEBUG_TOG_ENSQUELCHRESET() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_TOG.Reg) & 0x1000000) >> 24
}
func (o *USBPHY_Type) SetDEBUG_TOG_SQUELCHRESETLENGTH(value uint32) {
	volatile.StoreUint32(&o.DEBUG_TOG.Reg, volatile.LoadUint32(&o.DEBUG_TOG.Reg)&^(0x1e000000)|value<<25)
}
func (o *USBPHY_Type) GetDEBUG_TOG_SQUELCHRESETLENGTH() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_TOG.Reg) & 0x1e000000) >> 25
}
func (o *USBPHY_Type) SetDEBUG_TOG_HOST_RESUME_DEBUG(value uint32) {
	volatile.StoreUint32(&o.DEBUG_TOG.Reg, volatile.LoadUint32(&o.DEBUG_TOG.Reg)&^(0x20000000)|value<<29)
}
func (o *USBPHY_Type) GetDEBUG_TOG_HOST_RESUME_DEBUG() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_TOG.Reg) & 0x20000000) >> 29
}
func (o *USBPHY_Type) SetDEBUG_TOG_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.DEBUG_TOG.Reg, volatile.LoadUint32(&o.DEBUG_TOG.Reg)&^(0x40000000)|value<<30)
}
func (o *USBPHY_Type) GetDEBUG_TOG_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_TOG.Reg) & 0x40000000) >> 30
}
func (o *USBPHY_Type) SetDEBUG_TOG_RSVD3(value uint32) {
	volatile.StoreUint32(&o.DEBUG_TOG.Reg, volatile.LoadUint32(&o.DEBUG_TOG.Reg)&^(0x80000000)|value<<31)
}
func (o *USBPHY_Type) GetDEBUG_TOG_RSVD3() uint32 {
	return (volatile.LoadUint32(&o.DEBUG_TOG.Reg) & 0x80000000) >> 31
}

// USBPHY.DEBUG0_STATUS: UTMI Debug Status Register 0
func (o *USBPHY_Type) SetDEBUG0_STATUS_LOOP_BACK_FAIL_COUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG0_STATUS.Reg, volatile.LoadUint32(&o.DEBUG0_STATUS.Reg)&^(0xffff)|value)
}
func (o *USBPHY_Type) GetDEBUG0_STATUS_LOOP_BACK_FAIL_COUNT() uint32 {
	return volatile.LoadUint32(&o.DEBUG0_STATUS.Reg) & 0xffff
}
func (o *USBPHY_Type) SetDEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG0_STATUS.Reg, volatile.LoadUint32(&o.DEBUG0_STATUS.Reg)&^(0x3ff0000)|value<<16)
}
func (o *USBPHY_Type) GetDEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT() uint32 {
	return (volatile.LoadUint32(&o.DEBUG0_STATUS.Reg) & 0x3ff0000) >> 16
}
func (o *USBPHY_Type) SetDEBUG0_STATUS_SQUELCH_COUNT(value uint32) {
	volatile.StoreUint32(&o.DEBUG0_STATUS.Reg, volatile.LoadUint32(&o.DEBUG0_STATUS.Reg)&^(0xfc000000)|value<<26)
}
func (o *USBPHY_Type) GetDEBUG0_STATUS_SQUELCH_COUNT() uint32 {
	return (volatile.LoadUint32(&o.DEBUG0_STATUS.Reg) & 0xfc000000) >> 26
}

// USBPHY.DEBUG1: UTMI Debug Status Register 1
func (o *USBPHY_Type) SetDEBUG1_RSVD0(value uint32) {
	volatile.StoreUint32(&o.DEBUG1.Reg, volatile.LoadUint32(&o.DEBUG1.Reg)&^(0x1fff)|value)
}
func (o *USBPHY_Type) GetDEBUG1_RSVD0() uint32 {
	return volatile.LoadUint32(&o.DEBUG1.Reg) & 0x1fff
}
func (o *USBPHY_Type) SetDEBUG1_ENTAILADJVD(value uint32) {
	volatile.StoreUint32(&o.DEBUG1.Reg, volatile.LoadUint32(&o.DEBUG1.Reg)&^(0x6000)|value<<13)
}
func (o *USBPHY_Type) GetDEBUG1_ENTAILADJVD() uint32 {
	return (volatile.LoadUint32(&o.DEBUG1.Reg) & 0x6000) >> 13
}
func (o *USBPHY_Type) SetDEBUG1_RSVD1(value uint32) {
	volatile.StoreUint32(&o.DEBUG1.Reg, volatile.LoadUint32(&o.DEBUG1.Reg)&^(0xffff8000)|value<<15)
}
func (o *USBPHY_Type) GetDEBUG1_RSVD1() uint32 {
	return (volatile.LoadUint32(&o.DEBUG1.Reg) & 0xffff8000) >> 15
}

// USBPHY.DEBUG1_SET: UTMI Debug Status Register 1
func (o *USBPHY_Type) SetDEBUG1_SET_RSVD0(value uint32) {
	volatile.StoreUint32(&o.DEBUG1_SET.Reg, volatile.LoadUint32(&o.DEBUG1_SET.Reg)&^(0x1fff)|value)
}
func (o *USBPHY_Type) GetDEBUG1_SET_RSVD0() uint32 {
	return volatile.LoadUint32(&o.DEBUG1_SET.Reg) & 0x1fff
}
func (o *USBPHY_Type) SetDEBUG1_SET_ENTAILADJVD(value uint32) {
	volatile.StoreUint32(&o.DEBUG1_SET.Reg, volatile.LoadUint32(&o.DEBUG1_SET.Reg)&^(0x6000)|value<<13)
}
func (o *USBPHY_Type) GetDEBUG1_SET_ENTAILADJVD() uint32 {
	return (volatile.LoadUint32(&o.DEBUG1_SET.Reg) & 0x6000) >> 13
}
func (o *USBPHY_Type) SetDEBUG1_SET_RSVD1(value uint32) {
	volatile.StoreUint32(&o.DEBUG1_SET.Reg, volatile.LoadUint32(&o.DEBUG1_SET.Reg)&^(0xffff8000)|value<<15)
}
func (o *USBPHY_Type) GetDEBUG1_SET_RSVD1() uint32 {
	return (volatile.LoadUint32(&o.DEBUG1_SET.Reg) & 0xffff8000) >> 15
}

// USBPHY.DEBUG1_CLR: UTMI Debug Status Register 1
func (o *USBPHY_Type) SetDEBUG1_CLR_RSVD0(value uint32) {
	volatile.StoreUint32(&o.DEBUG1_CLR.Reg, volatile.LoadUint32(&o.DEBUG1_CLR.Reg)&^(0x1fff)|value)
}
func (o *USBPHY_Type) GetDEBUG1_CLR_RSVD0() uint32 {
	return volatile.LoadUint32(&o.DEBUG1_CLR.Reg) & 0x1fff
}
func (o *USBPHY_Type) SetDEBUG1_CLR_ENTAILADJVD(value uint32) {
	volatile.StoreUint32(&o.DEBUG1_CLR.Reg, volatile.LoadUint32(&o.DEBUG1_CLR.Reg)&^(0x6000)|value<<13)
}
func (o *USBPHY_Type) GetDEBUG1_CLR_ENTAILADJVD() uint32 {
	return (volatile.LoadUint32(&o.DEBUG1_CLR.Reg) & 0x6000) >> 13
}
func (o *USBPHY_Type) SetDEBUG1_CLR_RSVD1(value uint32) {
	volatile.StoreUint32(&o.DEBUG1_CLR.Reg, volatile.LoadUint32(&o.DEBUG1_CLR.Reg)&^(0xffff8000)|value<<15)
}
func (o *USBPHY_Type) GetDEBUG1_CLR_RSVD1() uint32 {
	return (volatile.LoadUint32(&o.DEBUG1_CLR.Reg) & 0xffff8000) >> 15
}

// USBPHY.DEBUG1_TOG: UTMI Debug Status Register 1
func (o *USBPHY_Type) SetDEBUG1_TOG_RSVD0(value uint32) {
	volatile.StoreUint32(&o.DEBUG1_TOG.Reg, volatile.LoadUint32(&o.DEBUG1_TOG.Reg)&^(0x1fff)|value)
}
func (o *USBPHY_Type) GetDEBUG1_TOG_RSVD0() uint32 {
	return volatile.LoadUint32(&o.DEBUG1_TOG.Reg) & 0x1fff
}
func (o *USBPHY_Type) SetDEBUG1_TOG_ENTAILADJVD(value uint32) {
	volatile.StoreUint32(&o.DEBUG1_TOG.Reg, volatile.LoadUint32(&o.DEBUG1_TOG.Reg)&^(0x6000)|value<<13)
}
func (o *USBPHY_Type) GetDEBUG1_TOG_ENTAILADJVD() uint32 {
	return (volatile.LoadUint32(&o.DEBUG1_TOG.Reg) & 0x6000) >> 13
}
func (o *USBPHY_Type) SetDEBUG1_TOG_RSVD1(value uint32) {
	volatile.StoreUint32(&o.DEBUG1_TOG.Reg, volatile.LoadUint32(&o.DEBUG1_TOG.Reg)&^(0xffff8000)|value<<15)
}
func (o *USBPHY_Type) GetDEBUG1_TOG_RSVD1() uint32 {
	return (volatile.LoadUint32(&o.DEBUG1_TOG.Reg) & 0xffff8000) >> 15
}

// USBPHY.VERSION: UTMI RTL Version
func (o *USBPHY_Type) SetVERSION_STEP(value uint32) {
	volatile.StoreUint32(&o.VERSION.Reg, volatile.LoadUint32(&o.VERSION.Reg)&^(0xffff)|value)
}
func (o *USBPHY_Type) GetVERSION_STEP() uint32 {
	return volatile.LoadUint32(&o.VERSION.Reg) & 0xffff
}
func (o *USBPHY_Type) SetVERSION_MINOR(value uint32) {
	volatile.StoreUint32(&o.VERSION.Reg, volatile.LoadUint32(&o.VERSION.Reg)&^(0xff0000)|value<<16)
}
func (o *USBPHY_Type) GetVERSION_MINOR() uint32 {
	return (volatile.LoadUint32(&o.VERSION.Reg) & 0xff0000) >> 16
}
func (o *USBPHY_Type) SetVERSION_MAJOR(value uint32) {
	volatile.StoreUint32(&o.VERSION.Reg, volatile.LoadUint32(&o.VERSION.Reg)&^(0xff000000)|value<<24)
}
func (o *USBPHY_Type) GetVERSION_MAJOR() uint32 {
	return (volatile.LoadUint32(&o.VERSION.Reg) & 0xff000000) >> 24
}

// CSU registers
type CSU_Type struct {
	CSL0       volatile.Register32 // 0x0
	CSL1       volatile.Register32 // 0x4
	CSL2       volatile.Register32 // 0x8
	CSL3       volatile.Register32 // 0xC
	CSL4       volatile.Register32 // 0x10
	CSL5       volatile.Register32 // 0x14
	CSL6       volatile.Register32 // 0x18
	CSL7       volatile.Register32 // 0x1C
	CSL8       volatile.Register32 // 0x20
	CSL9       volatile.Register32 // 0x24
	CSL10      volatile.Register32 // 0x28
	CSL11      volatile.Register32 // 0x2C
	CSL12      volatile.Register32 // 0x30
	CSL13      volatile.Register32 // 0x34
	CSL14      volatile.Register32 // 0x38
	CSL15      volatile.Register32 // 0x3C
	CSL16      volatile.Register32 // 0x40
	CSL17      volatile.Register32 // 0x44
	CSL18      volatile.Register32 // 0x48
	CSL19      volatile.Register32 // 0x4C
	CSL20      volatile.Register32 // 0x50
	CSL21      volatile.Register32 // 0x54
	CSL22      volatile.Register32 // 0x58
	CSL23      volatile.Register32 // 0x5C
	CSL24      volatile.Register32 // 0x60
	CSL25      volatile.Register32 // 0x64
	CSL26      volatile.Register32 // 0x68
	CSL27      volatile.Register32 // 0x6C
	CSL28      volatile.Register32 // 0x70
	CSL29      volatile.Register32 // 0x74
	CSL30      volatile.Register32 // 0x78
	CSL31      volatile.Register32 // 0x7C
	_          [384]byte
	HP0        volatile.Register32 // 0x200
	_          [20]byte
	SA         volatile.Register32 // 0x218
	_          [316]byte
	HPCONTROL0 volatile.Register32 // 0x358
}

// CSU.CSL0: Config security level register
func (o *CSU_Type) SetCSL0_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL0.Reg, volatile.LoadUint32(&o.CSL0.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL0_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL0.Reg) & 0x1
}
func (o *CSU_Type) SetCSL0_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL0.Reg, volatile.LoadUint32(&o.CSL0.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL0_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL0.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL0_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL0.Reg, volatile.LoadUint32(&o.CSL0.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL0_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL0.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL0_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL0.Reg, volatile.LoadUint32(&o.CSL0.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL0_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL0.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL0_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL0.Reg, volatile.LoadUint32(&o.CSL0.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL0_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL0.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL0_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL0.Reg, volatile.LoadUint32(&o.CSL0.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL0_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL0.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL0_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL0.Reg, volatile.LoadUint32(&o.CSL0.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL0_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL0.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL0_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL0.Reg, volatile.LoadUint32(&o.CSL0.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL0_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL0.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL0_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL0.Reg, volatile.LoadUint32(&o.CSL0.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL0_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL0.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL0_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL0.Reg, volatile.LoadUint32(&o.CSL0.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL0_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL0.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL0_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL0.Reg, volatile.LoadUint32(&o.CSL0.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL0_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL0.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL0_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL0.Reg, volatile.LoadUint32(&o.CSL0.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL0_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL0.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL0_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL0.Reg, volatile.LoadUint32(&o.CSL0.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL0_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL0.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL0_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL0.Reg, volatile.LoadUint32(&o.CSL0.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL0_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL0.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL0_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL0.Reg, volatile.LoadUint32(&o.CSL0.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL0_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL0.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL0_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL0.Reg, volatile.LoadUint32(&o.CSL0.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL0_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL0.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL0_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL0.Reg, volatile.LoadUint32(&o.CSL0.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL0_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL0.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL0_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL0.Reg, volatile.LoadUint32(&o.CSL0.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL0_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL0.Reg) & 0x1000000) >> 24
}

// CSU.CSL1: Config security level register
func (o *CSU_Type) SetCSL1_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL1.Reg, volatile.LoadUint32(&o.CSL1.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL1_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL1.Reg) & 0x1
}
func (o *CSU_Type) SetCSL1_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL1.Reg, volatile.LoadUint32(&o.CSL1.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL1_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL1.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL1_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL1.Reg, volatile.LoadUint32(&o.CSL1.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL1_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL1.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL1_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL1.Reg, volatile.LoadUint32(&o.CSL1.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL1_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL1.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL1_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL1.Reg, volatile.LoadUint32(&o.CSL1.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL1_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL1.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL1_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL1.Reg, volatile.LoadUint32(&o.CSL1.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL1_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL1.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL1_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL1.Reg, volatile.LoadUint32(&o.CSL1.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL1_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL1.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL1_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL1.Reg, volatile.LoadUint32(&o.CSL1.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL1_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL1.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL1_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL1.Reg, volatile.LoadUint32(&o.CSL1.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL1_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL1.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL1_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL1.Reg, volatile.LoadUint32(&o.CSL1.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL1_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL1.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL1_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL1.Reg, volatile.LoadUint32(&o.CSL1.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL1_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL1.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL1_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL1.Reg, volatile.LoadUint32(&o.CSL1.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL1_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL1.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL1_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL1.Reg, volatile.LoadUint32(&o.CSL1.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL1_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL1.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL1_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL1.Reg, volatile.LoadUint32(&o.CSL1.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL1_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL1.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL1_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL1.Reg, volatile.LoadUint32(&o.CSL1.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL1_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL1.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL1_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL1.Reg, volatile.LoadUint32(&o.CSL1.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL1_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL1.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL1_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL1.Reg, volatile.LoadUint32(&o.CSL1.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL1_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL1.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL1_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL1.Reg, volatile.LoadUint32(&o.CSL1.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL1_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL1.Reg) & 0x1000000) >> 24
}

// CSU.CSL2: Config security level register
func (o *CSU_Type) SetCSL2_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL2.Reg, volatile.LoadUint32(&o.CSL2.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL2_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL2.Reg) & 0x1
}
func (o *CSU_Type) SetCSL2_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL2.Reg, volatile.LoadUint32(&o.CSL2.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL2_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL2.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL2_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL2.Reg, volatile.LoadUint32(&o.CSL2.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL2_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL2.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL2_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL2.Reg, volatile.LoadUint32(&o.CSL2.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL2_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL2.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL2_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL2.Reg, volatile.LoadUint32(&o.CSL2.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL2_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL2.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL2_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL2.Reg, volatile.LoadUint32(&o.CSL2.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL2_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL2.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL2_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL2.Reg, volatile.LoadUint32(&o.CSL2.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL2_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL2.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL2_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL2.Reg, volatile.LoadUint32(&o.CSL2.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL2_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL2.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL2_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL2.Reg, volatile.LoadUint32(&o.CSL2.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL2_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL2.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL2_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL2.Reg, volatile.LoadUint32(&o.CSL2.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL2_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL2.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL2_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL2.Reg, volatile.LoadUint32(&o.CSL2.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL2_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL2.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL2_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL2.Reg, volatile.LoadUint32(&o.CSL2.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL2_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL2.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL2_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL2.Reg, volatile.LoadUint32(&o.CSL2.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL2_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL2.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL2_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL2.Reg, volatile.LoadUint32(&o.CSL2.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL2_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL2.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL2_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL2.Reg, volatile.LoadUint32(&o.CSL2.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL2_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL2.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL2_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL2.Reg, volatile.LoadUint32(&o.CSL2.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL2_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL2.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL2_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL2.Reg, volatile.LoadUint32(&o.CSL2.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL2_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL2.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL2_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL2.Reg, volatile.LoadUint32(&o.CSL2.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL2_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL2.Reg) & 0x1000000) >> 24
}

// CSU.CSL3: Config security level register
func (o *CSU_Type) SetCSL3_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL3.Reg, volatile.LoadUint32(&o.CSL3.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL3_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL3.Reg) & 0x1
}
func (o *CSU_Type) SetCSL3_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL3.Reg, volatile.LoadUint32(&o.CSL3.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL3_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL3.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL3_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL3.Reg, volatile.LoadUint32(&o.CSL3.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL3_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL3.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL3_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL3.Reg, volatile.LoadUint32(&o.CSL3.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL3_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL3.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL3_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL3.Reg, volatile.LoadUint32(&o.CSL3.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL3_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL3.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL3_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL3.Reg, volatile.LoadUint32(&o.CSL3.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL3_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL3.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL3_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL3.Reg, volatile.LoadUint32(&o.CSL3.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL3_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL3.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL3_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL3.Reg, volatile.LoadUint32(&o.CSL3.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL3_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL3.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL3_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL3.Reg, volatile.LoadUint32(&o.CSL3.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL3_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL3.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL3_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL3.Reg, volatile.LoadUint32(&o.CSL3.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL3_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL3.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL3_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL3.Reg, volatile.LoadUint32(&o.CSL3.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL3_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL3.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL3_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL3.Reg, volatile.LoadUint32(&o.CSL3.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL3_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL3.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL3_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL3.Reg, volatile.LoadUint32(&o.CSL3.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL3_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL3.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL3_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL3.Reg, volatile.LoadUint32(&o.CSL3.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL3_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL3.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL3_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL3.Reg, volatile.LoadUint32(&o.CSL3.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL3_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL3.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL3_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL3.Reg, volatile.LoadUint32(&o.CSL3.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL3_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL3.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL3_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL3.Reg, volatile.LoadUint32(&o.CSL3.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL3_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL3.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL3_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL3.Reg, volatile.LoadUint32(&o.CSL3.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL3_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL3.Reg) & 0x1000000) >> 24
}

// CSU.CSL4: Config security level register
func (o *CSU_Type) SetCSL4_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL4.Reg, volatile.LoadUint32(&o.CSL4.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL4_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL4.Reg) & 0x1
}
func (o *CSU_Type) SetCSL4_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL4.Reg, volatile.LoadUint32(&o.CSL4.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL4_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL4.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL4_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL4.Reg, volatile.LoadUint32(&o.CSL4.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL4_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL4.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL4_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL4.Reg, volatile.LoadUint32(&o.CSL4.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL4_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL4.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL4_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL4.Reg, volatile.LoadUint32(&o.CSL4.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL4_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL4.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL4_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL4.Reg, volatile.LoadUint32(&o.CSL4.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL4_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL4.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL4_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL4.Reg, volatile.LoadUint32(&o.CSL4.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL4_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL4.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL4_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL4.Reg, volatile.LoadUint32(&o.CSL4.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL4_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL4.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL4_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL4.Reg, volatile.LoadUint32(&o.CSL4.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL4_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL4.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL4_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL4.Reg, volatile.LoadUint32(&o.CSL4.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL4_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL4.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL4_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL4.Reg, volatile.LoadUint32(&o.CSL4.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL4_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL4.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL4_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL4.Reg, volatile.LoadUint32(&o.CSL4.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL4_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL4.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL4_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL4.Reg, volatile.LoadUint32(&o.CSL4.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL4_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL4.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL4_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL4.Reg, volatile.LoadUint32(&o.CSL4.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL4_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL4.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL4_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL4.Reg, volatile.LoadUint32(&o.CSL4.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL4_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL4.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL4_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL4.Reg, volatile.LoadUint32(&o.CSL4.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL4_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL4.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL4_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL4.Reg, volatile.LoadUint32(&o.CSL4.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL4_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL4.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL4_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL4.Reg, volatile.LoadUint32(&o.CSL4.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL4_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL4.Reg) & 0x1000000) >> 24
}

// CSU.CSL5: Config security level register
func (o *CSU_Type) SetCSL5_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL5.Reg, volatile.LoadUint32(&o.CSL5.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL5_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL5.Reg) & 0x1
}
func (o *CSU_Type) SetCSL5_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL5.Reg, volatile.LoadUint32(&o.CSL5.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL5_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL5.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL5_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL5.Reg, volatile.LoadUint32(&o.CSL5.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL5_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL5.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL5_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL5.Reg, volatile.LoadUint32(&o.CSL5.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL5_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL5.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL5_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL5.Reg, volatile.LoadUint32(&o.CSL5.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL5_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL5.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL5_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL5.Reg, volatile.LoadUint32(&o.CSL5.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL5_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL5.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL5_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL5.Reg, volatile.LoadUint32(&o.CSL5.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL5_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL5.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL5_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL5.Reg, volatile.LoadUint32(&o.CSL5.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL5_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL5.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL5_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL5.Reg, volatile.LoadUint32(&o.CSL5.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL5_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL5.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL5_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL5.Reg, volatile.LoadUint32(&o.CSL5.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL5_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL5.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL5_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL5.Reg, volatile.LoadUint32(&o.CSL5.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL5_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL5.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL5_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL5.Reg, volatile.LoadUint32(&o.CSL5.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL5_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL5.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL5_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL5.Reg, volatile.LoadUint32(&o.CSL5.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL5_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL5.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL5_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL5.Reg, volatile.LoadUint32(&o.CSL5.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL5_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL5.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL5_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL5.Reg, volatile.LoadUint32(&o.CSL5.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL5_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL5.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL5_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL5.Reg, volatile.LoadUint32(&o.CSL5.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL5_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL5.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL5_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL5.Reg, volatile.LoadUint32(&o.CSL5.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL5_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL5.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL5_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL5.Reg, volatile.LoadUint32(&o.CSL5.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL5_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL5.Reg) & 0x1000000) >> 24
}

// CSU.CSL6: Config security level register
func (o *CSU_Type) SetCSL6_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL6.Reg, volatile.LoadUint32(&o.CSL6.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL6_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL6.Reg) & 0x1
}
func (o *CSU_Type) SetCSL6_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL6.Reg, volatile.LoadUint32(&o.CSL6.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL6_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL6.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL6_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL6.Reg, volatile.LoadUint32(&o.CSL6.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL6_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL6.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL6_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL6.Reg, volatile.LoadUint32(&o.CSL6.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL6_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL6.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL6_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL6.Reg, volatile.LoadUint32(&o.CSL6.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL6_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL6.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL6_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL6.Reg, volatile.LoadUint32(&o.CSL6.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL6_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL6.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL6_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL6.Reg, volatile.LoadUint32(&o.CSL6.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL6_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL6.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL6_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL6.Reg, volatile.LoadUint32(&o.CSL6.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL6_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL6.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL6_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL6.Reg, volatile.LoadUint32(&o.CSL6.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL6_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL6.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL6_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL6.Reg, volatile.LoadUint32(&o.CSL6.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL6_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL6.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL6_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL6.Reg, volatile.LoadUint32(&o.CSL6.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL6_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL6.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL6_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL6.Reg, volatile.LoadUint32(&o.CSL6.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL6_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL6.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL6_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL6.Reg, volatile.LoadUint32(&o.CSL6.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL6_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL6.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL6_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL6.Reg, volatile.LoadUint32(&o.CSL6.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL6_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL6.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL6_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL6.Reg, volatile.LoadUint32(&o.CSL6.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL6_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL6.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL6_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL6.Reg, volatile.LoadUint32(&o.CSL6.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL6_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL6.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL6_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL6.Reg, volatile.LoadUint32(&o.CSL6.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL6_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL6.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL6_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL6.Reg, volatile.LoadUint32(&o.CSL6.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL6_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL6.Reg) & 0x1000000) >> 24
}

// CSU.CSL7: Config security level register
func (o *CSU_Type) SetCSL7_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL7.Reg, volatile.LoadUint32(&o.CSL7.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL7_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL7.Reg) & 0x1
}
func (o *CSU_Type) SetCSL7_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL7.Reg, volatile.LoadUint32(&o.CSL7.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL7_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL7.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL7_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL7.Reg, volatile.LoadUint32(&o.CSL7.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL7_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL7.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL7_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL7.Reg, volatile.LoadUint32(&o.CSL7.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL7_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL7.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL7_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL7.Reg, volatile.LoadUint32(&o.CSL7.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL7_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL7.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL7_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL7.Reg, volatile.LoadUint32(&o.CSL7.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL7_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL7.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL7_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL7.Reg, volatile.LoadUint32(&o.CSL7.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL7_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL7.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL7_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL7.Reg, volatile.LoadUint32(&o.CSL7.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL7_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL7.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL7_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL7.Reg, volatile.LoadUint32(&o.CSL7.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL7_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL7.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL7_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL7.Reg, volatile.LoadUint32(&o.CSL7.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL7_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL7.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL7_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL7.Reg, volatile.LoadUint32(&o.CSL7.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL7_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL7.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL7_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL7.Reg, volatile.LoadUint32(&o.CSL7.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL7_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL7.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL7_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL7.Reg, volatile.LoadUint32(&o.CSL7.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL7_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL7.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL7_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL7.Reg, volatile.LoadUint32(&o.CSL7.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL7_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL7.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL7_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL7.Reg, volatile.LoadUint32(&o.CSL7.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL7_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL7.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL7_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL7.Reg, volatile.LoadUint32(&o.CSL7.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL7_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL7.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL7_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL7.Reg, volatile.LoadUint32(&o.CSL7.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL7_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL7.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL7_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL7.Reg, volatile.LoadUint32(&o.CSL7.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL7_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL7.Reg) & 0x1000000) >> 24
}

// CSU.CSL8: Config security level register
func (o *CSU_Type) SetCSL8_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL8.Reg, volatile.LoadUint32(&o.CSL8.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL8_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL8.Reg) & 0x1
}
func (o *CSU_Type) SetCSL8_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL8.Reg, volatile.LoadUint32(&o.CSL8.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL8_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL8.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL8_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL8.Reg, volatile.LoadUint32(&o.CSL8.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL8_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL8.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL8_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL8.Reg, volatile.LoadUint32(&o.CSL8.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL8_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL8.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL8_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL8.Reg, volatile.LoadUint32(&o.CSL8.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL8_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL8.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL8_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL8.Reg, volatile.LoadUint32(&o.CSL8.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL8_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL8.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL8_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL8.Reg, volatile.LoadUint32(&o.CSL8.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL8_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL8.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL8_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL8.Reg, volatile.LoadUint32(&o.CSL8.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL8_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL8.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL8_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL8.Reg, volatile.LoadUint32(&o.CSL8.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL8_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL8.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL8_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL8.Reg, volatile.LoadUint32(&o.CSL8.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL8_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL8.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL8_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL8.Reg, volatile.LoadUint32(&o.CSL8.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL8_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL8.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL8_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL8.Reg, volatile.LoadUint32(&o.CSL8.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL8_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL8.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL8_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL8.Reg, volatile.LoadUint32(&o.CSL8.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL8_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL8.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL8_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL8.Reg, volatile.LoadUint32(&o.CSL8.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL8_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL8.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL8_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL8.Reg, volatile.LoadUint32(&o.CSL8.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL8_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL8.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL8_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL8.Reg, volatile.LoadUint32(&o.CSL8.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL8_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL8.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL8_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL8.Reg, volatile.LoadUint32(&o.CSL8.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL8_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL8.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL8_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL8.Reg, volatile.LoadUint32(&o.CSL8.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL8_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL8.Reg) & 0x1000000) >> 24
}

// CSU.CSL9: Config security level register
func (o *CSU_Type) SetCSL9_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL9.Reg, volatile.LoadUint32(&o.CSL9.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL9_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL9.Reg) & 0x1
}
func (o *CSU_Type) SetCSL9_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL9.Reg, volatile.LoadUint32(&o.CSL9.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL9_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL9.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL9_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL9.Reg, volatile.LoadUint32(&o.CSL9.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL9_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL9.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL9_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL9.Reg, volatile.LoadUint32(&o.CSL9.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL9_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL9.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL9_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL9.Reg, volatile.LoadUint32(&o.CSL9.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL9_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL9.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL9_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL9.Reg, volatile.LoadUint32(&o.CSL9.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL9_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL9.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL9_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL9.Reg, volatile.LoadUint32(&o.CSL9.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL9_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL9.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL9_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL9.Reg, volatile.LoadUint32(&o.CSL9.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL9_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL9.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL9_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL9.Reg, volatile.LoadUint32(&o.CSL9.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL9_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL9.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL9_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL9.Reg, volatile.LoadUint32(&o.CSL9.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL9_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL9.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL9_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL9.Reg, volatile.LoadUint32(&o.CSL9.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL9_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL9.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL9_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL9.Reg, volatile.LoadUint32(&o.CSL9.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL9_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL9.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL9_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL9.Reg, volatile.LoadUint32(&o.CSL9.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL9_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL9.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL9_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL9.Reg, volatile.LoadUint32(&o.CSL9.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL9_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL9.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL9_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL9.Reg, volatile.LoadUint32(&o.CSL9.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL9_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL9.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL9_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL9.Reg, volatile.LoadUint32(&o.CSL9.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL9_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL9.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL9_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL9.Reg, volatile.LoadUint32(&o.CSL9.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL9_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL9.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL9_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL9.Reg, volatile.LoadUint32(&o.CSL9.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL9_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL9.Reg) & 0x1000000) >> 24
}

// CSU.CSL10: Config security level register
func (o *CSU_Type) SetCSL10_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL10.Reg, volatile.LoadUint32(&o.CSL10.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL10_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL10.Reg) & 0x1
}
func (o *CSU_Type) SetCSL10_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL10.Reg, volatile.LoadUint32(&o.CSL10.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL10_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL10.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL10_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL10.Reg, volatile.LoadUint32(&o.CSL10.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL10_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL10.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL10_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL10.Reg, volatile.LoadUint32(&o.CSL10.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL10_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL10.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL10_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL10.Reg, volatile.LoadUint32(&o.CSL10.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL10_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL10.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL10_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL10.Reg, volatile.LoadUint32(&o.CSL10.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL10_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL10.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL10_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL10.Reg, volatile.LoadUint32(&o.CSL10.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL10_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL10.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL10_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL10.Reg, volatile.LoadUint32(&o.CSL10.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL10_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL10.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL10_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL10.Reg, volatile.LoadUint32(&o.CSL10.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL10_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL10.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL10_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL10.Reg, volatile.LoadUint32(&o.CSL10.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL10_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL10.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL10_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL10.Reg, volatile.LoadUint32(&o.CSL10.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL10_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL10.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL10_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL10.Reg, volatile.LoadUint32(&o.CSL10.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL10_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL10.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL10_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL10.Reg, volatile.LoadUint32(&o.CSL10.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL10_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL10.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL10_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL10.Reg, volatile.LoadUint32(&o.CSL10.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL10_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL10.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL10_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL10.Reg, volatile.LoadUint32(&o.CSL10.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL10_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL10.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL10_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL10.Reg, volatile.LoadUint32(&o.CSL10.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL10_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL10.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL10_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL10.Reg, volatile.LoadUint32(&o.CSL10.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL10_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL10.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL10_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL10.Reg, volatile.LoadUint32(&o.CSL10.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL10_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL10.Reg) & 0x1000000) >> 24
}

// CSU.CSL11: Config security level register
func (o *CSU_Type) SetCSL11_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL11.Reg, volatile.LoadUint32(&o.CSL11.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL11_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL11.Reg) & 0x1
}
func (o *CSU_Type) SetCSL11_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL11.Reg, volatile.LoadUint32(&o.CSL11.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL11_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL11.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL11_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL11.Reg, volatile.LoadUint32(&o.CSL11.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL11_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL11.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL11_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL11.Reg, volatile.LoadUint32(&o.CSL11.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL11_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL11.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL11_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL11.Reg, volatile.LoadUint32(&o.CSL11.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL11_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL11.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL11_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL11.Reg, volatile.LoadUint32(&o.CSL11.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL11_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL11.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL11_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL11.Reg, volatile.LoadUint32(&o.CSL11.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL11_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL11.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL11_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL11.Reg, volatile.LoadUint32(&o.CSL11.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL11_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL11.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL11_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL11.Reg, volatile.LoadUint32(&o.CSL11.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL11_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL11.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL11_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL11.Reg, volatile.LoadUint32(&o.CSL11.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL11_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL11.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL11_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL11.Reg, volatile.LoadUint32(&o.CSL11.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL11_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL11.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL11_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL11.Reg, volatile.LoadUint32(&o.CSL11.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL11_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL11.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL11_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL11.Reg, volatile.LoadUint32(&o.CSL11.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL11_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL11.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL11_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL11.Reg, volatile.LoadUint32(&o.CSL11.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL11_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL11.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL11_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL11.Reg, volatile.LoadUint32(&o.CSL11.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL11_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL11.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL11_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL11.Reg, volatile.LoadUint32(&o.CSL11.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL11_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL11.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL11_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL11.Reg, volatile.LoadUint32(&o.CSL11.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL11_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL11.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL11_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL11.Reg, volatile.LoadUint32(&o.CSL11.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL11_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL11.Reg) & 0x1000000) >> 24
}

// CSU.CSL12: Config security level register
func (o *CSU_Type) SetCSL12_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL12.Reg, volatile.LoadUint32(&o.CSL12.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL12_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL12.Reg) & 0x1
}
func (o *CSU_Type) SetCSL12_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL12.Reg, volatile.LoadUint32(&o.CSL12.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL12_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL12.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL12_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL12.Reg, volatile.LoadUint32(&o.CSL12.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL12_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL12.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL12_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL12.Reg, volatile.LoadUint32(&o.CSL12.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL12_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL12.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL12_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL12.Reg, volatile.LoadUint32(&o.CSL12.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL12_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL12.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL12_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL12.Reg, volatile.LoadUint32(&o.CSL12.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL12_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL12.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL12_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL12.Reg, volatile.LoadUint32(&o.CSL12.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL12_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL12.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL12_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL12.Reg, volatile.LoadUint32(&o.CSL12.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL12_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL12.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL12_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL12.Reg, volatile.LoadUint32(&o.CSL12.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL12_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL12.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL12_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL12.Reg, volatile.LoadUint32(&o.CSL12.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL12_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL12.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL12_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL12.Reg, volatile.LoadUint32(&o.CSL12.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL12_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL12.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL12_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL12.Reg, volatile.LoadUint32(&o.CSL12.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL12_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL12.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL12_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL12.Reg, volatile.LoadUint32(&o.CSL12.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL12_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL12.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL12_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL12.Reg, volatile.LoadUint32(&o.CSL12.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL12_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL12.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL12_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL12.Reg, volatile.LoadUint32(&o.CSL12.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL12_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL12.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL12_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL12.Reg, volatile.LoadUint32(&o.CSL12.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL12_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL12.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL12_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL12.Reg, volatile.LoadUint32(&o.CSL12.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL12_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL12.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL12_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL12.Reg, volatile.LoadUint32(&o.CSL12.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL12_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL12.Reg) & 0x1000000) >> 24
}

// CSU.CSL13: Config security level register
func (o *CSU_Type) SetCSL13_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL13.Reg, volatile.LoadUint32(&o.CSL13.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL13_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL13.Reg) & 0x1
}
func (o *CSU_Type) SetCSL13_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL13.Reg, volatile.LoadUint32(&o.CSL13.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL13_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL13.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL13_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL13.Reg, volatile.LoadUint32(&o.CSL13.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL13_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL13.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL13_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL13.Reg, volatile.LoadUint32(&o.CSL13.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL13_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL13.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL13_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL13.Reg, volatile.LoadUint32(&o.CSL13.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL13_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL13.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL13_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL13.Reg, volatile.LoadUint32(&o.CSL13.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL13_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL13.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL13_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL13.Reg, volatile.LoadUint32(&o.CSL13.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL13_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL13.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL13_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL13.Reg, volatile.LoadUint32(&o.CSL13.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL13_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL13.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL13_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL13.Reg, volatile.LoadUint32(&o.CSL13.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL13_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL13.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL13_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL13.Reg, volatile.LoadUint32(&o.CSL13.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL13_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL13.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL13_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL13.Reg, volatile.LoadUint32(&o.CSL13.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL13_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL13.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL13_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL13.Reg, volatile.LoadUint32(&o.CSL13.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL13_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL13.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL13_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL13.Reg, volatile.LoadUint32(&o.CSL13.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL13_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL13.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL13_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL13.Reg, volatile.LoadUint32(&o.CSL13.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL13_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL13.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL13_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL13.Reg, volatile.LoadUint32(&o.CSL13.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL13_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL13.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL13_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL13.Reg, volatile.LoadUint32(&o.CSL13.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL13_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL13.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL13_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL13.Reg, volatile.LoadUint32(&o.CSL13.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL13_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL13.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL13_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL13.Reg, volatile.LoadUint32(&o.CSL13.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL13_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL13.Reg) & 0x1000000) >> 24
}

// CSU.CSL14: Config security level register
func (o *CSU_Type) SetCSL14_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL14.Reg, volatile.LoadUint32(&o.CSL14.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL14_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL14.Reg) & 0x1
}
func (o *CSU_Type) SetCSL14_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL14.Reg, volatile.LoadUint32(&o.CSL14.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL14_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL14.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL14_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL14.Reg, volatile.LoadUint32(&o.CSL14.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL14_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL14.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL14_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL14.Reg, volatile.LoadUint32(&o.CSL14.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL14_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL14.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL14_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL14.Reg, volatile.LoadUint32(&o.CSL14.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL14_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL14.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL14_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL14.Reg, volatile.LoadUint32(&o.CSL14.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL14_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL14.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL14_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL14.Reg, volatile.LoadUint32(&o.CSL14.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL14_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL14.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL14_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL14.Reg, volatile.LoadUint32(&o.CSL14.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL14_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL14.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL14_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL14.Reg, volatile.LoadUint32(&o.CSL14.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL14_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL14.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL14_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL14.Reg, volatile.LoadUint32(&o.CSL14.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL14_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL14.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL14_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL14.Reg, volatile.LoadUint32(&o.CSL14.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL14_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL14.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL14_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL14.Reg, volatile.LoadUint32(&o.CSL14.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL14_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL14.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL14_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL14.Reg, volatile.LoadUint32(&o.CSL14.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL14_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL14.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL14_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL14.Reg, volatile.LoadUint32(&o.CSL14.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL14_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL14.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL14_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL14.Reg, volatile.LoadUint32(&o.CSL14.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL14_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL14.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL14_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL14.Reg, volatile.LoadUint32(&o.CSL14.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL14_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL14.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL14_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL14.Reg, volatile.LoadUint32(&o.CSL14.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL14_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL14.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL14_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL14.Reg, volatile.LoadUint32(&o.CSL14.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL14_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL14.Reg) & 0x1000000) >> 24
}

// CSU.CSL15: Config security level register
func (o *CSU_Type) SetCSL15_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL15.Reg, volatile.LoadUint32(&o.CSL15.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL15_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL15.Reg) & 0x1
}
func (o *CSU_Type) SetCSL15_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL15.Reg, volatile.LoadUint32(&o.CSL15.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL15_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL15.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL15_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL15.Reg, volatile.LoadUint32(&o.CSL15.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL15_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL15.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL15_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL15.Reg, volatile.LoadUint32(&o.CSL15.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL15_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL15.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL15_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL15.Reg, volatile.LoadUint32(&o.CSL15.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL15_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL15.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL15_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL15.Reg, volatile.LoadUint32(&o.CSL15.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL15_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL15.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL15_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL15.Reg, volatile.LoadUint32(&o.CSL15.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL15_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL15.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL15_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL15.Reg, volatile.LoadUint32(&o.CSL15.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL15_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL15.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL15_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL15.Reg, volatile.LoadUint32(&o.CSL15.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL15_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL15.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL15_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL15.Reg, volatile.LoadUint32(&o.CSL15.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL15_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL15.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL15_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL15.Reg, volatile.LoadUint32(&o.CSL15.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL15_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL15.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL15_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL15.Reg, volatile.LoadUint32(&o.CSL15.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL15_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL15.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL15_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL15.Reg, volatile.LoadUint32(&o.CSL15.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL15_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL15.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL15_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL15.Reg, volatile.LoadUint32(&o.CSL15.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL15_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL15.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL15_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL15.Reg, volatile.LoadUint32(&o.CSL15.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL15_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL15.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL15_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL15.Reg, volatile.LoadUint32(&o.CSL15.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL15_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL15.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL15_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL15.Reg, volatile.LoadUint32(&o.CSL15.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL15_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL15.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL15_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL15.Reg, volatile.LoadUint32(&o.CSL15.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL15_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL15.Reg) & 0x1000000) >> 24
}

// CSU.CSL16: Config security level register
func (o *CSU_Type) SetCSL16_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL16.Reg, volatile.LoadUint32(&o.CSL16.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL16_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL16.Reg) & 0x1
}
func (o *CSU_Type) SetCSL16_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL16.Reg, volatile.LoadUint32(&o.CSL16.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL16_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL16.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL16_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL16.Reg, volatile.LoadUint32(&o.CSL16.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL16_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL16.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL16_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL16.Reg, volatile.LoadUint32(&o.CSL16.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL16_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL16.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL16_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL16.Reg, volatile.LoadUint32(&o.CSL16.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL16_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL16.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL16_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL16.Reg, volatile.LoadUint32(&o.CSL16.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL16_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL16.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL16_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL16.Reg, volatile.LoadUint32(&o.CSL16.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL16_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL16.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL16_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL16.Reg, volatile.LoadUint32(&o.CSL16.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL16_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL16.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL16_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL16.Reg, volatile.LoadUint32(&o.CSL16.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL16_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL16.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL16_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL16.Reg, volatile.LoadUint32(&o.CSL16.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL16_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL16.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL16_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL16.Reg, volatile.LoadUint32(&o.CSL16.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL16_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL16.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL16_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL16.Reg, volatile.LoadUint32(&o.CSL16.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL16_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL16.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL16_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL16.Reg, volatile.LoadUint32(&o.CSL16.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL16_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL16.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL16_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL16.Reg, volatile.LoadUint32(&o.CSL16.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL16_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL16.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL16_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL16.Reg, volatile.LoadUint32(&o.CSL16.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL16_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL16.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL16_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL16.Reg, volatile.LoadUint32(&o.CSL16.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL16_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL16.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL16_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL16.Reg, volatile.LoadUint32(&o.CSL16.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL16_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL16.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL16_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL16.Reg, volatile.LoadUint32(&o.CSL16.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL16_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL16.Reg) & 0x1000000) >> 24
}

// CSU.CSL17: Config security level register
func (o *CSU_Type) SetCSL17_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL17.Reg, volatile.LoadUint32(&o.CSL17.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL17_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL17.Reg) & 0x1
}
func (o *CSU_Type) SetCSL17_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL17.Reg, volatile.LoadUint32(&o.CSL17.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL17_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL17.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL17_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL17.Reg, volatile.LoadUint32(&o.CSL17.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL17_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL17.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL17_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL17.Reg, volatile.LoadUint32(&o.CSL17.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL17_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL17.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL17_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL17.Reg, volatile.LoadUint32(&o.CSL17.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL17_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL17.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL17_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL17.Reg, volatile.LoadUint32(&o.CSL17.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL17_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL17.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL17_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL17.Reg, volatile.LoadUint32(&o.CSL17.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL17_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL17.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL17_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL17.Reg, volatile.LoadUint32(&o.CSL17.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL17_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL17.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL17_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL17.Reg, volatile.LoadUint32(&o.CSL17.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL17_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL17.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL17_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL17.Reg, volatile.LoadUint32(&o.CSL17.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL17_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL17.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL17_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL17.Reg, volatile.LoadUint32(&o.CSL17.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL17_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL17.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL17_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL17.Reg, volatile.LoadUint32(&o.CSL17.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL17_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL17.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL17_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL17.Reg, volatile.LoadUint32(&o.CSL17.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL17_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL17.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL17_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL17.Reg, volatile.LoadUint32(&o.CSL17.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL17_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL17.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL17_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL17.Reg, volatile.LoadUint32(&o.CSL17.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL17_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL17.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL17_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL17.Reg, volatile.LoadUint32(&o.CSL17.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL17_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL17.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL17_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL17.Reg, volatile.LoadUint32(&o.CSL17.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL17_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL17.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL17_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL17.Reg, volatile.LoadUint32(&o.CSL17.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL17_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL17.Reg) & 0x1000000) >> 24
}

// CSU.CSL18: Config security level register
func (o *CSU_Type) SetCSL18_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL18.Reg, volatile.LoadUint32(&o.CSL18.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL18_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL18.Reg) & 0x1
}
func (o *CSU_Type) SetCSL18_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL18.Reg, volatile.LoadUint32(&o.CSL18.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL18_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL18.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL18_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL18.Reg, volatile.LoadUint32(&o.CSL18.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL18_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL18.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL18_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL18.Reg, volatile.LoadUint32(&o.CSL18.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL18_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL18.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL18_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL18.Reg, volatile.LoadUint32(&o.CSL18.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL18_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL18.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL18_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL18.Reg, volatile.LoadUint32(&o.CSL18.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL18_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL18.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL18_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL18.Reg, volatile.LoadUint32(&o.CSL18.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL18_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL18.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL18_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL18.Reg, volatile.LoadUint32(&o.CSL18.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL18_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL18.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL18_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL18.Reg, volatile.LoadUint32(&o.CSL18.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL18_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL18.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL18_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL18.Reg, volatile.LoadUint32(&o.CSL18.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL18_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL18.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL18_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL18.Reg, volatile.LoadUint32(&o.CSL18.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL18_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL18.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL18_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL18.Reg, volatile.LoadUint32(&o.CSL18.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL18_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL18.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL18_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL18.Reg, volatile.LoadUint32(&o.CSL18.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL18_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL18.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL18_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL18.Reg, volatile.LoadUint32(&o.CSL18.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL18_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL18.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL18_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL18.Reg, volatile.LoadUint32(&o.CSL18.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL18_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL18.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL18_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL18.Reg, volatile.LoadUint32(&o.CSL18.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL18_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL18.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL18_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL18.Reg, volatile.LoadUint32(&o.CSL18.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL18_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL18.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL18_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL18.Reg, volatile.LoadUint32(&o.CSL18.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL18_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL18.Reg) & 0x1000000) >> 24
}

// CSU.CSL19: Config security level register
func (o *CSU_Type) SetCSL19_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL19.Reg, volatile.LoadUint32(&o.CSL19.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL19_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL19.Reg) & 0x1
}
func (o *CSU_Type) SetCSL19_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL19.Reg, volatile.LoadUint32(&o.CSL19.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL19_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL19.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL19_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL19.Reg, volatile.LoadUint32(&o.CSL19.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL19_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL19.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL19_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL19.Reg, volatile.LoadUint32(&o.CSL19.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL19_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL19.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL19_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL19.Reg, volatile.LoadUint32(&o.CSL19.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL19_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL19.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL19_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL19.Reg, volatile.LoadUint32(&o.CSL19.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL19_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL19.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL19_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL19.Reg, volatile.LoadUint32(&o.CSL19.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL19_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL19.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL19_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL19.Reg, volatile.LoadUint32(&o.CSL19.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL19_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL19.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL19_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL19.Reg, volatile.LoadUint32(&o.CSL19.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL19_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL19.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL19_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL19.Reg, volatile.LoadUint32(&o.CSL19.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL19_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL19.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL19_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL19.Reg, volatile.LoadUint32(&o.CSL19.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL19_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL19.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL19_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL19.Reg, volatile.LoadUint32(&o.CSL19.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL19_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL19.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL19_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL19.Reg, volatile.LoadUint32(&o.CSL19.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL19_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL19.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL19_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL19.Reg, volatile.LoadUint32(&o.CSL19.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL19_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL19.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL19_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL19.Reg, volatile.LoadUint32(&o.CSL19.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL19_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL19.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL19_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL19.Reg, volatile.LoadUint32(&o.CSL19.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL19_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL19.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL19_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL19.Reg, volatile.LoadUint32(&o.CSL19.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL19_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL19.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL19_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL19.Reg, volatile.LoadUint32(&o.CSL19.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL19_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL19.Reg) & 0x1000000) >> 24
}

// CSU.CSL20: Config security level register
func (o *CSU_Type) SetCSL20_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL20.Reg, volatile.LoadUint32(&o.CSL20.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL20_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL20.Reg) & 0x1
}
func (o *CSU_Type) SetCSL20_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL20.Reg, volatile.LoadUint32(&o.CSL20.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL20_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL20.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL20_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL20.Reg, volatile.LoadUint32(&o.CSL20.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL20_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL20.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL20_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL20.Reg, volatile.LoadUint32(&o.CSL20.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL20_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL20.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL20_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL20.Reg, volatile.LoadUint32(&o.CSL20.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL20_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL20.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL20_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL20.Reg, volatile.LoadUint32(&o.CSL20.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL20_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL20.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL20_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL20.Reg, volatile.LoadUint32(&o.CSL20.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL20_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL20.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL20_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL20.Reg, volatile.LoadUint32(&o.CSL20.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL20_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL20.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL20_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL20.Reg, volatile.LoadUint32(&o.CSL20.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL20_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL20.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL20_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL20.Reg, volatile.LoadUint32(&o.CSL20.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL20_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL20.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL20_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL20.Reg, volatile.LoadUint32(&o.CSL20.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL20_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL20.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL20_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL20.Reg, volatile.LoadUint32(&o.CSL20.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL20_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL20.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL20_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL20.Reg, volatile.LoadUint32(&o.CSL20.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL20_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL20.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL20_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL20.Reg, volatile.LoadUint32(&o.CSL20.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL20_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL20.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL20_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL20.Reg, volatile.LoadUint32(&o.CSL20.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL20_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL20.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL20_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL20.Reg, volatile.LoadUint32(&o.CSL20.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL20_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL20.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL20_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL20.Reg, volatile.LoadUint32(&o.CSL20.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL20_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL20.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL20_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL20.Reg, volatile.LoadUint32(&o.CSL20.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL20_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL20.Reg) & 0x1000000) >> 24
}

// CSU.CSL21: Config security level register
func (o *CSU_Type) SetCSL21_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL21.Reg, volatile.LoadUint32(&o.CSL21.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL21_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL21.Reg) & 0x1
}
func (o *CSU_Type) SetCSL21_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL21.Reg, volatile.LoadUint32(&o.CSL21.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL21_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL21.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL21_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL21.Reg, volatile.LoadUint32(&o.CSL21.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL21_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL21.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL21_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL21.Reg, volatile.LoadUint32(&o.CSL21.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL21_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL21.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL21_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL21.Reg, volatile.LoadUint32(&o.CSL21.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL21_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL21.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL21_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL21.Reg, volatile.LoadUint32(&o.CSL21.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL21_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL21.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL21_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL21.Reg, volatile.LoadUint32(&o.CSL21.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL21_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL21.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL21_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL21.Reg, volatile.LoadUint32(&o.CSL21.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL21_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL21.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL21_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL21.Reg, volatile.LoadUint32(&o.CSL21.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL21_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL21.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL21_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL21.Reg, volatile.LoadUint32(&o.CSL21.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL21_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL21.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL21_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL21.Reg, volatile.LoadUint32(&o.CSL21.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL21_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL21.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL21_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL21.Reg, volatile.LoadUint32(&o.CSL21.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL21_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL21.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL21_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL21.Reg, volatile.LoadUint32(&o.CSL21.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL21_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL21.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL21_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL21.Reg, volatile.LoadUint32(&o.CSL21.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL21_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL21.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL21_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL21.Reg, volatile.LoadUint32(&o.CSL21.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL21_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL21.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL21_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL21.Reg, volatile.LoadUint32(&o.CSL21.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL21_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL21.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL21_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL21.Reg, volatile.LoadUint32(&o.CSL21.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL21_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL21.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL21_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL21.Reg, volatile.LoadUint32(&o.CSL21.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL21_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL21.Reg) & 0x1000000) >> 24
}

// CSU.CSL22: Config security level register
func (o *CSU_Type) SetCSL22_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL22.Reg, volatile.LoadUint32(&o.CSL22.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL22_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL22.Reg) & 0x1
}
func (o *CSU_Type) SetCSL22_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL22.Reg, volatile.LoadUint32(&o.CSL22.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL22_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL22.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL22_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL22.Reg, volatile.LoadUint32(&o.CSL22.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL22_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL22.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL22_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL22.Reg, volatile.LoadUint32(&o.CSL22.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL22_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL22.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL22_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL22.Reg, volatile.LoadUint32(&o.CSL22.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL22_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL22.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL22_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL22.Reg, volatile.LoadUint32(&o.CSL22.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL22_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL22.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL22_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL22.Reg, volatile.LoadUint32(&o.CSL22.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL22_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL22.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL22_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL22.Reg, volatile.LoadUint32(&o.CSL22.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL22_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL22.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL22_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL22.Reg, volatile.LoadUint32(&o.CSL22.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL22_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL22.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL22_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL22.Reg, volatile.LoadUint32(&o.CSL22.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL22_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL22.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL22_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL22.Reg, volatile.LoadUint32(&o.CSL22.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL22_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL22.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL22_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL22.Reg, volatile.LoadUint32(&o.CSL22.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL22_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL22.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL22_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL22.Reg, volatile.LoadUint32(&o.CSL22.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL22_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL22.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL22_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL22.Reg, volatile.LoadUint32(&o.CSL22.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL22_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL22.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL22_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL22.Reg, volatile.LoadUint32(&o.CSL22.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL22_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL22.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL22_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL22.Reg, volatile.LoadUint32(&o.CSL22.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL22_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL22.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL22_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL22.Reg, volatile.LoadUint32(&o.CSL22.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL22_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL22.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL22_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL22.Reg, volatile.LoadUint32(&o.CSL22.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL22_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL22.Reg) & 0x1000000) >> 24
}

// CSU.CSL23: Config security level register
func (o *CSU_Type) SetCSL23_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL23.Reg, volatile.LoadUint32(&o.CSL23.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL23_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL23.Reg) & 0x1
}
func (o *CSU_Type) SetCSL23_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL23.Reg, volatile.LoadUint32(&o.CSL23.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL23_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL23.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL23_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL23.Reg, volatile.LoadUint32(&o.CSL23.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL23_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL23.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL23_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL23.Reg, volatile.LoadUint32(&o.CSL23.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL23_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL23.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL23_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL23.Reg, volatile.LoadUint32(&o.CSL23.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL23_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL23.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL23_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL23.Reg, volatile.LoadUint32(&o.CSL23.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL23_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL23.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL23_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL23.Reg, volatile.LoadUint32(&o.CSL23.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL23_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL23.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL23_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL23.Reg, volatile.LoadUint32(&o.CSL23.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL23_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL23.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL23_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL23.Reg, volatile.LoadUint32(&o.CSL23.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL23_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL23.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL23_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL23.Reg, volatile.LoadUint32(&o.CSL23.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL23_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL23.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL23_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL23.Reg, volatile.LoadUint32(&o.CSL23.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL23_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL23.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL23_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL23.Reg, volatile.LoadUint32(&o.CSL23.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL23_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL23.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL23_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL23.Reg, volatile.LoadUint32(&o.CSL23.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL23_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL23.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL23_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL23.Reg, volatile.LoadUint32(&o.CSL23.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL23_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL23.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL23_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL23.Reg, volatile.LoadUint32(&o.CSL23.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL23_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL23.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL23_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL23.Reg, volatile.LoadUint32(&o.CSL23.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL23_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL23.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL23_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL23.Reg, volatile.LoadUint32(&o.CSL23.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL23_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL23.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL23_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL23.Reg, volatile.LoadUint32(&o.CSL23.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL23_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL23.Reg) & 0x1000000) >> 24
}

// CSU.CSL24: Config security level register
func (o *CSU_Type) SetCSL24_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL24.Reg, volatile.LoadUint32(&o.CSL24.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL24_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL24.Reg) & 0x1
}
func (o *CSU_Type) SetCSL24_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL24.Reg, volatile.LoadUint32(&o.CSL24.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL24_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL24.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL24_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL24.Reg, volatile.LoadUint32(&o.CSL24.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL24_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL24.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL24_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL24.Reg, volatile.LoadUint32(&o.CSL24.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL24_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL24.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL24_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL24.Reg, volatile.LoadUint32(&o.CSL24.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL24_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL24.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL24_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL24.Reg, volatile.LoadUint32(&o.CSL24.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL24_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL24.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL24_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL24.Reg, volatile.LoadUint32(&o.CSL24.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL24_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL24.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL24_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL24.Reg, volatile.LoadUint32(&o.CSL24.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL24_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL24.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL24_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL24.Reg, volatile.LoadUint32(&o.CSL24.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL24_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL24.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL24_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL24.Reg, volatile.LoadUint32(&o.CSL24.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL24_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL24.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL24_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL24.Reg, volatile.LoadUint32(&o.CSL24.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL24_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL24.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL24_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL24.Reg, volatile.LoadUint32(&o.CSL24.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL24_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL24.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL24_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL24.Reg, volatile.LoadUint32(&o.CSL24.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL24_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL24.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL24_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL24.Reg, volatile.LoadUint32(&o.CSL24.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL24_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL24.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL24_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL24.Reg, volatile.LoadUint32(&o.CSL24.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL24_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL24.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL24_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL24.Reg, volatile.LoadUint32(&o.CSL24.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL24_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL24.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL24_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL24.Reg, volatile.LoadUint32(&o.CSL24.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL24_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL24.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL24_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL24.Reg, volatile.LoadUint32(&o.CSL24.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL24_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL24.Reg) & 0x1000000) >> 24
}

// CSU.CSL25: Config security level register
func (o *CSU_Type) SetCSL25_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL25.Reg, volatile.LoadUint32(&o.CSL25.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL25_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL25.Reg) & 0x1
}
func (o *CSU_Type) SetCSL25_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL25.Reg, volatile.LoadUint32(&o.CSL25.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL25_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL25.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL25_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL25.Reg, volatile.LoadUint32(&o.CSL25.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL25_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL25.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL25_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL25.Reg, volatile.LoadUint32(&o.CSL25.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL25_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL25.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL25_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL25.Reg, volatile.LoadUint32(&o.CSL25.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL25_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL25.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL25_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL25.Reg, volatile.LoadUint32(&o.CSL25.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL25_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL25.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL25_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL25.Reg, volatile.LoadUint32(&o.CSL25.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL25_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL25.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL25_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL25.Reg, volatile.LoadUint32(&o.CSL25.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL25_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL25.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL25_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL25.Reg, volatile.LoadUint32(&o.CSL25.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL25_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL25.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL25_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL25.Reg, volatile.LoadUint32(&o.CSL25.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL25_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL25.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL25_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL25.Reg, volatile.LoadUint32(&o.CSL25.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL25_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL25.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL25_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL25.Reg, volatile.LoadUint32(&o.CSL25.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL25_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL25.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL25_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL25.Reg, volatile.LoadUint32(&o.CSL25.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL25_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL25.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL25_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL25.Reg, volatile.LoadUint32(&o.CSL25.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL25_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL25.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL25_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL25.Reg, volatile.LoadUint32(&o.CSL25.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL25_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL25.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL25_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL25.Reg, volatile.LoadUint32(&o.CSL25.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL25_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL25.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL25_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL25.Reg, volatile.LoadUint32(&o.CSL25.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL25_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL25.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL25_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL25.Reg, volatile.LoadUint32(&o.CSL25.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL25_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL25.Reg) & 0x1000000) >> 24
}

// CSU.CSL26: Config security level register
func (o *CSU_Type) SetCSL26_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL26.Reg, volatile.LoadUint32(&o.CSL26.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL26_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL26.Reg) & 0x1
}
func (o *CSU_Type) SetCSL26_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL26.Reg, volatile.LoadUint32(&o.CSL26.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL26_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL26.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL26_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL26.Reg, volatile.LoadUint32(&o.CSL26.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL26_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL26.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL26_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL26.Reg, volatile.LoadUint32(&o.CSL26.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL26_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL26.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL26_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL26.Reg, volatile.LoadUint32(&o.CSL26.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL26_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL26.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL26_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL26.Reg, volatile.LoadUint32(&o.CSL26.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL26_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL26.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL26_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL26.Reg, volatile.LoadUint32(&o.CSL26.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL26_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL26.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL26_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL26.Reg, volatile.LoadUint32(&o.CSL26.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL26_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL26.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL26_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL26.Reg, volatile.LoadUint32(&o.CSL26.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL26_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL26.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL26_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL26.Reg, volatile.LoadUint32(&o.CSL26.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL26_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL26.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL26_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL26.Reg, volatile.LoadUint32(&o.CSL26.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL26_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL26.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL26_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL26.Reg, volatile.LoadUint32(&o.CSL26.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL26_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL26.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL26_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL26.Reg, volatile.LoadUint32(&o.CSL26.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL26_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL26.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL26_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL26.Reg, volatile.LoadUint32(&o.CSL26.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL26_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL26.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL26_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL26.Reg, volatile.LoadUint32(&o.CSL26.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL26_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL26.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL26_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL26.Reg, volatile.LoadUint32(&o.CSL26.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL26_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL26.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL26_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL26.Reg, volatile.LoadUint32(&o.CSL26.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL26_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL26.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL26_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL26.Reg, volatile.LoadUint32(&o.CSL26.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL26_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL26.Reg) & 0x1000000) >> 24
}

// CSU.CSL27: Config security level register
func (o *CSU_Type) SetCSL27_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL27.Reg, volatile.LoadUint32(&o.CSL27.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL27_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL27.Reg) & 0x1
}
func (o *CSU_Type) SetCSL27_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL27.Reg, volatile.LoadUint32(&o.CSL27.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL27_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL27.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL27_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL27.Reg, volatile.LoadUint32(&o.CSL27.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL27_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL27.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL27_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL27.Reg, volatile.LoadUint32(&o.CSL27.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL27_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL27.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL27_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL27.Reg, volatile.LoadUint32(&o.CSL27.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL27_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL27.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL27_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL27.Reg, volatile.LoadUint32(&o.CSL27.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL27_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL27.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL27_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL27.Reg, volatile.LoadUint32(&o.CSL27.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL27_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL27.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL27_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL27.Reg, volatile.LoadUint32(&o.CSL27.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL27_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL27.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL27_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL27.Reg, volatile.LoadUint32(&o.CSL27.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL27_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL27.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL27_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL27.Reg, volatile.LoadUint32(&o.CSL27.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL27_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL27.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL27_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL27.Reg, volatile.LoadUint32(&o.CSL27.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL27_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL27.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL27_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL27.Reg, volatile.LoadUint32(&o.CSL27.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL27_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL27.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL27_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL27.Reg, volatile.LoadUint32(&o.CSL27.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL27_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL27.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL27_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL27.Reg, volatile.LoadUint32(&o.CSL27.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL27_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL27.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL27_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL27.Reg, volatile.LoadUint32(&o.CSL27.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL27_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL27.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL27_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL27.Reg, volatile.LoadUint32(&o.CSL27.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL27_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL27.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL27_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL27.Reg, volatile.LoadUint32(&o.CSL27.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL27_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL27.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL27_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL27.Reg, volatile.LoadUint32(&o.CSL27.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL27_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL27.Reg) & 0x1000000) >> 24
}

// CSU.CSL28: Config security level register
func (o *CSU_Type) SetCSL28_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL28.Reg, volatile.LoadUint32(&o.CSL28.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL28_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL28.Reg) & 0x1
}
func (o *CSU_Type) SetCSL28_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL28.Reg, volatile.LoadUint32(&o.CSL28.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL28_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL28.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL28_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL28.Reg, volatile.LoadUint32(&o.CSL28.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL28_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL28.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL28_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL28.Reg, volatile.LoadUint32(&o.CSL28.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL28_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL28.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL28_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL28.Reg, volatile.LoadUint32(&o.CSL28.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL28_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL28.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL28_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL28.Reg, volatile.LoadUint32(&o.CSL28.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL28_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL28.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL28_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL28.Reg, volatile.LoadUint32(&o.CSL28.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL28_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL28.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL28_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL28.Reg, volatile.LoadUint32(&o.CSL28.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL28_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL28.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL28_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL28.Reg, volatile.LoadUint32(&o.CSL28.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL28_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL28.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL28_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL28.Reg, volatile.LoadUint32(&o.CSL28.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL28_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL28.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL28_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL28.Reg, volatile.LoadUint32(&o.CSL28.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL28_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL28.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL28_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL28.Reg, volatile.LoadUint32(&o.CSL28.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL28_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL28.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL28_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL28.Reg, volatile.LoadUint32(&o.CSL28.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL28_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL28.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL28_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL28.Reg, volatile.LoadUint32(&o.CSL28.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL28_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL28.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL28_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL28.Reg, volatile.LoadUint32(&o.CSL28.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL28_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL28.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL28_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL28.Reg, volatile.LoadUint32(&o.CSL28.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL28_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL28.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL28_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL28.Reg, volatile.LoadUint32(&o.CSL28.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL28_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL28.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL28_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL28.Reg, volatile.LoadUint32(&o.CSL28.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL28_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL28.Reg) & 0x1000000) >> 24
}

// CSU.CSL29: Config security level register
func (o *CSU_Type) SetCSL29_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL29.Reg, volatile.LoadUint32(&o.CSL29.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL29_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL29.Reg) & 0x1
}
func (o *CSU_Type) SetCSL29_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL29.Reg, volatile.LoadUint32(&o.CSL29.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL29_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL29.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL29_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL29.Reg, volatile.LoadUint32(&o.CSL29.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL29_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL29.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL29_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL29.Reg, volatile.LoadUint32(&o.CSL29.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL29_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL29.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL29_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL29.Reg, volatile.LoadUint32(&o.CSL29.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL29_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL29.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL29_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL29.Reg, volatile.LoadUint32(&o.CSL29.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL29_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL29.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL29_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL29.Reg, volatile.LoadUint32(&o.CSL29.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL29_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL29.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL29_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL29.Reg, volatile.LoadUint32(&o.CSL29.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL29_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL29.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL29_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL29.Reg, volatile.LoadUint32(&o.CSL29.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL29_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL29.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL29_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL29.Reg, volatile.LoadUint32(&o.CSL29.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL29_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL29.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL29_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL29.Reg, volatile.LoadUint32(&o.CSL29.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL29_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL29.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL29_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL29.Reg, volatile.LoadUint32(&o.CSL29.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL29_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL29.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL29_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL29.Reg, volatile.LoadUint32(&o.CSL29.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL29_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL29.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL29_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL29.Reg, volatile.LoadUint32(&o.CSL29.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL29_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL29.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL29_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL29.Reg, volatile.LoadUint32(&o.CSL29.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL29_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL29.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL29_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL29.Reg, volatile.LoadUint32(&o.CSL29.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL29_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL29.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL29_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL29.Reg, volatile.LoadUint32(&o.CSL29.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL29_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL29.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL29_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL29.Reg, volatile.LoadUint32(&o.CSL29.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL29_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL29.Reg) & 0x1000000) >> 24
}

// CSU.CSL30: Config security level register
func (o *CSU_Type) SetCSL30_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL30.Reg, volatile.LoadUint32(&o.CSL30.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL30_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL30.Reg) & 0x1
}
func (o *CSU_Type) SetCSL30_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL30.Reg, volatile.LoadUint32(&o.CSL30.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL30_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL30.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL30_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL30.Reg, volatile.LoadUint32(&o.CSL30.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL30_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL30.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL30_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL30.Reg, volatile.LoadUint32(&o.CSL30.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL30_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL30.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL30_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL30.Reg, volatile.LoadUint32(&o.CSL30.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL30_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL30.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL30_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL30.Reg, volatile.LoadUint32(&o.CSL30.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL30_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL30.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL30_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL30.Reg, volatile.LoadUint32(&o.CSL30.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL30_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL30.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL30_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL30.Reg, volatile.LoadUint32(&o.CSL30.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL30_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL30.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL30_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL30.Reg, volatile.LoadUint32(&o.CSL30.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL30_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL30.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL30_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL30.Reg, volatile.LoadUint32(&o.CSL30.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL30_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL30.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL30_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL30.Reg, volatile.LoadUint32(&o.CSL30.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL30_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL30.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL30_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL30.Reg, volatile.LoadUint32(&o.CSL30.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL30_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL30.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL30_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL30.Reg, volatile.LoadUint32(&o.CSL30.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL30_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL30.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL30_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL30.Reg, volatile.LoadUint32(&o.CSL30.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL30_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL30.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL30_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL30.Reg, volatile.LoadUint32(&o.CSL30.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL30_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL30.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL30_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL30.Reg, volatile.LoadUint32(&o.CSL30.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL30_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL30.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL30_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL30.Reg, volatile.LoadUint32(&o.CSL30.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL30_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL30.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL30_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL30.Reg, volatile.LoadUint32(&o.CSL30.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL30_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL30.Reg) & 0x1000000) >> 24
}

// CSU.CSL31: Config security level register
func (o *CSU_Type) SetCSL31_SUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL31.Reg, volatile.LoadUint32(&o.CSL31.Reg)&^(0x1)|value)
}
func (o *CSU_Type) GetCSL31_SUR_S2() uint32 {
	return volatile.LoadUint32(&o.CSL31.Reg) & 0x1
}
func (o *CSU_Type) SetCSL31_SSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL31.Reg, volatile.LoadUint32(&o.CSL31.Reg)&^(0x2)|value<<1)
}
func (o *CSU_Type) GetCSL31_SSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL31.Reg) & 0x2) >> 1
}
func (o *CSU_Type) SetCSL31_NUR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL31.Reg, volatile.LoadUint32(&o.CSL31.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetCSL31_NUR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL31.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetCSL31_NSR_S2(value uint32) {
	volatile.StoreUint32(&o.CSL31.Reg, volatile.LoadUint32(&o.CSL31.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetCSL31_NSR_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL31.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetCSL31_SUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL31.Reg, volatile.LoadUint32(&o.CSL31.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetCSL31_SUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL31.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetCSL31_SSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL31.Reg, volatile.LoadUint32(&o.CSL31.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetCSL31_SSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL31.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetCSL31_NUW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL31.Reg, volatile.LoadUint32(&o.CSL31.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetCSL31_NUW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL31.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetCSL31_NSW_S2(value uint32) {
	volatile.StoreUint32(&o.CSL31.Reg, volatile.LoadUint32(&o.CSL31.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetCSL31_NSW_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL31.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetCSL31_LOCK_S2(value uint32) {
	volatile.StoreUint32(&o.CSL31.Reg, volatile.LoadUint32(&o.CSL31.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetCSL31_LOCK_S2() uint32 {
	return (volatile.LoadUint32(&o.CSL31.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetCSL31_SUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL31.Reg, volatile.LoadUint32(&o.CSL31.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetCSL31_SUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL31.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetCSL31_SSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL31.Reg, volatile.LoadUint32(&o.CSL31.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetCSL31_SSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL31.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetCSL31_NUR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL31.Reg, volatile.LoadUint32(&o.CSL31.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetCSL31_NUR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL31.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetCSL31_NSR_S1(value uint32) {
	volatile.StoreUint32(&o.CSL31.Reg, volatile.LoadUint32(&o.CSL31.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetCSL31_NSR_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL31.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetCSL31_SUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL31.Reg, volatile.LoadUint32(&o.CSL31.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetCSL31_SUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL31.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetCSL31_SSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL31.Reg, volatile.LoadUint32(&o.CSL31.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetCSL31_SSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL31.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetCSL31_NUW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL31.Reg, volatile.LoadUint32(&o.CSL31.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetCSL31_NUW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL31.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetCSL31_NSW_S1(value uint32) {
	volatile.StoreUint32(&o.CSL31.Reg, volatile.LoadUint32(&o.CSL31.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetCSL31_NSW_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL31.Reg) & 0x800000) >> 23
}
func (o *CSU_Type) SetCSL31_LOCK_S1(value uint32) {
	volatile.StoreUint32(&o.CSL31.Reg, volatile.LoadUint32(&o.CSL31.Reg)&^(0x1000000)|value<<24)
}
func (o *CSU_Type) GetCSL31_LOCK_S1() uint32 {
	return (volatile.LoadUint32(&o.CSL31.Reg) & 0x1000000) >> 24
}

// CSU.HP0: HP0 register
func (o *CSU_Type) SetHP0_HP_DMA(value uint32) {
	volatile.StoreUint32(&o.HP0.Reg, volatile.LoadUint32(&o.HP0.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetHP0_HP_DMA() uint32 {
	return (volatile.LoadUint32(&o.HP0.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetHP0_L_DMA(value uint32) {
	volatile.StoreUint32(&o.HP0.Reg, volatile.LoadUint32(&o.HP0.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetHP0_L_DMA() uint32 {
	return (volatile.LoadUint32(&o.HP0.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetHP0_HP_LCDIF(value uint32) {
	volatile.StoreUint32(&o.HP0.Reg, volatile.LoadUint32(&o.HP0.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetHP0_HP_LCDIF() uint32 {
	return (volatile.LoadUint32(&o.HP0.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetHP0_L_LCDIF(value uint32) {
	volatile.StoreUint32(&o.HP0.Reg, volatile.LoadUint32(&o.HP0.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetHP0_L_LCDIF() uint32 {
	return (volatile.LoadUint32(&o.HP0.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetHP0_HP_CSI(value uint32) {
	volatile.StoreUint32(&o.HP0.Reg, volatile.LoadUint32(&o.HP0.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetHP0_HP_CSI() uint32 {
	return (volatile.LoadUint32(&o.HP0.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetHP0_L_CSI(value uint32) {
	volatile.StoreUint32(&o.HP0.Reg, volatile.LoadUint32(&o.HP0.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetHP0_L_CSI() uint32 {
	return (volatile.LoadUint32(&o.HP0.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetHP0_HP_PXP(value uint32) {
	volatile.StoreUint32(&o.HP0.Reg, volatile.LoadUint32(&o.HP0.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetHP0_HP_PXP() uint32 {
	return (volatile.LoadUint32(&o.HP0.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetHP0_L_PXP(value uint32) {
	volatile.StoreUint32(&o.HP0.Reg, volatile.LoadUint32(&o.HP0.Reg)&^(0x200)|value<<9)
}
func (o *CSU_Type) GetHP0_L_PXP() uint32 {
	return (volatile.LoadUint32(&o.HP0.Reg) & 0x200) >> 9
}
func (o *CSU_Type) SetHP0_HP_DCP(value uint32) {
	volatile.StoreUint32(&o.HP0.Reg, volatile.LoadUint32(&o.HP0.Reg)&^(0x400)|value<<10)
}
func (o *CSU_Type) GetHP0_HP_DCP() uint32 {
	return (volatile.LoadUint32(&o.HP0.Reg) & 0x400) >> 10
}
func (o *CSU_Type) SetHP0_L_DCP(value uint32) {
	volatile.StoreUint32(&o.HP0.Reg, volatile.LoadUint32(&o.HP0.Reg)&^(0x800)|value<<11)
}
func (o *CSU_Type) GetHP0_L_DCP() uint32 {
	return (volatile.LoadUint32(&o.HP0.Reg) & 0x800) >> 11
}
func (o *CSU_Type) SetHP0_HP_ENET(value uint32) {
	volatile.StoreUint32(&o.HP0.Reg, volatile.LoadUint32(&o.HP0.Reg)&^(0x4000)|value<<14)
}
func (o *CSU_Type) GetHP0_HP_ENET() uint32 {
	return (volatile.LoadUint32(&o.HP0.Reg) & 0x4000) >> 14
}
func (o *CSU_Type) SetHP0_L_ENET(value uint32) {
	volatile.StoreUint32(&o.HP0.Reg, volatile.LoadUint32(&o.HP0.Reg)&^(0x8000)|value<<15)
}
func (o *CSU_Type) GetHP0_L_ENET() uint32 {
	return (volatile.LoadUint32(&o.HP0.Reg) & 0x8000) >> 15
}
func (o *CSU_Type) SetHP0_HP_USDHC1(value uint32) {
	volatile.StoreUint32(&o.HP0.Reg, volatile.LoadUint32(&o.HP0.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetHP0_HP_USDHC1() uint32 {
	return (volatile.LoadUint32(&o.HP0.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetHP0_L_USDHC1(value uint32) {
	volatile.StoreUint32(&o.HP0.Reg, volatile.LoadUint32(&o.HP0.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetHP0_L_USDHC1() uint32 {
	return (volatile.LoadUint32(&o.HP0.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetHP0_HP_USDHC2(value uint32) {
	volatile.StoreUint32(&o.HP0.Reg, volatile.LoadUint32(&o.HP0.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetHP0_HP_USDHC2() uint32 {
	return (volatile.LoadUint32(&o.HP0.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetHP0_L_USDHC2(value uint32) {
	volatile.StoreUint32(&o.HP0.Reg, volatile.LoadUint32(&o.HP0.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetHP0_L_USDHC2() uint32 {
	return (volatile.LoadUint32(&o.HP0.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetHP0_HP_TPSMP(value uint32) {
	volatile.StoreUint32(&o.HP0.Reg, volatile.LoadUint32(&o.HP0.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetHP0_HP_TPSMP() uint32 {
	return (volatile.LoadUint32(&o.HP0.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetHP0_L_TPSMP(value uint32) {
	volatile.StoreUint32(&o.HP0.Reg, volatile.LoadUint32(&o.HP0.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetHP0_L_TPSMP() uint32 {
	return (volatile.LoadUint32(&o.HP0.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetHP0_HP_USB(value uint32) {
	volatile.StoreUint32(&o.HP0.Reg, volatile.LoadUint32(&o.HP0.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetHP0_HP_USB() uint32 {
	return (volatile.LoadUint32(&o.HP0.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetHP0_L_USB(value uint32) {
	volatile.StoreUint32(&o.HP0.Reg, volatile.LoadUint32(&o.HP0.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetHP0_L_USB() uint32 {
	return (volatile.LoadUint32(&o.HP0.Reg) & 0x800000) >> 23
}

// CSU.SA: Secure access register
func (o *CSU_Type) SetSA_NSA_DMA(value uint32) {
	volatile.StoreUint32(&o.SA.Reg, volatile.LoadUint32(&o.SA.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetSA_NSA_DMA() uint32 {
	return (volatile.LoadUint32(&o.SA.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetSA_L_DMA(value uint32) {
	volatile.StoreUint32(&o.SA.Reg, volatile.LoadUint32(&o.SA.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetSA_L_DMA() uint32 {
	return (volatile.LoadUint32(&o.SA.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetSA_NSA_LCDIF(value uint32) {
	volatile.StoreUint32(&o.SA.Reg, volatile.LoadUint32(&o.SA.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetSA_NSA_LCDIF() uint32 {
	return (volatile.LoadUint32(&o.SA.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetSA_L_LCDIF(value uint32) {
	volatile.StoreUint32(&o.SA.Reg, volatile.LoadUint32(&o.SA.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetSA_L_LCDIF() uint32 {
	return (volatile.LoadUint32(&o.SA.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetSA_NSA_CSI(value uint32) {
	volatile.StoreUint32(&o.SA.Reg, volatile.LoadUint32(&o.SA.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetSA_NSA_CSI() uint32 {
	return (volatile.LoadUint32(&o.SA.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetSA_L_CSI(value uint32) {
	volatile.StoreUint32(&o.SA.Reg, volatile.LoadUint32(&o.SA.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetSA_L_CSI() uint32 {
	return (volatile.LoadUint32(&o.SA.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetSA_NSA_PXP(value uint32) {
	volatile.StoreUint32(&o.SA.Reg, volatile.LoadUint32(&o.SA.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetSA_NSA_PXP() uint32 {
	return (volatile.LoadUint32(&o.SA.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetSA_L_PXP(value uint32) {
	volatile.StoreUint32(&o.SA.Reg, volatile.LoadUint32(&o.SA.Reg)&^(0x200)|value<<9)
}
func (o *CSU_Type) GetSA_L_PXP() uint32 {
	return (volatile.LoadUint32(&o.SA.Reg) & 0x200) >> 9
}
func (o *CSU_Type) SetSA_NSA_DCP(value uint32) {
	volatile.StoreUint32(&o.SA.Reg, volatile.LoadUint32(&o.SA.Reg)&^(0x400)|value<<10)
}
func (o *CSU_Type) GetSA_NSA_DCP() uint32 {
	return (volatile.LoadUint32(&o.SA.Reg) & 0x400) >> 10
}
func (o *CSU_Type) SetSA_L_DCP(value uint32) {
	volatile.StoreUint32(&o.SA.Reg, volatile.LoadUint32(&o.SA.Reg)&^(0x800)|value<<11)
}
func (o *CSU_Type) GetSA_L_DCP() uint32 {
	return (volatile.LoadUint32(&o.SA.Reg) & 0x800) >> 11
}
func (o *CSU_Type) SetSA_NSA_ENET(value uint32) {
	volatile.StoreUint32(&o.SA.Reg, volatile.LoadUint32(&o.SA.Reg)&^(0x4000)|value<<14)
}
func (o *CSU_Type) GetSA_NSA_ENET() uint32 {
	return (volatile.LoadUint32(&o.SA.Reg) & 0x4000) >> 14
}
func (o *CSU_Type) SetSA_L_ENET(value uint32) {
	volatile.StoreUint32(&o.SA.Reg, volatile.LoadUint32(&o.SA.Reg)&^(0x8000)|value<<15)
}
func (o *CSU_Type) GetSA_L_ENET() uint32 {
	return (volatile.LoadUint32(&o.SA.Reg) & 0x8000) >> 15
}
func (o *CSU_Type) SetSA_NSA_USDHC1(value uint32) {
	volatile.StoreUint32(&o.SA.Reg, volatile.LoadUint32(&o.SA.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetSA_NSA_USDHC1() uint32 {
	return (volatile.LoadUint32(&o.SA.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetSA_L_USDHC1(value uint32) {
	volatile.StoreUint32(&o.SA.Reg, volatile.LoadUint32(&o.SA.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetSA_L_USDHC1() uint32 {
	return (volatile.LoadUint32(&o.SA.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetSA_NSA_USDHC2(value uint32) {
	volatile.StoreUint32(&o.SA.Reg, volatile.LoadUint32(&o.SA.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetSA_NSA_USDHC2() uint32 {
	return (volatile.LoadUint32(&o.SA.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetSA_L_USDHC2(value uint32) {
	volatile.StoreUint32(&o.SA.Reg, volatile.LoadUint32(&o.SA.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetSA_L_USDHC2() uint32 {
	return (volatile.LoadUint32(&o.SA.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetSA_NSA_TPSMP(value uint32) {
	volatile.StoreUint32(&o.SA.Reg, volatile.LoadUint32(&o.SA.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetSA_NSA_TPSMP() uint32 {
	return (volatile.LoadUint32(&o.SA.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetSA_L_TPSMP(value uint32) {
	volatile.StoreUint32(&o.SA.Reg, volatile.LoadUint32(&o.SA.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetSA_L_TPSMP() uint32 {
	return (volatile.LoadUint32(&o.SA.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetSA_NSA_USB(value uint32) {
	volatile.StoreUint32(&o.SA.Reg, volatile.LoadUint32(&o.SA.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetSA_NSA_USB() uint32 {
	return (volatile.LoadUint32(&o.SA.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetSA_L_USB(value uint32) {
	volatile.StoreUint32(&o.SA.Reg, volatile.LoadUint32(&o.SA.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetSA_L_USB() uint32 {
	return (volatile.LoadUint32(&o.SA.Reg) & 0x800000) >> 23
}

// CSU.HPCONTROL0: HPCONTROL0 register
func (o *CSU_Type) SetHPCONTROL0_HPC_DMA(value uint32) {
	volatile.StoreUint32(&o.HPCONTROL0.Reg, volatile.LoadUint32(&o.HPCONTROL0.Reg)&^(0x4)|value<<2)
}
func (o *CSU_Type) GetHPCONTROL0_HPC_DMA() uint32 {
	return (volatile.LoadUint32(&o.HPCONTROL0.Reg) & 0x4) >> 2
}
func (o *CSU_Type) SetHPCONTROL0_L_DMA(value uint32) {
	volatile.StoreUint32(&o.HPCONTROL0.Reg, volatile.LoadUint32(&o.HPCONTROL0.Reg)&^(0x8)|value<<3)
}
func (o *CSU_Type) GetHPCONTROL0_L_DMA() uint32 {
	return (volatile.LoadUint32(&o.HPCONTROL0.Reg) & 0x8) >> 3
}
func (o *CSU_Type) SetHPCONTROL0_HPC_LCDIF(value uint32) {
	volatile.StoreUint32(&o.HPCONTROL0.Reg, volatile.LoadUint32(&o.HPCONTROL0.Reg)&^(0x10)|value<<4)
}
func (o *CSU_Type) GetHPCONTROL0_HPC_LCDIF() uint32 {
	return (volatile.LoadUint32(&o.HPCONTROL0.Reg) & 0x10) >> 4
}
func (o *CSU_Type) SetHPCONTROL0_L_LCDIF(value uint32) {
	volatile.StoreUint32(&o.HPCONTROL0.Reg, volatile.LoadUint32(&o.HPCONTROL0.Reg)&^(0x20)|value<<5)
}
func (o *CSU_Type) GetHPCONTROL0_L_LCDIF() uint32 {
	return (volatile.LoadUint32(&o.HPCONTROL0.Reg) & 0x20) >> 5
}
func (o *CSU_Type) SetHPCONTROL0_HPC_CSI(value uint32) {
	volatile.StoreUint32(&o.HPCONTROL0.Reg, volatile.LoadUint32(&o.HPCONTROL0.Reg)&^(0x40)|value<<6)
}
func (o *CSU_Type) GetHPCONTROL0_HPC_CSI() uint32 {
	return (volatile.LoadUint32(&o.HPCONTROL0.Reg) & 0x40) >> 6
}
func (o *CSU_Type) SetHPCONTROL0_L_CSI(value uint32) {
	volatile.StoreUint32(&o.HPCONTROL0.Reg, volatile.LoadUint32(&o.HPCONTROL0.Reg)&^(0x80)|value<<7)
}
func (o *CSU_Type) GetHPCONTROL0_L_CSI() uint32 {
	return (volatile.LoadUint32(&o.HPCONTROL0.Reg) & 0x80) >> 7
}
func (o *CSU_Type) SetHPCONTROL0_HPC_PXP(value uint32) {
	volatile.StoreUint32(&o.HPCONTROL0.Reg, volatile.LoadUint32(&o.HPCONTROL0.Reg)&^(0x100)|value<<8)
}
func (o *CSU_Type) GetHPCONTROL0_HPC_PXP() uint32 {
	return (volatile.LoadUint32(&o.HPCONTROL0.Reg) & 0x100) >> 8
}
func (o *CSU_Type) SetHPCONTROL0_L_PXP(value uint32) {
	volatile.StoreUint32(&o.HPCONTROL0.Reg, volatile.LoadUint32(&o.HPCONTROL0.Reg)&^(0x200)|value<<9)
}
func (o *CSU_Type) GetHPCONTROL0_L_PXP() uint32 {
	return (volatile.LoadUint32(&o.HPCONTROL0.Reg) & 0x200) >> 9
}
func (o *CSU_Type) SetHPCONTROL0_HPC_DCP(value uint32) {
	volatile.StoreUint32(&o.HPCONTROL0.Reg, volatile.LoadUint32(&o.HPCONTROL0.Reg)&^(0x400)|value<<10)
}
func (o *CSU_Type) GetHPCONTROL0_HPC_DCP() uint32 {
	return (volatile.LoadUint32(&o.HPCONTROL0.Reg) & 0x400) >> 10
}
func (o *CSU_Type) SetHPCONTROL0_L_DCP(value uint32) {
	volatile.StoreUint32(&o.HPCONTROL0.Reg, volatile.LoadUint32(&o.HPCONTROL0.Reg)&^(0x800)|value<<11)
}
func (o *CSU_Type) GetHPCONTROL0_L_DCP() uint32 {
	return (volatile.LoadUint32(&o.HPCONTROL0.Reg) & 0x800) >> 11
}
func (o *CSU_Type) SetHPCONTROL0_HPC_ENET(value uint32) {
	volatile.StoreUint32(&o.HPCONTROL0.Reg, volatile.LoadUint32(&o.HPCONTROL0.Reg)&^(0x4000)|value<<14)
}
func (o *CSU_Type) GetHPCONTROL0_HPC_ENET() uint32 {
	return (volatile.LoadUint32(&o.HPCONTROL0.Reg) & 0x4000) >> 14
}
func (o *CSU_Type) SetHPCONTROL0_L_ENET(value uint32) {
	volatile.StoreUint32(&o.HPCONTROL0.Reg, volatile.LoadUint32(&o.HPCONTROL0.Reg)&^(0x8000)|value<<15)
}
func (o *CSU_Type) GetHPCONTROL0_L_ENET() uint32 {
	return (volatile.LoadUint32(&o.HPCONTROL0.Reg) & 0x8000) >> 15
}
func (o *CSU_Type) SetHPCONTROL0_HPC_USDHC1(value uint32) {
	volatile.StoreUint32(&o.HPCONTROL0.Reg, volatile.LoadUint32(&o.HPCONTROL0.Reg)&^(0x10000)|value<<16)
}
func (o *CSU_Type) GetHPCONTROL0_HPC_USDHC1() uint32 {
	return (volatile.LoadUint32(&o.HPCONTROL0.Reg) & 0x10000) >> 16
}
func (o *CSU_Type) SetHPCONTROL0_L_USDHC1(value uint32) {
	volatile.StoreUint32(&o.HPCONTROL0.Reg, volatile.LoadUint32(&o.HPCONTROL0.Reg)&^(0x20000)|value<<17)
}
func (o *CSU_Type) GetHPCONTROL0_L_USDHC1() uint32 {
	return (volatile.LoadUint32(&o.HPCONTROL0.Reg) & 0x20000) >> 17
}
func (o *CSU_Type) SetHPCONTROL0_HPC_USDHC2(value uint32) {
	volatile.StoreUint32(&o.HPCONTROL0.Reg, volatile.LoadUint32(&o.HPCONTROL0.Reg)&^(0x40000)|value<<18)
}
func (o *CSU_Type) GetHPCONTROL0_HPC_USDHC2() uint32 {
	return (volatile.LoadUint32(&o.HPCONTROL0.Reg) & 0x40000) >> 18
}
func (o *CSU_Type) SetHPCONTROL0_L_USDHC2(value uint32) {
	volatile.StoreUint32(&o.HPCONTROL0.Reg, volatile.LoadUint32(&o.HPCONTROL0.Reg)&^(0x80000)|value<<19)
}
func (o *CSU_Type) GetHPCONTROL0_L_USDHC2() uint32 {
	return (volatile.LoadUint32(&o.HPCONTROL0.Reg) & 0x80000) >> 19
}
func (o *CSU_Type) SetHPCONTROL0_HPC_TPSMP(value uint32) {
	volatile.StoreUint32(&o.HPCONTROL0.Reg, volatile.LoadUint32(&o.HPCONTROL0.Reg)&^(0x100000)|value<<20)
}
func (o *CSU_Type) GetHPCONTROL0_HPC_TPSMP() uint32 {
	return (volatile.LoadUint32(&o.HPCONTROL0.Reg) & 0x100000) >> 20
}
func (o *CSU_Type) SetHPCONTROL0_L_TPSMP(value uint32) {
	volatile.StoreUint32(&o.HPCONTROL0.Reg, volatile.LoadUint32(&o.HPCONTROL0.Reg)&^(0x200000)|value<<21)
}
func (o *CSU_Type) GetHPCONTROL0_L_TPSMP() uint32 {
	return (volatile.LoadUint32(&o.HPCONTROL0.Reg) & 0x200000) >> 21
}
func (o *CSU_Type) SetHPCONTROL0_HPC_USB(value uint32) {
	volatile.StoreUint32(&o.HPCONTROL0.Reg, volatile.LoadUint32(&o.HPCONTROL0.Reg)&^(0x400000)|value<<22)
}
func (o *CSU_Type) GetHPCONTROL0_HPC_USB() uint32 {
	return (volatile.LoadUint32(&o.HPCONTROL0.Reg) & 0x400000) >> 22
}
func (o *CSU_Type) SetHPCONTROL0_L_USB(value uint32) {
	volatile.StoreUint32(&o.HPCONTROL0.Reg, volatile.LoadUint32(&o.HPCONTROL0.Reg)&^(0x800000)|value<<23)
}
func (o *CSU_Type) GetHPCONTROL0_L_USB() uint32 {
	return (volatile.LoadUint32(&o.HPCONTROL0.Reg) & 0x800000) >> 23
}

// USB
type USB_Type struct {
	ID             volatile.Register32 // 0x0
	HWGENERAL      volatile.Register32 // 0x4
	HWHOST         volatile.Register32 // 0x8
	HWDEVICE       volatile.Register32 // 0xC
	HWTXBUF        volatile.Register32 // 0x10
	HWRXBUF        volatile.Register32 // 0x14
	_              [104]byte
	GPTIMER0LD     volatile.Register32 // 0x80
	GPTIMER0CTRL   volatile.Register32 // 0x84
	GPTIMER1LD     volatile.Register32 // 0x88
	GPTIMER1CTRL   volatile.Register32 // 0x8C
	SBUSCFG        volatile.Register32 // 0x90
	_              [108]byte
	CAPLENGTH      volatile.Register8 // 0x100
	_              byte
	HCIVERSION     volatile.Register16 // 0x102
	HCSPARAMS      volatile.Register32 // 0x104
	HCCPARAMS      volatile.Register32 // 0x108
	_              [20]byte
	DCIVERSION     volatile.Register16 // 0x120
	_              [2]byte
	DCCPARAMS      volatile.Register32 // 0x124
	_              [24]byte
	USBCMD         volatile.Register32 // 0x140
	USBSTS         volatile.Register32 // 0x144
	USBINTR        volatile.Register32 // 0x148
	FRINDEX        volatile.Register32 // 0x14C
	_              [4]byte
	DEVICEADDR     volatile.Register32 // 0x154
	ASYNCLISTADDR  volatile.Register32 // 0x158
	_              [4]byte
	BURSTSIZE      volatile.Register32 // 0x160
	TXFILLTUNING   volatile.Register32 // 0x164
	_              [16]byte
	ENDPTNAK       volatile.Register32 // 0x178
	ENDPTNAKEN     volatile.Register32 // 0x17C
	CONFIGFLAG     volatile.Register32 // 0x180
	PORTSC1        volatile.Register32 // 0x184
	_              [28]byte
	OTGSC          volatile.Register32 // 0x1A4
	USBMODE        volatile.Register32 // 0x1A8
	ENDPTSETUPSTAT volatile.Register32 // 0x1AC
	ENDPTPRIME     volatile.Register32 // 0x1B0
	ENDPTFLUSH     volatile.Register32 // 0x1B4
	ENDPTSTAT      volatile.Register32 // 0x1B8
	ENDPTCOMPLETE  volatile.Register32 // 0x1BC
	ENDPTCTRL0     volatile.Register32 // 0x1C0
	ENDPTCTRL1     volatile.Register32 // 0x1C4
	ENDPTCTRL2     volatile.Register32 // 0x1C8
	ENDPTCTRL3     volatile.Register32 // 0x1CC
	ENDPTCTRL4     volatile.Register32 // 0x1D0
	ENDPTCTRL5     volatile.Register32 // 0x1D4
	ENDPTCTRL6     volatile.Register32 // 0x1D8
	ENDPTCTRL7     volatile.Register32 // 0x1DC
}

// USB.ID: Identification register
func (o *USB_Type) SetID(value uint32) {
	volatile.StoreUint32(&o.ID.Reg, volatile.LoadUint32(&o.ID.Reg)&^(0x3f)|value)
}
func (o *USB_Type) GetID() uint32 {
	return volatile.LoadUint32(&o.ID.Reg) & 0x3f
}
func (o *USB_Type) SetID_NID(value uint32) {
	volatile.StoreUint32(&o.ID.Reg, volatile.LoadUint32(&o.ID.Reg)&^(0x3f00)|value<<8)
}
func (o *USB_Type) GetID_NID() uint32 {
	return (volatile.LoadUint32(&o.ID.Reg) & 0x3f00) >> 8
}
func (o *USB_Type) SetID_REVISION(value uint32) {
	volatile.StoreUint32(&o.ID.Reg, volatile.LoadUint32(&o.ID.Reg)&^(0xff0000)|value<<16)
}
func (o *USB_Type) GetID_REVISION() uint32 {
	return (volatile.LoadUint32(&o.ID.Reg) & 0xff0000) >> 16
}

// USB.HWGENERAL: Hardware General
func (o *USB_Type) SetHWGENERAL_PHYW(value uint32) {
	volatile.StoreUint32(&o.HWGENERAL.Reg, volatile.LoadUint32(&o.HWGENERAL.Reg)&^(0x30)|value<<4)
}
func (o *USB_Type) GetHWGENERAL_PHYW() uint32 {
	return (volatile.LoadUint32(&o.HWGENERAL.Reg) & 0x30) >> 4
}
func (o *USB_Type) SetHWGENERAL_PHYM(value uint32) {
	volatile.StoreUint32(&o.HWGENERAL.Reg, volatile.LoadUint32(&o.HWGENERAL.Reg)&^(0x1c0)|value<<6)
}
func (o *USB_Type) GetHWGENERAL_PHYM() uint32 {
	return (volatile.LoadUint32(&o.HWGENERAL.Reg) & 0x1c0) >> 6
}
func (o *USB_Type) SetHWGENERAL_SM(value uint32) {
	volatile.StoreUint32(&o.HWGENERAL.Reg, volatile.LoadUint32(&o.HWGENERAL.Reg)&^(0x600)|value<<9)
}
func (o *USB_Type) GetHWGENERAL_SM() uint32 {
	return (volatile.LoadUint32(&o.HWGENERAL.Reg) & 0x600) >> 9
}

// USB.HWHOST: Host Hardware Parameters
func (o *USB_Type) SetHWHOST_HC(value uint32) {
	volatile.StoreUint32(&o.HWHOST.Reg, volatile.LoadUint32(&o.HWHOST.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetHWHOST_HC() uint32 {
	return volatile.LoadUint32(&o.HWHOST.Reg) & 0x1
}
func (o *USB_Type) SetHWHOST_NPORT(value uint32) {
	volatile.StoreUint32(&o.HWHOST.Reg, volatile.LoadUint32(&o.HWHOST.Reg)&^(0xe)|value<<1)
}
func (o *USB_Type) GetHWHOST_NPORT() uint32 {
	return (volatile.LoadUint32(&o.HWHOST.Reg) & 0xe) >> 1
}

// USB.HWDEVICE: Device Hardware Parameters
func (o *USB_Type) SetHWDEVICE_DC(value uint32) {
	volatile.StoreUint32(&o.HWDEVICE.Reg, volatile.LoadUint32(&o.HWDEVICE.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetHWDEVICE_DC() uint32 {
	return volatile.LoadUint32(&o.HWDEVICE.Reg) & 0x1
}
func (o *USB_Type) SetHWDEVICE_DEVEP(value uint32) {
	volatile.StoreUint32(&o.HWDEVICE.Reg, volatile.LoadUint32(&o.HWDEVICE.Reg)&^(0x3e)|value<<1)
}
func (o *USB_Type) GetHWDEVICE_DEVEP() uint32 {
	return (volatile.LoadUint32(&o.HWDEVICE.Reg) & 0x3e) >> 1
}

// USB.HWTXBUF: TX Buffer Hardware Parameters
func (o *USB_Type) SetHWTXBUF_TXBURST(value uint32) {
	volatile.StoreUint32(&o.HWTXBUF.Reg, volatile.LoadUint32(&o.HWTXBUF.Reg)&^(0xff)|value)
}
func (o *USB_Type) GetHWTXBUF_TXBURST() uint32 {
	return volatile.LoadUint32(&o.HWTXBUF.Reg) & 0xff
}
func (o *USB_Type) SetHWTXBUF_TXCHANADD(value uint32) {
	volatile.StoreUint32(&o.HWTXBUF.Reg, volatile.LoadUint32(&o.HWTXBUF.Reg)&^(0xff0000)|value<<16)
}
func (o *USB_Type) GetHWTXBUF_TXCHANADD() uint32 {
	return (volatile.LoadUint32(&o.HWTXBUF.Reg) & 0xff0000) >> 16
}

// USB.HWRXBUF: RX Buffer Hardware Parameters
func (o *USB_Type) SetHWRXBUF_RXBURST(value uint32) {
	volatile.StoreUint32(&o.HWRXBUF.Reg, volatile.LoadUint32(&o.HWRXBUF.Reg)&^(0xff)|value)
}
func (o *USB_Type) GetHWRXBUF_RXBURST() uint32 {
	return volatile.LoadUint32(&o.HWRXBUF.Reg) & 0xff
}
func (o *USB_Type) SetHWRXBUF_RXADD(value uint32) {
	volatile.StoreUint32(&o.HWRXBUF.Reg, volatile.LoadUint32(&o.HWRXBUF.Reg)&^(0xff00)|value<<8)
}
func (o *USB_Type) GetHWRXBUF_RXADD() uint32 {
	return (volatile.LoadUint32(&o.HWRXBUF.Reg) & 0xff00) >> 8
}

// USB.GPTIMER0LD: General Purpose Timer #0 Load
func (o *USB_Type) SetGPTIMER0LD_GPTLD(value uint32) {
	volatile.StoreUint32(&o.GPTIMER0LD.Reg, volatile.LoadUint32(&o.GPTIMER0LD.Reg)&^(0xffffff)|value)
}
func (o *USB_Type) GetGPTIMER0LD_GPTLD() uint32 {
	return volatile.LoadUint32(&o.GPTIMER0LD.Reg) & 0xffffff
}

// USB.GPTIMER0CTRL: General Purpose Timer #0 Controller
func (o *USB_Type) SetGPTIMER0CTRL_GPTCNT(value uint32) {
	volatile.StoreUint32(&o.GPTIMER0CTRL.Reg, volatile.LoadUint32(&o.GPTIMER0CTRL.Reg)&^(0xffffff)|value)
}
func (o *USB_Type) GetGPTIMER0CTRL_GPTCNT() uint32 {
	return volatile.LoadUint32(&o.GPTIMER0CTRL.Reg) & 0xffffff
}
func (o *USB_Type) SetGPTIMER0CTRL_GPTMODE(value uint32) {
	volatile.StoreUint32(&o.GPTIMER0CTRL.Reg, volatile.LoadUint32(&o.GPTIMER0CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetGPTIMER0CTRL_GPTMODE() uint32 {
	return (volatile.LoadUint32(&o.GPTIMER0CTRL.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetGPTIMER0CTRL_GPTRST(value uint32) {
	volatile.StoreUint32(&o.GPTIMER0CTRL.Reg, volatile.LoadUint32(&o.GPTIMER0CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetGPTIMER0CTRL_GPTRST() uint32 {
	return (volatile.LoadUint32(&o.GPTIMER0CTRL.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetGPTIMER0CTRL_GPTRUN(value uint32) {
	volatile.StoreUint32(&o.GPTIMER0CTRL.Reg, volatile.LoadUint32(&o.GPTIMER0CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetGPTIMER0CTRL_GPTRUN() uint32 {
	return (volatile.LoadUint32(&o.GPTIMER0CTRL.Reg) & 0x80000000) >> 31
}

// USB.GPTIMER1LD: General Purpose Timer #1 Load
func (o *USB_Type) SetGPTIMER1LD_GPTLD(value uint32) {
	volatile.StoreUint32(&o.GPTIMER1LD.Reg, volatile.LoadUint32(&o.GPTIMER1LD.Reg)&^(0xffffff)|value)
}
func (o *USB_Type) GetGPTIMER1LD_GPTLD() uint32 {
	return volatile.LoadUint32(&o.GPTIMER1LD.Reg) & 0xffffff
}

// USB.GPTIMER1CTRL: General Purpose Timer #1 Controller
func (o *USB_Type) SetGPTIMER1CTRL_GPTCNT(value uint32) {
	volatile.StoreUint32(&o.GPTIMER1CTRL.Reg, volatile.LoadUint32(&o.GPTIMER1CTRL.Reg)&^(0xffffff)|value)
}
func (o *USB_Type) GetGPTIMER1CTRL_GPTCNT() uint32 {
	return volatile.LoadUint32(&o.GPTIMER1CTRL.Reg) & 0xffffff
}
func (o *USB_Type) SetGPTIMER1CTRL_GPTMODE(value uint32) {
	volatile.StoreUint32(&o.GPTIMER1CTRL.Reg, volatile.LoadUint32(&o.GPTIMER1CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetGPTIMER1CTRL_GPTMODE() uint32 {
	return (volatile.LoadUint32(&o.GPTIMER1CTRL.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetGPTIMER1CTRL_GPTRST(value uint32) {
	volatile.StoreUint32(&o.GPTIMER1CTRL.Reg, volatile.LoadUint32(&o.GPTIMER1CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetGPTIMER1CTRL_GPTRST() uint32 {
	return (volatile.LoadUint32(&o.GPTIMER1CTRL.Reg) & 0x40000000) >> 30
}
func (o *USB_Type) SetGPTIMER1CTRL_GPTRUN(value uint32) {
	volatile.StoreUint32(&o.GPTIMER1CTRL.Reg, volatile.LoadUint32(&o.GPTIMER1CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *USB_Type) GetGPTIMER1CTRL_GPTRUN() uint32 {
	return (volatile.LoadUint32(&o.GPTIMER1CTRL.Reg) & 0x80000000) >> 31
}

// USB.SBUSCFG: System Bus Config
func (o *USB_Type) SetSBUSCFG_AHBBRST(value uint32) {
	volatile.StoreUint32(&o.SBUSCFG.Reg, volatile.LoadUint32(&o.SBUSCFG.Reg)&^(0x7)|value)
}
func (o *USB_Type) GetSBUSCFG_AHBBRST() uint32 {
	return volatile.LoadUint32(&o.SBUSCFG.Reg) & 0x7
}

// USB.CAPLENGTH: Capability Registers Length
func (o *USB_Type) SetCAPLENGTH(value uint8) {
	volatile.StoreUint8(&o.CAPLENGTH.Reg, value)
}
func (o *USB_Type) GetCAPLENGTH() uint8 {
	return volatile.LoadUint8(&o.CAPLENGTH.Reg)
}

// USB.HCIVERSION: Host Controller Interface Version
func (o *USB_Type) SetHCIVERSION(value uint16) {
	volatile.StoreUint16(&o.HCIVERSION.Reg, value)
}
func (o *USB_Type) GetHCIVERSION() uint16 {
	return volatile.LoadUint16(&o.HCIVERSION.Reg)
}

// USB.HCSPARAMS: Host Controller Structural Parameters
func (o *USB_Type) SetHCSPARAMS_N_PORTS(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0xf)|value)
}
func (o *USB_Type) GetHCSPARAMS_N_PORTS() uint32 {
	return volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0xf
}
func (o *USB_Type) SetHCSPARAMS_PPC(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetHCSPARAMS_PPC() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetHCSPARAMS_N_PCC(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0xf00)|value<<8)
}
func (o *USB_Type) GetHCSPARAMS_N_PCC() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0xf00) >> 8
}
func (o *USB_Type) SetHCSPARAMS_N_CC(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0xf000)|value<<12)
}
func (o *USB_Type) GetHCSPARAMS_N_CC() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0xf000) >> 12
}
func (o *USB_Type) SetHCSPARAMS_PI(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetHCSPARAMS_PI() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetHCSPARAMS_N_PTT(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0xf00000)|value<<20)
}
func (o *USB_Type) GetHCSPARAMS_N_PTT() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0xf00000) >> 20
}
func (o *USB_Type) SetHCSPARAMS_N_TT(value uint32) {
	volatile.StoreUint32(&o.HCSPARAMS.Reg, volatile.LoadUint32(&o.HCSPARAMS.Reg)&^(0xf000000)|value<<24)
}
func (o *USB_Type) GetHCSPARAMS_N_TT() uint32 {
	return (volatile.LoadUint32(&o.HCSPARAMS.Reg) & 0xf000000) >> 24
}

// USB.HCCPARAMS: Host Controller Capability Parameters
func (o *USB_Type) SetHCCPARAMS_ADC(value uint32) {
	volatile.StoreUint32(&o.HCCPARAMS.Reg, volatile.LoadUint32(&o.HCCPARAMS.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetHCCPARAMS_ADC() uint32 {
	return volatile.LoadUint32(&o.HCCPARAMS.Reg) & 0x1
}
func (o *USB_Type) SetHCCPARAMS_PFL(value uint32) {
	volatile.StoreUint32(&o.HCCPARAMS.Reg, volatile.LoadUint32(&o.HCCPARAMS.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetHCCPARAMS_PFL() uint32 {
	return (volatile.LoadUint32(&o.HCCPARAMS.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetHCCPARAMS_ASP(value uint32) {
	volatile.StoreUint32(&o.HCCPARAMS.Reg, volatile.LoadUint32(&o.HCCPARAMS.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetHCCPARAMS_ASP() uint32 {
	return (volatile.LoadUint32(&o.HCCPARAMS.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetHCCPARAMS_IST(value uint32) {
	volatile.StoreUint32(&o.HCCPARAMS.Reg, volatile.LoadUint32(&o.HCCPARAMS.Reg)&^(0xf0)|value<<4)
}
func (o *USB_Type) GetHCCPARAMS_IST() uint32 {
	return (volatile.LoadUint32(&o.HCCPARAMS.Reg) & 0xf0) >> 4
}
func (o *USB_Type) SetHCCPARAMS_EECP(value uint32) {
	volatile.StoreUint32(&o.HCCPARAMS.Reg, volatile.LoadUint32(&o.HCCPARAMS.Reg)&^(0xff00)|value<<8)
}
func (o *USB_Type) GetHCCPARAMS_EECP() uint32 {
	return (volatile.LoadUint32(&o.HCCPARAMS.Reg) & 0xff00) >> 8
}

// USB.DCIVERSION: Device Controller Interface Version
func (o *USB_Type) SetDCIVERSION(value uint16) {
	volatile.StoreUint16(&o.DCIVERSION.Reg, value)
}
func (o *USB_Type) GetDCIVERSION() uint16 {
	return volatile.LoadUint16(&o.DCIVERSION.Reg)
}

// USB.DCCPARAMS: Device Controller Capability Parameters
func (o *USB_Type) SetDCCPARAMS_DEN(value uint32) {
	volatile.StoreUint32(&o.DCCPARAMS.Reg, volatile.LoadUint32(&o.DCCPARAMS.Reg)&^(0x1f)|value)
}
func (o *USB_Type) GetDCCPARAMS_DEN() uint32 {
	return volatile.LoadUint32(&o.DCCPARAMS.Reg) & 0x1f
}
func (o *USB_Type) SetDCCPARAMS_DC(value uint32) {
	volatile.StoreUint32(&o.DCCPARAMS.Reg, volatile.LoadUint32(&o.DCCPARAMS.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetDCCPARAMS_DC() uint32 {
	return (volatile.LoadUint32(&o.DCCPARAMS.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetDCCPARAMS_HC(value uint32) {
	volatile.StoreUint32(&o.DCCPARAMS.Reg, volatile.LoadUint32(&o.DCCPARAMS.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetDCCPARAMS_HC() uint32 {
	return (volatile.LoadUint32(&o.DCCPARAMS.Reg) & 0x100) >> 8
}

// USB.USBCMD: USB Command Register
func (o *USB_Type) SetUSBCMD_RS(value uint32) {
	volatile.StoreUint32(&o.USBCMD.Reg, volatile.LoadUint32(&o.USBCMD.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetUSBCMD_RS() uint32 {
	return volatile.LoadUint32(&o.USBCMD.Reg) & 0x1
}
func (o *USB_Type) SetUSBCMD_RST(value uint32) {
	volatile.StoreUint32(&o.USBCMD.Reg, volatile.LoadUint32(&o.USBCMD.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetUSBCMD_RST() uint32 {
	return (volatile.LoadUint32(&o.USBCMD.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetUSBCMD_FS_1(value uint32) {
	volatile.StoreUint32(&o.USBCMD.Reg, volatile.LoadUint32(&o.USBCMD.Reg)&^(0xc)|value<<2)
}
func (o *USB_Type) GetUSBCMD_FS_1() uint32 {
	return (volatile.LoadUint32(&o.USBCMD.Reg) & 0xc) >> 2
}
func (o *USB_Type) SetUSBCMD_PSE(value uint32) {
	volatile.StoreUint32(&o.USBCMD.Reg, volatile.LoadUint32(&o.USBCMD.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetUSBCMD_PSE() uint32 {
	return (volatile.LoadUint32(&o.USBCMD.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetUSBCMD_ASE(value uint32) {
	volatile.StoreUint32(&o.USBCMD.Reg, volatile.LoadUint32(&o.USBCMD.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetUSBCMD_ASE() uint32 {
	return (volatile.LoadUint32(&o.USBCMD.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetUSBCMD_IAA(value uint32) {
	volatile.StoreUint32(&o.USBCMD.Reg, volatile.LoadUint32(&o.USBCMD.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetUSBCMD_IAA() uint32 {
	return (volatile.LoadUint32(&o.USBCMD.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetUSBCMD_ASP(value uint32) {
	volatile.StoreUint32(&o.USBCMD.Reg, volatile.LoadUint32(&o.USBCMD.Reg)&^(0x300)|value<<8)
}
func (o *USB_Type) GetUSBCMD_ASP() uint32 {
	return (volatile.LoadUint32(&o.USBCMD.Reg) & 0x300) >> 8
}
func (o *USB_Type) SetUSBCMD_ASPE(value uint32) {
	volatile.StoreUint32(&o.USBCMD.Reg, volatile.LoadUint32(&o.USBCMD.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetUSBCMD_ASPE() uint32 {
	return (volatile.LoadUint32(&o.USBCMD.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetUSBCMD_SUTW(value uint32) {
	volatile.StoreUint32(&o.USBCMD.Reg, volatile.LoadUint32(&o.USBCMD.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetUSBCMD_SUTW() uint32 {
	return (volatile.LoadUint32(&o.USBCMD.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetUSBCMD_ATDTW(value uint32) {
	volatile.StoreUint32(&o.USBCMD.Reg, volatile.LoadUint32(&o.USBCMD.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetUSBCMD_ATDTW() uint32 {
	return (volatile.LoadUint32(&o.USBCMD.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetUSBCMD_FS_2(value uint32) {
	volatile.StoreUint32(&o.USBCMD.Reg, volatile.LoadUint32(&o.USBCMD.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetUSBCMD_FS_2() uint32 {
	return (volatile.LoadUint32(&o.USBCMD.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetUSBCMD_ITC(value uint32) {
	volatile.StoreUint32(&o.USBCMD.Reg, volatile.LoadUint32(&o.USBCMD.Reg)&^(0xff0000)|value<<16)
}
func (o *USB_Type) GetUSBCMD_ITC() uint32 {
	return (volatile.LoadUint32(&o.USBCMD.Reg) & 0xff0000) >> 16
}

// USB.USBSTS: USB Status Register
func (o *USB_Type) SetUSBSTS_UI(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetUSBSTS_UI() uint32 {
	return volatile.LoadUint32(&o.USBSTS.Reg) & 0x1
}
func (o *USB_Type) SetUSBSTS_UEI(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetUSBSTS_UEI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetUSBSTS_PCI(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetUSBSTS_PCI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetUSBSTS_FRI(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetUSBSTS_FRI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetUSBSTS_SEI(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetUSBSTS_SEI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetUSBSTS_AAI(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetUSBSTS_AAI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetUSBSTS_URI(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetUSBSTS_URI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetUSBSTS_SRI(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetUSBSTS_SRI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetUSBSTS_SLI(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetUSBSTS_SLI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetUSBSTS_ULPII(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetUSBSTS_ULPII() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetUSBSTS_HCH(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetUSBSTS_HCH() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetUSBSTS_RCL(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetUSBSTS_RCL() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetUSBSTS_PS(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetUSBSTS_PS() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetUSBSTS_AS(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x8000)|value<<15)
}
func (o *USB_Type) GetUSBSTS_AS() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x8000) >> 15
}
func (o *USB_Type) SetUSBSTS_NAKI(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetUSBSTS_NAKI() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetUSBSTS_TI0(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetUSBSTS_TI0() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetUSBSTS_TI1(value uint32) {
	volatile.StoreUint32(&o.USBSTS.Reg, volatile.LoadUint32(&o.USBSTS.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_Type) GetUSBSTS_TI1() uint32 {
	return (volatile.LoadUint32(&o.USBSTS.Reg) & 0x2000000) >> 25
}

// USB.USBINTR: Interrupt Enable Register
func (o *USB_Type) SetUSBINTR_UE(value uint32) {
	volatile.StoreUint32(&o.USBINTR.Reg, volatile.LoadUint32(&o.USBINTR.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetUSBINTR_UE() uint32 {
	return volatile.LoadUint32(&o.USBINTR.Reg) & 0x1
}
func (o *USB_Type) SetUSBINTR_UEE(value uint32) {
	volatile.StoreUint32(&o.USBINTR.Reg, volatile.LoadUint32(&o.USBINTR.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetUSBINTR_UEE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetUSBINTR_PCE(value uint32) {
	volatile.StoreUint32(&o.USBINTR.Reg, volatile.LoadUint32(&o.USBINTR.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetUSBINTR_PCE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetUSBINTR_FRE(value uint32) {
	volatile.StoreUint32(&o.USBINTR.Reg, volatile.LoadUint32(&o.USBINTR.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetUSBINTR_FRE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetUSBINTR_SEE(value uint32) {
	volatile.StoreUint32(&o.USBINTR.Reg, volatile.LoadUint32(&o.USBINTR.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetUSBINTR_SEE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetUSBINTR_AAE(value uint32) {
	volatile.StoreUint32(&o.USBINTR.Reg, volatile.LoadUint32(&o.USBINTR.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetUSBINTR_AAE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetUSBINTR_URE(value uint32) {
	volatile.StoreUint32(&o.USBINTR.Reg, volatile.LoadUint32(&o.USBINTR.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetUSBINTR_URE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetUSBINTR_SRE(value uint32) {
	volatile.StoreUint32(&o.USBINTR.Reg, volatile.LoadUint32(&o.USBINTR.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetUSBINTR_SRE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetUSBINTR_SLE(value uint32) {
	volatile.StoreUint32(&o.USBINTR.Reg, volatile.LoadUint32(&o.USBINTR.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetUSBINTR_SLE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetUSBINTR_ULPIE(value uint32) {
	volatile.StoreUint32(&o.USBINTR.Reg, volatile.LoadUint32(&o.USBINTR.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetUSBINTR_ULPIE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetUSBINTR_NAKE(value uint32) {
	volatile.StoreUint32(&o.USBINTR.Reg, volatile.LoadUint32(&o.USBINTR.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetUSBINTR_NAKE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetUSBINTR_UAIE(value uint32) {
	volatile.StoreUint32(&o.USBINTR.Reg, volatile.LoadUint32(&o.USBINTR.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetUSBINTR_UAIE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR.Reg) & 0x40000) >> 18
}
func (o *USB_Type) SetUSBINTR_UPIE(value uint32) {
	volatile.StoreUint32(&o.USBINTR.Reg, volatile.LoadUint32(&o.USBINTR.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetUSBINTR_UPIE() uint32 {
	return (volatile.LoadUint32(&o.USBINTR.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetUSBINTR_TIE0(value uint32) {
	volatile.StoreUint32(&o.USBINTR.Reg, volatile.LoadUint32(&o.USBINTR.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetUSBINTR_TIE0() uint32 {
	return (volatile.LoadUint32(&o.USBINTR.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetUSBINTR_TIE1(value uint32) {
	volatile.StoreUint32(&o.USBINTR.Reg, volatile.LoadUint32(&o.USBINTR.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_Type) GetUSBINTR_TIE1() uint32 {
	return (volatile.LoadUint32(&o.USBINTR.Reg) & 0x2000000) >> 25
}

// USB.FRINDEX: USB Frame Index
func (o *USB_Type) SetFRINDEX(value uint32) {
	volatile.StoreUint32(&o.FRINDEX.Reg, volatile.LoadUint32(&o.FRINDEX.Reg)&^(0x3fff)|value)
}
func (o *USB_Type) GetFRINDEX() uint32 {
	return volatile.LoadUint32(&o.FRINDEX.Reg) & 0x3fff
}

// USB.DEVICEADDR: Device Address
func (o *USB_Type) SetDEVICEADDR_USBADRA(value uint32) {
	volatile.StoreUint32(&o.DEVICEADDR.Reg, volatile.LoadUint32(&o.DEVICEADDR.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetDEVICEADDR_USBADRA() uint32 {
	return (volatile.LoadUint32(&o.DEVICEADDR.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetDEVICEADDR_USBADR(value uint32) {
	volatile.StoreUint32(&o.DEVICEADDR.Reg, volatile.LoadUint32(&o.DEVICEADDR.Reg)&^(0xfe000000)|value<<25)
}
func (o *USB_Type) GetDEVICEADDR_USBADR() uint32 {
	return (volatile.LoadUint32(&o.DEVICEADDR.Reg) & 0xfe000000) >> 25
}

// USB.ASYNCLISTADDR: Next Asynch. Address
func (o *USB_Type) SetASYNCLISTADDR_ASYBASE(value uint32) {
	volatile.StoreUint32(&o.ASYNCLISTADDR.Reg, volatile.LoadUint32(&o.ASYNCLISTADDR.Reg)&^(0xffffffe0)|value<<5)
}
func (o *USB_Type) GetASYNCLISTADDR_ASYBASE() uint32 {
	return (volatile.LoadUint32(&o.ASYNCLISTADDR.Reg) & 0xffffffe0) >> 5
}

// USB.BURSTSIZE: Programmable Burst Size
func (o *USB_Type) SetBURSTSIZE_RXPBURST(value uint32) {
	volatile.StoreUint32(&o.BURSTSIZE.Reg, volatile.LoadUint32(&o.BURSTSIZE.Reg)&^(0xff)|value)
}
func (o *USB_Type) GetBURSTSIZE_RXPBURST() uint32 {
	return volatile.LoadUint32(&o.BURSTSIZE.Reg) & 0xff
}
func (o *USB_Type) SetBURSTSIZE_TXPBURST(value uint32) {
	volatile.StoreUint32(&o.BURSTSIZE.Reg, volatile.LoadUint32(&o.BURSTSIZE.Reg)&^(0x1ff00)|value<<8)
}
func (o *USB_Type) GetBURSTSIZE_TXPBURST() uint32 {
	return (volatile.LoadUint32(&o.BURSTSIZE.Reg) & 0x1ff00) >> 8
}

// USB.TXFILLTUNING: TX FIFO Fill Tuning
func (o *USB_Type) SetTXFILLTUNING_TXSCHOH(value uint32) {
	volatile.StoreUint32(&o.TXFILLTUNING.Reg, volatile.LoadUint32(&o.TXFILLTUNING.Reg)&^(0xff)|value)
}
func (o *USB_Type) GetTXFILLTUNING_TXSCHOH() uint32 {
	return volatile.LoadUint32(&o.TXFILLTUNING.Reg) & 0xff
}
func (o *USB_Type) SetTXFILLTUNING_TXSCHHEALTH(value uint32) {
	volatile.StoreUint32(&o.TXFILLTUNING.Reg, volatile.LoadUint32(&o.TXFILLTUNING.Reg)&^(0x1f00)|value<<8)
}
func (o *USB_Type) GetTXFILLTUNING_TXSCHHEALTH() uint32 {
	return (volatile.LoadUint32(&o.TXFILLTUNING.Reg) & 0x1f00) >> 8
}
func (o *USB_Type) SetTXFILLTUNING_TXFIFOTHRES(value uint32) {
	volatile.StoreUint32(&o.TXFILLTUNING.Reg, volatile.LoadUint32(&o.TXFILLTUNING.Reg)&^(0x3f0000)|value<<16)
}
func (o *USB_Type) GetTXFILLTUNING_TXFIFOTHRES() uint32 {
	return (volatile.LoadUint32(&o.TXFILLTUNING.Reg) & 0x3f0000) >> 16
}

// USB.ENDPTNAK: Endpoint NAK
func (o *USB_Type) SetENDPTNAK_EPRN(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAK.Reg, volatile.LoadUint32(&o.ENDPTNAK.Reg)&^(0xff)|value)
}
func (o *USB_Type) GetENDPTNAK_EPRN() uint32 {
	return volatile.LoadUint32(&o.ENDPTNAK.Reg) & 0xff
}
func (o *USB_Type) SetENDPTNAK_EPTN(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAK.Reg, volatile.LoadUint32(&o.ENDPTNAK.Reg)&^(0xff0000)|value<<16)
}
func (o *USB_Type) GetENDPTNAK_EPTN() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAK.Reg) & 0xff0000) >> 16
}

// USB.ENDPTNAKEN: Endpoint NAK Enable
func (o *USB_Type) SetENDPTNAKEN_EPRNE(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAKEN.Reg, volatile.LoadUint32(&o.ENDPTNAKEN.Reg)&^(0xff)|value)
}
func (o *USB_Type) GetENDPTNAKEN_EPRNE() uint32 {
	return volatile.LoadUint32(&o.ENDPTNAKEN.Reg) & 0xff
}
func (o *USB_Type) SetENDPTNAKEN_EPTNE(value uint32) {
	volatile.StoreUint32(&o.ENDPTNAKEN.Reg, volatile.LoadUint32(&o.ENDPTNAKEN.Reg)&^(0xff0000)|value<<16)
}
func (o *USB_Type) GetENDPTNAKEN_EPTNE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTNAKEN.Reg) & 0xff0000) >> 16
}

// USB.CONFIGFLAG: Configure Flag Register
func (o *USB_Type) SetCONFIGFLAG_CF(value uint32) {
	volatile.StoreUint32(&o.CONFIGFLAG.Reg, volatile.LoadUint32(&o.CONFIGFLAG.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetCONFIGFLAG_CF() uint32 {
	return volatile.LoadUint32(&o.CONFIGFLAG.Reg) & 0x1
}

// USB.PORTSC1: Port Status & Control
func (o *USB_Type) SetPORTSC1_CCS(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetPORTSC1_CCS() uint32 {
	return volatile.LoadUint32(&o.PORTSC1.Reg) & 0x1
}
func (o *USB_Type) SetPORTSC1_CSC(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetPORTSC1_CSC() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetPORTSC1_PE(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetPORTSC1_PE() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetPORTSC1_PEC(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetPORTSC1_PEC() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetPORTSC1_OCA(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetPORTSC1_OCA() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetPORTSC1_OCC(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetPORTSC1_OCC() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetPORTSC1_FPR(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetPORTSC1_FPR() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetPORTSC1_SUSP(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetPORTSC1_SUSP() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetPORTSC1_PR(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetPORTSC1_PR() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetPORTSC1_HSP(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetPORTSC1_HSP() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetPORTSC1_LS(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0xc00)|value<<10)
}
func (o *USB_Type) GetPORTSC1_LS() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0xc00) >> 10
}
func (o *USB_Type) SetPORTSC1_PP(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetPORTSC1_PP() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetPORTSC1_PO(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetPORTSC1_PO() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetPORTSC1_PIC(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0xc000)|value<<14)
}
func (o *USB_Type) GetPORTSC1_PIC() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0xc000) >> 14
}
func (o *USB_Type) SetPORTSC1_PTC(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0xf0000)|value<<16)
}
func (o *USB_Type) GetPORTSC1_PTC() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0xf0000) >> 16
}
func (o *USB_Type) SetPORTSC1_WKCN(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetPORTSC1_WKCN() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetPORTSC1_WKDC(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetPORTSC1_WKDC() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetPORTSC1_WKOC(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetPORTSC1_WKOC() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetPORTSC1_PHCD(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetPORTSC1_PHCD() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x800000) >> 23
}
func (o *USB_Type) SetPORTSC1_PFSC(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetPORTSC1_PFSC() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetPORTSC1_PTS_2(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_Type) GetPORTSC1_PTS_2() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x2000000) >> 25
}
func (o *USB_Type) SetPORTSC1_PSPD(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0xc000000)|value<<26)
}
func (o *USB_Type) GetPORTSC1_PSPD() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0xc000000) >> 26
}
func (o *USB_Type) SetPORTSC1_PTW(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetPORTSC1_PTW() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetPORTSC1_STS(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetPORTSC1_STS() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetPORTSC1_PTS_1(value uint32) {
	volatile.StoreUint32(&o.PORTSC1.Reg, volatile.LoadUint32(&o.PORTSC1.Reg)&^(0xc0000000)|value<<30)
}
func (o *USB_Type) GetPORTSC1_PTS_1() uint32 {
	return (volatile.LoadUint32(&o.PORTSC1.Reg) & 0xc0000000) >> 30
}

// USB.OTGSC: On-The-Go Status & control
func (o *USB_Type) SetOTGSC_VD(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetOTGSC_VD() uint32 {
	return volatile.LoadUint32(&o.OTGSC.Reg) & 0x1
}
func (o *USB_Type) SetOTGSC_VC(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetOTGSC_VC() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetOTGSC_OT(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetOTGSC_OT() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetOTGSC_DP(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetOTGSC_DP() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x10) >> 4
}
func (o *USB_Type) SetOTGSC_IDPU(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetOTGSC_IDPU() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetOTGSC_ID(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x100)|value<<8)
}
func (o *USB_Type) GetOTGSC_ID() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x100) >> 8
}
func (o *USB_Type) SetOTGSC_AVV(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x200)|value<<9)
}
func (o *USB_Type) GetOTGSC_AVV() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x200) >> 9
}
func (o *USB_Type) SetOTGSC_ASV(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x400)|value<<10)
}
func (o *USB_Type) GetOTGSC_ASV() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x400) >> 10
}
func (o *USB_Type) SetOTGSC_BSV(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x800)|value<<11)
}
func (o *USB_Type) GetOTGSC_BSV() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x800) >> 11
}
func (o *USB_Type) SetOTGSC_BSE(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x1000)|value<<12)
}
func (o *USB_Type) GetOTGSC_BSE() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x1000) >> 12
}
func (o *USB_Type) SetOTGSC_TOG_1MS(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x2000)|value<<13)
}
func (o *USB_Type) GetOTGSC_TOG_1MS() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x2000) >> 13
}
func (o *USB_Type) SetOTGSC_DPS(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x4000)|value<<14)
}
func (o *USB_Type) GetOTGSC_DPS() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x4000) >> 14
}
func (o *USB_Type) SetOTGSC_IDIS(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetOTGSC_IDIS() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetOTGSC_AVVIS(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetOTGSC_AVVIS() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetOTGSC_ASVIS(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x40000)|value<<18)
}
func (o *USB_Type) GetOTGSC_ASVIS() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x40000) >> 18
}
func (o *USB_Type) SetOTGSC_BSVIS(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x80000)|value<<19)
}
func (o *USB_Type) GetOTGSC_BSVIS() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x80000) >> 19
}
func (o *USB_Type) SetOTGSC_BSEIS(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x100000)|value<<20)
}
func (o *USB_Type) GetOTGSC_BSEIS() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x100000) >> 20
}
func (o *USB_Type) SetOTGSC_STATUS_1MS(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetOTGSC_STATUS_1MS() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetOTGSC_DPIS(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetOTGSC_DPIS() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetOTGSC_IDIE(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x1000000)|value<<24)
}
func (o *USB_Type) GetOTGSC_IDIE() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x1000000) >> 24
}
func (o *USB_Type) SetOTGSC_AVVIE(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x2000000)|value<<25)
}
func (o *USB_Type) GetOTGSC_AVVIE() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x2000000) >> 25
}
func (o *USB_Type) SetOTGSC_ASVIE(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x4000000)|value<<26)
}
func (o *USB_Type) GetOTGSC_ASVIE() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x4000000) >> 26
}
func (o *USB_Type) SetOTGSC_BSVIE(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x8000000)|value<<27)
}
func (o *USB_Type) GetOTGSC_BSVIE() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x8000000) >> 27
}
func (o *USB_Type) SetOTGSC_BSEIE(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x10000000)|value<<28)
}
func (o *USB_Type) GetOTGSC_BSEIE() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x10000000) >> 28
}
func (o *USB_Type) SetOTGSC_EN_1MS(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x20000000)|value<<29)
}
func (o *USB_Type) GetOTGSC_EN_1MS() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x20000000) >> 29
}
func (o *USB_Type) SetOTGSC_DPIE(value uint32) {
	volatile.StoreUint32(&o.OTGSC.Reg, volatile.LoadUint32(&o.OTGSC.Reg)&^(0x40000000)|value<<30)
}
func (o *USB_Type) GetOTGSC_DPIE() uint32 {
	return (volatile.LoadUint32(&o.OTGSC.Reg) & 0x40000000) >> 30
}

// USB.USBMODE: USB Device Mode
func (o *USB_Type) SetUSBMODE_CM(value uint32) {
	volatile.StoreUint32(&o.USBMODE.Reg, volatile.LoadUint32(&o.USBMODE.Reg)&^(0x3)|value)
}
func (o *USB_Type) GetUSBMODE_CM() uint32 {
	return volatile.LoadUint32(&o.USBMODE.Reg) & 0x3
}
func (o *USB_Type) SetUSBMODE_ES(value uint32) {
	volatile.StoreUint32(&o.USBMODE.Reg, volatile.LoadUint32(&o.USBMODE.Reg)&^(0x4)|value<<2)
}
func (o *USB_Type) GetUSBMODE_ES() uint32 {
	return (volatile.LoadUint32(&o.USBMODE.Reg) & 0x4) >> 2
}
func (o *USB_Type) SetUSBMODE_SLOM(value uint32) {
	volatile.StoreUint32(&o.USBMODE.Reg, volatile.LoadUint32(&o.USBMODE.Reg)&^(0x8)|value<<3)
}
func (o *USB_Type) GetUSBMODE_SLOM() uint32 {
	return (volatile.LoadUint32(&o.USBMODE.Reg) & 0x8) >> 3
}
func (o *USB_Type) SetUSBMODE_SDIS(value uint32) {
	volatile.StoreUint32(&o.USBMODE.Reg, volatile.LoadUint32(&o.USBMODE.Reg)&^(0x10)|value<<4)
}
func (o *USB_Type) GetUSBMODE_SDIS() uint32 {
	return (volatile.LoadUint32(&o.USBMODE.Reg) & 0x10) >> 4
}

// USB.ENDPTSETUPSTAT: Endpoint Setup Status
func (o *USB_Type) SetENDPTSETUPSTAT(value uint32) {
	volatile.StoreUint32(&o.ENDPTSETUPSTAT.Reg, volatile.LoadUint32(&o.ENDPTSETUPSTAT.Reg)&^(0xffff)|value)
}
func (o *USB_Type) GetENDPTSETUPSTAT() uint32 {
	return volatile.LoadUint32(&o.ENDPTSETUPSTAT.Reg) & 0xffff
}

// USB.ENDPTPRIME: Endpoint Prime
func (o *USB_Type) SetENDPTPRIME_PERB(value uint32) {
	volatile.StoreUint32(&o.ENDPTPRIME.Reg, volatile.LoadUint32(&o.ENDPTPRIME.Reg)&^(0xff)|value)
}
func (o *USB_Type) GetENDPTPRIME_PERB() uint32 {
	return volatile.LoadUint32(&o.ENDPTPRIME.Reg) & 0xff
}
func (o *USB_Type) SetENDPTPRIME_PETB(value uint32) {
	volatile.StoreUint32(&o.ENDPTPRIME.Reg, volatile.LoadUint32(&o.ENDPTPRIME.Reg)&^(0xff0000)|value<<16)
}
func (o *USB_Type) GetENDPTPRIME_PETB() uint32 {
	return (volatile.LoadUint32(&o.ENDPTPRIME.Reg) & 0xff0000) >> 16
}

// USB.ENDPTFLUSH: Endpoint Flush
func (o *USB_Type) SetENDPTFLUSH_FERB(value uint32) {
	volatile.StoreUint32(&o.ENDPTFLUSH.Reg, volatile.LoadUint32(&o.ENDPTFLUSH.Reg)&^(0xff)|value)
}
func (o *USB_Type) GetENDPTFLUSH_FERB() uint32 {
	return volatile.LoadUint32(&o.ENDPTFLUSH.Reg) & 0xff
}
func (o *USB_Type) SetENDPTFLUSH_FETB(value uint32) {
	volatile.StoreUint32(&o.ENDPTFLUSH.Reg, volatile.LoadUint32(&o.ENDPTFLUSH.Reg)&^(0xff0000)|value<<16)
}
func (o *USB_Type) GetENDPTFLUSH_FETB() uint32 {
	return (volatile.LoadUint32(&o.ENDPTFLUSH.Reg) & 0xff0000) >> 16
}

// USB.ENDPTSTAT: Endpoint Status
func (o *USB_Type) SetENDPTSTAT_ERBR(value uint32) {
	volatile.StoreUint32(&o.ENDPTSTAT.Reg, volatile.LoadUint32(&o.ENDPTSTAT.Reg)&^(0xff)|value)
}
func (o *USB_Type) GetENDPTSTAT_ERBR() uint32 {
	return volatile.LoadUint32(&o.ENDPTSTAT.Reg) & 0xff
}
func (o *USB_Type) SetENDPTSTAT_ETBR(value uint32) {
	volatile.StoreUint32(&o.ENDPTSTAT.Reg, volatile.LoadUint32(&o.ENDPTSTAT.Reg)&^(0xff0000)|value<<16)
}
func (o *USB_Type) GetENDPTSTAT_ETBR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTSTAT.Reg) & 0xff0000) >> 16
}

// USB.ENDPTCOMPLETE: Endpoint Complete
func (o *USB_Type) SetENDPTCOMPLETE_ERCE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCOMPLETE.Reg, volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg)&^(0xff)|value)
}
func (o *USB_Type) GetENDPTCOMPLETE_ERCE() uint32 {
	return volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg) & 0xff
}
func (o *USB_Type) SetENDPTCOMPLETE_ETCE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCOMPLETE.Reg, volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg)&^(0xff0000)|value<<16)
}
func (o *USB_Type) GetENDPTCOMPLETE_ETCE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCOMPLETE.Reg) & 0xff0000) >> 16
}

// USB.ENDPTCTRL0: Endpoint Control0
func (o *USB_Type) SetENDPTCTRL0_RXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetENDPTCTRL0_RXS() uint32 {
	return volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0x1
}
func (o *USB_Type) SetENDPTCTRL0_RXT(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0xc)|value<<2)
}
func (o *USB_Type) GetENDPTCTRL0_RXT() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0xc) >> 2
}
func (o *USB_Type) SetENDPTCTRL0_RXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetENDPTCTRL0_RXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetENDPTCTRL0_TXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetENDPTCTRL0_TXS() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetENDPTCTRL0_TXT(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetENDPTCTRL0_TXT() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetENDPTCTRL0_TXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL0.Reg, volatile.LoadUint32(&o.ENDPTCTRL0.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetENDPTCTRL0_TXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL0.Reg) & 0x800000) >> 23
}

// USB.ENDPTCTRL1: Endpoint Control 1
func (o *USB_Type) SetENDPTCTRL1_RXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetENDPTCTRL1_RXS() uint32 {
	return volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x1
}
func (o *USB_Type) SetENDPTCTRL1_RXD(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetENDPTCTRL1_RXD() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetENDPTCTRL1_RXT(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0xc)|value<<2)
}
func (o *USB_Type) GetENDPTCTRL1_RXT() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0xc) >> 2
}
func (o *USB_Type) SetENDPTCTRL1_RXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetENDPTCTRL1_RXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetENDPTCTRL1_RXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetENDPTCTRL1_RXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetENDPTCTRL1_RXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetENDPTCTRL1_RXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetENDPTCTRL1_TXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetENDPTCTRL1_TXS() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetENDPTCTRL1_TXD(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetENDPTCTRL1_TXD() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetENDPTCTRL1_TXT(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetENDPTCTRL1_TXT() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetENDPTCTRL1_TXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetENDPTCTRL1_TXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetENDPTCTRL1_TXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetENDPTCTRL1_TXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetENDPTCTRL1_TXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL1.Reg, volatile.LoadUint32(&o.ENDPTCTRL1.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetENDPTCTRL1_TXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL1.Reg) & 0x800000) >> 23
}

// USB.ENDPTCTRL2: Endpoint Control 2
func (o *USB_Type) SetENDPTCTRL2_RXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetENDPTCTRL2_RXS() uint32 {
	return volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x1
}
func (o *USB_Type) SetENDPTCTRL2_RXD(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetENDPTCTRL2_RXD() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetENDPTCTRL2_RXT(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0xc)|value<<2)
}
func (o *USB_Type) GetENDPTCTRL2_RXT() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0xc) >> 2
}
func (o *USB_Type) SetENDPTCTRL2_RXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetENDPTCTRL2_RXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetENDPTCTRL2_RXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetENDPTCTRL2_RXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetENDPTCTRL2_RXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetENDPTCTRL2_RXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetENDPTCTRL2_TXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetENDPTCTRL2_TXS() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetENDPTCTRL2_TXD(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetENDPTCTRL2_TXD() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetENDPTCTRL2_TXT(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetENDPTCTRL2_TXT() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetENDPTCTRL2_TXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetENDPTCTRL2_TXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetENDPTCTRL2_TXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetENDPTCTRL2_TXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetENDPTCTRL2_TXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL2.Reg, volatile.LoadUint32(&o.ENDPTCTRL2.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetENDPTCTRL2_TXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL2.Reg) & 0x800000) >> 23
}

// USB.ENDPTCTRL3: Endpoint Control 3
func (o *USB_Type) SetENDPTCTRL3_RXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetENDPTCTRL3_RXS() uint32 {
	return volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x1
}
func (o *USB_Type) SetENDPTCTRL3_RXD(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetENDPTCTRL3_RXD() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetENDPTCTRL3_RXT(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0xc)|value<<2)
}
func (o *USB_Type) GetENDPTCTRL3_RXT() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0xc) >> 2
}
func (o *USB_Type) SetENDPTCTRL3_RXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetENDPTCTRL3_RXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetENDPTCTRL3_RXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetENDPTCTRL3_RXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetENDPTCTRL3_RXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetENDPTCTRL3_RXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetENDPTCTRL3_TXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetENDPTCTRL3_TXS() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetENDPTCTRL3_TXD(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetENDPTCTRL3_TXD() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetENDPTCTRL3_TXT(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetENDPTCTRL3_TXT() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetENDPTCTRL3_TXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetENDPTCTRL3_TXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetENDPTCTRL3_TXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetENDPTCTRL3_TXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetENDPTCTRL3_TXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL3.Reg, volatile.LoadUint32(&o.ENDPTCTRL3.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetENDPTCTRL3_TXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL3.Reg) & 0x800000) >> 23
}

// USB.ENDPTCTRL4: Endpoint Control 4
func (o *USB_Type) SetENDPTCTRL4_RXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL4.Reg, volatile.LoadUint32(&o.ENDPTCTRL4.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetENDPTCTRL4_RXS() uint32 {
	return volatile.LoadUint32(&o.ENDPTCTRL4.Reg) & 0x1
}
func (o *USB_Type) SetENDPTCTRL4_RXD(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL4.Reg, volatile.LoadUint32(&o.ENDPTCTRL4.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetENDPTCTRL4_RXD() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL4.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetENDPTCTRL4_RXT(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL4.Reg, volatile.LoadUint32(&o.ENDPTCTRL4.Reg)&^(0xc)|value<<2)
}
func (o *USB_Type) GetENDPTCTRL4_RXT() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL4.Reg) & 0xc) >> 2
}
func (o *USB_Type) SetENDPTCTRL4_RXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL4.Reg, volatile.LoadUint32(&o.ENDPTCTRL4.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetENDPTCTRL4_RXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL4.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetENDPTCTRL4_RXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL4.Reg, volatile.LoadUint32(&o.ENDPTCTRL4.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetENDPTCTRL4_RXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL4.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetENDPTCTRL4_RXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL4.Reg, volatile.LoadUint32(&o.ENDPTCTRL4.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetENDPTCTRL4_RXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL4.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetENDPTCTRL4_TXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL4.Reg, volatile.LoadUint32(&o.ENDPTCTRL4.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetENDPTCTRL4_TXS() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL4.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetENDPTCTRL4_TXD(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL4.Reg, volatile.LoadUint32(&o.ENDPTCTRL4.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetENDPTCTRL4_TXD() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL4.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetENDPTCTRL4_TXT(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL4.Reg, volatile.LoadUint32(&o.ENDPTCTRL4.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetENDPTCTRL4_TXT() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL4.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetENDPTCTRL4_TXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL4.Reg, volatile.LoadUint32(&o.ENDPTCTRL4.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetENDPTCTRL4_TXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL4.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetENDPTCTRL4_TXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL4.Reg, volatile.LoadUint32(&o.ENDPTCTRL4.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetENDPTCTRL4_TXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL4.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetENDPTCTRL4_TXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL4.Reg, volatile.LoadUint32(&o.ENDPTCTRL4.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetENDPTCTRL4_TXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL4.Reg) & 0x800000) >> 23
}

// USB.ENDPTCTRL5: Endpoint Control 5
func (o *USB_Type) SetENDPTCTRL5_RXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL5.Reg, volatile.LoadUint32(&o.ENDPTCTRL5.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetENDPTCTRL5_RXS() uint32 {
	return volatile.LoadUint32(&o.ENDPTCTRL5.Reg) & 0x1
}
func (o *USB_Type) SetENDPTCTRL5_RXD(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL5.Reg, volatile.LoadUint32(&o.ENDPTCTRL5.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetENDPTCTRL5_RXD() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL5.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetENDPTCTRL5_RXT(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL5.Reg, volatile.LoadUint32(&o.ENDPTCTRL5.Reg)&^(0xc)|value<<2)
}
func (o *USB_Type) GetENDPTCTRL5_RXT() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL5.Reg) & 0xc) >> 2
}
func (o *USB_Type) SetENDPTCTRL5_RXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL5.Reg, volatile.LoadUint32(&o.ENDPTCTRL5.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetENDPTCTRL5_RXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL5.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetENDPTCTRL5_RXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL5.Reg, volatile.LoadUint32(&o.ENDPTCTRL5.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetENDPTCTRL5_RXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL5.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetENDPTCTRL5_RXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL5.Reg, volatile.LoadUint32(&o.ENDPTCTRL5.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetENDPTCTRL5_RXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL5.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetENDPTCTRL5_TXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL5.Reg, volatile.LoadUint32(&o.ENDPTCTRL5.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetENDPTCTRL5_TXS() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL5.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetENDPTCTRL5_TXD(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL5.Reg, volatile.LoadUint32(&o.ENDPTCTRL5.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetENDPTCTRL5_TXD() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL5.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetENDPTCTRL5_TXT(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL5.Reg, volatile.LoadUint32(&o.ENDPTCTRL5.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetENDPTCTRL5_TXT() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL5.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetENDPTCTRL5_TXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL5.Reg, volatile.LoadUint32(&o.ENDPTCTRL5.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetENDPTCTRL5_TXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL5.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetENDPTCTRL5_TXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL5.Reg, volatile.LoadUint32(&o.ENDPTCTRL5.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetENDPTCTRL5_TXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL5.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetENDPTCTRL5_TXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL5.Reg, volatile.LoadUint32(&o.ENDPTCTRL5.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetENDPTCTRL5_TXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL5.Reg) & 0x800000) >> 23
}

// USB.ENDPTCTRL6: Endpoint Control 6
func (o *USB_Type) SetENDPTCTRL6_RXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL6.Reg, volatile.LoadUint32(&o.ENDPTCTRL6.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetENDPTCTRL6_RXS() uint32 {
	return volatile.LoadUint32(&o.ENDPTCTRL6.Reg) & 0x1
}
func (o *USB_Type) SetENDPTCTRL6_RXD(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL6.Reg, volatile.LoadUint32(&o.ENDPTCTRL6.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetENDPTCTRL6_RXD() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL6.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetENDPTCTRL6_RXT(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL6.Reg, volatile.LoadUint32(&o.ENDPTCTRL6.Reg)&^(0xc)|value<<2)
}
func (o *USB_Type) GetENDPTCTRL6_RXT() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL6.Reg) & 0xc) >> 2
}
func (o *USB_Type) SetENDPTCTRL6_RXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL6.Reg, volatile.LoadUint32(&o.ENDPTCTRL6.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetENDPTCTRL6_RXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL6.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetENDPTCTRL6_RXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL6.Reg, volatile.LoadUint32(&o.ENDPTCTRL6.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetENDPTCTRL6_RXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL6.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetENDPTCTRL6_RXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL6.Reg, volatile.LoadUint32(&o.ENDPTCTRL6.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetENDPTCTRL6_RXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL6.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetENDPTCTRL6_TXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL6.Reg, volatile.LoadUint32(&o.ENDPTCTRL6.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetENDPTCTRL6_TXS() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL6.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetENDPTCTRL6_TXD(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL6.Reg, volatile.LoadUint32(&o.ENDPTCTRL6.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetENDPTCTRL6_TXD() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL6.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetENDPTCTRL6_TXT(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL6.Reg, volatile.LoadUint32(&o.ENDPTCTRL6.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetENDPTCTRL6_TXT() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL6.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetENDPTCTRL6_TXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL6.Reg, volatile.LoadUint32(&o.ENDPTCTRL6.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetENDPTCTRL6_TXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL6.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetENDPTCTRL6_TXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL6.Reg, volatile.LoadUint32(&o.ENDPTCTRL6.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetENDPTCTRL6_TXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL6.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetENDPTCTRL6_TXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL6.Reg, volatile.LoadUint32(&o.ENDPTCTRL6.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetENDPTCTRL6_TXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL6.Reg) & 0x800000) >> 23
}

// USB.ENDPTCTRL7: Endpoint Control 7
func (o *USB_Type) SetENDPTCTRL7_RXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL7.Reg, volatile.LoadUint32(&o.ENDPTCTRL7.Reg)&^(0x1)|value)
}
func (o *USB_Type) GetENDPTCTRL7_RXS() uint32 {
	return volatile.LoadUint32(&o.ENDPTCTRL7.Reg) & 0x1
}
func (o *USB_Type) SetENDPTCTRL7_RXD(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL7.Reg, volatile.LoadUint32(&o.ENDPTCTRL7.Reg)&^(0x2)|value<<1)
}
func (o *USB_Type) GetENDPTCTRL7_RXD() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL7.Reg) & 0x2) >> 1
}
func (o *USB_Type) SetENDPTCTRL7_RXT(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL7.Reg, volatile.LoadUint32(&o.ENDPTCTRL7.Reg)&^(0xc)|value<<2)
}
func (o *USB_Type) GetENDPTCTRL7_RXT() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL7.Reg) & 0xc) >> 2
}
func (o *USB_Type) SetENDPTCTRL7_RXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL7.Reg, volatile.LoadUint32(&o.ENDPTCTRL7.Reg)&^(0x20)|value<<5)
}
func (o *USB_Type) GetENDPTCTRL7_RXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL7.Reg) & 0x20) >> 5
}
func (o *USB_Type) SetENDPTCTRL7_RXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL7.Reg, volatile.LoadUint32(&o.ENDPTCTRL7.Reg)&^(0x40)|value<<6)
}
func (o *USB_Type) GetENDPTCTRL7_RXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL7.Reg) & 0x40) >> 6
}
func (o *USB_Type) SetENDPTCTRL7_RXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL7.Reg, volatile.LoadUint32(&o.ENDPTCTRL7.Reg)&^(0x80)|value<<7)
}
func (o *USB_Type) GetENDPTCTRL7_RXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL7.Reg) & 0x80) >> 7
}
func (o *USB_Type) SetENDPTCTRL7_TXS(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL7.Reg, volatile.LoadUint32(&o.ENDPTCTRL7.Reg)&^(0x10000)|value<<16)
}
func (o *USB_Type) GetENDPTCTRL7_TXS() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL7.Reg) & 0x10000) >> 16
}
func (o *USB_Type) SetENDPTCTRL7_TXD(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL7.Reg, volatile.LoadUint32(&o.ENDPTCTRL7.Reg)&^(0x20000)|value<<17)
}
func (o *USB_Type) GetENDPTCTRL7_TXD() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL7.Reg) & 0x20000) >> 17
}
func (o *USB_Type) SetENDPTCTRL7_TXT(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL7.Reg, volatile.LoadUint32(&o.ENDPTCTRL7.Reg)&^(0xc0000)|value<<18)
}
func (o *USB_Type) GetENDPTCTRL7_TXT() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL7.Reg) & 0xc0000) >> 18
}
func (o *USB_Type) SetENDPTCTRL7_TXI(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL7.Reg, volatile.LoadUint32(&o.ENDPTCTRL7.Reg)&^(0x200000)|value<<21)
}
func (o *USB_Type) GetENDPTCTRL7_TXI() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL7.Reg) & 0x200000) >> 21
}
func (o *USB_Type) SetENDPTCTRL7_TXR(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL7.Reg, volatile.LoadUint32(&o.ENDPTCTRL7.Reg)&^(0x400000)|value<<22)
}
func (o *USB_Type) GetENDPTCTRL7_TXR() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL7.Reg) & 0x400000) >> 22
}
func (o *USB_Type) SetENDPTCTRL7_TXE(value uint32) {
	volatile.StoreUint32(&o.ENDPTCTRL7.Reg, volatile.LoadUint32(&o.ENDPTCTRL7.Reg)&^(0x800000)|value<<23)
}
func (o *USB_Type) GetENDPTCTRL7_TXE() uint32 {
	return (volatile.LoadUint32(&o.ENDPTCTRL7.Reg) & 0x800000) >> 23
}

// USB
type USBNC_Type struct {
	_                   [2048]byte
	USB_OTG1_CTRL       volatile.Register32 // 0x800
	_                   [20]byte
	USB_OTG1_PHY_CTRL_0 volatile.Register32 // 0x818
}

// USBNC.USB_OTG1_CTRL: USB OTG1 Control Register
func (o *USBNC_Type) SetUSB_OTG1_CTRL_OVER_CUR_DIS(value uint32) {
	volatile.StoreUint32(&o.USB_OTG1_CTRL.Reg, volatile.LoadUint32(&o.USB_OTG1_CTRL.Reg)&^(0x80)|value<<7)
}
func (o *USBNC_Type) GetUSB_OTG1_CTRL_OVER_CUR_DIS() uint32 {
	return (volatile.LoadUint32(&o.USB_OTG1_CTRL.Reg) & 0x80) >> 7
}
func (o *USBNC_Type) SetUSB_OTG1_CTRL_OVER_CUR_POL(value uint32) {
	volatile.StoreUint32(&o.USB_OTG1_CTRL.Reg, volatile.LoadUint32(&o.USB_OTG1_CTRL.Reg)&^(0x100)|value<<8)
}
func (o *USBNC_Type) GetUSB_OTG1_CTRL_OVER_CUR_POL() uint32 {
	return (volatile.LoadUint32(&o.USB_OTG1_CTRL.Reg) & 0x100) >> 8
}
func (o *USBNC_Type) SetUSB_OTG1_CTRL_PWR_POL(value uint32) {
	volatile.StoreUint32(&o.USB_OTG1_CTRL.Reg, volatile.LoadUint32(&o.USB_OTG1_CTRL.Reg)&^(0x200)|value<<9)
}
func (o *USBNC_Type) GetUSB_OTG1_CTRL_PWR_POL() uint32 {
	return (volatile.LoadUint32(&o.USB_OTG1_CTRL.Reg) & 0x200) >> 9
}
func (o *USBNC_Type) SetUSB_OTG1_CTRL_WIE(value uint32) {
	volatile.StoreUint32(&o.USB_OTG1_CTRL.Reg, volatile.LoadUint32(&o.USB_OTG1_CTRL.Reg)&^(0x400)|value<<10)
}
func (o *USBNC_Type) GetUSB_OTG1_CTRL_WIE() uint32 {
	return (volatile.LoadUint32(&o.USB_OTG1_CTRL.Reg) & 0x400) >> 10
}
func (o *USBNC_Type) SetUSB_OTG1_CTRL_WKUP_SW_EN(value uint32) {
	volatile.StoreUint32(&o.USB_OTG1_CTRL.Reg, volatile.LoadUint32(&o.USB_OTG1_CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *USBNC_Type) GetUSB_OTG1_CTRL_WKUP_SW_EN() uint32 {
	return (volatile.LoadUint32(&o.USB_OTG1_CTRL.Reg) & 0x4000) >> 14
}
func (o *USBNC_Type) SetUSB_OTG1_CTRL_WKUP_SW(value uint32) {
	volatile.StoreUint32(&o.USB_OTG1_CTRL.Reg, volatile.LoadUint32(&o.USB_OTG1_CTRL.Reg)&^(0x8000)|value<<15)
}
func (o *USBNC_Type) GetUSB_OTG1_CTRL_WKUP_SW() uint32 {
	return (volatile.LoadUint32(&o.USB_OTG1_CTRL.Reg) & 0x8000) >> 15
}
func (o *USBNC_Type) SetUSB_OTG1_CTRL_WKUP_ID_EN(value uint32) {
	volatile.StoreUint32(&o.USB_OTG1_CTRL.Reg, volatile.LoadUint32(&o.USB_OTG1_CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *USBNC_Type) GetUSB_OTG1_CTRL_WKUP_ID_EN() uint32 {
	return (volatile.LoadUint32(&o.USB_OTG1_CTRL.Reg) & 0x10000) >> 16
}
func (o *USBNC_Type) SetUSB_OTG1_CTRL_WKUP_VBUS_EN(value uint32) {
	volatile.StoreUint32(&o.USB_OTG1_CTRL.Reg, volatile.LoadUint32(&o.USB_OTG1_CTRL.Reg)&^(0x20000)|value<<17)
}
func (o *USBNC_Type) GetUSB_OTG1_CTRL_WKUP_VBUS_EN() uint32 {
	return (volatile.LoadUint32(&o.USB_OTG1_CTRL.Reg) & 0x20000) >> 17
}
func (o *USBNC_Type) SetUSB_OTG1_CTRL_WKUP_DPDM_EN(value uint32) {
	volatile.StoreUint32(&o.USB_OTG1_CTRL.Reg, volatile.LoadUint32(&o.USB_OTG1_CTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *USBNC_Type) GetUSB_OTG1_CTRL_WKUP_DPDM_EN() uint32 {
	return (volatile.LoadUint32(&o.USB_OTG1_CTRL.Reg) & 0x20000000) >> 29
}
func (o *USBNC_Type) SetUSB_OTG1_CTRL_WIR(value uint32) {
	volatile.StoreUint32(&o.USB_OTG1_CTRL.Reg, volatile.LoadUint32(&o.USB_OTG1_CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *USBNC_Type) GetUSB_OTG1_CTRL_WIR() uint32 {
	return (volatile.LoadUint32(&o.USB_OTG1_CTRL.Reg) & 0x80000000) >> 31
}

// USBNC.USB_OTG1_PHY_CTRL_0: OTG1 UTMI PHY Control 0 Register
func (o *USBNC_Type) SetUSB_OTG1_PHY_CTRL_0_UTMI_CLK_VLD(value uint32) {
	volatile.StoreUint32(&o.USB_OTG1_PHY_CTRL_0.Reg, volatile.LoadUint32(&o.USB_OTG1_PHY_CTRL_0.Reg)&^(0x80000000)|value<<31)
}
func (o *USBNC_Type) GetUSB_OTG1_PHY_CTRL_0_UTMI_CLK_VLD() uint32 {
	return (volatile.LoadUint32(&o.USB_OTG1_PHY_CTRL_0.Reg) & 0x80000000) >> 31
}

// DMA
type DMA_Type struct {
	CR                  volatile.Register32 // 0x0
	ES                  volatile.Register32 // 0x4
	_                   [4]byte
	ERQ                 volatile.Register32 // 0xC
	_                   [4]byte
	EEI                 volatile.Register32 // 0x14
	CEEI                volatile.Register8  // 0x18
	SEEI                volatile.Register8  // 0x19
	CERQ                volatile.Register8  // 0x1A
	SERQ                volatile.Register8  // 0x1B
	CDNE                volatile.Register8  // 0x1C
	SSRT                volatile.Register8  // 0x1D
	CERR                volatile.Register8  // 0x1E
	CINT                volatile.Register8  // 0x1F
	_                   [4]byte
	INT                 volatile.Register32 // 0x24
	_                   [4]byte
	ERR                 volatile.Register32 // 0x2C
	_                   [4]byte
	HRS                 volatile.Register32 // 0x34
	_                   [12]byte
	EARS                volatile.Register32 // 0x44
	_                   [184]byte
	DCHPRI3             volatile.Register8 // 0x100
	DCHPRI2             volatile.Register8 // 0x101
	DCHPRI1             volatile.Register8 // 0x102
	DCHPRI0             volatile.Register8 // 0x103
	DCHPRI7             volatile.Register8 // 0x104
	DCHPRI6             volatile.Register8 // 0x105
	DCHPRI5             volatile.Register8 // 0x106
	DCHPRI4             volatile.Register8 // 0x107
	DCHPRI11            volatile.Register8 // 0x108
	DCHPRI10            volatile.Register8 // 0x109
	DCHPRI9             volatile.Register8 // 0x10A
	DCHPRI8             volatile.Register8 // 0x10B
	DCHPRI15            volatile.Register8 // 0x10C
	DCHPRI14            volatile.Register8 // 0x10D
	DCHPRI13            volatile.Register8 // 0x10E
	DCHPRI12            volatile.Register8 // 0x10F
	_                   [3824]byte
	TCD0_SADDR          volatile.Register32 // 0x1000
	TCD0_SOFF           volatile.Register16 // 0x1004
	TCD0_ATTR           volatile.Register16 // 0x1006
	TCD0_NBYTES_MLNO    volatile.Register32 // 0x1008
	TCD0_SLAST          volatile.Register32 // 0x100C
	TCD0_DADDR          volatile.Register32 // 0x1010
	TCD0_DOFF           volatile.Register16 // 0x1014
	TCD0_CITER_ELINKNO  volatile.Register16 // 0x1016
	TCD0_DLASTSGA       volatile.Register32 // 0x1018
	TCD0_CSR            volatile.Register16 // 0x101C
	TCD0_BITER_ELINKNO  volatile.Register16 // 0x101E
	TCD1_SADDR          volatile.Register32 // 0x1020
	TCD1_SOFF           volatile.Register16 // 0x1024
	TCD1_ATTR           volatile.Register16 // 0x1026
	TCD1_NBYTES_MLNO    volatile.Register32 // 0x1028
	TCD1_SLAST          volatile.Register32 // 0x102C
	TCD1_DADDR          volatile.Register32 // 0x1030
	TCD1_DOFF           volatile.Register16 // 0x1034
	TCD1_CITER_ELINKNO  volatile.Register16 // 0x1036
	TCD1_DLASTSGA       volatile.Register32 // 0x1038
	TCD1_CSR            volatile.Register16 // 0x103C
	TCD1_BITER_ELINKNO  volatile.Register16 // 0x103E
	TCD2_SADDR          volatile.Register32 // 0x1040
	TCD2_SOFF           volatile.Register16 // 0x1044
	TCD2_ATTR           volatile.Register16 // 0x1046
	TCD2_NBYTES_MLNO    volatile.Register32 // 0x1048
	TCD2_SLAST          volatile.Register32 // 0x104C
	TCD2_DADDR          volatile.Register32 // 0x1050
	TCD2_DOFF           volatile.Register16 // 0x1054
	TCD2_CITER_ELINKNO  volatile.Register16 // 0x1056
	TCD2_DLASTSGA       volatile.Register32 // 0x1058
	TCD2_CSR            volatile.Register16 // 0x105C
	TCD2_BITER_ELINKNO  volatile.Register16 // 0x105E
	TCD3_SADDR          volatile.Register32 // 0x1060
	TCD3_SOFF           volatile.Register16 // 0x1064
	TCD3_ATTR           volatile.Register16 // 0x1066
	TCD3_NBYTES_MLNO    volatile.Register32 // 0x1068
	TCD3_SLAST          volatile.Register32 // 0x106C
	TCD3_DADDR          volatile.Register32 // 0x1070
	TCD3_DOFF           volatile.Register16 // 0x1074
	TCD3_CITER_ELINKNO  volatile.Register16 // 0x1076
	TCD3_DLASTSGA       volatile.Register32 // 0x1078
	TCD3_CSR            volatile.Register16 // 0x107C
	TCD3_BITER_ELINKNO  volatile.Register16 // 0x107E
	TCD4_SADDR          volatile.Register32 // 0x1080
	TCD4_SOFF           volatile.Register16 // 0x1084
	TCD4_ATTR           volatile.Register16 // 0x1086
	TCD4_NBYTES_MLNO    volatile.Register32 // 0x1088
	TCD4_SLAST          volatile.Register32 // 0x108C
	TCD4_DADDR          volatile.Register32 // 0x1090
	TCD4_DOFF           volatile.Register16 // 0x1094
	TCD4_CITER_ELINKNO  volatile.Register16 // 0x1096
	TCD4_DLASTSGA       volatile.Register32 // 0x1098
	TCD4_CSR            volatile.Register16 // 0x109C
	TCD4_BITER_ELINKNO  volatile.Register16 // 0x109E
	TCD5_SADDR          volatile.Register32 // 0x10A0
	TCD5_SOFF           volatile.Register16 // 0x10A4
	TCD5_ATTR           volatile.Register16 // 0x10A6
	TCD5_NBYTES_MLNO    volatile.Register32 // 0x10A8
	TCD5_SLAST          volatile.Register32 // 0x10AC
	TCD5_DADDR          volatile.Register32 // 0x10B0
	TCD5_DOFF           volatile.Register16 // 0x10B4
	TCD5_CITER_ELINKNO  volatile.Register16 // 0x10B6
	TCD5_DLASTSGA       volatile.Register32 // 0x10B8
	TCD5_CSR            volatile.Register16 // 0x10BC
	TCD5_BITER_ELINKNO  volatile.Register16 // 0x10BE
	TCD6_SADDR          volatile.Register32 // 0x10C0
	TCD6_SOFF           volatile.Register16 // 0x10C4
	TCD6_ATTR           volatile.Register16 // 0x10C6
	TCD6_NBYTES_MLNO    volatile.Register32 // 0x10C8
	TCD6_SLAST          volatile.Register32 // 0x10CC
	TCD6_DADDR          volatile.Register32 // 0x10D0
	TCD6_DOFF           volatile.Register16 // 0x10D4
	TCD6_CITER_ELINKNO  volatile.Register16 // 0x10D6
	TCD6_DLASTSGA       volatile.Register32 // 0x10D8
	TCD6_CSR            volatile.Register16 // 0x10DC
	TCD6_BITER_ELINKNO  volatile.Register16 // 0x10DE
	TCD7_SADDR          volatile.Register32 // 0x10E0
	TCD7_SOFF           volatile.Register16 // 0x10E4
	TCD7_ATTR           volatile.Register16 // 0x10E6
	TCD7_NBYTES_MLNO    volatile.Register32 // 0x10E8
	TCD7_SLAST          volatile.Register32 // 0x10EC
	TCD7_DADDR          volatile.Register32 // 0x10F0
	TCD7_DOFF           volatile.Register16 // 0x10F4
	TCD7_CITER_ELINKNO  volatile.Register16 // 0x10F6
	TCD7_DLASTSGA       volatile.Register32 // 0x10F8
	TCD7_CSR            volatile.Register16 // 0x10FC
	TCD7_BITER_ELINKNO  volatile.Register16 // 0x10FE
	TCD8_SADDR          volatile.Register32 // 0x1100
	TCD8_SOFF           volatile.Register16 // 0x1104
	TCD8_ATTR           volatile.Register16 // 0x1106
	TCD8_NBYTES_MLNO    volatile.Register32 // 0x1108
	TCD8_SLAST          volatile.Register32 // 0x110C
	TCD8_DADDR          volatile.Register32 // 0x1110
	TCD8_DOFF           volatile.Register16 // 0x1114
	TCD8_CITER_ELINKNO  volatile.Register16 // 0x1116
	TCD8_DLASTSGA       volatile.Register32 // 0x1118
	TCD8_CSR            volatile.Register16 // 0x111C
	TCD8_BITER_ELINKNO  volatile.Register16 // 0x111E
	TCD9_SADDR          volatile.Register32 // 0x1120
	TCD9_SOFF           volatile.Register16 // 0x1124
	TCD9_ATTR           volatile.Register16 // 0x1126
	TCD9_NBYTES_MLNO    volatile.Register32 // 0x1128
	TCD9_SLAST          volatile.Register32 // 0x112C
	TCD9_DADDR          volatile.Register32 // 0x1130
	TCD9_DOFF           volatile.Register16 // 0x1134
	TCD9_CITER_ELINKNO  volatile.Register16 // 0x1136
	TCD9_DLASTSGA       volatile.Register32 // 0x1138
	TCD9_CSR            volatile.Register16 // 0x113C
	TCD9_BITER_ELINKNO  volatile.Register16 // 0x113E
	TCD10_SADDR         volatile.Register32 // 0x1140
	TCD10_SOFF          volatile.Register16 // 0x1144
	TCD10_ATTR          volatile.Register16 // 0x1146
	TCD10_NBYTES_MLNO   volatile.Register32 // 0x1148
	TCD10_SLAST         volatile.Register32 // 0x114C
	TCD10_DADDR         volatile.Register32 // 0x1150
	TCD10_DOFF          volatile.Register16 // 0x1154
	TCD10_CITER_ELINKNO volatile.Register16 // 0x1156
	TCD10_DLASTSGA      volatile.Register32 // 0x1158
	TCD10_CSR           volatile.Register16 // 0x115C
	TCD10_BITER_ELINKNO volatile.Register16 // 0x115E
	TCD11_SADDR         volatile.Register32 // 0x1160
	TCD11_SOFF          volatile.Register16 // 0x1164
	TCD11_ATTR          volatile.Register16 // 0x1166
	TCD11_NBYTES_MLNO   volatile.Register32 // 0x1168
	TCD11_SLAST         volatile.Register32 // 0x116C
	TCD11_DADDR         volatile.Register32 // 0x1170
	TCD11_DOFF          volatile.Register16 // 0x1174
	TCD11_CITER_ELINKNO volatile.Register16 // 0x1176
	TCD11_DLASTSGA      volatile.Register32 // 0x1178
	TCD11_CSR           volatile.Register16 // 0x117C
	TCD11_BITER_ELINKNO volatile.Register16 // 0x117E
	TCD12_SADDR         volatile.Register32 // 0x1180
	TCD12_SOFF          volatile.Register16 // 0x1184
	TCD12_ATTR          volatile.Register16 // 0x1186
	TCD12_NBYTES_MLNO   volatile.Register32 // 0x1188
	TCD12_SLAST         volatile.Register32 // 0x118C
	TCD12_DADDR         volatile.Register32 // 0x1190
	TCD12_DOFF          volatile.Register16 // 0x1194
	TCD12_CITER_ELINKNO volatile.Register16 // 0x1196
	TCD12_DLASTSGA      volatile.Register32 // 0x1198
	TCD12_CSR           volatile.Register16 // 0x119C
	TCD12_BITER_ELINKNO volatile.Register16 // 0x119E
	TCD13_SADDR         volatile.Register32 // 0x11A0
	TCD13_SOFF          volatile.Register16 // 0x11A4
	TCD13_ATTR          volatile.Register16 // 0x11A6
	TCD13_NBYTES_MLNO   volatile.Register32 // 0x11A8
	TCD13_SLAST         volatile.Register32 // 0x11AC
	TCD13_DADDR         volatile.Register32 // 0x11B0
	TCD13_DOFF          volatile.Register16 // 0x11B4
	TCD13_CITER_ELINKNO volatile.Register16 // 0x11B6
	TCD13_DLASTSGA      volatile.Register32 // 0x11B8
	TCD13_CSR           volatile.Register16 // 0x11BC
	TCD13_BITER_ELINKNO volatile.Register16 // 0x11BE
	TCD14_SADDR         volatile.Register32 // 0x11C0
	TCD14_SOFF          volatile.Register16 // 0x11C4
	TCD14_ATTR          volatile.Register16 // 0x11C6
	TCD14_NBYTES_MLNO   volatile.Register32 // 0x11C8
	TCD14_SLAST         volatile.Register32 // 0x11CC
	TCD14_DADDR         volatile.Register32 // 0x11D0
	TCD14_DOFF          volatile.Register16 // 0x11D4
	TCD14_CITER_ELINKNO volatile.Register16 // 0x11D6
	TCD14_DLASTSGA      volatile.Register32 // 0x11D8
	TCD14_CSR           volatile.Register16 // 0x11DC
	TCD14_BITER_ELINKNO volatile.Register16 // 0x11DE
	TCD15_SADDR         volatile.Register32 // 0x11E0
	TCD15_SOFF          volatile.Register16 // 0x11E4
	TCD15_ATTR          volatile.Register16 // 0x11E6
	TCD15_NBYTES_MLNO   volatile.Register32 // 0x11E8
	TCD15_SLAST         volatile.Register32 // 0x11EC
	TCD15_DADDR         volatile.Register32 // 0x11F0
	TCD15_DOFF          volatile.Register16 // 0x11F4
	TCD15_CITER_ELINKNO volatile.Register16 // 0x11F6
	TCD15_DLASTSGA      volatile.Register32 // 0x11F8
	TCD15_CSR           volatile.Register16 // 0x11FC
	TCD15_BITER_ELINKNO volatile.Register16 // 0x11FE
}

// DMA.CR: Control Register
func (o *DMA_Type) SetCR_EDBG(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetCR_EDBG() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetCR_ERCA(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetCR_ERCA() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetCR_HOE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetCR_HOE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetCR_HALT(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetCR_HALT() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetCR_CLM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCR_CLM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCR_EMLM(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCR_EMLM() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetCR_ECX(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *DMA_Type) GetCR_ECX() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *DMA_Type) SetCR_CX(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000)|value<<17)
}
func (o *DMA_Type) GetCR_CX() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000) >> 17
}
func (o *DMA_Type) SetCR_ACTIVE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000000)|value<<31)
}
func (o *DMA_Type) GetCR_ACTIVE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000000) >> 31
}

// DMA.ES: Error Status Register
func (o *DMA_Type) SetES_DBE(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetES_DBE() uint32 {
	return volatile.LoadUint32(&o.ES.Reg) & 0x1
}
func (o *DMA_Type) SetES_SBE(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetES_SBE() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetES_SGE(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetES_SGE() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetES_NCE(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetES_NCE() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetES_DOE(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetES_DOE() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetES_DAE(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetES_DAE() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetES_SOE(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetES_SOE() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetES_SAE(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetES_SAE() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetES_ERRCHN(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetES_ERRCHN() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetES_CPE(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetES_CPE() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetES_ECX(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x10000)|value<<16)
}
func (o *DMA_Type) GetES_ECX() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x10000) >> 16
}
func (o *DMA_Type) SetES_VLD(value uint32) {
	volatile.StoreUint32(&o.ES.Reg, volatile.LoadUint32(&o.ES.Reg)&^(0x80000000)|value<<31)
}
func (o *DMA_Type) GetES_VLD() uint32 {
	return (volatile.LoadUint32(&o.ES.Reg) & 0x80000000) >> 31
}

// DMA.ERQ: Enable Request Register
func (o *DMA_Type) SetERQ_ERQ0(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetERQ_ERQ0() uint32 {
	return volatile.LoadUint32(&o.ERQ.Reg) & 0x1
}
func (o *DMA_Type) SetERQ_ERQ1(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetERQ_ERQ1() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetERQ_ERQ2(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetERQ_ERQ2() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetERQ_ERQ3(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetERQ_ERQ3() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetERQ_ERQ4(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetERQ_ERQ4() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetERQ_ERQ5(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetERQ_ERQ5() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetERQ_ERQ6(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetERQ_ERQ6() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetERQ_ERQ7(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetERQ_ERQ7() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetERQ_ERQ8(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetERQ_ERQ8() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetERQ_ERQ9(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetERQ_ERQ9() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetERQ_ERQ10(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetERQ_ERQ10() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetERQ_ERQ11(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetERQ_ERQ11() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetERQ_ERQ12(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetERQ_ERQ12() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x1000) >> 12
}
func (o *DMA_Type) SetERQ_ERQ13(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x2000)|value<<13)
}
func (o *DMA_Type) GetERQ_ERQ13() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x2000) >> 13
}
func (o *DMA_Type) SetERQ_ERQ14(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetERQ_ERQ14() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetERQ_ERQ15(value uint32) {
	volatile.StoreUint32(&o.ERQ.Reg, volatile.LoadUint32(&o.ERQ.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetERQ_ERQ15() uint32 {
	return (volatile.LoadUint32(&o.ERQ.Reg) & 0x8000) >> 15
}

// DMA.EEI: Enable Error Interrupt Register
func (o *DMA_Type) SetEEI_EEI0(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetEEI_EEI0() uint32 {
	return volatile.LoadUint32(&o.EEI.Reg) & 0x1
}
func (o *DMA_Type) SetEEI_EEI1(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetEEI_EEI1() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetEEI_EEI2(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetEEI_EEI2() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetEEI_EEI3(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetEEI_EEI3() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetEEI_EEI4(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetEEI_EEI4() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetEEI_EEI5(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetEEI_EEI5() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetEEI_EEI6(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetEEI_EEI6() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetEEI_EEI7(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetEEI_EEI7() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetEEI_EEI8(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetEEI_EEI8() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetEEI_EEI9(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetEEI_EEI9() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetEEI_EEI10(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetEEI_EEI10() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetEEI_EEI11(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetEEI_EEI11() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetEEI_EEI12(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetEEI_EEI12() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x1000) >> 12
}
func (o *DMA_Type) SetEEI_EEI13(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x2000)|value<<13)
}
func (o *DMA_Type) GetEEI_EEI13() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x2000) >> 13
}
func (o *DMA_Type) SetEEI_EEI14(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetEEI_EEI14() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetEEI_EEI15(value uint32) {
	volatile.StoreUint32(&o.EEI.Reg, volatile.LoadUint32(&o.EEI.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetEEI_EEI15() uint32 {
	return (volatile.LoadUint32(&o.EEI.Reg) & 0x8000) >> 15
}

// DMA.CEEI: Clear Enable Error Interrupt Register
func (o *DMA_Type) SetCEEI(value uint8) {
	volatile.StoreUint8(&o.CEEI.Reg, volatile.LoadUint8(&o.CEEI.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetCEEI() uint8 {
	return volatile.LoadUint8(&o.CEEI.Reg) & 0xf
}
func (o *DMA_Type) SetCEEI_CAEE(value uint8) {
	volatile.StoreUint8(&o.CEEI.Reg, volatile.LoadUint8(&o.CEEI.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCEEI_CAEE() uint8 {
	return (volatile.LoadUint8(&o.CEEI.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCEEI_NOP(value uint8) {
	volatile.StoreUint8(&o.CEEI.Reg, volatile.LoadUint8(&o.CEEI.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCEEI_NOP() uint8 {
	return (volatile.LoadUint8(&o.CEEI.Reg) & 0x80) >> 7
}

// DMA.SEEI: Set Enable Error Interrupt Register
func (o *DMA_Type) SetSEEI(value uint8) {
	volatile.StoreUint8(&o.SEEI.Reg, volatile.LoadUint8(&o.SEEI.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetSEEI() uint8 {
	return volatile.LoadUint8(&o.SEEI.Reg) & 0xf
}
func (o *DMA_Type) SetSEEI_SAEE(value uint8) {
	volatile.StoreUint8(&o.SEEI.Reg, volatile.LoadUint8(&o.SEEI.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetSEEI_SAEE() uint8 {
	return (volatile.LoadUint8(&o.SEEI.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetSEEI_NOP(value uint8) {
	volatile.StoreUint8(&o.SEEI.Reg, volatile.LoadUint8(&o.SEEI.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetSEEI_NOP() uint8 {
	return (volatile.LoadUint8(&o.SEEI.Reg) & 0x80) >> 7
}

// DMA.CERQ: Clear Enable Request Register
func (o *DMA_Type) SetCERQ(value uint8) {
	volatile.StoreUint8(&o.CERQ.Reg, volatile.LoadUint8(&o.CERQ.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetCERQ() uint8 {
	return volatile.LoadUint8(&o.CERQ.Reg) & 0xf
}
func (o *DMA_Type) SetCERQ_CAER(value uint8) {
	volatile.StoreUint8(&o.CERQ.Reg, volatile.LoadUint8(&o.CERQ.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCERQ_CAER() uint8 {
	return (volatile.LoadUint8(&o.CERQ.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCERQ_NOP(value uint8) {
	volatile.StoreUint8(&o.CERQ.Reg, volatile.LoadUint8(&o.CERQ.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCERQ_NOP() uint8 {
	return (volatile.LoadUint8(&o.CERQ.Reg) & 0x80) >> 7
}

// DMA.SERQ: Set Enable Request Register
func (o *DMA_Type) SetSERQ(value uint8) {
	volatile.StoreUint8(&o.SERQ.Reg, volatile.LoadUint8(&o.SERQ.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetSERQ() uint8 {
	return volatile.LoadUint8(&o.SERQ.Reg) & 0xf
}
func (o *DMA_Type) SetSERQ_SAER(value uint8) {
	volatile.StoreUint8(&o.SERQ.Reg, volatile.LoadUint8(&o.SERQ.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetSERQ_SAER() uint8 {
	return (volatile.LoadUint8(&o.SERQ.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetSERQ_NOP(value uint8) {
	volatile.StoreUint8(&o.SERQ.Reg, volatile.LoadUint8(&o.SERQ.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetSERQ_NOP() uint8 {
	return (volatile.LoadUint8(&o.SERQ.Reg) & 0x80) >> 7
}

// DMA.CDNE: Clear DONE Status Bit Register
func (o *DMA_Type) SetCDNE(value uint8) {
	volatile.StoreUint8(&o.CDNE.Reg, volatile.LoadUint8(&o.CDNE.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetCDNE() uint8 {
	return volatile.LoadUint8(&o.CDNE.Reg) & 0xf
}
func (o *DMA_Type) SetCDNE_CADN(value uint8) {
	volatile.StoreUint8(&o.CDNE.Reg, volatile.LoadUint8(&o.CDNE.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCDNE_CADN() uint8 {
	return (volatile.LoadUint8(&o.CDNE.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCDNE_NOP(value uint8) {
	volatile.StoreUint8(&o.CDNE.Reg, volatile.LoadUint8(&o.CDNE.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCDNE_NOP() uint8 {
	return (volatile.LoadUint8(&o.CDNE.Reg) & 0x80) >> 7
}

// DMA.SSRT: Set START Bit Register
func (o *DMA_Type) SetSSRT(value uint8) {
	volatile.StoreUint8(&o.SSRT.Reg, volatile.LoadUint8(&o.SSRT.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetSSRT() uint8 {
	return volatile.LoadUint8(&o.SSRT.Reg) & 0xf
}
func (o *DMA_Type) SetSSRT_SAST(value uint8) {
	volatile.StoreUint8(&o.SSRT.Reg, volatile.LoadUint8(&o.SSRT.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetSSRT_SAST() uint8 {
	return (volatile.LoadUint8(&o.SSRT.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetSSRT_NOP(value uint8) {
	volatile.StoreUint8(&o.SSRT.Reg, volatile.LoadUint8(&o.SSRT.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetSSRT_NOP() uint8 {
	return (volatile.LoadUint8(&o.SSRT.Reg) & 0x80) >> 7
}

// DMA.CERR: Clear Error Register
func (o *DMA_Type) SetCERR(value uint8) {
	volatile.StoreUint8(&o.CERR.Reg, volatile.LoadUint8(&o.CERR.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetCERR() uint8 {
	return volatile.LoadUint8(&o.CERR.Reg) & 0xf
}
func (o *DMA_Type) SetCERR_CAEI(value uint8) {
	volatile.StoreUint8(&o.CERR.Reg, volatile.LoadUint8(&o.CERR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCERR_CAEI() uint8 {
	return (volatile.LoadUint8(&o.CERR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCERR_NOP(value uint8) {
	volatile.StoreUint8(&o.CERR.Reg, volatile.LoadUint8(&o.CERR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCERR_NOP() uint8 {
	return (volatile.LoadUint8(&o.CERR.Reg) & 0x80) >> 7
}

// DMA.CINT: Clear Interrupt Request Register
func (o *DMA_Type) SetCINT(value uint8) {
	volatile.StoreUint8(&o.CINT.Reg, volatile.LoadUint8(&o.CINT.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetCINT() uint8 {
	return volatile.LoadUint8(&o.CINT.Reg) & 0xf
}
func (o *DMA_Type) SetCINT_CAIR(value uint8) {
	volatile.StoreUint8(&o.CINT.Reg, volatile.LoadUint8(&o.CINT.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetCINT_CAIR() uint8 {
	return (volatile.LoadUint8(&o.CINT.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetCINT_NOP(value uint8) {
	volatile.StoreUint8(&o.CINT.Reg, volatile.LoadUint8(&o.CINT.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetCINT_NOP() uint8 {
	return (volatile.LoadUint8(&o.CINT.Reg) & 0x80) >> 7
}

// DMA.INT: Interrupt Request Register
func (o *DMA_Type) SetINT_INT0(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetINT_INT0() uint32 {
	return volatile.LoadUint32(&o.INT.Reg) & 0x1
}
func (o *DMA_Type) SetINT_INT1(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetINT_INT1() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetINT_INT2(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetINT_INT2() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetINT_INT3(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetINT_INT3() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetINT_INT4(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetINT_INT4() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetINT_INT5(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetINT_INT5() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetINT_INT6(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetINT_INT6() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetINT_INT7(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetINT_INT7() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetINT_INT8(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetINT_INT8() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetINT_INT9(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetINT_INT9() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetINT_INT10(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetINT_INT10() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetINT_INT11(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetINT_INT11() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetINT_INT12(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetINT_INT12() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x1000) >> 12
}
func (o *DMA_Type) SetINT_INT13(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x2000)|value<<13)
}
func (o *DMA_Type) GetINT_INT13() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x2000) >> 13
}
func (o *DMA_Type) SetINT_INT14(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetINT_INT14() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetINT_INT15(value uint32) {
	volatile.StoreUint32(&o.INT.Reg, volatile.LoadUint32(&o.INT.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetINT_INT15() uint32 {
	return (volatile.LoadUint32(&o.INT.Reg) & 0x8000) >> 15
}

// DMA.ERR: Error Register
func (o *DMA_Type) SetERR_ERR0(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetERR_ERR0() uint32 {
	return volatile.LoadUint32(&o.ERR.Reg) & 0x1
}
func (o *DMA_Type) SetERR_ERR1(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetERR_ERR1() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetERR_ERR2(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetERR_ERR2() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetERR_ERR3(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetERR_ERR3() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetERR_ERR4(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetERR_ERR4() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetERR_ERR5(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetERR_ERR5() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetERR_ERR6(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetERR_ERR6() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetERR_ERR7(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetERR_ERR7() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetERR_ERR8(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetERR_ERR8() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetERR_ERR9(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetERR_ERR9() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetERR_ERR10(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetERR_ERR10() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetERR_ERR11(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetERR_ERR11() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetERR_ERR12(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetERR_ERR12() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x1000) >> 12
}
func (o *DMA_Type) SetERR_ERR13(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x2000)|value<<13)
}
func (o *DMA_Type) GetERR_ERR13() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x2000) >> 13
}
func (o *DMA_Type) SetERR_ERR14(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetERR_ERR14() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetERR_ERR15(value uint32) {
	volatile.StoreUint32(&o.ERR.Reg, volatile.LoadUint32(&o.ERR.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetERR_ERR15() uint32 {
	return (volatile.LoadUint32(&o.ERR.Reg) & 0x8000) >> 15
}

// DMA.HRS: Hardware Request Status Register
func (o *DMA_Type) SetHRS_HRS0(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetHRS_HRS0() uint32 {
	return volatile.LoadUint32(&o.HRS.Reg) & 0x1
}
func (o *DMA_Type) SetHRS_HRS1(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetHRS_HRS1() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetHRS_HRS2(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetHRS_HRS2() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetHRS_HRS3(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetHRS_HRS3() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetHRS_HRS4(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetHRS_HRS4() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetHRS_HRS5(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetHRS_HRS5() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetHRS_HRS6(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetHRS_HRS6() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetHRS_HRS7(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetHRS_HRS7() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetHRS_HRS8(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetHRS_HRS8() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetHRS_HRS9(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetHRS_HRS9() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetHRS_HRS10(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetHRS_HRS10() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetHRS_HRS11(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetHRS_HRS11() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetHRS_HRS12(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetHRS_HRS12() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x1000) >> 12
}
func (o *DMA_Type) SetHRS_HRS13(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x2000)|value<<13)
}
func (o *DMA_Type) GetHRS_HRS13() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x2000) >> 13
}
func (o *DMA_Type) SetHRS_HRS14(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetHRS_HRS14() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetHRS_HRS15(value uint32) {
	volatile.StoreUint32(&o.HRS.Reg, volatile.LoadUint32(&o.HRS.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetHRS_HRS15() uint32 {
	return (volatile.LoadUint32(&o.HRS.Reg) & 0x8000) >> 15
}

// DMA.EARS: Enable Asynchronous Request in Stop Register
func (o *DMA_Type) SetEARS_EDREQ_0(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetEARS_EDREQ_0() uint32 {
	return volatile.LoadUint32(&o.EARS.Reg) & 0x1
}
func (o *DMA_Type) SetEARS_EDREQ_1(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetEARS_EDREQ_1() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetEARS_EDREQ_2(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetEARS_EDREQ_2() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetEARS_EDREQ_3(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetEARS_EDREQ_3() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetEARS_EDREQ_4(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetEARS_EDREQ_4() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetEARS_EDREQ_5(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetEARS_EDREQ_5() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetEARS_EDREQ_6(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetEARS_EDREQ_6() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetEARS_EDREQ_7(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetEARS_EDREQ_7() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetEARS_EDREQ_8(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x100)|value<<8)
}
func (o *DMA_Type) GetEARS_EDREQ_8() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x100) >> 8
}
func (o *DMA_Type) SetEARS_EDREQ_9(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x200)|value<<9)
}
func (o *DMA_Type) GetEARS_EDREQ_9() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x200) >> 9
}
func (o *DMA_Type) SetEARS_EDREQ_10(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x400)|value<<10)
}
func (o *DMA_Type) GetEARS_EDREQ_10() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x400) >> 10
}
func (o *DMA_Type) SetEARS_EDREQ_11(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x800)|value<<11)
}
func (o *DMA_Type) GetEARS_EDREQ_11() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x800) >> 11
}
func (o *DMA_Type) SetEARS_EDREQ_12(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x1000)|value<<12)
}
func (o *DMA_Type) GetEARS_EDREQ_12() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x1000) >> 12
}
func (o *DMA_Type) SetEARS_EDREQ_13(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x2000)|value<<13)
}
func (o *DMA_Type) GetEARS_EDREQ_13() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x2000) >> 13
}
func (o *DMA_Type) SetEARS_EDREQ_14(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x4000)|value<<14)
}
func (o *DMA_Type) GetEARS_EDREQ_14() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x4000) >> 14
}
func (o *DMA_Type) SetEARS_EDREQ_15(value uint32) {
	volatile.StoreUint32(&o.EARS.Reg, volatile.LoadUint32(&o.EARS.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetEARS_EDREQ_15() uint32 {
	return (volatile.LoadUint32(&o.EARS.Reg) & 0x8000) >> 15
}

// DMA.DCHPRI3: Channel Priority Register
func (o *DMA_Type) SetDCHPRI3_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI3.Reg, volatile.LoadUint8(&o.DCHPRI3.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI3_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI3.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI3_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI3.Reg, volatile.LoadUint8(&o.DCHPRI3.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI3_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI3.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI3_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI3.Reg, volatile.LoadUint8(&o.DCHPRI3.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI3_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI3.Reg) & 0x80) >> 7
}

// DMA.DCHPRI2: Channel Priority Register
func (o *DMA_Type) SetDCHPRI2_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI2.Reg, volatile.LoadUint8(&o.DCHPRI2.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI2_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI2.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI2_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI2.Reg, volatile.LoadUint8(&o.DCHPRI2.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI2_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI2.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI2_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI2.Reg, volatile.LoadUint8(&o.DCHPRI2.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI2_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI2.Reg) & 0x80) >> 7
}

// DMA.DCHPRI1: Channel Priority Register
func (o *DMA_Type) SetDCHPRI1_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI1.Reg, volatile.LoadUint8(&o.DCHPRI1.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI1_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI1.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI1_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI1.Reg, volatile.LoadUint8(&o.DCHPRI1.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI1_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI1.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI1_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI1.Reg, volatile.LoadUint8(&o.DCHPRI1.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI1_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI1.Reg) & 0x80) >> 7
}

// DMA.DCHPRI0: Channel Priority Register
func (o *DMA_Type) SetDCHPRI0_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI0.Reg, volatile.LoadUint8(&o.DCHPRI0.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI0_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI0.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI0_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI0.Reg, volatile.LoadUint8(&o.DCHPRI0.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI0_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI0.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI0_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI0.Reg, volatile.LoadUint8(&o.DCHPRI0.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI0_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI0.Reg) & 0x80) >> 7
}

// DMA.DCHPRI7: Channel Priority Register
func (o *DMA_Type) SetDCHPRI7_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI7.Reg, volatile.LoadUint8(&o.DCHPRI7.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI7_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI7.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI7_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI7.Reg, volatile.LoadUint8(&o.DCHPRI7.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI7_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI7.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI7_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI7.Reg, volatile.LoadUint8(&o.DCHPRI7.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI7_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI7.Reg) & 0x80) >> 7
}

// DMA.DCHPRI6: Channel Priority Register
func (o *DMA_Type) SetDCHPRI6_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI6.Reg, volatile.LoadUint8(&o.DCHPRI6.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI6_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI6.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI6_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI6.Reg, volatile.LoadUint8(&o.DCHPRI6.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI6_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI6.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI6_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI6.Reg, volatile.LoadUint8(&o.DCHPRI6.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI6_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI6.Reg) & 0x80) >> 7
}

// DMA.DCHPRI5: Channel Priority Register
func (o *DMA_Type) SetDCHPRI5_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI5.Reg, volatile.LoadUint8(&o.DCHPRI5.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI5_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI5.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI5_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI5.Reg, volatile.LoadUint8(&o.DCHPRI5.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI5_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI5.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI5_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI5.Reg, volatile.LoadUint8(&o.DCHPRI5.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI5_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI5.Reg) & 0x80) >> 7
}

// DMA.DCHPRI4: Channel Priority Register
func (o *DMA_Type) SetDCHPRI4_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI4.Reg, volatile.LoadUint8(&o.DCHPRI4.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI4_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI4.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI4_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI4.Reg, volatile.LoadUint8(&o.DCHPRI4.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI4_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI4.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI4_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI4.Reg, volatile.LoadUint8(&o.DCHPRI4.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI4_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI4.Reg) & 0x80) >> 7
}

// DMA.DCHPRI11: Channel Priority Register
func (o *DMA_Type) SetDCHPRI11_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI11.Reg, volatile.LoadUint8(&o.DCHPRI11.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI11_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI11.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI11_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI11.Reg, volatile.LoadUint8(&o.DCHPRI11.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI11_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI11.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI11_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI11.Reg, volatile.LoadUint8(&o.DCHPRI11.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI11_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI11.Reg) & 0x80) >> 7
}

// DMA.DCHPRI10: Channel Priority Register
func (o *DMA_Type) SetDCHPRI10_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI10.Reg, volatile.LoadUint8(&o.DCHPRI10.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI10_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI10.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI10_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI10.Reg, volatile.LoadUint8(&o.DCHPRI10.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI10_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI10.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI10_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI10.Reg, volatile.LoadUint8(&o.DCHPRI10.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI10_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI10.Reg) & 0x80) >> 7
}

// DMA.DCHPRI9: Channel Priority Register
func (o *DMA_Type) SetDCHPRI9_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI9.Reg, volatile.LoadUint8(&o.DCHPRI9.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI9_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI9.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI9_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI9.Reg, volatile.LoadUint8(&o.DCHPRI9.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI9_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI9.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI9_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI9.Reg, volatile.LoadUint8(&o.DCHPRI9.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI9_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI9.Reg) & 0x80) >> 7
}

// DMA.DCHPRI8: Channel Priority Register
func (o *DMA_Type) SetDCHPRI8_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI8.Reg, volatile.LoadUint8(&o.DCHPRI8.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI8_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI8.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI8_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI8.Reg, volatile.LoadUint8(&o.DCHPRI8.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI8_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI8.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI8_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI8.Reg, volatile.LoadUint8(&o.DCHPRI8.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI8_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI8.Reg) & 0x80) >> 7
}

// DMA.DCHPRI15: Channel Priority Register
func (o *DMA_Type) SetDCHPRI15_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI15.Reg, volatile.LoadUint8(&o.DCHPRI15.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI15_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI15.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI15_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI15.Reg, volatile.LoadUint8(&o.DCHPRI15.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI15_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI15.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI15_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI15.Reg, volatile.LoadUint8(&o.DCHPRI15.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI15_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI15.Reg) & 0x80) >> 7
}

// DMA.DCHPRI14: Channel Priority Register
func (o *DMA_Type) SetDCHPRI14_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI14.Reg, volatile.LoadUint8(&o.DCHPRI14.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI14_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI14.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI14_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI14.Reg, volatile.LoadUint8(&o.DCHPRI14.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI14_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI14.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI14_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI14.Reg, volatile.LoadUint8(&o.DCHPRI14.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI14_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI14.Reg) & 0x80) >> 7
}

// DMA.DCHPRI13: Channel Priority Register
func (o *DMA_Type) SetDCHPRI13_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI13.Reg, volatile.LoadUint8(&o.DCHPRI13.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI13_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI13.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI13_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI13.Reg, volatile.LoadUint8(&o.DCHPRI13.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI13_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI13.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI13_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI13.Reg, volatile.LoadUint8(&o.DCHPRI13.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI13_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI13.Reg) & 0x80) >> 7
}

// DMA.DCHPRI12: Channel Priority Register
func (o *DMA_Type) SetDCHPRI12_CHPRI(value uint8) {
	volatile.StoreUint8(&o.DCHPRI12.Reg, volatile.LoadUint8(&o.DCHPRI12.Reg)&^(0xf)|value)
}
func (o *DMA_Type) GetDCHPRI12_CHPRI() uint8 {
	return volatile.LoadUint8(&o.DCHPRI12.Reg) & 0xf
}
func (o *DMA_Type) SetDCHPRI12_DPA(value uint8) {
	volatile.StoreUint8(&o.DCHPRI12.Reg, volatile.LoadUint8(&o.DCHPRI12.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetDCHPRI12_DPA() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI12.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetDCHPRI12_ECP(value uint8) {
	volatile.StoreUint8(&o.DCHPRI12.Reg, volatile.LoadUint8(&o.DCHPRI12.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetDCHPRI12_ECP() uint8 {
	return (volatile.LoadUint8(&o.DCHPRI12.Reg) & 0x80) >> 7
}

// DMA.TCD0_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD0_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD0_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD0_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD0_SADDR.Reg)
}

// DMA.TCD0_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD0_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD0_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD0_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD0_SOFF.Reg)
}

// DMA.TCD0_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD0_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD0_ATTR.Reg, volatile.LoadUint16(&o.TCD0_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD0_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD0_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD0_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD0_ATTR.Reg, volatile.LoadUint16(&o.TCD0_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD0_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD0_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD0_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD0_ATTR.Reg, volatile.LoadUint16(&o.TCD0_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD0_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD0_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD0_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD0_ATTR.Reg, volatile.LoadUint16(&o.TCD0_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD0_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD0_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD0_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD0_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD0_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD0_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD0_NBYTES_MLNO.Reg)
}

// DMA.TCD0_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD0_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD0_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD0_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD0_SLAST.Reg)
}

// DMA.TCD0_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD0_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD0_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD0_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD0_DADDR.Reg)
}

// DMA.TCD0_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD0_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD0_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD0_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD0_DOFF.Reg)
}

// DMA.TCD0_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD0_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD0_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD0_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD0_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD0_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD0_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD0_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD0_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD0_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD0_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD0_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD0_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD0_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD0_DLASTSGA.Reg)
}

// DMA.TCD0_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD0_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD0_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD0_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD0_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD0_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD0_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD0_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD0_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD0_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD0_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD0_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD0_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD0_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD0_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD0_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD0_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD0_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD0_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD0_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD0_CSR.Reg, volatile.LoadUint16(&o.TCD0_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD0_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD0_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD0_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD0_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD0_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD0_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD0_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD0_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD0_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD0_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD0_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD0_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD0_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD1_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD1_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD1_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD1_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD1_SADDR.Reg)
}

// DMA.TCD1_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD1_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD1_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD1_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD1_SOFF.Reg)
}

// DMA.TCD1_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD1_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD1_ATTR.Reg, volatile.LoadUint16(&o.TCD1_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD1_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD1_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD1_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD1_ATTR.Reg, volatile.LoadUint16(&o.TCD1_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD1_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD1_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD1_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD1_ATTR.Reg, volatile.LoadUint16(&o.TCD1_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD1_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD1_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD1_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD1_ATTR.Reg, volatile.LoadUint16(&o.TCD1_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD1_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD1_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD1_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD1_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD1_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD1_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD1_NBYTES_MLNO.Reg)
}

// DMA.TCD1_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD1_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD1_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD1_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD1_SLAST.Reg)
}

// DMA.TCD1_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD1_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD1_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD1_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD1_DADDR.Reg)
}

// DMA.TCD1_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD1_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD1_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD1_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD1_DOFF.Reg)
}

// DMA.TCD1_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD1_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD1_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD1_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD1_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD1_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD1_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD1_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD1_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD1_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD1_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD1_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD1_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD1_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD1_DLASTSGA.Reg)
}

// DMA.TCD1_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD1_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD1_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD1_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD1_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD1_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD1_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD1_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD1_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD1_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD1_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD1_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD1_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD1_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD1_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD1_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD1_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD1_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD1_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD1_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD1_CSR.Reg, volatile.LoadUint16(&o.TCD1_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD1_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD1_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD1_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD1_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD1_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD1_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD1_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD1_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD1_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD1_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD1_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD1_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD1_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD2_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD2_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD2_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD2_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD2_SADDR.Reg)
}

// DMA.TCD2_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD2_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD2_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD2_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD2_SOFF.Reg)
}

// DMA.TCD2_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD2_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD2_ATTR.Reg, volatile.LoadUint16(&o.TCD2_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD2_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD2_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD2_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD2_ATTR.Reg, volatile.LoadUint16(&o.TCD2_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD2_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD2_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD2_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD2_ATTR.Reg, volatile.LoadUint16(&o.TCD2_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD2_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD2_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD2_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD2_ATTR.Reg, volatile.LoadUint16(&o.TCD2_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD2_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD2_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD2_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD2_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD2_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD2_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD2_NBYTES_MLNO.Reg)
}

// DMA.TCD2_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD2_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD2_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD2_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD2_SLAST.Reg)
}

// DMA.TCD2_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD2_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD2_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD2_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD2_DADDR.Reg)
}

// DMA.TCD2_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD2_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD2_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD2_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD2_DOFF.Reg)
}

// DMA.TCD2_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD2_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD2_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD2_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD2_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD2_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD2_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD2_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD2_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD2_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD2_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD2_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD2_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD2_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD2_DLASTSGA.Reg)
}

// DMA.TCD2_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD2_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD2_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD2_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD2_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD2_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD2_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD2_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD2_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD2_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD2_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD2_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD2_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD2_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD2_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD2_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD2_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD2_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD2_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD2_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD2_CSR.Reg, volatile.LoadUint16(&o.TCD2_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD2_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD2_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD2_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD2_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD2_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD2_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD2_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD2_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD2_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD2_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD2_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD2_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD2_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD3_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD3_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD3_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD3_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD3_SADDR.Reg)
}

// DMA.TCD3_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD3_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD3_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD3_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD3_SOFF.Reg)
}

// DMA.TCD3_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD3_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD3_ATTR.Reg, volatile.LoadUint16(&o.TCD3_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD3_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD3_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD3_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD3_ATTR.Reg, volatile.LoadUint16(&o.TCD3_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD3_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD3_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD3_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD3_ATTR.Reg, volatile.LoadUint16(&o.TCD3_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD3_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD3_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD3_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD3_ATTR.Reg, volatile.LoadUint16(&o.TCD3_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD3_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD3_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD3_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD3_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD3_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD3_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD3_NBYTES_MLNO.Reg)
}

// DMA.TCD3_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD3_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD3_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD3_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD3_SLAST.Reg)
}

// DMA.TCD3_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD3_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD3_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD3_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD3_DADDR.Reg)
}

// DMA.TCD3_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD3_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD3_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD3_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD3_DOFF.Reg)
}

// DMA.TCD3_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD3_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD3_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD3_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD3_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD3_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD3_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD3_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD3_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD3_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD3_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD3_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD3_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD3_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD3_DLASTSGA.Reg)
}

// DMA.TCD3_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD3_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD3_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD3_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD3_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD3_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD3_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD3_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD3_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD3_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD3_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD3_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD3_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD3_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD3_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD3_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD3_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD3_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD3_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD3_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD3_CSR.Reg, volatile.LoadUint16(&o.TCD3_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD3_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD3_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD3_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD3_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD3_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD3_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD3_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD3_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD3_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD3_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD3_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD3_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD3_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD4_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD4_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD4_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD4_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD4_SADDR.Reg)
}

// DMA.TCD4_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD4_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD4_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD4_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD4_SOFF.Reg)
}

// DMA.TCD4_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD4_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD4_ATTR.Reg, volatile.LoadUint16(&o.TCD4_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD4_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD4_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD4_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD4_ATTR.Reg, volatile.LoadUint16(&o.TCD4_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD4_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD4_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD4_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD4_ATTR.Reg, volatile.LoadUint16(&o.TCD4_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD4_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD4_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD4_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD4_ATTR.Reg, volatile.LoadUint16(&o.TCD4_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD4_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD4_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD4_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD4_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD4_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD4_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD4_NBYTES_MLNO.Reg)
}

// DMA.TCD4_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD4_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD4_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD4_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD4_SLAST.Reg)
}

// DMA.TCD4_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD4_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD4_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD4_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD4_DADDR.Reg)
}

// DMA.TCD4_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD4_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD4_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD4_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD4_DOFF.Reg)
}

// DMA.TCD4_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD4_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD4_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD4_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD4_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD4_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD4_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD4_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD4_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD4_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD4_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD4_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD4_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD4_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD4_DLASTSGA.Reg)
}

// DMA.TCD4_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD4_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD4_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD4_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD4_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD4_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD4_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD4_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD4_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD4_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD4_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD4_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD4_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD4_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD4_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD4_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD4_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD4_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD4_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD4_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD4_CSR.Reg, volatile.LoadUint16(&o.TCD4_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD4_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD4_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD4_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD4_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD4_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD4_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD4_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD4_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD4_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD4_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD4_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD4_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD4_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD5_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD5_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD5_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD5_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD5_SADDR.Reg)
}

// DMA.TCD5_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD5_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD5_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD5_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD5_SOFF.Reg)
}

// DMA.TCD5_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD5_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD5_ATTR.Reg, volatile.LoadUint16(&o.TCD5_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD5_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD5_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD5_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD5_ATTR.Reg, volatile.LoadUint16(&o.TCD5_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD5_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD5_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD5_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD5_ATTR.Reg, volatile.LoadUint16(&o.TCD5_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD5_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD5_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD5_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD5_ATTR.Reg, volatile.LoadUint16(&o.TCD5_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD5_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD5_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD5_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD5_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD5_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD5_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD5_NBYTES_MLNO.Reg)
}

// DMA.TCD5_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD5_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD5_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD5_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD5_SLAST.Reg)
}

// DMA.TCD5_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD5_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD5_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD5_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD5_DADDR.Reg)
}

// DMA.TCD5_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD5_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD5_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD5_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD5_DOFF.Reg)
}

// DMA.TCD5_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD5_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD5_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD5_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD5_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD5_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD5_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD5_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD5_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD5_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD5_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD5_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD5_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD5_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD5_DLASTSGA.Reg)
}

// DMA.TCD5_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD5_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD5_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD5_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD5_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD5_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD5_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD5_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD5_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD5_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD5_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD5_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD5_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD5_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD5_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD5_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD5_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD5_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD5_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD5_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD5_CSR.Reg, volatile.LoadUint16(&o.TCD5_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD5_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD5_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD5_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD5_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD5_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD5_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD5_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD5_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD5_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD5_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD5_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD5_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD5_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD6_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD6_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD6_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD6_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD6_SADDR.Reg)
}

// DMA.TCD6_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD6_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD6_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD6_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD6_SOFF.Reg)
}

// DMA.TCD6_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD6_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD6_ATTR.Reg, volatile.LoadUint16(&o.TCD6_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD6_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD6_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD6_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD6_ATTR.Reg, volatile.LoadUint16(&o.TCD6_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD6_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD6_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD6_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD6_ATTR.Reg, volatile.LoadUint16(&o.TCD6_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD6_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD6_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD6_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD6_ATTR.Reg, volatile.LoadUint16(&o.TCD6_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD6_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD6_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD6_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD6_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD6_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD6_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD6_NBYTES_MLNO.Reg)
}

// DMA.TCD6_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD6_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD6_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD6_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD6_SLAST.Reg)
}

// DMA.TCD6_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD6_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD6_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD6_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD6_DADDR.Reg)
}

// DMA.TCD6_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD6_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD6_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD6_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD6_DOFF.Reg)
}

// DMA.TCD6_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD6_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD6_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD6_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD6_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD6_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD6_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD6_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD6_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD6_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD6_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD6_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD6_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD6_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD6_DLASTSGA.Reg)
}

// DMA.TCD6_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD6_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD6_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD6_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD6_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD6_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD6_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD6_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD6_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD6_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD6_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD6_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD6_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD6_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD6_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD6_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD6_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD6_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD6_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD6_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD6_CSR.Reg, volatile.LoadUint16(&o.TCD6_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD6_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD6_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD6_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD6_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD6_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD6_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD6_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD6_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD6_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD6_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD6_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD6_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD6_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD7_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD7_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD7_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD7_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD7_SADDR.Reg)
}

// DMA.TCD7_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD7_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD7_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD7_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD7_SOFF.Reg)
}

// DMA.TCD7_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD7_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD7_ATTR.Reg, volatile.LoadUint16(&o.TCD7_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD7_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD7_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD7_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD7_ATTR.Reg, volatile.LoadUint16(&o.TCD7_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD7_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD7_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD7_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD7_ATTR.Reg, volatile.LoadUint16(&o.TCD7_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD7_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD7_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD7_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD7_ATTR.Reg, volatile.LoadUint16(&o.TCD7_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD7_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD7_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD7_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD7_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD7_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD7_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD7_NBYTES_MLNO.Reg)
}

// DMA.TCD7_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD7_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD7_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD7_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD7_SLAST.Reg)
}

// DMA.TCD7_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD7_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD7_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD7_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD7_DADDR.Reg)
}

// DMA.TCD7_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD7_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD7_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD7_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD7_DOFF.Reg)
}

// DMA.TCD7_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD7_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD7_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD7_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD7_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD7_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD7_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD7_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD7_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD7_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD7_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD7_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD7_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD7_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD7_DLASTSGA.Reg)
}

// DMA.TCD7_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD7_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD7_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD7_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD7_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD7_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD7_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD7_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD7_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD7_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD7_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD7_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD7_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD7_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD7_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD7_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD7_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD7_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD7_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD7_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD7_CSR.Reg, volatile.LoadUint16(&o.TCD7_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD7_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD7_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD7_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD7_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD7_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD7_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD7_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD7_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD7_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD7_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD7_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD7_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD7_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD8_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD8_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD8_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD8_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD8_SADDR.Reg)
}

// DMA.TCD8_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD8_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD8_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD8_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD8_SOFF.Reg)
}

// DMA.TCD8_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD8_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD8_ATTR.Reg, volatile.LoadUint16(&o.TCD8_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD8_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD8_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD8_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD8_ATTR.Reg, volatile.LoadUint16(&o.TCD8_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD8_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD8_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD8_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD8_ATTR.Reg, volatile.LoadUint16(&o.TCD8_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD8_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD8_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD8_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD8_ATTR.Reg, volatile.LoadUint16(&o.TCD8_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD8_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD8_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD8_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD8_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD8_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD8_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD8_NBYTES_MLNO.Reg)
}

// DMA.TCD8_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD8_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD8_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD8_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD8_SLAST.Reg)
}

// DMA.TCD8_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD8_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD8_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD8_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD8_DADDR.Reg)
}

// DMA.TCD8_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD8_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD8_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD8_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD8_DOFF.Reg)
}

// DMA.TCD8_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD8_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD8_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD8_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD8_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD8_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD8_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD8_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD8_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD8_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD8_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD8_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD8_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD8_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD8_DLASTSGA.Reg)
}

// DMA.TCD8_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD8_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD8_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD8_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD8_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD8_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD8_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD8_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD8_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD8_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD8_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD8_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD8_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD8_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD8_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD8_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD8_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD8_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD8_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD8_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD8_CSR.Reg, volatile.LoadUint16(&o.TCD8_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD8_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD8_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD8_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD8_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD8_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD8_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD8_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD8_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD8_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD8_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD8_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD8_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD8_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD9_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD9_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD9_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD9_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD9_SADDR.Reg)
}

// DMA.TCD9_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD9_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD9_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD9_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD9_SOFF.Reg)
}

// DMA.TCD9_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD9_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD9_ATTR.Reg, volatile.LoadUint16(&o.TCD9_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD9_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD9_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD9_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD9_ATTR.Reg, volatile.LoadUint16(&o.TCD9_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD9_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD9_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD9_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD9_ATTR.Reg, volatile.LoadUint16(&o.TCD9_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD9_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD9_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD9_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD9_ATTR.Reg, volatile.LoadUint16(&o.TCD9_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD9_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD9_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD9_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD9_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD9_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD9_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD9_NBYTES_MLNO.Reg)
}

// DMA.TCD9_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD9_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD9_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD9_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD9_SLAST.Reg)
}

// DMA.TCD9_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD9_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD9_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD9_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD9_DADDR.Reg)
}

// DMA.TCD9_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD9_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD9_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD9_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD9_DOFF.Reg)
}

// DMA.TCD9_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD9_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD9_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD9_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD9_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD9_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD9_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD9_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD9_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD9_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD9_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD9_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD9_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD9_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD9_DLASTSGA.Reg)
}

// DMA.TCD9_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD9_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD9_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD9_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD9_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD9_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD9_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD9_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD9_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD9_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD9_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD9_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD9_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD9_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD9_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD9_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD9_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD9_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD9_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD9_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD9_CSR.Reg, volatile.LoadUint16(&o.TCD9_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD9_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD9_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD9_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD9_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD9_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD9_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD9_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD9_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD9_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD9_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD9_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD9_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD9_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD10_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD10_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD10_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD10_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD10_SADDR.Reg)
}

// DMA.TCD10_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD10_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD10_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD10_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD10_SOFF.Reg)
}

// DMA.TCD10_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD10_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD10_ATTR.Reg, volatile.LoadUint16(&o.TCD10_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD10_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD10_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD10_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD10_ATTR.Reg, volatile.LoadUint16(&o.TCD10_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD10_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD10_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD10_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD10_ATTR.Reg, volatile.LoadUint16(&o.TCD10_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD10_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD10_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD10_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD10_ATTR.Reg, volatile.LoadUint16(&o.TCD10_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD10_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD10_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD10_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD10_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD10_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD10_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD10_NBYTES_MLNO.Reg)
}

// DMA.TCD10_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD10_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD10_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD10_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD10_SLAST.Reg)
}

// DMA.TCD10_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD10_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD10_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD10_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD10_DADDR.Reg)
}

// DMA.TCD10_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD10_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD10_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD10_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD10_DOFF.Reg)
}

// DMA.TCD10_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD10_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD10_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD10_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD10_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD10_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD10_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD10_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD10_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD10_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD10_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD10_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD10_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD10_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD10_DLASTSGA.Reg)
}

// DMA.TCD10_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD10_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD10_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD10_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD10_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD10_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD10_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD10_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD10_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD10_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD10_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD10_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD10_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD10_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD10_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD10_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD10_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD10_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD10_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD10_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD10_CSR.Reg, volatile.LoadUint16(&o.TCD10_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD10_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD10_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD10_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD10_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD10_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD10_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD10_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD10_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD10_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD10_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD10_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD10_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD10_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD11_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD11_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD11_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD11_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD11_SADDR.Reg)
}

// DMA.TCD11_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD11_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD11_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD11_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD11_SOFF.Reg)
}

// DMA.TCD11_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD11_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD11_ATTR.Reg, volatile.LoadUint16(&o.TCD11_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD11_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD11_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD11_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD11_ATTR.Reg, volatile.LoadUint16(&o.TCD11_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD11_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD11_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD11_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD11_ATTR.Reg, volatile.LoadUint16(&o.TCD11_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD11_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD11_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD11_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD11_ATTR.Reg, volatile.LoadUint16(&o.TCD11_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD11_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD11_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD11_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD11_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD11_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD11_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD11_NBYTES_MLNO.Reg)
}

// DMA.TCD11_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD11_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD11_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD11_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD11_SLAST.Reg)
}

// DMA.TCD11_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD11_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD11_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD11_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD11_DADDR.Reg)
}

// DMA.TCD11_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD11_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD11_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD11_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD11_DOFF.Reg)
}

// DMA.TCD11_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD11_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD11_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD11_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD11_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD11_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD11_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD11_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD11_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD11_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD11_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD11_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD11_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD11_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD11_DLASTSGA.Reg)
}

// DMA.TCD11_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD11_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD11_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD11_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD11_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD11_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD11_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD11_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD11_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD11_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD11_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD11_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD11_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD11_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD11_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD11_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD11_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD11_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD11_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD11_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD11_CSR.Reg, volatile.LoadUint16(&o.TCD11_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD11_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD11_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD11_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD11_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD11_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD11_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD11_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD11_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD11_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD11_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD11_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD11_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD11_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD12_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD12_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD12_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD12_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD12_SADDR.Reg)
}

// DMA.TCD12_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD12_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD12_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD12_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD12_SOFF.Reg)
}

// DMA.TCD12_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD12_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD12_ATTR.Reg, volatile.LoadUint16(&o.TCD12_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD12_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD12_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD12_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD12_ATTR.Reg, volatile.LoadUint16(&o.TCD12_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD12_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD12_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD12_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD12_ATTR.Reg, volatile.LoadUint16(&o.TCD12_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD12_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD12_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD12_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD12_ATTR.Reg, volatile.LoadUint16(&o.TCD12_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD12_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD12_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD12_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD12_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD12_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD12_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD12_NBYTES_MLNO.Reg)
}

// DMA.TCD12_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD12_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD12_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD12_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD12_SLAST.Reg)
}

// DMA.TCD12_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD12_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD12_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD12_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD12_DADDR.Reg)
}

// DMA.TCD12_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD12_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD12_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD12_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD12_DOFF.Reg)
}

// DMA.TCD12_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD12_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD12_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD12_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD12_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD12_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD12_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD12_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD12_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD12_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD12_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD12_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD12_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD12_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD12_DLASTSGA.Reg)
}

// DMA.TCD12_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD12_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD12_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD12_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD12_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD12_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD12_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD12_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD12_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD12_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD12_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD12_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD12_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD12_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD12_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD12_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD12_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD12_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD12_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD12_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD12_CSR.Reg, volatile.LoadUint16(&o.TCD12_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD12_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD12_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD12_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD12_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD12_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD12_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD12_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD12_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD12_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD12_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD12_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD12_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD12_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD13_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD13_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD13_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD13_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD13_SADDR.Reg)
}

// DMA.TCD13_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD13_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD13_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD13_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD13_SOFF.Reg)
}

// DMA.TCD13_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD13_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD13_ATTR.Reg, volatile.LoadUint16(&o.TCD13_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD13_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD13_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD13_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD13_ATTR.Reg, volatile.LoadUint16(&o.TCD13_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD13_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD13_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD13_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD13_ATTR.Reg, volatile.LoadUint16(&o.TCD13_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD13_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD13_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD13_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD13_ATTR.Reg, volatile.LoadUint16(&o.TCD13_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD13_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD13_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD13_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD13_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD13_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD13_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD13_NBYTES_MLNO.Reg)
}

// DMA.TCD13_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD13_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD13_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD13_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD13_SLAST.Reg)
}

// DMA.TCD13_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD13_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD13_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD13_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD13_DADDR.Reg)
}

// DMA.TCD13_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD13_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD13_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD13_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD13_DOFF.Reg)
}

// DMA.TCD13_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD13_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD13_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD13_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD13_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD13_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD13_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD13_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD13_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD13_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD13_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD13_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD13_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD13_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD13_DLASTSGA.Reg)
}

// DMA.TCD13_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD13_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD13_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD13_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD13_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD13_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD13_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD13_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD13_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD13_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD13_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD13_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD13_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD13_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD13_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD13_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD13_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD13_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD13_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD13_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD13_CSR.Reg, volatile.LoadUint16(&o.TCD13_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD13_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD13_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD13_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD13_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD13_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD13_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD13_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD13_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD13_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD13_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD13_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD13_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD13_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD14_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD14_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD14_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD14_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD14_SADDR.Reg)
}

// DMA.TCD14_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD14_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD14_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD14_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD14_SOFF.Reg)
}

// DMA.TCD14_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD14_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD14_ATTR.Reg, volatile.LoadUint16(&o.TCD14_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD14_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD14_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD14_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD14_ATTR.Reg, volatile.LoadUint16(&o.TCD14_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD14_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD14_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD14_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD14_ATTR.Reg, volatile.LoadUint16(&o.TCD14_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD14_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD14_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD14_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD14_ATTR.Reg, volatile.LoadUint16(&o.TCD14_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD14_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD14_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD14_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD14_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD14_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD14_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD14_NBYTES_MLNO.Reg)
}

// DMA.TCD14_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD14_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD14_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD14_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD14_SLAST.Reg)
}

// DMA.TCD14_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD14_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD14_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD14_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD14_DADDR.Reg)
}

// DMA.TCD14_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD14_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD14_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD14_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD14_DOFF.Reg)
}

// DMA.TCD14_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD14_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD14_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD14_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD14_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD14_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD14_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD14_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD14_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD14_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD14_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD14_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD14_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD14_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD14_DLASTSGA.Reg)
}

// DMA.TCD14_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD14_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD14_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD14_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD14_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD14_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD14_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD14_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD14_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD14_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD14_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD14_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD14_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD14_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD14_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD14_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD14_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD14_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD14_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD14_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD14_CSR.Reg, volatile.LoadUint16(&o.TCD14_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD14_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD14_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD14_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD14_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD14_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD14_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD14_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD14_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD14_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD14_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD14_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD14_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD14_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD15_SADDR: TCD Source Address
func (o *DMA_Type) SetTCD15_SADDR(value uint32) {
	volatile.StoreUint32(&o.TCD15_SADDR.Reg, value)
}
func (o *DMA_Type) GetTCD15_SADDR() uint32 {
	return volatile.LoadUint32(&o.TCD15_SADDR.Reg)
}

// DMA.TCD15_SOFF: TCD Signed Source Address Offset
func (o *DMA_Type) SetTCD15_SOFF(value uint16) {
	volatile.StoreUint16(&o.TCD15_SOFF.Reg, value)
}
func (o *DMA_Type) GetTCD15_SOFF() uint16 {
	return volatile.LoadUint16(&o.TCD15_SOFF.Reg)
}

// DMA.TCD15_ATTR: TCD Transfer Attributes
func (o *DMA_Type) SetTCD15_ATTR_DSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD15_ATTR.Reg, volatile.LoadUint16(&o.TCD15_ATTR.Reg)&^(0x7)|value)
}
func (o *DMA_Type) GetTCD15_ATTR_DSIZE() uint16 {
	return volatile.LoadUint16(&o.TCD15_ATTR.Reg) & 0x7
}
func (o *DMA_Type) SetTCD15_ATTR_DMOD(value uint16) {
	volatile.StoreUint16(&o.TCD15_ATTR.Reg, volatile.LoadUint16(&o.TCD15_ATTR.Reg)&^(0xf8)|value<<3)
}
func (o *DMA_Type) GetTCD15_ATTR_DMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD15_ATTR.Reg) & 0xf8) >> 3
}
func (o *DMA_Type) SetTCD15_ATTR_SSIZE(value uint16) {
	volatile.StoreUint16(&o.TCD15_ATTR.Reg, volatile.LoadUint16(&o.TCD15_ATTR.Reg)&^(0x700)|value<<8)
}
func (o *DMA_Type) GetTCD15_ATTR_SSIZE() uint16 {
	return (volatile.LoadUint16(&o.TCD15_ATTR.Reg) & 0x700) >> 8
}
func (o *DMA_Type) SetTCD15_ATTR_SMOD(value uint16) {
	volatile.StoreUint16(&o.TCD15_ATTR.Reg, volatile.LoadUint16(&o.TCD15_ATTR.Reg)&^(0xf800)|value<<11)
}
func (o *DMA_Type) GetTCD15_ATTR_SMOD() uint16 {
	return (volatile.LoadUint16(&o.TCD15_ATTR.Reg) & 0xf800) >> 11
}

// DMA.TCD15_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
func (o *DMA_Type) SetTCD15_NBYTES_MLNO(value uint32) {
	volatile.StoreUint32(&o.TCD15_NBYTES_MLNO.Reg, value)
}
func (o *DMA_Type) GetTCD15_NBYTES_MLNO() uint32 {
	return volatile.LoadUint32(&o.TCD15_NBYTES_MLNO.Reg)
}

// DMA.TCD15_SLAST: TCD Last Source Address Adjustment
func (o *DMA_Type) SetTCD15_SLAST(value uint32) {
	volatile.StoreUint32(&o.TCD15_SLAST.Reg, value)
}
func (o *DMA_Type) GetTCD15_SLAST() uint32 {
	return volatile.LoadUint32(&o.TCD15_SLAST.Reg)
}

// DMA.TCD15_DADDR: TCD Destination Address
func (o *DMA_Type) SetTCD15_DADDR(value uint32) {
	volatile.StoreUint32(&o.TCD15_DADDR.Reg, value)
}
func (o *DMA_Type) GetTCD15_DADDR() uint32 {
	return volatile.LoadUint32(&o.TCD15_DADDR.Reg)
}

// DMA.TCD15_DOFF: TCD Signed Destination Address Offset
func (o *DMA_Type) SetTCD15_DOFF(value uint16) {
	volatile.StoreUint16(&o.TCD15_DOFF.Reg, value)
}
func (o *DMA_Type) GetTCD15_DOFF() uint16 {
	return volatile.LoadUint16(&o.TCD15_DOFF.Reg)
}

// DMA.TCD15_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD15_CITER_ELINKNO_CITER(value uint16) {
	volatile.StoreUint16(&o.TCD15_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD15_CITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD15_CITER_ELINKNO_CITER() uint16 {
	return volatile.LoadUint16(&o.TCD15_CITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD15_CITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD15_CITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD15_CITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD15_CITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMA.TCD15_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
func (o *DMA_Type) SetTCD15_DLASTSGA(value uint32) {
	volatile.StoreUint32(&o.TCD15_DLASTSGA.Reg, value)
}
func (o *DMA_Type) GetTCD15_DLASTSGA() uint32 {
	return volatile.LoadUint32(&o.TCD15_DLASTSGA.Reg)
}

// DMA.TCD15_CSR: TCD Control and Status
func (o *DMA_Type) SetTCD15_CSR_START(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetTCD15_CSR_START() uint16 {
	return volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0x1
}
func (o *DMA_Type) SetTCD15_CSR_INTMAJOR(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0x2)|value<<1)
}
func (o *DMA_Type) GetTCD15_CSR_INTMAJOR() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0x2) >> 1
}
func (o *DMA_Type) SetTCD15_CSR_INTHALF(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0x4)|value<<2)
}
func (o *DMA_Type) GetTCD15_CSR_INTHALF() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0x4) >> 2
}
func (o *DMA_Type) SetTCD15_CSR_DREQ(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0x8)|value<<3)
}
func (o *DMA_Type) GetTCD15_CSR_DREQ() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0x8) >> 3
}
func (o *DMA_Type) SetTCD15_CSR_ESG(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0x10)|value<<4)
}
func (o *DMA_Type) GetTCD15_CSR_ESG() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0x10) >> 4
}
func (o *DMA_Type) SetTCD15_CSR_MAJORELINK(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0x20)|value<<5)
}
func (o *DMA_Type) GetTCD15_CSR_MAJORELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0x20) >> 5
}
func (o *DMA_Type) SetTCD15_CSR_ACTIVE(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0x40)|value<<6)
}
func (o *DMA_Type) GetTCD15_CSR_ACTIVE() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0x40) >> 6
}
func (o *DMA_Type) SetTCD15_CSR_DONE(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0x80)|value<<7)
}
func (o *DMA_Type) GetTCD15_CSR_DONE() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0x80) >> 7
}
func (o *DMA_Type) SetTCD15_CSR_MAJORLINKCH(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0xf00)|value<<8)
}
func (o *DMA_Type) GetTCD15_CSR_MAJORLINKCH() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0xf00) >> 8
}
func (o *DMA_Type) SetTCD15_CSR_BWC(value uint16) {
	volatile.StoreUint16(&o.TCD15_CSR.Reg, volatile.LoadUint16(&o.TCD15_CSR.Reg)&^(0xc000)|value<<14)
}
func (o *DMA_Type) GetTCD15_CSR_BWC() uint16 {
	return (volatile.LoadUint16(&o.TCD15_CSR.Reg) & 0xc000) >> 14
}

// DMA.TCD15_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
func (o *DMA_Type) SetTCD15_BITER_ELINKNO_BITER(value uint16) {
	volatile.StoreUint16(&o.TCD15_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD15_BITER_ELINKNO.Reg)&^(0x7fff)|value)
}
func (o *DMA_Type) GetTCD15_BITER_ELINKNO_BITER() uint16 {
	return volatile.LoadUint16(&o.TCD15_BITER_ELINKNO.Reg) & 0x7fff
}
func (o *DMA_Type) SetTCD15_BITER_ELINKNO_ELINK(value uint16) {
	volatile.StoreUint16(&o.TCD15_BITER_ELINKNO.Reg, volatile.LoadUint16(&o.TCD15_BITER_ELINKNO.Reg)&^(0x8000)|value<<15)
}
func (o *DMA_Type) GetTCD15_BITER_ELINKNO_ELINK() uint16 {
	return (volatile.LoadUint16(&o.TCD15_BITER_ELINKNO.Reg) & 0x8000) >> 15
}

// DMAMUX
type DMAMUX_Type struct {
	CHCFG [16]volatile.Register32 // 0x0
}

// DMAMUX.CHCFG: Channel 0 Configuration Register
func (o *DMAMUX_Type) SetCHCFG_SOURCE(idx int, value uint32) {
	volatile.StoreUint32(&o.CHCFG[idx].Reg, volatile.LoadUint32(&o.CHCFG[idx].Reg)&^(0x7f)|value)
}
func (o *DMAMUX_Type) GetCHCFG_SOURCE(idx int) uint32 {
	return volatile.LoadUint32(&o.CHCFG[idx].Reg) & 0x7f
}
func (o *DMAMUX_Type) SetCHCFG_A_ON(idx int, value uint32) {
	volatile.StoreUint32(&o.CHCFG[idx].Reg, volatile.LoadUint32(&o.CHCFG[idx].Reg)&^(0x20000000)|value<<29)
}
func (o *DMAMUX_Type) GetCHCFG_A_ON(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHCFG[idx].Reg) & 0x20000000) >> 29
}
func (o *DMAMUX_Type) SetCHCFG_TRIG(idx int, value uint32) {
	volatile.StoreUint32(&o.CHCFG[idx].Reg, volatile.LoadUint32(&o.CHCFG[idx].Reg)&^(0x40000000)|value<<30)
}
func (o *DMAMUX_Type) GetCHCFG_TRIG(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHCFG[idx].Reg) & 0x40000000) >> 30
}
func (o *DMAMUX_Type) SetCHCFG_ENBL(idx int, value uint32) {
	volatile.StoreUint32(&o.CHCFG[idx].Reg, volatile.LoadUint32(&o.CHCFG[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *DMAMUX_Type) GetCHCFG_ENBL(idx int) uint32 {
	return (volatile.LoadUint32(&o.CHCFG[idx].Reg) & 0x80000000) >> 31
}

// DCP register reference index
type DCP_Type struct {
	CTRL            volatile.Register32 // 0x0
	CTRL_SET        volatile.Register32 // 0x4
	CTRL_CLR        volatile.Register32 // 0x8
	CTRL_TOG        volatile.Register32 // 0xC
	STAT            volatile.Register32 // 0x10
	STAT_SET        volatile.Register32 // 0x14
	STAT_CLR        volatile.Register32 // 0x18
	STAT_TOG        volatile.Register32 // 0x1C
	CHANNELCTRL     volatile.Register32 // 0x20
	CHANNELCTRL_SET volatile.Register32 // 0x24
	CHANNELCTRL_CLR volatile.Register32 // 0x28
	CHANNELCTRL_TOG volatile.Register32 // 0x2C
	CAPABILITY0     volatile.Register32 // 0x30
	_               [12]byte
	CAPABILITY1     volatile.Register32 // 0x40
	_               [12]byte
	CONTEXT         volatile.Register32 // 0x50
	_               [12]byte
	KEY             volatile.Register32 // 0x60
	_               [12]byte
	KEYDATA         volatile.Register32 // 0x70
	_               [12]byte
	PACKET0         volatile.Register32 // 0x80
	_               [12]byte
	PACKET1         volatile.Register32 // 0x90
	_               [12]byte
	PACKET2         volatile.Register32 // 0xA0
	_               [12]byte
	PACKET3         volatile.Register32 // 0xB0
	_               [12]byte
	PACKET4         volatile.Register32 // 0xC0
	_               [12]byte
	PACKET5         volatile.Register32 // 0xD0
	_               [12]byte
	PACKET6         volatile.Register32 // 0xE0
	_               [28]byte
	CH0CMDPTR       volatile.Register32 // 0x100
	_               [12]byte
	CH0SEMA         volatile.Register32 // 0x110
	_               [12]byte
	CH0STAT         volatile.Register32 // 0x120
	CH0STAT_SET     volatile.Register32 // 0x124
	CH0STAT_CLR     volatile.Register32 // 0x128
	CH0STAT_TOG     volatile.Register32 // 0x12C
	CH0OPTS         volatile.Register32 // 0x130
	CH0OPTS_SET     volatile.Register32 // 0x134
	CH0OPTS_CLR     volatile.Register32 // 0x138
	CH0OPTS_TOG     volatile.Register32 // 0x13C
	CH1CMDPTR       volatile.Register32 // 0x140
	_               [12]byte
	CH1SEMA         volatile.Register32 // 0x150
	_               [12]byte
	CH1STAT         volatile.Register32 // 0x160
	CH1STAT_SET     volatile.Register32 // 0x164
	CH1STAT_CLR     volatile.Register32 // 0x168
	CH1STAT_TOG     volatile.Register32 // 0x16C
	CH1OPTS         volatile.Register32 // 0x170
	CH1OPTS_SET     volatile.Register32 // 0x174
	CH1OPTS_CLR     volatile.Register32 // 0x178
	CH1OPTS_TOG     volatile.Register32 // 0x17C
	CH2CMDPTR       volatile.Register32 // 0x180
	_               [12]byte
	CH2SEMA         volatile.Register32 // 0x190
	_               [12]byte
	CH2STAT         volatile.Register32 // 0x1A0
	CH2STAT_SET     volatile.Register32 // 0x1A4
	CH2STAT_CLR     volatile.Register32 // 0x1A8
	CH2STAT_TOG     volatile.Register32 // 0x1AC
	CH2OPTS         volatile.Register32 // 0x1B0
	CH2OPTS_SET     volatile.Register32 // 0x1B4
	CH2OPTS_CLR     volatile.Register32 // 0x1B8
	CH2OPTS_TOG     volatile.Register32 // 0x1BC
	CH3CMDPTR       volatile.Register32 // 0x1C0
	_               [12]byte
	CH3SEMA         volatile.Register32 // 0x1D0
	_               [12]byte
	CH3STAT         volatile.Register32 // 0x1E0
	CH3STAT_SET     volatile.Register32 // 0x1E4
	CH3STAT_CLR     volatile.Register32 // 0x1E8
	CH3STAT_TOG     volatile.Register32 // 0x1EC
	CH3OPTS         volatile.Register32 // 0x1F0
	CH3OPTS_SET     volatile.Register32 // 0x1F4
	CH3OPTS_CLR     volatile.Register32 // 0x1F8
	CH3OPTS_TOG     volatile.Register32 // 0x1FC
	_               [512]byte
	DBGSELECT       volatile.Register32 // 0x400
	_               [12]byte
	DBGDATA         volatile.Register32 // 0x410
	_               [12]byte
	PAGETABLE       volatile.Register32 // 0x420
	_               [12]byte
	VERSION         volatile.Register32 // 0x430
}

// DCP.CTRL: DCP control register 0
func (o *DCP_Type) SetCTRL_CHANNEL_INTERRUPT_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0xff)|value)
}
func (o *DCP_Type) GetCTRL_CHANNEL_INTERRUPT_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0xff
}
func (o *DCP_Type) SetCTRL_ENABLE_CONTEXT_SWITCHING(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x200000)|value<<21)
}
func (o *DCP_Type) GetCTRL_ENABLE_CONTEXT_SWITCHING() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x200000) >> 21
}
func (o *DCP_Type) SetCTRL_ENABLE_CONTEXT_CACHING(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x400000)|value<<22)
}
func (o *DCP_Type) GetCTRL_ENABLE_CONTEXT_CACHING() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x400000) >> 22
}
func (o *DCP_Type) SetCTRL_GATHER_RESIDUAL_WRITES(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x800000)|value<<23)
}
func (o *DCP_Type) GetCTRL_GATHER_RESIDUAL_WRITES() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x800000) >> 23
}
func (o *DCP_Type) SetCTRL_PRESENT_SHA(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10000000)|value<<28)
}
func (o *DCP_Type) GetCTRL_PRESENT_SHA() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10000000) >> 28
}
func (o *DCP_Type) SetCTRL_PRESENT_CRYPTO(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *DCP_Type) GetCTRL_PRESENT_CRYPTO() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20000000) >> 29
}
func (o *DCP_Type) SetCTRL_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *DCP_Type) GetCTRL_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40000000) >> 30
}
func (o *DCP_Type) SetCTRL_SFTRST(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *DCP_Type) GetCTRL_SFTRST() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80000000) >> 31
}

// DCP.CTRL_SET: DCP control register 0
func (o *DCP_Type) SetCTRL_SET_CHANNEL_INTERRUPT_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0xff)|value)
}
func (o *DCP_Type) GetCTRL_SET_CHANNEL_INTERRUPT_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CTRL_SET.Reg) & 0xff
}
func (o *DCP_Type) SetCTRL_SET_ENABLE_CONTEXT_SWITCHING(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x200000)|value<<21)
}
func (o *DCP_Type) GetCTRL_SET_ENABLE_CONTEXT_SWITCHING() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x200000) >> 21
}
func (o *DCP_Type) SetCTRL_SET_ENABLE_CONTEXT_CACHING(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x400000)|value<<22)
}
func (o *DCP_Type) GetCTRL_SET_ENABLE_CONTEXT_CACHING() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x400000) >> 22
}
func (o *DCP_Type) SetCTRL_SET_GATHER_RESIDUAL_WRITES(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x800000)|value<<23)
}
func (o *DCP_Type) GetCTRL_SET_GATHER_RESIDUAL_WRITES() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x800000) >> 23
}
func (o *DCP_Type) SetCTRL_SET_PRESENT_SHA(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x10000000)|value<<28)
}
func (o *DCP_Type) GetCTRL_SET_PRESENT_SHA() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x10000000) >> 28
}
func (o *DCP_Type) SetCTRL_SET_PRESENT_CRYPTO(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x20000000)|value<<29)
}
func (o *DCP_Type) GetCTRL_SET_PRESENT_CRYPTO() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x20000000) >> 29
}
func (o *DCP_Type) SetCTRL_SET_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x40000000)|value<<30)
}
func (o *DCP_Type) GetCTRL_SET_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x40000000) >> 30
}
func (o *DCP_Type) SetCTRL_SET_SFTRST(value uint32) {
	volatile.StoreUint32(&o.CTRL_SET.Reg, volatile.LoadUint32(&o.CTRL_SET.Reg)&^(0x80000000)|value<<31)
}
func (o *DCP_Type) GetCTRL_SET_SFTRST() uint32 {
	return (volatile.LoadUint32(&o.CTRL_SET.Reg) & 0x80000000) >> 31
}

// DCP.CTRL_CLR: DCP control register 0
func (o *DCP_Type) SetCTRL_CLR_CHANNEL_INTERRUPT_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0xff)|value)
}
func (o *DCP_Type) GetCTRL_CLR_CHANNEL_INTERRUPT_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0xff
}
func (o *DCP_Type) SetCTRL_CLR_ENABLE_CONTEXT_SWITCHING(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x200000)|value<<21)
}
func (o *DCP_Type) GetCTRL_CLR_ENABLE_CONTEXT_SWITCHING() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x200000) >> 21
}
func (o *DCP_Type) SetCTRL_CLR_ENABLE_CONTEXT_CACHING(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x400000)|value<<22)
}
func (o *DCP_Type) GetCTRL_CLR_ENABLE_CONTEXT_CACHING() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x400000) >> 22
}
func (o *DCP_Type) SetCTRL_CLR_GATHER_RESIDUAL_WRITES(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x800000)|value<<23)
}
func (o *DCP_Type) GetCTRL_CLR_GATHER_RESIDUAL_WRITES() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x800000) >> 23
}
func (o *DCP_Type) SetCTRL_CLR_PRESENT_SHA(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x10000000)|value<<28)
}
func (o *DCP_Type) GetCTRL_CLR_PRESENT_SHA() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x10000000) >> 28
}
func (o *DCP_Type) SetCTRL_CLR_PRESENT_CRYPTO(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x20000000)|value<<29)
}
func (o *DCP_Type) GetCTRL_CLR_PRESENT_CRYPTO() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x20000000) >> 29
}
func (o *DCP_Type) SetCTRL_CLR_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x40000000)|value<<30)
}
func (o *DCP_Type) GetCTRL_CLR_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x40000000) >> 30
}
func (o *DCP_Type) SetCTRL_CLR_SFTRST(value uint32) {
	volatile.StoreUint32(&o.CTRL_CLR.Reg, volatile.LoadUint32(&o.CTRL_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *DCP_Type) GetCTRL_CLR_SFTRST() uint32 {
	return (volatile.LoadUint32(&o.CTRL_CLR.Reg) & 0x80000000) >> 31
}

// DCP.CTRL_TOG: DCP control register 0
func (o *DCP_Type) SetCTRL_TOG_CHANNEL_INTERRUPT_ENABLE(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0xff)|value)
}
func (o *DCP_Type) GetCTRL_TOG_CHANNEL_INTERRUPT_ENABLE() uint32 {
	return volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0xff
}
func (o *DCP_Type) SetCTRL_TOG_ENABLE_CONTEXT_SWITCHING(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x200000)|value<<21)
}
func (o *DCP_Type) GetCTRL_TOG_ENABLE_CONTEXT_SWITCHING() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x200000) >> 21
}
func (o *DCP_Type) SetCTRL_TOG_ENABLE_CONTEXT_CACHING(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x400000)|value<<22)
}
func (o *DCP_Type) GetCTRL_TOG_ENABLE_CONTEXT_CACHING() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x400000) >> 22
}
func (o *DCP_Type) SetCTRL_TOG_GATHER_RESIDUAL_WRITES(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x800000)|value<<23)
}
func (o *DCP_Type) GetCTRL_TOG_GATHER_RESIDUAL_WRITES() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x800000) >> 23
}
func (o *DCP_Type) SetCTRL_TOG_PRESENT_SHA(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x10000000)|value<<28)
}
func (o *DCP_Type) GetCTRL_TOG_PRESENT_SHA() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x10000000) >> 28
}
func (o *DCP_Type) SetCTRL_TOG_PRESENT_CRYPTO(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x20000000)|value<<29)
}
func (o *DCP_Type) GetCTRL_TOG_PRESENT_CRYPTO() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x20000000) >> 29
}
func (o *DCP_Type) SetCTRL_TOG_CLKGATE(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x40000000)|value<<30)
}
func (o *DCP_Type) GetCTRL_TOG_CLKGATE() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x40000000) >> 30
}
func (o *DCP_Type) SetCTRL_TOG_SFTRST(value uint32) {
	volatile.StoreUint32(&o.CTRL_TOG.Reg, volatile.LoadUint32(&o.CTRL_TOG.Reg)&^(0x80000000)|value<<31)
}
func (o *DCP_Type) GetCTRL_TOG_SFTRST() uint32 {
	return (volatile.LoadUint32(&o.CTRL_TOG.Reg) & 0x80000000) >> 31
}

// DCP.STAT: DCP status register
func (o *DCP_Type) SetSTAT_IRQ(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0xf)|value)
}
func (o *DCP_Type) GetSTAT_IRQ() uint32 {
	return volatile.LoadUint32(&o.STAT.Reg) & 0xf
}
func (o *DCP_Type) SetSTAT_READY_CHANNELS(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0xff0000)|value<<16)
}
func (o *DCP_Type) GetSTAT_READY_CHANNELS() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0xff0000) >> 16
}
func (o *DCP_Type) SetSTAT_CUR_CHANNEL(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0xf000000)|value<<24)
}
func (o *DCP_Type) GetSTAT_CUR_CHANNEL() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0xf000000) >> 24
}
func (o *DCP_Type) SetSTAT_OTP_KEY_READY(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x10000000)|value<<28)
}
func (o *DCP_Type) GetSTAT_OTP_KEY_READY() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x10000000) >> 28
}

// DCP.STAT_SET: DCP status register
func (o *DCP_Type) SetSTAT_SET_IRQ(value uint32) {
	volatile.StoreUint32(&o.STAT_SET.Reg, volatile.LoadUint32(&o.STAT_SET.Reg)&^(0xf)|value)
}
func (o *DCP_Type) GetSTAT_SET_IRQ() uint32 {
	return volatile.LoadUint32(&o.STAT_SET.Reg) & 0xf
}
func (o *DCP_Type) SetSTAT_SET_READY_CHANNELS(value uint32) {
	volatile.StoreUint32(&o.STAT_SET.Reg, volatile.LoadUint32(&o.STAT_SET.Reg)&^(0xff0000)|value<<16)
}
func (o *DCP_Type) GetSTAT_SET_READY_CHANNELS() uint32 {
	return (volatile.LoadUint32(&o.STAT_SET.Reg) & 0xff0000) >> 16
}
func (o *DCP_Type) SetSTAT_SET_CUR_CHANNEL(value uint32) {
	volatile.StoreUint32(&o.STAT_SET.Reg, volatile.LoadUint32(&o.STAT_SET.Reg)&^(0xf000000)|value<<24)
}
func (o *DCP_Type) GetSTAT_SET_CUR_CHANNEL() uint32 {
	return (volatile.LoadUint32(&o.STAT_SET.Reg) & 0xf000000) >> 24
}
func (o *DCP_Type) SetSTAT_SET_OTP_KEY_READY(value uint32) {
	volatile.StoreUint32(&o.STAT_SET.Reg, volatile.LoadUint32(&o.STAT_SET.Reg)&^(0x10000000)|value<<28)
}
func (o *DCP_Type) GetSTAT_SET_OTP_KEY_READY() uint32 {
	return (volatile.LoadUint32(&o.STAT_SET.Reg) & 0x10000000) >> 28
}

// DCP.STAT_CLR: DCP status register
func (o *DCP_Type) SetSTAT_CLR_IRQ(value uint32) {
	volatile.StoreUint32(&o.STAT_CLR.Reg, volatile.LoadUint32(&o.STAT_CLR.Reg)&^(0xf)|value)
}
func (o *DCP_Type) GetSTAT_CLR_IRQ() uint32 {
	return volatile.LoadUint32(&o.STAT_CLR.Reg) & 0xf
}
func (o *DCP_Type) SetSTAT_CLR_READY_CHANNELS(value uint32) {
	volatile.StoreUint32(&o.STAT_CLR.Reg, volatile.LoadUint32(&o.STAT_CLR.Reg)&^(0xff0000)|value<<16)
}
func (o *DCP_Type) GetSTAT_CLR_READY_CHANNELS() uint32 {
	return (volatile.LoadUint32(&o.STAT_CLR.Reg) & 0xff0000) >> 16
}
func (o *DCP_Type) SetSTAT_CLR_CUR_CHANNEL(value uint32) {
	volatile.StoreUint32(&o.STAT_CLR.Reg, volatile.LoadUint32(&o.STAT_CLR.Reg)&^(0xf000000)|value<<24)
}
func (o *DCP_Type) GetSTAT_CLR_CUR_CHANNEL() uint32 {
	return (volatile.LoadUint32(&o.STAT_CLR.Reg) & 0xf000000) >> 24
}
func (o *DCP_Type) SetSTAT_CLR_OTP_KEY_READY(value uint32) {
	volatile.StoreUint32(&o.STAT_CLR.Reg, volatile.LoadUint32(&o.STAT_CLR.Reg)&^(0x10000000)|value<<28)
}
func (o *DCP_Type) GetSTAT_CLR_OTP_KEY_READY() uint32 {
	return (volatile.LoadUint32(&o.STAT_CLR.Reg) & 0x10000000) >> 28
}

// DCP.STAT_TOG: DCP status register
func (o *DCP_Type) SetSTAT_TOG_IRQ(value uint32) {
	volatile.StoreUint32(&o.STAT_TOG.Reg, volatile.LoadUint32(&o.STAT_TOG.Reg)&^(0xf)|value)
}
func (o *DCP_Type) GetSTAT_TOG_IRQ() uint32 {
	return volatile.LoadUint32(&o.STAT_TOG.Reg) & 0xf
}
func (o *DCP_Type) SetSTAT_TOG_READY_CHANNELS(value uint32) {
	volatile.StoreUint32(&o.STAT_TOG.Reg, volatile.LoadUint32(&o.STAT_TOG.Reg)&^(0xff0000)|value<<16)
}
func (o *DCP_Type) GetSTAT_TOG_READY_CHANNELS() uint32 {
	return (volatile.LoadUint32(&o.STAT_TOG.Reg) & 0xff0000) >> 16
}
func (o *DCP_Type) SetSTAT_TOG_CUR_CHANNEL(value uint32) {
	volatile.StoreUint32(&o.STAT_TOG.Reg, volatile.LoadUint32(&o.STAT_TOG.Reg)&^(0xf000000)|value<<24)
}
func (o *DCP_Type) GetSTAT_TOG_CUR_CHANNEL() uint32 {
	return (volatile.LoadUint32(&o.STAT_TOG.Reg) & 0xf000000) >> 24
}
func (o *DCP_Type) SetSTAT_TOG_OTP_KEY_READY(value uint32) {
	volatile.StoreUint32(&o.STAT_TOG.Reg, volatile.LoadUint32(&o.STAT_TOG.Reg)&^(0x10000000)|value<<28)
}
func (o *DCP_Type) GetSTAT_TOG_OTP_KEY_READY() uint32 {
	return (volatile.LoadUint32(&o.STAT_TOG.Reg) & 0x10000000) >> 28
}

// DCP.CHANNELCTRL: DCP channel control register
func (o *DCP_Type) SetCHANNELCTRL_ENABLE_CHANNEL(value uint32) {
	volatile.StoreUint32(&o.CHANNELCTRL.Reg, volatile.LoadUint32(&o.CHANNELCTRL.Reg)&^(0xff)|value)
}
func (o *DCP_Type) GetCHANNELCTRL_ENABLE_CHANNEL() uint32 {
	return volatile.LoadUint32(&o.CHANNELCTRL.Reg) & 0xff
}
func (o *DCP_Type) SetCHANNELCTRL_HIGH_PRIORITY_CHANNEL(value uint32) {
	volatile.StoreUint32(&o.CHANNELCTRL.Reg, volatile.LoadUint32(&o.CHANNELCTRL.Reg)&^(0xff00)|value<<8)
}
func (o *DCP_Type) GetCHANNELCTRL_HIGH_PRIORITY_CHANNEL() uint32 {
	return (volatile.LoadUint32(&o.CHANNELCTRL.Reg) & 0xff00) >> 8
}
func (o *DCP_Type) SetCHANNELCTRL_CH0_IRQ_MERGED(value uint32) {
	volatile.StoreUint32(&o.CHANNELCTRL.Reg, volatile.LoadUint32(&o.CHANNELCTRL.Reg)&^(0x10000)|value<<16)
}
func (o *DCP_Type) GetCHANNELCTRL_CH0_IRQ_MERGED() uint32 {
	return (volatile.LoadUint32(&o.CHANNELCTRL.Reg) & 0x10000) >> 16
}

// DCP.CHANNELCTRL_SET: DCP channel control register
func (o *DCP_Type) SetCHANNELCTRL_SET_ENABLE_CHANNEL(value uint32) {
	volatile.StoreUint32(&o.CHANNELCTRL_SET.Reg, volatile.LoadUint32(&o.CHANNELCTRL_SET.Reg)&^(0xff)|value)
}
func (o *DCP_Type) GetCHANNELCTRL_SET_ENABLE_CHANNEL() uint32 {
	return volatile.LoadUint32(&o.CHANNELCTRL_SET.Reg) & 0xff
}
func (o *DCP_Type) SetCHANNELCTRL_SET_HIGH_PRIORITY_CHANNEL(value uint32) {
	volatile.StoreUint32(&o.CHANNELCTRL_SET.Reg, volatile.LoadUint32(&o.CHANNELCTRL_SET.Reg)&^(0xff00)|value<<8)
}
func (o *DCP_Type) GetCHANNELCTRL_SET_HIGH_PRIORITY_CHANNEL() uint32 {
	return (volatile.LoadUint32(&o.CHANNELCTRL_SET.Reg) & 0xff00) >> 8
}
func (o *DCP_Type) SetCHANNELCTRL_SET_CH0_IRQ_MERGED(value uint32) {
	volatile.StoreUint32(&o.CHANNELCTRL_SET.Reg, volatile.LoadUint32(&o.CHANNELCTRL_SET.Reg)&^(0x10000)|value<<16)
}
func (o *DCP_Type) GetCHANNELCTRL_SET_CH0_IRQ_MERGED() uint32 {
	return (volatile.LoadUint32(&o.CHANNELCTRL_SET.Reg) & 0x10000) >> 16
}

// DCP.CHANNELCTRL_CLR: DCP channel control register
func (o *DCP_Type) SetCHANNELCTRL_CLR_ENABLE_CHANNEL(value uint32) {
	volatile.StoreUint32(&o.CHANNELCTRL_CLR.Reg, volatile.LoadUint32(&o.CHANNELCTRL_CLR.Reg)&^(0xff)|value)
}
func (o *DCP_Type) GetCHANNELCTRL_CLR_ENABLE_CHANNEL() uint32 {
	return volatile.LoadUint32(&o.CHANNELCTRL_CLR.Reg) & 0xff
}
func (o *DCP_Type) SetCHANNELCTRL_CLR_HIGH_PRIORITY_CHANNEL(value uint32) {
	volatile.StoreUint32(&o.CHANNELCTRL_CLR.Reg, volatile.LoadUint32(&o.CHANNELCTRL_CLR.Reg)&^(0xff00)|value<<8)
}
func (o *DCP_Type) GetCHANNELCTRL_CLR_HIGH_PRIORITY_CHANNEL() uint32 {
	return (volatile.LoadUint32(&o.CHANNELCTRL_CLR.Reg) & 0xff00) >> 8
}
func (o *DCP_Type) SetCHANNELCTRL_CLR_CH0_IRQ_MERGED(value uint32) {
	volatile.StoreUint32(&o.CHANNELCTRL_CLR.Reg, volatile.LoadUint32(&o.CHANNELCTRL_CLR.Reg)&^(0x10000)|value<<16)
}
func (o *DCP_Type) GetCHANNELCTRL_CLR_CH0_IRQ_MERGED() uint32 {
	return (volatile.LoadUint32(&o.CHANNELCTRL_CLR.Reg) & 0x10000) >> 16
}

// DCP.CHANNELCTRL_TOG: DCP channel control register
func (o *DCP_Type) SetCHANNELCTRL_TOG_ENABLE_CHANNEL(value uint32) {
	volatile.StoreUint32(&o.CHANNELCTRL_TOG.Reg, volatile.LoadUint32(&o.CHANNELCTRL_TOG.Reg)&^(0xff)|value)
}
func (o *DCP_Type) GetCHANNELCTRL_TOG_ENABLE_CHANNEL() uint32 {
	return volatile.LoadUint32(&o.CHANNELCTRL_TOG.Reg) & 0xff
}
func (o *DCP_Type) SetCHANNELCTRL_TOG_HIGH_PRIORITY_CHANNEL(value uint32) {
	volatile.StoreUint32(&o.CHANNELCTRL_TOG.Reg, volatile.LoadUint32(&o.CHANNELCTRL_TOG.Reg)&^(0xff00)|value<<8)
}
func (o *DCP_Type) GetCHANNELCTRL_TOG_HIGH_PRIORITY_CHANNEL() uint32 {
	return (volatile.LoadUint32(&o.CHANNELCTRL_TOG.Reg) & 0xff00) >> 8
}
func (o *DCP_Type) SetCHANNELCTRL_TOG_CH0_IRQ_MERGED(value uint32) {
	volatile.StoreUint32(&o.CHANNELCTRL_TOG.Reg, volatile.LoadUint32(&o.CHANNELCTRL_TOG.Reg)&^(0x10000)|value<<16)
}
func (o *DCP_Type) GetCHANNELCTRL_TOG_CH0_IRQ_MERGED() uint32 {
	return (volatile.LoadUint32(&o.CHANNELCTRL_TOG.Reg) & 0x10000) >> 16
}

// DCP.CAPABILITY0: DCP capability 0 register
func (o *DCP_Type) SetCAPABILITY0_NUM_KEYS(value uint32) {
	volatile.StoreUint32(&o.CAPABILITY0.Reg, volatile.LoadUint32(&o.CAPABILITY0.Reg)&^(0xff)|value)
}
func (o *DCP_Type) GetCAPABILITY0_NUM_KEYS() uint32 {
	return volatile.LoadUint32(&o.CAPABILITY0.Reg) & 0xff
}
func (o *DCP_Type) SetCAPABILITY0_NUM_CHANNELS(value uint32) {
	volatile.StoreUint32(&o.CAPABILITY0.Reg, volatile.LoadUint32(&o.CAPABILITY0.Reg)&^(0xf00)|value<<8)
}
func (o *DCP_Type) GetCAPABILITY0_NUM_CHANNELS() uint32 {
	return (volatile.LoadUint32(&o.CAPABILITY0.Reg) & 0xf00) >> 8
}
func (o *DCP_Type) SetCAPABILITY0_DISABLE_UNIQUE_KEY(value uint32) {
	volatile.StoreUint32(&o.CAPABILITY0.Reg, volatile.LoadUint32(&o.CAPABILITY0.Reg)&^(0x20000000)|value<<29)
}
func (o *DCP_Type) GetCAPABILITY0_DISABLE_UNIQUE_KEY() uint32 {
	return (volatile.LoadUint32(&o.CAPABILITY0.Reg) & 0x20000000) >> 29
}
func (o *DCP_Type) SetCAPABILITY0_DISABLE_DECRYPT(value uint32) {
	volatile.StoreUint32(&o.CAPABILITY0.Reg, volatile.LoadUint32(&o.CAPABILITY0.Reg)&^(0x80000000)|value<<31)
}
func (o *DCP_Type) GetCAPABILITY0_DISABLE_DECRYPT() uint32 {
	return (volatile.LoadUint32(&o.CAPABILITY0.Reg) & 0x80000000) >> 31
}

// DCP.CAPABILITY1: DCP capability 1 register
func (o *DCP_Type) SetCAPABILITY1_CIPHER_ALGORITHMS(value uint32) {
	volatile.StoreUint32(&o.CAPABILITY1.Reg, volatile.LoadUint32(&o.CAPABILITY1.Reg)&^(0xffff)|value)
}
func (o *DCP_Type) GetCAPABILITY1_CIPHER_ALGORITHMS() uint32 {
	return volatile.LoadUint32(&o.CAPABILITY1.Reg) & 0xffff
}
func (o *DCP_Type) SetCAPABILITY1_HASH_ALGORITHMS(value uint32) {
	volatile.StoreUint32(&o.CAPABILITY1.Reg, volatile.LoadUint32(&o.CAPABILITY1.Reg)&^(0xffff0000)|value<<16)
}
func (o *DCP_Type) GetCAPABILITY1_HASH_ALGORITHMS() uint32 {
	return (volatile.LoadUint32(&o.CAPABILITY1.Reg) & 0xffff0000) >> 16
}

// DCP.CONTEXT: DCP context buffer pointer
func (o *DCP_Type) SetCONTEXT(value uint32) {
	volatile.StoreUint32(&o.CONTEXT.Reg, value)
}
func (o *DCP_Type) GetCONTEXT() uint32 {
	return volatile.LoadUint32(&o.CONTEXT.Reg)
}

// DCP.KEY: DCP key index
func (o *DCP_Type) SetKEY_SUBWORD(value uint32) {
	volatile.StoreUint32(&o.KEY.Reg, volatile.LoadUint32(&o.KEY.Reg)&^(0x3)|value)
}
func (o *DCP_Type) GetKEY_SUBWORD() uint32 {
	return volatile.LoadUint32(&o.KEY.Reg) & 0x3
}
func (o *DCP_Type) SetKEY_INDEX(value uint32) {
	volatile.StoreUint32(&o.KEY.Reg, volatile.LoadUint32(&o.KEY.Reg)&^(0x30)|value<<4)
}
func (o *DCP_Type) GetKEY_INDEX() uint32 {
	return (volatile.LoadUint32(&o.KEY.Reg) & 0x30) >> 4
}

// DCP.KEYDATA: DCP key data
func (o *DCP_Type) SetKEYDATA(value uint32) {
	volatile.StoreUint32(&o.KEYDATA.Reg, value)
}
func (o *DCP_Type) GetKEYDATA() uint32 {
	return volatile.LoadUint32(&o.KEYDATA.Reg)
}

// DCP.PACKET0: DCP work packet 0 status register
func (o *DCP_Type) SetPACKET0(value uint32) {
	volatile.StoreUint32(&o.PACKET0.Reg, value)
}
func (o *DCP_Type) GetPACKET0() uint32 {
	return volatile.LoadUint32(&o.PACKET0.Reg)
}

// DCP.PACKET1: DCP work packet 1 status register
func (o *DCP_Type) SetPACKET1_INTERRUPT(value uint32) {
	volatile.StoreUint32(&o.PACKET1.Reg, volatile.LoadUint32(&o.PACKET1.Reg)&^(0x1)|value)
}
func (o *DCP_Type) GetPACKET1_INTERRUPT() uint32 {
	return volatile.LoadUint32(&o.PACKET1.Reg) & 0x1
}
func (o *DCP_Type) SetPACKET1_DECR_SEMAPHORE(value uint32) {
	volatile.StoreUint32(&o.PACKET1.Reg, volatile.LoadUint32(&o.PACKET1.Reg)&^(0x2)|value<<1)
}
func (o *DCP_Type) GetPACKET1_DECR_SEMAPHORE() uint32 {
	return (volatile.LoadUint32(&o.PACKET1.Reg) & 0x2) >> 1
}
func (o *DCP_Type) SetPACKET1_CHAIN(value uint32) {
	volatile.StoreUint32(&o.PACKET1.Reg, volatile.LoadUint32(&o.PACKET1.Reg)&^(0x4)|value<<2)
}
func (o *DCP_Type) GetPACKET1_CHAIN() uint32 {
	return (volatile.LoadUint32(&o.PACKET1.Reg) & 0x4) >> 2
}
func (o *DCP_Type) SetPACKET1_CHAIN_CONTIGUOUS(value uint32) {
	volatile.StoreUint32(&o.PACKET1.Reg, volatile.LoadUint32(&o.PACKET1.Reg)&^(0x8)|value<<3)
}
func (o *DCP_Type) GetPACKET1_CHAIN_CONTIGUOUS() uint32 {
	return (volatile.LoadUint32(&o.PACKET1.Reg) & 0x8) >> 3
}
func (o *DCP_Type) SetPACKET1_ENABLE_MEMCOPY(value uint32) {
	volatile.StoreUint32(&o.PACKET1.Reg, volatile.LoadUint32(&o.PACKET1.Reg)&^(0x10)|value<<4)
}
func (o *DCP_Type) GetPACKET1_ENABLE_MEMCOPY() uint32 {
	return (volatile.LoadUint32(&o.PACKET1.Reg) & 0x10) >> 4
}
func (o *DCP_Type) SetPACKET1_ENABLE_CIPHER(value uint32) {
	volatile.StoreUint32(&o.PACKET1.Reg, volatile.LoadUint32(&o.PACKET1.Reg)&^(0x20)|value<<5)
}
func (o *DCP_Type) GetPACKET1_ENABLE_CIPHER() uint32 {
	return (volatile.LoadUint32(&o.PACKET1.Reg) & 0x20) >> 5
}
func (o *DCP_Type) SetPACKET1_ENABLE_HASH(value uint32) {
	volatile.StoreUint32(&o.PACKET1.Reg, volatile.LoadUint32(&o.PACKET1.Reg)&^(0x40)|value<<6)
}
func (o *DCP_Type) GetPACKET1_ENABLE_HASH() uint32 {
	return (volatile.LoadUint32(&o.PACKET1.Reg) & 0x40) >> 6
}
func (o *DCP_Type) SetPACKET1_ENABLE_BLIT(value uint32) {
	volatile.StoreUint32(&o.PACKET1.Reg, volatile.LoadUint32(&o.PACKET1.Reg)&^(0x80)|value<<7)
}
func (o *DCP_Type) GetPACKET1_ENABLE_BLIT() uint32 {
	return (volatile.LoadUint32(&o.PACKET1.Reg) & 0x80) >> 7
}
func (o *DCP_Type) SetPACKET1_CIPHER_ENCRYPT(value uint32) {
	volatile.StoreUint32(&o.PACKET1.Reg, volatile.LoadUint32(&o.PACKET1.Reg)&^(0x100)|value<<8)
}
func (o *DCP_Type) GetPACKET1_CIPHER_ENCRYPT() uint32 {
	return (volatile.LoadUint32(&o.PACKET1.Reg) & 0x100) >> 8
}
func (o *DCP_Type) SetPACKET1_CIPHER_INIT(value uint32) {
	volatile.StoreUint32(&o.PACKET1.Reg, volatile.LoadUint32(&o.PACKET1.Reg)&^(0x200)|value<<9)
}
func (o *DCP_Type) GetPACKET1_CIPHER_INIT() uint32 {
	return (volatile.LoadUint32(&o.PACKET1.Reg) & 0x200) >> 9
}
func (o *DCP_Type) SetPACKET1_OTP_KEY(value uint32) {
	volatile.StoreUint32(&o.PACKET1.Reg, volatile.LoadUint32(&o.PACKET1.Reg)&^(0x400)|value<<10)
}
func (o *DCP_Type) GetPACKET1_OTP_KEY() uint32 {
	return (volatile.LoadUint32(&o.PACKET1.Reg) & 0x400) >> 10
}
func (o *DCP_Type) SetPACKET1_PAYLOAD_KEY(value uint32) {
	volatile.StoreUint32(&o.PACKET1.Reg, volatile.LoadUint32(&o.PACKET1.Reg)&^(0x800)|value<<11)
}
func (o *DCP_Type) GetPACKET1_PAYLOAD_KEY() uint32 {
	return (volatile.LoadUint32(&o.PACKET1.Reg) & 0x800) >> 11
}
func (o *DCP_Type) SetPACKET1_HASH_INIT(value uint32) {
	volatile.StoreUint32(&o.PACKET1.Reg, volatile.LoadUint32(&o.PACKET1.Reg)&^(0x1000)|value<<12)
}
func (o *DCP_Type) GetPACKET1_HASH_INIT() uint32 {
	return (volatile.LoadUint32(&o.PACKET1.Reg) & 0x1000) >> 12
}
func (o *DCP_Type) SetPACKET1_HASH_TERM(value uint32) {
	volatile.StoreUint32(&o.PACKET1.Reg, volatile.LoadUint32(&o.PACKET1.Reg)&^(0x2000)|value<<13)
}
func (o *DCP_Type) GetPACKET1_HASH_TERM() uint32 {
	return (volatile.LoadUint32(&o.PACKET1.Reg) & 0x2000) >> 13
}
func (o *DCP_Type) SetPACKET1_CHECK_HASH(value uint32) {
	volatile.StoreUint32(&o.PACKET1.Reg, volatile.LoadUint32(&o.PACKET1.Reg)&^(0x4000)|value<<14)
}
func (o *DCP_Type) GetPACKET1_CHECK_HASH() uint32 {
	return (volatile.LoadUint32(&o.PACKET1.Reg) & 0x4000) >> 14
}
func (o *DCP_Type) SetPACKET1_HASH_OUTPUT(value uint32) {
	volatile.StoreUint32(&o.PACKET1.Reg, volatile.LoadUint32(&o.PACKET1.Reg)&^(0x8000)|value<<15)
}
func (o *DCP_Type) GetPACKET1_HASH_OUTPUT() uint32 {
	return (volatile.LoadUint32(&o.PACKET1.Reg) & 0x8000) >> 15
}
func (o *DCP_Type) SetPACKET1_CONSTANT_FILL(value uint32) {
	volatile.StoreUint32(&o.PACKET1.Reg, volatile.LoadUint32(&o.PACKET1.Reg)&^(0x10000)|value<<16)
}
func (o *DCP_Type) GetPACKET1_CONSTANT_FILL() uint32 {
	return (volatile.LoadUint32(&o.PACKET1.Reg) & 0x10000) >> 16
}
func (o *DCP_Type) SetPACKET1_TEST_SEMA_IRQ(value uint32) {
	volatile.StoreUint32(&o.PACKET1.Reg, volatile.LoadUint32(&o.PACKET1.Reg)&^(0x20000)|value<<17)
}
func (o *DCP_Type) GetPACKET1_TEST_SEMA_IRQ() uint32 {
	return (volatile.LoadUint32(&o.PACKET1.Reg) & 0x20000) >> 17
}
func (o *DCP_Type) SetPACKET1_KEY_BYTESWAP(value uint32) {
	volatile.StoreUint32(&o.PACKET1.Reg, volatile.LoadUint32(&o.PACKET1.Reg)&^(0x40000)|value<<18)
}
func (o *DCP_Type) GetPACKET1_KEY_BYTESWAP() uint32 {
	return (volatile.LoadUint32(&o.PACKET1.Reg) & 0x40000) >> 18
}
func (o *DCP_Type) SetPACKET1_KEY_WORDSWAP(value uint32) {
	volatile.StoreUint32(&o.PACKET1.Reg, volatile.LoadUint32(&o.PACKET1.Reg)&^(0x80000)|value<<19)
}
func (o *DCP_Type) GetPACKET1_KEY_WORDSWAP() uint32 {
	return (volatile.LoadUint32(&o.PACKET1.Reg) & 0x80000) >> 19
}
func (o *DCP_Type) SetPACKET1_INPUT_BYTESWAP(value uint32) {
	volatile.StoreUint32(&o.PACKET1.Reg, volatile.LoadUint32(&o.PACKET1.Reg)&^(0x100000)|value<<20)
}
func (o *DCP_Type) GetPACKET1_INPUT_BYTESWAP() uint32 {
	return (volatile.LoadUint32(&o.PACKET1.Reg) & 0x100000) >> 20
}
func (o *DCP_Type) SetPACKET1_INPUT_WORDSWAP(value uint32) {
	volatile.StoreUint32(&o.PACKET1.Reg, volatile.LoadUint32(&o.PACKET1.Reg)&^(0x200000)|value<<21)
}
func (o *DCP_Type) GetPACKET1_INPUT_WORDSWAP() uint32 {
	return (volatile.LoadUint32(&o.PACKET1.Reg) & 0x200000) >> 21
}
func (o *DCP_Type) SetPACKET1_OUTPUT_BYTESWAP(value uint32) {
	volatile.StoreUint32(&o.PACKET1.Reg, volatile.LoadUint32(&o.PACKET1.Reg)&^(0x400000)|value<<22)
}
func (o *DCP_Type) GetPACKET1_OUTPUT_BYTESWAP() uint32 {
	return (volatile.LoadUint32(&o.PACKET1.Reg) & 0x400000) >> 22
}
func (o *DCP_Type) SetPACKET1_OUTPUT_WORDSWAP(value uint32) {
	volatile.StoreUint32(&o.PACKET1.Reg, volatile.LoadUint32(&o.PACKET1.Reg)&^(0x800000)|value<<23)
}
func (o *DCP_Type) GetPACKET1_OUTPUT_WORDSWAP() uint32 {
	return (volatile.LoadUint32(&o.PACKET1.Reg) & 0x800000) >> 23
}
func (o *DCP_Type) SetPACKET1_TAG(value uint32) {
	volatile.StoreUint32(&o.PACKET1.Reg, volatile.LoadUint32(&o.PACKET1.Reg)&^(0xff000000)|value<<24)
}
func (o *DCP_Type) GetPACKET1_TAG() uint32 {
	return (volatile.LoadUint32(&o.PACKET1.Reg) & 0xff000000) >> 24
}

// DCP.PACKET2: DCP work packet 2 status register
func (o *DCP_Type) SetPACKET2_CIPHER_SELECT(value uint32) {
	volatile.StoreUint32(&o.PACKET2.Reg, volatile.LoadUint32(&o.PACKET2.Reg)&^(0xf)|value)
}
func (o *DCP_Type) GetPACKET2_CIPHER_SELECT() uint32 {
	return volatile.LoadUint32(&o.PACKET2.Reg) & 0xf
}
func (o *DCP_Type) SetPACKET2_CIPHER_MODE(value uint32) {
	volatile.StoreUint32(&o.PACKET2.Reg, volatile.LoadUint32(&o.PACKET2.Reg)&^(0xf0)|value<<4)
}
func (o *DCP_Type) GetPACKET2_CIPHER_MODE() uint32 {
	return (volatile.LoadUint32(&o.PACKET2.Reg) & 0xf0) >> 4
}
func (o *DCP_Type) SetPACKET2_KEY_SELECT(value uint32) {
	volatile.StoreUint32(&o.PACKET2.Reg, volatile.LoadUint32(&o.PACKET2.Reg)&^(0xff00)|value<<8)
}
func (o *DCP_Type) GetPACKET2_KEY_SELECT() uint32 {
	return (volatile.LoadUint32(&o.PACKET2.Reg) & 0xff00) >> 8
}
func (o *DCP_Type) SetPACKET2_HASH_SELECT(value uint32) {
	volatile.StoreUint32(&o.PACKET2.Reg, volatile.LoadUint32(&o.PACKET2.Reg)&^(0xf0000)|value<<16)
}
func (o *DCP_Type) GetPACKET2_HASH_SELECT() uint32 {
	return (volatile.LoadUint32(&o.PACKET2.Reg) & 0xf0000) >> 16
}
func (o *DCP_Type) SetPACKET2_CIPHER_CFG(value uint32) {
	volatile.StoreUint32(&o.PACKET2.Reg, volatile.LoadUint32(&o.PACKET2.Reg)&^(0xff000000)|value<<24)
}
func (o *DCP_Type) GetPACKET2_CIPHER_CFG() uint32 {
	return (volatile.LoadUint32(&o.PACKET2.Reg) & 0xff000000) >> 24
}

// DCP.PACKET3: DCP work packet 3 status register
func (o *DCP_Type) SetPACKET3(value uint32) {
	volatile.StoreUint32(&o.PACKET3.Reg, value)
}
func (o *DCP_Type) GetPACKET3() uint32 {
	return volatile.LoadUint32(&o.PACKET3.Reg)
}

// DCP.PACKET4: DCP work packet 4 status register
func (o *DCP_Type) SetPACKET4(value uint32) {
	volatile.StoreUint32(&o.PACKET4.Reg, value)
}
func (o *DCP_Type) GetPACKET4() uint32 {
	return volatile.LoadUint32(&o.PACKET4.Reg)
}

// DCP.PACKET5: DCP work packet 5 status register
func (o *DCP_Type) SetPACKET5(value uint32) {
	volatile.StoreUint32(&o.PACKET5.Reg, value)
}
func (o *DCP_Type) GetPACKET5() uint32 {
	return volatile.LoadUint32(&o.PACKET5.Reg)
}

// DCP.PACKET6: DCP work packet 6 status register
func (o *DCP_Type) SetPACKET6(value uint32) {
	volatile.StoreUint32(&o.PACKET6.Reg, value)
}
func (o *DCP_Type) GetPACKET6() uint32 {
	return volatile.LoadUint32(&o.PACKET6.Reg)
}

// DCP.CH0CMDPTR: DCP channel 0 command pointer address register
func (o *DCP_Type) SetCH0CMDPTR(value uint32) {
	volatile.StoreUint32(&o.CH0CMDPTR.Reg, value)
}
func (o *DCP_Type) GetCH0CMDPTR() uint32 {
	return volatile.LoadUint32(&o.CH0CMDPTR.Reg)
}

// DCP.CH0SEMA: DCP channel 0 semaphore register
func (o *DCP_Type) SetCH0SEMA_INCREMENT(value uint32) {
	volatile.StoreUint32(&o.CH0SEMA.Reg, volatile.LoadUint32(&o.CH0SEMA.Reg)&^(0xff)|value)
}
func (o *DCP_Type) GetCH0SEMA_INCREMENT() uint32 {
	return volatile.LoadUint32(&o.CH0SEMA.Reg) & 0xff
}
func (o *DCP_Type) SetCH0SEMA_VALUE(value uint32) {
	volatile.StoreUint32(&o.CH0SEMA.Reg, volatile.LoadUint32(&o.CH0SEMA.Reg)&^(0xff0000)|value<<16)
}
func (o *DCP_Type) GetCH0SEMA_VALUE() uint32 {
	return (volatile.LoadUint32(&o.CH0SEMA.Reg) & 0xff0000) >> 16
}

// DCP.CH0STAT: DCP channel 0 status register
func (o *DCP_Type) SetCH0STAT_HASH_MISMATCH(value uint32) {
	volatile.StoreUint32(&o.CH0STAT.Reg, volatile.LoadUint32(&o.CH0STAT.Reg)&^(0x2)|value<<1)
}
func (o *DCP_Type) GetCH0STAT_HASH_MISMATCH() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT.Reg) & 0x2) >> 1
}
func (o *DCP_Type) SetCH0STAT_ERROR_SETUP(value uint32) {
	volatile.StoreUint32(&o.CH0STAT.Reg, volatile.LoadUint32(&o.CH0STAT.Reg)&^(0x4)|value<<2)
}
func (o *DCP_Type) GetCH0STAT_ERROR_SETUP() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT.Reg) & 0x4) >> 2
}
func (o *DCP_Type) SetCH0STAT_ERROR_PACKET(value uint32) {
	volatile.StoreUint32(&o.CH0STAT.Reg, volatile.LoadUint32(&o.CH0STAT.Reg)&^(0x8)|value<<3)
}
func (o *DCP_Type) GetCH0STAT_ERROR_PACKET() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT.Reg) & 0x8) >> 3
}
func (o *DCP_Type) SetCH0STAT_ERROR_SRC(value uint32) {
	volatile.StoreUint32(&o.CH0STAT.Reg, volatile.LoadUint32(&o.CH0STAT.Reg)&^(0x10)|value<<4)
}
func (o *DCP_Type) GetCH0STAT_ERROR_SRC() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT.Reg) & 0x10) >> 4
}
func (o *DCP_Type) SetCH0STAT_ERROR_DST(value uint32) {
	volatile.StoreUint32(&o.CH0STAT.Reg, volatile.LoadUint32(&o.CH0STAT.Reg)&^(0x20)|value<<5)
}
func (o *DCP_Type) GetCH0STAT_ERROR_DST() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT.Reg) & 0x20) >> 5
}
func (o *DCP_Type) SetCH0STAT_ERROR_PAGEFAULT(value uint32) {
	volatile.StoreUint32(&o.CH0STAT.Reg, volatile.LoadUint32(&o.CH0STAT.Reg)&^(0x40)|value<<6)
}
func (o *DCP_Type) GetCH0STAT_ERROR_PAGEFAULT() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT.Reg) & 0x40) >> 6
}
func (o *DCP_Type) SetCH0STAT_ERROR_CODE(value uint32) {
	volatile.StoreUint32(&o.CH0STAT.Reg, volatile.LoadUint32(&o.CH0STAT.Reg)&^(0xff0000)|value<<16)
}
func (o *DCP_Type) GetCH0STAT_ERROR_CODE() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT.Reg) & 0xff0000) >> 16
}
func (o *DCP_Type) SetCH0STAT_TAG(value uint32) {
	volatile.StoreUint32(&o.CH0STAT.Reg, volatile.LoadUint32(&o.CH0STAT.Reg)&^(0xff000000)|value<<24)
}
func (o *DCP_Type) GetCH0STAT_TAG() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT.Reg) & 0xff000000) >> 24
}

// DCP.CH0STAT_SET: DCP channel 0 status register
func (o *DCP_Type) SetCH0STAT_SET_HASH_MISMATCH(value uint32) {
	volatile.StoreUint32(&o.CH0STAT_SET.Reg, volatile.LoadUint32(&o.CH0STAT_SET.Reg)&^(0x2)|value<<1)
}
func (o *DCP_Type) GetCH0STAT_SET_HASH_MISMATCH() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT_SET.Reg) & 0x2) >> 1
}
func (o *DCP_Type) SetCH0STAT_SET_ERROR_SETUP(value uint32) {
	volatile.StoreUint32(&o.CH0STAT_SET.Reg, volatile.LoadUint32(&o.CH0STAT_SET.Reg)&^(0x4)|value<<2)
}
func (o *DCP_Type) GetCH0STAT_SET_ERROR_SETUP() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT_SET.Reg) & 0x4) >> 2
}
func (o *DCP_Type) SetCH0STAT_SET_ERROR_PACKET(value uint32) {
	volatile.StoreUint32(&o.CH0STAT_SET.Reg, volatile.LoadUint32(&o.CH0STAT_SET.Reg)&^(0x8)|value<<3)
}
func (o *DCP_Type) GetCH0STAT_SET_ERROR_PACKET() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT_SET.Reg) & 0x8) >> 3
}
func (o *DCP_Type) SetCH0STAT_SET_ERROR_SRC(value uint32) {
	volatile.StoreUint32(&o.CH0STAT_SET.Reg, volatile.LoadUint32(&o.CH0STAT_SET.Reg)&^(0x10)|value<<4)
}
func (o *DCP_Type) GetCH0STAT_SET_ERROR_SRC() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT_SET.Reg) & 0x10) >> 4
}
func (o *DCP_Type) SetCH0STAT_SET_ERROR_DST(value uint32) {
	volatile.StoreUint32(&o.CH0STAT_SET.Reg, volatile.LoadUint32(&o.CH0STAT_SET.Reg)&^(0x20)|value<<5)
}
func (o *DCP_Type) GetCH0STAT_SET_ERROR_DST() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT_SET.Reg) & 0x20) >> 5
}
func (o *DCP_Type) SetCH0STAT_SET_ERROR_PAGEFAULT(value uint32) {
	volatile.StoreUint32(&o.CH0STAT_SET.Reg, volatile.LoadUint32(&o.CH0STAT_SET.Reg)&^(0x40)|value<<6)
}
func (o *DCP_Type) GetCH0STAT_SET_ERROR_PAGEFAULT() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT_SET.Reg) & 0x40) >> 6
}
func (o *DCP_Type) SetCH0STAT_SET_ERROR_CODE(value uint32) {
	volatile.StoreUint32(&o.CH0STAT_SET.Reg, volatile.LoadUint32(&o.CH0STAT_SET.Reg)&^(0xff0000)|value<<16)
}
func (o *DCP_Type) GetCH0STAT_SET_ERROR_CODE() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT_SET.Reg) & 0xff0000) >> 16
}
func (o *DCP_Type) SetCH0STAT_SET_TAG(value uint32) {
	volatile.StoreUint32(&o.CH0STAT_SET.Reg, volatile.LoadUint32(&o.CH0STAT_SET.Reg)&^(0xff000000)|value<<24)
}
func (o *DCP_Type) GetCH0STAT_SET_TAG() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT_SET.Reg) & 0xff000000) >> 24
}

// DCP.CH0STAT_CLR: DCP channel 0 status register
func (o *DCP_Type) SetCH0STAT_CLR_HASH_MISMATCH(value uint32) {
	volatile.StoreUint32(&o.CH0STAT_CLR.Reg, volatile.LoadUint32(&o.CH0STAT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *DCP_Type) GetCH0STAT_CLR_HASH_MISMATCH() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT_CLR.Reg) & 0x2) >> 1
}
func (o *DCP_Type) SetCH0STAT_CLR_ERROR_SETUP(value uint32) {
	volatile.StoreUint32(&o.CH0STAT_CLR.Reg, volatile.LoadUint32(&o.CH0STAT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *DCP_Type) GetCH0STAT_CLR_ERROR_SETUP() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT_CLR.Reg) & 0x4) >> 2
}
func (o *DCP_Type) SetCH0STAT_CLR_ERROR_PACKET(value uint32) {
	volatile.StoreUint32(&o.CH0STAT_CLR.Reg, volatile.LoadUint32(&o.CH0STAT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *DCP_Type) GetCH0STAT_CLR_ERROR_PACKET() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT_CLR.Reg) & 0x8) >> 3
}
func (o *DCP_Type) SetCH0STAT_CLR_ERROR_SRC(value uint32) {
	volatile.StoreUint32(&o.CH0STAT_CLR.Reg, volatile.LoadUint32(&o.CH0STAT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *DCP_Type) GetCH0STAT_CLR_ERROR_SRC() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT_CLR.Reg) & 0x10) >> 4
}
func (o *DCP_Type) SetCH0STAT_CLR_ERROR_DST(value uint32) {
	volatile.StoreUint32(&o.CH0STAT_CLR.Reg, volatile.LoadUint32(&o.CH0STAT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *DCP_Type) GetCH0STAT_CLR_ERROR_DST() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT_CLR.Reg) & 0x20) >> 5
}
func (o *DCP_Type) SetCH0STAT_CLR_ERROR_PAGEFAULT(value uint32) {
	volatile.StoreUint32(&o.CH0STAT_CLR.Reg, volatile.LoadUint32(&o.CH0STAT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *DCP_Type) GetCH0STAT_CLR_ERROR_PAGEFAULT() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT_CLR.Reg) & 0x40) >> 6
}
func (o *DCP_Type) SetCH0STAT_CLR_ERROR_CODE(value uint32) {
	volatile.StoreUint32(&o.CH0STAT_CLR.Reg, volatile.LoadUint32(&o.CH0STAT_CLR.Reg)&^(0xff0000)|value<<16)
}
func (o *DCP_Type) GetCH0STAT_CLR_ERROR_CODE() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT_CLR.Reg) & 0xff0000) >> 16
}
func (o *DCP_Type) SetCH0STAT_CLR_TAG(value uint32) {
	volatile.StoreUint32(&o.CH0STAT_CLR.Reg, volatile.LoadUint32(&o.CH0STAT_CLR.Reg)&^(0xff000000)|value<<24)
}
func (o *DCP_Type) GetCH0STAT_CLR_TAG() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT_CLR.Reg) & 0xff000000) >> 24
}

// DCP.CH0STAT_TOG: DCP channel 0 status register
func (o *DCP_Type) SetCH0STAT_TOG_HASH_MISMATCH(value uint32) {
	volatile.StoreUint32(&o.CH0STAT_TOG.Reg, volatile.LoadUint32(&o.CH0STAT_TOG.Reg)&^(0x2)|value<<1)
}
func (o *DCP_Type) GetCH0STAT_TOG_HASH_MISMATCH() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT_TOG.Reg) & 0x2) >> 1
}
func (o *DCP_Type) SetCH0STAT_TOG_ERROR_SETUP(value uint32) {
	volatile.StoreUint32(&o.CH0STAT_TOG.Reg, volatile.LoadUint32(&o.CH0STAT_TOG.Reg)&^(0x4)|value<<2)
}
func (o *DCP_Type) GetCH0STAT_TOG_ERROR_SETUP() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT_TOG.Reg) & 0x4) >> 2
}
func (o *DCP_Type) SetCH0STAT_TOG_ERROR_PACKET(value uint32) {
	volatile.StoreUint32(&o.CH0STAT_TOG.Reg, volatile.LoadUint32(&o.CH0STAT_TOG.Reg)&^(0x8)|value<<3)
}
func (o *DCP_Type) GetCH0STAT_TOG_ERROR_PACKET() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT_TOG.Reg) & 0x8) >> 3
}
func (o *DCP_Type) SetCH0STAT_TOG_ERROR_SRC(value uint32) {
	volatile.StoreUint32(&o.CH0STAT_TOG.Reg, volatile.LoadUint32(&o.CH0STAT_TOG.Reg)&^(0x10)|value<<4)
}
func (o *DCP_Type) GetCH0STAT_TOG_ERROR_SRC() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT_TOG.Reg) & 0x10) >> 4
}
func (o *DCP_Type) SetCH0STAT_TOG_ERROR_DST(value uint32) {
	volatile.StoreUint32(&o.CH0STAT_TOG.Reg, volatile.LoadUint32(&o.CH0STAT_TOG.Reg)&^(0x20)|value<<5)
}
func (o *DCP_Type) GetCH0STAT_TOG_ERROR_DST() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT_TOG.Reg) & 0x20) >> 5
}
func (o *DCP_Type) SetCH0STAT_TOG_ERROR_PAGEFAULT(value uint32) {
	volatile.StoreUint32(&o.CH0STAT_TOG.Reg, volatile.LoadUint32(&o.CH0STAT_TOG.Reg)&^(0x40)|value<<6)
}
func (o *DCP_Type) GetCH0STAT_TOG_ERROR_PAGEFAULT() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT_TOG.Reg) & 0x40) >> 6
}
func (o *DCP_Type) SetCH0STAT_TOG_ERROR_CODE(value uint32) {
	volatile.StoreUint32(&o.CH0STAT_TOG.Reg, volatile.LoadUint32(&o.CH0STAT_TOG.Reg)&^(0xff0000)|value<<16)
}
func (o *DCP_Type) GetCH0STAT_TOG_ERROR_CODE() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT_TOG.Reg) & 0xff0000) >> 16
}
func (o *DCP_Type) SetCH0STAT_TOG_TAG(value uint32) {
	volatile.StoreUint32(&o.CH0STAT_TOG.Reg, volatile.LoadUint32(&o.CH0STAT_TOG.Reg)&^(0xff000000)|value<<24)
}
func (o *DCP_Type) GetCH0STAT_TOG_TAG() uint32 {
	return (volatile.LoadUint32(&o.CH0STAT_TOG.Reg) & 0xff000000) >> 24
}

// DCP.CH0OPTS: DCP channel 0 options register
func (o *DCP_Type) SetCH0OPTS_RECOVERY_TIMER(value uint32) {
	volatile.StoreUint32(&o.CH0OPTS.Reg, volatile.LoadUint32(&o.CH0OPTS.Reg)&^(0xffff)|value)
}
func (o *DCP_Type) GetCH0OPTS_RECOVERY_TIMER() uint32 {
	return volatile.LoadUint32(&o.CH0OPTS.Reg) & 0xffff
}

// DCP.CH0OPTS_SET: DCP channel 0 options register
func (o *DCP_Type) SetCH0OPTS_SET_RECOVERY_TIMER(value uint32) {
	volatile.StoreUint32(&o.CH0OPTS_SET.Reg, volatile.LoadUint32(&o.CH0OPTS_SET.Reg)&^(0xffff)|value)
}
func (o *DCP_Type) GetCH0OPTS_SET_RECOVERY_TIMER() uint32 {
	return volatile.LoadUint32(&o.CH0OPTS_SET.Reg) & 0xffff
}

// DCP.CH0OPTS_CLR: DCP channel 0 options register
func (o *DCP_Type) SetCH0OPTS_CLR_RECOVERY_TIMER(value uint32) {
	volatile.StoreUint32(&o.CH0OPTS_CLR.Reg, volatile.LoadUint32(&o.CH0OPTS_CLR.Reg)&^(0xffff)|value)
}
func (o *DCP_Type) GetCH0OPTS_CLR_RECOVERY_TIMER() uint32 {
	return volatile.LoadUint32(&o.CH0OPTS_CLR.Reg) & 0xffff
}

// DCP.CH0OPTS_TOG: DCP channel 0 options register
func (o *DCP_Type) SetCH0OPTS_TOG_RECOVERY_TIMER(value uint32) {
	volatile.StoreUint32(&o.CH0OPTS_TOG.Reg, volatile.LoadUint32(&o.CH0OPTS_TOG.Reg)&^(0xffff)|value)
}
func (o *DCP_Type) GetCH0OPTS_TOG_RECOVERY_TIMER() uint32 {
	return volatile.LoadUint32(&o.CH0OPTS_TOG.Reg) & 0xffff
}

// DCP.CH1CMDPTR: DCP channel 1 command pointer address register
func (o *DCP_Type) SetCH1CMDPTR(value uint32) {
	volatile.StoreUint32(&o.CH1CMDPTR.Reg, value)
}
func (o *DCP_Type) GetCH1CMDPTR() uint32 {
	return volatile.LoadUint32(&o.CH1CMDPTR.Reg)
}

// DCP.CH1SEMA: DCP channel 1 semaphore register
func (o *DCP_Type) SetCH1SEMA_INCREMENT(value uint32) {
	volatile.StoreUint32(&o.CH1SEMA.Reg, volatile.LoadUint32(&o.CH1SEMA.Reg)&^(0xff)|value)
}
func (o *DCP_Type) GetCH1SEMA_INCREMENT() uint32 {
	return volatile.LoadUint32(&o.CH1SEMA.Reg) & 0xff
}
func (o *DCP_Type) SetCH1SEMA_VALUE(value uint32) {
	volatile.StoreUint32(&o.CH1SEMA.Reg, volatile.LoadUint32(&o.CH1SEMA.Reg)&^(0xff0000)|value<<16)
}
func (o *DCP_Type) GetCH1SEMA_VALUE() uint32 {
	return (volatile.LoadUint32(&o.CH1SEMA.Reg) & 0xff0000) >> 16
}

// DCP.CH1STAT: DCP channel 1 status register
func (o *DCP_Type) SetCH1STAT_HASH_MISMATCH(value uint32) {
	volatile.StoreUint32(&o.CH1STAT.Reg, volatile.LoadUint32(&o.CH1STAT.Reg)&^(0x2)|value<<1)
}
func (o *DCP_Type) GetCH1STAT_HASH_MISMATCH() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT.Reg) & 0x2) >> 1
}
func (o *DCP_Type) SetCH1STAT_ERROR_SETUP(value uint32) {
	volatile.StoreUint32(&o.CH1STAT.Reg, volatile.LoadUint32(&o.CH1STAT.Reg)&^(0x4)|value<<2)
}
func (o *DCP_Type) GetCH1STAT_ERROR_SETUP() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT.Reg) & 0x4) >> 2
}
func (o *DCP_Type) SetCH1STAT_ERROR_PACKET(value uint32) {
	volatile.StoreUint32(&o.CH1STAT.Reg, volatile.LoadUint32(&o.CH1STAT.Reg)&^(0x8)|value<<3)
}
func (o *DCP_Type) GetCH1STAT_ERROR_PACKET() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT.Reg) & 0x8) >> 3
}
func (o *DCP_Type) SetCH1STAT_ERROR_SRC(value uint32) {
	volatile.StoreUint32(&o.CH1STAT.Reg, volatile.LoadUint32(&o.CH1STAT.Reg)&^(0x10)|value<<4)
}
func (o *DCP_Type) GetCH1STAT_ERROR_SRC() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT.Reg) & 0x10) >> 4
}
func (o *DCP_Type) SetCH1STAT_ERROR_DST(value uint32) {
	volatile.StoreUint32(&o.CH1STAT.Reg, volatile.LoadUint32(&o.CH1STAT.Reg)&^(0x20)|value<<5)
}
func (o *DCP_Type) GetCH1STAT_ERROR_DST() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT.Reg) & 0x20) >> 5
}
func (o *DCP_Type) SetCH1STAT_ERROR_PAGEFAULT(value uint32) {
	volatile.StoreUint32(&o.CH1STAT.Reg, volatile.LoadUint32(&o.CH1STAT.Reg)&^(0x40)|value<<6)
}
func (o *DCP_Type) GetCH1STAT_ERROR_PAGEFAULT() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT.Reg) & 0x40) >> 6
}
func (o *DCP_Type) SetCH1STAT_ERROR_CODE(value uint32) {
	volatile.StoreUint32(&o.CH1STAT.Reg, volatile.LoadUint32(&o.CH1STAT.Reg)&^(0xff0000)|value<<16)
}
func (o *DCP_Type) GetCH1STAT_ERROR_CODE() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT.Reg) & 0xff0000) >> 16
}
func (o *DCP_Type) SetCH1STAT_TAG(value uint32) {
	volatile.StoreUint32(&o.CH1STAT.Reg, volatile.LoadUint32(&o.CH1STAT.Reg)&^(0xff000000)|value<<24)
}
func (o *DCP_Type) GetCH1STAT_TAG() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT.Reg) & 0xff000000) >> 24
}

// DCP.CH1STAT_SET: DCP channel 1 status register
func (o *DCP_Type) SetCH1STAT_SET_HASH_MISMATCH(value uint32) {
	volatile.StoreUint32(&o.CH1STAT_SET.Reg, volatile.LoadUint32(&o.CH1STAT_SET.Reg)&^(0x2)|value<<1)
}
func (o *DCP_Type) GetCH1STAT_SET_HASH_MISMATCH() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT_SET.Reg) & 0x2) >> 1
}
func (o *DCP_Type) SetCH1STAT_SET_ERROR_SETUP(value uint32) {
	volatile.StoreUint32(&o.CH1STAT_SET.Reg, volatile.LoadUint32(&o.CH1STAT_SET.Reg)&^(0x4)|value<<2)
}
func (o *DCP_Type) GetCH1STAT_SET_ERROR_SETUP() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT_SET.Reg) & 0x4) >> 2
}
func (o *DCP_Type) SetCH1STAT_SET_ERROR_PACKET(value uint32) {
	volatile.StoreUint32(&o.CH1STAT_SET.Reg, volatile.LoadUint32(&o.CH1STAT_SET.Reg)&^(0x8)|value<<3)
}
func (o *DCP_Type) GetCH1STAT_SET_ERROR_PACKET() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT_SET.Reg) & 0x8) >> 3
}
func (o *DCP_Type) SetCH1STAT_SET_ERROR_SRC(value uint32) {
	volatile.StoreUint32(&o.CH1STAT_SET.Reg, volatile.LoadUint32(&o.CH1STAT_SET.Reg)&^(0x10)|value<<4)
}
func (o *DCP_Type) GetCH1STAT_SET_ERROR_SRC() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT_SET.Reg) & 0x10) >> 4
}
func (o *DCP_Type) SetCH1STAT_SET_ERROR_DST(value uint32) {
	volatile.StoreUint32(&o.CH1STAT_SET.Reg, volatile.LoadUint32(&o.CH1STAT_SET.Reg)&^(0x20)|value<<5)
}
func (o *DCP_Type) GetCH1STAT_SET_ERROR_DST() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT_SET.Reg) & 0x20) >> 5
}
func (o *DCP_Type) SetCH1STAT_SET_ERROR_PAGEFAULT(value uint32) {
	volatile.StoreUint32(&o.CH1STAT_SET.Reg, volatile.LoadUint32(&o.CH1STAT_SET.Reg)&^(0x40)|value<<6)
}
func (o *DCP_Type) GetCH1STAT_SET_ERROR_PAGEFAULT() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT_SET.Reg) & 0x40) >> 6
}
func (o *DCP_Type) SetCH1STAT_SET_ERROR_CODE(value uint32) {
	volatile.StoreUint32(&o.CH1STAT_SET.Reg, volatile.LoadUint32(&o.CH1STAT_SET.Reg)&^(0xff0000)|value<<16)
}
func (o *DCP_Type) GetCH1STAT_SET_ERROR_CODE() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT_SET.Reg) & 0xff0000) >> 16
}
func (o *DCP_Type) SetCH1STAT_SET_TAG(value uint32) {
	volatile.StoreUint32(&o.CH1STAT_SET.Reg, volatile.LoadUint32(&o.CH1STAT_SET.Reg)&^(0xff000000)|value<<24)
}
func (o *DCP_Type) GetCH1STAT_SET_TAG() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT_SET.Reg) & 0xff000000) >> 24
}

// DCP.CH1STAT_CLR: DCP channel 1 status register
func (o *DCP_Type) SetCH1STAT_CLR_HASH_MISMATCH(value uint32) {
	volatile.StoreUint32(&o.CH1STAT_CLR.Reg, volatile.LoadUint32(&o.CH1STAT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *DCP_Type) GetCH1STAT_CLR_HASH_MISMATCH() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT_CLR.Reg) & 0x2) >> 1
}
func (o *DCP_Type) SetCH1STAT_CLR_ERROR_SETUP(value uint32) {
	volatile.StoreUint32(&o.CH1STAT_CLR.Reg, volatile.LoadUint32(&o.CH1STAT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *DCP_Type) GetCH1STAT_CLR_ERROR_SETUP() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT_CLR.Reg) & 0x4) >> 2
}
func (o *DCP_Type) SetCH1STAT_CLR_ERROR_PACKET(value uint32) {
	volatile.StoreUint32(&o.CH1STAT_CLR.Reg, volatile.LoadUint32(&o.CH1STAT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *DCP_Type) GetCH1STAT_CLR_ERROR_PACKET() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT_CLR.Reg) & 0x8) >> 3
}
func (o *DCP_Type) SetCH1STAT_CLR_ERROR_SRC(value uint32) {
	volatile.StoreUint32(&o.CH1STAT_CLR.Reg, volatile.LoadUint32(&o.CH1STAT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *DCP_Type) GetCH1STAT_CLR_ERROR_SRC() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT_CLR.Reg) & 0x10) >> 4
}
func (o *DCP_Type) SetCH1STAT_CLR_ERROR_DST(value uint32) {
	volatile.StoreUint32(&o.CH1STAT_CLR.Reg, volatile.LoadUint32(&o.CH1STAT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *DCP_Type) GetCH1STAT_CLR_ERROR_DST() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT_CLR.Reg) & 0x20) >> 5
}
func (o *DCP_Type) SetCH1STAT_CLR_ERROR_PAGEFAULT(value uint32) {
	volatile.StoreUint32(&o.CH1STAT_CLR.Reg, volatile.LoadUint32(&o.CH1STAT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *DCP_Type) GetCH1STAT_CLR_ERROR_PAGEFAULT() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT_CLR.Reg) & 0x40) >> 6
}
func (o *DCP_Type) SetCH1STAT_CLR_ERROR_CODE(value uint32) {
	volatile.StoreUint32(&o.CH1STAT_CLR.Reg, volatile.LoadUint32(&o.CH1STAT_CLR.Reg)&^(0xff0000)|value<<16)
}
func (o *DCP_Type) GetCH1STAT_CLR_ERROR_CODE() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT_CLR.Reg) & 0xff0000) >> 16
}
func (o *DCP_Type) SetCH1STAT_CLR_TAG(value uint32) {
	volatile.StoreUint32(&o.CH1STAT_CLR.Reg, volatile.LoadUint32(&o.CH1STAT_CLR.Reg)&^(0xff000000)|value<<24)
}
func (o *DCP_Type) GetCH1STAT_CLR_TAG() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT_CLR.Reg) & 0xff000000) >> 24
}

// DCP.CH1STAT_TOG: DCP channel 1 status register
func (o *DCP_Type) SetCH1STAT_TOG_HASH_MISMATCH(value uint32) {
	volatile.StoreUint32(&o.CH1STAT_TOG.Reg, volatile.LoadUint32(&o.CH1STAT_TOG.Reg)&^(0x2)|value<<1)
}
func (o *DCP_Type) GetCH1STAT_TOG_HASH_MISMATCH() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT_TOG.Reg) & 0x2) >> 1
}
func (o *DCP_Type) SetCH1STAT_TOG_ERROR_SETUP(value uint32) {
	volatile.StoreUint32(&o.CH1STAT_TOG.Reg, volatile.LoadUint32(&o.CH1STAT_TOG.Reg)&^(0x4)|value<<2)
}
func (o *DCP_Type) GetCH1STAT_TOG_ERROR_SETUP() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT_TOG.Reg) & 0x4) >> 2
}
func (o *DCP_Type) SetCH1STAT_TOG_ERROR_PACKET(value uint32) {
	volatile.StoreUint32(&o.CH1STAT_TOG.Reg, volatile.LoadUint32(&o.CH1STAT_TOG.Reg)&^(0x8)|value<<3)
}
func (o *DCP_Type) GetCH1STAT_TOG_ERROR_PACKET() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT_TOG.Reg) & 0x8) >> 3
}
func (o *DCP_Type) SetCH1STAT_TOG_ERROR_SRC(value uint32) {
	volatile.StoreUint32(&o.CH1STAT_TOG.Reg, volatile.LoadUint32(&o.CH1STAT_TOG.Reg)&^(0x10)|value<<4)
}
func (o *DCP_Type) GetCH1STAT_TOG_ERROR_SRC() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT_TOG.Reg) & 0x10) >> 4
}
func (o *DCP_Type) SetCH1STAT_TOG_ERROR_DST(value uint32) {
	volatile.StoreUint32(&o.CH1STAT_TOG.Reg, volatile.LoadUint32(&o.CH1STAT_TOG.Reg)&^(0x20)|value<<5)
}
func (o *DCP_Type) GetCH1STAT_TOG_ERROR_DST() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT_TOG.Reg) & 0x20) >> 5
}
func (o *DCP_Type) SetCH1STAT_TOG_ERROR_PAGEFAULT(value uint32) {
	volatile.StoreUint32(&o.CH1STAT_TOG.Reg, volatile.LoadUint32(&o.CH1STAT_TOG.Reg)&^(0x40)|value<<6)
}
func (o *DCP_Type) GetCH1STAT_TOG_ERROR_PAGEFAULT() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT_TOG.Reg) & 0x40) >> 6
}
func (o *DCP_Type) SetCH1STAT_TOG_ERROR_CODE(value uint32) {
	volatile.StoreUint32(&o.CH1STAT_TOG.Reg, volatile.LoadUint32(&o.CH1STAT_TOG.Reg)&^(0xff0000)|value<<16)
}
func (o *DCP_Type) GetCH1STAT_TOG_ERROR_CODE() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT_TOG.Reg) & 0xff0000) >> 16
}
func (o *DCP_Type) SetCH1STAT_TOG_TAG(value uint32) {
	volatile.StoreUint32(&o.CH1STAT_TOG.Reg, volatile.LoadUint32(&o.CH1STAT_TOG.Reg)&^(0xff000000)|value<<24)
}
func (o *DCP_Type) GetCH1STAT_TOG_TAG() uint32 {
	return (volatile.LoadUint32(&o.CH1STAT_TOG.Reg) & 0xff000000) >> 24
}

// DCP.CH1OPTS: DCP channel 1 options register
func (o *DCP_Type) SetCH1OPTS_RECOVERY_TIMER(value uint32) {
	volatile.StoreUint32(&o.CH1OPTS.Reg, volatile.LoadUint32(&o.CH1OPTS.Reg)&^(0xffff)|value)
}
func (o *DCP_Type) GetCH1OPTS_RECOVERY_TIMER() uint32 {
	return volatile.LoadUint32(&o.CH1OPTS.Reg) & 0xffff
}

// DCP.CH1OPTS_SET: DCP channel 1 options register
func (o *DCP_Type) SetCH1OPTS_SET_RECOVERY_TIMER(value uint32) {
	volatile.StoreUint32(&o.CH1OPTS_SET.Reg, volatile.LoadUint32(&o.CH1OPTS_SET.Reg)&^(0xffff)|value)
}
func (o *DCP_Type) GetCH1OPTS_SET_RECOVERY_TIMER() uint32 {
	return volatile.LoadUint32(&o.CH1OPTS_SET.Reg) & 0xffff
}

// DCP.CH1OPTS_CLR: DCP channel 1 options register
func (o *DCP_Type) SetCH1OPTS_CLR_RECOVERY_TIMER(value uint32) {
	volatile.StoreUint32(&o.CH1OPTS_CLR.Reg, volatile.LoadUint32(&o.CH1OPTS_CLR.Reg)&^(0xffff)|value)
}
func (o *DCP_Type) GetCH1OPTS_CLR_RECOVERY_TIMER() uint32 {
	return volatile.LoadUint32(&o.CH1OPTS_CLR.Reg) & 0xffff
}

// DCP.CH1OPTS_TOG: DCP channel 1 options register
func (o *DCP_Type) SetCH1OPTS_TOG_RECOVERY_TIMER(value uint32) {
	volatile.StoreUint32(&o.CH1OPTS_TOG.Reg, volatile.LoadUint32(&o.CH1OPTS_TOG.Reg)&^(0xffff)|value)
}
func (o *DCP_Type) GetCH1OPTS_TOG_RECOVERY_TIMER() uint32 {
	return volatile.LoadUint32(&o.CH1OPTS_TOG.Reg) & 0xffff
}

// DCP.CH2CMDPTR: DCP channel 2 command pointer address register
func (o *DCP_Type) SetCH2CMDPTR(value uint32) {
	volatile.StoreUint32(&o.CH2CMDPTR.Reg, value)
}
func (o *DCP_Type) GetCH2CMDPTR() uint32 {
	return volatile.LoadUint32(&o.CH2CMDPTR.Reg)
}

// DCP.CH2SEMA: DCP channel 2 semaphore register
func (o *DCP_Type) SetCH2SEMA_INCREMENT(value uint32) {
	volatile.StoreUint32(&o.CH2SEMA.Reg, volatile.LoadUint32(&o.CH2SEMA.Reg)&^(0xff)|value)
}
func (o *DCP_Type) GetCH2SEMA_INCREMENT() uint32 {
	return volatile.LoadUint32(&o.CH2SEMA.Reg) & 0xff
}
func (o *DCP_Type) SetCH2SEMA_VALUE(value uint32) {
	volatile.StoreUint32(&o.CH2SEMA.Reg, volatile.LoadUint32(&o.CH2SEMA.Reg)&^(0xff0000)|value<<16)
}
func (o *DCP_Type) GetCH2SEMA_VALUE() uint32 {
	return (volatile.LoadUint32(&o.CH2SEMA.Reg) & 0xff0000) >> 16
}

// DCP.CH2STAT: DCP channel 2 status register
func (o *DCP_Type) SetCH2STAT_HASH_MISMATCH(value uint32) {
	volatile.StoreUint32(&o.CH2STAT.Reg, volatile.LoadUint32(&o.CH2STAT.Reg)&^(0x2)|value<<1)
}
func (o *DCP_Type) GetCH2STAT_HASH_MISMATCH() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT.Reg) & 0x2) >> 1
}
func (o *DCP_Type) SetCH2STAT_ERROR_SETUP(value uint32) {
	volatile.StoreUint32(&o.CH2STAT.Reg, volatile.LoadUint32(&o.CH2STAT.Reg)&^(0x4)|value<<2)
}
func (o *DCP_Type) GetCH2STAT_ERROR_SETUP() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT.Reg) & 0x4) >> 2
}
func (o *DCP_Type) SetCH2STAT_ERROR_PACKET(value uint32) {
	volatile.StoreUint32(&o.CH2STAT.Reg, volatile.LoadUint32(&o.CH2STAT.Reg)&^(0x8)|value<<3)
}
func (o *DCP_Type) GetCH2STAT_ERROR_PACKET() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT.Reg) & 0x8) >> 3
}
func (o *DCP_Type) SetCH2STAT_ERROR_SRC(value uint32) {
	volatile.StoreUint32(&o.CH2STAT.Reg, volatile.LoadUint32(&o.CH2STAT.Reg)&^(0x10)|value<<4)
}
func (o *DCP_Type) GetCH2STAT_ERROR_SRC() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT.Reg) & 0x10) >> 4
}
func (o *DCP_Type) SetCH2STAT_ERROR_DST(value uint32) {
	volatile.StoreUint32(&o.CH2STAT.Reg, volatile.LoadUint32(&o.CH2STAT.Reg)&^(0x20)|value<<5)
}
func (o *DCP_Type) GetCH2STAT_ERROR_DST() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT.Reg) & 0x20) >> 5
}
func (o *DCP_Type) SetCH2STAT_ERROR_PAGEFAULT(value uint32) {
	volatile.StoreUint32(&o.CH2STAT.Reg, volatile.LoadUint32(&o.CH2STAT.Reg)&^(0x40)|value<<6)
}
func (o *DCP_Type) GetCH2STAT_ERROR_PAGEFAULT() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT.Reg) & 0x40) >> 6
}
func (o *DCP_Type) SetCH2STAT_ERROR_CODE(value uint32) {
	volatile.StoreUint32(&o.CH2STAT.Reg, volatile.LoadUint32(&o.CH2STAT.Reg)&^(0xff0000)|value<<16)
}
func (o *DCP_Type) GetCH2STAT_ERROR_CODE() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT.Reg) & 0xff0000) >> 16
}
func (o *DCP_Type) SetCH2STAT_TAG(value uint32) {
	volatile.StoreUint32(&o.CH2STAT.Reg, volatile.LoadUint32(&o.CH2STAT.Reg)&^(0xff000000)|value<<24)
}
func (o *DCP_Type) GetCH2STAT_TAG() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT.Reg) & 0xff000000) >> 24
}

// DCP.CH2STAT_SET: DCP channel 2 status register
func (o *DCP_Type) SetCH2STAT_SET_HASH_MISMATCH(value uint32) {
	volatile.StoreUint32(&o.CH2STAT_SET.Reg, volatile.LoadUint32(&o.CH2STAT_SET.Reg)&^(0x2)|value<<1)
}
func (o *DCP_Type) GetCH2STAT_SET_HASH_MISMATCH() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT_SET.Reg) & 0x2) >> 1
}
func (o *DCP_Type) SetCH2STAT_SET_ERROR_SETUP(value uint32) {
	volatile.StoreUint32(&o.CH2STAT_SET.Reg, volatile.LoadUint32(&o.CH2STAT_SET.Reg)&^(0x4)|value<<2)
}
func (o *DCP_Type) GetCH2STAT_SET_ERROR_SETUP() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT_SET.Reg) & 0x4) >> 2
}
func (o *DCP_Type) SetCH2STAT_SET_ERROR_PACKET(value uint32) {
	volatile.StoreUint32(&o.CH2STAT_SET.Reg, volatile.LoadUint32(&o.CH2STAT_SET.Reg)&^(0x8)|value<<3)
}
func (o *DCP_Type) GetCH2STAT_SET_ERROR_PACKET() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT_SET.Reg) & 0x8) >> 3
}
func (o *DCP_Type) SetCH2STAT_SET_ERROR_SRC(value uint32) {
	volatile.StoreUint32(&o.CH2STAT_SET.Reg, volatile.LoadUint32(&o.CH2STAT_SET.Reg)&^(0x10)|value<<4)
}
func (o *DCP_Type) GetCH2STAT_SET_ERROR_SRC() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT_SET.Reg) & 0x10) >> 4
}
func (o *DCP_Type) SetCH2STAT_SET_ERROR_DST(value uint32) {
	volatile.StoreUint32(&o.CH2STAT_SET.Reg, volatile.LoadUint32(&o.CH2STAT_SET.Reg)&^(0x20)|value<<5)
}
func (o *DCP_Type) GetCH2STAT_SET_ERROR_DST() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT_SET.Reg) & 0x20) >> 5
}
func (o *DCP_Type) SetCH2STAT_SET_ERROR_PAGEFAULT(value uint32) {
	volatile.StoreUint32(&o.CH2STAT_SET.Reg, volatile.LoadUint32(&o.CH2STAT_SET.Reg)&^(0x40)|value<<6)
}
func (o *DCP_Type) GetCH2STAT_SET_ERROR_PAGEFAULT() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT_SET.Reg) & 0x40) >> 6
}
func (o *DCP_Type) SetCH2STAT_SET_ERROR_CODE(value uint32) {
	volatile.StoreUint32(&o.CH2STAT_SET.Reg, volatile.LoadUint32(&o.CH2STAT_SET.Reg)&^(0xff0000)|value<<16)
}
func (o *DCP_Type) GetCH2STAT_SET_ERROR_CODE() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT_SET.Reg) & 0xff0000) >> 16
}
func (o *DCP_Type) SetCH2STAT_SET_TAG(value uint32) {
	volatile.StoreUint32(&o.CH2STAT_SET.Reg, volatile.LoadUint32(&o.CH2STAT_SET.Reg)&^(0xff000000)|value<<24)
}
func (o *DCP_Type) GetCH2STAT_SET_TAG() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT_SET.Reg) & 0xff000000) >> 24
}

// DCP.CH2STAT_CLR: DCP channel 2 status register
func (o *DCP_Type) SetCH2STAT_CLR_HASH_MISMATCH(value uint32) {
	volatile.StoreUint32(&o.CH2STAT_CLR.Reg, volatile.LoadUint32(&o.CH2STAT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *DCP_Type) GetCH2STAT_CLR_HASH_MISMATCH() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT_CLR.Reg) & 0x2) >> 1
}
func (o *DCP_Type) SetCH2STAT_CLR_ERROR_SETUP(value uint32) {
	volatile.StoreUint32(&o.CH2STAT_CLR.Reg, volatile.LoadUint32(&o.CH2STAT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *DCP_Type) GetCH2STAT_CLR_ERROR_SETUP() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT_CLR.Reg) & 0x4) >> 2
}
func (o *DCP_Type) SetCH2STAT_CLR_ERROR_PACKET(value uint32) {
	volatile.StoreUint32(&o.CH2STAT_CLR.Reg, volatile.LoadUint32(&o.CH2STAT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *DCP_Type) GetCH2STAT_CLR_ERROR_PACKET() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT_CLR.Reg) & 0x8) >> 3
}
func (o *DCP_Type) SetCH2STAT_CLR_ERROR_SRC(value uint32) {
	volatile.StoreUint32(&o.CH2STAT_CLR.Reg, volatile.LoadUint32(&o.CH2STAT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *DCP_Type) GetCH2STAT_CLR_ERROR_SRC() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT_CLR.Reg) & 0x10) >> 4
}
func (o *DCP_Type) SetCH2STAT_CLR_ERROR_DST(value uint32) {
	volatile.StoreUint32(&o.CH2STAT_CLR.Reg, volatile.LoadUint32(&o.CH2STAT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *DCP_Type) GetCH2STAT_CLR_ERROR_DST() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT_CLR.Reg) & 0x20) >> 5
}
func (o *DCP_Type) SetCH2STAT_CLR_ERROR_PAGEFAULT(value uint32) {
	volatile.StoreUint32(&o.CH2STAT_CLR.Reg, volatile.LoadUint32(&o.CH2STAT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *DCP_Type) GetCH2STAT_CLR_ERROR_PAGEFAULT() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT_CLR.Reg) & 0x40) >> 6
}
func (o *DCP_Type) SetCH2STAT_CLR_ERROR_CODE(value uint32) {
	volatile.StoreUint32(&o.CH2STAT_CLR.Reg, volatile.LoadUint32(&o.CH2STAT_CLR.Reg)&^(0xff0000)|value<<16)
}
func (o *DCP_Type) GetCH2STAT_CLR_ERROR_CODE() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT_CLR.Reg) & 0xff0000) >> 16
}
func (o *DCP_Type) SetCH2STAT_CLR_TAG(value uint32) {
	volatile.StoreUint32(&o.CH2STAT_CLR.Reg, volatile.LoadUint32(&o.CH2STAT_CLR.Reg)&^(0xff000000)|value<<24)
}
func (o *DCP_Type) GetCH2STAT_CLR_TAG() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT_CLR.Reg) & 0xff000000) >> 24
}

// DCP.CH2STAT_TOG: DCP channel 2 status register
func (o *DCP_Type) SetCH2STAT_TOG_HASH_MISMATCH(value uint32) {
	volatile.StoreUint32(&o.CH2STAT_TOG.Reg, volatile.LoadUint32(&o.CH2STAT_TOG.Reg)&^(0x2)|value<<1)
}
func (o *DCP_Type) GetCH2STAT_TOG_HASH_MISMATCH() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT_TOG.Reg) & 0x2) >> 1
}
func (o *DCP_Type) SetCH2STAT_TOG_ERROR_SETUP(value uint32) {
	volatile.StoreUint32(&o.CH2STAT_TOG.Reg, volatile.LoadUint32(&o.CH2STAT_TOG.Reg)&^(0x4)|value<<2)
}
func (o *DCP_Type) GetCH2STAT_TOG_ERROR_SETUP() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT_TOG.Reg) & 0x4) >> 2
}
func (o *DCP_Type) SetCH2STAT_TOG_ERROR_PACKET(value uint32) {
	volatile.StoreUint32(&o.CH2STAT_TOG.Reg, volatile.LoadUint32(&o.CH2STAT_TOG.Reg)&^(0x8)|value<<3)
}
func (o *DCP_Type) GetCH2STAT_TOG_ERROR_PACKET() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT_TOG.Reg) & 0x8) >> 3
}
func (o *DCP_Type) SetCH2STAT_TOG_ERROR_SRC(value uint32) {
	volatile.StoreUint32(&o.CH2STAT_TOG.Reg, volatile.LoadUint32(&o.CH2STAT_TOG.Reg)&^(0x10)|value<<4)
}
func (o *DCP_Type) GetCH2STAT_TOG_ERROR_SRC() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT_TOG.Reg) & 0x10) >> 4
}
func (o *DCP_Type) SetCH2STAT_TOG_ERROR_DST(value uint32) {
	volatile.StoreUint32(&o.CH2STAT_TOG.Reg, volatile.LoadUint32(&o.CH2STAT_TOG.Reg)&^(0x20)|value<<5)
}
func (o *DCP_Type) GetCH2STAT_TOG_ERROR_DST() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT_TOG.Reg) & 0x20) >> 5
}
func (o *DCP_Type) SetCH2STAT_TOG_ERROR_PAGEFAULT(value uint32) {
	volatile.StoreUint32(&o.CH2STAT_TOG.Reg, volatile.LoadUint32(&o.CH2STAT_TOG.Reg)&^(0x40)|value<<6)
}
func (o *DCP_Type) GetCH2STAT_TOG_ERROR_PAGEFAULT() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT_TOG.Reg) & 0x40) >> 6
}
func (o *DCP_Type) SetCH2STAT_TOG_ERROR_CODE(value uint32) {
	volatile.StoreUint32(&o.CH2STAT_TOG.Reg, volatile.LoadUint32(&o.CH2STAT_TOG.Reg)&^(0xff0000)|value<<16)
}
func (o *DCP_Type) GetCH2STAT_TOG_ERROR_CODE() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT_TOG.Reg) & 0xff0000) >> 16
}
func (o *DCP_Type) SetCH2STAT_TOG_TAG(value uint32) {
	volatile.StoreUint32(&o.CH2STAT_TOG.Reg, volatile.LoadUint32(&o.CH2STAT_TOG.Reg)&^(0xff000000)|value<<24)
}
func (o *DCP_Type) GetCH2STAT_TOG_TAG() uint32 {
	return (volatile.LoadUint32(&o.CH2STAT_TOG.Reg) & 0xff000000) >> 24
}

// DCP.CH2OPTS: DCP channel 2 options register
func (o *DCP_Type) SetCH2OPTS_RECOVERY_TIMER(value uint32) {
	volatile.StoreUint32(&o.CH2OPTS.Reg, volatile.LoadUint32(&o.CH2OPTS.Reg)&^(0xffff)|value)
}
func (o *DCP_Type) GetCH2OPTS_RECOVERY_TIMER() uint32 {
	return volatile.LoadUint32(&o.CH2OPTS.Reg) & 0xffff
}

// DCP.CH2OPTS_SET: DCP channel 2 options register
func (o *DCP_Type) SetCH2OPTS_SET_RECOVERY_TIMER(value uint32) {
	volatile.StoreUint32(&o.CH2OPTS_SET.Reg, volatile.LoadUint32(&o.CH2OPTS_SET.Reg)&^(0xffff)|value)
}
func (o *DCP_Type) GetCH2OPTS_SET_RECOVERY_TIMER() uint32 {
	return volatile.LoadUint32(&o.CH2OPTS_SET.Reg) & 0xffff
}

// DCP.CH2OPTS_CLR: DCP channel 2 options register
func (o *DCP_Type) SetCH2OPTS_CLR_RECOVERY_TIMER(value uint32) {
	volatile.StoreUint32(&o.CH2OPTS_CLR.Reg, volatile.LoadUint32(&o.CH2OPTS_CLR.Reg)&^(0xffff)|value)
}
func (o *DCP_Type) GetCH2OPTS_CLR_RECOVERY_TIMER() uint32 {
	return volatile.LoadUint32(&o.CH2OPTS_CLR.Reg) & 0xffff
}

// DCP.CH2OPTS_TOG: DCP channel 2 options register
func (o *DCP_Type) SetCH2OPTS_TOG_RECOVERY_TIMER(value uint32) {
	volatile.StoreUint32(&o.CH2OPTS_TOG.Reg, volatile.LoadUint32(&o.CH2OPTS_TOG.Reg)&^(0xffff)|value)
}
func (o *DCP_Type) GetCH2OPTS_TOG_RECOVERY_TIMER() uint32 {
	return volatile.LoadUint32(&o.CH2OPTS_TOG.Reg) & 0xffff
}

// DCP.CH3CMDPTR: DCP channel 3 command pointer address register
func (o *DCP_Type) SetCH3CMDPTR(value uint32) {
	volatile.StoreUint32(&o.CH3CMDPTR.Reg, value)
}
func (o *DCP_Type) GetCH3CMDPTR() uint32 {
	return volatile.LoadUint32(&o.CH3CMDPTR.Reg)
}

// DCP.CH3SEMA: DCP channel 3 semaphore register
func (o *DCP_Type) SetCH3SEMA_INCREMENT(value uint32) {
	volatile.StoreUint32(&o.CH3SEMA.Reg, volatile.LoadUint32(&o.CH3SEMA.Reg)&^(0xff)|value)
}
func (o *DCP_Type) GetCH3SEMA_INCREMENT() uint32 {
	return volatile.LoadUint32(&o.CH3SEMA.Reg) & 0xff
}
func (o *DCP_Type) SetCH3SEMA_VALUE(value uint32) {
	volatile.StoreUint32(&o.CH3SEMA.Reg, volatile.LoadUint32(&o.CH3SEMA.Reg)&^(0xff0000)|value<<16)
}
func (o *DCP_Type) GetCH3SEMA_VALUE() uint32 {
	return (volatile.LoadUint32(&o.CH3SEMA.Reg) & 0xff0000) >> 16
}

// DCP.CH3STAT: DCP channel 3 status register
func (o *DCP_Type) SetCH3STAT_HASH_MISMATCH(value uint32) {
	volatile.StoreUint32(&o.CH3STAT.Reg, volatile.LoadUint32(&o.CH3STAT.Reg)&^(0x2)|value<<1)
}
func (o *DCP_Type) GetCH3STAT_HASH_MISMATCH() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT.Reg) & 0x2) >> 1
}
func (o *DCP_Type) SetCH3STAT_ERROR_SETUP(value uint32) {
	volatile.StoreUint32(&o.CH3STAT.Reg, volatile.LoadUint32(&o.CH3STAT.Reg)&^(0x4)|value<<2)
}
func (o *DCP_Type) GetCH3STAT_ERROR_SETUP() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT.Reg) & 0x4) >> 2
}
func (o *DCP_Type) SetCH3STAT_ERROR_PACKET(value uint32) {
	volatile.StoreUint32(&o.CH3STAT.Reg, volatile.LoadUint32(&o.CH3STAT.Reg)&^(0x8)|value<<3)
}
func (o *DCP_Type) GetCH3STAT_ERROR_PACKET() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT.Reg) & 0x8) >> 3
}
func (o *DCP_Type) SetCH3STAT_ERROR_SRC(value uint32) {
	volatile.StoreUint32(&o.CH3STAT.Reg, volatile.LoadUint32(&o.CH3STAT.Reg)&^(0x10)|value<<4)
}
func (o *DCP_Type) GetCH3STAT_ERROR_SRC() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT.Reg) & 0x10) >> 4
}
func (o *DCP_Type) SetCH3STAT_ERROR_DST(value uint32) {
	volatile.StoreUint32(&o.CH3STAT.Reg, volatile.LoadUint32(&o.CH3STAT.Reg)&^(0x20)|value<<5)
}
func (o *DCP_Type) GetCH3STAT_ERROR_DST() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT.Reg) & 0x20) >> 5
}
func (o *DCP_Type) SetCH3STAT_ERROR_PAGEFAULT(value uint32) {
	volatile.StoreUint32(&o.CH3STAT.Reg, volatile.LoadUint32(&o.CH3STAT.Reg)&^(0x40)|value<<6)
}
func (o *DCP_Type) GetCH3STAT_ERROR_PAGEFAULT() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT.Reg) & 0x40) >> 6
}
func (o *DCP_Type) SetCH3STAT_ERROR_CODE(value uint32) {
	volatile.StoreUint32(&o.CH3STAT.Reg, volatile.LoadUint32(&o.CH3STAT.Reg)&^(0xff0000)|value<<16)
}
func (o *DCP_Type) GetCH3STAT_ERROR_CODE() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT.Reg) & 0xff0000) >> 16
}
func (o *DCP_Type) SetCH3STAT_TAG(value uint32) {
	volatile.StoreUint32(&o.CH3STAT.Reg, volatile.LoadUint32(&o.CH3STAT.Reg)&^(0xff000000)|value<<24)
}
func (o *DCP_Type) GetCH3STAT_TAG() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT.Reg) & 0xff000000) >> 24
}

// DCP.CH3STAT_SET: DCP channel 3 status register
func (o *DCP_Type) SetCH3STAT_SET_HASH_MISMATCH(value uint32) {
	volatile.StoreUint32(&o.CH3STAT_SET.Reg, volatile.LoadUint32(&o.CH3STAT_SET.Reg)&^(0x2)|value<<1)
}
func (o *DCP_Type) GetCH3STAT_SET_HASH_MISMATCH() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT_SET.Reg) & 0x2) >> 1
}
func (o *DCP_Type) SetCH3STAT_SET_ERROR_SETUP(value uint32) {
	volatile.StoreUint32(&o.CH3STAT_SET.Reg, volatile.LoadUint32(&o.CH3STAT_SET.Reg)&^(0x4)|value<<2)
}
func (o *DCP_Type) GetCH3STAT_SET_ERROR_SETUP() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT_SET.Reg) & 0x4) >> 2
}
func (o *DCP_Type) SetCH3STAT_SET_ERROR_PACKET(value uint32) {
	volatile.StoreUint32(&o.CH3STAT_SET.Reg, volatile.LoadUint32(&o.CH3STAT_SET.Reg)&^(0x8)|value<<3)
}
func (o *DCP_Type) GetCH3STAT_SET_ERROR_PACKET() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT_SET.Reg) & 0x8) >> 3
}
func (o *DCP_Type) SetCH3STAT_SET_ERROR_SRC(value uint32) {
	volatile.StoreUint32(&o.CH3STAT_SET.Reg, volatile.LoadUint32(&o.CH3STAT_SET.Reg)&^(0x10)|value<<4)
}
func (o *DCP_Type) GetCH3STAT_SET_ERROR_SRC() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT_SET.Reg) & 0x10) >> 4
}
func (o *DCP_Type) SetCH3STAT_SET_ERROR_DST(value uint32) {
	volatile.StoreUint32(&o.CH3STAT_SET.Reg, volatile.LoadUint32(&o.CH3STAT_SET.Reg)&^(0x20)|value<<5)
}
func (o *DCP_Type) GetCH3STAT_SET_ERROR_DST() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT_SET.Reg) & 0x20) >> 5
}
func (o *DCP_Type) SetCH3STAT_SET_ERROR_PAGEFAULT(value uint32) {
	volatile.StoreUint32(&o.CH3STAT_SET.Reg, volatile.LoadUint32(&o.CH3STAT_SET.Reg)&^(0x40)|value<<6)
}
func (o *DCP_Type) GetCH3STAT_SET_ERROR_PAGEFAULT() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT_SET.Reg) & 0x40) >> 6
}
func (o *DCP_Type) SetCH3STAT_SET_ERROR_CODE(value uint32) {
	volatile.StoreUint32(&o.CH3STAT_SET.Reg, volatile.LoadUint32(&o.CH3STAT_SET.Reg)&^(0xff0000)|value<<16)
}
func (o *DCP_Type) GetCH3STAT_SET_ERROR_CODE() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT_SET.Reg) & 0xff0000) >> 16
}
func (o *DCP_Type) SetCH3STAT_SET_TAG(value uint32) {
	volatile.StoreUint32(&o.CH3STAT_SET.Reg, volatile.LoadUint32(&o.CH3STAT_SET.Reg)&^(0xff000000)|value<<24)
}
func (o *DCP_Type) GetCH3STAT_SET_TAG() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT_SET.Reg) & 0xff000000) >> 24
}

// DCP.CH3STAT_CLR: DCP channel 3 status register
func (o *DCP_Type) SetCH3STAT_CLR_HASH_MISMATCH(value uint32) {
	volatile.StoreUint32(&o.CH3STAT_CLR.Reg, volatile.LoadUint32(&o.CH3STAT_CLR.Reg)&^(0x2)|value<<1)
}
func (o *DCP_Type) GetCH3STAT_CLR_HASH_MISMATCH() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT_CLR.Reg) & 0x2) >> 1
}
func (o *DCP_Type) SetCH3STAT_CLR_ERROR_SETUP(value uint32) {
	volatile.StoreUint32(&o.CH3STAT_CLR.Reg, volatile.LoadUint32(&o.CH3STAT_CLR.Reg)&^(0x4)|value<<2)
}
func (o *DCP_Type) GetCH3STAT_CLR_ERROR_SETUP() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT_CLR.Reg) & 0x4) >> 2
}
func (o *DCP_Type) SetCH3STAT_CLR_ERROR_PACKET(value uint32) {
	volatile.StoreUint32(&o.CH3STAT_CLR.Reg, volatile.LoadUint32(&o.CH3STAT_CLR.Reg)&^(0x8)|value<<3)
}
func (o *DCP_Type) GetCH3STAT_CLR_ERROR_PACKET() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT_CLR.Reg) & 0x8) >> 3
}
func (o *DCP_Type) SetCH3STAT_CLR_ERROR_SRC(value uint32) {
	volatile.StoreUint32(&o.CH3STAT_CLR.Reg, volatile.LoadUint32(&o.CH3STAT_CLR.Reg)&^(0x10)|value<<4)
}
func (o *DCP_Type) GetCH3STAT_CLR_ERROR_SRC() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT_CLR.Reg) & 0x10) >> 4
}
func (o *DCP_Type) SetCH3STAT_CLR_ERROR_DST(value uint32) {
	volatile.StoreUint32(&o.CH3STAT_CLR.Reg, volatile.LoadUint32(&o.CH3STAT_CLR.Reg)&^(0x20)|value<<5)
}
func (o *DCP_Type) GetCH3STAT_CLR_ERROR_DST() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT_CLR.Reg) & 0x20) >> 5
}
func (o *DCP_Type) SetCH3STAT_CLR_ERROR_PAGEFAULT(value uint32) {
	volatile.StoreUint32(&o.CH3STAT_CLR.Reg, volatile.LoadUint32(&o.CH3STAT_CLR.Reg)&^(0x40)|value<<6)
}
func (o *DCP_Type) GetCH3STAT_CLR_ERROR_PAGEFAULT() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT_CLR.Reg) & 0x40) >> 6
}
func (o *DCP_Type) SetCH3STAT_CLR_ERROR_CODE(value uint32) {
	volatile.StoreUint32(&o.CH3STAT_CLR.Reg, volatile.LoadUint32(&o.CH3STAT_CLR.Reg)&^(0xff0000)|value<<16)
}
func (o *DCP_Type) GetCH3STAT_CLR_ERROR_CODE() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT_CLR.Reg) & 0xff0000) >> 16
}
func (o *DCP_Type) SetCH3STAT_CLR_TAG(value uint32) {
	volatile.StoreUint32(&o.CH3STAT_CLR.Reg, volatile.LoadUint32(&o.CH3STAT_CLR.Reg)&^(0xff000000)|value<<24)
}
func (o *DCP_Type) GetCH3STAT_CLR_TAG() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT_CLR.Reg) & 0xff000000) >> 24
}

// DCP.CH3STAT_TOG: DCP channel 3 status register
func (o *DCP_Type) SetCH3STAT_TOG_HASH_MISMATCH(value uint32) {
	volatile.StoreUint32(&o.CH3STAT_TOG.Reg, volatile.LoadUint32(&o.CH3STAT_TOG.Reg)&^(0x2)|value<<1)
}
func (o *DCP_Type) GetCH3STAT_TOG_HASH_MISMATCH() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT_TOG.Reg) & 0x2) >> 1
}
func (o *DCP_Type) SetCH3STAT_TOG_ERROR_SETUP(value uint32) {
	volatile.StoreUint32(&o.CH3STAT_TOG.Reg, volatile.LoadUint32(&o.CH3STAT_TOG.Reg)&^(0x4)|value<<2)
}
func (o *DCP_Type) GetCH3STAT_TOG_ERROR_SETUP() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT_TOG.Reg) & 0x4) >> 2
}
func (o *DCP_Type) SetCH3STAT_TOG_ERROR_PACKET(value uint32) {
	volatile.StoreUint32(&o.CH3STAT_TOG.Reg, volatile.LoadUint32(&o.CH3STAT_TOG.Reg)&^(0x8)|value<<3)
}
func (o *DCP_Type) GetCH3STAT_TOG_ERROR_PACKET() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT_TOG.Reg) & 0x8) >> 3
}
func (o *DCP_Type) SetCH3STAT_TOG_ERROR_SRC(value uint32) {
	volatile.StoreUint32(&o.CH3STAT_TOG.Reg, volatile.LoadUint32(&o.CH3STAT_TOG.Reg)&^(0x10)|value<<4)
}
func (o *DCP_Type) GetCH3STAT_TOG_ERROR_SRC() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT_TOG.Reg) & 0x10) >> 4
}
func (o *DCP_Type) SetCH3STAT_TOG_ERROR_DST(value uint32) {
	volatile.StoreUint32(&o.CH3STAT_TOG.Reg, volatile.LoadUint32(&o.CH3STAT_TOG.Reg)&^(0x20)|value<<5)
}
func (o *DCP_Type) GetCH3STAT_TOG_ERROR_DST() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT_TOG.Reg) & 0x20) >> 5
}
func (o *DCP_Type) SetCH3STAT_TOG_ERROR_PAGEFAULT(value uint32) {
	volatile.StoreUint32(&o.CH3STAT_TOG.Reg, volatile.LoadUint32(&o.CH3STAT_TOG.Reg)&^(0x40)|value<<6)
}
func (o *DCP_Type) GetCH3STAT_TOG_ERROR_PAGEFAULT() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT_TOG.Reg) & 0x40) >> 6
}
func (o *DCP_Type) SetCH3STAT_TOG_ERROR_CODE(value uint32) {
	volatile.StoreUint32(&o.CH3STAT_TOG.Reg, volatile.LoadUint32(&o.CH3STAT_TOG.Reg)&^(0xff0000)|value<<16)
}
func (o *DCP_Type) GetCH3STAT_TOG_ERROR_CODE() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT_TOG.Reg) & 0xff0000) >> 16
}
func (o *DCP_Type) SetCH3STAT_TOG_TAG(value uint32) {
	volatile.StoreUint32(&o.CH3STAT_TOG.Reg, volatile.LoadUint32(&o.CH3STAT_TOG.Reg)&^(0xff000000)|value<<24)
}
func (o *DCP_Type) GetCH3STAT_TOG_TAG() uint32 {
	return (volatile.LoadUint32(&o.CH3STAT_TOG.Reg) & 0xff000000) >> 24
}

// DCP.CH3OPTS: DCP channel 3 options register
func (o *DCP_Type) SetCH3OPTS_RECOVERY_TIMER(value uint32) {
	volatile.StoreUint32(&o.CH3OPTS.Reg, volatile.LoadUint32(&o.CH3OPTS.Reg)&^(0xffff)|value)
}
func (o *DCP_Type) GetCH3OPTS_RECOVERY_TIMER() uint32 {
	return volatile.LoadUint32(&o.CH3OPTS.Reg) & 0xffff
}

// DCP.CH3OPTS_SET: DCP channel 3 options register
func (o *DCP_Type) SetCH3OPTS_SET_RECOVERY_TIMER(value uint32) {
	volatile.StoreUint32(&o.CH3OPTS_SET.Reg, volatile.LoadUint32(&o.CH3OPTS_SET.Reg)&^(0xffff)|value)
}
func (o *DCP_Type) GetCH3OPTS_SET_RECOVERY_TIMER() uint32 {
	return volatile.LoadUint32(&o.CH3OPTS_SET.Reg) & 0xffff
}

// DCP.CH3OPTS_CLR: DCP channel 3 options register
func (o *DCP_Type) SetCH3OPTS_CLR_RECOVERY_TIMER(value uint32) {
	volatile.StoreUint32(&o.CH3OPTS_CLR.Reg, volatile.LoadUint32(&o.CH3OPTS_CLR.Reg)&^(0xffff)|value)
}
func (o *DCP_Type) GetCH3OPTS_CLR_RECOVERY_TIMER() uint32 {
	return volatile.LoadUint32(&o.CH3OPTS_CLR.Reg) & 0xffff
}

// DCP.CH3OPTS_TOG: DCP channel 3 options register
func (o *DCP_Type) SetCH3OPTS_TOG_RECOVERY_TIMER(value uint32) {
	volatile.StoreUint32(&o.CH3OPTS_TOG.Reg, volatile.LoadUint32(&o.CH3OPTS_TOG.Reg)&^(0xffff)|value)
}
func (o *DCP_Type) GetCH3OPTS_TOG_RECOVERY_TIMER() uint32 {
	return volatile.LoadUint32(&o.CH3OPTS_TOG.Reg) & 0xffff
}

// DCP.DBGSELECT: DCP debug select register
func (o *DCP_Type) SetDBGSELECT_INDEX(value uint32) {
	volatile.StoreUint32(&o.DBGSELECT.Reg, volatile.LoadUint32(&o.DBGSELECT.Reg)&^(0xff)|value)
}
func (o *DCP_Type) GetDBGSELECT_INDEX() uint32 {
	return volatile.LoadUint32(&o.DBGSELECT.Reg) & 0xff
}

// DCP.DBGDATA: DCP debug data register
func (o *DCP_Type) SetDBGDATA(value uint32) {
	volatile.StoreUint32(&o.DBGDATA.Reg, value)
}
func (o *DCP_Type) GetDBGDATA() uint32 {
	return volatile.LoadUint32(&o.DBGDATA.Reg)
}

// DCP.PAGETABLE: DCP page table register
func (o *DCP_Type) SetPAGETABLE_ENABLE(value uint32) {
	volatile.StoreUint32(&o.PAGETABLE.Reg, volatile.LoadUint32(&o.PAGETABLE.Reg)&^(0x1)|value)
}
func (o *DCP_Type) GetPAGETABLE_ENABLE() uint32 {
	return volatile.LoadUint32(&o.PAGETABLE.Reg) & 0x1
}
func (o *DCP_Type) SetPAGETABLE_FLUSH(value uint32) {
	volatile.StoreUint32(&o.PAGETABLE.Reg, volatile.LoadUint32(&o.PAGETABLE.Reg)&^(0x2)|value<<1)
}
func (o *DCP_Type) GetPAGETABLE_FLUSH() uint32 {
	return (volatile.LoadUint32(&o.PAGETABLE.Reg) & 0x2) >> 1
}
func (o *DCP_Type) SetPAGETABLE_BASE(value uint32) {
	volatile.StoreUint32(&o.PAGETABLE.Reg, volatile.LoadUint32(&o.PAGETABLE.Reg)&^(0xfffffffc)|value<<2)
}
func (o *DCP_Type) GetPAGETABLE_BASE() uint32 {
	return (volatile.LoadUint32(&o.PAGETABLE.Reg) & 0xfffffffc) >> 2
}

// DCP.VERSION: DCP version register
func (o *DCP_Type) SetVERSION_STEP(value uint32) {
	volatile.StoreUint32(&o.VERSION.Reg, volatile.LoadUint32(&o.VERSION.Reg)&^(0xffff)|value)
}
func (o *DCP_Type) GetVERSION_STEP() uint32 {
	return volatile.LoadUint32(&o.VERSION.Reg) & 0xffff
}
func (o *DCP_Type) SetVERSION_MINOR(value uint32) {
	volatile.StoreUint32(&o.VERSION.Reg, volatile.LoadUint32(&o.VERSION.Reg)&^(0xff0000)|value<<16)
}
func (o *DCP_Type) GetVERSION_MINOR() uint32 {
	return (volatile.LoadUint32(&o.VERSION.Reg) & 0xff0000) >> 16
}
func (o *DCP_Type) SetVERSION_MAJOR(value uint32) {
	volatile.StoreUint32(&o.VERSION.Reg, volatile.LoadUint32(&o.VERSION.Reg)&^(0xff000000)|value<<24)
}
func (o *DCP_Type) GetVERSION_MAJOR() uint32 {
	return (volatile.LoadUint32(&o.VERSION.Reg) & 0xff000000) >> 24
}

// GPC
type GPC_Type struct {
	CNTR volatile.Register32 // 0x0
	_    [4]byte
	IMR1 volatile.Register32 // 0x8
	IMR2 volatile.Register32 // 0xC
	IMR3 volatile.Register32 // 0x10
	IMR4 volatile.Register32 // 0x14
	ISR1 volatile.Register32 // 0x18
	ISR2 volatile.Register32 // 0x1C
	ISR3 volatile.Register32 // 0x20
	ISR4 volatile.Register32 // 0x24
	_    [12]byte
	IMR5 volatile.Register32 // 0x34
	ISR5 volatile.Register32 // 0x38
}

// GPC.CNTR: GPC Interface control register
func (o *GPC_Type) SetCNTR_MEGA_PDN_REQ(value uint32) {
	volatile.StoreUint32(&o.CNTR.Reg, volatile.LoadUint32(&o.CNTR.Reg)&^(0x4)|value<<2)
}
func (o *GPC_Type) GetCNTR_MEGA_PDN_REQ() uint32 {
	return (volatile.LoadUint32(&o.CNTR.Reg) & 0x4) >> 2
}
func (o *GPC_Type) SetCNTR_MEGA_PUP_REQ(value uint32) {
	volatile.StoreUint32(&o.CNTR.Reg, volatile.LoadUint32(&o.CNTR.Reg)&^(0x8)|value<<3)
}
func (o *GPC_Type) GetCNTR_MEGA_PUP_REQ() uint32 {
	return (volatile.LoadUint32(&o.CNTR.Reg) & 0x8) >> 3
}
func (o *GPC_Type) SetCNTR_PDRAM0_PGE(value uint32) {
	volatile.StoreUint32(&o.CNTR.Reg, volatile.LoadUint32(&o.CNTR.Reg)&^(0x400000)|value<<22)
}
func (o *GPC_Type) GetCNTR_PDRAM0_PGE() uint32 {
	return (volatile.LoadUint32(&o.CNTR.Reg) & 0x400000) >> 22
}

// GPC.IMR1: IRQ masking register 1
func (o *GPC_Type) SetIMR1(value uint32) {
	volatile.StoreUint32(&o.IMR1.Reg, value)
}
func (o *GPC_Type) GetIMR1() uint32 {
	return volatile.LoadUint32(&o.IMR1.Reg)
}

// GPC.IMR2: IRQ masking register 2
func (o *GPC_Type) SetIMR2(value uint32) {
	volatile.StoreUint32(&o.IMR2.Reg, value)
}
func (o *GPC_Type) GetIMR2() uint32 {
	return volatile.LoadUint32(&o.IMR2.Reg)
}

// GPC.IMR3: IRQ masking register 3
func (o *GPC_Type) SetIMR3(value uint32) {
	volatile.StoreUint32(&o.IMR3.Reg, value)
}
func (o *GPC_Type) GetIMR3() uint32 {
	return volatile.LoadUint32(&o.IMR3.Reg)
}

// GPC.IMR4: IRQ masking register 4
func (o *GPC_Type) SetIMR4(value uint32) {
	volatile.StoreUint32(&o.IMR4.Reg, value)
}
func (o *GPC_Type) GetIMR4() uint32 {
	return volatile.LoadUint32(&o.IMR4.Reg)
}

// GPC.ISR1: IRQ status resister 1
func (o *GPC_Type) SetISR1(value uint32) {
	volatile.StoreUint32(&o.ISR1.Reg, value)
}
func (o *GPC_Type) GetISR1() uint32 {
	return volatile.LoadUint32(&o.ISR1.Reg)
}

// GPC.ISR2: IRQ status resister 2
func (o *GPC_Type) SetISR2(value uint32) {
	volatile.StoreUint32(&o.ISR2.Reg, value)
}
func (o *GPC_Type) GetISR2() uint32 {
	return volatile.LoadUint32(&o.ISR2.Reg)
}

// GPC.ISR3: IRQ status resister 3
func (o *GPC_Type) SetISR3(value uint32) {
	volatile.StoreUint32(&o.ISR3.Reg, value)
}
func (o *GPC_Type) GetISR3() uint32 {
	return volatile.LoadUint32(&o.ISR3.Reg)
}

// GPC.ISR4: IRQ status resister 4
func (o *GPC_Type) SetISR4(value uint32) {
	volatile.StoreUint32(&o.ISR4.Reg, value)
}
func (o *GPC_Type) GetISR4() uint32 {
	return volatile.LoadUint32(&o.ISR4.Reg)
}

// GPC.IMR5: IRQ masking register 5
func (o *GPC_Type) SetIMR5(value uint32) {
	volatile.StoreUint32(&o.IMR5.Reg, value)
}
func (o *GPC_Type) GetIMR5() uint32 {
	return volatile.LoadUint32(&o.IMR5.Reg)
}

// GPC.ISR5: IRQ status resister 5
func (o *GPC_Type) SetISR5(value uint32) {
	volatile.StoreUint32(&o.ISR5.Reg, value)
}
func (o *GPC_Type) GetISR5() uint32 {
	return volatile.LoadUint32(&o.ISR5.Reg)
}

// PGC
type PGC_Type struct {
	_           [544]byte
	MEGA_CTRL   volatile.Register32 // 0x220
	MEGA_PUPSCR volatile.Register32 // 0x224
	MEGA_PDNSCR volatile.Register32 // 0x228
	MEGA_SR     volatile.Register32 // 0x22C
	_           [112]byte
	CPU_CTRL    volatile.Register32 // 0x2A0
	CPU_PUPSCR  volatile.Register32 // 0x2A4
	CPU_PDNSCR  volatile.Register32 // 0x2A8
	CPU_SR      volatile.Register32 // 0x2AC
}

// PGC.MEGA_CTRL: PGC Mega Control Register
func (o *PGC_Type) SetMEGA_CTRL_PCR(value uint32) {
	volatile.StoreUint32(&o.MEGA_CTRL.Reg, volatile.LoadUint32(&o.MEGA_CTRL.Reg)&^(0x1)|value)
}
func (o *PGC_Type) GetMEGA_CTRL_PCR() uint32 {
	return volatile.LoadUint32(&o.MEGA_CTRL.Reg) & 0x1
}

// PGC.MEGA_PUPSCR: PGC Mega Power Up Sequence Control Register
func (o *PGC_Type) SetMEGA_PUPSCR_SW(value uint32) {
	volatile.StoreUint32(&o.MEGA_PUPSCR.Reg, volatile.LoadUint32(&o.MEGA_PUPSCR.Reg)&^(0x3f)|value)
}
func (o *PGC_Type) GetMEGA_PUPSCR_SW() uint32 {
	return volatile.LoadUint32(&o.MEGA_PUPSCR.Reg) & 0x3f
}
func (o *PGC_Type) SetMEGA_PUPSCR_SW2ISO(value uint32) {
	volatile.StoreUint32(&o.MEGA_PUPSCR.Reg, volatile.LoadUint32(&o.MEGA_PUPSCR.Reg)&^(0x3f00)|value<<8)
}
func (o *PGC_Type) GetMEGA_PUPSCR_SW2ISO() uint32 {
	return (volatile.LoadUint32(&o.MEGA_PUPSCR.Reg) & 0x3f00) >> 8
}

// PGC.MEGA_PDNSCR: PGC Mega Pull Down Sequence Control Register
func (o *PGC_Type) SetMEGA_PDNSCR_ISO(value uint32) {
	volatile.StoreUint32(&o.MEGA_PDNSCR.Reg, volatile.LoadUint32(&o.MEGA_PDNSCR.Reg)&^(0x3f)|value)
}
func (o *PGC_Type) GetMEGA_PDNSCR_ISO() uint32 {
	return volatile.LoadUint32(&o.MEGA_PDNSCR.Reg) & 0x3f
}
func (o *PGC_Type) SetMEGA_PDNSCR_ISO2SW(value uint32) {
	volatile.StoreUint32(&o.MEGA_PDNSCR.Reg, volatile.LoadUint32(&o.MEGA_PDNSCR.Reg)&^(0x3f00)|value<<8)
}
func (o *PGC_Type) GetMEGA_PDNSCR_ISO2SW() uint32 {
	return (volatile.LoadUint32(&o.MEGA_PDNSCR.Reg) & 0x3f00) >> 8
}

// PGC.MEGA_SR: PGC Mega Power Gating Controller Status Register
func (o *PGC_Type) SetMEGA_SR_PSR(value uint32) {
	volatile.StoreUint32(&o.MEGA_SR.Reg, volatile.LoadUint32(&o.MEGA_SR.Reg)&^(0x1)|value)
}
func (o *PGC_Type) GetMEGA_SR_PSR() uint32 {
	return volatile.LoadUint32(&o.MEGA_SR.Reg) & 0x1
}

// PGC.CPU_CTRL: PGC CPU Control Register
func (o *PGC_Type) SetCPU_CTRL_PCR(value uint32) {
	volatile.StoreUint32(&o.CPU_CTRL.Reg, volatile.LoadUint32(&o.CPU_CTRL.Reg)&^(0x1)|value)
}
func (o *PGC_Type) GetCPU_CTRL_PCR() uint32 {
	return volatile.LoadUint32(&o.CPU_CTRL.Reg) & 0x1
}

// PGC.CPU_PUPSCR: PGC CPU Power Up Sequence Control Register
func (o *PGC_Type) SetCPU_PUPSCR_SW(value uint32) {
	volatile.StoreUint32(&o.CPU_PUPSCR.Reg, volatile.LoadUint32(&o.CPU_PUPSCR.Reg)&^(0x3f)|value)
}
func (o *PGC_Type) GetCPU_PUPSCR_SW() uint32 {
	return volatile.LoadUint32(&o.CPU_PUPSCR.Reg) & 0x3f
}
func (o *PGC_Type) SetCPU_PUPSCR_SW2ISO(value uint32) {
	volatile.StoreUint32(&o.CPU_PUPSCR.Reg, volatile.LoadUint32(&o.CPU_PUPSCR.Reg)&^(0x3f00)|value<<8)
}
func (o *PGC_Type) GetCPU_PUPSCR_SW2ISO() uint32 {
	return (volatile.LoadUint32(&o.CPU_PUPSCR.Reg) & 0x3f00) >> 8
}

// PGC.CPU_PDNSCR: PGC CPU Pull Down Sequence Control Register
func (o *PGC_Type) SetCPU_PDNSCR_ISO(value uint32) {
	volatile.StoreUint32(&o.CPU_PDNSCR.Reg, volatile.LoadUint32(&o.CPU_PDNSCR.Reg)&^(0x3f)|value)
}
func (o *PGC_Type) GetCPU_PDNSCR_ISO() uint32 {
	return volatile.LoadUint32(&o.CPU_PDNSCR.Reg) & 0x3f
}
func (o *PGC_Type) SetCPU_PDNSCR_ISO2SW(value uint32) {
	volatile.StoreUint32(&o.CPU_PDNSCR.Reg, volatile.LoadUint32(&o.CPU_PDNSCR.Reg)&^(0x3f00)|value<<8)
}
func (o *PGC_Type) GetCPU_PDNSCR_ISO2SW() uint32 {
	return (volatile.LoadUint32(&o.CPU_PDNSCR.Reg) & 0x3f00) >> 8
}

// PGC.CPU_SR: PGC CPU Power Gating Controller Status Register
func (o *PGC_Type) SetCPU_SR_PSR(value uint32) {
	volatile.StoreUint32(&o.CPU_SR.Reg, volatile.LoadUint32(&o.CPU_SR.Reg)&^(0x1)|value)
}
func (o *PGC_Type) GetCPU_SR_PSR() uint32 {
	return volatile.LoadUint32(&o.CPU_SR.Reg) & 0x1
}

// SRC
type SRC_Type struct {
	SCR   volatile.Register32 // 0x0
	SBMR1 volatile.Register32 // 0x4
	SRSR  volatile.Register32 // 0x8
	_     [16]byte
	SBMR2 volatile.Register32 // 0x1C
	GPR1  volatile.Register32 // 0x20
	GPR2  volatile.Register32 // 0x24
	GPR3  volatile.Register32 // 0x28
	GPR4  volatile.Register32 // 0x2C
	GPR5  volatile.Register32 // 0x30
	GPR6  volatile.Register32 // 0x34
	GPR7  volatile.Register32 // 0x38
	GPR8  volatile.Register32 // 0x3C
	GPR9  volatile.Register32 // 0x40
	GPR10 volatile.Register32 // 0x44
}

// SRC.SCR: SRC Control Register
func (o *SRC_Type) SetSCR_LOCKUP_RST(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *SRC_Type) GetSCR_LOCKUP_RST() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x10) >> 4
}
func (o *SRC_Type) SetSCR_MASK_WDOG_RST(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x780)|value<<7)
}
func (o *SRC_Type) GetSCR_MASK_WDOG_RST() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x780) >> 7
}
func (o *SRC_Type) SetSCR_CORE0_RST(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x2000)|value<<13)
}
func (o *SRC_Type) GetSCR_CORE0_RST() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x2000) >> 13
}
func (o *SRC_Type) SetSCR_CORE0_DBG_RST(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x20000)|value<<17)
}
func (o *SRC_Type) GetSCR_CORE0_DBG_RST() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x20000) >> 17
}
func (o *SRC_Type) SetSCR_DBG_RST_MSK_PG(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x2000000)|value<<25)
}
func (o *SRC_Type) GetSCR_DBG_RST_MSK_PG() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x2000000) >> 25
}
func (o *SRC_Type) SetSCR_MASK_WDOG3_RST(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0xf0000000)|value<<28)
}
func (o *SRC_Type) GetSCR_MASK_WDOG3_RST() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0xf0000000) >> 28
}

// SRC.SBMR1: SRC Boot Mode Register 1
func (o *SRC_Type) SetSBMR1_BOOT_CFG1(value uint32) {
	volatile.StoreUint32(&o.SBMR1.Reg, volatile.LoadUint32(&o.SBMR1.Reg)&^(0xff)|value)
}
func (o *SRC_Type) GetSBMR1_BOOT_CFG1() uint32 {
	return volatile.LoadUint32(&o.SBMR1.Reg) & 0xff
}
func (o *SRC_Type) SetSBMR1_BOOT_CFG2(value uint32) {
	volatile.StoreUint32(&o.SBMR1.Reg, volatile.LoadUint32(&o.SBMR1.Reg)&^(0xff00)|value<<8)
}
func (o *SRC_Type) GetSBMR1_BOOT_CFG2() uint32 {
	return (volatile.LoadUint32(&o.SBMR1.Reg) & 0xff00) >> 8
}
func (o *SRC_Type) SetSBMR1_BOOT_CFG3(value uint32) {
	volatile.StoreUint32(&o.SBMR1.Reg, volatile.LoadUint32(&o.SBMR1.Reg)&^(0xff0000)|value<<16)
}
func (o *SRC_Type) GetSBMR1_BOOT_CFG3() uint32 {
	return (volatile.LoadUint32(&o.SBMR1.Reg) & 0xff0000) >> 16
}
func (o *SRC_Type) SetSBMR1_BOOT_CFG4(value uint32) {
	volatile.StoreUint32(&o.SBMR1.Reg, volatile.LoadUint32(&o.SBMR1.Reg)&^(0xff000000)|value<<24)
}
func (o *SRC_Type) GetSBMR1_BOOT_CFG4() uint32 {
	return (volatile.LoadUint32(&o.SBMR1.Reg) & 0xff000000) >> 24
}

// SRC.SRSR: SRC Reset Status Register
func (o *SRC_Type) SetSRSR_IPP_RESET_B(value uint32) {
	volatile.StoreUint32(&o.SRSR.Reg, volatile.LoadUint32(&o.SRSR.Reg)&^(0x1)|value)
}
func (o *SRC_Type) GetSRSR_IPP_RESET_B() uint32 {
	return volatile.LoadUint32(&o.SRSR.Reg) & 0x1
}
func (o *SRC_Type) SetSRSR_LOCKUP(value uint32) {
	volatile.StoreUint32(&o.SRSR.Reg, volatile.LoadUint32(&o.SRSR.Reg)&^(0x2)|value<<1)
}
func (o *SRC_Type) GetSRSR_LOCKUP() uint32 {
	return (volatile.LoadUint32(&o.SRSR.Reg) & 0x2) >> 1
}
func (o *SRC_Type) SetSRSR_CSU_RESET_B(value uint32) {
	volatile.StoreUint32(&o.SRSR.Reg, volatile.LoadUint32(&o.SRSR.Reg)&^(0x4)|value<<2)
}
func (o *SRC_Type) GetSRSR_CSU_RESET_B() uint32 {
	return (volatile.LoadUint32(&o.SRSR.Reg) & 0x4) >> 2
}
func (o *SRC_Type) SetSRSR_IPP_USER_RESET_B(value uint32) {
	volatile.StoreUint32(&o.SRSR.Reg, volatile.LoadUint32(&o.SRSR.Reg)&^(0x8)|value<<3)
}
func (o *SRC_Type) GetSRSR_IPP_USER_RESET_B() uint32 {
	return (volatile.LoadUint32(&o.SRSR.Reg) & 0x8) >> 3
}
func (o *SRC_Type) SetSRSR_WDOG_RST_B(value uint32) {
	volatile.StoreUint32(&o.SRSR.Reg, volatile.LoadUint32(&o.SRSR.Reg)&^(0x10)|value<<4)
}
func (o *SRC_Type) GetSRSR_WDOG_RST_B() uint32 {
	return (volatile.LoadUint32(&o.SRSR.Reg) & 0x10) >> 4
}
func (o *SRC_Type) SetSRSR_JTAG_RST_B(value uint32) {
	volatile.StoreUint32(&o.SRSR.Reg, volatile.LoadUint32(&o.SRSR.Reg)&^(0x20)|value<<5)
}
func (o *SRC_Type) GetSRSR_JTAG_RST_B() uint32 {
	return (volatile.LoadUint32(&o.SRSR.Reg) & 0x20) >> 5
}
func (o *SRC_Type) SetSRSR_JTAG_SW_RST(value uint32) {
	volatile.StoreUint32(&o.SRSR.Reg, volatile.LoadUint32(&o.SRSR.Reg)&^(0x40)|value<<6)
}
func (o *SRC_Type) GetSRSR_JTAG_SW_RST() uint32 {
	return (volatile.LoadUint32(&o.SRSR.Reg) & 0x40) >> 6
}
func (o *SRC_Type) SetSRSR_WDOG3_RST_B(value uint32) {
	volatile.StoreUint32(&o.SRSR.Reg, volatile.LoadUint32(&o.SRSR.Reg)&^(0x80)|value<<7)
}
func (o *SRC_Type) GetSRSR_WDOG3_RST_B() uint32 {
	return (volatile.LoadUint32(&o.SRSR.Reg) & 0x80) >> 7
}
func (o *SRC_Type) SetSRSR_TEMPSENSE_RST_B(value uint32) {
	volatile.StoreUint32(&o.SRSR.Reg, volatile.LoadUint32(&o.SRSR.Reg)&^(0x100)|value<<8)
}
func (o *SRC_Type) GetSRSR_TEMPSENSE_RST_B() uint32 {
	return (volatile.LoadUint32(&o.SRSR.Reg) & 0x100) >> 8
}

// SRC.SBMR2: SRC Boot Mode Register 2
func (o *SRC_Type) SetSBMR2_SEC_CONFIG(value uint32) {
	volatile.StoreUint32(&o.SBMR2.Reg, volatile.LoadUint32(&o.SBMR2.Reg)&^(0x3)|value)
}
func (o *SRC_Type) GetSBMR2_SEC_CONFIG() uint32 {
	return volatile.LoadUint32(&o.SBMR2.Reg) & 0x3
}
func (o *SRC_Type) SetSBMR2_DIR_BT_DIS(value uint32) {
	volatile.StoreUint32(&o.SBMR2.Reg, volatile.LoadUint32(&o.SBMR2.Reg)&^(0x8)|value<<3)
}
func (o *SRC_Type) GetSBMR2_DIR_BT_DIS() uint32 {
	return (volatile.LoadUint32(&o.SBMR2.Reg) & 0x8) >> 3
}
func (o *SRC_Type) SetSBMR2_BT_FUSE_SEL(value uint32) {
	volatile.StoreUint32(&o.SBMR2.Reg, volatile.LoadUint32(&o.SBMR2.Reg)&^(0x10)|value<<4)
}
func (o *SRC_Type) GetSBMR2_BT_FUSE_SEL() uint32 {
	return (volatile.LoadUint32(&o.SBMR2.Reg) & 0x10) >> 4
}
func (o *SRC_Type) SetSBMR2_BMOD(value uint32) {
	volatile.StoreUint32(&o.SBMR2.Reg, volatile.LoadUint32(&o.SBMR2.Reg)&^(0x3000000)|value<<24)
}
func (o *SRC_Type) GetSBMR2_BMOD() uint32 {
	return (volatile.LoadUint32(&o.SBMR2.Reg) & 0x3000000) >> 24
}

// SRC.GPR1: SRC General Purpose Register 1
func (o *SRC_Type) SetGPR1(value uint32) {
	volatile.StoreUint32(&o.GPR1.Reg, value)
}
func (o *SRC_Type) GetGPR1() uint32 {
	return volatile.LoadUint32(&o.GPR1.Reg)
}

// SRC.GPR2: SRC General Purpose Register 2
func (o *SRC_Type) SetGPR2(value uint32) {
	volatile.StoreUint32(&o.GPR2.Reg, value)
}
func (o *SRC_Type) GetGPR2() uint32 {
	return volatile.LoadUint32(&o.GPR2.Reg)
}

// SRC.GPR10: SRC General Purpose Register 10
func (o *SRC_Type) SetGPR10_PERSIST_REDUNDANT_BOOT(value uint32) {
	volatile.StoreUint32(&o.GPR10.Reg, volatile.LoadUint32(&o.GPR10.Reg)&^(0xc000000)|value<<26)
}
func (o *SRC_Type) GetGPR10_PERSIST_REDUNDANT_BOOT() uint32 {
	return (volatile.LoadUint32(&o.GPR10.Reg) & 0xc000000) >> 26
}
func (o *SRC_Type) SetGPR10_PERSIST_SECONDARY_BOOT(value uint32) {
	volatile.StoreUint32(&o.GPR10.Reg, volatile.LoadUint32(&o.GPR10.Reg)&^(0x40000000)|value<<30)
}
func (o *SRC_Type) GetGPR10_PERSIST_SECONDARY_BOOT() uint32 {
	return (volatile.LoadUint32(&o.GPR10.Reg) & 0x40000000) >> 30
}

// CCM
type CCM_Type struct {
	CCR    volatile.Register32 // 0x0
	_      [4]byte
	CSR    volatile.Register32 // 0x8
	CCSR   volatile.Register32 // 0xC
	_      [4]byte
	CBCDR  volatile.Register32 // 0x14
	CBCMR  volatile.Register32 // 0x18
	CSCMR1 volatile.Register32 // 0x1C
	CSCMR2 volatile.Register32 // 0x20
	CSCDR1 volatile.Register32 // 0x24
	CS1CDR volatile.Register32 // 0x28
	_      [4]byte
	CDCDR  volatile.Register32 // 0x30
	_      [4]byte
	CSCDR2 volatile.Register32 // 0x38
	_      [12]byte
	CDHIPR volatile.Register32 // 0x48
	_      [8]byte
	CLPCR  volatile.Register32 // 0x54
	CISR   volatile.Register32 // 0x58
	CIMR   volatile.Register32 // 0x5C
	CCOSR  volatile.Register32 // 0x60
	CGPR   volatile.Register32 // 0x64
	CCGR0  volatile.Register32 // 0x68
	CCGR1  volatile.Register32 // 0x6C
	CCGR2  volatile.Register32 // 0x70
	CCGR3  volatile.Register32 // 0x74
	CCGR4  volatile.Register32 // 0x78
	CCGR5  volatile.Register32 // 0x7C
	CCGR6  volatile.Register32 // 0x80
	_      [4]byte
	CMEOR  volatile.Register32 // 0x88
}

// CCM.CCR: CCM Control Register
func (o *CCM_Type) SetCCR_OSCNT(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0xff)|value)
}
func (o *CCM_Type) GetCCR_OSCNT() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0xff
}
func (o *CCM_Type) SetCCR_COSC_EN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x1000)|value<<12)
}
func (o *CCM_Type) GetCCR_COSC_EN() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x1000) >> 12
}
func (o *CCM_Type) SetCCR_REG_BYPASS_COUNT(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x7e00000)|value<<21)
}
func (o *CCM_Type) GetCCR_REG_BYPASS_COUNT() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x7e00000) >> 21
}
func (o *CCM_Type) SetCCR_RBC_EN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x8000000)|value<<27)
}
func (o *CCM_Type) GetCCR_RBC_EN() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x8000000) >> 27
}

// CCM.CSR: CCM Status Register
func (o *CCM_Type) SetCSR_REF_EN_B(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x1)|value)
}
func (o *CCM_Type) GetCSR_REF_EN_B() uint32 {
	return volatile.LoadUint32(&o.CSR.Reg) & 0x1
}
func (o *CCM_Type) SetCSR_CAMP2_READY(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x8)|value<<3)
}
func (o *CCM_Type) GetCSR_CAMP2_READY() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x8) >> 3
}
func (o *CCM_Type) SetCSR_COSC_READY(value uint32) {
	volatile.StoreUint32(&o.CSR.Reg, volatile.LoadUint32(&o.CSR.Reg)&^(0x20)|value<<5)
}
func (o *CCM_Type) GetCSR_COSC_READY() uint32 {
	return (volatile.LoadUint32(&o.CSR.Reg) & 0x20) >> 5
}

// CCM.CCSR: CCM Clock Switcher Register
func (o *CCM_Type) SetCCSR_PLL3_SW_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.CCSR.Reg, volatile.LoadUint32(&o.CCSR.Reg)&^(0x1)|value)
}
func (o *CCM_Type) GetCCSR_PLL3_SW_CLK_SEL() uint32 {
	return volatile.LoadUint32(&o.CCSR.Reg) & 0x1
}

// CCM.CBCDR: CCM Bus Clock Divider Register
func (o *CCM_Type) SetCBCDR_IPG_PODF(value uint32) {
	volatile.StoreUint32(&o.CBCDR.Reg, volatile.LoadUint32(&o.CBCDR.Reg)&^(0x300)|value<<8)
}
func (o *CCM_Type) GetCBCDR_IPG_PODF() uint32 {
	return (volatile.LoadUint32(&o.CBCDR.Reg) & 0x300) >> 8
}
func (o *CCM_Type) SetCBCDR_AHB_PODF(value uint32) {
	volatile.StoreUint32(&o.CBCDR.Reg, volatile.LoadUint32(&o.CBCDR.Reg)&^(0x1c00)|value<<10)
}
func (o *CCM_Type) GetCBCDR_AHB_PODF() uint32 {
	return (volatile.LoadUint32(&o.CBCDR.Reg) & 0x1c00) >> 10
}
func (o *CCM_Type) SetCBCDR_PERIPH_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.CBCDR.Reg, volatile.LoadUint32(&o.CBCDR.Reg)&^(0x2000000)|value<<25)
}
func (o *CCM_Type) GetCBCDR_PERIPH_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.CBCDR.Reg) & 0x2000000) >> 25
}

// CCM.CBCMR: CCM Bus Clock Multiplexer Register
func (o *CCM_Type) SetCBCMR_LPSPI_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.CBCMR.Reg, volatile.LoadUint32(&o.CBCMR.Reg)&^(0x30)|value<<4)
}
func (o *CCM_Type) GetCBCMR_LPSPI_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.CBCMR.Reg) & 0x30) >> 4
}
func (o *CCM_Type) SetCBCMR_PERIPH_CLK2_SEL(value uint32) {
	volatile.StoreUint32(&o.CBCMR.Reg, volatile.LoadUint32(&o.CBCMR.Reg)&^(0x3000)|value<<12)
}
func (o *CCM_Type) GetCBCMR_PERIPH_CLK2_SEL() uint32 {
	return (volatile.LoadUint32(&o.CBCMR.Reg) & 0x3000) >> 12
}
func (o *CCM_Type) SetCBCMR_TRACE_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.CBCMR.Reg, volatile.LoadUint32(&o.CBCMR.Reg)&^(0xc000)|value<<14)
}
func (o *CCM_Type) GetCBCMR_TRACE_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.CBCMR.Reg) & 0xc000) >> 14
}
func (o *CCM_Type) SetCBCMR_PRE_PERIPH_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.CBCMR.Reg, volatile.LoadUint32(&o.CBCMR.Reg)&^(0xc0000)|value<<18)
}
func (o *CCM_Type) GetCBCMR_PRE_PERIPH_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.CBCMR.Reg) & 0xc0000) >> 18
}
func (o *CCM_Type) SetCBCMR_LPSPI_PODF(value uint32) {
	volatile.StoreUint32(&o.CBCMR.Reg, volatile.LoadUint32(&o.CBCMR.Reg)&^(0x3c000000)|value<<26)
}
func (o *CCM_Type) GetCBCMR_LPSPI_PODF() uint32 {
	return (volatile.LoadUint32(&o.CBCMR.Reg) & 0x3c000000) >> 26
}

// CCM.CSCMR1: CCM Serial Clock Multiplexer Register 1
func (o *CCM_Type) SetCSCMR1_PERCLK_PODF(value uint32) {
	volatile.StoreUint32(&o.CSCMR1.Reg, volatile.LoadUint32(&o.CSCMR1.Reg)&^(0x3f)|value)
}
func (o *CCM_Type) GetCSCMR1_PERCLK_PODF() uint32 {
	return volatile.LoadUint32(&o.CSCMR1.Reg) & 0x3f
}
func (o *CCM_Type) SetCSCMR1_PERCLK_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.CSCMR1.Reg, volatile.LoadUint32(&o.CSCMR1.Reg)&^(0x40)|value<<6)
}
func (o *CCM_Type) GetCSCMR1_PERCLK_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.CSCMR1.Reg) & 0x40) >> 6
}
func (o *CCM_Type) SetCSCMR1_SAI1_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.CSCMR1.Reg, volatile.LoadUint32(&o.CSCMR1.Reg)&^(0xc00)|value<<10)
}
func (o *CCM_Type) GetCSCMR1_SAI1_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.CSCMR1.Reg) & 0xc00) >> 10
}
func (o *CCM_Type) SetCSCMR1_SAI3_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.CSCMR1.Reg, volatile.LoadUint32(&o.CSCMR1.Reg)&^(0xc000)|value<<14)
}
func (o *CCM_Type) GetCSCMR1_SAI3_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.CSCMR1.Reg) & 0xc000) >> 14
}
func (o *CCM_Type) SetCSCMR1_FLEXSPI_PODF(value uint32) {
	volatile.StoreUint32(&o.CSCMR1.Reg, volatile.LoadUint32(&o.CSCMR1.Reg)&^(0x3800000)|value<<23)
}
func (o *CCM_Type) GetCSCMR1_FLEXSPI_PODF() uint32 {
	return (volatile.LoadUint32(&o.CSCMR1.Reg) & 0x3800000) >> 23
}
func (o *CCM_Type) SetCSCMR1_FLEXSPI_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.CSCMR1.Reg, volatile.LoadUint32(&o.CSCMR1.Reg)&^(0x60000000)|value<<29)
}
func (o *CCM_Type) GetCSCMR1_FLEXSPI_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.CSCMR1.Reg) & 0x60000000) >> 29
}
func (o *CCM_Type) SetCSCMR1_FLEXSPI_CLK_SRC(value uint32) {
	volatile.StoreUint32(&o.CSCMR1.Reg, volatile.LoadUint32(&o.CSCMR1.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_Type) GetCSCMR1_FLEXSPI_CLK_SRC() uint32 {
	return (volatile.LoadUint32(&o.CSCMR1.Reg) & 0x80000000) >> 31
}

// CCM.CSCMR2: CCM Serial Clock Multiplexer Register 2
func (o *CCM_Type) SetCSCMR2_FLEXIO1_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.CSCMR2.Reg, volatile.LoadUint32(&o.CSCMR2.Reg)&^(0x180000)|value<<19)
}
func (o *CCM_Type) GetCSCMR2_FLEXIO1_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.CSCMR2.Reg) & 0x180000) >> 19
}
func (o *CCM_Type) SetCSCMR2_ADC_ACLK_PODF(value uint32) {
	volatile.StoreUint32(&o.CSCMR2.Reg, volatile.LoadUint32(&o.CSCMR2.Reg)&^(0x78000000)|value<<27)
}
func (o *CCM_Type) GetCSCMR2_ADC_ACLK_PODF() uint32 {
	return (volatile.LoadUint32(&o.CSCMR2.Reg) & 0x78000000) >> 27
}
func (o *CCM_Type) SetCSCMR2_ADC_ACLK_EN(value uint32) {
	volatile.StoreUint32(&o.CSCMR2.Reg, volatile.LoadUint32(&o.CSCMR2.Reg)&^(0x80000000)|value<<31)
}
func (o *CCM_Type) GetCSCMR2_ADC_ACLK_EN() uint32 {
	return (volatile.LoadUint32(&o.CSCMR2.Reg) & 0x80000000) >> 31
}

// CCM.CSCDR1: CCM Serial Clock Divider Register 1
func (o *CCM_Type) SetCSCDR1_UART_CLK_PODF(value uint32) {
	volatile.StoreUint32(&o.CSCDR1.Reg, volatile.LoadUint32(&o.CSCDR1.Reg)&^(0x3f)|value)
}
func (o *CCM_Type) GetCSCDR1_UART_CLK_PODF() uint32 {
	return volatile.LoadUint32(&o.CSCDR1.Reg) & 0x3f
}
func (o *CCM_Type) SetCSCDR1_UART_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.CSCDR1.Reg, volatile.LoadUint32(&o.CSCDR1.Reg)&^(0xc0)|value<<6)
}
func (o *CCM_Type) GetCSCDR1_UART_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.CSCDR1.Reg) & 0xc0) >> 6
}
func (o *CCM_Type) SetCSCDR1_TRACE_PODF(value uint32) {
	volatile.StoreUint32(&o.CSCDR1.Reg, volatile.LoadUint32(&o.CSCDR1.Reg)&^(0x1e000000)|value<<25)
}
func (o *CCM_Type) GetCSCDR1_TRACE_PODF() uint32 {
	return (volatile.LoadUint32(&o.CSCDR1.Reg) & 0x1e000000) >> 25
}

// CCM.CS1CDR: CCM Clock Divider Register
func (o *CCM_Type) SetCS1CDR_SAI1_CLK_PODF(value uint32) {
	volatile.StoreUint32(&o.CS1CDR.Reg, volatile.LoadUint32(&o.CS1CDR.Reg)&^(0x3f)|value)
}
func (o *CCM_Type) GetCS1CDR_SAI1_CLK_PODF() uint32 {
	return volatile.LoadUint32(&o.CS1CDR.Reg) & 0x3f
}
func (o *CCM_Type) SetCS1CDR_SAI1_CLK_PRED(value uint32) {
	volatile.StoreUint32(&o.CS1CDR.Reg, volatile.LoadUint32(&o.CS1CDR.Reg)&^(0x1c0)|value<<6)
}
func (o *CCM_Type) GetCS1CDR_SAI1_CLK_PRED() uint32 {
	return (volatile.LoadUint32(&o.CS1CDR.Reg) & 0x1c0) >> 6
}
func (o *CCM_Type) SetCS1CDR_FLEXIO1_CLK_PRED(value uint32) {
	volatile.StoreUint32(&o.CS1CDR.Reg, volatile.LoadUint32(&o.CS1CDR.Reg)&^(0xe00)|value<<9)
}
func (o *CCM_Type) GetCS1CDR_FLEXIO1_CLK_PRED() uint32 {
	return (volatile.LoadUint32(&o.CS1CDR.Reg) & 0xe00) >> 9
}
func (o *CCM_Type) SetCS1CDR_SAI3_CLK_PODF(value uint32) {
	volatile.StoreUint32(&o.CS1CDR.Reg, volatile.LoadUint32(&o.CS1CDR.Reg)&^(0x3f0000)|value<<16)
}
func (o *CCM_Type) GetCS1CDR_SAI3_CLK_PODF() uint32 {
	return (volatile.LoadUint32(&o.CS1CDR.Reg) & 0x3f0000) >> 16
}
func (o *CCM_Type) SetCS1CDR_SAI3_CLK_PRED(value uint32) {
	volatile.StoreUint32(&o.CS1CDR.Reg, volatile.LoadUint32(&o.CS1CDR.Reg)&^(0x1c00000)|value<<22)
}
func (o *CCM_Type) GetCS1CDR_SAI3_CLK_PRED() uint32 {
	return (volatile.LoadUint32(&o.CS1CDR.Reg) & 0x1c00000) >> 22
}
func (o *CCM_Type) SetCS1CDR_FLEXIO1_CLK_PODF(value uint32) {
	volatile.StoreUint32(&o.CS1CDR.Reg, volatile.LoadUint32(&o.CS1CDR.Reg)&^(0x1e000000)|value<<25)
}
func (o *CCM_Type) GetCS1CDR_FLEXIO1_CLK_PODF() uint32 {
	return (volatile.LoadUint32(&o.CS1CDR.Reg) & 0x1e000000) >> 25
}

// CCM.CDCDR: CCM D1 Clock Divider Register
func (o *CCM_Type) SetCDCDR_SPDIF0_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.CDCDR.Reg, volatile.LoadUint32(&o.CDCDR.Reg)&^(0x300000)|value<<20)
}
func (o *CCM_Type) GetCDCDR_SPDIF0_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.CDCDR.Reg) & 0x300000) >> 20
}
func (o *CCM_Type) SetCDCDR_SPDIF0_CLK_PODF(value uint32) {
	volatile.StoreUint32(&o.CDCDR.Reg, volatile.LoadUint32(&o.CDCDR.Reg)&^(0x1c00000)|value<<22)
}
func (o *CCM_Type) GetCDCDR_SPDIF0_CLK_PODF() uint32 {
	return (volatile.LoadUint32(&o.CDCDR.Reg) & 0x1c00000) >> 22
}
func (o *CCM_Type) SetCDCDR_SPDIF0_CLK_PRED(value uint32) {
	volatile.StoreUint32(&o.CDCDR.Reg, volatile.LoadUint32(&o.CDCDR.Reg)&^(0xe000000)|value<<25)
}
func (o *CCM_Type) GetCDCDR_SPDIF0_CLK_PRED() uint32 {
	return (volatile.LoadUint32(&o.CDCDR.Reg) & 0xe000000) >> 25
}

// CCM.CSCDR2: CCM Serial Clock Divider Register 2
func (o *CCM_Type) SetCSCDR2_LPI2C_CLK_SEL(value uint32) {
	volatile.StoreUint32(&o.CSCDR2.Reg, volatile.LoadUint32(&o.CSCDR2.Reg)&^(0x40000)|value<<18)
}
func (o *CCM_Type) GetCSCDR2_LPI2C_CLK_SEL() uint32 {
	return (volatile.LoadUint32(&o.CSCDR2.Reg) & 0x40000) >> 18
}
func (o *CCM_Type) SetCSCDR2_LPI2C_CLK_PODF(value uint32) {
	volatile.StoreUint32(&o.CSCDR2.Reg, volatile.LoadUint32(&o.CSCDR2.Reg)&^(0x1f80000)|value<<19)
}
func (o *CCM_Type) GetCSCDR2_LPI2C_CLK_PODF() uint32 {
	return (volatile.LoadUint32(&o.CSCDR2.Reg) & 0x1f80000) >> 19
}

// CCM.CDHIPR: CCM Divider Handshake In-Process Register
func (o *CCM_Type) SetCDHIPR_AHB_PODF_BUSY(value uint32) {
	volatile.StoreUint32(&o.CDHIPR.Reg, volatile.LoadUint32(&o.CDHIPR.Reg)&^(0x2)|value<<1)
}
func (o *CCM_Type) GetCDHIPR_AHB_PODF_BUSY() uint32 {
	return (volatile.LoadUint32(&o.CDHIPR.Reg) & 0x2) >> 1
}
func (o *CCM_Type) SetCDHIPR_FLEXSPI_PODF_BUSY(value uint32) {
	volatile.StoreUint32(&o.CDHIPR.Reg, volatile.LoadUint32(&o.CDHIPR.Reg)&^(0x8)|value<<3)
}
func (o *CCM_Type) GetCDHIPR_FLEXSPI_PODF_BUSY() uint32 {
	return (volatile.LoadUint32(&o.CDHIPR.Reg) & 0x8) >> 3
}
func (o *CCM_Type) SetCDHIPR_PERCLK_PODF_BUSY(value uint32) {
	volatile.StoreUint32(&o.CDHIPR.Reg, volatile.LoadUint32(&o.CDHIPR.Reg)&^(0x10)|value<<4)
}
func (o *CCM_Type) GetCDHIPR_PERCLK_PODF_BUSY() uint32 {
	return (volatile.LoadUint32(&o.CDHIPR.Reg) & 0x10) >> 4
}
func (o *CCM_Type) SetCDHIPR_PERIPH_CLK_SEL_BUSY(value uint32) {
	volatile.StoreUint32(&o.CDHIPR.Reg, volatile.LoadUint32(&o.CDHIPR.Reg)&^(0x20)|value<<5)
}
func (o *CCM_Type) GetCDHIPR_PERIPH_CLK_SEL_BUSY() uint32 {
	return (volatile.LoadUint32(&o.CDHIPR.Reg) & 0x20) >> 5
}

// CCM.CLPCR: CCM Low Power Control Register
func (o *CCM_Type) SetCLPCR_LPM(value uint32) {
	volatile.StoreUint32(&o.CLPCR.Reg, volatile.LoadUint32(&o.CLPCR.Reg)&^(0x3)|value)
}
func (o *CCM_Type) GetCLPCR_LPM() uint32 {
	return volatile.LoadUint32(&o.CLPCR.Reg) & 0x3
}
func (o *CCM_Type) SetCLPCR_ARM_CLK_DIS_ON_LPM(value uint32) {
	volatile.StoreUint32(&o.CLPCR.Reg, volatile.LoadUint32(&o.CLPCR.Reg)&^(0x20)|value<<5)
}
func (o *CCM_Type) GetCLPCR_ARM_CLK_DIS_ON_LPM() uint32 {
	return (volatile.LoadUint32(&o.CLPCR.Reg) & 0x20) >> 5
}
func (o *CCM_Type) SetCLPCR_SBYOS(value uint32) {
	volatile.StoreUint32(&o.CLPCR.Reg, volatile.LoadUint32(&o.CLPCR.Reg)&^(0x40)|value<<6)
}
func (o *CCM_Type) GetCLPCR_SBYOS() uint32 {
	return (volatile.LoadUint32(&o.CLPCR.Reg) & 0x40) >> 6
}
func (o *CCM_Type) SetCLPCR_DIS_REF_OSC(value uint32) {
	volatile.StoreUint32(&o.CLPCR.Reg, volatile.LoadUint32(&o.CLPCR.Reg)&^(0x80)|value<<7)
}
func (o *CCM_Type) GetCLPCR_DIS_REF_OSC() uint32 {
	return (volatile.LoadUint32(&o.CLPCR.Reg) & 0x80) >> 7
}
func (o *CCM_Type) SetCLPCR_VSTBY(value uint32) {
	volatile.StoreUint32(&o.CLPCR.Reg, volatile.LoadUint32(&o.CLPCR.Reg)&^(0x100)|value<<8)
}
func (o *CCM_Type) GetCLPCR_VSTBY() uint32 {
	return (volatile.LoadUint32(&o.CLPCR.Reg) & 0x100) >> 8
}
func (o *CCM_Type) SetCLPCR_STBY_COUNT(value uint32) {
	volatile.StoreUint32(&o.CLPCR.Reg, volatile.LoadUint32(&o.CLPCR.Reg)&^(0x600)|value<<9)
}
func (o *CCM_Type) GetCLPCR_STBY_COUNT() uint32 {
	return (volatile.LoadUint32(&o.CLPCR.Reg) & 0x600) >> 9
}
func (o *CCM_Type) SetCLPCR_COSC_PWRDOWN(value uint32) {
	volatile.StoreUint32(&o.CLPCR.Reg, volatile.LoadUint32(&o.CLPCR.Reg)&^(0x800)|value<<11)
}
func (o *CCM_Type) GetCLPCR_COSC_PWRDOWN() uint32 {
	return (volatile.LoadUint32(&o.CLPCR.Reg) & 0x800) >> 11
}
func (o *CCM_Type) SetCLPCR_MASK_CORE0_WFI(value uint32) {
	volatile.StoreUint32(&o.CLPCR.Reg, volatile.LoadUint32(&o.CLPCR.Reg)&^(0x400000)|value<<22)
}
func (o *CCM_Type) GetCLPCR_MASK_CORE0_WFI() uint32 {
	return (volatile.LoadUint32(&o.CLPCR.Reg) & 0x400000) >> 22
}
func (o *CCM_Type) SetCLPCR_MASK_SCU_IDLE(value uint32) {
	volatile.StoreUint32(&o.CLPCR.Reg, volatile.LoadUint32(&o.CLPCR.Reg)&^(0x4000000)|value<<26)
}
func (o *CCM_Type) GetCLPCR_MASK_SCU_IDLE() uint32 {
	return (volatile.LoadUint32(&o.CLPCR.Reg) & 0x4000000) >> 26
}
func (o *CCM_Type) SetCLPCR_MASK_L2CC_IDLE(value uint32) {
	volatile.StoreUint32(&o.CLPCR.Reg, volatile.LoadUint32(&o.CLPCR.Reg)&^(0x8000000)|value<<27)
}
func (o *CCM_Type) GetCLPCR_MASK_L2CC_IDLE() uint32 {
	return (volatile.LoadUint32(&o.CLPCR.Reg) & 0x8000000) >> 27
}

// CCM.CISR: CCM Interrupt Status Register
func (o *CCM_Type) SetCISR_LRF_PLL(value uint32) {
	volatile.StoreUint32(&o.CISR.Reg, volatile.LoadUint32(&o.CISR.Reg)&^(0x1)|value)
}
func (o *CCM_Type) GetCISR_LRF_PLL() uint32 {
	return volatile.LoadUint32(&o.CISR.Reg) & 0x1
}
func (o *CCM_Type) SetCISR_COSC_READY(value uint32) {
	volatile.StoreUint32(&o.CISR.Reg, volatile.LoadUint32(&o.CISR.Reg)&^(0x40)|value<<6)
}
func (o *CCM_Type) GetCISR_COSC_READY() uint32 {
	return (volatile.LoadUint32(&o.CISR.Reg) & 0x40) >> 6
}
func (o *CCM_Type) SetCISR_FLEXSPI_PODF_LOADED(value uint32) {
	volatile.StoreUint32(&o.CISR.Reg, volatile.LoadUint32(&o.CISR.Reg)&^(0x10000)|value<<16)
}
func (o *CCM_Type) GetCISR_FLEXSPI_PODF_LOADED() uint32 {
	return (volatile.LoadUint32(&o.CISR.Reg) & 0x10000) >> 16
}
func (o *CCM_Type) SetCISR_PERCLK_PODF_LOADED(value uint32) {
	volatile.StoreUint32(&o.CISR.Reg, volatile.LoadUint32(&o.CISR.Reg)&^(0x40000)|value<<18)
}
func (o *CCM_Type) GetCISR_PERCLK_PODF_LOADED() uint32 {
	return (volatile.LoadUint32(&o.CISR.Reg) & 0x40000) >> 18
}
func (o *CCM_Type) SetCISR_AHB_PODF_LOADED(value uint32) {
	volatile.StoreUint32(&o.CISR.Reg, volatile.LoadUint32(&o.CISR.Reg)&^(0x100000)|value<<20)
}
func (o *CCM_Type) GetCISR_AHB_PODF_LOADED() uint32 {
	return (volatile.LoadUint32(&o.CISR.Reg) & 0x100000) >> 20
}
func (o *CCM_Type) SetCISR_PERIPH_CLK_SEL_LOADED(value uint32) {
	volatile.StoreUint32(&o.CISR.Reg, volatile.LoadUint32(&o.CISR.Reg)&^(0x400000)|value<<22)
}
func (o *CCM_Type) GetCISR_PERIPH_CLK_SEL_LOADED() uint32 {
	return (volatile.LoadUint32(&o.CISR.Reg) & 0x400000) >> 22
}

// CCM.CIMR: CCM Interrupt Mask Register
func (o *CCM_Type) SetCIMR_MASK_LRF_PLL(value uint32) {
	volatile.StoreUint32(&o.CIMR.Reg, volatile.LoadUint32(&o.CIMR.Reg)&^(0x1)|value)
}
func (o *CCM_Type) GetCIMR_MASK_LRF_PLL() uint32 {
	return volatile.LoadUint32(&o.CIMR.Reg) & 0x1
}
func (o *CCM_Type) SetCIMR_MASK_COSC_READY(value uint32) {
	volatile.StoreUint32(&o.CIMR.Reg, volatile.LoadUint32(&o.CIMR.Reg)&^(0x40)|value<<6)
}
func (o *CCM_Type) GetCIMR_MASK_COSC_READY() uint32 {
	return (volatile.LoadUint32(&o.CIMR.Reg) & 0x40) >> 6
}
func (o *CCM_Type) SetCIMR_MASK_FLEXSPI_PODF_LOADED(value uint32) {
	volatile.StoreUint32(&o.CIMR.Reg, volatile.LoadUint32(&o.CIMR.Reg)&^(0x10000)|value<<16)
}
func (o *CCM_Type) GetCIMR_MASK_FLEXSPI_PODF_LOADED() uint32 {
	return (volatile.LoadUint32(&o.CIMR.Reg) & 0x10000) >> 16
}
func (o *CCM_Type) SetCIMR_MASK_PERCLK_PODF_LOADED(value uint32) {
	volatile.StoreUint32(&o.CIMR.Reg, volatile.LoadUint32(&o.CIMR.Reg)&^(0x40000)|value<<18)
}
func (o *CCM_Type) GetCIMR_MASK_PERCLK_PODF_LOADED() uint32 {
	return (volatile.LoadUint32(&o.CIMR.Reg) & 0x40000) >> 18
}
func (o *CCM_Type) SetCIMR_MASK_AHB_PODF_LOADED(value uint32) {
	volatile.StoreUint32(&o.CIMR.Reg, volatile.LoadUint32(&o.CIMR.Reg)&^(0x100000)|value<<20)
}
func (o *CCM_Type) GetCIMR_MASK_AHB_PODF_LOADED() uint32 {
	return (volatile.LoadUint32(&o.CIMR.Reg) & 0x100000) >> 20
}
func (o *CCM_Type) SetCIMR_MASK_PERIPH_CLK_SEL_LOADED(value uint32) {
	volatile.StoreUint32(&o.CIMR.Reg, volatile.LoadUint32(&o.CIMR.Reg)&^(0x400000)|value<<22)
}
func (o *CCM_Type) GetCIMR_MASK_PERIPH_CLK_SEL_LOADED() uint32 {
	return (volatile.LoadUint32(&o.CIMR.Reg) & 0x400000) >> 22
}

// CCM.CCOSR: CCM Clock Output Source Register
func (o *CCM_Type) SetCCOSR_CLKO1_SEL(value uint32) {
	volatile.StoreUint32(&o.CCOSR.Reg, volatile.LoadUint32(&o.CCOSR.Reg)&^(0xf)|value)
}
func (o *CCM_Type) GetCCOSR_CLKO1_SEL() uint32 {
	return volatile.LoadUint32(&o.CCOSR.Reg) & 0xf
}
func (o *CCM_Type) SetCCOSR_CLKO1_DIV(value uint32) {
	volatile.StoreUint32(&o.CCOSR.Reg, volatile.LoadUint32(&o.CCOSR.Reg)&^(0x70)|value<<4)
}
func (o *CCM_Type) GetCCOSR_CLKO1_DIV() uint32 {
	return (volatile.LoadUint32(&o.CCOSR.Reg) & 0x70) >> 4
}
func (o *CCM_Type) SetCCOSR_CLKO1_EN(value uint32) {
	volatile.StoreUint32(&o.CCOSR.Reg, volatile.LoadUint32(&o.CCOSR.Reg)&^(0x80)|value<<7)
}
func (o *CCM_Type) GetCCOSR_CLKO1_EN() uint32 {
	return (volatile.LoadUint32(&o.CCOSR.Reg) & 0x80) >> 7
}
func (o *CCM_Type) SetCCOSR_CLK_OUT_SEL(value uint32) {
	volatile.StoreUint32(&o.CCOSR.Reg, volatile.LoadUint32(&o.CCOSR.Reg)&^(0x100)|value<<8)
}
func (o *CCM_Type) GetCCOSR_CLK_OUT_SEL() uint32 {
	return (volatile.LoadUint32(&o.CCOSR.Reg) & 0x100) >> 8
}
func (o *CCM_Type) SetCCOSR_CLKO2_SEL(value uint32) {
	volatile.StoreUint32(&o.CCOSR.Reg, volatile.LoadUint32(&o.CCOSR.Reg)&^(0x1f0000)|value<<16)
}
func (o *CCM_Type) GetCCOSR_CLKO2_SEL() uint32 {
	return (volatile.LoadUint32(&o.CCOSR.Reg) & 0x1f0000) >> 16
}
func (o *CCM_Type) SetCCOSR_CLKO2_DIV(value uint32) {
	volatile.StoreUint32(&o.CCOSR.Reg, volatile.LoadUint32(&o.CCOSR.Reg)&^(0xe00000)|value<<21)
}
func (o *CCM_Type) GetCCOSR_CLKO2_DIV() uint32 {
	return (volatile.LoadUint32(&o.CCOSR.Reg) & 0xe00000) >> 21
}
func (o *CCM_Type) SetCCOSR_CLKO2_EN(value uint32) {
	volatile.StoreUint32(&o.CCOSR.Reg, volatile.LoadUint32(&o.CCOSR.Reg)&^(0x1000000)|value<<24)
}
func (o *CCM_Type) GetCCOSR_CLKO2_EN() uint32 {
	return (volatile.LoadUint32(&o.CCOSR.Reg) & 0x1000000) >> 24
}

// CCM.CGPR: CCM General Purpose Register
func (o *CCM_Type) SetCGPR_PMIC_DELAY_SCALER(value uint32) {
	volatile.StoreUint32(&o.CGPR.Reg, volatile.LoadUint32(&o.CGPR.Reg)&^(0x1)|value)
}
func (o *CCM_Type) GetCGPR_PMIC_DELAY_SCALER() uint32 {
	return volatile.LoadUint32(&o.CGPR.Reg) & 0x1
}
func (o *CCM_Type) SetCGPR_EFUSE_PROG_SUPPLY_GATE(value uint32) {
	volatile.StoreUint32(&o.CGPR.Reg, volatile.LoadUint32(&o.CGPR.Reg)&^(0x10)|value<<4)
}
func (o *CCM_Type) GetCGPR_EFUSE_PROG_SUPPLY_GATE() uint32 {
	return (volatile.LoadUint32(&o.CGPR.Reg) & 0x10) >> 4
}
func (o *CCM_Type) SetCGPR_SYS_MEM_DS_CTRL(value uint32) {
	volatile.StoreUint32(&o.CGPR.Reg, volatile.LoadUint32(&o.CGPR.Reg)&^(0xc000)|value<<14)
}
func (o *CCM_Type) GetCGPR_SYS_MEM_DS_CTRL() uint32 {
	return (volatile.LoadUint32(&o.CGPR.Reg) & 0xc000) >> 14
}
func (o *CCM_Type) SetCGPR_FPL(value uint32) {
	volatile.StoreUint32(&o.CGPR.Reg, volatile.LoadUint32(&o.CGPR.Reg)&^(0x10000)|value<<16)
}
func (o *CCM_Type) GetCGPR_FPL() uint32 {
	return (volatile.LoadUint32(&o.CGPR.Reg) & 0x10000) >> 16
}
func (o *CCM_Type) SetCGPR_INT_MEM_CLK_LPM(value uint32) {
	volatile.StoreUint32(&o.CGPR.Reg, volatile.LoadUint32(&o.CGPR.Reg)&^(0x20000)|value<<17)
}
func (o *CCM_Type) GetCGPR_INT_MEM_CLK_LPM() uint32 {
	return (volatile.LoadUint32(&o.CGPR.Reg) & 0x20000) >> 17
}

// CCM.CCGR0: CCM Clock Gating Register 0
func (o *CCM_Type) SetCCGR0_CG0(value uint32) {
	volatile.StoreUint32(&o.CCGR0.Reg, volatile.LoadUint32(&o.CCGR0.Reg)&^(0x3)|value)
}
func (o *CCM_Type) GetCCGR0_CG0() uint32 {
	return volatile.LoadUint32(&o.CCGR0.Reg) & 0x3
}
func (o *CCM_Type) SetCCGR0_CG1(value uint32) {
	volatile.StoreUint32(&o.CCGR0.Reg, volatile.LoadUint32(&o.CCGR0.Reg)&^(0xc)|value<<2)
}
func (o *CCM_Type) GetCCGR0_CG1() uint32 {
	return (volatile.LoadUint32(&o.CCGR0.Reg) & 0xc) >> 2
}
func (o *CCM_Type) SetCCGR0_CG2(value uint32) {
	volatile.StoreUint32(&o.CCGR0.Reg, volatile.LoadUint32(&o.CCGR0.Reg)&^(0x30)|value<<4)
}
func (o *CCM_Type) GetCCGR0_CG2() uint32 {
	return (volatile.LoadUint32(&o.CCGR0.Reg) & 0x30) >> 4
}
func (o *CCM_Type) SetCCGR0_CG3(value uint32) {
	volatile.StoreUint32(&o.CCGR0.Reg, volatile.LoadUint32(&o.CCGR0.Reg)&^(0xc0)|value<<6)
}
func (o *CCM_Type) GetCCGR0_CG3() uint32 {
	return (volatile.LoadUint32(&o.CCGR0.Reg) & 0xc0) >> 6
}
func (o *CCM_Type) SetCCGR0_CG4(value uint32) {
	volatile.StoreUint32(&o.CCGR0.Reg, volatile.LoadUint32(&o.CCGR0.Reg)&^(0x300)|value<<8)
}
func (o *CCM_Type) GetCCGR0_CG4() uint32 {
	return (volatile.LoadUint32(&o.CCGR0.Reg) & 0x300) >> 8
}
func (o *CCM_Type) SetCCGR0_CG5(value uint32) {
	volatile.StoreUint32(&o.CCGR0.Reg, volatile.LoadUint32(&o.CCGR0.Reg)&^(0xc00)|value<<10)
}
func (o *CCM_Type) GetCCGR0_CG5() uint32 {
	return (volatile.LoadUint32(&o.CCGR0.Reg) & 0xc00) >> 10
}
func (o *CCM_Type) SetCCGR0_CG6(value uint32) {
	volatile.StoreUint32(&o.CCGR0.Reg, volatile.LoadUint32(&o.CCGR0.Reg)&^(0x3000)|value<<12)
}
func (o *CCM_Type) GetCCGR0_CG6() uint32 {
	return (volatile.LoadUint32(&o.CCGR0.Reg) & 0x3000) >> 12
}
func (o *CCM_Type) SetCCGR0_CG7(value uint32) {
	volatile.StoreUint32(&o.CCGR0.Reg, volatile.LoadUint32(&o.CCGR0.Reg)&^(0xc000)|value<<14)
}
func (o *CCM_Type) GetCCGR0_CG7() uint32 {
	return (volatile.LoadUint32(&o.CCGR0.Reg) & 0xc000) >> 14
}
func (o *CCM_Type) SetCCGR0_CG8(value uint32) {
	volatile.StoreUint32(&o.CCGR0.Reg, volatile.LoadUint32(&o.CCGR0.Reg)&^(0x30000)|value<<16)
}
func (o *CCM_Type) GetCCGR0_CG8() uint32 {
	return (volatile.LoadUint32(&o.CCGR0.Reg) & 0x30000) >> 16
}
func (o *CCM_Type) SetCCGR0_CG9(value uint32) {
	volatile.StoreUint32(&o.CCGR0.Reg, volatile.LoadUint32(&o.CCGR0.Reg)&^(0xc0000)|value<<18)
}
func (o *CCM_Type) GetCCGR0_CG9() uint32 {
	return (volatile.LoadUint32(&o.CCGR0.Reg) & 0xc0000) >> 18
}
func (o *CCM_Type) SetCCGR0_CG10(value uint32) {
	volatile.StoreUint32(&o.CCGR0.Reg, volatile.LoadUint32(&o.CCGR0.Reg)&^(0x300000)|value<<20)
}
func (o *CCM_Type) GetCCGR0_CG10() uint32 {
	return (volatile.LoadUint32(&o.CCGR0.Reg) & 0x300000) >> 20
}
func (o *CCM_Type) SetCCGR0_CG11(value uint32) {
	volatile.StoreUint32(&o.CCGR0.Reg, volatile.LoadUint32(&o.CCGR0.Reg)&^(0xc00000)|value<<22)
}
func (o *CCM_Type) GetCCGR0_CG11() uint32 {
	return (volatile.LoadUint32(&o.CCGR0.Reg) & 0xc00000) >> 22
}
func (o *CCM_Type) SetCCGR0_CG12(value uint32) {
	volatile.StoreUint32(&o.CCGR0.Reg, volatile.LoadUint32(&o.CCGR0.Reg)&^(0x3000000)|value<<24)
}
func (o *CCM_Type) GetCCGR0_CG12() uint32 {
	return (volatile.LoadUint32(&o.CCGR0.Reg) & 0x3000000) >> 24
}
func (o *CCM_Type) SetCCGR0_CG13(value uint32) {
	volatile.StoreUint32(&o.CCGR0.Reg, volatile.LoadUint32(&o.CCGR0.Reg)&^(0xc000000)|value<<26)
}
func (o *CCM_Type) GetCCGR0_CG13() uint32 {
	return (volatile.LoadUint32(&o.CCGR0.Reg) & 0xc000000) >> 26
}
func (o *CCM_Type) SetCCGR0_CG14(value uint32) {
	volatile.StoreUint32(&o.CCGR0.Reg, volatile.LoadUint32(&o.CCGR0.Reg)&^(0x30000000)|value<<28)
}
func (o *CCM_Type) GetCCGR0_CG14() uint32 {
	return (volatile.LoadUint32(&o.CCGR0.Reg) & 0x30000000) >> 28
}
func (o *CCM_Type) SetCCGR0_CG15(value uint32) {
	volatile.StoreUint32(&o.CCGR0.Reg, volatile.LoadUint32(&o.CCGR0.Reg)&^(0xc0000000)|value<<30)
}
func (o *CCM_Type) GetCCGR0_CG15() uint32 {
	return (volatile.LoadUint32(&o.CCGR0.Reg) & 0xc0000000) >> 30
}

// CCM.CCGR1: CCM Clock Gating Register 1
func (o *CCM_Type) SetCCGR1_CG0(value uint32) {
	volatile.StoreUint32(&o.CCGR1.Reg, volatile.LoadUint32(&o.CCGR1.Reg)&^(0x3)|value)
}
func (o *CCM_Type) GetCCGR1_CG0() uint32 {
	return volatile.LoadUint32(&o.CCGR1.Reg) & 0x3
}
func (o *CCM_Type) SetCCGR1_CG1(value uint32) {
	volatile.StoreUint32(&o.CCGR1.Reg, volatile.LoadUint32(&o.CCGR1.Reg)&^(0xc)|value<<2)
}
func (o *CCM_Type) GetCCGR1_CG1() uint32 {
	return (volatile.LoadUint32(&o.CCGR1.Reg) & 0xc) >> 2
}
func (o *CCM_Type) SetCCGR1_CG2(value uint32) {
	volatile.StoreUint32(&o.CCGR1.Reg, volatile.LoadUint32(&o.CCGR1.Reg)&^(0x30)|value<<4)
}
func (o *CCM_Type) GetCCGR1_CG2() uint32 {
	return (volatile.LoadUint32(&o.CCGR1.Reg) & 0x30) >> 4
}
func (o *CCM_Type) SetCCGR1_CG3(value uint32) {
	volatile.StoreUint32(&o.CCGR1.Reg, volatile.LoadUint32(&o.CCGR1.Reg)&^(0xc0)|value<<6)
}
func (o *CCM_Type) GetCCGR1_CG3() uint32 {
	return (volatile.LoadUint32(&o.CCGR1.Reg) & 0xc0) >> 6
}
func (o *CCM_Type) SetCCGR1_CG4(value uint32) {
	volatile.StoreUint32(&o.CCGR1.Reg, volatile.LoadUint32(&o.CCGR1.Reg)&^(0x300)|value<<8)
}
func (o *CCM_Type) GetCCGR1_CG4() uint32 {
	return (volatile.LoadUint32(&o.CCGR1.Reg) & 0x300) >> 8
}
func (o *CCM_Type) SetCCGR1_CG5(value uint32) {
	volatile.StoreUint32(&o.CCGR1.Reg, volatile.LoadUint32(&o.CCGR1.Reg)&^(0xc00)|value<<10)
}
func (o *CCM_Type) GetCCGR1_CG5() uint32 {
	return (volatile.LoadUint32(&o.CCGR1.Reg) & 0xc00) >> 10
}
func (o *CCM_Type) SetCCGR1_CG6(value uint32) {
	volatile.StoreUint32(&o.CCGR1.Reg, volatile.LoadUint32(&o.CCGR1.Reg)&^(0x3000)|value<<12)
}
func (o *CCM_Type) GetCCGR1_CG6() uint32 {
	return (volatile.LoadUint32(&o.CCGR1.Reg) & 0x3000) >> 12
}
func (o *CCM_Type) SetCCGR1_CG7(value uint32) {
	volatile.StoreUint32(&o.CCGR1.Reg, volatile.LoadUint32(&o.CCGR1.Reg)&^(0xc000)|value<<14)
}
func (o *CCM_Type) GetCCGR1_CG7() uint32 {
	return (volatile.LoadUint32(&o.CCGR1.Reg) & 0xc000) >> 14
}
func (o *CCM_Type) SetCCGR1_CG8(value uint32) {
	volatile.StoreUint32(&o.CCGR1.Reg, volatile.LoadUint32(&o.CCGR1.Reg)&^(0x30000)|value<<16)
}
func (o *CCM_Type) GetCCGR1_CG8() uint32 {
	return (volatile.LoadUint32(&o.CCGR1.Reg) & 0x30000) >> 16
}
func (o *CCM_Type) SetCCGR1_CG9(value uint32) {
	volatile.StoreUint32(&o.CCGR1.Reg, volatile.LoadUint32(&o.CCGR1.Reg)&^(0xc0000)|value<<18)
}
func (o *CCM_Type) GetCCGR1_CG9() uint32 {
	return (volatile.LoadUint32(&o.CCGR1.Reg) & 0xc0000) >> 18
}
func (o *CCM_Type) SetCCGR1_CG10(value uint32) {
	volatile.StoreUint32(&o.CCGR1.Reg, volatile.LoadUint32(&o.CCGR1.Reg)&^(0x300000)|value<<20)
}
func (o *CCM_Type) GetCCGR1_CG10() uint32 {
	return (volatile.LoadUint32(&o.CCGR1.Reg) & 0x300000) >> 20
}
func (o *CCM_Type) SetCCGR1_CG11(value uint32) {
	volatile.StoreUint32(&o.CCGR1.Reg, volatile.LoadUint32(&o.CCGR1.Reg)&^(0xc00000)|value<<22)
}
func (o *CCM_Type) GetCCGR1_CG11() uint32 {
	return (volatile.LoadUint32(&o.CCGR1.Reg) & 0xc00000) >> 22
}
func (o *CCM_Type) SetCCGR1_CG12(value uint32) {
	volatile.StoreUint32(&o.CCGR1.Reg, volatile.LoadUint32(&o.CCGR1.Reg)&^(0x3000000)|value<<24)
}
func (o *CCM_Type) GetCCGR1_CG12() uint32 {
	return (volatile.LoadUint32(&o.CCGR1.Reg) & 0x3000000) >> 24
}
func (o *CCM_Type) SetCCGR1_CG13(value uint32) {
	volatile.StoreUint32(&o.CCGR1.Reg, volatile.LoadUint32(&o.CCGR1.Reg)&^(0xc000000)|value<<26)
}
func (o *CCM_Type) GetCCGR1_CG13() uint32 {
	return (volatile.LoadUint32(&o.CCGR1.Reg) & 0xc000000) >> 26
}
func (o *CCM_Type) SetCCGR1_CG14(value uint32) {
	volatile.StoreUint32(&o.CCGR1.Reg, volatile.LoadUint32(&o.CCGR1.Reg)&^(0x30000000)|value<<28)
}
func (o *CCM_Type) GetCCGR1_CG14() uint32 {
	return (volatile.LoadUint32(&o.CCGR1.Reg) & 0x30000000) >> 28
}
func (o *CCM_Type) SetCCGR1_CG15(value uint32) {
	volatile.StoreUint32(&o.CCGR1.Reg, volatile.LoadUint32(&o.CCGR1.Reg)&^(0xc0000000)|value<<30)
}
func (o *CCM_Type) GetCCGR1_CG15() uint32 {
	return (volatile.LoadUint32(&o.CCGR1.Reg) & 0xc0000000) >> 30
}

// CCM.CCGR2: CCM Clock Gating Register 2
func (o *CCM_Type) SetCCGR2_CG0(value uint32) {
	volatile.StoreUint32(&o.CCGR2.Reg, volatile.LoadUint32(&o.CCGR2.Reg)&^(0x3)|value)
}
func (o *CCM_Type) GetCCGR2_CG0() uint32 {
	return volatile.LoadUint32(&o.CCGR2.Reg) & 0x3
}
func (o *CCM_Type) SetCCGR2_CG1(value uint32) {
	volatile.StoreUint32(&o.CCGR2.Reg, volatile.LoadUint32(&o.CCGR2.Reg)&^(0xc)|value<<2)
}
func (o *CCM_Type) GetCCGR2_CG1() uint32 {
	return (volatile.LoadUint32(&o.CCGR2.Reg) & 0xc) >> 2
}
func (o *CCM_Type) SetCCGR2_CG2(value uint32) {
	volatile.StoreUint32(&o.CCGR2.Reg, volatile.LoadUint32(&o.CCGR2.Reg)&^(0x30)|value<<4)
}
func (o *CCM_Type) GetCCGR2_CG2() uint32 {
	return (volatile.LoadUint32(&o.CCGR2.Reg) & 0x30) >> 4
}
func (o *CCM_Type) SetCCGR2_CG3(value uint32) {
	volatile.StoreUint32(&o.CCGR2.Reg, volatile.LoadUint32(&o.CCGR2.Reg)&^(0xc0)|value<<6)
}
func (o *CCM_Type) GetCCGR2_CG3() uint32 {
	return (volatile.LoadUint32(&o.CCGR2.Reg) & 0xc0) >> 6
}
func (o *CCM_Type) SetCCGR2_CG4(value uint32) {
	volatile.StoreUint32(&o.CCGR2.Reg, volatile.LoadUint32(&o.CCGR2.Reg)&^(0x300)|value<<8)
}
func (o *CCM_Type) GetCCGR2_CG4() uint32 {
	return (volatile.LoadUint32(&o.CCGR2.Reg) & 0x300) >> 8
}
func (o *CCM_Type) SetCCGR2_CG5(value uint32) {
	volatile.StoreUint32(&o.CCGR2.Reg, volatile.LoadUint32(&o.CCGR2.Reg)&^(0xc00)|value<<10)
}
func (o *CCM_Type) GetCCGR2_CG5() uint32 {
	return (volatile.LoadUint32(&o.CCGR2.Reg) & 0xc00) >> 10
}
func (o *CCM_Type) SetCCGR2_CG6(value uint32) {
	volatile.StoreUint32(&o.CCGR2.Reg, volatile.LoadUint32(&o.CCGR2.Reg)&^(0x3000)|value<<12)
}
func (o *CCM_Type) GetCCGR2_CG6() uint32 {
	return (volatile.LoadUint32(&o.CCGR2.Reg) & 0x3000) >> 12
}
func (o *CCM_Type) SetCCGR2_CG7(value uint32) {
	volatile.StoreUint32(&o.CCGR2.Reg, volatile.LoadUint32(&o.CCGR2.Reg)&^(0xc000)|value<<14)
}
func (o *CCM_Type) GetCCGR2_CG7() uint32 {
	return (volatile.LoadUint32(&o.CCGR2.Reg) & 0xc000) >> 14
}
func (o *CCM_Type) SetCCGR2_CG8(value uint32) {
	volatile.StoreUint32(&o.CCGR2.Reg, volatile.LoadUint32(&o.CCGR2.Reg)&^(0x30000)|value<<16)
}
func (o *CCM_Type) GetCCGR2_CG8() uint32 {
	return (volatile.LoadUint32(&o.CCGR2.Reg) & 0x30000) >> 16
}
func (o *CCM_Type) SetCCGR2_CG9(value uint32) {
	volatile.StoreUint32(&o.CCGR2.Reg, volatile.LoadUint32(&o.CCGR2.Reg)&^(0xc0000)|value<<18)
}
func (o *CCM_Type) GetCCGR2_CG9() uint32 {
	return (volatile.LoadUint32(&o.CCGR2.Reg) & 0xc0000) >> 18
}
func (o *CCM_Type) SetCCGR2_CG10(value uint32) {
	volatile.StoreUint32(&o.CCGR2.Reg, volatile.LoadUint32(&o.CCGR2.Reg)&^(0x300000)|value<<20)
}
func (o *CCM_Type) GetCCGR2_CG10() uint32 {
	return (volatile.LoadUint32(&o.CCGR2.Reg) & 0x300000) >> 20
}
func (o *CCM_Type) SetCCGR2_CG11(value uint32) {
	volatile.StoreUint32(&o.CCGR2.Reg, volatile.LoadUint32(&o.CCGR2.Reg)&^(0xc00000)|value<<22)
}
func (o *CCM_Type) GetCCGR2_CG11() uint32 {
	return (volatile.LoadUint32(&o.CCGR2.Reg) & 0xc00000) >> 22
}
func (o *CCM_Type) SetCCGR2_CG12(value uint32) {
	volatile.StoreUint32(&o.CCGR2.Reg, volatile.LoadUint32(&o.CCGR2.Reg)&^(0x3000000)|value<<24)
}
func (o *CCM_Type) GetCCGR2_CG12() uint32 {
	return (volatile.LoadUint32(&o.CCGR2.Reg) & 0x3000000) >> 24
}
func (o *CCM_Type) SetCCGR2_CG13(value uint32) {
	volatile.StoreUint32(&o.CCGR2.Reg, volatile.LoadUint32(&o.CCGR2.Reg)&^(0xc000000)|value<<26)
}
func (o *CCM_Type) GetCCGR2_CG13() uint32 {
	return (volatile.LoadUint32(&o.CCGR2.Reg) & 0xc000000) >> 26
}
func (o *CCM_Type) SetCCGR2_CG14(value uint32) {
	volatile.StoreUint32(&o.CCGR2.Reg, volatile.LoadUint32(&o.CCGR2.Reg)&^(0x30000000)|value<<28)
}
func (o *CCM_Type) GetCCGR2_CG14() uint32 {
	return (volatile.LoadUint32(&o.CCGR2.Reg) & 0x30000000) >> 28
}
func (o *CCM_Type) SetCCGR2_CG15(value uint32) {
	volatile.StoreUint32(&o.CCGR2.Reg, volatile.LoadUint32(&o.CCGR2.Reg)&^(0xc0000000)|value<<30)
}
func (o *CCM_Type) GetCCGR2_CG15() uint32 {
	return (volatile.LoadUint32(&o.CCGR2.Reg) & 0xc0000000) >> 30
}

// CCM.CCGR3: CCM Clock Gating Register 3
func (o *CCM_Type) SetCCGR3_CG0(value uint32) {
	volatile.StoreUint32(&o.CCGR3.Reg, volatile.LoadUint32(&o.CCGR3.Reg)&^(0x3)|value)
}
func (o *CCM_Type) GetCCGR3_CG0() uint32 {
	return volatile.LoadUint32(&o.CCGR3.Reg) & 0x3
}
func (o *CCM_Type) SetCCGR3_CG1(value uint32) {
	volatile.StoreUint32(&o.CCGR3.Reg, volatile.LoadUint32(&o.CCGR3.Reg)&^(0xc)|value<<2)
}
func (o *CCM_Type) GetCCGR3_CG1() uint32 {
	return (volatile.LoadUint32(&o.CCGR3.Reg) & 0xc) >> 2
}
func (o *CCM_Type) SetCCGR3_CG2(value uint32) {
	volatile.StoreUint32(&o.CCGR3.Reg, volatile.LoadUint32(&o.CCGR3.Reg)&^(0x30)|value<<4)
}
func (o *CCM_Type) GetCCGR3_CG2() uint32 {
	return (volatile.LoadUint32(&o.CCGR3.Reg) & 0x30) >> 4
}
func (o *CCM_Type) SetCCGR3_CG3(value uint32) {
	volatile.StoreUint32(&o.CCGR3.Reg, volatile.LoadUint32(&o.CCGR3.Reg)&^(0xc0)|value<<6)
}
func (o *CCM_Type) GetCCGR3_CG3() uint32 {
	return (volatile.LoadUint32(&o.CCGR3.Reg) & 0xc0) >> 6
}
func (o *CCM_Type) SetCCGR3_CG4(value uint32) {
	volatile.StoreUint32(&o.CCGR3.Reg, volatile.LoadUint32(&o.CCGR3.Reg)&^(0x300)|value<<8)
}
func (o *CCM_Type) GetCCGR3_CG4() uint32 {
	return (volatile.LoadUint32(&o.CCGR3.Reg) & 0x300) >> 8
}
func (o *CCM_Type) SetCCGR3_CG5(value uint32) {
	volatile.StoreUint32(&o.CCGR3.Reg, volatile.LoadUint32(&o.CCGR3.Reg)&^(0xc00)|value<<10)
}
func (o *CCM_Type) GetCCGR3_CG5() uint32 {
	return (volatile.LoadUint32(&o.CCGR3.Reg) & 0xc00) >> 10
}
func (o *CCM_Type) SetCCGR3_CG6(value uint32) {
	volatile.StoreUint32(&o.CCGR3.Reg, volatile.LoadUint32(&o.CCGR3.Reg)&^(0x3000)|value<<12)
}
func (o *CCM_Type) GetCCGR3_CG6() uint32 {
	return (volatile.LoadUint32(&o.CCGR3.Reg) & 0x3000) >> 12
}
func (o *CCM_Type) SetCCGR3_CG7(value uint32) {
	volatile.StoreUint32(&o.CCGR3.Reg, volatile.LoadUint32(&o.CCGR3.Reg)&^(0xc000)|value<<14)
}
func (o *CCM_Type) GetCCGR3_CG7() uint32 {
	return (volatile.LoadUint32(&o.CCGR3.Reg) & 0xc000) >> 14
}
func (o *CCM_Type) SetCCGR3_CG8(value uint32) {
	volatile.StoreUint32(&o.CCGR3.Reg, volatile.LoadUint32(&o.CCGR3.Reg)&^(0x30000)|value<<16)
}
func (o *CCM_Type) GetCCGR3_CG8() uint32 {
	return (volatile.LoadUint32(&o.CCGR3.Reg) & 0x30000) >> 16
}
func (o *CCM_Type) SetCCGR3_CG9(value uint32) {
	volatile.StoreUint32(&o.CCGR3.Reg, volatile.LoadUint32(&o.CCGR3.Reg)&^(0xc0000)|value<<18)
}
func (o *CCM_Type) GetCCGR3_CG9() uint32 {
	return (volatile.LoadUint32(&o.CCGR3.Reg) & 0xc0000) >> 18
}
func (o *CCM_Type) SetCCGR3_CG10(value uint32) {
	volatile.StoreUint32(&o.CCGR3.Reg, volatile.LoadUint32(&o.CCGR3.Reg)&^(0x300000)|value<<20)
}
func (o *CCM_Type) GetCCGR3_CG10() uint32 {
	return (volatile.LoadUint32(&o.CCGR3.Reg) & 0x300000) >> 20
}
func (o *CCM_Type) SetCCGR3_CG11(value uint32) {
	volatile.StoreUint32(&o.CCGR3.Reg, volatile.LoadUint32(&o.CCGR3.Reg)&^(0xc00000)|value<<22)
}
func (o *CCM_Type) GetCCGR3_CG11() uint32 {
	return (volatile.LoadUint32(&o.CCGR3.Reg) & 0xc00000) >> 22
}
func (o *CCM_Type) SetCCGR3_CG12(value uint32) {
	volatile.StoreUint32(&o.CCGR3.Reg, volatile.LoadUint32(&o.CCGR3.Reg)&^(0x3000000)|value<<24)
}
func (o *CCM_Type) GetCCGR3_CG12() uint32 {
	return (volatile.LoadUint32(&o.CCGR3.Reg) & 0x3000000) >> 24
}
func (o *CCM_Type) SetCCGR3_CG13(value uint32) {
	volatile.StoreUint32(&o.CCGR3.Reg, volatile.LoadUint32(&o.CCGR3.Reg)&^(0xc000000)|value<<26)
}
func (o *CCM_Type) GetCCGR3_CG13() uint32 {
	return (volatile.LoadUint32(&o.CCGR3.Reg) & 0xc000000) >> 26
}
func (o *CCM_Type) SetCCGR3_CG14(value uint32) {
	volatile.StoreUint32(&o.CCGR3.Reg, volatile.LoadUint32(&o.CCGR3.Reg)&^(0x30000000)|value<<28)
}
func (o *CCM_Type) GetCCGR3_CG14() uint32 {
	return (volatile.LoadUint32(&o.CCGR3.Reg) & 0x30000000) >> 28
}
func (o *CCM_Type) SetCCGR3_CG15(value uint32) {
	volatile.StoreUint32(&o.CCGR3.Reg, volatile.LoadUint32(&o.CCGR3.Reg)&^(0xc0000000)|value<<30)
}
func (o *CCM_Type) GetCCGR3_CG15() uint32 {
	return (volatile.LoadUint32(&o.CCGR3.Reg) & 0xc0000000) >> 30
}

// CCM.CCGR4: CCM Clock Gating Register 4
func (o *CCM_Type) SetCCGR4_CG0(value uint32) {
	volatile.StoreUint32(&o.CCGR4.Reg, volatile.LoadUint32(&o.CCGR4.Reg)&^(0x3)|value)
}
func (o *CCM_Type) GetCCGR4_CG0() uint32 {
	return volatile.LoadUint32(&o.CCGR4.Reg) & 0x3
}
func (o *CCM_Type) SetCCGR4_CG1(value uint32) {
	volatile.StoreUint32(&o.CCGR4.Reg, volatile.LoadUint32(&o.CCGR4.Reg)&^(0xc)|value<<2)
}
func (o *CCM_Type) GetCCGR4_CG1() uint32 {
	return (volatile.LoadUint32(&o.CCGR4.Reg) & 0xc) >> 2
}
func (o *CCM_Type) SetCCGR4_CG2(value uint32) {
	volatile.StoreUint32(&o.CCGR4.Reg, volatile.LoadUint32(&o.CCGR4.Reg)&^(0x30)|value<<4)
}
func (o *CCM_Type) GetCCGR4_CG2() uint32 {
	return (volatile.LoadUint32(&o.CCGR4.Reg) & 0x30) >> 4
}
func (o *CCM_Type) SetCCGR4_CG3(value uint32) {
	volatile.StoreUint32(&o.CCGR4.Reg, volatile.LoadUint32(&o.CCGR4.Reg)&^(0xc0)|value<<6)
}
func (o *CCM_Type) GetCCGR4_CG3() uint32 {
	return (volatile.LoadUint32(&o.CCGR4.Reg) & 0xc0) >> 6
}
func (o *CCM_Type) SetCCGR4_CG4(value uint32) {
	volatile.StoreUint32(&o.CCGR4.Reg, volatile.LoadUint32(&o.CCGR4.Reg)&^(0x300)|value<<8)
}
func (o *CCM_Type) GetCCGR4_CG4() uint32 {
	return (volatile.LoadUint32(&o.CCGR4.Reg) & 0x300) >> 8
}
func (o *CCM_Type) SetCCGR4_CG5(value uint32) {
	volatile.StoreUint32(&o.CCGR4.Reg, volatile.LoadUint32(&o.CCGR4.Reg)&^(0xc00)|value<<10)
}
func (o *CCM_Type) GetCCGR4_CG5() uint32 {
	return (volatile.LoadUint32(&o.CCGR4.Reg) & 0xc00) >> 10
}
func (o *CCM_Type) SetCCGR4_CG6(value uint32) {
	volatile.StoreUint32(&o.CCGR4.Reg, volatile.LoadUint32(&o.CCGR4.Reg)&^(0x3000)|value<<12)
}
func (o *CCM_Type) GetCCGR4_CG6() uint32 {
	return (volatile.LoadUint32(&o.CCGR4.Reg) & 0x3000) >> 12
}
func (o *CCM_Type) SetCCGR4_CG7(value uint32) {
	volatile.StoreUint32(&o.CCGR4.Reg, volatile.LoadUint32(&o.CCGR4.Reg)&^(0xc000)|value<<14)
}
func (o *CCM_Type) GetCCGR4_CG7() uint32 {
	return (volatile.LoadUint32(&o.CCGR4.Reg) & 0xc000) >> 14
}
func (o *CCM_Type) SetCCGR4_CG8(value uint32) {
	volatile.StoreUint32(&o.CCGR4.Reg, volatile.LoadUint32(&o.CCGR4.Reg)&^(0x30000)|value<<16)
}
func (o *CCM_Type) GetCCGR4_CG8() uint32 {
	return (volatile.LoadUint32(&o.CCGR4.Reg) & 0x30000) >> 16
}
func (o *CCM_Type) SetCCGR4_CG9(value uint32) {
	volatile.StoreUint32(&o.CCGR4.Reg, volatile.LoadUint32(&o.CCGR4.Reg)&^(0xc0000)|value<<18)
}
func (o *CCM_Type) GetCCGR4_CG9() uint32 {
	return (volatile.LoadUint32(&o.CCGR4.Reg) & 0xc0000) >> 18
}
func (o *CCM_Type) SetCCGR4_CG10(value uint32) {
	volatile.StoreUint32(&o.CCGR4.Reg, volatile.LoadUint32(&o.CCGR4.Reg)&^(0x300000)|value<<20)
}
func (o *CCM_Type) GetCCGR4_CG10() uint32 {
	return (volatile.LoadUint32(&o.CCGR4.Reg) & 0x300000) >> 20
}
func (o *CCM_Type) SetCCGR4_CG11(value uint32) {
	volatile.StoreUint32(&o.CCGR4.Reg, volatile.LoadUint32(&o.CCGR4.Reg)&^(0xc00000)|value<<22)
}
func (o *CCM_Type) GetCCGR4_CG11() uint32 {
	return (volatile.LoadUint32(&o.CCGR4.Reg) & 0xc00000) >> 22
}
func (o *CCM_Type) SetCCGR4_CG12(value uint32) {
	volatile.StoreUint32(&o.CCGR4.Reg, volatile.LoadUint32(&o.CCGR4.Reg)&^(0x3000000)|value<<24)
}
func (o *CCM_Type) GetCCGR4_CG12() uint32 {
	return (volatile.LoadUint32(&o.CCGR4.Reg) & 0x3000000) >> 24
}
func (o *CCM_Type) SetCCGR4_CG13(value uint32) {
	volatile.StoreUint32(&o.CCGR4.Reg, volatile.LoadUint32(&o.CCGR4.Reg)&^(0xc000000)|value<<26)
}
func (o *CCM_Type) GetCCGR4_CG13() uint32 {
	return (volatile.LoadUint32(&o.CCGR4.Reg) & 0xc000000) >> 26
}
func (o *CCM_Type) SetCCGR4_CG14(value uint32) {
	volatile.StoreUint32(&o.CCGR4.Reg, volatile.LoadUint32(&o.CCGR4.Reg)&^(0x30000000)|value<<28)
}
func (o *CCM_Type) GetCCGR4_CG14() uint32 {
	return (volatile.LoadUint32(&o.CCGR4.Reg) & 0x30000000) >> 28
}
func (o *CCM_Type) SetCCGR4_CG15(value uint32) {
	volatile.StoreUint32(&o.CCGR4.Reg, volatile.LoadUint32(&o.CCGR4.Reg)&^(0xc0000000)|value<<30)
}
func (o *CCM_Type) GetCCGR4_CG15() uint32 {
	return (volatile.LoadUint32(&o.CCGR4.Reg) & 0xc0000000) >> 30
}

// CCM.CCGR5: CCM Clock Gating Register 5
func (o *CCM_Type) SetCCGR5_CG0(value uint32) {
	volatile.StoreUint32(&o.CCGR5.Reg, volatile.LoadUint32(&o.CCGR5.Reg)&^(0x3)|value)
}
func (o *CCM_Type) GetCCGR5_CG0() uint32 {
	return volatile.LoadUint32(&o.CCGR5.Reg) & 0x3
}
func (o *CCM_Type) SetCCGR5_CG1(value uint32) {
	volatile.StoreUint32(&o.CCGR5.Reg, volatile.LoadUint32(&o.CCGR5.Reg)&^(0xc)|value<<2)
}
func (o *CCM_Type) GetCCGR5_CG1() uint32 {
	return (volatile.LoadUint32(&o.CCGR5.Reg) & 0xc) >> 2
}
func (o *CCM_Type) SetCCGR5_CG2(value uint32) {
	volatile.StoreUint32(&o.CCGR5.Reg, volatile.LoadUint32(&o.CCGR5.Reg)&^(0x30)|value<<4)
}
func (o *CCM_Type) GetCCGR5_CG2() uint32 {
	return (volatile.LoadUint32(&o.CCGR5.Reg) & 0x30) >> 4
}
func (o *CCM_Type) SetCCGR5_CG3(value uint32) {
	volatile.StoreUint32(&o.CCGR5.Reg, volatile.LoadUint32(&o.CCGR5.Reg)&^(0xc0)|value<<6)
}
func (o *CCM_Type) GetCCGR5_CG3() uint32 {
	return (volatile.LoadUint32(&o.CCGR5.Reg) & 0xc0) >> 6
}
func (o *CCM_Type) SetCCGR5_CG4(value uint32) {
	volatile.StoreUint32(&o.CCGR5.Reg, volatile.LoadUint32(&o.CCGR5.Reg)&^(0x300)|value<<8)
}
func (o *CCM_Type) GetCCGR5_CG4() uint32 {
	return (volatile.LoadUint32(&o.CCGR5.Reg) & 0x300) >> 8
}
func (o *CCM_Type) SetCCGR5_CG5(value uint32) {
	volatile.StoreUint32(&o.CCGR5.Reg, volatile.LoadUint32(&o.CCGR5.Reg)&^(0xc00)|value<<10)
}
func (o *CCM_Type) GetCCGR5_CG5() uint32 {
	return (volatile.LoadUint32(&o.CCGR5.Reg) & 0xc00) >> 10
}
func (o *CCM_Type) SetCCGR5_CG6(value uint32) {
	volatile.StoreUint32(&o.CCGR5.Reg, volatile.LoadUint32(&o.CCGR5.Reg)&^(0x3000)|value<<12)
}
func (o *CCM_Type) GetCCGR5_CG6() uint32 {
	return (volatile.LoadUint32(&o.CCGR5.Reg) & 0x3000) >> 12
}
func (o *CCM_Type) SetCCGR5_CG7(value uint32) {
	volatile.StoreUint32(&o.CCGR5.Reg, volatile.LoadUint32(&o.CCGR5.Reg)&^(0xc000)|value<<14)
}
func (o *CCM_Type) GetCCGR5_CG7() uint32 {
	return (volatile.LoadUint32(&o.CCGR5.Reg) & 0xc000) >> 14
}
func (o *CCM_Type) SetCCGR5_CG8(value uint32) {
	volatile.StoreUint32(&o.CCGR5.Reg, volatile.LoadUint32(&o.CCGR5.Reg)&^(0x30000)|value<<16)
}
func (o *CCM_Type) GetCCGR5_CG8() uint32 {
	return (volatile.LoadUint32(&o.CCGR5.Reg) & 0x30000) >> 16
}
func (o *CCM_Type) SetCCGR5_CG9(value uint32) {
	volatile.StoreUint32(&o.CCGR5.Reg, volatile.LoadUint32(&o.CCGR5.Reg)&^(0xc0000)|value<<18)
}
func (o *CCM_Type) GetCCGR5_CG9() uint32 {
	return (volatile.LoadUint32(&o.CCGR5.Reg) & 0xc0000) >> 18
}
func (o *CCM_Type) SetCCGR5_CG10(value uint32) {
	volatile.StoreUint32(&o.CCGR5.Reg, volatile.LoadUint32(&o.CCGR5.Reg)&^(0x300000)|value<<20)
}
func (o *CCM_Type) GetCCGR5_CG10() uint32 {
	return (volatile.LoadUint32(&o.CCGR5.Reg) & 0x300000) >> 20
}
func (o *CCM_Type) SetCCGR5_CG11(value uint32) {
	volatile.StoreUint32(&o.CCGR5.Reg, volatile.LoadUint32(&o.CCGR5.Reg)&^(0xc00000)|value<<22)
}
func (o *CCM_Type) GetCCGR5_CG11() uint32 {
	return (volatile.LoadUint32(&o.CCGR5.Reg) & 0xc00000) >> 22
}
func (o *CCM_Type) SetCCGR5_CG12(value uint32) {
	volatile.StoreUint32(&o.CCGR5.Reg, volatile.LoadUint32(&o.CCGR5.Reg)&^(0x3000000)|value<<24)
}
func (o *CCM_Type) GetCCGR5_CG12() uint32 {
	return (volatile.LoadUint32(&o.CCGR5.Reg) & 0x3000000) >> 24
}
func (o *CCM_Type) SetCCGR5_CG13(value uint32) {
	volatile.StoreUint32(&o.CCGR5.Reg, volatile.LoadUint32(&o.CCGR5.Reg)&^(0xc000000)|value<<26)
}
func (o *CCM_Type) GetCCGR5_CG13() uint32 {
	return (volatile.LoadUint32(&o.CCGR5.Reg) & 0xc000000) >> 26
}
func (o *CCM_Type) SetCCGR5_CG14(value uint32) {
	volatile.StoreUint32(&o.CCGR5.Reg, volatile.LoadUint32(&o.CCGR5.Reg)&^(0x30000000)|value<<28)
}
func (o *CCM_Type) GetCCGR5_CG14() uint32 {
	return (volatile.LoadUint32(&o.CCGR5.Reg) & 0x30000000) >> 28
}
func (o *CCM_Type) SetCCGR5_CG15(value uint32) {
	volatile.StoreUint32(&o.CCGR5.Reg, volatile.LoadUint32(&o.CCGR5.Reg)&^(0xc0000000)|value<<30)
}
func (o *CCM_Type) GetCCGR5_CG15() uint32 {
	return (volatile.LoadUint32(&o.CCGR5.Reg) & 0xc0000000) >> 30
}

// CCM.CCGR6: CCM Clock Gating Register 6
func (o *CCM_Type) SetCCGR6_CG0(value uint32) {
	volatile.StoreUint32(&o.CCGR6.Reg, volatile.LoadUint32(&o.CCGR6.Reg)&^(0x3)|value)
}
func (o *CCM_Type) GetCCGR6_CG0() uint32 {
	return volatile.LoadUint32(&o.CCGR6.Reg) & 0x3
}
func (o *CCM_Type) SetCCGR6_CG1(value uint32) {
	volatile.StoreUint32(&o.CCGR6.Reg, volatile.LoadUint32(&o.CCGR6.Reg)&^(0xc)|value<<2)
}
func (o *CCM_Type) GetCCGR6_CG1() uint32 {
	return (volatile.LoadUint32(&o.CCGR6.Reg) & 0xc) >> 2
}
func (o *CCM_Type) SetCCGR6_CG2(value uint32) {
	volatile.StoreUint32(&o.CCGR6.Reg, volatile.LoadUint32(&o.CCGR6.Reg)&^(0x30)|value<<4)
}
func (o *CCM_Type) GetCCGR6_CG2() uint32 {
	return (volatile.LoadUint32(&o.CCGR6.Reg) & 0x30) >> 4
}
func (o *CCM_Type) SetCCGR6_CG3(value uint32) {
	volatile.StoreUint32(&o.CCGR6.Reg, volatile.LoadUint32(&o.CCGR6.Reg)&^(0xc0)|value<<6)
}
func (o *CCM_Type) GetCCGR6_CG3() uint32 {
	return (volatile.LoadUint32(&o.CCGR6.Reg) & 0xc0) >> 6
}
func (o *CCM_Type) SetCCGR6_CG4(value uint32) {
	volatile.StoreUint32(&o.CCGR6.Reg, volatile.LoadUint32(&o.CCGR6.Reg)&^(0x300)|value<<8)
}
func (o *CCM_Type) GetCCGR6_CG4() uint32 {
	return (volatile.LoadUint32(&o.CCGR6.Reg) & 0x300) >> 8
}
func (o *CCM_Type) SetCCGR6_CG5(value uint32) {
	volatile.StoreUint32(&o.CCGR6.Reg, volatile.LoadUint32(&o.CCGR6.Reg)&^(0xc00)|value<<10)
}
func (o *CCM_Type) GetCCGR6_CG5() uint32 {
	return (volatile.LoadUint32(&o.CCGR6.Reg) & 0xc00) >> 10
}
func (o *CCM_Type) SetCCGR6_CG6(value uint32) {
	volatile.StoreUint32(&o.CCGR6.Reg, volatile.LoadUint32(&o.CCGR6.Reg)&^(0x3000)|value<<12)
}
func (o *CCM_Type) GetCCGR6_CG6() uint32 {
	return (volatile.LoadUint32(&o.CCGR6.Reg) & 0x3000) >> 12
}
func (o *CCM_Type) SetCCGR6_CG7(value uint32) {
	volatile.StoreUint32(&o.CCGR6.Reg, volatile.LoadUint32(&o.CCGR6.Reg)&^(0xc000)|value<<14)
}
func (o *CCM_Type) GetCCGR6_CG7() uint32 {
	return (volatile.LoadUint32(&o.CCGR6.Reg) & 0xc000) >> 14
}
func (o *CCM_Type) SetCCGR6_CG8(value uint32) {
	volatile.StoreUint32(&o.CCGR6.Reg, volatile.LoadUint32(&o.CCGR6.Reg)&^(0x30000)|value<<16)
}
func (o *CCM_Type) GetCCGR6_CG8() uint32 {
	return (volatile.LoadUint32(&o.CCGR6.Reg) & 0x30000) >> 16
}
func (o *CCM_Type) SetCCGR6_CG9(value uint32) {
	volatile.StoreUint32(&o.CCGR6.Reg, volatile.LoadUint32(&o.CCGR6.Reg)&^(0xc0000)|value<<18)
}
func (o *CCM_Type) GetCCGR6_CG9() uint32 {
	return (volatile.LoadUint32(&o.CCGR6.Reg) & 0xc0000) >> 18
}
func (o *CCM_Type) SetCCGR6_CG10(value uint32) {
	volatile.StoreUint32(&o.CCGR6.Reg, volatile.LoadUint32(&o.CCGR6.Reg)&^(0x300000)|value<<20)
}
func (o *CCM_Type) GetCCGR6_CG10() uint32 {
	return (volatile.LoadUint32(&o.CCGR6.Reg) & 0x300000) >> 20
}
func (o *CCM_Type) SetCCGR6_CG11(value uint32) {
	volatile.StoreUint32(&o.CCGR6.Reg, volatile.LoadUint32(&o.CCGR6.Reg)&^(0xc00000)|value<<22)
}
func (o *CCM_Type) GetCCGR6_CG11() uint32 {
	return (volatile.LoadUint32(&o.CCGR6.Reg) & 0xc00000) >> 22
}
func (o *CCM_Type) SetCCGR6_CG12(value uint32) {
	volatile.StoreUint32(&o.CCGR6.Reg, volatile.LoadUint32(&o.CCGR6.Reg)&^(0x3000000)|value<<24)
}
func (o *CCM_Type) GetCCGR6_CG12() uint32 {
	return (volatile.LoadUint32(&o.CCGR6.Reg) & 0x3000000) >> 24
}
func (o *CCM_Type) SetCCGR6_CG13(value uint32) {
	volatile.StoreUint32(&o.CCGR6.Reg, volatile.LoadUint32(&o.CCGR6.Reg)&^(0xc000000)|value<<26)
}
func (o *CCM_Type) GetCCGR6_CG13() uint32 {
	return (volatile.LoadUint32(&o.CCGR6.Reg) & 0xc000000) >> 26
}
func (o *CCM_Type) SetCCGR6_CG14(value uint32) {
	volatile.StoreUint32(&o.CCGR6.Reg, volatile.LoadUint32(&o.CCGR6.Reg)&^(0x30000000)|value<<28)
}
func (o *CCM_Type) GetCCGR6_CG14() uint32 {
	return (volatile.LoadUint32(&o.CCGR6.Reg) & 0x30000000) >> 28
}
func (o *CCM_Type) SetCCGR6_CG15(value uint32) {
	volatile.StoreUint32(&o.CCGR6.Reg, volatile.LoadUint32(&o.CCGR6.Reg)&^(0xc0000000)|value<<30)
}
func (o *CCM_Type) GetCCGR6_CG15() uint32 {
	return (volatile.LoadUint32(&o.CCGR6.Reg) & 0xc0000000) >> 30
}

// CCM.CMEOR: CCM Module Enable Overide Register
func (o *CCM_Type) SetCMEOR_MOD_EN_OV_GPT(value uint32) {
	volatile.StoreUint32(&o.CMEOR.Reg, volatile.LoadUint32(&o.CMEOR.Reg)&^(0x20)|value<<5)
}
func (o *CCM_Type) GetCMEOR_MOD_EN_OV_GPT() uint32 {
	return (volatile.LoadUint32(&o.CMEOR.Reg) & 0x20) >> 5
}
func (o *CCM_Type) SetCMEOR_MOD_EN_OV_PIT(value uint32) {
	volatile.StoreUint32(&o.CMEOR.Reg, volatile.LoadUint32(&o.CMEOR.Reg)&^(0x40)|value<<6)
}
func (o *CCM_Type) GetCMEOR_MOD_EN_OV_PIT() uint32 {
	return (volatile.LoadUint32(&o.CMEOR.Reg) & 0x40) >> 6
}
func (o *CCM_Type) SetCMEOR_MOD_EN_OV_TRNG(value uint32) {
	volatile.StoreUint32(&o.CMEOR.Reg, volatile.LoadUint32(&o.CMEOR.Reg)&^(0x200)|value<<9)
}
func (o *CCM_Type) GetCMEOR_MOD_EN_OV_TRNG() uint32 {
	return (volatile.LoadUint32(&o.CMEOR.Reg) & 0x200) >> 9
}

// ROMC
type ROMC_Type struct {
	_            [212]byte
	ROMPATCH7D   volatile.Register32 // 0xD4
	ROMPATCH6D   volatile.Register32 // 0xD8
	ROMPATCH5D   volatile.Register32 // 0xDC
	ROMPATCH4D   volatile.Register32 // 0xE0
	ROMPATCH3D   volatile.Register32 // 0xE4
	ROMPATCH2D   volatile.Register32 // 0xE8
	ROMPATCH1D   volatile.Register32 // 0xEC
	ROMPATCH0D   volatile.Register32 // 0xF0
	ROMPATCHCNTL volatile.Register32 // 0xF4
	ROMPATCHENH  volatile.Register32 // 0xF8
	ROMPATCHENL  volatile.Register32 // 0xFC
	ROMPATCH0A   volatile.Register32 // 0x100
	ROMPATCH1A   volatile.Register32 // 0x104
	ROMPATCH2A   volatile.Register32 // 0x108
	ROMPATCH3A   volatile.Register32 // 0x10C
	ROMPATCH4A   volatile.Register32 // 0x110
	ROMPATCH5A   volatile.Register32 // 0x114
	ROMPATCH6A   volatile.Register32 // 0x118
	ROMPATCH7A   volatile.Register32 // 0x11C
	ROMPATCH8A   volatile.Register32 // 0x120
	ROMPATCH9A   volatile.Register32 // 0x124
	ROMPATCH10A  volatile.Register32 // 0x128
	ROMPATCH11A  volatile.Register32 // 0x12C
	ROMPATCH12A  volatile.Register32 // 0x130
	ROMPATCH13A  volatile.Register32 // 0x134
	ROMPATCH14A  volatile.Register32 // 0x138
	ROMPATCH15A  volatile.Register32 // 0x13C
	_            [200]byte
	ROMPATCHSR   volatile.Register32 // 0x208
}

// ROMC.ROMPATCH7D: ROMC Data Registers
func (o *ROMC_Type) SetROMPATCH7D(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH7D.Reg, value)
}
func (o *ROMC_Type) GetROMPATCH7D() uint32 {
	return volatile.LoadUint32(&o.ROMPATCH7D.Reg)
}

// ROMC.ROMPATCH6D: ROMC Data Registers
func (o *ROMC_Type) SetROMPATCH6D(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH6D.Reg, value)
}
func (o *ROMC_Type) GetROMPATCH6D() uint32 {
	return volatile.LoadUint32(&o.ROMPATCH6D.Reg)
}

// ROMC.ROMPATCH5D: ROMC Data Registers
func (o *ROMC_Type) SetROMPATCH5D(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH5D.Reg, value)
}
func (o *ROMC_Type) GetROMPATCH5D() uint32 {
	return volatile.LoadUint32(&o.ROMPATCH5D.Reg)
}

// ROMC.ROMPATCH4D: ROMC Data Registers
func (o *ROMC_Type) SetROMPATCH4D(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH4D.Reg, value)
}
func (o *ROMC_Type) GetROMPATCH4D() uint32 {
	return volatile.LoadUint32(&o.ROMPATCH4D.Reg)
}

// ROMC.ROMPATCH3D: ROMC Data Registers
func (o *ROMC_Type) SetROMPATCH3D(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH3D.Reg, value)
}
func (o *ROMC_Type) GetROMPATCH3D() uint32 {
	return volatile.LoadUint32(&o.ROMPATCH3D.Reg)
}

// ROMC.ROMPATCH2D: ROMC Data Registers
func (o *ROMC_Type) SetROMPATCH2D(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH2D.Reg, value)
}
func (o *ROMC_Type) GetROMPATCH2D() uint32 {
	return volatile.LoadUint32(&o.ROMPATCH2D.Reg)
}

// ROMC.ROMPATCH1D: ROMC Data Registers
func (o *ROMC_Type) SetROMPATCH1D(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH1D.Reg, value)
}
func (o *ROMC_Type) GetROMPATCH1D() uint32 {
	return volatile.LoadUint32(&o.ROMPATCH1D.Reg)
}

// ROMC.ROMPATCH0D: ROMC Data Registers
func (o *ROMC_Type) SetROMPATCH0D(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH0D.Reg, value)
}
func (o *ROMC_Type) GetROMPATCH0D() uint32 {
	return volatile.LoadUint32(&o.ROMPATCH0D.Reg)
}

// ROMC.ROMPATCHCNTL: ROMC Control Register
func (o *ROMC_Type) SetROMPATCHCNTL_DATAFIX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCHCNTL.Reg, volatile.LoadUint32(&o.ROMPATCHCNTL.Reg)&^(0xff)|value)
}
func (o *ROMC_Type) GetROMPATCHCNTL_DATAFIX() uint32 {
	return volatile.LoadUint32(&o.ROMPATCHCNTL.Reg) & 0xff
}
func (o *ROMC_Type) SetROMPATCHCNTL_DIS(value uint32) {
	volatile.StoreUint32(&o.ROMPATCHCNTL.Reg, volatile.LoadUint32(&o.ROMPATCHCNTL.Reg)&^(0x20000000)|value<<29)
}
func (o *ROMC_Type) GetROMPATCHCNTL_DIS() uint32 {
	return (volatile.LoadUint32(&o.ROMPATCHCNTL.Reg) & 0x20000000) >> 29
}

// ROMC.ROMPATCHENL: ROMC Enable Register Low
func (o *ROMC_Type) SetROMPATCHENL_ENABLE(value uint32) {
	volatile.StoreUint32(&o.ROMPATCHENL.Reg, volatile.LoadUint32(&o.ROMPATCHENL.Reg)&^(0xffff)|value)
}
func (o *ROMC_Type) GetROMPATCHENL_ENABLE() uint32 {
	return volatile.LoadUint32(&o.ROMPATCHENL.Reg) & 0xffff
}

// ROMC.ROMPATCH0A: ROMC Address Registers
func (o *ROMC_Type) SetROMPATCH0A_THUMBX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH0A.Reg, volatile.LoadUint32(&o.ROMPATCH0A.Reg)&^(0x1)|value)
}
func (o *ROMC_Type) GetROMPATCH0A_THUMBX() uint32 {
	return volatile.LoadUint32(&o.ROMPATCH0A.Reg) & 0x1
}
func (o *ROMC_Type) SetROMPATCH0A_ADDRX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH0A.Reg, volatile.LoadUint32(&o.ROMPATCH0A.Reg)&^(0x7ffffe)|value<<1)
}
func (o *ROMC_Type) GetROMPATCH0A_ADDRX() uint32 {
	return (volatile.LoadUint32(&o.ROMPATCH0A.Reg) & 0x7ffffe) >> 1
}

// ROMC.ROMPATCH1A: ROMC Address Registers
func (o *ROMC_Type) SetROMPATCH1A_THUMBX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH1A.Reg, volatile.LoadUint32(&o.ROMPATCH1A.Reg)&^(0x1)|value)
}
func (o *ROMC_Type) GetROMPATCH1A_THUMBX() uint32 {
	return volatile.LoadUint32(&o.ROMPATCH1A.Reg) & 0x1
}
func (o *ROMC_Type) SetROMPATCH1A_ADDRX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH1A.Reg, volatile.LoadUint32(&o.ROMPATCH1A.Reg)&^(0x7ffffe)|value<<1)
}
func (o *ROMC_Type) GetROMPATCH1A_ADDRX() uint32 {
	return (volatile.LoadUint32(&o.ROMPATCH1A.Reg) & 0x7ffffe) >> 1
}

// ROMC.ROMPATCH2A: ROMC Address Registers
func (o *ROMC_Type) SetROMPATCH2A_THUMBX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH2A.Reg, volatile.LoadUint32(&o.ROMPATCH2A.Reg)&^(0x1)|value)
}
func (o *ROMC_Type) GetROMPATCH2A_THUMBX() uint32 {
	return volatile.LoadUint32(&o.ROMPATCH2A.Reg) & 0x1
}
func (o *ROMC_Type) SetROMPATCH2A_ADDRX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH2A.Reg, volatile.LoadUint32(&o.ROMPATCH2A.Reg)&^(0x7ffffe)|value<<1)
}
func (o *ROMC_Type) GetROMPATCH2A_ADDRX() uint32 {
	return (volatile.LoadUint32(&o.ROMPATCH2A.Reg) & 0x7ffffe) >> 1
}

// ROMC.ROMPATCH3A: ROMC Address Registers
func (o *ROMC_Type) SetROMPATCH3A_THUMBX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH3A.Reg, volatile.LoadUint32(&o.ROMPATCH3A.Reg)&^(0x1)|value)
}
func (o *ROMC_Type) GetROMPATCH3A_THUMBX() uint32 {
	return volatile.LoadUint32(&o.ROMPATCH3A.Reg) & 0x1
}
func (o *ROMC_Type) SetROMPATCH3A_ADDRX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH3A.Reg, volatile.LoadUint32(&o.ROMPATCH3A.Reg)&^(0x7ffffe)|value<<1)
}
func (o *ROMC_Type) GetROMPATCH3A_ADDRX() uint32 {
	return (volatile.LoadUint32(&o.ROMPATCH3A.Reg) & 0x7ffffe) >> 1
}

// ROMC.ROMPATCH4A: ROMC Address Registers
func (o *ROMC_Type) SetROMPATCH4A_THUMBX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH4A.Reg, volatile.LoadUint32(&o.ROMPATCH4A.Reg)&^(0x1)|value)
}
func (o *ROMC_Type) GetROMPATCH4A_THUMBX() uint32 {
	return volatile.LoadUint32(&o.ROMPATCH4A.Reg) & 0x1
}
func (o *ROMC_Type) SetROMPATCH4A_ADDRX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH4A.Reg, volatile.LoadUint32(&o.ROMPATCH4A.Reg)&^(0x7ffffe)|value<<1)
}
func (o *ROMC_Type) GetROMPATCH4A_ADDRX() uint32 {
	return (volatile.LoadUint32(&o.ROMPATCH4A.Reg) & 0x7ffffe) >> 1
}

// ROMC.ROMPATCH5A: ROMC Address Registers
func (o *ROMC_Type) SetROMPATCH5A_THUMBX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH5A.Reg, volatile.LoadUint32(&o.ROMPATCH5A.Reg)&^(0x1)|value)
}
func (o *ROMC_Type) GetROMPATCH5A_THUMBX() uint32 {
	return volatile.LoadUint32(&o.ROMPATCH5A.Reg) & 0x1
}
func (o *ROMC_Type) SetROMPATCH5A_ADDRX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH5A.Reg, volatile.LoadUint32(&o.ROMPATCH5A.Reg)&^(0x7ffffe)|value<<1)
}
func (o *ROMC_Type) GetROMPATCH5A_ADDRX() uint32 {
	return (volatile.LoadUint32(&o.ROMPATCH5A.Reg) & 0x7ffffe) >> 1
}

// ROMC.ROMPATCH6A: ROMC Address Registers
func (o *ROMC_Type) SetROMPATCH6A_THUMBX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH6A.Reg, volatile.LoadUint32(&o.ROMPATCH6A.Reg)&^(0x1)|value)
}
func (o *ROMC_Type) GetROMPATCH6A_THUMBX() uint32 {
	return volatile.LoadUint32(&o.ROMPATCH6A.Reg) & 0x1
}
func (o *ROMC_Type) SetROMPATCH6A_ADDRX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH6A.Reg, volatile.LoadUint32(&o.ROMPATCH6A.Reg)&^(0x7ffffe)|value<<1)
}
func (o *ROMC_Type) GetROMPATCH6A_ADDRX() uint32 {
	return (volatile.LoadUint32(&o.ROMPATCH6A.Reg) & 0x7ffffe) >> 1
}

// ROMC.ROMPATCH7A: ROMC Address Registers
func (o *ROMC_Type) SetROMPATCH7A_THUMBX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH7A.Reg, volatile.LoadUint32(&o.ROMPATCH7A.Reg)&^(0x1)|value)
}
func (o *ROMC_Type) GetROMPATCH7A_THUMBX() uint32 {
	return volatile.LoadUint32(&o.ROMPATCH7A.Reg) & 0x1
}
func (o *ROMC_Type) SetROMPATCH7A_ADDRX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH7A.Reg, volatile.LoadUint32(&o.ROMPATCH7A.Reg)&^(0x7ffffe)|value<<1)
}
func (o *ROMC_Type) GetROMPATCH7A_ADDRX() uint32 {
	return (volatile.LoadUint32(&o.ROMPATCH7A.Reg) & 0x7ffffe) >> 1
}

// ROMC.ROMPATCH8A: ROMC Address Registers
func (o *ROMC_Type) SetROMPATCH8A_THUMBX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH8A.Reg, volatile.LoadUint32(&o.ROMPATCH8A.Reg)&^(0x1)|value)
}
func (o *ROMC_Type) GetROMPATCH8A_THUMBX() uint32 {
	return volatile.LoadUint32(&o.ROMPATCH8A.Reg) & 0x1
}
func (o *ROMC_Type) SetROMPATCH8A_ADDRX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH8A.Reg, volatile.LoadUint32(&o.ROMPATCH8A.Reg)&^(0x7ffffe)|value<<1)
}
func (o *ROMC_Type) GetROMPATCH8A_ADDRX() uint32 {
	return (volatile.LoadUint32(&o.ROMPATCH8A.Reg) & 0x7ffffe) >> 1
}

// ROMC.ROMPATCH9A: ROMC Address Registers
func (o *ROMC_Type) SetROMPATCH9A_THUMBX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH9A.Reg, volatile.LoadUint32(&o.ROMPATCH9A.Reg)&^(0x1)|value)
}
func (o *ROMC_Type) GetROMPATCH9A_THUMBX() uint32 {
	return volatile.LoadUint32(&o.ROMPATCH9A.Reg) & 0x1
}
func (o *ROMC_Type) SetROMPATCH9A_ADDRX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH9A.Reg, volatile.LoadUint32(&o.ROMPATCH9A.Reg)&^(0x7ffffe)|value<<1)
}
func (o *ROMC_Type) GetROMPATCH9A_ADDRX() uint32 {
	return (volatile.LoadUint32(&o.ROMPATCH9A.Reg) & 0x7ffffe) >> 1
}

// ROMC.ROMPATCH10A: ROMC Address Registers
func (o *ROMC_Type) SetROMPATCH10A_THUMBX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH10A.Reg, volatile.LoadUint32(&o.ROMPATCH10A.Reg)&^(0x1)|value)
}
func (o *ROMC_Type) GetROMPATCH10A_THUMBX() uint32 {
	return volatile.LoadUint32(&o.ROMPATCH10A.Reg) & 0x1
}
func (o *ROMC_Type) SetROMPATCH10A_ADDRX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH10A.Reg, volatile.LoadUint32(&o.ROMPATCH10A.Reg)&^(0x7ffffe)|value<<1)
}
func (o *ROMC_Type) GetROMPATCH10A_ADDRX() uint32 {
	return (volatile.LoadUint32(&o.ROMPATCH10A.Reg) & 0x7ffffe) >> 1
}

// ROMC.ROMPATCH11A: ROMC Address Registers
func (o *ROMC_Type) SetROMPATCH11A_THUMBX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH11A.Reg, volatile.LoadUint32(&o.ROMPATCH11A.Reg)&^(0x1)|value)
}
func (o *ROMC_Type) GetROMPATCH11A_THUMBX() uint32 {
	return volatile.LoadUint32(&o.ROMPATCH11A.Reg) & 0x1
}
func (o *ROMC_Type) SetROMPATCH11A_ADDRX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH11A.Reg, volatile.LoadUint32(&o.ROMPATCH11A.Reg)&^(0x7ffffe)|value<<1)
}
func (o *ROMC_Type) GetROMPATCH11A_ADDRX() uint32 {
	return (volatile.LoadUint32(&o.ROMPATCH11A.Reg) & 0x7ffffe) >> 1
}

// ROMC.ROMPATCH12A: ROMC Address Registers
func (o *ROMC_Type) SetROMPATCH12A_THUMBX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH12A.Reg, volatile.LoadUint32(&o.ROMPATCH12A.Reg)&^(0x1)|value)
}
func (o *ROMC_Type) GetROMPATCH12A_THUMBX() uint32 {
	return volatile.LoadUint32(&o.ROMPATCH12A.Reg) & 0x1
}
func (o *ROMC_Type) SetROMPATCH12A_ADDRX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH12A.Reg, volatile.LoadUint32(&o.ROMPATCH12A.Reg)&^(0x7ffffe)|value<<1)
}
func (o *ROMC_Type) GetROMPATCH12A_ADDRX() uint32 {
	return (volatile.LoadUint32(&o.ROMPATCH12A.Reg) & 0x7ffffe) >> 1
}

// ROMC.ROMPATCH13A: ROMC Address Registers
func (o *ROMC_Type) SetROMPATCH13A_THUMBX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH13A.Reg, volatile.LoadUint32(&o.ROMPATCH13A.Reg)&^(0x1)|value)
}
func (o *ROMC_Type) GetROMPATCH13A_THUMBX() uint32 {
	return volatile.LoadUint32(&o.ROMPATCH13A.Reg) & 0x1
}
func (o *ROMC_Type) SetROMPATCH13A_ADDRX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH13A.Reg, volatile.LoadUint32(&o.ROMPATCH13A.Reg)&^(0x7ffffe)|value<<1)
}
func (o *ROMC_Type) GetROMPATCH13A_ADDRX() uint32 {
	return (volatile.LoadUint32(&o.ROMPATCH13A.Reg) & 0x7ffffe) >> 1
}

// ROMC.ROMPATCH14A: ROMC Address Registers
func (o *ROMC_Type) SetROMPATCH14A_THUMBX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH14A.Reg, volatile.LoadUint32(&o.ROMPATCH14A.Reg)&^(0x1)|value)
}
func (o *ROMC_Type) GetROMPATCH14A_THUMBX() uint32 {
	return volatile.LoadUint32(&o.ROMPATCH14A.Reg) & 0x1
}
func (o *ROMC_Type) SetROMPATCH14A_ADDRX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH14A.Reg, volatile.LoadUint32(&o.ROMPATCH14A.Reg)&^(0x7ffffe)|value<<1)
}
func (o *ROMC_Type) GetROMPATCH14A_ADDRX() uint32 {
	return (volatile.LoadUint32(&o.ROMPATCH14A.Reg) & 0x7ffffe) >> 1
}

// ROMC.ROMPATCH15A: ROMC Address Registers
func (o *ROMC_Type) SetROMPATCH15A_THUMBX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH15A.Reg, volatile.LoadUint32(&o.ROMPATCH15A.Reg)&^(0x1)|value)
}
func (o *ROMC_Type) GetROMPATCH15A_THUMBX() uint32 {
	return volatile.LoadUint32(&o.ROMPATCH15A.Reg) & 0x1
}
func (o *ROMC_Type) SetROMPATCH15A_ADDRX(value uint32) {
	volatile.StoreUint32(&o.ROMPATCH15A.Reg, volatile.LoadUint32(&o.ROMPATCH15A.Reg)&^(0x7ffffe)|value<<1)
}
func (o *ROMC_Type) GetROMPATCH15A_ADDRX() uint32 {
	return (volatile.LoadUint32(&o.ROMPATCH15A.Reg) & 0x7ffffe) >> 1
}

// ROMC.ROMPATCHSR: ROMC Status Register
func (o *ROMC_Type) SetROMPATCHSR_SOURCE(value uint32) {
	volatile.StoreUint32(&o.ROMPATCHSR.Reg, volatile.LoadUint32(&o.ROMPATCHSR.Reg)&^(0x3f)|value)
}
func (o *ROMC_Type) GetROMPATCHSR_SOURCE() uint32 {
	return volatile.LoadUint32(&o.ROMPATCHSR.Reg) & 0x3f
}
func (o *ROMC_Type) SetROMPATCHSR_SW(value uint32) {
	volatile.StoreUint32(&o.ROMPATCHSR.Reg, volatile.LoadUint32(&o.ROMPATCHSR.Reg)&^(0x20000)|value<<17)
}
func (o *ROMC_Type) GetROMPATCHSR_SW() uint32 {
	return (volatile.LoadUint32(&o.ROMPATCHSR.Reg) & 0x20000) >> 17
}

// LPUART
type LPUART_Type struct {
	VERID  volatile.Register32 // 0x0
	PARAM  volatile.Register32 // 0x4
	GLOBAL volatile.Register32 // 0x8
	PINCFG volatile.Register32 // 0xC
	BAUD   volatile.Register32 // 0x10
	STAT   volatile.Register32 // 0x14
	CTRL   volatile.Register32 // 0x18
	DATA   volatile.Register32 // 0x1C
	MATCH  volatile.Register32 // 0x20
	MODIR  volatile.Register32 // 0x24
	FIFO   volatile.Register32 // 0x28
	WATER  volatile.Register32 // 0x2C
}

// LPUART.VERID: Version ID Register
func (o *LPUART_Type) SetVERID_FEATURE(value uint32) {
	volatile.StoreUint32(&o.VERID.Reg, volatile.LoadUint32(&o.VERID.Reg)&^(0xffff)|value)
}
func (o *LPUART_Type) GetVERID_FEATURE() uint32 {
	return volatile.LoadUint32(&o.VERID.Reg) & 0xffff
}
func (o *LPUART_Type) SetVERID_MINOR(value uint32) {
	volatile.StoreUint32(&o.VERID.Reg, volatile.LoadUint32(&o.VERID.Reg)&^(0xff0000)|value<<16)
}
func (o *LPUART_Type) GetVERID_MINOR() uint32 {
	return (volatile.LoadUint32(&o.VERID.Reg) & 0xff0000) >> 16
}
func (o *LPUART_Type) SetVERID_MAJOR(value uint32) {
	volatile.StoreUint32(&o.VERID.Reg, volatile.LoadUint32(&o.VERID.Reg)&^(0xff000000)|value<<24)
}
func (o *LPUART_Type) GetVERID_MAJOR() uint32 {
	return (volatile.LoadUint32(&o.VERID.Reg) & 0xff000000) >> 24
}

// LPUART.PARAM: Parameter Register
func (o *LPUART_Type) SetPARAM_TXFIFO(value uint32) {
	volatile.StoreUint32(&o.PARAM.Reg, volatile.LoadUint32(&o.PARAM.Reg)&^(0xff)|value)
}
func (o *LPUART_Type) GetPARAM_TXFIFO() uint32 {
	return volatile.LoadUint32(&o.PARAM.Reg) & 0xff
}
func (o *LPUART_Type) SetPARAM_RXFIFO(value uint32) {
	volatile.StoreUint32(&o.PARAM.Reg, volatile.LoadUint32(&o.PARAM.Reg)&^(0xff00)|value<<8)
}
func (o *LPUART_Type) GetPARAM_RXFIFO() uint32 {
	return (volatile.LoadUint32(&o.PARAM.Reg) & 0xff00) >> 8
}

// LPUART.GLOBAL: LPUART Global Register
func (o *LPUART_Type) SetGLOBAL_RST(value uint32) {
	volatile.StoreUint32(&o.GLOBAL.Reg, volatile.LoadUint32(&o.GLOBAL.Reg)&^(0x2)|value<<1)
}
func (o *LPUART_Type) GetGLOBAL_RST() uint32 {
	return (volatile.LoadUint32(&o.GLOBAL.Reg) & 0x2) >> 1
}

// LPUART.PINCFG: LPUART Pin Configuration Register
func (o *LPUART_Type) SetPINCFG_TRGSEL(value uint32) {
	volatile.StoreUint32(&o.PINCFG.Reg, volatile.LoadUint32(&o.PINCFG.Reg)&^(0x3)|value)
}
func (o *LPUART_Type) GetPINCFG_TRGSEL() uint32 {
	return volatile.LoadUint32(&o.PINCFG.Reg) & 0x3
}

// LPUART.BAUD: LPUART Baud Rate Register
func (o *LPUART_Type) SetBAUD_SBR(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0x1fff)|value)
}
func (o *LPUART_Type) GetBAUD_SBR() uint32 {
	return volatile.LoadUint32(&o.BAUD.Reg) & 0x1fff
}
func (o *LPUART_Type) SetBAUD_SBNS(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0x2000)|value<<13)
}
func (o *LPUART_Type) GetBAUD_SBNS() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0x2000) >> 13
}
func (o *LPUART_Type) SetBAUD_RXEDGIE(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0x4000)|value<<14)
}
func (o *LPUART_Type) GetBAUD_RXEDGIE() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0x4000) >> 14
}
func (o *LPUART_Type) SetBAUD_LBKDIE(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0x8000)|value<<15)
}
func (o *LPUART_Type) GetBAUD_LBKDIE() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0x8000) >> 15
}
func (o *LPUART_Type) SetBAUD_RESYNCDIS(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0x10000)|value<<16)
}
func (o *LPUART_Type) GetBAUD_RESYNCDIS() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0x10000) >> 16
}
func (o *LPUART_Type) SetBAUD_BOTHEDGE(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0x20000)|value<<17)
}
func (o *LPUART_Type) GetBAUD_BOTHEDGE() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0x20000) >> 17
}
func (o *LPUART_Type) SetBAUD_MATCFG(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0xc0000)|value<<18)
}
func (o *LPUART_Type) GetBAUD_MATCFG() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0xc0000) >> 18
}
func (o *LPUART_Type) SetBAUD_RIDMAE(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0x100000)|value<<20)
}
func (o *LPUART_Type) GetBAUD_RIDMAE() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0x100000) >> 20
}
func (o *LPUART_Type) SetBAUD_RDMAE(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0x200000)|value<<21)
}
func (o *LPUART_Type) GetBAUD_RDMAE() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0x200000) >> 21
}
func (o *LPUART_Type) SetBAUD_TDMAE(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0x800000)|value<<23)
}
func (o *LPUART_Type) GetBAUD_TDMAE() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0x800000) >> 23
}
func (o *LPUART_Type) SetBAUD_OSR(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0x1f000000)|value<<24)
}
func (o *LPUART_Type) GetBAUD_OSR() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0x1f000000) >> 24
}
func (o *LPUART_Type) SetBAUD_M10(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0x20000000)|value<<29)
}
func (o *LPUART_Type) GetBAUD_M10() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0x20000000) >> 29
}
func (o *LPUART_Type) SetBAUD_MAEN2(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0x40000000)|value<<30)
}
func (o *LPUART_Type) GetBAUD_MAEN2() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0x40000000) >> 30
}
func (o *LPUART_Type) SetBAUD_MAEN1(value uint32) {
	volatile.StoreUint32(&o.BAUD.Reg, volatile.LoadUint32(&o.BAUD.Reg)&^(0x80000000)|value<<31)
}
func (o *LPUART_Type) GetBAUD_MAEN1() uint32 {
	return (volatile.LoadUint32(&o.BAUD.Reg) & 0x80000000) >> 31
}

// LPUART.STAT: LPUART Status Register
func (o *LPUART_Type) SetSTAT_MA2F(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x4000)|value<<14)
}
func (o *LPUART_Type) GetSTAT_MA2F() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x4000) >> 14
}
func (o *LPUART_Type) SetSTAT_MA1F(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x8000)|value<<15)
}
func (o *LPUART_Type) GetSTAT_MA1F() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x8000) >> 15
}
func (o *LPUART_Type) SetSTAT_PF(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x10000)|value<<16)
}
func (o *LPUART_Type) GetSTAT_PF() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x10000) >> 16
}
func (o *LPUART_Type) SetSTAT_FE(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x20000)|value<<17)
}
func (o *LPUART_Type) GetSTAT_FE() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x20000) >> 17
}
func (o *LPUART_Type) SetSTAT_NF(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x40000)|value<<18)
}
func (o *LPUART_Type) GetSTAT_NF() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x40000) >> 18
}
func (o *LPUART_Type) SetSTAT_OR(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x80000)|value<<19)
}
func (o *LPUART_Type) GetSTAT_OR() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x80000) >> 19
}
func (o *LPUART_Type) SetSTAT_IDLE(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x100000)|value<<20)
}
func (o *LPUART_Type) GetSTAT_IDLE() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x100000) >> 20
}
func (o *LPUART_Type) SetSTAT_RDRF(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x200000)|value<<21)
}
func (o *LPUART_Type) GetSTAT_RDRF() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x200000) >> 21
}
func (o *LPUART_Type) SetSTAT_TC(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x400000)|value<<22)
}
func (o *LPUART_Type) GetSTAT_TC() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x400000) >> 22
}
func (o *LPUART_Type) SetSTAT_TDRE(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x800000)|value<<23)
}
func (o *LPUART_Type) GetSTAT_TDRE() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x800000) >> 23
}
func (o *LPUART_Type) SetSTAT_RAF(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x1000000)|value<<24)
}
func (o *LPUART_Type) GetSTAT_RAF() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x1000000) >> 24
}
func (o *LPUART_Type) SetSTAT_LBKDE(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x2000000)|value<<25)
}
func (o *LPUART_Type) GetSTAT_LBKDE() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x2000000) >> 25
}
func (o *LPUART_Type) SetSTAT_BRK13(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x4000000)|value<<26)
}
func (o *LPUART_Type) GetSTAT_BRK13() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x4000000) >> 26
}
func (o *LPUART_Type) SetSTAT_RWUID(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x8000000)|value<<27)
}
func (o *LPUART_Type) GetSTAT_RWUID() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x8000000) >> 27
}
func (o *LPUART_Type) SetSTAT_RXINV(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x10000000)|value<<28)
}
func (o *LPUART_Type) GetSTAT_RXINV() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x10000000) >> 28
}
func (o *LPUART_Type) SetSTAT_MSBF(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x20000000)|value<<29)
}
func (o *LPUART_Type) GetSTAT_MSBF() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x20000000) >> 29
}
func (o *LPUART_Type) SetSTAT_RXEDGIF(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x40000000)|value<<30)
}
func (o *LPUART_Type) GetSTAT_RXEDGIF() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x40000000) >> 30
}
func (o *LPUART_Type) SetSTAT_LBKDIF(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x80000000)|value<<31)
}
func (o *LPUART_Type) GetSTAT_LBKDIF() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x80000000) >> 31
}

// LPUART.CTRL: LPUART Control Register
func (o *LPUART_Type) SetCTRL_PT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *LPUART_Type) GetCTRL_PT() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *LPUART_Type) SetCTRL_PE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *LPUART_Type) GetCTRL_PE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *LPUART_Type) SetCTRL_ILT(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *LPUART_Type) GetCTRL_ILT() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}
func (o *LPUART_Type) SetCTRL_WAKE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8)|value<<3)
}
func (o *LPUART_Type) GetCTRL_WAKE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8) >> 3
}
func (o *LPUART_Type) SetCTRL_M(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10)|value<<4)
}
func (o *LPUART_Type) GetCTRL_M() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10) >> 4
}
func (o *LPUART_Type) SetCTRL_RSRC(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20)|value<<5)
}
func (o *LPUART_Type) GetCTRL_RSRC() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20) >> 5
}
func (o *LPUART_Type) SetCTRL_DOZEEN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40)|value<<6)
}
func (o *LPUART_Type) GetCTRL_DOZEEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40) >> 6
}
func (o *LPUART_Type) SetCTRL_LOOPS(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80)|value<<7)
}
func (o *LPUART_Type) GetCTRL_LOOPS() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80) >> 7
}
func (o *LPUART_Type) SetCTRL_IDLECFG(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x700)|value<<8)
}
func (o *LPUART_Type) GetCTRL_IDLECFG() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x700) >> 8
}
func (o *LPUART_Type) SetCTRL_M7(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x800)|value<<11)
}
func (o *LPUART_Type) GetCTRL_M7() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x800) >> 11
}
func (o *LPUART_Type) SetCTRL_MA2IE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4000)|value<<14)
}
func (o *LPUART_Type) GetCTRL_MA2IE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4000) >> 14
}
func (o *LPUART_Type) SetCTRL_MA1IE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8000)|value<<15)
}
func (o *LPUART_Type) GetCTRL_MA1IE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8000) >> 15
}
func (o *LPUART_Type) SetCTRL_SBK(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10000)|value<<16)
}
func (o *LPUART_Type) GetCTRL_SBK() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10000) >> 16
}
func (o *LPUART_Type) SetCTRL_RWU(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20000)|value<<17)
}
func (o *LPUART_Type) GetCTRL_RWU() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20000) >> 17
}
func (o *LPUART_Type) SetCTRL_RE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40000)|value<<18)
}
func (o *LPUART_Type) GetCTRL_RE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40000) >> 18
}
func (o *LPUART_Type) SetCTRL_TE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80000)|value<<19)
}
func (o *LPUART_Type) GetCTRL_TE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80000) >> 19
}
func (o *LPUART_Type) SetCTRL_ILIE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x100000)|value<<20)
}
func (o *LPUART_Type) GetCTRL_ILIE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x100000) >> 20
}
func (o *LPUART_Type) SetCTRL_RIE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x200000)|value<<21)
}
func (o *LPUART_Type) GetCTRL_RIE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x200000) >> 21
}
func (o *LPUART_Type) SetCTRL_TCIE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x400000)|value<<22)
}
func (o *LPUART_Type) GetCTRL_TCIE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x400000) >> 22
}
func (o *LPUART_Type) SetCTRL_TIE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x800000)|value<<23)
}
func (o *LPUART_Type) GetCTRL_TIE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x800000) >> 23
}
func (o *LPUART_Type) SetCTRL_PEIE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1000000)|value<<24)
}
func (o *LPUART_Type) GetCTRL_PEIE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x1000000) >> 24
}
func (o *LPUART_Type) SetCTRL_FEIE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2000000)|value<<25)
}
func (o *LPUART_Type) GetCTRL_FEIE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2000000) >> 25
}
func (o *LPUART_Type) SetCTRL_NEIE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4000000)|value<<26)
}
func (o *LPUART_Type) GetCTRL_NEIE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4000000) >> 26
}
func (o *LPUART_Type) SetCTRL_ORIE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x8000000)|value<<27)
}
func (o *LPUART_Type) GetCTRL_ORIE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x8000000) >> 27
}
func (o *LPUART_Type) SetCTRL_TXINV(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x10000000)|value<<28)
}
func (o *LPUART_Type) GetCTRL_TXINV() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x10000000) >> 28
}
func (o *LPUART_Type) SetCTRL_TXDIR(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x20000000)|value<<29)
}
func (o *LPUART_Type) GetCTRL_TXDIR() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x20000000) >> 29
}
func (o *LPUART_Type) SetCTRL_R9T8(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *LPUART_Type) GetCTRL_R9T8() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40000000) >> 30
}
func (o *LPUART_Type) SetCTRL_R8T9(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *LPUART_Type) GetCTRL_R8T9() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80000000) >> 31
}

// LPUART.DATA: LPUART Data Register
func (o *LPUART_Type) SetDATA_R0T0(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x1)|value)
}
func (o *LPUART_Type) GetDATA_R0T0() uint32 {
	return volatile.LoadUint32(&o.DATA.Reg) & 0x1
}
func (o *LPUART_Type) SetDATA_R1T1(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x2)|value<<1)
}
func (o *LPUART_Type) GetDATA_R1T1() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x2) >> 1
}
func (o *LPUART_Type) SetDATA_R2T2(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x4)|value<<2)
}
func (o *LPUART_Type) GetDATA_R2T2() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x4) >> 2
}
func (o *LPUART_Type) SetDATA_R3T3(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x8)|value<<3)
}
func (o *LPUART_Type) GetDATA_R3T3() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x8) >> 3
}
func (o *LPUART_Type) SetDATA_R4T4(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x10)|value<<4)
}
func (o *LPUART_Type) GetDATA_R4T4() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x10) >> 4
}
func (o *LPUART_Type) SetDATA_R5T5(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x20)|value<<5)
}
func (o *LPUART_Type) GetDATA_R5T5() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x20) >> 5
}
func (o *LPUART_Type) SetDATA_R6T6(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x40)|value<<6)
}
func (o *LPUART_Type) GetDATA_R6T6() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x40) >> 6
}
func (o *LPUART_Type) SetDATA_R7T7(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x80)|value<<7)
}
func (o *LPUART_Type) GetDATA_R7T7() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x80) >> 7
}
func (o *LPUART_Type) SetDATA_R8T8(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x100)|value<<8)
}
func (o *LPUART_Type) GetDATA_R8T8() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x100) >> 8
}
func (o *LPUART_Type) SetDATA_R9T9(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x200)|value<<9)
}
func (o *LPUART_Type) GetDATA_R9T9() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x200) >> 9
}
func (o *LPUART_Type) SetDATA_IDLINE(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x800)|value<<11)
}
func (o *LPUART_Type) GetDATA_IDLINE() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x800) >> 11
}
func (o *LPUART_Type) SetDATA_RXEMPT(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x1000)|value<<12)
}
func (o *LPUART_Type) GetDATA_RXEMPT() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x1000) >> 12
}
func (o *LPUART_Type) SetDATA_FRETSC(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x2000)|value<<13)
}
func (o *LPUART_Type) GetDATA_FRETSC() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x2000) >> 13
}
func (o *LPUART_Type) SetDATA_PARITYE(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x4000)|value<<14)
}
func (o *LPUART_Type) GetDATA_PARITYE() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x4000) >> 14
}
func (o *LPUART_Type) SetDATA_NOISY(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x8000)|value<<15)
}
func (o *LPUART_Type) GetDATA_NOISY() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x8000) >> 15
}

// LPUART.MATCH: LPUART Match Address Register
func (o *LPUART_Type) SetMATCH_MA1(value uint32) {
	volatile.StoreUint32(&o.MATCH.Reg, volatile.LoadUint32(&o.MATCH.Reg)&^(0x3ff)|value)
}
func (o *LPUART_Type) GetMATCH_MA1() uint32 {
	return volatile.LoadUint32(&o.MATCH.Reg) & 0x3ff
}
func (o *LPUART_Type) SetMATCH_MA2(value uint32) {
	volatile.StoreUint32(&o.MATCH.Reg, volatile.LoadUint32(&o.MATCH.Reg)&^(0x3ff0000)|value<<16)
}
func (o *LPUART_Type) GetMATCH_MA2() uint32 {
	return (volatile.LoadUint32(&o.MATCH.Reg) & 0x3ff0000) >> 16
}

// LPUART.MODIR: LPUART Modem IrDA Register
func (o *LPUART_Type) SetMODIR_TXCTSE(value uint32) {
	volatile.StoreUint32(&o.MODIR.Reg, volatile.LoadUint32(&o.MODIR.Reg)&^(0x1)|value)
}
func (o *LPUART_Type) GetMODIR_TXCTSE() uint32 {
	return volatile.LoadUint32(&o.MODIR.Reg) & 0x1
}
func (o *LPUART_Type) SetMODIR_TXRTSE(value uint32) {
	volatile.StoreUint32(&o.MODIR.Reg, volatile.LoadUint32(&o.MODIR.Reg)&^(0x2)|value<<1)
}
func (o *LPUART_Type) GetMODIR_TXRTSE() uint32 {
	return (volatile.LoadUint32(&o.MODIR.Reg) & 0x2) >> 1
}
func (o *LPUART_Type) SetMODIR_TXRTSPOL(value uint32) {
	volatile.StoreUint32(&o.MODIR.Reg, volatile.LoadUint32(&o.MODIR.Reg)&^(0x4)|value<<2)
}
func (o *LPUART_Type) GetMODIR_TXRTSPOL() uint32 {
	return (volatile.LoadUint32(&o.MODIR.Reg) & 0x4) >> 2
}
func (o *LPUART_Type) SetMODIR_RXRTSE(value uint32) {
	volatile.StoreUint32(&o.MODIR.Reg, volatile.LoadUint32(&o.MODIR.Reg)&^(0x8)|value<<3)
}
func (o *LPUART_Type) GetMODIR_RXRTSE() uint32 {
	return (volatile.LoadUint32(&o.MODIR.Reg) & 0x8) >> 3
}
func (o *LPUART_Type) SetMODIR_TXCTSC(value uint32) {
	volatile.StoreUint32(&o.MODIR.Reg, volatile.LoadUint32(&o.MODIR.Reg)&^(0x10)|value<<4)
}
func (o *LPUART_Type) GetMODIR_TXCTSC() uint32 {
	return (volatile.LoadUint32(&o.MODIR.Reg) & 0x10) >> 4
}
func (o *LPUART_Type) SetMODIR_TXCTSSRC(value uint32) {
	volatile.StoreUint32(&o.MODIR.Reg, volatile.LoadUint32(&o.MODIR.Reg)&^(0x20)|value<<5)
}
func (o *LPUART_Type) GetMODIR_TXCTSSRC() uint32 {
	return (volatile.LoadUint32(&o.MODIR.Reg) & 0x20) >> 5
}
func (o *LPUART_Type) SetMODIR_RTSWATER(value uint32) {
	volatile.StoreUint32(&o.MODIR.Reg, volatile.LoadUint32(&o.MODIR.Reg)&^(0x300)|value<<8)
}
func (o *LPUART_Type) GetMODIR_RTSWATER() uint32 {
	return (volatile.LoadUint32(&o.MODIR.Reg) & 0x300) >> 8
}
func (o *LPUART_Type) SetMODIR_TNP(value uint32) {
	volatile.StoreUint32(&o.MODIR.Reg, volatile.LoadUint32(&o.MODIR.Reg)&^(0x30000)|value<<16)
}
func (o *LPUART_Type) GetMODIR_TNP() uint32 {
	return (volatile.LoadUint32(&o.MODIR.Reg) & 0x30000) >> 16
}
func (o *LPUART_Type) SetMODIR_IREN(value uint32) {
	volatile.StoreUint32(&o.MODIR.Reg, volatile.LoadUint32(&o.MODIR.Reg)&^(0x40000)|value<<18)
}
func (o *LPUART_Type) GetMODIR_IREN() uint32 {
	return (volatile.LoadUint32(&o.MODIR.Reg) & 0x40000) >> 18
}

// LPUART.FIFO: LPUART FIFO Register
func (o *LPUART_Type) SetFIFO_RXFIFOSIZE(value uint32) {
	volatile.StoreUint32(&o.FIFO.Reg, volatile.LoadUint32(&o.FIFO.Reg)&^(0x7)|value)
}
func (o *LPUART_Type) GetFIFO_RXFIFOSIZE() uint32 {
	return volatile.LoadUint32(&o.FIFO.Reg) & 0x7
}
func (o *LPUART_Type) SetFIFO_RXFE(value uint32) {
	volatile.StoreUint32(&o.FIFO.Reg, volatile.LoadUint32(&o.FIFO.Reg)&^(0x8)|value<<3)
}
func (o *LPUART_Type) GetFIFO_RXFE() uint32 {
	return (volatile.LoadUint32(&o.FIFO.Reg) & 0x8) >> 3
}
func (o *LPUART_Type) SetFIFO_TXFIFOSIZE(value uint32) {
	volatile.StoreUint32(&o.FIFO.Reg, volatile.LoadUint32(&o.FIFO.Reg)&^(0x70)|value<<4)
}
func (o *LPUART_Type) GetFIFO_TXFIFOSIZE() uint32 {
	return (volatile.LoadUint32(&o.FIFO.Reg) & 0x70) >> 4
}
func (o *LPUART_Type) SetFIFO_TXFE(value uint32) {
	volatile.StoreUint32(&o.FIFO.Reg, volatile.LoadUint32(&o.FIFO.Reg)&^(0x80)|value<<7)
}
func (o *LPUART_Type) GetFIFO_TXFE() uint32 {
	return (volatile.LoadUint32(&o.FIFO.Reg) & 0x80) >> 7
}
func (o *LPUART_Type) SetFIFO_RXUFE(value uint32) {
	volatile.StoreUint32(&o.FIFO.Reg, volatile.LoadUint32(&o.FIFO.Reg)&^(0x100)|value<<8)
}
func (o *LPUART_Type) GetFIFO_RXUFE() uint32 {
	return (volatile.LoadUint32(&o.FIFO.Reg) & 0x100) >> 8
}
func (o *LPUART_Type) SetFIFO_TXOFE(value uint32) {
	volatile.StoreUint32(&o.FIFO.Reg, volatile.LoadUint32(&o.FIFO.Reg)&^(0x200)|value<<9)
}
func (o *LPUART_Type) GetFIFO_TXOFE() uint32 {
	return (volatile.LoadUint32(&o.FIFO.Reg) & 0x200) >> 9
}
func (o *LPUART_Type) SetFIFO_RXIDEN(value uint32) {
	volatile.StoreUint32(&o.FIFO.Reg, volatile.LoadUint32(&o.FIFO.Reg)&^(0x1c00)|value<<10)
}
func (o *LPUART_Type) GetFIFO_RXIDEN() uint32 {
	return (volatile.LoadUint32(&o.FIFO.Reg) & 0x1c00) >> 10
}
func (o *LPUART_Type) SetFIFO_RXFLUSH(value uint32) {
	volatile.StoreUint32(&o.FIFO.Reg, volatile.LoadUint32(&o.FIFO.Reg)&^(0x4000)|value<<14)
}
func (o *LPUART_Type) GetFIFO_RXFLUSH() uint32 {
	return (volatile.LoadUint32(&o.FIFO.Reg) & 0x4000) >> 14
}
func (o *LPUART_Type) SetFIFO_TXFLUSH(value uint32) {
	volatile.StoreUint32(&o.FIFO.Reg, volatile.LoadUint32(&o.FIFO.Reg)&^(0x8000)|value<<15)
}
func (o *LPUART_Type) GetFIFO_TXFLUSH() uint32 {
	return (volatile.LoadUint32(&o.FIFO.Reg) & 0x8000) >> 15
}
func (o *LPUART_Type) SetFIFO_RXUF(value uint32) {
	volatile.StoreUint32(&o.FIFO.Reg, volatile.LoadUint32(&o.FIFO.Reg)&^(0x10000)|value<<16)
}
func (o *LPUART_Type) GetFIFO_RXUF() uint32 {
	return (volatile.LoadUint32(&o.FIFO.Reg) & 0x10000) >> 16
}
func (o *LPUART_Type) SetFIFO_TXOF(value uint32) {
	volatile.StoreUint32(&o.FIFO.Reg, volatile.LoadUint32(&o.FIFO.Reg)&^(0x20000)|value<<17)
}
func (o *LPUART_Type) GetFIFO_TXOF() uint32 {
	return (volatile.LoadUint32(&o.FIFO.Reg) & 0x20000) >> 17
}
func (o *LPUART_Type) SetFIFO_RXEMPT(value uint32) {
	volatile.StoreUint32(&o.FIFO.Reg, volatile.LoadUint32(&o.FIFO.Reg)&^(0x400000)|value<<22)
}
func (o *LPUART_Type) GetFIFO_RXEMPT() uint32 {
	return (volatile.LoadUint32(&o.FIFO.Reg) & 0x400000) >> 22
}
func (o *LPUART_Type) SetFIFO_TXEMPT(value uint32) {
	volatile.StoreUint32(&o.FIFO.Reg, volatile.LoadUint32(&o.FIFO.Reg)&^(0x800000)|value<<23)
}
func (o *LPUART_Type) GetFIFO_TXEMPT() uint32 {
	return (volatile.LoadUint32(&o.FIFO.Reg) & 0x800000) >> 23
}

// LPUART.WATER: LPUART Watermark Register
func (o *LPUART_Type) SetWATER_TXWATER(value uint32) {
	volatile.StoreUint32(&o.WATER.Reg, volatile.LoadUint32(&o.WATER.Reg)&^(0x3)|value)
}
func (o *LPUART_Type) GetWATER_TXWATER() uint32 {
	return volatile.LoadUint32(&o.WATER.Reg) & 0x3
}
func (o *LPUART_Type) SetWATER_TXCOUNT(value uint32) {
	volatile.StoreUint32(&o.WATER.Reg, volatile.LoadUint32(&o.WATER.Reg)&^(0x700)|value<<8)
}
func (o *LPUART_Type) GetWATER_TXCOUNT() uint32 {
	return (volatile.LoadUint32(&o.WATER.Reg) & 0x700) >> 8
}
func (o *LPUART_Type) SetWATER_RXWATER(value uint32) {
	volatile.StoreUint32(&o.WATER.Reg, volatile.LoadUint32(&o.WATER.Reg)&^(0x30000)|value<<16)
}
func (o *LPUART_Type) GetWATER_RXWATER() uint32 {
	return (volatile.LoadUint32(&o.WATER.Reg) & 0x30000) >> 16
}
func (o *LPUART_Type) SetWATER_RXCOUNT(value uint32) {
	volatile.StoreUint32(&o.WATER.Reg, volatile.LoadUint32(&o.WATER.Reg)&^(0x7000000)|value<<24)
}
func (o *LPUART_Type) GetWATER_RXCOUNT() uint32 {
	return (volatile.LoadUint32(&o.WATER.Reg) & 0x7000000) >> 24
}

// LPSPI
type LPSPI_Type struct {
	VERID volatile.Register32 // 0x0
	PARAM volatile.Register32 // 0x4
	_     [8]byte
	CR    volatile.Register32 // 0x10
	SR    volatile.Register32 // 0x14
	IER   volatile.Register32 // 0x18
	DER   volatile.Register32 // 0x1C
	CFGR0 volatile.Register32 // 0x20
	CFGR1 volatile.Register32 // 0x24
	_     [8]byte
	DMR0  volatile.Register32 // 0x30
	DMR1  volatile.Register32 // 0x34
	_     [8]byte
	CCR   volatile.Register32 // 0x40
	_     [20]byte
	FCR   volatile.Register32 // 0x58
	FSR   volatile.Register32 // 0x5C
	TCR   volatile.Register32 // 0x60
	TDR   volatile.Register32 // 0x64
	_     [8]byte
	RSR   volatile.Register32 // 0x70
	RDR   volatile.Register32 // 0x74
}

// LPSPI.VERID: Version ID Register
func (o *LPSPI_Type) SetVERID_FEATURE(value uint32) {
	volatile.StoreUint32(&o.VERID.Reg, volatile.LoadUint32(&o.VERID.Reg)&^(0xffff)|value)
}
func (o *LPSPI_Type) GetVERID_FEATURE() uint32 {
	return volatile.LoadUint32(&o.VERID.Reg) & 0xffff
}
func (o *LPSPI_Type) SetVERID_MINOR(value uint32) {
	volatile.StoreUint32(&o.VERID.Reg, volatile.LoadUint32(&o.VERID.Reg)&^(0xff0000)|value<<16)
}
func (o *LPSPI_Type) GetVERID_MINOR() uint32 {
	return (volatile.LoadUint32(&o.VERID.Reg) & 0xff0000) >> 16
}
func (o *LPSPI_Type) SetVERID_MAJOR(value uint32) {
	volatile.StoreUint32(&o.VERID.Reg, volatile.LoadUint32(&o.VERID.Reg)&^(0xff000000)|value<<24)
}
func (o *LPSPI_Type) GetVERID_MAJOR() uint32 {
	return (volatile.LoadUint32(&o.VERID.Reg) & 0xff000000) >> 24
}

// LPSPI.PARAM: Parameter Register
func (o *LPSPI_Type) SetPARAM_TXFIFO(value uint32) {
	volatile.StoreUint32(&o.PARAM.Reg, volatile.LoadUint32(&o.PARAM.Reg)&^(0xff)|value)
}
func (o *LPSPI_Type) GetPARAM_TXFIFO() uint32 {
	return volatile.LoadUint32(&o.PARAM.Reg) & 0xff
}
func (o *LPSPI_Type) SetPARAM_RXFIFO(value uint32) {
	volatile.StoreUint32(&o.PARAM.Reg, volatile.LoadUint32(&o.PARAM.Reg)&^(0xff00)|value<<8)
}
func (o *LPSPI_Type) GetPARAM_RXFIFO() uint32 {
	return (volatile.LoadUint32(&o.PARAM.Reg) & 0xff00) >> 8
}
func (o *LPSPI_Type) SetPARAM_PCSNUM(value uint32) {
	volatile.StoreUint32(&o.PARAM.Reg, volatile.LoadUint32(&o.PARAM.Reg)&^(0xff0000)|value<<16)
}
func (o *LPSPI_Type) GetPARAM_PCSNUM() uint32 {
	return (volatile.LoadUint32(&o.PARAM.Reg) & 0xff0000) >> 16
}

// LPSPI.CR: Control Register
func (o *LPSPI_Type) SetCR_MEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *LPSPI_Type) GetCR_MEN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *LPSPI_Type) SetCR_RST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *LPSPI_Type) GetCR_RST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *LPSPI_Type) SetCR_DOZEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *LPSPI_Type) GetCR_DOZEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *LPSPI_Type) SetCR_DBGEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *LPSPI_Type) GetCR_DBGEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *LPSPI_Type) SetCR_RTF(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x100)|value<<8)
}
func (o *LPSPI_Type) GetCR_RTF() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x100) >> 8
}
func (o *LPSPI_Type) SetCR_RRF(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *LPSPI_Type) GetCR_RRF() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}

// LPSPI.SR: Status Register
func (o *LPSPI_Type) SetSR_TDF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *LPSPI_Type) GetSR_TDF() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *LPSPI_Type) SetSR_RDF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *LPSPI_Type) GetSR_RDF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *LPSPI_Type) SetSR_WCF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x100)|value<<8)
}
func (o *LPSPI_Type) GetSR_WCF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x100) >> 8
}
func (o *LPSPI_Type) SetSR_FCF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x200)|value<<9)
}
func (o *LPSPI_Type) GetSR_FCF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x200) >> 9
}
func (o *LPSPI_Type) SetSR_TCF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x400)|value<<10)
}
func (o *LPSPI_Type) GetSR_TCF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x400) >> 10
}
func (o *LPSPI_Type) SetSR_TEF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x800)|value<<11)
}
func (o *LPSPI_Type) GetSR_TEF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x800) >> 11
}
func (o *LPSPI_Type) SetSR_REF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1000)|value<<12)
}
func (o *LPSPI_Type) GetSR_REF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1000) >> 12
}
func (o *LPSPI_Type) SetSR_DMF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2000)|value<<13)
}
func (o *LPSPI_Type) GetSR_DMF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2000) >> 13
}
func (o *LPSPI_Type) SetSR_MBF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1000000)|value<<24)
}
func (o *LPSPI_Type) GetSR_MBF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x1000000) >> 24
}

// LPSPI.IER: Interrupt Enable Register
func (o *LPSPI_Type) SetIER_TDIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1)|value)
}
func (o *LPSPI_Type) GetIER_TDIE() uint32 {
	return volatile.LoadUint32(&o.IER.Reg) & 0x1
}
func (o *LPSPI_Type) SetIER_RDIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2)|value<<1)
}
func (o *LPSPI_Type) GetIER_RDIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2) >> 1
}
func (o *LPSPI_Type) SetIER_WCIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x100)|value<<8)
}
func (o *LPSPI_Type) GetIER_WCIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x100) >> 8
}
func (o *LPSPI_Type) SetIER_FCIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x200)|value<<9)
}
func (o *LPSPI_Type) GetIER_FCIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x200) >> 9
}
func (o *LPSPI_Type) SetIER_TCIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x400)|value<<10)
}
func (o *LPSPI_Type) GetIER_TCIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x400) >> 10
}
func (o *LPSPI_Type) SetIER_TEIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x800)|value<<11)
}
func (o *LPSPI_Type) GetIER_TEIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x800) >> 11
}
func (o *LPSPI_Type) SetIER_REIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x1000)|value<<12)
}
func (o *LPSPI_Type) GetIER_REIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x1000) >> 12
}
func (o *LPSPI_Type) SetIER_DMIE(value uint32) {
	volatile.StoreUint32(&o.IER.Reg, volatile.LoadUint32(&o.IER.Reg)&^(0x2000)|value<<13)
}
func (o *LPSPI_Type) GetIER_DMIE() uint32 {
	return (volatile.LoadUint32(&o.IER.Reg) & 0x2000) >> 13
}

// LPSPI.DER: DMA Enable Register
func (o *LPSPI_Type) SetDER_TDDE(value uint32) {
	volatile.StoreUint32(&o.DER.Reg, volatile.LoadUint32(&o.DER.Reg)&^(0x1)|value)
}
func (o *LPSPI_Type) GetDER_TDDE() uint32 {
	return volatile.LoadUint32(&o.DER.Reg) & 0x1
}
func (o *LPSPI_Type) SetDER_RDDE(value uint32) {
	volatile.StoreUint32(&o.DER.Reg, volatile.LoadUint32(&o.DER.Reg)&^(0x2)|value<<1)
}
func (o *LPSPI_Type) GetDER_RDDE() uint32 {
	return (volatile.LoadUint32(&o.DER.Reg) & 0x2) >> 1
}

// LPSPI.CFGR0: Configuration Register 0
func (o *LPSPI_Type) SetCFGR0_HREN(value uint32) {
	volatile.StoreUint32(&o.CFGR0.Reg, volatile.LoadUint32(&o.CFGR0.Reg)&^(0x1)|value)
}
func (o *LPSPI_Type) GetCFGR0_HREN() uint32 {
	return volatile.LoadUint32(&o.CFGR0.Reg) & 0x1
}
func (o *LPSPI_Type) SetCFGR0_HRPOL(value uint32) {
	volatile.StoreUint32(&o.CFGR0.Reg, volatile.LoadUint32(&o.CFGR0.Reg)&^(0x2)|value<<1)
}
func (o *LPSPI_Type) GetCFGR0_HRPOL() uint32 {
	return (volatile.LoadUint32(&o.CFGR0.Reg) & 0x2) >> 1
}
func (o *LPSPI_Type) SetCFGR0_HRSEL(value uint32) {
	volatile.StoreUint32(&o.CFGR0.Reg, volatile.LoadUint32(&o.CFGR0.Reg)&^(0x4)|value<<2)
}
func (o *LPSPI_Type) GetCFGR0_HRSEL() uint32 {
	return (volatile.LoadUint32(&o.CFGR0.Reg) & 0x4) >> 2
}
func (o *LPSPI_Type) SetCFGR0_CIRFIFO(value uint32) {
	volatile.StoreUint32(&o.CFGR0.Reg, volatile.LoadUint32(&o.CFGR0.Reg)&^(0x100)|value<<8)
}
func (o *LPSPI_Type) GetCFGR0_CIRFIFO() uint32 {
	return (volatile.LoadUint32(&o.CFGR0.Reg) & 0x100) >> 8
}
func (o *LPSPI_Type) SetCFGR0_RDMO(value uint32) {
	volatile.StoreUint32(&o.CFGR0.Reg, volatile.LoadUint32(&o.CFGR0.Reg)&^(0x200)|value<<9)
}
func (o *LPSPI_Type) GetCFGR0_RDMO() uint32 {
	return (volatile.LoadUint32(&o.CFGR0.Reg) & 0x200) >> 9
}

// LPSPI.CFGR1: Configuration Register 1
func (o *LPSPI_Type) SetCFGR1_MASTER(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x1)|value)
}
func (o *LPSPI_Type) GetCFGR1_MASTER() uint32 {
	return volatile.LoadUint32(&o.CFGR1.Reg) & 0x1
}
func (o *LPSPI_Type) SetCFGR1_SAMPLE(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x2)|value<<1)
}
func (o *LPSPI_Type) GetCFGR1_SAMPLE() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x2) >> 1
}
func (o *LPSPI_Type) SetCFGR1_AUTOPCS(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x4)|value<<2)
}
func (o *LPSPI_Type) GetCFGR1_AUTOPCS() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x4) >> 2
}
func (o *LPSPI_Type) SetCFGR1_NOSTALL(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x8)|value<<3)
}
func (o *LPSPI_Type) GetCFGR1_NOSTALL() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x8) >> 3
}
func (o *LPSPI_Type) SetCFGR1_PCSPOL(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0xf00)|value<<8)
}
func (o *LPSPI_Type) GetCFGR1_PCSPOL() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0xf00) >> 8
}
func (o *LPSPI_Type) SetCFGR1_MATCFG(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x70000)|value<<16)
}
func (o *LPSPI_Type) GetCFGR1_MATCFG() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x70000) >> 16
}
func (o *LPSPI_Type) SetCFGR1_PINCFG(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x3000000)|value<<24)
}
func (o *LPSPI_Type) GetCFGR1_PINCFG() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x3000000) >> 24
}
func (o *LPSPI_Type) SetCFGR1_OUTCFG(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x4000000)|value<<26)
}
func (o *LPSPI_Type) GetCFGR1_OUTCFG() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x4000000) >> 26
}
func (o *LPSPI_Type) SetCFGR1_PCSCFG(value uint32) {
	volatile.StoreUint32(&o.CFGR1.Reg, volatile.LoadUint32(&o.CFGR1.Reg)&^(0x8000000)|value<<27)
}
func (o *LPSPI_Type) GetCFGR1_PCSCFG() uint32 {
	return (volatile.LoadUint32(&o.CFGR1.Reg) & 0x8000000) >> 27
}

// LPSPI.DMR0: Data Match Register 0
func (o *LPSPI_Type) SetDMR0(value uint32) {
	volatile.StoreUint32(&o.DMR0.Reg, value)
}
func (o *LPSPI_Type) GetDMR0() uint32 {
	return volatile.LoadUint32(&o.DMR0.Reg)
}

// LPSPI.DMR1: Data Match Register 1
func (o *LPSPI_Type) SetDMR1(value uint32) {
	volatile.StoreUint32(&o.DMR1.Reg, value)
}
func (o *LPSPI_Type) GetDMR1() uint32 {
	return volatile.LoadUint32(&o.DMR1.Reg)
}

// LPSPI.CCR: Clock Configuration Register
func (o *LPSPI_Type) SetCCR_SCKDIV(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0xff)|value)
}
func (o *LPSPI_Type) GetCCR_SCKDIV() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0xff
}
func (o *LPSPI_Type) SetCCR_DBT(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0xff00)|value<<8)
}
func (o *LPSPI_Type) GetCCR_DBT() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0xff00) >> 8
}
func (o *LPSPI_Type) SetCCR_PCSSCK(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0xff0000)|value<<16)
}
func (o *LPSPI_Type) GetCCR_PCSSCK() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0xff0000) >> 16
}
func (o *LPSPI_Type) SetCCR_SCKPCS(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0xff000000)|value<<24)
}
func (o *LPSPI_Type) GetCCR_SCKPCS() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0xff000000) >> 24
}

// LPSPI.FCR: FIFO Control Register
func (o *LPSPI_Type) SetFCR_TXWATER(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0xf)|value)
}
func (o *LPSPI_Type) GetFCR_TXWATER() uint32 {
	return volatile.LoadUint32(&o.FCR.Reg) & 0xf
}
func (o *LPSPI_Type) SetFCR_RXWATER(value uint32) {
	volatile.StoreUint32(&o.FCR.Reg, volatile.LoadUint32(&o.FCR.Reg)&^(0xf0000)|value<<16)
}
func (o *LPSPI_Type) GetFCR_RXWATER() uint32 {
	return (volatile.LoadUint32(&o.FCR.Reg) & 0xf0000) >> 16
}

// LPSPI.FSR: FIFO Status Register
func (o *LPSPI_Type) SetFSR_TXCOUNT(value uint32) {
	volatile.StoreUint32(&o.FSR.Reg, volatile.LoadUint32(&o.FSR.Reg)&^(0x1f)|value)
}
func (o *LPSPI_Type) GetFSR_TXCOUNT() uint32 {
	return volatile.LoadUint32(&o.FSR.Reg) & 0x1f
}
func (o *LPSPI_Type) SetFSR_RXCOUNT(value uint32) {
	volatile.StoreUint32(&o.FSR.Reg, volatile.LoadUint32(&o.FSR.Reg)&^(0x1f0000)|value<<16)
}
func (o *LPSPI_Type) GetFSR_RXCOUNT() uint32 {
	return (volatile.LoadUint32(&o.FSR.Reg) & 0x1f0000) >> 16
}

// LPSPI.TCR: Transmit Command Register
func (o *LPSPI_Type) SetTCR_FRAMESZ(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xfff)|value)
}
func (o *LPSPI_Type) GetTCR_FRAMESZ() uint32 {
	return volatile.LoadUint32(&o.TCR.Reg) & 0xfff
}
func (o *LPSPI_Type) SetTCR_WIDTH(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x30000)|value<<16)
}
func (o *LPSPI_Type) GetTCR_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x30000) >> 16
}
func (o *LPSPI_Type) SetTCR_TXMSK(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x40000)|value<<18)
}
func (o *LPSPI_Type) GetTCR_TXMSK() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x40000) >> 18
}
func (o *LPSPI_Type) SetTCR_RXMSK(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x80000)|value<<19)
}
func (o *LPSPI_Type) GetTCR_RXMSK() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x80000) >> 19
}
func (o *LPSPI_Type) SetTCR_CONTC(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x100000)|value<<20)
}
func (o *LPSPI_Type) GetTCR_CONTC() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x100000) >> 20
}
func (o *LPSPI_Type) SetTCR_CONT(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x200000)|value<<21)
}
func (o *LPSPI_Type) GetTCR_CONT() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x200000) >> 21
}
func (o *LPSPI_Type) SetTCR_BYSW(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x400000)|value<<22)
}
func (o *LPSPI_Type) GetTCR_BYSW() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x400000) >> 22
}
func (o *LPSPI_Type) SetTCR_LSBF(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x800000)|value<<23)
}
func (o *LPSPI_Type) GetTCR_LSBF() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x800000) >> 23
}
func (o *LPSPI_Type) SetTCR_PCS(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x3000000)|value<<24)
}
func (o *LPSPI_Type) GetTCR_PCS() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x3000000) >> 24
}
func (o *LPSPI_Type) SetTCR_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x38000000)|value<<27)
}
func (o *LPSPI_Type) GetTCR_PRESCALE() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x38000000) >> 27
}
func (o *LPSPI_Type) SetTCR_CPHA(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x40000000)|value<<30)
}
func (o *LPSPI_Type) GetTCR_CPHA() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x40000000) >> 30
}
func (o *LPSPI_Type) SetTCR_CPOL(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x80000000)|value<<31)
}
func (o *LPSPI_Type) GetTCR_CPOL() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x80000000) >> 31
}

// LPSPI.TDR: Transmit Data Register
func (o *LPSPI_Type) SetTDR(value uint32) {
	volatile.StoreUint32(&o.TDR.Reg, value)
}
func (o *LPSPI_Type) GetTDR() uint32 {
	return volatile.LoadUint32(&o.TDR.Reg)
}

// LPSPI.RSR: Receive Status Register
func (o *LPSPI_Type) SetRSR_SOF(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x1)|value)
}
func (o *LPSPI_Type) GetRSR_SOF() uint32 {
	return volatile.LoadUint32(&o.RSR.Reg) & 0x1
}
func (o *LPSPI_Type) SetRSR_RXEMPTY(value uint32) {
	volatile.StoreUint32(&o.RSR.Reg, volatile.LoadUint32(&o.RSR.Reg)&^(0x2)|value<<1)
}
func (o *LPSPI_Type) GetRSR_RXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.RSR.Reg) & 0x2) >> 1
}

// LPSPI.RDR: Receive Data Register
func (o *LPSPI_Type) SetRDR(value uint32) {
	volatile.StoreUint32(&o.RDR.Reg, value)
}
func (o *LPSPI_Type) GetRDR() uint32 {
	return volatile.LoadUint32(&o.RDR.Reg)
}

// LPI2C
type LPI2C_Type struct {
	VERID  volatile.Register32 // 0x0
	PARAM  volatile.Register32 // 0x4
	_      [8]byte
	MCR    volatile.Register32 // 0x10
	MSR    volatile.Register32 // 0x14
	MIER   volatile.Register32 // 0x18
	MDER   volatile.Register32 // 0x1C
	MCFGR0 volatile.Register32 // 0x20
	MCFGR1 volatile.Register32 // 0x24
	MCFGR2 volatile.Register32 // 0x28
	MCFGR3 volatile.Register32 // 0x2C
	_      [16]byte
	MDMR   volatile.Register32 // 0x40
	_      [4]byte
	MCCR0  volatile.Register32 // 0x48
	_      [4]byte
	MCCR1  volatile.Register32 // 0x50
	_      [4]byte
	MFCR   volatile.Register32 // 0x58
	MFSR   volatile.Register32 // 0x5C
	MTDR   volatile.Register32 // 0x60
	_      [12]byte
	MRDR   volatile.Register32 // 0x70
	_      [156]byte
	SCR    volatile.Register32 // 0x110
	SSR    volatile.Register32 // 0x114
	SIER   volatile.Register32 // 0x118
	SDER   volatile.Register32 // 0x11C
	_      [4]byte
	SCFGR1 volatile.Register32 // 0x124
	SCFGR2 volatile.Register32 // 0x128
	_      [20]byte
	SAMR   volatile.Register32 // 0x140
	_      [12]byte
	SASR   volatile.Register32 // 0x150
	STAR   volatile.Register32 // 0x154
	_      [8]byte
	STDR   volatile.Register32 // 0x160
	_      [12]byte
	SRDR   volatile.Register32 // 0x170
}

// LPI2C.VERID: Version ID Register
func (o *LPI2C_Type) SetVERID_FEATURE(value uint32) {
	volatile.StoreUint32(&o.VERID.Reg, volatile.LoadUint32(&o.VERID.Reg)&^(0xffff)|value)
}
func (o *LPI2C_Type) GetVERID_FEATURE() uint32 {
	return volatile.LoadUint32(&o.VERID.Reg) & 0xffff
}
func (o *LPI2C_Type) SetVERID_MINOR(value uint32) {
	volatile.StoreUint32(&o.VERID.Reg, volatile.LoadUint32(&o.VERID.Reg)&^(0xff0000)|value<<16)
}
func (o *LPI2C_Type) GetVERID_MINOR() uint32 {
	return (volatile.LoadUint32(&o.VERID.Reg) & 0xff0000) >> 16
}
func (o *LPI2C_Type) SetVERID_MAJOR(value uint32) {
	volatile.StoreUint32(&o.VERID.Reg, volatile.LoadUint32(&o.VERID.Reg)&^(0xff000000)|value<<24)
}
func (o *LPI2C_Type) GetVERID_MAJOR() uint32 {
	return (volatile.LoadUint32(&o.VERID.Reg) & 0xff000000) >> 24
}

// LPI2C.PARAM: Parameter Register
func (o *LPI2C_Type) SetPARAM_MTXFIFO(value uint32) {
	volatile.StoreUint32(&o.PARAM.Reg, volatile.LoadUint32(&o.PARAM.Reg)&^(0xf)|value)
}
func (o *LPI2C_Type) GetPARAM_MTXFIFO() uint32 {
	return volatile.LoadUint32(&o.PARAM.Reg) & 0xf
}
func (o *LPI2C_Type) SetPARAM_MRXFIFO(value uint32) {
	volatile.StoreUint32(&o.PARAM.Reg, volatile.LoadUint32(&o.PARAM.Reg)&^(0xf00)|value<<8)
}
func (o *LPI2C_Type) GetPARAM_MRXFIFO() uint32 {
	return (volatile.LoadUint32(&o.PARAM.Reg) & 0xf00) >> 8
}

// LPI2C.MCR: Master Control Register
func (o *LPI2C_Type) SetMCR_MEN(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x1)|value)
}
func (o *LPI2C_Type) GetMCR_MEN() uint32 {
	return volatile.LoadUint32(&o.MCR.Reg) & 0x1
}
func (o *LPI2C_Type) SetMCR_RST(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x2)|value<<1)
}
func (o *LPI2C_Type) GetMCR_RST() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x2) >> 1
}
func (o *LPI2C_Type) SetMCR_DOZEN(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x4)|value<<2)
}
func (o *LPI2C_Type) GetMCR_DOZEN() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x4) >> 2
}
func (o *LPI2C_Type) SetMCR_DBGEN(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x8)|value<<3)
}
func (o *LPI2C_Type) GetMCR_DBGEN() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x8) >> 3
}
func (o *LPI2C_Type) SetMCR_RTF(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x100)|value<<8)
}
func (o *LPI2C_Type) GetMCR_RTF() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x100) >> 8
}
func (o *LPI2C_Type) SetMCR_RRF(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x200)|value<<9)
}
func (o *LPI2C_Type) GetMCR_RRF() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x200) >> 9
}

// LPI2C.MSR: Master Status Register
func (o *LPI2C_Type) SetMSR_TDF(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x1)|value)
}
func (o *LPI2C_Type) GetMSR_TDF() uint32 {
	return volatile.LoadUint32(&o.MSR.Reg) & 0x1
}
func (o *LPI2C_Type) SetMSR_RDF(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x2)|value<<1)
}
func (o *LPI2C_Type) GetMSR_RDF() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x2) >> 1
}
func (o *LPI2C_Type) SetMSR_EPF(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x100)|value<<8)
}
func (o *LPI2C_Type) GetMSR_EPF() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x100) >> 8
}
func (o *LPI2C_Type) SetMSR_SDF(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x200)|value<<9)
}
func (o *LPI2C_Type) GetMSR_SDF() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x200) >> 9
}
func (o *LPI2C_Type) SetMSR_NDF(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x400)|value<<10)
}
func (o *LPI2C_Type) GetMSR_NDF() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x400) >> 10
}
func (o *LPI2C_Type) SetMSR_ALF(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x800)|value<<11)
}
func (o *LPI2C_Type) GetMSR_ALF() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x800) >> 11
}
func (o *LPI2C_Type) SetMSR_FEF(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x1000)|value<<12)
}
func (o *LPI2C_Type) GetMSR_FEF() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x1000) >> 12
}
func (o *LPI2C_Type) SetMSR_PLTF(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x2000)|value<<13)
}
func (o *LPI2C_Type) GetMSR_PLTF() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x2000) >> 13
}
func (o *LPI2C_Type) SetMSR_DMF(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x4000)|value<<14)
}
func (o *LPI2C_Type) GetMSR_DMF() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x4000) >> 14
}
func (o *LPI2C_Type) SetMSR_MBF(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x1000000)|value<<24)
}
func (o *LPI2C_Type) GetMSR_MBF() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x1000000) >> 24
}
func (o *LPI2C_Type) SetMSR_BBF(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x2000000)|value<<25)
}
func (o *LPI2C_Type) GetMSR_BBF() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x2000000) >> 25
}

// LPI2C.MIER: Master Interrupt Enable Register
func (o *LPI2C_Type) SetMIER_TDIE(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x1)|value)
}
func (o *LPI2C_Type) GetMIER_TDIE() uint32 {
	return volatile.LoadUint32(&o.MIER.Reg) & 0x1
}
func (o *LPI2C_Type) SetMIER_RDIE(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x2)|value<<1)
}
func (o *LPI2C_Type) GetMIER_RDIE() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x2) >> 1
}
func (o *LPI2C_Type) SetMIER_EPIE(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x100)|value<<8)
}
func (o *LPI2C_Type) GetMIER_EPIE() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x100) >> 8
}
func (o *LPI2C_Type) SetMIER_SDIE(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x200)|value<<9)
}
func (o *LPI2C_Type) GetMIER_SDIE() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x200) >> 9
}
func (o *LPI2C_Type) SetMIER_NDIE(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x400)|value<<10)
}
func (o *LPI2C_Type) GetMIER_NDIE() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x400) >> 10
}
func (o *LPI2C_Type) SetMIER_ALIE(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x800)|value<<11)
}
func (o *LPI2C_Type) GetMIER_ALIE() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x800) >> 11
}
func (o *LPI2C_Type) SetMIER_FEIE(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x1000)|value<<12)
}
func (o *LPI2C_Type) GetMIER_FEIE() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x1000) >> 12
}
func (o *LPI2C_Type) SetMIER_PLTIE(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x2000)|value<<13)
}
func (o *LPI2C_Type) GetMIER_PLTIE() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x2000) >> 13
}
func (o *LPI2C_Type) SetMIER_DMIE(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x4000)|value<<14)
}
func (o *LPI2C_Type) GetMIER_DMIE() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x4000) >> 14
}

// LPI2C.MDER: Master DMA Enable Register
func (o *LPI2C_Type) SetMDER_TDDE(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x1)|value)
}
func (o *LPI2C_Type) GetMDER_TDDE() uint32 {
	return volatile.LoadUint32(&o.MDER.Reg) & 0x1
}
func (o *LPI2C_Type) SetMDER_RDDE(value uint32) {
	volatile.StoreUint32(&o.MDER.Reg, volatile.LoadUint32(&o.MDER.Reg)&^(0x2)|value<<1)
}
func (o *LPI2C_Type) GetMDER_RDDE() uint32 {
	return (volatile.LoadUint32(&o.MDER.Reg) & 0x2) >> 1
}

// LPI2C.MCFGR0: Master Configuration Register 0
func (o *LPI2C_Type) SetMCFGR0_HREN(value uint32) {
	volatile.StoreUint32(&o.MCFGR0.Reg, volatile.LoadUint32(&o.MCFGR0.Reg)&^(0x1)|value)
}
func (o *LPI2C_Type) GetMCFGR0_HREN() uint32 {
	return volatile.LoadUint32(&o.MCFGR0.Reg) & 0x1
}
func (o *LPI2C_Type) SetMCFGR0_HRPOL(value uint32) {
	volatile.StoreUint32(&o.MCFGR0.Reg, volatile.LoadUint32(&o.MCFGR0.Reg)&^(0x2)|value<<1)
}
func (o *LPI2C_Type) GetMCFGR0_HRPOL() uint32 {
	return (volatile.LoadUint32(&o.MCFGR0.Reg) & 0x2) >> 1
}
func (o *LPI2C_Type) SetMCFGR0_HRSEL(value uint32) {
	volatile.StoreUint32(&o.MCFGR0.Reg, volatile.LoadUint32(&o.MCFGR0.Reg)&^(0x4)|value<<2)
}
func (o *LPI2C_Type) GetMCFGR0_HRSEL() uint32 {
	return (volatile.LoadUint32(&o.MCFGR0.Reg) & 0x4) >> 2
}
func (o *LPI2C_Type) SetMCFGR0_CIRFIFO(value uint32) {
	volatile.StoreUint32(&o.MCFGR0.Reg, volatile.LoadUint32(&o.MCFGR0.Reg)&^(0x100)|value<<8)
}
func (o *LPI2C_Type) GetMCFGR0_CIRFIFO() uint32 {
	return (volatile.LoadUint32(&o.MCFGR0.Reg) & 0x100) >> 8
}
func (o *LPI2C_Type) SetMCFGR0_RDMO(value uint32) {
	volatile.StoreUint32(&o.MCFGR0.Reg, volatile.LoadUint32(&o.MCFGR0.Reg)&^(0x200)|value<<9)
}
func (o *LPI2C_Type) GetMCFGR0_RDMO() uint32 {
	return (volatile.LoadUint32(&o.MCFGR0.Reg) & 0x200) >> 9
}

// LPI2C.MCFGR1: Master Configuration Register 1
func (o *LPI2C_Type) SetMCFGR1_PRESCALE(value uint32) {
	volatile.StoreUint32(&o.MCFGR1.Reg, volatile.LoadUint32(&o.MCFGR1.Reg)&^(0x7)|value)
}
func (o *LPI2C_Type) GetMCFGR1_PRESCALE() uint32 {
	return volatile.LoadUint32(&o.MCFGR1.Reg) & 0x7
}
func (o *LPI2C_Type) SetMCFGR1_AUTOSTOP(value uint32) {
	volatile.StoreUint32(&o.MCFGR1.Reg, volatile.LoadUint32(&o.MCFGR1.Reg)&^(0x100)|value<<8)
}
func (o *LPI2C_Type) GetMCFGR1_AUTOSTOP() uint32 {
	return (volatile.LoadUint32(&o.MCFGR1.Reg) & 0x100) >> 8
}
func (o *LPI2C_Type) SetMCFGR1_IGNACK(value uint32) {
	volatile.StoreUint32(&o.MCFGR1.Reg, volatile.LoadUint32(&o.MCFGR1.Reg)&^(0x200)|value<<9)
}
func (o *LPI2C_Type) GetMCFGR1_IGNACK() uint32 {
	return (volatile.LoadUint32(&o.MCFGR1.Reg) & 0x200) >> 9
}
func (o *LPI2C_Type) SetMCFGR1_TIMECFG(value uint32) {
	volatile.StoreUint32(&o.MCFGR1.Reg, volatile.LoadUint32(&o.MCFGR1.Reg)&^(0x400)|value<<10)
}
func (o *LPI2C_Type) GetMCFGR1_TIMECFG() uint32 {
	return (volatile.LoadUint32(&o.MCFGR1.Reg) & 0x400) >> 10
}
func (o *LPI2C_Type) SetMCFGR1_MATCFG(value uint32) {
	volatile.StoreUint32(&o.MCFGR1.Reg, volatile.LoadUint32(&o.MCFGR1.Reg)&^(0x70000)|value<<16)
}
func (o *LPI2C_Type) GetMCFGR1_MATCFG() uint32 {
	return (volatile.LoadUint32(&o.MCFGR1.Reg) & 0x70000) >> 16
}
func (o *LPI2C_Type) SetMCFGR1_PINCFG(value uint32) {
	volatile.StoreUint32(&o.MCFGR1.Reg, volatile.LoadUint32(&o.MCFGR1.Reg)&^(0x7000000)|value<<24)
}
func (o *LPI2C_Type) GetMCFGR1_PINCFG() uint32 {
	return (volatile.LoadUint32(&o.MCFGR1.Reg) & 0x7000000) >> 24
}

// LPI2C.MCFGR2: Master Configuration Register 2
func (o *LPI2C_Type) SetMCFGR2_BUSIDLE(value uint32) {
	volatile.StoreUint32(&o.MCFGR2.Reg, volatile.LoadUint32(&o.MCFGR2.Reg)&^(0xfff)|value)
}
func (o *LPI2C_Type) GetMCFGR2_BUSIDLE() uint32 {
	return volatile.LoadUint32(&o.MCFGR2.Reg) & 0xfff
}
func (o *LPI2C_Type) SetMCFGR2_FILTSCL(value uint32) {
	volatile.StoreUint32(&o.MCFGR2.Reg, volatile.LoadUint32(&o.MCFGR2.Reg)&^(0xf0000)|value<<16)
}
func (o *LPI2C_Type) GetMCFGR2_FILTSCL() uint32 {
	return (volatile.LoadUint32(&o.MCFGR2.Reg) & 0xf0000) >> 16
}
func (o *LPI2C_Type) SetMCFGR2_FILTSDA(value uint32) {
	volatile.StoreUint32(&o.MCFGR2.Reg, volatile.LoadUint32(&o.MCFGR2.Reg)&^(0xf000000)|value<<24)
}
func (o *LPI2C_Type) GetMCFGR2_FILTSDA() uint32 {
	return (volatile.LoadUint32(&o.MCFGR2.Reg) & 0xf000000) >> 24
}

// LPI2C.MCFGR3: Master Configuration Register 3
func (o *LPI2C_Type) SetMCFGR3_PINLOW(value uint32) {
	volatile.StoreUint32(&o.MCFGR3.Reg, volatile.LoadUint32(&o.MCFGR3.Reg)&^(0xfff00)|value<<8)
}
func (o *LPI2C_Type) GetMCFGR3_PINLOW() uint32 {
	return (volatile.LoadUint32(&o.MCFGR3.Reg) & 0xfff00) >> 8
}

// LPI2C.MDMR: Master Data Match Register
func (o *LPI2C_Type) SetMDMR_MATCH0(value uint32) {
	volatile.StoreUint32(&o.MDMR.Reg, volatile.LoadUint32(&o.MDMR.Reg)&^(0xff)|value)
}
func (o *LPI2C_Type) GetMDMR_MATCH0() uint32 {
	return volatile.LoadUint32(&o.MDMR.Reg) & 0xff
}
func (o *LPI2C_Type) SetMDMR_MATCH1(value uint32) {
	volatile.StoreUint32(&o.MDMR.Reg, volatile.LoadUint32(&o.MDMR.Reg)&^(0xff0000)|value<<16)
}
func (o *LPI2C_Type) GetMDMR_MATCH1() uint32 {
	return (volatile.LoadUint32(&o.MDMR.Reg) & 0xff0000) >> 16
}

// LPI2C.MCCR0: Master Clock Configuration Register 0
func (o *LPI2C_Type) SetMCCR0_CLKLO(value uint32) {
	volatile.StoreUint32(&o.MCCR0.Reg, volatile.LoadUint32(&o.MCCR0.Reg)&^(0x3f)|value)
}
func (o *LPI2C_Type) GetMCCR0_CLKLO() uint32 {
	return volatile.LoadUint32(&o.MCCR0.Reg) & 0x3f
}
func (o *LPI2C_Type) SetMCCR0_CLKHI(value uint32) {
	volatile.StoreUint32(&o.MCCR0.Reg, volatile.LoadUint32(&o.MCCR0.Reg)&^(0x3f00)|value<<8)
}
func (o *LPI2C_Type) GetMCCR0_CLKHI() uint32 {
	return (volatile.LoadUint32(&o.MCCR0.Reg) & 0x3f00) >> 8
}
func (o *LPI2C_Type) SetMCCR0_SETHOLD(value uint32) {
	volatile.StoreUint32(&o.MCCR0.Reg, volatile.LoadUint32(&o.MCCR0.Reg)&^(0x3f0000)|value<<16)
}
func (o *LPI2C_Type) GetMCCR0_SETHOLD() uint32 {
	return (volatile.LoadUint32(&o.MCCR0.Reg) & 0x3f0000) >> 16
}
func (o *LPI2C_Type) SetMCCR0_DATAVD(value uint32) {
	volatile.StoreUint32(&o.MCCR0.Reg, volatile.LoadUint32(&o.MCCR0.Reg)&^(0x3f000000)|value<<24)
}
func (o *LPI2C_Type) GetMCCR0_DATAVD() uint32 {
	return (volatile.LoadUint32(&o.MCCR0.Reg) & 0x3f000000) >> 24
}

// LPI2C.MCCR1: Master Clock Configuration Register 1
func (o *LPI2C_Type) SetMCCR1_CLKLO(value uint32) {
	volatile.StoreUint32(&o.MCCR1.Reg, volatile.LoadUint32(&o.MCCR1.Reg)&^(0x3f)|value)
}
func (o *LPI2C_Type) GetMCCR1_CLKLO() uint32 {
	return volatile.LoadUint32(&o.MCCR1.Reg) & 0x3f
}
func (o *LPI2C_Type) SetMCCR1_CLKHI(value uint32) {
	volatile.StoreUint32(&o.MCCR1.Reg, volatile.LoadUint32(&o.MCCR1.Reg)&^(0x3f00)|value<<8)
}
func (o *LPI2C_Type) GetMCCR1_CLKHI() uint32 {
	return (volatile.LoadUint32(&o.MCCR1.Reg) & 0x3f00) >> 8
}
func (o *LPI2C_Type) SetMCCR1_SETHOLD(value uint32) {
	volatile.StoreUint32(&o.MCCR1.Reg, volatile.LoadUint32(&o.MCCR1.Reg)&^(0x3f0000)|value<<16)
}
func (o *LPI2C_Type) GetMCCR1_SETHOLD() uint32 {
	return (volatile.LoadUint32(&o.MCCR1.Reg) & 0x3f0000) >> 16
}
func (o *LPI2C_Type) SetMCCR1_DATAVD(value uint32) {
	volatile.StoreUint32(&o.MCCR1.Reg, volatile.LoadUint32(&o.MCCR1.Reg)&^(0x3f000000)|value<<24)
}
func (o *LPI2C_Type) GetMCCR1_DATAVD() uint32 {
	return (volatile.LoadUint32(&o.MCCR1.Reg) & 0x3f000000) >> 24
}

// LPI2C.MFCR: Master FIFO Control Register
func (o *LPI2C_Type) SetMFCR_TXWATER(value uint32) {
	volatile.StoreUint32(&o.MFCR.Reg, volatile.LoadUint32(&o.MFCR.Reg)&^(0x3)|value)
}
func (o *LPI2C_Type) GetMFCR_TXWATER() uint32 {
	return volatile.LoadUint32(&o.MFCR.Reg) & 0x3
}
func (o *LPI2C_Type) SetMFCR_RXWATER(value uint32) {
	volatile.StoreUint32(&o.MFCR.Reg, volatile.LoadUint32(&o.MFCR.Reg)&^(0x30000)|value<<16)
}
func (o *LPI2C_Type) GetMFCR_RXWATER() uint32 {
	return (volatile.LoadUint32(&o.MFCR.Reg) & 0x30000) >> 16
}

// LPI2C.MFSR: Master FIFO Status Register
func (o *LPI2C_Type) SetMFSR_TXCOUNT(value uint32) {
	volatile.StoreUint32(&o.MFSR.Reg, volatile.LoadUint32(&o.MFSR.Reg)&^(0x7)|value)
}
func (o *LPI2C_Type) GetMFSR_TXCOUNT() uint32 {
	return volatile.LoadUint32(&o.MFSR.Reg) & 0x7
}
func (o *LPI2C_Type) SetMFSR_RXCOUNT(value uint32) {
	volatile.StoreUint32(&o.MFSR.Reg, volatile.LoadUint32(&o.MFSR.Reg)&^(0x70000)|value<<16)
}
func (o *LPI2C_Type) GetMFSR_RXCOUNT() uint32 {
	return (volatile.LoadUint32(&o.MFSR.Reg) & 0x70000) >> 16
}

// LPI2C.MTDR: Master Transmit Data Register
func (o *LPI2C_Type) SetMTDR_DATA(value uint32) {
	volatile.StoreUint32(&o.MTDR.Reg, volatile.LoadUint32(&o.MTDR.Reg)&^(0xff)|value)
}
func (o *LPI2C_Type) GetMTDR_DATA() uint32 {
	return volatile.LoadUint32(&o.MTDR.Reg) & 0xff
}
func (o *LPI2C_Type) SetMTDR_CMD(value uint32) {
	volatile.StoreUint32(&o.MTDR.Reg, volatile.LoadUint32(&o.MTDR.Reg)&^(0x700)|value<<8)
}
func (o *LPI2C_Type) GetMTDR_CMD() uint32 {
	return (volatile.LoadUint32(&o.MTDR.Reg) & 0x700) >> 8
}

// LPI2C.MRDR: Master Receive Data Register
func (o *LPI2C_Type) SetMRDR_DATA(value uint32) {
	volatile.StoreUint32(&o.MRDR.Reg, volatile.LoadUint32(&o.MRDR.Reg)&^(0xff)|value)
}
func (o *LPI2C_Type) GetMRDR_DATA() uint32 {
	return volatile.LoadUint32(&o.MRDR.Reg) & 0xff
}
func (o *LPI2C_Type) SetMRDR_RXEMPTY(value uint32) {
	volatile.StoreUint32(&o.MRDR.Reg, volatile.LoadUint32(&o.MRDR.Reg)&^(0x4000)|value<<14)
}
func (o *LPI2C_Type) GetMRDR_RXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.MRDR.Reg) & 0x4000) >> 14
}

// LPI2C.SCR: Slave Control Register
func (o *LPI2C_Type) SetSCR_SEN(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x1)|value)
}
func (o *LPI2C_Type) GetSCR_SEN() uint32 {
	return volatile.LoadUint32(&o.SCR.Reg) & 0x1
}
func (o *LPI2C_Type) SetSCR_RST(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x2)|value<<1)
}
func (o *LPI2C_Type) GetSCR_RST() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x2) >> 1
}
func (o *LPI2C_Type) SetSCR_FILTEN(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *LPI2C_Type) GetSCR_FILTEN() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x10) >> 4
}
func (o *LPI2C_Type) SetSCR_FILTDZ(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x20)|value<<5)
}
func (o *LPI2C_Type) GetSCR_FILTDZ() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x20) >> 5
}
func (o *LPI2C_Type) SetSCR_RTF(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x100)|value<<8)
}
func (o *LPI2C_Type) GetSCR_RTF() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x100) >> 8
}
func (o *LPI2C_Type) SetSCR_RRF(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x200)|value<<9)
}
func (o *LPI2C_Type) GetSCR_RRF() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x200) >> 9
}

// LPI2C.SSR: Slave Status Register
func (o *LPI2C_Type) SetSSR_TDF(value uint32) {
	volatile.StoreUint32(&o.SSR.Reg, volatile.LoadUint32(&o.SSR.Reg)&^(0x1)|value)
}
func (o *LPI2C_Type) GetSSR_TDF() uint32 {
	return volatile.LoadUint32(&o.SSR.Reg) & 0x1
}
func (o *LPI2C_Type) SetSSR_RDF(value uint32) {
	volatile.StoreUint32(&o.SSR.Reg, volatile.LoadUint32(&o.SSR.Reg)&^(0x2)|value<<1)
}
func (o *LPI2C_Type) GetSSR_RDF() uint32 {
	return (volatile.LoadUint32(&o.SSR.Reg) & 0x2) >> 1
}
func (o *LPI2C_Type) SetSSR_AVF(value uint32) {
	volatile.StoreUint32(&o.SSR.Reg, volatile.LoadUint32(&o.SSR.Reg)&^(0x4)|value<<2)
}
func (o *LPI2C_Type) GetSSR_AVF() uint32 {
	return (volatile.LoadUint32(&o.SSR.Reg) & 0x4) >> 2
}
func (o *LPI2C_Type) SetSSR_TAF(value uint32) {
	volatile.StoreUint32(&o.SSR.Reg, volatile.LoadUint32(&o.SSR.Reg)&^(0x8)|value<<3)
}
func (o *LPI2C_Type) GetSSR_TAF() uint32 {
	return (volatile.LoadUint32(&o.SSR.Reg) & 0x8) >> 3
}
func (o *LPI2C_Type) SetSSR_RSF(value uint32) {
	volatile.StoreUint32(&o.SSR.Reg, volatile.LoadUint32(&o.SSR.Reg)&^(0x100)|value<<8)
}
func (o *LPI2C_Type) GetSSR_RSF() uint32 {
	return (volatile.LoadUint32(&o.SSR.Reg) & 0x100) >> 8
}
func (o *LPI2C_Type) SetSSR_SDF(value uint32) {
	volatile.StoreUint32(&o.SSR.Reg, volatile.LoadUint32(&o.SSR.Reg)&^(0x200)|value<<9)
}
func (o *LPI2C_Type) GetSSR_SDF() uint32 {
	return (volatile.LoadUint32(&o.SSR.Reg) & 0x200) >> 9
}
func (o *LPI2C_Type) SetSSR_BEF(value uint32) {
	volatile.StoreUint32(&o.SSR.Reg, volatile.LoadUint32(&o.SSR.Reg)&^(0x400)|value<<10)
}
func (o *LPI2C_Type) GetSSR_BEF() uint32 {
	return (volatile.LoadUint32(&o.SSR.Reg) & 0x400) >> 10
}
func (o *LPI2C_Type) SetSSR_FEF(value uint32) {
	volatile.StoreUint32(&o.SSR.Reg, volatile.LoadUint32(&o.SSR.Reg)&^(0x800)|value<<11)
}
func (o *LPI2C_Type) GetSSR_FEF() uint32 {
	return (volatile.LoadUint32(&o.SSR.Reg) & 0x800) >> 11
}
func (o *LPI2C_Type) SetSSR_AM0F(value uint32) {
	volatile.StoreUint32(&o.SSR.Reg, volatile.LoadUint32(&o.SSR.Reg)&^(0x1000)|value<<12)
}
func (o *LPI2C_Type) GetSSR_AM0F() uint32 {
	return (volatile.LoadUint32(&o.SSR.Reg) & 0x1000) >> 12
}
func (o *LPI2C_Type) SetSSR_AM1F(value uint32) {
	volatile.StoreUint32(&o.SSR.Reg, volatile.LoadUint32(&o.SSR.Reg)&^(0x2000)|value<<13)
}
func (o *LPI2C_Type) GetSSR_AM1F() uint32 {
	return (volatile.LoadUint32(&o.SSR.Reg) & 0x2000) >> 13
}
func (o *LPI2C_Type) SetSSR_GCF(value uint32) {
	volatile.StoreUint32(&o.SSR.Reg, volatile.LoadUint32(&o.SSR.Reg)&^(0x4000)|value<<14)
}
func (o *LPI2C_Type) GetSSR_GCF() uint32 {
	return (volatile.LoadUint32(&o.SSR.Reg) & 0x4000) >> 14
}
func (o *LPI2C_Type) SetSSR_SARF(value uint32) {
	volatile.StoreUint32(&o.SSR.Reg, volatile.LoadUint32(&o.SSR.Reg)&^(0x8000)|value<<15)
}
func (o *LPI2C_Type) GetSSR_SARF() uint32 {
	return (volatile.LoadUint32(&o.SSR.Reg) & 0x8000) >> 15
}
func (o *LPI2C_Type) SetSSR_SBF(value uint32) {
	volatile.StoreUint32(&o.SSR.Reg, volatile.LoadUint32(&o.SSR.Reg)&^(0x1000000)|value<<24)
}
func (o *LPI2C_Type) GetSSR_SBF() uint32 {
	return (volatile.LoadUint32(&o.SSR.Reg) & 0x1000000) >> 24
}
func (o *LPI2C_Type) SetSSR_BBF(value uint32) {
	volatile.StoreUint32(&o.SSR.Reg, volatile.LoadUint32(&o.SSR.Reg)&^(0x2000000)|value<<25)
}
func (o *LPI2C_Type) GetSSR_BBF() uint32 {
	return (volatile.LoadUint32(&o.SSR.Reg) & 0x2000000) >> 25
}

// LPI2C.SIER: Slave Interrupt Enable Register
func (o *LPI2C_Type) SetSIER_TDIE(value uint32) {
	volatile.StoreUint32(&o.SIER.Reg, volatile.LoadUint32(&o.SIER.Reg)&^(0x1)|value)
}
func (o *LPI2C_Type) GetSIER_TDIE() uint32 {
	return volatile.LoadUint32(&o.SIER.Reg) & 0x1
}
func (o *LPI2C_Type) SetSIER_RDIE(value uint32) {
	volatile.StoreUint32(&o.SIER.Reg, volatile.LoadUint32(&o.SIER.Reg)&^(0x2)|value<<1)
}
func (o *LPI2C_Type) GetSIER_RDIE() uint32 {
	return (volatile.LoadUint32(&o.SIER.Reg) & 0x2) >> 1
}
func (o *LPI2C_Type) SetSIER_AVIE(value uint32) {
	volatile.StoreUint32(&o.SIER.Reg, volatile.LoadUint32(&o.SIER.Reg)&^(0x4)|value<<2)
}
func (o *LPI2C_Type) GetSIER_AVIE() uint32 {
	return (volatile.LoadUint32(&o.SIER.Reg) & 0x4) >> 2
}
func (o *LPI2C_Type) SetSIER_TAIE(value uint32) {
	volatile.StoreUint32(&o.SIER.Reg, volatile.LoadUint32(&o.SIER.Reg)&^(0x8)|value<<3)
}
func (o *LPI2C_Type) GetSIER_TAIE() uint32 {
	return (volatile.LoadUint32(&o.SIER.Reg) & 0x8) >> 3
}
func (o *LPI2C_Type) SetSIER_RSIE(value uint32) {
	volatile.StoreUint32(&o.SIER.Reg, volatile.LoadUint32(&o.SIER.Reg)&^(0x100)|value<<8)
}
func (o *LPI2C_Type) GetSIER_RSIE() uint32 {
	return (volatile.LoadUint32(&o.SIER.Reg) & 0x100) >> 8
}
func (o *LPI2C_Type) SetSIER_SDIE(value uint32) {
	volatile.StoreUint32(&o.SIER.Reg, volatile.LoadUint32(&o.SIER.Reg)&^(0x200)|value<<9)
}
func (o *LPI2C_Type) GetSIER_SDIE() uint32 {
	return (volatile.LoadUint32(&o.SIER.Reg) & 0x200) >> 9
}
func (o *LPI2C_Type) SetSIER_BEIE(value uint32) {
	volatile.StoreUint32(&o.SIER.Reg, volatile.LoadUint32(&o.SIER.Reg)&^(0x400)|value<<10)
}
func (o *LPI2C_Type) GetSIER_BEIE() uint32 {
	return (volatile.LoadUint32(&o.SIER.Reg) & 0x400) >> 10
}
func (o *LPI2C_Type) SetSIER_FEIE(value uint32) {
	volatile.StoreUint32(&o.SIER.Reg, volatile.LoadUint32(&o.SIER.Reg)&^(0x800)|value<<11)
}
func (o *LPI2C_Type) GetSIER_FEIE() uint32 {
	return (volatile.LoadUint32(&o.SIER.Reg) & 0x800) >> 11
}
func (o *LPI2C_Type) SetSIER_AM0IE(value uint32) {
	volatile.StoreUint32(&o.SIER.Reg, volatile.LoadUint32(&o.SIER.Reg)&^(0x1000)|value<<12)
}
func (o *LPI2C_Type) GetSIER_AM0IE() uint32 {
	return (volatile.LoadUint32(&o.SIER.Reg) & 0x1000) >> 12
}
func (o *LPI2C_Type) SetSIER_AM1F(value uint32) {
	volatile.StoreUint32(&o.SIER.Reg, volatile.LoadUint32(&o.SIER.Reg)&^(0x2000)|value<<13)
}
func (o *LPI2C_Type) GetSIER_AM1F() uint32 {
	return (volatile.LoadUint32(&o.SIER.Reg) & 0x2000) >> 13
}
func (o *LPI2C_Type) SetSIER_GCIE(value uint32) {
	volatile.StoreUint32(&o.SIER.Reg, volatile.LoadUint32(&o.SIER.Reg)&^(0x4000)|value<<14)
}
func (o *LPI2C_Type) GetSIER_GCIE() uint32 {
	return (volatile.LoadUint32(&o.SIER.Reg) & 0x4000) >> 14
}
func (o *LPI2C_Type) SetSIER_SARIE(value uint32) {
	volatile.StoreUint32(&o.SIER.Reg, volatile.LoadUint32(&o.SIER.Reg)&^(0x8000)|value<<15)
}
func (o *LPI2C_Type) GetSIER_SARIE() uint32 {
	return (volatile.LoadUint32(&o.SIER.Reg) & 0x8000) >> 15
}

// LPI2C.SDER: Slave DMA Enable Register
func (o *LPI2C_Type) SetSDER_TDDE(value uint32) {
	volatile.StoreUint32(&o.SDER.Reg, volatile.LoadUint32(&o.SDER.Reg)&^(0x1)|value)
}
func (o *LPI2C_Type) GetSDER_TDDE() uint32 {
	return volatile.LoadUint32(&o.SDER.Reg) & 0x1
}
func (o *LPI2C_Type) SetSDER_RDDE(value uint32) {
	volatile.StoreUint32(&o.SDER.Reg, volatile.LoadUint32(&o.SDER.Reg)&^(0x2)|value<<1)
}
func (o *LPI2C_Type) GetSDER_RDDE() uint32 {
	return (volatile.LoadUint32(&o.SDER.Reg) & 0x2) >> 1
}
func (o *LPI2C_Type) SetSDER_AVDE(value uint32) {
	volatile.StoreUint32(&o.SDER.Reg, volatile.LoadUint32(&o.SDER.Reg)&^(0x4)|value<<2)
}
func (o *LPI2C_Type) GetSDER_AVDE() uint32 {
	return (volatile.LoadUint32(&o.SDER.Reg) & 0x4) >> 2
}

// LPI2C.SCFGR1: Slave Configuration Register 1
func (o *LPI2C_Type) SetSCFGR1_ADRSTALL(value uint32) {
	volatile.StoreUint32(&o.SCFGR1.Reg, volatile.LoadUint32(&o.SCFGR1.Reg)&^(0x1)|value)
}
func (o *LPI2C_Type) GetSCFGR1_ADRSTALL() uint32 {
	return volatile.LoadUint32(&o.SCFGR1.Reg) & 0x1
}
func (o *LPI2C_Type) SetSCFGR1_RXSTALL(value uint32) {
	volatile.StoreUint32(&o.SCFGR1.Reg, volatile.LoadUint32(&o.SCFGR1.Reg)&^(0x2)|value<<1)
}
func (o *LPI2C_Type) GetSCFGR1_RXSTALL() uint32 {
	return (volatile.LoadUint32(&o.SCFGR1.Reg) & 0x2) >> 1
}
func (o *LPI2C_Type) SetSCFGR1_TXDSTALL(value uint32) {
	volatile.StoreUint32(&o.SCFGR1.Reg, volatile.LoadUint32(&o.SCFGR1.Reg)&^(0x4)|value<<2)
}
func (o *LPI2C_Type) GetSCFGR1_TXDSTALL() uint32 {
	return (volatile.LoadUint32(&o.SCFGR1.Reg) & 0x4) >> 2
}
func (o *LPI2C_Type) SetSCFGR1_ACKSTALL(value uint32) {
	volatile.StoreUint32(&o.SCFGR1.Reg, volatile.LoadUint32(&o.SCFGR1.Reg)&^(0x8)|value<<3)
}
func (o *LPI2C_Type) GetSCFGR1_ACKSTALL() uint32 {
	return (volatile.LoadUint32(&o.SCFGR1.Reg) & 0x8) >> 3
}
func (o *LPI2C_Type) SetSCFGR1_GCEN(value uint32) {
	volatile.StoreUint32(&o.SCFGR1.Reg, volatile.LoadUint32(&o.SCFGR1.Reg)&^(0x100)|value<<8)
}
func (o *LPI2C_Type) GetSCFGR1_GCEN() uint32 {
	return (volatile.LoadUint32(&o.SCFGR1.Reg) & 0x100) >> 8
}
func (o *LPI2C_Type) SetSCFGR1_SAEN(value uint32) {
	volatile.StoreUint32(&o.SCFGR1.Reg, volatile.LoadUint32(&o.SCFGR1.Reg)&^(0x200)|value<<9)
}
func (o *LPI2C_Type) GetSCFGR1_SAEN() uint32 {
	return (volatile.LoadUint32(&o.SCFGR1.Reg) & 0x200) >> 9
}
func (o *LPI2C_Type) SetSCFGR1_TXCFG(value uint32) {
	volatile.StoreUint32(&o.SCFGR1.Reg, volatile.LoadUint32(&o.SCFGR1.Reg)&^(0x400)|value<<10)
}
func (o *LPI2C_Type) GetSCFGR1_TXCFG() uint32 {
	return (volatile.LoadUint32(&o.SCFGR1.Reg) & 0x400) >> 10
}
func (o *LPI2C_Type) SetSCFGR1_RXCFG(value uint32) {
	volatile.StoreUint32(&o.SCFGR1.Reg, volatile.LoadUint32(&o.SCFGR1.Reg)&^(0x800)|value<<11)
}
func (o *LPI2C_Type) GetSCFGR1_RXCFG() uint32 {
	return (volatile.LoadUint32(&o.SCFGR1.Reg) & 0x800) >> 11
}
func (o *LPI2C_Type) SetSCFGR1_IGNACK(value uint32) {
	volatile.StoreUint32(&o.SCFGR1.Reg, volatile.LoadUint32(&o.SCFGR1.Reg)&^(0x1000)|value<<12)
}
func (o *LPI2C_Type) GetSCFGR1_IGNACK() uint32 {
	return (volatile.LoadUint32(&o.SCFGR1.Reg) & 0x1000) >> 12
}
func (o *LPI2C_Type) SetSCFGR1_HSMEN(value uint32) {
	volatile.StoreUint32(&o.SCFGR1.Reg, volatile.LoadUint32(&o.SCFGR1.Reg)&^(0x2000)|value<<13)
}
func (o *LPI2C_Type) GetSCFGR1_HSMEN() uint32 {
	return (volatile.LoadUint32(&o.SCFGR1.Reg) & 0x2000) >> 13
}
func (o *LPI2C_Type) SetSCFGR1_ADDRCFG(value uint32) {
	volatile.StoreUint32(&o.SCFGR1.Reg, volatile.LoadUint32(&o.SCFGR1.Reg)&^(0x70000)|value<<16)
}
func (o *LPI2C_Type) GetSCFGR1_ADDRCFG() uint32 {
	return (volatile.LoadUint32(&o.SCFGR1.Reg) & 0x70000) >> 16
}

// LPI2C.SCFGR2: Slave Configuration Register 2
func (o *LPI2C_Type) SetSCFGR2_CLKHOLD(value uint32) {
	volatile.StoreUint32(&o.SCFGR2.Reg, volatile.LoadUint32(&o.SCFGR2.Reg)&^(0xf)|value)
}
func (o *LPI2C_Type) GetSCFGR2_CLKHOLD() uint32 {
	return volatile.LoadUint32(&o.SCFGR2.Reg) & 0xf
}
func (o *LPI2C_Type) SetSCFGR2_DATAVD(value uint32) {
	volatile.StoreUint32(&o.SCFGR2.Reg, volatile.LoadUint32(&o.SCFGR2.Reg)&^(0x3f00)|value<<8)
}
func (o *LPI2C_Type) GetSCFGR2_DATAVD() uint32 {
	return (volatile.LoadUint32(&o.SCFGR2.Reg) & 0x3f00) >> 8
}
func (o *LPI2C_Type) SetSCFGR2_FILTSCL(value uint32) {
	volatile.StoreUint32(&o.SCFGR2.Reg, volatile.LoadUint32(&o.SCFGR2.Reg)&^(0xf0000)|value<<16)
}
func (o *LPI2C_Type) GetSCFGR2_FILTSCL() uint32 {
	return (volatile.LoadUint32(&o.SCFGR2.Reg) & 0xf0000) >> 16
}
func (o *LPI2C_Type) SetSCFGR2_FILTSDA(value uint32) {
	volatile.StoreUint32(&o.SCFGR2.Reg, volatile.LoadUint32(&o.SCFGR2.Reg)&^(0xf000000)|value<<24)
}
func (o *LPI2C_Type) GetSCFGR2_FILTSDA() uint32 {
	return (volatile.LoadUint32(&o.SCFGR2.Reg) & 0xf000000) >> 24
}

// LPI2C.SAMR: Slave Address Match Register
func (o *LPI2C_Type) SetSAMR_ADDR0(value uint32) {
	volatile.StoreUint32(&o.SAMR.Reg, volatile.LoadUint32(&o.SAMR.Reg)&^(0x7fe)|value<<1)
}
func (o *LPI2C_Type) GetSAMR_ADDR0() uint32 {
	return (volatile.LoadUint32(&o.SAMR.Reg) & 0x7fe) >> 1
}
func (o *LPI2C_Type) SetSAMR_ADDR1(value uint32) {
	volatile.StoreUint32(&o.SAMR.Reg, volatile.LoadUint32(&o.SAMR.Reg)&^(0x7fe0000)|value<<17)
}
func (o *LPI2C_Type) GetSAMR_ADDR1() uint32 {
	return (volatile.LoadUint32(&o.SAMR.Reg) & 0x7fe0000) >> 17
}

// LPI2C.SASR: Slave Address Status Register
func (o *LPI2C_Type) SetSASR_RADDR(value uint32) {
	volatile.StoreUint32(&o.SASR.Reg, volatile.LoadUint32(&o.SASR.Reg)&^(0x7ff)|value)
}
func (o *LPI2C_Type) GetSASR_RADDR() uint32 {
	return volatile.LoadUint32(&o.SASR.Reg) & 0x7ff
}
func (o *LPI2C_Type) SetSASR_ANV(value uint32) {
	volatile.StoreUint32(&o.SASR.Reg, volatile.LoadUint32(&o.SASR.Reg)&^(0x4000)|value<<14)
}
func (o *LPI2C_Type) GetSASR_ANV() uint32 {
	return (volatile.LoadUint32(&o.SASR.Reg) & 0x4000) >> 14
}

// LPI2C.STAR: Slave Transmit ACK Register
func (o *LPI2C_Type) SetSTAR_TXNACK(value uint32) {
	volatile.StoreUint32(&o.STAR.Reg, volatile.LoadUint32(&o.STAR.Reg)&^(0x1)|value)
}
func (o *LPI2C_Type) GetSTAR_TXNACK() uint32 {
	return volatile.LoadUint32(&o.STAR.Reg) & 0x1
}

// LPI2C.STDR: Slave Transmit Data Register
func (o *LPI2C_Type) SetSTDR_DATA(value uint32) {
	volatile.StoreUint32(&o.STDR.Reg, volatile.LoadUint32(&o.STDR.Reg)&^(0xff)|value)
}
func (o *LPI2C_Type) GetSTDR_DATA() uint32 {
	return volatile.LoadUint32(&o.STDR.Reg) & 0xff
}

// LPI2C.SRDR: Slave Receive Data Register
func (o *LPI2C_Type) SetSRDR_DATA(value uint32) {
	volatile.StoreUint32(&o.SRDR.Reg, volatile.LoadUint32(&o.SRDR.Reg)&^(0xff)|value)
}
func (o *LPI2C_Type) GetSRDR_DATA() uint32 {
	return volatile.LoadUint32(&o.SRDR.Reg) & 0xff
}
func (o *LPI2C_Type) SetSRDR_RXEMPTY(value uint32) {
	volatile.StoreUint32(&o.SRDR.Reg, volatile.LoadUint32(&o.SRDR.Reg)&^(0x4000)|value<<14)
}
func (o *LPI2C_Type) GetSRDR_RXEMPTY() uint32 {
	return (volatile.LoadUint32(&o.SRDR.Reg) & 0x4000) >> 14
}
func (o *LPI2C_Type) SetSRDR_SOF(value uint32) {
	volatile.StoreUint32(&o.SRDR.Reg, volatile.LoadUint32(&o.SRDR.Reg)&^(0x8000)|value<<15)
}
func (o *LPI2C_Type) GetSRDR_SOF() uint32 {
	return (volatile.LoadUint32(&o.SRDR.Reg) & 0x8000) >> 15
}

// FLEXIO
type FLEXIO_Type struct {
	VERID       volatile.Register32 // 0x0
	PARAM       volatile.Register32 // 0x4
	CTRL        volatile.Register32 // 0x8
	PIN         volatile.Register32 // 0xC
	SHIFTSTAT   volatile.Register32 // 0x10
	SHIFTERR    volatile.Register32 // 0x14
	TIMSTAT     volatile.Register32 // 0x18
	_           [4]byte
	SHIFTSIEN   volatile.Register32 // 0x20
	SHIFTEIEN   volatile.Register32 // 0x24
	TIMIEN      volatile.Register32 // 0x28
	_           [4]byte
	SHIFTSDEN   volatile.Register32 // 0x30
	_           [12]byte
	SHIFTSTATE  volatile.Register32 // 0x40
	_           [60]byte
	SHIFTCTL    [8]volatile.Register32 // 0x80
	_           [96]byte
	SHIFTCFG    [8]volatile.Register32 // 0x100
	_           [224]byte
	SHIFTBUF    [8]volatile.Register32 // 0x200
	_           [96]byte
	SHIFTBUFBIS [8]volatile.Register32 // 0x280
	_           [96]byte
	SHIFTBUFBYS [8]volatile.Register32 // 0x300
	_           [96]byte
	SHIFTBUFBBS [8]volatile.Register32 // 0x380
	_           [96]byte
	TIMCTL      [8]volatile.Register32 // 0x400
	_           [96]byte
	TIMCFG      [8]volatile.Register32 // 0x480
	_           [96]byte
	TIMCMP      [8]volatile.Register32 // 0x500
	_           [352]byte
	SHIFTBUFNBS [8]volatile.Register32 // 0x680
	_           [96]byte
	SHIFTBUFHWS [8]volatile.Register32 // 0x700
	_           [96]byte
	SHIFTBUFNIS [8]volatile.Register32 // 0x780
}

// FLEXIO.VERID: Version ID Register
func (o *FLEXIO_Type) SetVERID_FEATURE(value uint32) {
	volatile.StoreUint32(&o.VERID.Reg, volatile.LoadUint32(&o.VERID.Reg)&^(0xffff)|value)
}
func (o *FLEXIO_Type) GetVERID_FEATURE() uint32 {
	return volatile.LoadUint32(&o.VERID.Reg) & 0xffff
}
func (o *FLEXIO_Type) SetVERID_MINOR(value uint32) {
	volatile.StoreUint32(&o.VERID.Reg, volatile.LoadUint32(&o.VERID.Reg)&^(0xff0000)|value<<16)
}
func (o *FLEXIO_Type) GetVERID_MINOR() uint32 {
	return (volatile.LoadUint32(&o.VERID.Reg) & 0xff0000) >> 16
}
func (o *FLEXIO_Type) SetVERID_MAJOR(value uint32) {
	volatile.StoreUint32(&o.VERID.Reg, volatile.LoadUint32(&o.VERID.Reg)&^(0xff000000)|value<<24)
}
func (o *FLEXIO_Type) GetVERID_MAJOR() uint32 {
	return (volatile.LoadUint32(&o.VERID.Reg) & 0xff000000) >> 24
}

// FLEXIO.PARAM: Parameter Register
func (o *FLEXIO_Type) SetPARAM_SHIFTER(value uint32) {
	volatile.StoreUint32(&o.PARAM.Reg, volatile.LoadUint32(&o.PARAM.Reg)&^(0xff)|value)
}
func (o *FLEXIO_Type) GetPARAM_SHIFTER() uint32 {
	return volatile.LoadUint32(&o.PARAM.Reg) & 0xff
}
func (o *FLEXIO_Type) SetPARAM_TIMER(value uint32) {
	volatile.StoreUint32(&o.PARAM.Reg, volatile.LoadUint32(&o.PARAM.Reg)&^(0xff00)|value<<8)
}
func (o *FLEXIO_Type) GetPARAM_TIMER() uint32 {
	return (volatile.LoadUint32(&o.PARAM.Reg) & 0xff00) >> 8
}
func (o *FLEXIO_Type) SetPARAM_PIN(value uint32) {
	volatile.StoreUint32(&o.PARAM.Reg, volatile.LoadUint32(&o.PARAM.Reg)&^(0xff0000)|value<<16)
}
func (o *FLEXIO_Type) GetPARAM_PIN() uint32 {
	return (volatile.LoadUint32(&o.PARAM.Reg) & 0xff0000) >> 16
}
func (o *FLEXIO_Type) SetPARAM_TRIGGER(value uint32) {
	volatile.StoreUint32(&o.PARAM.Reg, volatile.LoadUint32(&o.PARAM.Reg)&^(0xff000000)|value<<24)
}
func (o *FLEXIO_Type) GetPARAM_TRIGGER() uint32 {
	return (volatile.LoadUint32(&o.PARAM.Reg) & 0xff000000) >> 24
}

// FLEXIO.CTRL: FlexIO Control Register
func (o *FLEXIO_Type) SetCTRL_FLEXEN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x1)|value)
}
func (o *FLEXIO_Type) GetCTRL_FLEXEN() uint32 {
	return volatile.LoadUint32(&o.CTRL.Reg) & 0x1
}
func (o *FLEXIO_Type) SetCTRL_SWRST(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x2)|value<<1)
}
func (o *FLEXIO_Type) GetCTRL_SWRST() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x2) >> 1
}
func (o *FLEXIO_Type) SetCTRL_FASTACC(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x4)|value<<2)
}
func (o *FLEXIO_Type) GetCTRL_FASTACC() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x4) >> 2
}
func (o *FLEXIO_Type) SetCTRL_DBGE(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x40000000)|value<<30)
}
func (o *FLEXIO_Type) GetCTRL_DBGE() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x40000000) >> 30
}
func (o *FLEXIO_Type) SetCTRL_DOZEN(value uint32) {
	volatile.StoreUint32(&o.CTRL.Reg, volatile.LoadUint32(&o.CTRL.Reg)&^(0x80000000)|value<<31)
}
func (o *FLEXIO_Type) GetCTRL_DOZEN() uint32 {
	return (volatile.LoadUint32(&o.CTRL.Reg) & 0x80000000) >> 31
}

// FLEXIO.PIN: Pin State Register
func (o *FLEXIO_Type) SetPIN(value uint32) {
	volatile.StoreUint32(&o.PIN.Reg, value)
}
func (o *FLEXIO_Type) GetPIN() uint32 {
	return volatile.LoadUint32(&o.PIN.Reg)
}

// FLEXIO.SHIFTSTAT: Shifter Status Register
func (o *FLEXIO_Type) SetSHIFTSTAT_SSF(value uint32) {
	volatile.StoreUint32(&o.SHIFTSTAT.Reg, volatile.LoadUint32(&o.SHIFTSTAT.Reg)&^(0xff)|value)
}
func (o *FLEXIO_Type) GetSHIFTSTAT_SSF() uint32 {
	return volatile.LoadUint32(&o.SHIFTSTAT.Reg) & 0xff
}

// FLEXIO.SHIFTERR: Shifter Error Register
func (o *FLEXIO_Type) SetSHIFTERR_SEF(value uint32) {
	volatile.StoreUint32(&o.SHIFTERR.Reg, volatile.LoadUint32(&o.SHIFTERR.Reg)&^(0xff)|value)
}
func (o *FLEXIO_Type) GetSHIFTERR_SEF() uint32 {
	return volatile.LoadUint32(&o.SHIFTERR.Reg) & 0xff
}

// FLEXIO.TIMSTAT: Timer Status Register
func (o *FLEXIO_Type) SetTIMSTAT_TSF(value uint32) {
	volatile.StoreUint32(&o.TIMSTAT.Reg, volatile.LoadUint32(&o.TIMSTAT.Reg)&^(0xff)|value)
}
func (o *FLEXIO_Type) GetTIMSTAT_TSF() uint32 {
	return volatile.LoadUint32(&o.TIMSTAT.Reg) & 0xff
}

// FLEXIO.SHIFTSIEN: Shifter Status Interrupt Enable
func (o *FLEXIO_Type) SetSHIFTSIEN_SSIE(value uint32) {
	volatile.StoreUint32(&o.SHIFTSIEN.Reg, volatile.LoadUint32(&o.SHIFTSIEN.Reg)&^(0xff)|value)
}
func (o *FLEXIO_Type) GetSHIFTSIEN_SSIE() uint32 {
	return volatile.LoadUint32(&o.SHIFTSIEN.Reg) & 0xff
}

// FLEXIO.SHIFTEIEN: Shifter Error Interrupt Enable
func (o *FLEXIO_Type) SetSHIFTEIEN_SEIE(value uint32) {
	volatile.StoreUint32(&o.SHIFTEIEN.Reg, volatile.LoadUint32(&o.SHIFTEIEN.Reg)&^(0xff)|value)
}
func (o *FLEXIO_Type) GetSHIFTEIEN_SEIE() uint32 {
	return volatile.LoadUint32(&o.SHIFTEIEN.Reg) & 0xff
}

// FLEXIO.TIMIEN: Timer Interrupt Enable Register
func (o *FLEXIO_Type) SetTIMIEN_TEIE(value uint32) {
	volatile.StoreUint32(&o.TIMIEN.Reg, volatile.LoadUint32(&o.TIMIEN.Reg)&^(0xff)|value)
}
func (o *FLEXIO_Type) GetTIMIEN_TEIE() uint32 {
	return volatile.LoadUint32(&o.TIMIEN.Reg) & 0xff
}

// FLEXIO.SHIFTSDEN: Shifter Status DMA Enable
func (o *FLEXIO_Type) SetSHIFTSDEN_SSDE(value uint32) {
	volatile.StoreUint32(&o.SHIFTSDEN.Reg, volatile.LoadUint32(&o.SHIFTSDEN.Reg)&^(0xff)|value)
}
func (o *FLEXIO_Type) GetSHIFTSDEN_SSDE() uint32 {
	return volatile.LoadUint32(&o.SHIFTSDEN.Reg) & 0xff
}

// FLEXIO.SHIFTSTATE: Shifter State Register
func (o *FLEXIO_Type) SetSHIFTSTATE_STATE(value uint32) {
	volatile.StoreUint32(&o.SHIFTSTATE.Reg, volatile.LoadUint32(&o.SHIFTSTATE.Reg)&^(0x7)|value)
}
func (o *FLEXIO_Type) GetSHIFTSTATE_STATE() uint32 {
	return volatile.LoadUint32(&o.SHIFTSTATE.Reg) & 0x7
}

// FLEXIO.SHIFTCTL: Shifter Control N Register
func (o *FLEXIO_Type) SetSHIFTCTL_SMOD(idx int, value uint32) {
	volatile.StoreUint32(&o.SHIFTCTL[idx].Reg, volatile.LoadUint32(&o.SHIFTCTL[idx].Reg)&^(0x7)|value)
}
func (o *FLEXIO_Type) GetSHIFTCTL_SMOD(idx int) uint32 {
	return volatile.LoadUint32(&o.SHIFTCTL[idx].Reg) & 0x7
}
func (o *FLEXIO_Type) SetSHIFTCTL_PINPOL(idx int, value uint32) {
	volatile.StoreUint32(&o.SHIFTCTL[idx].Reg, volatile.LoadUint32(&o.SHIFTCTL[idx].Reg)&^(0x80)|value<<7)
}
func (o *FLEXIO_Type) GetSHIFTCTL_PINPOL(idx int) uint32 {
	return (volatile.LoadUint32(&o.SHIFTCTL[idx].Reg) & 0x80) >> 7
}
func (o *FLEXIO_Type) SetSHIFTCTL_PINSEL(idx int, value uint32) {
	volatile.StoreUint32(&o.SHIFTCTL[idx].Reg, volatile.LoadUint32(&o.SHIFTCTL[idx].Reg)&^(0x1f00)|value<<8)
}
func (o *FLEXIO_Type) GetSHIFTCTL_PINSEL(idx int) uint32 {
	return (volatile.LoadUint32(&o.SHIFTCTL[idx].Reg) & 0x1f00) >> 8
}
func (o *FLEXIO_Type) SetSHIFTCTL_PINCFG(idx int, value uint32) {
	volatile.StoreUint32(&o.SHIFTCTL[idx].Reg, volatile.LoadUint32(&o.SHIFTCTL[idx].Reg)&^(0x30000)|value<<16)
}
func (o *FLEXIO_Type) GetSHIFTCTL_PINCFG(idx int) uint32 {
	return (volatile.LoadUint32(&o.SHIFTCTL[idx].Reg) & 0x30000) >> 16
}
func (o *FLEXIO_Type) SetSHIFTCTL_TIMPOL(idx int, value uint32) {
	volatile.StoreUint32(&o.SHIFTCTL[idx].Reg, volatile.LoadUint32(&o.SHIFTCTL[idx].Reg)&^(0x800000)|value<<23)
}
func (o *FLEXIO_Type) GetSHIFTCTL_TIMPOL(idx int) uint32 {
	return (volatile.LoadUint32(&o.SHIFTCTL[idx].Reg) & 0x800000) >> 23
}
func (o *FLEXIO_Type) SetSHIFTCTL_TIMSEL(idx int, value uint32) {
	volatile.StoreUint32(&o.SHIFTCTL[idx].Reg, volatile.LoadUint32(&o.SHIFTCTL[idx].Reg)&^(0x7000000)|value<<24)
}
func (o *FLEXIO_Type) GetSHIFTCTL_TIMSEL(idx int) uint32 {
	return (volatile.LoadUint32(&o.SHIFTCTL[idx].Reg) & 0x7000000) >> 24
}

// FLEXIO.SHIFTCFG: Shifter Configuration N Register
func (o *FLEXIO_Type) SetSHIFTCFG_SSTART(idx int, value uint32) {
	volatile.StoreUint32(&o.SHIFTCFG[idx].Reg, volatile.LoadUint32(&o.SHIFTCFG[idx].Reg)&^(0x3)|value)
}
func (o *FLEXIO_Type) GetSHIFTCFG_SSTART(idx int) uint32 {
	return volatile.LoadUint32(&o.SHIFTCFG[idx].Reg) & 0x3
}
func (o *FLEXIO_Type) SetSHIFTCFG_SSTOP(idx int, value uint32) {
	volatile.StoreUint32(&o.SHIFTCFG[idx].Reg, volatile.LoadUint32(&o.SHIFTCFG[idx].Reg)&^(0x30)|value<<4)
}
func (o *FLEXIO_Type) GetSHIFTCFG_SSTOP(idx int) uint32 {
	return (volatile.LoadUint32(&o.SHIFTCFG[idx].Reg) & 0x30) >> 4
}
func (o *FLEXIO_Type) SetSHIFTCFG_INSRC(idx int, value uint32) {
	volatile.StoreUint32(&o.SHIFTCFG[idx].Reg, volatile.LoadUint32(&o.SHIFTCFG[idx].Reg)&^(0x100)|value<<8)
}
func (o *FLEXIO_Type) GetSHIFTCFG_INSRC(idx int) uint32 {
	return (volatile.LoadUint32(&o.SHIFTCFG[idx].Reg) & 0x100) >> 8
}
func (o *FLEXIO_Type) SetSHIFTCFG_PWIDTH(idx int, value uint32) {
	volatile.StoreUint32(&o.SHIFTCFG[idx].Reg, volatile.LoadUint32(&o.SHIFTCFG[idx].Reg)&^(0x1f0000)|value<<16)
}
func (o *FLEXIO_Type) GetSHIFTCFG_PWIDTH(idx int) uint32 {
	return (volatile.LoadUint32(&o.SHIFTCFG[idx].Reg) & 0x1f0000) >> 16
}

// FLEXIO.SHIFTBUF: Shifter Buffer N Register
func (o *FLEXIO_Type) SetSHIFTBUF(idx int, value uint32) {
	volatile.StoreUint32(&o.SHIFTBUF[idx].Reg, value)
}
func (o *FLEXIO_Type) GetSHIFTBUF(idx int) uint32 {
	return volatile.LoadUint32(&o.SHIFTBUF[idx].Reg)
}

// FLEXIO.SHIFTBUFBIS: Shifter Buffer N Bit Swapped Register
func (o *FLEXIO_Type) SetSHIFTBUFBIS(idx int, value uint32) {
	volatile.StoreUint32(&o.SHIFTBUFBIS[idx].Reg, value)
}
func (o *FLEXIO_Type) GetSHIFTBUFBIS(idx int) uint32 {
	return volatile.LoadUint32(&o.SHIFTBUFBIS[idx].Reg)
}

// FLEXIO.SHIFTBUFBYS: Shifter Buffer N Byte Swapped Register
func (o *FLEXIO_Type) SetSHIFTBUFBYS(idx int, value uint32) {
	volatile.StoreUint32(&o.SHIFTBUFBYS[idx].Reg, value)
}
func (o *FLEXIO_Type) GetSHIFTBUFBYS(idx int) uint32 {
	return volatile.LoadUint32(&o.SHIFTBUFBYS[idx].Reg)
}

// FLEXIO.SHIFTBUFBBS: Shifter Buffer N Bit Byte Swapped Register
func (o *FLEXIO_Type) SetSHIFTBUFBBS(idx int, value uint32) {
	volatile.StoreUint32(&o.SHIFTBUFBBS[idx].Reg, value)
}
func (o *FLEXIO_Type) GetSHIFTBUFBBS(idx int) uint32 {
	return volatile.LoadUint32(&o.SHIFTBUFBBS[idx].Reg)
}

// FLEXIO.TIMCTL: Timer Control N Register
func (o *FLEXIO_Type) SetTIMCTL_TIMOD(idx int, value uint32) {
	volatile.StoreUint32(&o.TIMCTL[idx].Reg, volatile.LoadUint32(&o.TIMCTL[idx].Reg)&^(0x3)|value)
}
func (o *FLEXIO_Type) GetTIMCTL_TIMOD(idx int) uint32 {
	return volatile.LoadUint32(&o.TIMCTL[idx].Reg) & 0x3
}
func (o *FLEXIO_Type) SetTIMCTL_PINPOL(idx int, value uint32) {
	volatile.StoreUint32(&o.TIMCTL[idx].Reg, volatile.LoadUint32(&o.TIMCTL[idx].Reg)&^(0x80)|value<<7)
}
func (o *FLEXIO_Type) GetTIMCTL_PINPOL(idx int) uint32 {
	return (volatile.LoadUint32(&o.TIMCTL[idx].Reg) & 0x80) >> 7
}
func (o *FLEXIO_Type) SetTIMCTL_PINSEL(idx int, value uint32) {
	volatile.StoreUint32(&o.TIMCTL[idx].Reg, volatile.LoadUint32(&o.TIMCTL[idx].Reg)&^(0x1f00)|value<<8)
}
func (o *FLEXIO_Type) GetTIMCTL_PINSEL(idx int) uint32 {
	return (volatile.LoadUint32(&o.TIMCTL[idx].Reg) & 0x1f00) >> 8
}
func (o *FLEXIO_Type) SetTIMCTL_PINCFG(idx int, value uint32) {
	volatile.StoreUint32(&o.TIMCTL[idx].Reg, volatile.LoadUint32(&o.TIMCTL[idx].Reg)&^(0x30000)|value<<16)
}
func (o *FLEXIO_Type) GetTIMCTL_PINCFG(idx int) uint32 {
	return (volatile.LoadUint32(&o.TIMCTL[idx].Reg) & 0x30000) >> 16
}
func (o *FLEXIO_Type) SetTIMCTL_TRGSRC(idx int, value uint32) {
	volatile.StoreUint32(&o.TIMCTL[idx].Reg, volatile.LoadUint32(&o.TIMCTL[idx].Reg)&^(0x400000)|value<<22)
}
func (o *FLEXIO_Type) GetTIMCTL_TRGSRC(idx int) uint32 {
	return (volatile.LoadUint32(&o.TIMCTL[idx].Reg) & 0x400000) >> 22
}
func (o *FLEXIO_Type) SetTIMCTL_TRGPOL(idx int, value uint32) {
	volatile.StoreUint32(&o.TIMCTL[idx].Reg, volatile.LoadUint32(&o.TIMCTL[idx].Reg)&^(0x800000)|value<<23)
}
func (o *FLEXIO_Type) GetTIMCTL_TRGPOL(idx int) uint32 {
	return (volatile.LoadUint32(&o.TIMCTL[idx].Reg) & 0x800000) >> 23
}
func (o *FLEXIO_Type) SetTIMCTL_TRGSEL(idx int, value uint32) {
	volatile.StoreUint32(&o.TIMCTL[idx].Reg, volatile.LoadUint32(&o.TIMCTL[idx].Reg)&^(0x3f000000)|value<<24)
}
func (o *FLEXIO_Type) GetTIMCTL_TRGSEL(idx int) uint32 {
	return (volatile.LoadUint32(&o.TIMCTL[idx].Reg) & 0x3f000000) >> 24
}

// FLEXIO.TIMCFG: Timer Configuration N Register
func (o *FLEXIO_Type) SetTIMCFG_TSTART(idx int, value uint32) {
	volatile.StoreUint32(&o.TIMCFG[idx].Reg, volatile.LoadUint32(&o.TIMCFG[idx].Reg)&^(0x2)|value<<1)
}
func (o *FLEXIO_Type) GetTIMCFG_TSTART(idx int) uint32 {
	return (volatile.LoadUint32(&o.TIMCFG[idx].Reg) & 0x2) >> 1
}
func (o *FLEXIO_Type) SetTIMCFG_TSTOP(idx int, value uint32) {
	volatile.StoreUint32(&o.TIMCFG[idx].Reg, volatile.LoadUint32(&o.TIMCFG[idx].Reg)&^(0x30)|value<<4)
}
func (o *FLEXIO_Type) GetTIMCFG_TSTOP(idx int) uint32 {
	return (volatile.LoadUint32(&o.TIMCFG[idx].Reg) & 0x30) >> 4
}
func (o *FLEXIO_Type) SetTIMCFG_TIMENA(idx int, value uint32) {
	volatile.StoreUint32(&o.TIMCFG[idx].Reg, volatile.LoadUint32(&o.TIMCFG[idx].Reg)&^(0x700)|value<<8)
}
func (o *FLEXIO_Type) GetTIMCFG_TIMENA(idx int) uint32 {
	return (volatile.LoadUint32(&o.TIMCFG[idx].Reg) & 0x700) >> 8
}
func (o *FLEXIO_Type) SetTIMCFG_TIMDIS(idx int, value uint32) {
	volatile.StoreUint32(&o.TIMCFG[idx].Reg, volatile.LoadUint32(&o.TIMCFG[idx].Reg)&^(0x7000)|value<<12)
}
func (o *FLEXIO_Type) GetTIMCFG_TIMDIS(idx int) uint32 {
	return (volatile.LoadUint32(&o.TIMCFG[idx].Reg) & 0x7000) >> 12
}
func (o *FLEXIO_Type) SetTIMCFG_TIMRST(idx int, value uint32) {
	volatile.StoreUint32(&o.TIMCFG[idx].Reg, volatile.LoadUint32(&o.TIMCFG[idx].Reg)&^(0x70000)|value<<16)
}
func (o *FLEXIO_Type) GetTIMCFG_TIMRST(idx int) uint32 {
	return (volatile.LoadUint32(&o.TIMCFG[idx].Reg) & 0x70000) >> 16
}
func (o *FLEXIO_Type) SetTIMCFG_TIMDEC(idx int, value uint32) {
	volatile.StoreUint32(&o.TIMCFG[idx].Reg, volatile.LoadUint32(&o.TIMCFG[idx].Reg)&^(0x300000)|value<<20)
}
func (o *FLEXIO_Type) GetTIMCFG_TIMDEC(idx int) uint32 {
	return (volatile.LoadUint32(&o.TIMCFG[idx].Reg) & 0x300000) >> 20
}
func (o *FLEXIO_Type) SetTIMCFG_TIMOUT(idx int, value uint32) {
	volatile.StoreUint32(&o.TIMCFG[idx].Reg, volatile.LoadUint32(&o.TIMCFG[idx].Reg)&^(0x3000000)|value<<24)
}
func (o *FLEXIO_Type) GetTIMCFG_TIMOUT(idx int) uint32 {
	return (volatile.LoadUint32(&o.TIMCFG[idx].Reg) & 0x3000000) >> 24
}

// FLEXIO.TIMCMP: Timer Compare N Register
func (o *FLEXIO_Type) SetTIMCMP_CMP(idx int, value uint32) {
	volatile.StoreUint32(&o.TIMCMP[idx].Reg, volatile.LoadUint32(&o.TIMCMP[idx].Reg)&^(0xffff)|value)
}
func (o *FLEXIO_Type) GetTIMCMP_CMP(idx int) uint32 {
	return volatile.LoadUint32(&o.TIMCMP[idx].Reg) & 0xffff
}

// FLEXIO.SHIFTBUFNBS: Shifter Buffer N Nibble Byte Swapped Register
func (o *FLEXIO_Type) SetSHIFTBUFNBS(idx int, value uint32) {
	volatile.StoreUint32(&o.SHIFTBUFNBS[idx].Reg, value)
}
func (o *FLEXIO_Type) GetSHIFTBUFNBS(idx int) uint32 {
	return volatile.LoadUint32(&o.SHIFTBUFNBS[idx].Reg)
}

// FLEXIO.SHIFTBUFHWS: Shifter Buffer N Half Word Swapped Register
func (o *FLEXIO_Type) SetSHIFTBUFHWS(idx int, value uint32) {
	volatile.StoreUint32(&o.SHIFTBUFHWS[idx].Reg, value)
}
func (o *FLEXIO_Type) GetSHIFTBUFHWS(idx int) uint32 {
	return volatile.LoadUint32(&o.SHIFTBUFHWS[idx].Reg)
}

// FLEXIO.SHIFTBUFNIS: Shifter Buffer N Nibble Swapped Register
func (o *FLEXIO_Type) SetSHIFTBUFNIS(idx int, value uint32) {
	volatile.StoreUint32(&o.SHIFTBUFNIS[idx].Reg, value)
}
func (o *FLEXIO_Type) GetSHIFTBUFNIS(idx int) uint32 {
	return volatile.LoadUint32(&o.SHIFTBUFNIS[idx].Reg)
}

// GPIO
type GPIO_Type struct {
	DR        volatile.Register32 // 0x0
	GDIR      volatile.Register32 // 0x4
	PSR       volatile.Register32 // 0x8
	ICR1      volatile.Register32 // 0xC
	ICR2      volatile.Register32 // 0x10
	IMR       volatile.Register32 // 0x14
	ISR       volatile.Register32 // 0x18
	EDGE_SEL  volatile.Register32 // 0x1C
	_         [100]byte
	DR_SET    volatile.Register32 // 0x84
	DR_CLEAR  volatile.Register32 // 0x88
	DR_TOGGLE volatile.Register32 // 0x8C
}

// GPIO.DR: GPIO data register
func (o *GPIO_Type) SetDR(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, value)
}
func (o *GPIO_Type) GetDR() uint32 {
	return volatile.LoadUint32(&o.DR.Reg)
}

// GPIO.GDIR: GPIO direction register
func (o *GPIO_Type) SetGDIR(value uint32) {
	volatile.StoreUint32(&o.GDIR.Reg, value)
}
func (o *GPIO_Type) GetGDIR() uint32 {
	return volatile.LoadUint32(&o.GDIR.Reg)
}

// GPIO.PSR: GPIO pad status register
func (o *GPIO_Type) SetPSR(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, value)
}
func (o *GPIO_Type) GetPSR() uint32 {
	return volatile.LoadUint32(&o.PSR.Reg)
}

// GPIO.ICR1: GPIO interrupt configuration register1
func (o *GPIO_Type) SetICR1_ICR0(value uint32) {
	volatile.StoreUint32(&o.ICR1.Reg, volatile.LoadUint32(&o.ICR1.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetICR1_ICR0() uint32 {
	return volatile.LoadUint32(&o.ICR1.Reg) & 0x3
}
func (o *GPIO_Type) SetICR1(value uint32) {
	volatile.StoreUint32(&o.ICR1.Reg, volatile.LoadUint32(&o.ICR1.Reg)&^(0xc)|value<<2)
}
func (o *GPIO_Type) GetICR1() uint32 {
	return (volatile.LoadUint32(&o.ICR1.Reg) & 0xc) >> 2
}
func (o *GPIO_Type) SetICR1_ICR2(value uint32) {
	volatile.StoreUint32(&o.ICR1.Reg, volatile.LoadUint32(&o.ICR1.Reg)&^(0x30)|value<<4)
}
func (o *GPIO_Type) GetICR1_ICR2() uint32 {
	return (volatile.LoadUint32(&o.ICR1.Reg) & 0x30) >> 4
}
func (o *GPIO_Type) SetICR1_ICR3(value uint32) {
	volatile.StoreUint32(&o.ICR1.Reg, volatile.LoadUint32(&o.ICR1.Reg)&^(0xc0)|value<<6)
}
func (o *GPIO_Type) GetICR1_ICR3() uint32 {
	return (volatile.LoadUint32(&o.ICR1.Reg) & 0xc0) >> 6
}
func (o *GPIO_Type) SetICR1_ICR4(value uint32) {
	volatile.StoreUint32(&o.ICR1.Reg, volatile.LoadUint32(&o.ICR1.Reg)&^(0x300)|value<<8)
}
func (o *GPIO_Type) GetICR1_ICR4() uint32 {
	return (volatile.LoadUint32(&o.ICR1.Reg) & 0x300) >> 8
}
func (o *GPIO_Type) SetICR1_ICR5(value uint32) {
	volatile.StoreUint32(&o.ICR1.Reg, volatile.LoadUint32(&o.ICR1.Reg)&^(0xc00)|value<<10)
}
func (o *GPIO_Type) GetICR1_ICR5() uint32 {
	return (volatile.LoadUint32(&o.ICR1.Reg) & 0xc00) >> 10
}
func (o *GPIO_Type) SetICR1_ICR6(value uint32) {
	volatile.StoreUint32(&o.ICR1.Reg, volatile.LoadUint32(&o.ICR1.Reg)&^(0x3000)|value<<12)
}
func (o *GPIO_Type) GetICR1_ICR6() uint32 {
	return (volatile.LoadUint32(&o.ICR1.Reg) & 0x3000) >> 12
}
func (o *GPIO_Type) SetICR1_ICR7(value uint32) {
	volatile.StoreUint32(&o.ICR1.Reg, volatile.LoadUint32(&o.ICR1.Reg)&^(0xc000)|value<<14)
}
func (o *GPIO_Type) GetICR1_ICR7() uint32 {
	return (volatile.LoadUint32(&o.ICR1.Reg) & 0xc000) >> 14
}
func (o *GPIO_Type) SetICR1_ICR8(value uint32) {
	volatile.StoreUint32(&o.ICR1.Reg, volatile.LoadUint32(&o.ICR1.Reg)&^(0x30000)|value<<16)
}
func (o *GPIO_Type) GetICR1_ICR8() uint32 {
	return (volatile.LoadUint32(&o.ICR1.Reg) & 0x30000) >> 16
}
func (o *GPIO_Type) SetICR1_ICR9(value uint32) {
	volatile.StoreUint32(&o.ICR1.Reg, volatile.LoadUint32(&o.ICR1.Reg)&^(0xc0000)|value<<18)
}
func (o *GPIO_Type) GetICR1_ICR9() uint32 {
	return (volatile.LoadUint32(&o.ICR1.Reg) & 0xc0000) >> 18
}
func (o *GPIO_Type) SetICR1_ICR10(value uint32) {
	volatile.StoreUint32(&o.ICR1.Reg, volatile.LoadUint32(&o.ICR1.Reg)&^(0x300000)|value<<20)
}
func (o *GPIO_Type) GetICR1_ICR10() uint32 {
	return (volatile.LoadUint32(&o.ICR1.Reg) & 0x300000) >> 20
}
func (o *GPIO_Type) SetICR1_ICR11(value uint32) {
	volatile.StoreUint32(&o.ICR1.Reg, volatile.LoadUint32(&o.ICR1.Reg)&^(0xc00000)|value<<22)
}
func (o *GPIO_Type) GetICR1_ICR11() uint32 {
	return (volatile.LoadUint32(&o.ICR1.Reg) & 0xc00000) >> 22
}
func (o *GPIO_Type) SetICR1_ICR12(value uint32) {
	volatile.StoreUint32(&o.ICR1.Reg, volatile.LoadUint32(&o.ICR1.Reg)&^(0x3000000)|value<<24)
}
func (o *GPIO_Type) GetICR1_ICR12() uint32 {
	return (volatile.LoadUint32(&o.ICR1.Reg) & 0x3000000) >> 24
}
func (o *GPIO_Type) SetICR1_ICR13(value uint32) {
	volatile.StoreUint32(&o.ICR1.Reg, volatile.LoadUint32(&o.ICR1.Reg)&^(0xc000000)|value<<26)
}
func (o *GPIO_Type) GetICR1_ICR13() uint32 {
	return (volatile.LoadUint32(&o.ICR1.Reg) & 0xc000000) >> 26
}
func (o *GPIO_Type) SetICR1_ICR14(value uint32) {
	volatile.StoreUint32(&o.ICR1.Reg, volatile.LoadUint32(&o.ICR1.Reg)&^(0x30000000)|value<<28)
}
func (o *GPIO_Type) GetICR1_ICR14() uint32 {
	return (volatile.LoadUint32(&o.ICR1.Reg) & 0x30000000) >> 28
}
func (o *GPIO_Type) SetICR1_ICR15(value uint32) {
	volatile.StoreUint32(&o.ICR1.Reg, volatile.LoadUint32(&o.ICR1.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPIO_Type) GetICR1_ICR15() uint32 {
	return (volatile.LoadUint32(&o.ICR1.Reg) & 0xc0000000) >> 30
}

// GPIO.ICR2: GPIO interrupt configuration register2
func (o *GPIO_Type) SetICR2_ICR16(value uint32) {
	volatile.StoreUint32(&o.ICR2.Reg, volatile.LoadUint32(&o.ICR2.Reg)&^(0x3)|value)
}
func (o *GPIO_Type) GetICR2_ICR16() uint32 {
	return volatile.LoadUint32(&o.ICR2.Reg) & 0x3
}
func (o *GPIO_Type) SetICR2_ICR17(value uint32) {
	volatile.StoreUint32(&o.ICR2.Reg, volatile.LoadUint32(&o.ICR2.Reg)&^(0xc)|value<<2)
}
func (o *GPIO_Type) GetICR2_ICR17() uint32 {
	return (volatile.LoadUint32(&o.ICR2.Reg) & 0xc) >> 2
}
func (o *GPIO_Type) SetICR2_ICR18(value uint32) {
	volatile.StoreUint32(&o.ICR2.Reg, volatile.LoadUint32(&o.ICR2.Reg)&^(0x30)|value<<4)
}
func (o *GPIO_Type) GetICR2_ICR18() uint32 {
	return (volatile.LoadUint32(&o.ICR2.Reg) & 0x30) >> 4
}
func (o *GPIO_Type) SetICR2_ICR19(value uint32) {
	volatile.StoreUint32(&o.ICR2.Reg, volatile.LoadUint32(&o.ICR2.Reg)&^(0xc0)|value<<6)
}
func (o *GPIO_Type) GetICR2_ICR19() uint32 {
	return (volatile.LoadUint32(&o.ICR2.Reg) & 0xc0) >> 6
}
func (o *GPIO_Type) SetICR2_ICR20(value uint32) {
	volatile.StoreUint32(&o.ICR2.Reg, volatile.LoadUint32(&o.ICR2.Reg)&^(0x300)|value<<8)
}
func (o *GPIO_Type) GetICR2_ICR20() uint32 {
	return (volatile.LoadUint32(&o.ICR2.Reg) & 0x300) >> 8
}
func (o *GPIO_Type) SetICR2_ICR21(value uint32) {
	volatile.StoreUint32(&o.ICR2.Reg, volatile.LoadUint32(&o.ICR2.Reg)&^(0xc00)|value<<10)
}
func (o *GPIO_Type) GetICR2_ICR21() uint32 {
	return (volatile.LoadUint32(&o.ICR2.Reg) & 0xc00) >> 10
}
func (o *GPIO_Type) SetICR2_ICR22(value uint32) {
	volatile.StoreUint32(&o.ICR2.Reg, volatile.LoadUint32(&o.ICR2.Reg)&^(0x3000)|value<<12)
}
func (o *GPIO_Type) GetICR2_ICR22() uint32 {
	return (volatile.LoadUint32(&o.ICR2.Reg) & 0x3000) >> 12
}
func (o *GPIO_Type) SetICR2_ICR23(value uint32) {
	volatile.StoreUint32(&o.ICR2.Reg, volatile.LoadUint32(&o.ICR2.Reg)&^(0xc000)|value<<14)
}
func (o *GPIO_Type) GetICR2_ICR23() uint32 {
	return (volatile.LoadUint32(&o.ICR2.Reg) & 0xc000) >> 14
}
func (o *GPIO_Type) SetICR2_ICR24(value uint32) {
	volatile.StoreUint32(&o.ICR2.Reg, volatile.LoadUint32(&o.ICR2.Reg)&^(0x30000)|value<<16)
}
func (o *GPIO_Type) GetICR2_ICR24() uint32 {
	return (volatile.LoadUint32(&o.ICR2.Reg) & 0x30000) >> 16
}
func (o *GPIO_Type) SetICR2_ICR25(value uint32) {
	volatile.StoreUint32(&o.ICR2.Reg, volatile.LoadUint32(&o.ICR2.Reg)&^(0xc0000)|value<<18)
}
func (o *GPIO_Type) GetICR2_ICR25() uint32 {
	return (volatile.LoadUint32(&o.ICR2.Reg) & 0xc0000) >> 18
}
func (o *GPIO_Type) SetICR2_ICR26(value uint32) {
	volatile.StoreUint32(&o.ICR2.Reg, volatile.LoadUint32(&o.ICR2.Reg)&^(0x300000)|value<<20)
}
func (o *GPIO_Type) GetICR2_ICR26() uint32 {
	return (volatile.LoadUint32(&o.ICR2.Reg) & 0x300000) >> 20
}
func (o *GPIO_Type) SetICR2_ICR27(value uint32) {
	volatile.StoreUint32(&o.ICR2.Reg, volatile.LoadUint32(&o.ICR2.Reg)&^(0xc00000)|value<<22)
}
func (o *GPIO_Type) GetICR2_ICR27() uint32 {
	return (volatile.LoadUint32(&o.ICR2.Reg) & 0xc00000) >> 22
}
func (o *GPIO_Type) SetICR2_ICR28(value uint32) {
	volatile.StoreUint32(&o.ICR2.Reg, volatile.LoadUint32(&o.ICR2.Reg)&^(0x3000000)|value<<24)
}
func (o *GPIO_Type) GetICR2_ICR28() uint32 {
	return (volatile.LoadUint32(&o.ICR2.Reg) & 0x3000000) >> 24
}
func (o *GPIO_Type) SetICR2_ICR29(value uint32) {
	volatile.StoreUint32(&o.ICR2.Reg, volatile.LoadUint32(&o.ICR2.Reg)&^(0xc000000)|value<<26)
}
func (o *GPIO_Type) GetICR2_ICR29() uint32 {
	return (volatile.LoadUint32(&o.ICR2.Reg) & 0xc000000) >> 26
}
func (o *GPIO_Type) SetICR2_ICR30(value uint32) {
	volatile.StoreUint32(&o.ICR2.Reg, volatile.LoadUint32(&o.ICR2.Reg)&^(0x30000000)|value<<28)
}
func (o *GPIO_Type) GetICR2_ICR30() uint32 {
	return (volatile.LoadUint32(&o.ICR2.Reg) & 0x30000000) >> 28
}
func (o *GPIO_Type) SetICR2_ICR31(value uint32) {
	volatile.StoreUint32(&o.ICR2.Reg, volatile.LoadUint32(&o.ICR2.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPIO_Type) GetICR2_ICR31() uint32 {
	return (volatile.LoadUint32(&o.ICR2.Reg) & 0xc0000000) >> 30
}

// GPIO.IMR: GPIO interrupt mask register
func (o *GPIO_Type) SetIMR(value uint32) {
	volatile.StoreUint32(&o.IMR.Reg, value)
}
func (o *GPIO_Type) GetIMR() uint32 {
	return volatile.LoadUint32(&o.IMR.Reg)
}

// GPIO.ISR: GPIO interrupt status register
func (o *GPIO_Type) SetISR(value uint32) {
	volatile.StoreUint32(&o.ISR.Reg, value)
}
func (o *GPIO_Type) GetISR() uint32 {
	return volatile.LoadUint32(&o.ISR.Reg)
}

// GPIO.EDGE_SEL: GPIO edge select register
func (o *GPIO_Type) SetEDGE_SEL(value uint32) {
	volatile.StoreUint32(&o.EDGE_SEL.Reg, value)
}
func (o *GPIO_Type) GetEDGE_SEL() uint32 {
	return volatile.LoadUint32(&o.EDGE_SEL.Reg)
}

// GPIO.DR_SET: GPIO data register SET
func (o *GPIO_Type) SetDR_SET(value uint32) {
	volatile.StoreUint32(&o.DR_SET.Reg, value)
}
func (o *GPIO_Type) GetDR_SET() uint32 {
	return volatile.LoadUint32(&o.DR_SET.Reg)
}

// GPIO.DR_CLEAR: GPIO data register CLEAR
func (o *GPIO_Type) SetDR_CLEAR(value uint32) {
	volatile.StoreUint32(&o.DR_CLEAR.Reg, value)
}
func (o *GPIO_Type) GetDR_CLEAR() uint32 {
	return volatile.LoadUint32(&o.DR_CLEAR.Reg)
}

// GPIO.DR_TOGGLE: GPIO data register TOGGLE
func (o *GPIO_Type) SetDR_TOGGLE(value uint32) {
	volatile.StoreUint32(&o.DR_TOGGLE.Reg, value)
}
func (o *GPIO_Type) GetDR_TOGGLE() uint32 {
	return volatile.LoadUint32(&o.DR_TOGGLE.Reg)
}

// PWM
type PWM_Type struct {
	SM0CNT       volatile.Register16 // 0x0
	SM0INIT      volatile.Register16 // 0x2
	SM0CTRL2     volatile.Register16 // 0x4
	SM0CTRL      volatile.Register16 // 0x6
	_            [2]byte
	SM0VAL0      volatile.Register16 // 0xA
	SM0FRACVAL1  volatile.Register16 // 0xC
	SM0VAL1      volatile.Register16 // 0xE
	SM0FRACVAL2  volatile.Register16 // 0x10
	SM0VAL2      volatile.Register16 // 0x12
	SM0FRACVAL3  volatile.Register16 // 0x14
	SM0VAL3      volatile.Register16 // 0x16
	SM0FRACVAL4  volatile.Register16 // 0x18
	SM0VAL4      volatile.Register16 // 0x1A
	SM0FRACVAL5  volatile.Register16 // 0x1C
	SM0VAL5      volatile.Register16 // 0x1E
	SM0FRCTRL    volatile.Register16 // 0x20
	SM0OCTRL     volatile.Register16 // 0x22
	SM0STS       volatile.Register16 // 0x24
	SM0INTEN     volatile.Register16 // 0x26
	SM0DMAEN     volatile.Register16 // 0x28
	SM0TCTRL     volatile.Register16 // 0x2A
	SM0DISMAP0   volatile.Register16 // 0x2C
	SM0DISMAP1   volatile.Register16 // 0x2E
	SM0DTCNT0    volatile.Register16 // 0x30
	SM0DTCNT1    volatile.Register16 // 0x32
	SM0CAPTCTRLA volatile.Register16 // 0x34
	SM0CAPTCOMPA volatile.Register16 // 0x36
	SM0CAPTCTRLB volatile.Register16 // 0x38
	SM0CAPTCOMPB volatile.Register16 // 0x3A
	SM0CAPTCTRLX volatile.Register16 // 0x3C
	SM0CAPTCOMPX volatile.Register16 // 0x3E
	SM0CVAL0     volatile.Register16 // 0x40
	SM0CVAL0CYC  volatile.Register16 // 0x42
	SM0CVAL1     volatile.Register16 // 0x44
	SM0CVAL1CYC  volatile.Register16 // 0x46
	SM0CVAL2     volatile.Register16 // 0x48
	SM0CVAL2CYC  volatile.Register16 // 0x4A
	SM0CVAL3     volatile.Register16 // 0x4C
	SM0CVAL3CYC  volatile.Register16 // 0x4E
	SM0CVAL4     volatile.Register16 // 0x50
	SM0CVAL4CYC  volatile.Register16 // 0x52
	SM0CVAL5     volatile.Register16 // 0x54
	SM0CVAL5CYC  volatile.Register16 // 0x56
	SM0PHASEDLY  volatile.Register16 // 0x58
	_            [6]byte
	SM1CNT       volatile.Register16 // 0x60
	SM1INIT      volatile.Register16 // 0x62
	SM1CTRL2     volatile.Register16 // 0x64
	SM1CTRL      volatile.Register16 // 0x66
	_            [2]byte
	SM1VAL0      volatile.Register16 // 0x6A
	SM1FRACVAL1  volatile.Register16 // 0x6C
	SM1VAL1      volatile.Register16 // 0x6E
	SM1FRACVAL2  volatile.Register16 // 0x70
	SM1VAL2      volatile.Register16 // 0x72
	SM1FRACVAL3  volatile.Register16 // 0x74
	SM1VAL3      volatile.Register16 // 0x76
	SM1FRACVAL4  volatile.Register16 // 0x78
	SM1VAL4      volatile.Register16 // 0x7A
	SM1FRACVAL5  volatile.Register16 // 0x7C
	SM1VAL5      volatile.Register16 // 0x7E
	SM1FRCTRL    volatile.Register16 // 0x80
	SM1OCTRL     volatile.Register16 // 0x82
	SM1STS       volatile.Register16 // 0x84
	SM1INTEN     volatile.Register16 // 0x86
	SM1DMAEN     volatile.Register16 // 0x88
	SM1TCTRL     volatile.Register16 // 0x8A
	SM1DISMAP0   volatile.Register16 // 0x8C
	SM1DISMAP1   volatile.Register16 // 0x8E
	SM1DTCNT0    volatile.Register16 // 0x90
	SM1DTCNT1    volatile.Register16 // 0x92
	SM1CAPTCTRLA volatile.Register16 // 0x94
	SM1CAPTCOMPA volatile.Register16 // 0x96
	SM1CAPTCTRLB volatile.Register16 // 0x98
	SM1CAPTCOMPB volatile.Register16 // 0x9A
	SM1CAPTCTRLX volatile.Register16 // 0x9C
	SM1CAPTCOMPX volatile.Register16 // 0x9E
	SM1CVAL0     volatile.Register16 // 0xA0
	SM1CVAL0CYC  volatile.Register16 // 0xA2
	SM1CVAL1     volatile.Register16 // 0xA4
	SM1CVAL1CYC  volatile.Register16 // 0xA6
	SM1CVAL2     volatile.Register16 // 0xA8
	SM1CVAL2CYC  volatile.Register16 // 0xAA
	SM1CVAL3     volatile.Register16 // 0xAC
	SM1CVAL3CYC  volatile.Register16 // 0xAE
	SM1CVAL4     volatile.Register16 // 0xB0
	SM1CVAL4CYC  volatile.Register16 // 0xB2
	SM1CVAL5     volatile.Register16 // 0xB4
	SM1CVAL5CYC  volatile.Register16 // 0xB6
	SM1PHASEDLY  volatile.Register16 // 0xB8
	_            [6]byte
	SM2CNT       volatile.Register16 // 0xC0
	SM2INIT      volatile.Register16 // 0xC2
	SM2CTRL2     volatile.Register16 // 0xC4
	SM2CTRL      volatile.Register16 // 0xC6
	_            [2]byte
	SM2VAL0      volatile.Register16 // 0xCA
	SM2FRACVAL1  volatile.Register16 // 0xCC
	SM2VAL1      volatile.Register16 // 0xCE
	SM2FRACVAL2  volatile.Register16 // 0xD0
	SM2VAL2      volatile.Register16 // 0xD2
	SM2FRACVAL3  volatile.Register16 // 0xD4
	SM2VAL3      volatile.Register16 // 0xD6
	SM2FRACVAL4  volatile.Register16 // 0xD8
	SM2VAL4      volatile.Register16 // 0xDA
	SM2FRACVAL5  volatile.Register16 // 0xDC
	SM2VAL5      volatile.Register16 // 0xDE
	SM2FRCTRL    volatile.Register16 // 0xE0
	SM2OCTRL     volatile.Register16 // 0xE2
	SM2STS       volatile.Register16 // 0xE4
	SM2INTEN     volatile.Register16 // 0xE6
	SM2DMAEN     volatile.Register16 // 0xE8
	SM2TCTRL     volatile.Register16 // 0xEA
	SM2DISMAP0   volatile.Register16 // 0xEC
	SM2DISMAP1   volatile.Register16 // 0xEE
	SM2DTCNT0    volatile.Register16 // 0xF0
	SM2DTCNT1    volatile.Register16 // 0xF2
	SM2CAPTCTRLA volatile.Register16 // 0xF4
	SM2CAPTCOMPA volatile.Register16 // 0xF6
	SM2CAPTCTRLB volatile.Register16 // 0xF8
	SM2CAPTCOMPB volatile.Register16 // 0xFA
	SM2CAPTCTRLX volatile.Register16 // 0xFC
	SM2CAPTCOMPX volatile.Register16 // 0xFE
	SM2CVAL0     volatile.Register16 // 0x100
	SM2CVAL0CYC  volatile.Register16 // 0x102
	SM2CVAL1     volatile.Register16 // 0x104
	SM2CVAL1CYC  volatile.Register16 // 0x106
	SM2CVAL2     volatile.Register16 // 0x108
	SM2CVAL2CYC  volatile.Register16 // 0x10A
	SM2CVAL3     volatile.Register16 // 0x10C
	SM2CVAL3CYC  volatile.Register16 // 0x10E
	SM2CVAL4     volatile.Register16 // 0x110
	SM2CVAL4CYC  volatile.Register16 // 0x112
	SM2CVAL5     volatile.Register16 // 0x114
	SM2CVAL5CYC  volatile.Register16 // 0x116
	SM2PHASEDLY  volatile.Register16 // 0x118
	_            [6]byte
	SM3CNT       volatile.Register16 // 0x120
	SM3INIT      volatile.Register16 // 0x122
	SM3CTRL2     volatile.Register16 // 0x124
	SM3CTRL      volatile.Register16 // 0x126
	_            [2]byte
	SM3VAL0      volatile.Register16 // 0x12A
	SM3FRACVAL1  volatile.Register16 // 0x12C
	SM3VAL1      volatile.Register16 // 0x12E
	SM3FRACVAL2  volatile.Register16 // 0x130
	SM3VAL2      volatile.Register16 // 0x132
	SM3FRACVAL3  volatile.Register16 // 0x134
	SM3VAL3      volatile.Register16 // 0x136
	SM3FRACVAL4  volatile.Register16 // 0x138
	SM3VAL4      volatile.Register16 // 0x13A
	SM3FRACVAL5  volatile.Register16 // 0x13C
	SM3VAL5      volatile.Register16 // 0x13E
	SM3FRCTRL    volatile.Register16 // 0x140
	SM3OCTRL     volatile.Register16 // 0x142
	SM3STS       volatile.Register16 // 0x144
	SM3INTEN     volatile.Register16 // 0x146
	SM3DMAEN     volatile.Register16 // 0x148
	SM3TCTRL     volatile.Register16 // 0x14A
	SM3DISMAP0   volatile.Register16 // 0x14C
	SM3DISMAP1   volatile.Register16 // 0x14E
	SM3DTCNT0    volatile.Register16 // 0x150
	SM3DTCNT1    volatile.Register16 // 0x152
	SM3CAPTCTRLA volatile.Register16 // 0x154
	SM3CAPTCOMPA volatile.Register16 // 0x156
	SM3CAPTCTRLB volatile.Register16 // 0x158
	SM3CAPTCOMPB volatile.Register16 // 0x15A
	SM3CAPTCTRLX volatile.Register16 // 0x15C
	SM3CAPTCOMPX volatile.Register16 // 0x15E
	SM3CVAL0     volatile.Register16 // 0x160
	SM3CVAL0CYC  volatile.Register16 // 0x162
	SM3CVAL1     volatile.Register16 // 0x164
	SM3CVAL1CYC  volatile.Register16 // 0x166
	SM3CVAL2     volatile.Register16 // 0x168
	SM3CVAL2CYC  volatile.Register16 // 0x16A
	SM3CVAL3     volatile.Register16 // 0x16C
	SM3CVAL3CYC  volatile.Register16 // 0x16E
	SM3CVAL4     volatile.Register16 // 0x170
	SM3CVAL4CYC  volatile.Register16 // 0x172
	SM3CVAL5     volatile.Register16 // 0x174
	SM3CVAL5CYC  volatile.Register16 // 0x176
	SM3PHASEDLY  volatile.Register16 // 0x178
	_            [6]byte
	OUTEN        volatile.Register16 // 0x180
	MASK         volatile.Register16 // 0x182
	SWCOUT       volatile.Register16 // 0x184
	DTSRCSEL     volatile.Register16 // 0x186
	MCTRL        volatile.Register16 // 0x188
	MCTRL2       volatile.Register16 // 0x18A
	FCTRL0       volatile.Register16 // 0x18C
	FSTS0        volatile.Register16 // 0x18E
	FFILT0       volatile.Register16 // 0x190
	FTST0        volatile.Register16 // 0x192
	FCTRL20      volatile.Register16 // 0x194
}

// PWM.SM0CNT: Counter Register
func (o *PWM_Type) SetSM0CNT(value uint16) {
	volatile.StoreUint16(&o.SM0CNT.Reg, value)
}
func (o *PWM_Type) GetSM0CNT() uint16 {
	return volatile.LoadUint16(&o.SM0CNT.Reg)
}

// PWM.SM0INIT: Initial Count Register
func (o *PWM_Type) SetSM0INIT(value uint16) {
	volatile.StoreUint16(&o.SM0INIT.Reg, value)
}
func (o *PWM_Type) GetSM0INIT() uint16 {
	return volatile.LoadUint16(&o.SM0INIT.Reg)
}

// PWM.SM0CTRL2: Control 2 Register
func (o *PWM_Type) SetSM0CTRL2_CLK_SEL(value uint16) {
	volatile.StoreUint16(&o.SM0CTRL2.Reg, volatile.LoadUint16(&o.SM0CTRL2.Reg)&^(0x3)|value)
}
func (o *PWM_Type) GetSM0CTRL2_CLK_SEL() uint16 {
	return volatile.LoadUint16(&o.SM0CTRL2.Reg) & 0x3
}
func (o *PWM_Type) SetSM0CTRL2_RELOAD_SEL(value uint16) {
	volatile.StoreUint16(&o.SM0CTRL2.Reg, volatile.LoadUint16(&o.SM0CTRL2.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetSM0CTRL2_RELOAD_SEL() uint16 {
	return (volatile.LoadUint16(&o.SM0CTRL2.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetSM0CTRL2_FORCE_SEL(value uint16) {
	volatile.StoreUint16(&o.SM0CTRL2.Reg, volatile.LoadUint16(&o.SM0CTRL2.Reg)&^(0x38)|value<<3)
}
func (o *PWM_Type) GetSM0CTRL2_FORCE_SEL() uint16 {
	return (volatile.LoadUint16(&o.SM0CTRL2.Reg) & 0x38) >> 3
}
func (o *PWM_Type) SetSM0CTRL2_FORCE(value uint16) {
	volatile.StoreUint16(&o.SM0CTRL2.Reg, volatile.LoadUint16(&o.SM0CTRL2.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetSM0CTRL2_FORCE() uint16 {
	return (volatile.LoadUint16(&o.SM0CTRL2.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetSM0CTRL2_FRCEN(value uint16) {
	volatile.StoreUint16(&o.SM0CTRL2.Reg, volatile.LoadUint16(&o.SM0CTRL2.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetSM0CTRL2_FRCEN() uint16 {
	return (volatile.LoadUint16(&o.SM0CTRL2.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetSM0CTRL2_INIT_SEL(value uint16) {
	volatile.StoreUint16(&o.SM0CTRL2.Reg, volatile.LoadUint16(&o.SM0CTRL2.Reg)&^(0x300)|value<<8)
}
func (o *PWM_Type) GetSM0CTRL2_INIT_SEL() uint16 {
	return (volatile.LoadUint16(&o.SM0CTRL2.Reg) & 0x300) >> 8
}
func (o *PWM_Type) SetSM0CTRL2_PWMX_INIT(value uint16) {
	volatile.StoreUint16(&o.SM0CTRL2.Reg, volatile.LoadUint16(&o.SM0CTRL2.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetSM0CTRL2_PWMX_INIT() uint16 {
	return (volatile.LoadUint16(&o.SM0CTRL2.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetSM0CTRL2_PWM45_INIT(value uint16) {
	volatile.StoreUint16(&o.SM0CTRL2.Reg, volatile.LoadUint16(&o.SM0CTRL2.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetSM0CTRL2_PWM45_INIT() uint16 {
	return (volatile.LoadUint16(&o.SM0CTRL2.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetSM0CTRL2_PWM23_INIT(value uint16) {
	volatile.StoreUint16(&o.SM0CTRL2.Reg, volatile.LoadUint16(&o.SM0CTRL2.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetSM0CTRL2_PWM23_INIT() uint16 {
	return (volatile.LoadUint16(&o.SM0CTRL2.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetSM0CTRL2_INDEP(value uint16) {
	volatile.StoreUint16(&o.SM0CTRL2.Reg, volatile.LoadUint16(&o.SM0CTRL2.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetSM0CTRL2_INDEP() uint16 {
	return (volatile.LoadUint16(&o.SM0CTRL2.Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetSM0CTRL2_WAITEN(value uint16) {
	volatile.StoreUint16(&o.SM0CTRL2.Reg, volatile.LoadUint16(&o.SM0CTRL2.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetSM0CTRL2_WAITEN() uint16 {
	return (volatile.LoadUint16(&o.SM0CTRL2.Reg) & 0x4000) >> 14
}
func (o *PWM_Type) SetSM0CTRL2_DBGEN(value uint16) {
	volatile.StoreUint16(&o.SM0CTRL2.Reg, volatile.LoadUint16(&o.SM0CTRL2.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetSM0CTRL2_DBGEN() uint16 {
	return (volatile.LoadUint16(&o.SM0CTRL2.Reg) & 0x8000) >> 15
}

// PWM.SM0CTRL: Control Register
func (o *PWM_Type) SetSM0CTRL_DBLEN(value uint16) {
	volatile.StoreUint16(&o.SM0CTRL.Reg, volatile.LoadUint16(&o.SM0CTRL.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSM0CTRL_DBLEN() uint16 {
	return volatile.LoadUint16(&o.SM0CTRL.Reg) & 0x1
}
func (o *PWM_Type) SetSM0CTRL_DBLX(value uint16) {
	volatile.StoreUint16(&o.SM0CTRL.Reg, volatile.LoadUint16(&o.SM0CTRL.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSM0CTRL_DBLX() uint16 {
	return (volatile.LoadUint16(&o.SM0CTRL.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSM0CTRL_LDMOD(value uint16) {
	volatile.StoreUint16(&o.SM0CTRL.Reg, volatile.LoadUint16(&o.SM0CTRL.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetSM0CTRL_LDMOD() uint16 {
	return (volatile.LoadUint16(&o.SM0CTRL.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetSM0CTRL_SPLIT(value uint16) {
	volatile.StoreUint16(&o.SM0CTRL.Reg, volatile.LoadUint16(&o.SM0CTRL.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetSM0CTRL_SPLIT() uint16 {
	return (volatile.LoadUint16(&o.SM0CTRL.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetSM0CTRL_PRSC(value uint16) {
	volatile.StoreUint16(&o.SM0CTRL.Reg, volatile.LoadUint16(&o.SM0CTRL.Reg)&^(0x70)|value<<4)
}
func (o *PWM_Type) GetSM0CTRL_PRSC() uint16 {
	return (volatile.LoadUint16(&o.SM0CTRL.Reg) & 0x70) >> 4
}
func (o *PWM_Type) SetSM0CTRL_COMPMODE(value uint16) {
	volatile.StoreUint16(&o.SM0CTRL.Reg, volatile.LoadUint16(&o.SM0CTRL.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetSM0CTRL_COMPMODE() uint16 {
	return (volatile.LoadUint16(&o.SM0CTRL.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetSM0CTRL_DT(value uint16) {
	volatile.StoreUint16(&o.SM0CTRL.Reg, volatile.LoadUint16(&o.SM0CTRL.Reg)&^(0x300)|value<<8)
}
func (o *PWM_Type) GetSM0CTRL_DT() uint16 {
	return (volatile.LoadUint16(&o.SM0CTRL.Reg) & 0x300) >> 8
}
func (o *PWM_Type) SetSM0CTRL_FULL(value uint16) {
	volatile.StoreUint16(&o.SM0CTRL.Reg, volatile.LoadUint16(&o.SM0CTRL.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetSM0CTRL_FULL() uint16 {
	return (volatile.LoadUint16(&o.SM0CTRL.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetSM0CTRL_HALF(value uint16) {
	volatile.StoreUint16(&o.SM0CTRL.Reg, volatile.LoadUint16(&o.SM0CTRL.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetSM0CTRL_HALF() uint16 {
	return (volatile.LoadUint16(&o.SM0CTRL.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetSM0CTRL_LDFQ(value uint16) {
	volatile.StoreUint16(&o.SM0CTRL.Reg, volatile.LoadUint16(&o.SM0CTRL.Reg)&^(0xf000)|value<<12)
}
func (o *PWM_Type) GetSM0CTRL_LDFQ() uint16 {
	return (volatile.LoadUint16(&o.SM0CTRL.Reg) & 0xf000) >> 12
}

// PWM.SM0VAL0: Value Register 0
func (o *PWM_Type) SetSM0VAL0(value uint16) {
	volatile.StoreUint16(&o.SM0VAL0.Reg, value)
}
func (o *PWM_Type) GetSM0VAL0() uint16 {
	return volatile.LoadUint16(&o.SM0VAL0.Reg)
}

// PWM.SM0FRACVAL1: Fractional Value Register 1
func (o *PWM_Type) SetSM0FRACVAL1_FRACVAL1(value uint16) {
	volatile.StoreUint16(&o.SM0FRACVAL1.Reg, volatile.LoadUint16(&o.SM0FRACVAL1.Reg)&^(0xf800)|value<<11)
}
func (o *PWM_Type) GetSM0FRACVAL1_FRACVAL1() uint16 {
	return (volatile.LoadUint16(&o.SM0FRACVAL1.Reg) & 0xf800) >> 11
}

// PWM.SM0VAL1: Value Register 1
func (o *PWM_Type) SetSM0VAL1(value uint16) {
	volatile.StoreUint16(&o.SM0VAL1.Reg, value)
}
func (o *PWM_Type) GetSM0VAL1() uint16 {
	return volatile.LoadUint16(&o.SM0VAL1.Reg)
}

// PWM.SM0FRACVAL2: Fractional Value Register 2
func (o *PWM_Type) SetSM0FRACVAL2_FRACVAL2(value uint16) {
	volatile.StoreUint16(&o.SM0FRACVAL2.Reg, volatile.LoadUint16(&o.SM0FRACVAL2.Reg)&^(0xf800)|value<<11)
}
func (o *PWM_Type) GetSM0FRACVAL2_FRACVAL2() uint16 {
	return (volatile.LoadUint16(&o.SM0FRACVAL2.Reg) & 0xf800) >> 11
}

// PWM.SM0VAL2: Value Register 2
func (o *PWM_Type) SetSM0VAL2(value uint16) {
	volatile.StoreUint16(&o.SM0VAL2.Reg, value)
}
func (o *PWM_Type) GetSM0VAL2() uint16 {
	return volatile.LoadUint16(&o.SM0VAL2.Reg)
}

// PWM.SM0FRACVAL3: Fractional Value Register 3
func (o *PWM_Type) SetSM0FRACVAL3_FRACVAL3(value uint16) {
	volatile.StoreUint16(&o.SM0FRACVAL3.Reg, volatile.LoadUint16(&o.SM0FRACVAL3.Reg)&^(0xf800)|value<<11)
}
func (o *PWM_Type) GetSM0FRACVAL3_FRACVAL3() uint16 {
	return (volatile.LoadUint16(&o.SM0FRACVAL3.Reg) & 0xf800) >> 11
}

// PWM.SM0VAL3: Value Register 3
func (o *PWM_Type) SetSM0VAL3(value uint16) {
	volatile.StoreUint16(&o.SM0VAL3.Reg, value)
}
func (o *PWM_Type) GetSM0VAL3() uint16 {
	return volatile.LoadUint16(&o.SM0VAL3.Reg)
}

// PWM.SM0FRACVAL4: Fractional Value Register 4
func (o *PWM_Type) SetSM0FRACVAL4_FRACVAL4(value uint16) {
	volatile.StoreUint16(&o.SM0FRACVAL4.Reg, volatile.LoadUint16(&o.SM0FRACVAL4.Reg)&^(0xf800)|value<<11)
}
func (o *PWM_Type) GetSM0FRACVAL4_FRACVAL4() uint16 {
	return (volatile.LoadUint16(&o.SM0FRACVAL4.Reg) & 0xf800) >> 11
}

// PWM.SM0VAL4: Value Register 4
func (o *PWM_Type) SetSM0VAL4(value uint16) {
	volatile.StoreUint16(&o.SM0VAL4.Reg, value)
}
func (o *PWM_Type) GetSM0VAL4() uint16 {
	return volatile.LoadUint16(&o.SM0VAL4.Reg)
}

// PWM.SM0FRACVAL5: Fractional Value Register 5
func (o *PWM_Type) SetSM0FRACVAL5_FRACVAL5(value uint16) {
	volatile.StoreUint16(&o.SM0FRACVAL5.Reg, volatile.LoadUint16(&o.SM0FRACVAL5.Reg)&^(0xf800)|value<<11)
}
func (o *PWM_Type) GetSM0FRACVAL5_FRACVAL5() uint16 {
	return (volatile.LoadUint16(&o.SM0FRACVAL5.Reg) & 0xf800) >> 11
}

// PWM.SM0VAL5: Value Register 5
func (o *PWM_Type) SetSM0VAL5(value uint16) {
	volatile.StoreUint16(&o.SM0VAL5.Reg, value)
}
func (o *PWM_Type) GetSM0VAL5() uint16 {
	return volatile.LoadUint16(&o.SM0VAL5.Reg)
}

// PWM.SM0FRCTRL: Fractional Control Register
func (o *PWM_Type) SetSM0FRCTRL_FRAC1_EN(value uint16) {
	volatile.StoreUint16(&o.SM0FRCTRL.Reg, volatile.LoadUint16(&o.SM0FRCTRL.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSM0FRCTRL_FRAC1_EN() uint16 {
	return (volatile.LoadUint16(&o.SM0FRCTRL.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSM0FRCTRL_FRAC23_EN(value uint16) {
	volatile.StoreUint16(&o.SM0FRCTRL.Reg, volatile.LoadUint16(&o.SM0FRCTRL.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetSM0FRCTRL_FRAC23_EN() uint16 {
	return (volatile.LoadUint16(&o.SM0FRCTRL.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetSM0FRCTRL_FRAC45_EN(value uint16) {
	volatile.StoreUint16(&o.SM0FRCTRL.Reg, volatile.LoadUint16(&o.SM0FRCTRL.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetSM0FRCTRL_FRAC45_EN() uint16 {
	return (volatile.LoadUint16(&o.SM0FRCTRL.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetSM0FRCTRL_FRAC_PU(value uint16) {
	volatile.StoreUint16(&o.SM0FRCTRL.Reg, volatile.LoadUint16(&o.SM0FRCTRL.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetSM0FRCTRL_FRAC_PU() uint16 {
	return (volatile.LoadUint16(&o.SM0FRCTRL.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetSM0FRCTRL_TEST(value uint16) {
	volatile.StoreUint16(&o.SM0FRCTRL.Reg, volatile.LoadUint16(&o.SM0FRCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetSM0FRCTRL_TEST() uint16 {
	return (volatile.LoadUint16(&o.SM0FRCTRL.Reg) & 0x8000) >> 15
}

// PWM.SM0OCTRL: Output Control Register
func (o *PWM_Type) SetSM0OCTRL_PWMXFS(value uint16) {
	volatile.StoreUint16(&o.SM0OCTRL.Reg, volatile.LoadUint16(&o.SM0OCTRL.Reg)&^(0x3)|value)
}
func (o *PWM_Type) GetSM0OCTRL_PWMXFS() uint16 {
	return volatile.LoadUint16(&o.SM0OCTRL.Reg) & 0x3
}
func (o *PWM_Type) SetSM0OCTRL_PWMBFS(value uint16) {
	volatile.StoreUint16(&o.SM0OCTRL.Reg, volatile.LoadUint16(&o.SM0OCTRL.Reg)&^(0xc)|value<<2)
}
func (o *PWM_Type) GetSM0OCTRL_PWMBFS() uint16 {
	return (volatile.LoadUint16(&o.SM0OCTRL.Reg) & 0xc) >> 2
}
func (o *PWM_Type) SetSM0OCTRL_PWMAFS(value uint16) {
	volatile.StoreUint16(&o.SM0OCTRL.Reg, volatile.LoadUint16(&o.SM0OCTRL.Reg)&^(0x30)|value<<4)
}
func (o *PWM_Type) GetSM0OCTRL_PWMAFS() uint16 {
	return (volatile.LoadUint16(&o.SM0OCTRL.Reg) & 0x30) >> 4
}
func (o *PWM_Type) SetSM0OCTRL_POLX(value uint16) {
	volatile.StoreUint16(&o.SM0OCTRL.Reg, volatile.LoadUint16(&o.SM0OCTRL.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetSM0OCTRL_POLX() uint16 {
	return (volatile.LoadUint16(&o.SM0OCTRL.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetSM0OCTRL_POLB(value uint16) {
	volatile.StoreUint16(&o.SM0OCTRL.Reg, volatile.LoadUint16(&o.SM0OCTRL.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetSM0OCTRL_POLB() uint16 {
	return (volatile.LoadUint16(&o.SM0OCTRL.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetSM0OCTRL_POLA(value uint16) {
	volatile.StoreUint16(&o.SM0OCTRL.Reg, volatile.LoadUint16(&o.SM0OCTRL.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetSM0OCTRL_POLA() uint16 {
	return (volatile.LoadUint16(&o.SM0OCTRL.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetSM0OCTRL_PWMX_IN(value uint16) {
	volatile.StoreUint16(&o.SM0OCTRL.Reg, volatile.LoadUint16(&o.SM0OCTRL.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetSM0OCTRL_PWMX_IN() uint16 {
	return (volatile.LoadUint16(&o.SM0OCTRL.Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetSM0OCTRL_PWMB_IN(value uint16) {
	volatile.StoreUint16(&o.SM0OCTRL.Reg, volatile.LoadUint16(&o.SM0OCTRL.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetSM0OCTRL_PWMB_IN() uint16 {
	return (volatile.LoadUint16(&o.SM0OCTRL.Reg) & 0x4000) >> 14
}
func (o *PWM_Type) SetSM0OCTRL_PWMA_IN(value uint16) {
	volatile.StoreUint16(&o.SM0OCTRL.Reg, volatile.LoadUint16(&o.SM0OCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetSM0OCTRL_PWMA_IN() uint16 {
	return (volatile.LoadUint16(&o.SM0OCTRL.Reg) & 0x8000) >> 15
}

// PWM.SM0STS: Status Register
func (o *PWM_Type) SetSM0STS_CMPF(value uint16) {
	volatile.StoreUint16(&o.SM0STS.Reg, volatile.LoadUint16(&o.SM0STS.Reg)&^(0x3f)|value)
}
func (o *PWM_Type) GetSM0STS_CMPF() uint16 {
	return volatile.LoadUint16(&o.SM0STS.Reg) & 0x3f
}
func (o *PWM_Type) SetSM0STS_CFX0(value uint16) {
	volatile.StoreUint16(&o.SM0STS.Reg, volatile.LoadUint16(&o.SM0STS.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetSM0STS_CFX0() uint16 {
	return (volatile.LoadUint16(&o.SM0STS.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetSM0STS_CFX1(value uint16) {
	volatile.StoreUint16(&o.SM0STS.Reg, volatile.LoadUint16(&o.SM0STS.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetSM0STS_CFX1() uint16 {
	return (volatile.LoadUint16(&o.SM0STS.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetSM0STS_CFB0(value uint16) {
	volatile.StoreUint16(&o.SM0STS.Reg, volatile.LoadUint16(&o.SM0STS.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetSM0STS_CFB0() uint16 {
	return (volatile.LoadUint16(&o.SM0STS.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetSM0STS_CFB1(value uint16) {
	volatile.StoreUint16(&o.SM0STS.Reg, volatile.LoadUint16(&o.SM0STS.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetSM0STS_CFB1() uint16 {
	return (volatile.LoadUint16(&o.SM0STS.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetSM0STS_CFA0(value uint16) {
	volatile.StoreUint16(&o.SM0STS.Reg, volatile.LoadUint16(&o.SM0STS.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetSM0STS_CFA0() uint16 {
	return (volatile.LoadUint16(&o.SM0STS.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetSM0STS_CFA1(value uint16) {
	volatile.StoreUint16(&o.SM0STS.Reg, volatile.LoadUint16(&o.SM0STS.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetSM0STS_CFA1() uint16 {
	return (volatile.LoadUint16(&o.SM0STS.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetSM0STS_RF(value uint16) {
	volatile.StoreUint16(&o.SM0STS.Reg, volatile.LoadUint16(&o.SM0STS.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetSM0STS_RF() uint16 {
	return (volatile.LoadUint16(&o.SM0STS.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetSM0STS_REF(value uint16) {
	volatile.StoreUint16(&o.SM0STS.Reg, volatile.LoadUint16(&o.SM0STS.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetSM0STS_REF() uint16 {
	return (volatile.LoadUint16(&o.SM0STS.Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetSM0STS_RUF(value uint16) {
	volatile.StoreUint16(&o.SM0STS.Reg, volatile.LoadUint16(&o.SM0STS.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetSM0STS_RUF() uint16 {
	return (volatile.LoadUint16(&o.SM0STS.Reg) & 0x4000) >> 14
}

// PWM.SM0INTEN: Interrupt Enable Register
func (o *PWM_Type) SetSM0INTEN_CMPIE(value uint16) {
	volatile.StoreUint16(&o.SM0INTEN.Reg, volatile.LoadUint16(&o.SM0INTEN.Reg)&^(0x3f)|value)
}
func (o *PWM_Type) GetSM0INTEN_CMPIE() uint16 {
	return volatile.LoadUint16(&o.SM0INTEN.Reg) & 0x3f
}
func (o *PWM_Type) SetSM0INTEN_CX0IE(value uint16) {
	volatile.StoreUint16(&o.SM0INTEN.Reg, volatile.LoadUint16(&o.SM0INTEN.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetSM0INTEN_CX0IE() uint16 {
	return (volatile.LoadUint16(&o.SM0INTEN.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetSM0INTEN_CX1IE(value uint16) {
	volatile.StoreUint16(&o.SM0INTEN.Reg, volatile.LoadUint16(&o.SM0INTEN.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetSM0INTEN_CX1IE() uint16 {
	return (volatile.LoadUint16(&o.SM0INTEN.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetSM0INTEN_CB0IE(value uint16) {
	volatile.StoreUint16(&o.SM0INTEN.Reg, volatile.LoadUint16(&o.SM0INTEN.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetSM0INTEN_CB0IE() uint16 {
	return (volatile.LoadUint16(&o.SM0INTEN.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetSM0INTEN_CB1IE(value uint16) {
	volatile.StoreUint16(&o.SM0INTEN.Reg, volatile.LoadUint16(&o.SM0INTEN.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetSM0INTEN_CB1IE() uint16 {
	return (volatile.LoadUint16(&o.SM0INTEN.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetSM0INTEN_CA0IE(value uint16) {
	volatile.StoreUint16(&o.SM0INTEN.Reg, volatile.LoadUint16(&o.SM0INTEN.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetSM0INTEN_CA0IE() uint16 {
	return (volatile.LoadUint16(&o.SM0INTEN.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetSM0INTEN_CA1IE(value uint16) {
	volatile.StoreUint16(&o.SM0INTEN.Reg, volatile.LoadUint16(&o.SM0INTEN.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetSM0INTEN_CA1IE() uint16 {
	return (volatile.LoadUint16(&o.SM0INTEN.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetSM0INTEN_RIE(value uint16) {
	volatile.StoreUint16(&o.SM0INTEN.Reg, volatile.LoadUint16(&o.SM0INTEN.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetSM0INTEN_RIE() uint16 {
	return (volatile.LoadUint16(&o.SM0INTEN.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetSM0INTEN_REIE(value uint16) {
	volatile.StoreUint16(&o.SM0INTEN.Reg, volatile.LoadUint16(&o.SM0INTEN.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetSM0INTEN_REIE() uint16 {
	return (volatile.LoadUint16(&o.SM0INTEN.Reg) & 0x2000) >> 13
}

// PWM.SM0DMAEN: DMA Enable Register
func (o *PWM_Type) SetSM0DMAEN_CX0DE(value uint16) {
	volatile.StoreUint16(&o.SM0DMAEN.Reg, volatile.LoadUint16(&o.SM0DMAEN.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSM0DMAEN_CX0DE() uint16 {
	return volatile.LoadUint16(&o.SM0DMAEN.Reg) & 0x1
}
func (o *PWM_Type) SetSM0DMAEN_CX1DE(value uint16) {
	volatile.StoreUint16(&o.SM0DMAEN.Reg, volatile.LoadUint16(&o.SM0DMAEN.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSM0DMAEN_CX1DE() uint16 {
	return (volatile.LoadUint16(&o.SM0DMAEN.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSM0DMAEN_CB0DE(value uint16) {
	volatile.StoreUint16(&o.SM0DMAEN.Reg, volatile.LoadUint16(&o.SM0DMAEN.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetSM0DMAEN_CB0DE() uint16 {
	return (volatile.LoadUint16(&o.SM0DMAEN.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetSM0DMAEN_CB1DE(value uint16) {
	volatile.StoreUint16(&o.SM0DMAEN.Reg, volatile.LoadUint16(&o.SM0DMAEN.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetSM0DMAEN_CB1DE() uint16 {
	return (volatile.LoadUint16(&o.SM0DMAEN.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetSM0DMAEN_CA0DE(value uint16) {
	volatile.StoreUint16(&o.SM0DMAEN.Reg, volatile.LoadUint16(&o.SM0DMAEN.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetSM0DMAEN_CA0DE() uint16 {
	return (volatile.LoadUint16(&o.SM0DMAEN.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetSM0DMAEN_CA1DE(value uint16) {
	volatile.StoreUint16(&o.SM0DMAEN.Reg, volatile.LoadUint16(&o.SM0DMAEN.Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetSM0DMAEN_CA1DE() uint16 {
	return (volatile.LoadUint16(&o.SM0DMAEN.Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetSM0DMAEN_CAPTDE(value uint16) {
	volatile.StoreUint16(&o.SM0DMAEN.Reg, volatile.LoadUint16(&o.SM0DMAEN.Reg)&^(0xc0)|value<<6)
}
func (o *PWM_Type) GetSM0DMAEN_CAPTDE() uint16 {
	return (volatile.LoadUint16(&o.SM0DMAEN.Reg) & 0xc0) >> 6
}
func (o *PWM_Type) SetSM0DMAEN_FAND(value uint16) {
	volatile.StoreUint16(&o.SM0DMAEN.Reg, volatile.LoadUint16(&o.SM0DMAEN.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetSM0DMAEN_FAND() uint16 {
	return (volatile.LoadUint16(&o.SM0DMAEN.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetSM0DMAEN_VALDE(value uint16) {
	volatile.StoreUint16(&o.SM0DMAEN.Reg, volatile.LoadUint16(&o.SM0DMAEN.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetSM0DMAEN_VALDE() uint16 {
	return (volatile.LoadUint16(&o.SM0DMAEN.Reg) & 0x200) >> 9
}

// PWM.SM0TCTRL: Output Trigger Control Register
func (o *PWM_Type) SetSM0TCTRL_OUT_TRIG_EN(value uint16) {
	volatile.StoreUint16(&o.SM0TCTRL.Reg, volatile.LoadUint16(&o.SM0TCTRL.Reg)&^(0x3f)|value)
}
func (o *PWM_Type) GetSM0TCTRL_OUT_TRIG_EN() uint16 {
	return volatile.LoadUint16(&o.SM0TCTRL.Reg) & 0x3f
}
func (o *PWM_Type) SetSM0TCTRL_TRGFRQ(value uint16) {
	volatile.StoreUint16(&o.SM0TCTRL.Reg, volatile.LoadUint16(&o.SM0TCTRL.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetSM0TCTRL_TRGFRQ() uint16 {
	return (volatile.LoadUint16(&o.SM0TCTRL.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetSM0TCTRL_PWBOT1(value uint16) {
	volatile.StoreUint16(&o.SM0TCTRL.Reg, volatile.LoadUint16(&o.SM0TCTRL.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetSM0TCTRL_PWBOT1() uint16 {
	return (volatile.LoadUint16(&o.SM0TCTRL.Reg) & 0x4000) >> 14
}
func (o *PWM_Type) SetSM0TCTRL_PWAOT0(value uint16) {
	volatile.StoreUint16(&o.SM0TCTRL.Reg, volatile.LoadUint16(&o.SM0TCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetSM0TCTRL_PWAOT0() uint16 {
	return (volatile.LoadUint16(&o.SM0TCTRL.Reg) & 0x8000) >> 15
}

// PWM.SM0DISMAP0: Fault Disable Mapping Register 0
func (o *PWM_Type) SetSM0DISMAP0_DIS0A(value uint16) {
	volatile.StoreUint16(&o.SM0DISMAP0.Reg, volatile.LoadUint16(&o.SM0DISMAP0.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM0DISMAP0_DIS0A() uint16 {
	return volatile.LoadUint16(&o.SM0DISMAP0.Reg) & 0xf
}
func (o *PWM_Type) SetSM0DISMAP0_DIS0B(value uint16) {
	volatile.StoreUint16(&o.SM0DISMAP0.Reg, volatile.LoadUint16(&o.SM0DISMAP0.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetSM0DISMAP0_DIS0B() uint16 {
	return (volatile.LoadUint16(&o.SM0DISMAP0.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetSM0DISMAP0_DIS0X(value uint16) {
	volatile.StoreUint16(&o.SM0DISMAP0.Reg, volatile.LoadUint16(&o.SM0DISMAP0.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetSM0DISMAP0_DIS0X() uint16 {
	return (volatile.LoadUint16(&o.SM0DISMAP0.Reg) & 0xf00) >> 8
}

// PWM.SM0DISMAP1: Fault Disable Mapping Register 1
func (o *PWM_Type) SetSM0DISMAP1_DIS1A(value uint16) {
	volatile.StoreUint16(&o.SM0DISMAP1.Reg, volatile.LoadUint16(&o.SM0DISMAP1.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM0DISMAP1_DIS1A() uint16 {
	return volatile.LoadUint16(&o.SM0DISMAP1.Reg) & 0xf
}
func (o *PWM_Type) SetSM0DISMAP1_DIS1B(value uint16) {
	volatile.StoreUint16(&o.SM0DISMAP1.Reg, volatile.LoadUint16(&o.SM0DISMAP1.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetSM0DISMAP1_DIS1B() uint16 {
	return (volatile.LoadUint16(&o.SM0DISMAP1.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetSM0DISMAP1_DIS1X(value uint16) {
	volatile.StoreUint16(&o.SM0DISMAP1.Reg, volatile.LoadUint16(&o.SM0DISMAP1.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetSM0DISMAP1_DIS1X() uint16 {
	return (volatile.LoadUint16(&o.SM0DISMAP1.Reg) & 0xf00) >> 8
}

// PWM.SM0DTCNT0: Deadtime Count Register 0
func (o *PWM_Type) SetSM0DTCNT0(value uint16) {
	volatile.StoreUint16(&o.SM0DTCNT0.Reg, value)
}
func (o *PWM_Type) GetSM0DTCNT0() uint16 {
	return volatile.LoadUint16(&o.SM0DTCNT0.Reg)
}

// PWM.SM0DTCNT1: Deadtime Count Register 1
func (o *PWM_Type) SetSM0DTCNT1(value uint16) {
	volatile.StoreUint16(&o.SM0DTCNT1.Reg, value)
}
func (o *PWM_Type) GetSM0DTCNT1() uint16 {
	return volatile.LoadUint16(&o.SM0DTCNT1.Reg)
}

// PWM.SM0CAPTCTRLA: Capture Control A Register
func (o *PWM_Type) SetSM0CAPTCTRLA_ARMA(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM0CAPTCTRLA.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSM0CAPTCTRLA_ARMA() uint16 {
	return volatile.LoadUint16(&o.SM0CAPTCTRLA.Reg) & 0x1
}
func (o *PWM_Type) SetSM0CAPTCTRLA_ONESHOTA(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM0CAPTCTRLA.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSM0CAPTCTRLA_ONESHOTA() uint16 {
	return (volatile.LoadUint16(&o.SM0CAPTCTRLA.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSM0CAPTCTRLA_EDGA0(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM0CAPTCTRLA.Reg)&^(0xc)|value<<2)
}
func (o *PWM_Type) GetSM0CAPTCTRLA_EDGA0() uint16 {
	return (volatile.LoadUint16(&o.SM0CAPTCTRLA.Reg) & 0xc) >> 2
}
func (o *PWM_Type) SetSM0CAPTCTRLA_EDGA1(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM0CAPTCTRLA.Reg)&^(0x30)|value<<4)
}
func (o *PWM_Type) GetSM0CAPTCTRLA_EDGA1() uint16 {
	return (volatile.LoadUint16(&o.SM0CAPTCTRLA.Reg) & 0x30) >> 4
}
func (o *PWM_Type) SetSM0CAPTCTRLA_INP_SELA(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM0CAPTCTRLA.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetSM0CAPTCTRLA_INP_SELA() uint16 {
	return (volatile.LoadUint16(&o.SM0CAPTCTRLA.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetSM0CAPTCTRLA_EDGCNTA_EN(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM0CAPTCTRLA.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetSM0CAPTCTRLA_EDGCNTA_EN() uint16 {
	return (volatile.LoadUint16(&o.SM0CAPTCTRLA.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetSM0CAPTCTRLA_CFAWM(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM0CAPTCTRLA.Reg)&^(0x300)|value<<8)
}
func (o *PWM_Type) GetSM0CAPTCTRLA_CFAWM() uint16 {
	return (volatile.LoadUint16(&o.SM0CAPTCTRLA.Reg) & 0x300) >> 8
}
func (o *PWM_Type) SetSM0CAPTCTRLA_CA0CNT(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM0CAPTCTRLA.Reg)&^(0x1c00)|value<<10)
}
func (o *PWM_Type) GetSM0CAPTCTRLA_CA0CNT() uint16 {
	return (volatile.LoadUint16(&o.SM0CAPTCTRLA.Reg) & 0x1c00) >> 10
}
func (o *PWM_Type) SetSM0CAPTCTRLA_CA1CNT(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM0CAPTCTRLA.Reg)&^(0xe000)|value<<13)
}
func (o *PWM_Type) GetSM0CAPTCTRLA_CA1CNT() uint16 {
	return (volatile.LoadUint16(&o.SM0CAPTCTRLA.Reg) & 0xe000) >> 13
}

// PWM.SM0CAPTCOMPA: Capture Compare A Register
func (o *PWM_Type) SetSM0CAPTCOMPA_EDGCMPA(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCOMPA.Reg, volatile.LoadUint16(&o.SM0CAPTCOMPA.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetSM0CAPTCOMPA_EDGCMPA() uint16 {
	return volatile.LoadUint16(&o.SM0CAPTCOMPA.Reg) & 0xff
}
func (o *PWM_Type) SetSM0CAPTCOMPA_EDGCNTA(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCOMPA.Reg, volatile.LoadUint16(&o.SM0CAPTCOMPA.Reg)&^(0xff00)|value<<8)
}
func (o *PWM_Type) GetSM0CAPTCOMPA_EDGCNTA() uint16 {
	return (volatile.LoadUint16(&o.SM0CAPTCOMPA.Reg) & 0xff00) >> 8
}

// PWM.SM0CAPTCTRLB: Capture Control B Register
func (o *PWM_Type) SetSM0CAPTCTRLB_ARMB(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM0CAPTCTRLB.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSM0CAPTCTRLB_ARMB() uint16 {
	return volatile.LoadUint16(&o.SM0CAPTCTRLB.Reg) & 0x1
}
func (o *PWM_Type) SetSM0CAPTCTRLB_ONESHOTB(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM0CAPTCTRLB.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSM0CAPTCTRLB_ONESHOTB() uint16 {
	return (volatile.LoadUint16(&o.SM0CAPTCTRLB.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSM0CAPTCTRLB_EDGB0(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM0CAPTCTRLB.Reg)&^(0xc)|value<<2)
}
func (o *PWM_Type) GetSM0CAPTCTRLB_EDGB0() uint16 {
	return (volatile.LoadUint16(&o.SM0CAPTCTRLB.Reg) & 0xc) >> 2
}
func (o *PWM_Type) SetSM0CAPTCTRLB_EDGB1(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM0CAPTCTRLB.Reg)&^(0x30)|value<<4)
}
func (o *PWM_Type) GetSM0CAPTCTRLB_EDGB1() uint16 {
	return (volatile.LoadUint16(&o.SM0CAPTCTRLB.Reg) & 0x30) >> 4
}
func (o *PWM_Type) SetSM0CAPTCTRLB_INP_SELB(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM0CAPTCTRLB.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetSM0CAPTCTRLB_INP_SELB() uint16 {
	return (volatile.LoadUint16(&o.SM0CAPTCTRLB.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetSM0CAPTCTRLB_EDGCNTB_EN(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM0CAPTCTRLB.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetSM0CAPTCTRLB_EDGCNTB_EN() uint16 {
	return (volatile.LoadUint16(&o.SM0CAPTCTRLB.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetSM0CAPTCTRLB_CFBWM(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM0CAPTCTRLB.Reg)&^(0x300)|value<<8)
}
func (o *PWM_Type) GetSM0CAPTCTRLB_CFBWM() uint16 {
	return (volatile.LoadUint16(&o.SM0CAPTCTRLB.Reg) & 0x300) >> 8
}
func (o *PWM_Type) SetSM0CAPTCTRLB_CB0CNT(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM0CAPTCTRLB.Reg)&^(0x1c00)|value<<10)
}
func (o *PWM_Type) GetSM0CAPTCTRLB_CB0CNT() uint16 {
	return (volatile.LoadUint16(&o.SM0CAPTCTRLB.Reg) & 0x1c00) >> 10
}
func (o *PWM_Type) SetSM0CAPTCTRLB_CB1CNT(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM0CAPTCTRLB.Reg)&^(0xe000)|value<<13)
}
func (o *PWM_Type) GetSM0CAPTCTRLB_CB1CNT() uint16 {
	return (volatile.LoadUint16(&o.SM0CAPTCTRLB.Reg) & 0xe000) >> 13
}

// PWM.SM0CAPTCOMPB: Capture Compare B Register
func (o *PWM_Type) SetSM0CAPTCOMPB_EDGCMPB(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCOMPB.Reg, volatile.LoadUint16(&o.SM0CAPTCOMPB.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetSM0CAPTCOMPB_EDGCMPB() uint16 {
	return volatile.LoadUint16(&o.SM0CAPTCOMPB.Reg) & 0xff
}
func (o *PWM_Type) SetSM0CAPTCOMPB_EDGCNTB(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCOMPB.Reg, volatile.LoadUint16(&o.SM0CAPTCOMPB.Reg)&^(0xff00)|value<<8)
}
func (o *PWM_Type) GetSM0CAPTCOMPB_EDGCNTB() uint16 {
	return (volatile.LoadUint16(&o.SM0CAPTCOMPB.Reg) & 0xff00) >> 8
}

// PWM.SM0CAPTCTRLX: Capture Control X Register
func (o *PWM_Type) SetSM0CAPTCTRLX_ARMX(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM0CAPTCTRLX.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSM0CAPTCTRLX_ARMX() uint16 {
	return volatile.LoadUint16(&o.SM0CAPTCTRLX.Reg) & 0x1
}
func (o *PWM_Type) SetSM0CAPTCTRLX_ONESHOTX(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM0CAPTCTRLX.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSM0CAPTCTRLX_ONESHOTX() uint16 {
	return (volatile.LoadUint16(&o.SM0CAPTCTRLX.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSM0CAPTCTRLX_EDGX0(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM0CAPTCTRLX.Reg)&^(0xc)|value<<2)
}
func (o *PWM_Type) GetSM0CAPTCTRLX_EDGX0() uint16 {
	return (volatile.LoadUint16(&o.SM0CAPTCTRLX.Reg) & 0xc) >> 2
}
func (o *PWM_Type) SetSM0CAPTCTRLX_EDGX1(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM0CAPTCTRLX.Reg)&^(0x30)|value<<4)
}
func (o *PWM_Type) GetSM0CAPTCTRLX_EDGX1() uint16 {
	return (volatile.LoadUint16(&o.SM0CAPTCTRLX.Reg) & 0x30) >> 4
}
func (o *PWM_Type) SetSM0CAPTCTRLX_INP_SELX(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM0CAPTCTRLX.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetSM0CAPTCTRLX_INP_SELX() uint16 {
	return (volatile.LoadUint16(&o.SM0CAPTCTRLX.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetSM0CAPTCTRLX_EDGCNTX_EN(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM0CAPTCTRLX.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetSM0CAPTCTRLX_EDGCNTX_EN() uint16 {
	return (volatile.LoadUint16(&o.SM0CAPTCTRLX.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetSM0CAPTCTRLX_CFXWM(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM0CAPTCTRLX.Reg)&^(0x300)|value<<8)
}
func (o *PWM_Type) GetSM0CAPTCTRLX_CFXWM() uint16 {
	return (volatile.LoadUint16(&o.SM0CAPTCTRLX.Reg) & 0x300) >> 8
}
func (o *PWM_Type) SetSM0CAPTCTRLX_CX0CNT(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM0CAPTCTRLX.Reg)&^(0x1c00)|value<<10)
}
func (o *PWM_Type) GetSM0CAPTCTRLX_CX0CNT() uint16 {
	return (volatile.LoadUint16(&o.SM0CAPTCTRLX.Reg) & 0x1c00) >> 10
}
func (o *PWM_Type) SetSM0CAPTCTRLX_CX1CNT(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM0CAPTCTRLX.Reg)&^(0xe000)|value<<13)
}
func (o *PWM_Type) GetSM0CAPTCTRLX_CX1CNT() uint16 {
	return (volatile.LoadUint16(&o.SM0CAPTCTRLX.Reg) & 0xe000) >> 13
}

// PWM.SM0CAPTCOMPX: Capture Compare X Register
func (o *PWM_Type) SetSM0CAPTCOMPX_EDGCMPX(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCOMPX.Reg, volatile.LoadUint16(&o.SM0CAPTCOMPX.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetSM0CAPTCOMPX_EDGCMPX() uint16 {
	return volatile.LoadUint16(&o.SM0CAPTCOMPX.Reg) & 0xff
}
func (o *PWM_Type) SetSM0CAPTCOMPX_EDGCNTX(value uint16) {
	volatile.StoreUint16(&o.SM0CAPTCOMPX.Reg, volatile.LoadUint16(&o.SM0CAPTCOMPX.Reg)&^(0xff00)|value<<8)
}
func (o *PWM_Type) GetSM0CAPTCOMPX_EDGCNTX() uint16 {
	return (volatile.LoadUint16(&o.SM0CAPTCOMPX.Reg) & 0xff00) >> 8
}

// PWM.SM0CVAL0: Capture Value 0 Register
func (o *PWM_Type) SetSM0CVAL0(value uint16) {
	volatile.StoreUint16(&o.SM0CVAL0.Reg, value)
}
func (o *PWM_Type) GetSM0CVAL0() uint16 {
	return volatile.LoadUint16(&o.SM0CVAL0.Reg)
}

// PWM.SM0CVAL0CYC: Capture Value 0 Cycle Register
func (o *PWM_Type) SetSM0CVAL0CYC_CVAL0CYC(value uint16) {
	volatile.StoreUint16(&o.SM0CVAL0CYC.Reg, volatile.LoadUint16(&o.SM0CVAL0CYC.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM0CVAL0CYC_CVAL0CYC() uint16 {
	return volatile.LoadUint16(&o.SM0CVAL0CYC.Reg) & 0xf
}

// PWM.SM0CVAL1: Capture Value 1 Register
func (o *PWM_Type) SetSM0CVAL1(value uint16) {
	volatile.StoreUint16(&o.SM0CVAL1.Reg, value)
}
func (o *PWM_Type) GetSM0CVAL1() uint16 {
	return volatile.LoadUint16(&o.SM0CVAL1.Reg)
}

// PWM.SM0CVAL1CYC: Capture Value 1 Cycle Register
func (o *PWM_Type) SetSM0CVAL1CYC_CVAL1CYC(value uint16) {
	volatile.StoreUint16(&o.SM0CVAL1CYC.Reg, volatile.LoadUint16(&o.SM0CVAL1CYC.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM0CVAL1CYC_CVAL1CYC() uint16 {
	return volatile.LoadUint16(&o.SM0CVAL1CYC.Reg) & 0xf
}

// PWM.SM0CVAL2: Capture Value 2 Register
func (o *PWM_Type) SetSM0CVAL2(value uint16) {
	volatile.StoreUint16(&o.SM0CVAL2.Reg, value)
}
func (o *PWM_Type) GetSM0CVAL2() uint16 {
	return volatile.LoadUint16(&o.SM0CVAL2.Reg)
}

// PWM.SM0CVAL2CYC: Capture Value 2 Cycle Register
func (o *PWM_Type) SetSM0CVAL2CYC_CVAL2CYC(value uint16) {
	volatile.StoreUint16(&o.SM0CVAL2CYC.Reg, volatile.LoadUint16(&o.SM0CVAL2CYC.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM0CVAL2CYC_CVAL2CYC() uint16 {
	return volatile.LoadUint16(&o.SM0CVAL2CYC.Reg) & 0xf
}

// PWM.SM0CVAL3: Capture Value 3 Register
func (o *PWM_Type) SetSM0CVAL3(value uint16) {
	volatile.StoreUint16(&o.SM0CVAL3.Reg, value)
}
func (o *PWM_Type) GetSM0CVAL3() uint16 {
	return volatile.LoadUint16(&o.SM0CVAL3.Reg)
}

// PWM.SM0CVAL3CYC: Capture Value 3 Cycle Register
func (o *PWM_Type) SetSM0CVAL3CYC_CVAL3CYC(value uint16) {
	volatile.StoreUint16(&o.SM0CVAL3CYC.Reg, volatile.LoadUint16(&o.SM0CVAL3CYC.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM0CVAL3CYC_CVAL3CYC() uint16 {
	return volatile.LoadUint16(&o.SM0CVAL3CYC.Reg) & 0xf
}

// PWM.SM0CVAL4: Capture Value 4 Register
func (o *PWM_Type) SetSM0CVAL4(value uint16) {
	volatile.StoreUint16(&o.SM0CVAL4.Reg, value)
}
func (o *PWM_Type) GetSM0CVAL4() uint16 {
	return volatile.LoadUint16(&o.SM0CVAL4.Reg)
}

// PWM.SM0CVAL4CYC: Capture Value 4 Cycle Register
func (o *PWM_Type) SetSM0CVAL4CYC_CVAL4CYC(value uint16) {
	volatile.StoreUint16(&o.SM0CVAL4CYC.Reg, volatile.LoadUint16(&o.SM0CVAL4CYC.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM0CVAL4CYC_CVAL4CYC() uint16 {
	return volatile.LoadUint16(&o.SM0CVAL4CYC.Reg) & 0xf
}

// PWM.SM0CVAL5: Capture Value 5 Register
func (o *PWM_Type) SetSM0CVAL5(value uint16) {
	volatile.StoreUint16(&o.SM0CVAL5.Reg, value)
}
func (o *PWM_Type) GetSM0CVAL5() uint16 {
	return volatile.LoadUint16(&o.SM0CVAL5.Reg)
}

// PWM.SM0CVAL5CYC: Capture Value 5 Cycle Register
func (o *PWM_Type) SetSM0CVAL5CYC_CVAL5CYC(value uint16) {
	volatile.StoreUint16(&o.SM0CVAL5CYC.Reg, volatile.LoadUint16(&o.SM0CVAL5CYC.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM0CVAL5CYC_CVAL5CYC() uint16 {
	return volatile.LoadUint16(&o.SM0CVAL5CYC.Reg) & 0xf
}

// PWM.SM0PHASEDLY: Phase Delay Register
func (o *PWM_Type) SetSM0PHASEDLY(value uint16) {
	volatile.StoreUint16(&o.SM0PHASEDLY.Reg, value)
}
func (o *PWM_Type) GetSM0PHASEDLY() uint16 {
	return volatile.LoadUint16(&o.SM0PHASEDLY.Reg)
}

// PWM.SM1CNT: Counter Register
func (o *PWM_Type) SetSM1CNT(value uint16) {
	volatile.StoreUint16(&o.SM1CNT.Reg, value)
}
func (o *PWM_Type) GetSM1CNT() uint16 {
	return volatile.LoadUint16(&o.SM1CNT.Reg)
}

// PWM.SM1INIT: Initial Count Register
func (o *PWM_Type) SetSM1INIT(value uint16) {
	volatile.StoreUint16(&o.SM1INIT.Reg, value)
}
func (o *PWM_Type) GetSM1INIT() uint16 {
	return volatile.LoadUint16(&o.SM1INIT.Reg)
}

// PWM.SM1CTRL2: Control 2 Register
func (o *PWM_Type) SetSM1CTRL2_CLK_SEL(value uint16) {
	volatile.StoreUint16(&o.SM1CTRL2.Reg, volatile.LoadUint16(&o.SM1CTRL2.Reg)&^(0x3)|value)
}
func (o *PWM_Type) GetSM1CTRL2_CLK_SEL() uint16 {
	return volatile.LoadUint16(&o.SM1CTRL2.Reg) & 0x3
}
func (o *PWM_Type) SetSM1CTRL2_RELOAD_SEL(value uint16) {
	volatile.StoreUint16(&o.SM1CTRL2.Reg, volatile.LoadUint16(&o.SM1CTRL2.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetSM1CTRL2_RELOAD_SEL() uint16 {
	return (volatile.LoadUint16(&o.SM1CTRL2.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetSM1CTRL2_FORCE_SEL(value uint16) {
	volatile.StoreUint16(&o.SM1CTRL2.Reg, volatile.LoadUint16(&o.SM1CTRL2.Reg)&^(0x38)|value<<3)
}
func (o *PWM_Type) GetSM1CTRL2_FORCE_SEL() uint16 {
	return (volatile.LoadUint16(&o.SM1CTRL2.Reg) & 0x38) >> 3
}
func (o *PWM_Type) SetSM1CTRL2_FORCE(value uint16) {
	volatile.StoreUint16(&o.SM1CTRL2.Reg, volatile.LoadUint16(&o.SM1CTRL2.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetSM1CTRL2_FORCE() uint16 {
	return (volatile.LoadUint16(&o.SM1CTRL2.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetSM1CTRL2_FRCEN(value uint16) {
	volatile.StoreUint16(&o.SM1CTRL2.Reg, volatile.LoadUint16(&o.SM1CTRL2.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetSM1CTRL2_FRCEN() uint16 {
	return (volatile.LoadUint16(&o.SM1CTRL2.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetSM1CTRL2_INIT_SEL(value uint16) {
	volatile.StoreUint16(&o.SM1CTRL2.Reg, volatile.LoadUint16(&o.SM1CTRL2.Reg)&^(0x300)|value<<8)
}
func (o *PWM_Type) GetSM1CTRL2_INIT_SEL() uint16 {
	return (volatile.LoadUint16(&o.SM1CTRL2.Reg) & 0x300) >> 8
}
func (o *PWM_Type) SetSM1CTRL2_PWMX_INIT(value uint16) {
	volatile.StoreUint16(&o.SM1CTRL2.Reg, volatile.LoadUint16(&o.SM1CTRL2.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetSM1CTRL2_PWMX_INIT() uint16 {
	return (volatile.LoadUint16(&o.SM1CTRL2.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetSM1CTRL2_PWM45_INIT(value uint16) {
	volatile.StoreUint16(&o.SM1CTRL2.Reg, volatile.LoadUint16(&o.SM1CTRL2.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetSM1CTRL2_PWM45_INIT() uint16 {
	return (volatile.LoadUint16(&o.SM1CTRL2.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetSM1CTRL2_PWM23_INIT(value uint16) {
	volatile.StoreUint16(&o.SM1CTRL2.Reg, volatile.LoadUint16(&o.SM1CTRL2.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetSM1CTRL2_PWM23_INIT() uint16 {
	return (volatile.LoadUint16(&o.SM1CTRL2.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetSM1CTRL2_INDEP(value uint16) {
	volatile.StoreUint16(&o.SM1CTRL2.Reg, volatile.LoadUint16(&o.SM1CTRL2.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetSM1CTRL2_INDEP() uint16 {
	return (volatile.LoadUint16(&o.SM1CTRL2.Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetSM1CTRL2_WAITEN(value uint16) {
	volatile.StoreUint16(&o.SM1CTRL2.Reg, volatile.LoadUint16(&o.SM1CTRL2.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetSM1CTRL2_WAITEN() uint16 {
	return (volatile.LoadUint16(&o.SM1CTRL2.Reg) & 0x4000) >> 14
}
func (o *PWM_Type) SetSM1CTRL2_DBGEN(value uint16) {
	volatile.StoreUint16(&o.SM1CTRL2.Reg, volatile.LoadUint16(&o.SM1CTRL2.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetSM1CTRL2_DBGEN() uint16 {
	return (volatile.LoadUint16(&o.SM1CTRL2.Reg) & 0x8000) >> 15
}

// PWM.SM1CTRL: Control Register
func (o *PWM_Type) SetSM1CTRL_DBLEN(value uint16) {
	volatile.StoreUint16(&o.SM1CTRL.Reg, volatile.LoadUint16(&o.SM1CTRL.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSM1CTRL_DBLEN() uint16 {
	return volatile.LoadUint16(&o.SM1CTRL.Reg) & 0x1
}
func (o *PWM_Type) SetSM1CTRL_DBLX(value uint16) {
	volatile.StoreUint16(&o.SM1CTRL.Reg, volatile.LoadUint16(&o.SM1CTRL.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSM1CTRL_DBLX() uint16 {
	return (volatile.LoadUint16(&o.SM1CTRL.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSM1CTRL_LDMOD(value uint16) {
	volatile.StoreUint16(&o.SM1CTRL.Reg, volatile.LoadUint16(&o.SM1CTRL.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetSM1CTRL_LDMOD() uint16 {
	return (volatile.LoadUint16(&o.SM1CTRL.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetSM1CTRL_SPLIT(value uint16) {
	volatile.StoreUint16(&o.SM1CTRL.Reg, volatile.LoadUint16(&o.SM1CTRL.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetSM1CTRL_SPLIT() uint16 {
	return (volatile.LoadUint16(&o.SM1CTRL.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetSM1CTRL_PRSC(value uint16) {
	volatile.StoreUint16(&o.SM1CTRL.Reg, volatile.LoadUint16(&o.SM1CTRL.Reg)&^(0x70)|value<<4)
}
func (o *PWM_Type) GetSM1CTRL_PRSC() uint16 {
	return (volatile.LoadUint16(&o.SM1CTRL.Reg) & 0x70) >> 4
}
func (o *PWM_Type) SetSM1CTRL_COMPMODE(value uint16) {
	volatile.StoreUint16(&o.SM1CTRL.Reg, volatile.LoadUint16(&o.SM1CTRL.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetSM1CTRL_COMPMODE() uint16 {
	return (volatile.LoadUint16(&o.SM1CTRL.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetSM1CTRL_DT(value uint16) {
	volatile.StoreUint16(&o.SM1CTRL.Reg, volatile.LoadUint16(&o.SM1CTRL.Reg)&^(0x300)|value<<8)
}
func (o *PWM_Type) GetSM1CTRL_DT() uint16 {
	return (volatile.LoadUint16(&o.SM1CTRL.Reg) & 0x300) >> 8
}
func (o *PWM_Type) SetSM1CTRL_FULL(value uint16) {
	volatile.StoreUint16(&o.SM1CTRL.Reg, volatile.LoadUint16(&o.SM1CTRL.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetSM1CTRL_FULL() uint16 {
	return (volatile.LoadUint16(&o.SM1CTRL.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetSM1CTRL_HALF(value uint16) {
	volatile.StoreUint16(&o.SM1CTRL.Reg, volatile.LoadUint16(&o.SM1CTRL.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetSM1CTRL_HALF() uint16 {
	return (volatile.LoadUint16(&o.SM1CTRL.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetSM1CTRL_LDFQ(value uint16) {
	volatile.StoreUint16(&o.SM1CTRL.Reg, volatile.LoadUint16(&o.SM1CTRL.Reg)&^(0xf000)|value<<12)
}
func (o *PWM_Type) GetSM1CTRL_LDFQ() uint16 {
	return (volatile.LoadUint16(&o.SM1CTRL.Reg) & 0xf000) >> 12
}

// PWM.SM1VAL0: Value Register 0
func (o *PWM_Type) SetSM1VAL0(value uint16) {
	volatile.StoreUint16(&o.SM1VAL0.Reg, value)
}
func (o *PWM_Type) GetSM1VAL0() uint16 {
	return volatile.LoadUint16(&o.SM1VAL0.Reg)
}

// PWM.SM1FRACVAL1: Fractional Value Register 1
func (o *PWM_Type) SetSM1FRACVAL1_FRACVAL1(value uint16) {
	volatile.StoreUint16(&o.SM1FRACVAL1.Reg, volatile.LoadUint16(&o.SM1FRACVAL1.Reg)&^(0xf800)|value<<11)
}
func (o *PWM_Type) GetSM1FRACVAL1_FRACVAL1() uint16 {
	return (volatile.LoadUint16(&o.SM1FRACVAL1.Reg) & 0xf800) >> 11
}

// PWM.SM1VAL1: Value Register 1
func (o *PWM_Type) SetSM1VAL1(value uint16) {
	volatile.StoreUint16(&o.SM1VAL1.Reg, value)
}
func (o *PWM_Type) GetSM1VAL1() uint16 {
	return volatile.LoadUint16(&o.SM1VAL1.Reg)
}

// PWM.SM1FRACVAL2: Fractional Value Register 2
func (o *PWM_Type) SetSM1FRACVAL2_FRACVAL2(value uint16) {
	volatile.StoreUint16(&o.SM1FRACVAL2.Reg, volatile.LoadUint16(&o.SM1FRACVAL2.Reg)&^(0xf800)|value<<11)
}
func (o *PWM_Type) GetSM1FRACVAL2_FRACVAL2() uint16 {
	return (volatile.LoadUint16(&o.SM1FRACVAL2.Reg) & 0xf800) >> 11
}

// PWM.SM1VAL2: Value Register 2
func (o *PWM_Type) SetSM1VAL2(value uint16) {
	volatile.StoreUint16(&o.SM1VAL2.Reg, value)
}
func (o *PWM_Type) GetSM1VAL2() uint16 {
	return volatile.LoadUint16(&o.SM1VAL2.Reg)
}

// PWM.SM1FRACVAL3: Fractional Value Register 3
func (o *PWM_Type) SetSM1FRACVAL3_FRACVAL3(value uint16) {
	volatile.StoreUint16(&o.SM1FRACVAL3.Reg, volatile.LoadUint16(&o.SM1FRACVAL3.Reg)&^(0xf800)|value<<11)
}
func (o *PWM_Type) GetSM1FRACVAL3_FRACVAL3() uint16 {
	return (volatile.LoadUint16(&o.SM1FRACVAL3.Reg) & 0xf800) >> 11
}

// PWM.SM1VAL3: Value Register 3
func (o *PWM_Type) SetSM1VAL3(value uint16) {
	volatile.StoreUint16(&o.SM1VAL3.Reg, value)
}
func (o *PWM_Type) GetSM1VAL3() uint16 {
	return volatile.LoadUint16(&o.SM1VAL3.Reg)
}

// PWM.SM1FRACVAL4: Fractional Value Register 4
func (o *PWM_Type) SetSM1FRACVAL4_FRACVAL4(value uint16) {
	volatile.StoreUint16(&o.SM1FRACVAL4.Reg, volatile.LoadUint16(&o.SM1FRACVAL4.Reg)&^(0xf800)|value<<11)
}
func (o *PWM_Type) GetSM1FRACVAL4_FRACVAL4() uint16 {
	return (volatile.LoadUint16(&o.SM1FRACVAL4.Reg) & 0xf800) >> 11
}

// PWM.SM1VAL4: Value Register 4
func (o *PWM_Type) SetSM1VAL4(value uint16) {
	volatile.StoreUint16(&o.SM1VAL4.Reg, value)
}
func (o *PWM_Type) GetSM1VAL4() uint16 {
	return volatile.LoadUint16(&o.SM1VAL4.Reg)
}

// PWM.SM1FRACVAL5: Fractional Value Register 5
func (o *PWM_Type) SetSM1FRACVAL5_FRACVAL5(value uint16) {
	volatile.StoreUint16(&o.SM1FRACVAL5.Reg, volatile.LoadUint16(&o.SM1FRACVAL5.Reg)&^(0xf800)|value<<11)
}
func (o *PWM_Type) GetSM1FRACVAL5_FRACVAL5() uint16 {
	return (volatile.LoadUint16(&o.SM1FRACVAL5.Reg) & 0xf800) >> 11
}

// PWM.SM1VAL5: Value Register 5
func (o *PWM_Type) SetSM1VAL5(value uint16) {
	volatile.StoreUint16(&o.SM1VAL5.Reg, value)
}
func (o *PWM_Type) GetSM1VAL5() uint16 {
	return volatile.LoadUint16(&o.SM1VAL5.Reg)
}

// PWM.SM1FRCTRL: Fractional Control Register
func (o *PWM_Type) SetSM1FRCTRL_FRAC1_EN(value uint16) {
	volatile.StoreUint16(&o.SM1FRCTRL.Reg, volatile.LoadUint16(&o.SM1FRCTRL.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSM1FRCTRL_FRAC1_EN() uint16 {
	return (volatile.LoadUint16(&o.SM1FRCTRL.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSM1FRCTRL_FRAC23_EN(value uint16) {
	volatile.StoreUint16(&o.SM1FRCTRL.Reg, volatile.LoadUint16(&o.SM1FRCTRL.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetSM1FRCTRL_FRAC23_EN() uint16 {
	return (volatile.LoadUint16(&o.SM1FRCTRL.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetSM1FRCTRL_FRAC45_EN(value uint16) {
	volatile.StoreUint16(&o.SM1FRCTRL.Reg, volatile.LoadUint16(&o.SM1FRCTRL.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetSM1FRCTRL_FRAC45_EN() uint16 {
	return (volatile.LoadUint16(&o.SM1FRCTRL.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetSM1FRCTRL_FRAC_PU(value uint16) {
	volatile.StoreUint16(&o.SM1FRCTRL.Reg, volatile.LoadUint16(&o.SM1FRCTRL.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetSM1FRCTRL_FRAC_PU() uint16 {
	return (volatile.LoadUint16(&o.SM1FRCTRL.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetSM1FRCTRL_TEST(value uint16) {
	volatile.StoreUint16(&o.SM1FRCTRL.Reg, volatile.LoadUint16(&o.SM1FRCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetSM1FRCTRL_TEST() uint16 {
	return (volatile.LoadUint16(&o.SM1FRCTRL.Reg) & 0x8000) >> 15
}

// PWM.SM1OCTRL: Output Control Register
func (o *PWM_Type) SetSM1OCTRL_PWMXFS(value uint16) {
	volatile.StoreUint16(&o.SM1OCTRL.Reg, volatile.LoadUint16(&o.SM1OCTRL.Reg)&^(0x3)|value)
}
func (o *PWM_Type) GetSM1OCTRL_PWMXFS() uint16 {
	return volatile.LoadUint16(&o.SM1OCTRL.Reg) & 0x3
}
func (o *PWM_Type) SetSM1OCTRL_PWMBFS(value uint16) {
	volatile.StoreUint16(&o.SM1OCTRL.Reg, volatile.LoadUint16(&o.SM1OCTRL.Reg)&^(0xc)|value<<2)
}
func (o *PWM_Type) GetSM1OCTRL_PWMBFS() uint16 {
	return (volatile.LoadUint16(&o.SM1OCTRL.Reg) & 0xc) >> 2
}
func (o *PWM_Type) SetSM1OCTRL_PWMAFS(value uint16) {
	volatile.StoreUint16(&o.SM1OCTRL.Reg, volatile.LoadUint16(&o.SM1OCTRL.Reg)&^(0x30)|value<<4)
}
func (o *PWM_Type) GetSM1OCTRL_PWMAFS() uint16 {
	return (volatile.LoadUint16(&o.SM1OCTRL.Reg) & 0x30) >> 4
}
func (o *PWM_Type) SetSM1OCTRL_POLX(value uint16) {
	volatile.StoreUint16(&o.SM1OCTRL.Reg, volatile.LoadUint16(&o.SM1OCTRL.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetSM1OCTRL_POLX() uint16 {
	return (volatile.LoadUint16(&o.SM1OCTRL.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetSM1OCTRL_POLB(value uint16) {
	volatile.StoreUint16(&o.SM1OCTRL.Reg, volatile.LoadUint16(&o.SM1OCTRL.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetSM1OCTRL_POLB() uint16 {
	return (volatile.LoadUint16(&o.SM1OCTRL.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetSM1OCTRL_POLA(value uint16) {
	volatile.StoreUint16(&o.SM1OCTRL.Reg, volatile.LoadUint16(&o.SM1OCTRL.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetSM1OCTRL_POLA() uint16 {
	return (volatile.LoadUint16(&o.SM1OCTRL.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetSM1OCTRL_PWMX_IN(value uint16) {
	volatile.StoreUint16(&o.SM1OCTRL.Reg, volatile.LoadUint16(&o.SM1OCTRL.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetSM1OCTRL_PWMX_IN() uint16 {
	return (volatile.LoadUint16(&o.SM1OCTRL.Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetSM1OCTRL_PWMB_IN(value uint16) {
	volatile.StoreUint16(&o.SM1OCTRL.Reg, volatile.LoadUint16(&o.SM1OCTRL.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetSM1OCTRL_PWMB_IN() uint16 {
	return (volatile.LoadUint16(&o.SM1OCTRL.Reg) & 0x4000) >> 14
}
func (o *PWM_Type) SetSM1OCTRL_PWMA_IN(value uint16) {
	volatile.StoreUint16(&o.SM1OCTRL.Reg, volatile.LoadUint16(&o.SM1OCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetSM1OCTRL_PWMA_IN() uint16 {
	return (volatile.LoadUint16(&o.SM1OCTRL.Reg) & 0x8000) >> 15
}

// PWM.SM1STS: Status Register
func (o *PWM_Type) SetSM1STS_CMPF(value uint16) {
	volatile.StoreUint16(&o.SM1STS.Reg, volatile.LoadUint16(&o.SM1STS.Reg)&^(0x3f)|value)
}
func (o *PWM_Type) GetSM1STS_CMPF() uint16 {
	return volatile.LoadUint16(&o.SM1STS.Reg) & 0x3f
}
func (o *PWM_Type) SetSM1STS_CFX0(value uint16) {
	volatile.StoreUint16(&o.SM1STS.Reg, volatile.LoadUint16(&o.SM1STS.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetSM1STS_CFX0() uint16 {
	return (volatile.LoadUint16(&o.SM1STS.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetSM1STS_CFX1(value uint16) {
	volatile.StoreUint16(&o.SM1STS.Reg, volatile.LoadUint16(&o.SM1STS.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetSM1STS_CFX1() uint16 {
	return (volatile.LoadUint16(&o.SM1STS.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetSM1STS_CFB0(value uint16) {
	volatile.StoreUint16(&o.SM1STS.Reg, volatile.LoadUint16(&o.SM1STS.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetSM1STS_CFB0() uint16 {
	return (volatile.LoadUint16(&o.SM1STS.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetSM1STS_CFB1(value uint16) {
	volatile.StoreUint16(&o.SM1STS.Reg, volatile.LoadUint16(&o.SM1STS.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetSM1STS_CFB1() uint16 {
	return (volatile.LoadUint16(&o.SM1STS.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetSM1STS_CFA0(value uint16) {
	volatile.StoreUint16(&o.SM1STS.Reg, volatile.LoadUint16(&o.SM1STS.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetSM1STS_CFA0() uint16 {
	return (volatile.LoadUint16(&o.SM1STS.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetSM1STS_CFA1(value uint16) {
	volatile.StoreUint16(&o.SM1STS.Reg, volatile.LoadUint16(&o.SM1STS.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetSM1STS_CFA1() uint16 {
	return (volatile.LoadUint16(&o.SM1STS.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetSM1STS_RF(value uint16) {
	volatile.StoreUint16(&o.SM1STS.Reg, volatile.LoadUint16(&o.SM1STS.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetSM1STS_RF() uint16 {
	return (volatile.LoadUint16(&o.SM1STS.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetSM1STS_REF(value uint16) {
	volatile.StoreUint16(&o.SM1STS.Reg, volatile.LoadUint16(&o.SM1STS.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetSM1STS_REF() uint16 {
	return (volatile.LoadUint16(&o.SM1STS.Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetSM1STS_RUF(value uint16) {
	volatile.StoreUint16(&o.SM1STS.Reg, volatile.LoadUint16(&o.SM1STS.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetSM1STS_RUF() uint16 {
	return (volatile.LoadUint16(&o.SM1STS.Reg) & 0x4000) >> 14
}

// PWM.SM1INTEN: Interrupt Enable Register
func (o *PWM_Type) SetSM1INTEN_CMPIE(value uint16) {
	volatile.StoreUint16(&o.SM1INTEN.Reg, volatile.LoadUint16(&o.SM1INTEN.Reg)&^(0x3f)|value)
}
func (o *PWM_Type) GetSM1INTEN_CMPIE() uint16 {
	return volatile.LoadUint16(&o.SM1INTEN.Reg) & 0x3f
}
func (o *PWM_Type) SetSM1INTEN_CX0IE(value uint16) {
	volatile.StoreUint16(&o.SM1INTEN.Reg, volatile.LoadUint16(&o.SM1INTEN.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetSM1INTEN_CX0IE() uint16 {
	return (volatile.LoadUint16(&o.SM1INTEN.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetSM1INTEN_CX1IE(value uint16) {
	volatile.StoreUint16(&o.SM1INTEN.Reg, volatile.LoadUint16(&o.SM1INTEN.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetSM1INTEN_CX1IE() uint16 {
	return (volatile.LoadUint16(&o.SM1INTEN.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetSM1INTEN_CB0IE(value uint16) {
	volatile.StoreUint16(&o.SM1INTEN.Reg, volatile.LoadUint16(&o.SM1INTEN.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetSM1INTEN_CB0IE() uint16 {
	return (volatile.LoadUint16(&o.SM1INTEN.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetSM1INTEN_CB1IE(value uint16) {
	volatile.StoreUint16(&o.SM1INTEN.Reg, volatile.LoadUint16(&o.SM1INTEN.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetSM1INTEN_CB1IE() uint16 {
	return (volatile.LoadUint16(&o.SM1INTEN.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetSM1INTEN_CA0IE(value uint16) {
	volatile.StoreUint16(&o.SM1INTEN.Reg, volatile.LoadUint16(&o.SM1INTEN.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetSM1INTEN_CA0IE() uint16 {
	return (volatile.LoadUint16(&o.SM1INTEN.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetSM1INTEN_CA1IE(value uint16) {
	volatile.StoreUint16(&o.SM1INTEN.Reg, volatile.LoadUint16(&o.SM1INTEN.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetSM1INTEN_CA1IE() uint16 {
	return (volatile.LoadUint16(&o.SM1INTEN.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetSM1INTEN_RIE(value uint16) {
	volatile.StoreUint16(&o.SM1INTEN.Reg, volatile.LoadUint16(&o.SM1INTEN.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetSM1INTEN_RIE() uint16 {
	return (volatile.LoadUint16(&o.SM1INTEN.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetSM1INTEN_REIE(value uint16) {
	volatile.StoreUint16(&o.SM1INTEN.Reg, volatile.LoadUint16(&o.SM1INTEN.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetSM1INTEN_REIE() uint16 {
	return (volatile.LoadUint16(&o.SM1INTEN.Reg) & 0x2000) >> 13
}

// PWM.SM1DMAEN: DMA Enable Register
func (o *PWM_Type) SetSM1DMAEN_CX0DE(value uint16) {
	volatile.StoreUint16(&o.SM1DMAEN.Reg, volatile.LoadUint16(&o.SM1DMAEN.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSM1DMAEN_CX0DE() uint16 {
	return volatile.LoadUint16(&o.SM1DMAEN.Reg) & 0x1
}
func (o *PWM_Type) SetSM1DMAEN_CX1DE(value uint16) {
	volatile.StoreUint16(&o.SM1DMAEN.Reg, volatile.LoadUint16(&o.SM1DMAEN.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSM1DMAEN_CX1DE() uint16 {
	return (volatile.LoadUint16(&o.SM1DMAEN.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSM1DMAEN_CB0DE(value uint16) {
	volatile.StoreUint16(&o.SM1DMAEN.Reg, volatile.LoadUint16(&o.SM1DMAEN.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetSM1DMAEN_CB0DE() uint16 {
	return (volatile.LoadUint16(&o.SM1DMAEN.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetSM1DMAEN_CB1DE(value uint16) {
	volatile.StoreUint16(&o.SM1DMAEN.Reg, volatile.LoadUint16(&o.SM1DMAEN.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetSM1DMAEN_CB1DE() uint16 {
	return (volatile.LoadUint16(&o.SM1DMAEN.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetSM1DMAEN_CA0DE(value uint16) {
	volatile.StoreUint16(&o.SM1DMAEN.Reg, volatile.LoadUint16(&o.SM1DMAEN.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetSM1DMAEN_CA0DE() uint16 {
	return (volatile.LoadUint16(&o.SM1DMAEN.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetSM1DMAEN_CA1DE(value uint16) {
	volatile.StoreUint16(&o.SM1DMAEN.Reg, volatile.LoadUint16(&o.SM1DMAEN.Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetSM1DMAEN_CA1DE() uint16 {
	return (volatile.LoadUint16(&o.SM1DMAEN.Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetSM1DMAEN_CAPTDE(value uint16) {
	volatile.StoreUint16(&o.SM1DMAEN.Reg, volatile.LoadUint16(&o.SM1DMAEN.Reg)&^(0xc0)|value<<6)
}
func (o *PWM_Type) GetSM1DMAEN_CAPTDE() uint16 {
	return (volatile.LoadUint16(&o.SM1DMAEN.Reg) & 0xc0) >> 6
}
func (o *PWM_Type) SetSM1DMAEN_FAND(value uint16) {
	volatile.StoreUint16(&o.SM1DMAEN.Reg, volatile.LoadUint16(&o.SM1DMAEN.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetSM1DMAEN_FAND() uint16 {
	return (volatile.LoadUint16(&o.SM1DMAEN.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetSM1DMAEN_VALDE(value uint16) {
	volatile.StoreUint16(&o.SM1DMAEN.Reg, volatile.LoadUint16(&o.SM1DMAEN.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetSM1DMAEN_VALDE() uint16 {
	return (volatile.LoadUint16(&o.SM1DMAEN.Reg) & 0x200) >> 9
}

// PWM.SM1TCTRL: Output Trigger Control Register
func (o *PWM_Type) SetSM1TCTRL_OUT_TRIG_EN(value uint16) {
	volatile.StoreUint16(&o.SM1TCTRL.Reg, volatile.LoadUint16(&o.SM1TCTRL.Reg)&^(0x3f)|value)
}
func (o *PWM_Type) GetSM1TCTRL_OUT_TRIG_EN() uint16 {
	return volatile.LoadUint16(&o.SM1TCTRL.Reg) & 0x3f
}
func (o *PWM_Type) SetSM1TCTRL_TRGFRQ(value uint16) {
	volatile.StoreUint16(&o.SM1TCTRL.Reg, volatile.LoadUint16(&o.SM1TCTRL.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetSM1TCTRL_TRGFRQ() uint16 {
	return (volatile.LoadUint16(&o.SM1TCTRL.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetSM1TCTRL_PWBOT1(value uint16) {
	volatile.StoreUint16(&o.SM1TCTRL.Reg, volatile.LoadUint16(&o.SM1TCTRL.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetSM1TCTRL_PWBOT1() uint16 {
	return (volatile.LoadUint16(&o.SM1TCTRL.Reg) & 0x4000) >> 14
}
func (o *PWM_Type) SetSM1TCTRL_PWAOT0(value uint16) {
	volatile.StoreUint16(&o.SM1TCTRL.Reg, volatile.LoadUint16(&o.SM1TCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetSM1TCTRL_PWAOT0() uint16 {
	return (volatile.LoadUint16(&o.SM1TCTRL.Reg) & 0x8000) >> 15
}

// PWM.SM1DISMAP0: Fault Disable Mapping Register 0
func (o *PWM_Type) SetSM1DISMAP0_DIS0A(value uint16) {
	volatile.StoreUint16(&o.SM1DISMAP0.Reg, volatile.LoadUint16(&o.SM1DISMAP0.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM1DISMAP0_DIS0A() uint16 {
	return volatile.LoadUint16(&o.SM1DISMAP0.Reg) & 0xf
}
func (o *PWM_Type) SetSM1DISMAP0_DIS0B(value uint16) {
	volatile.StoreUint16(&o.SM1DISMAP0.Reg, volatile.LoadUint16(&o.SM1DISMAP0.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetSM1DISMAP0_DIS0B() uint16 {
	return (volatile.LoadUint16(&o.SM1DISMAP0.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetSM1DISMAP0_DIS0X(value uint16) {
	volatile.StoreUint16(&o.SM1DISMAP0.Reg, volatile.LoadUint16(&o.SM1DISMAP0.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetSM1DISMAP0_DIS0X() uint16 {
	return (volatile.LoadUint16(&o.SM1DISMAP0.Reg) & 0xf00) >> 8
}

// PWM.SM1DISMAP1: Fault Disable Mapping Register 1
func (o *PWM_Type) SetSM1DISMAP1_DIS1A(value uint16) {
	volatile.StoreUint16(&o.SM1DISMAP1.Reg, volatile.LoadUint16(&o.SM1DISMAP1.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM1DISMAP1_DIS1A() uint16 {
	return volatile.LoadUint16(&o.SM1DISMAP1.Reg) & 0xf
}
func (o *PWM_Type) SetSM1DISMAP1_DIS1B(value uint16) {
	volatile.StoreUint16(&o.SM1DISMAP1.Reg, volatile.LoadUint16(&o.SM1DISMAP1.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetSM1DISMAP1_DIS1B() uint16 {
	return (volatile.LoadUint16(&o.SM1DISMAP1.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetSM1DISMAP1_DIS1X(value uint16) {
	volatile.StoreUint16(&o.SM1DISMAP1.Reg, volatile.LoadUint16(&o.SM1DISMAP1.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetSM1DISMAP1_DIS1X() uint16 {
	return (volatile.LoadUint16(&o.SM1DISMAP1.Reg) & 0xf00) >> 8
}

// PWM.SM1DTCNT0: Deadtime Count Register 0
func (o *PWM_Type) SetSM1DTCNT0(value uint16) {
	volatile.StoreUint16(&o.SM1DTCNT0.Reg, value)
}
func (o *PWM_Type) GetSM1DTCNT0() uint16 {
	return volatile.LoadUint16(&o.SM1DTCNT0.Reg)
}

// PWM.SM1DTCNT1: Deadtime Count Register 1
func (o *PWM_Type) SetSM1DTCNT1(value uint16) {
	volatile.StoreUint16(&o.SM1DTCNT1.Reg, value)
}
func (o *PWM_Type) GetSM1DTCNT1() uint16 {
	return volatile.LoadUint16(&o.SM1DTCNT1.Reg)
}

// PWM.SM1CAPTCTRLA: Capture Control A Register
func (o *PWM_Type) SetSM1CAPTCTRLA_ARMA(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM1CAPTCTRLA.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSM1CAPTCTRLA_ARMA() uint16 {
	return volatile.LoadUint16(&o.SM1CAPTCTRLA.Reg) & 0x1
}
func (o *PWM_Type) SetSM1CAPTCTRLA_ONESHOTA(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM1CAPTCTRLA.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSM1CAPTCTRLA_ONESHOTA() uint16 {
	return (volatile.LoadUint16(&o.SM1CAPTCTRLA.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSM1CAPTCTRLA_EDGA0(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM1CAPTCTRLA.Reg)&^(0xc)|value<<2)
}
func (o *PWM_Type) GetSM1CAPTCTRLA_EDGA0() uint16 {
	return (volatile.LoadUint16(&o.SM1CAPTCTRLA.Reg) & 0xc) >> 2
}
func (o *PWM_Type) SetSM1CAPTCTRLA_EDGA1(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM1CAPTCTRLA.Reg)&^(0x30)|value<<4)
}
func (o *PWM_Type) GetSM1CAPTCTRLA_EDGA1() uint16 {
	return (volatile.LoadUint16(&o.SM1CAPTCTRLA.Reg) & 0x30) >> 4
}
func (o *PWM_Type) SetSM1CAPTCTRLA_INP_SELA(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM1CAPTCTRLA.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetSM1CAPTCTRLA_INP_SELA() uint16 {
	return (volatile.LoadUint16(&o.SM1CAPTCTRLA.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetSM1CAPTCTRLA_EDGCNTA_EN(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM1CAPTCTRLA.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetSM1CAPTCTRLA_EDGCNTA_EN() uint16 {
	return (volatile.LoadUint16(&o.SM1CAPTCTRLA.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetSM1CAPTCTRLA_CFAWM(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM1CAPTCTRLA.Reg)&^(0x300)|value<<8)
}
func (o *PWM_Type) GetSM1CAPTCTRLA_CFAWM() uint16 {
	return (volatile.LoadUint16(&o.SM1CAPTCTRLA.Reg) & 0x300) >> 8
}
func (o *PWM_Type) SetSM1CAPTCTRLA_CA0CNT(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM1CAPTCTRLA.Reg)&^(0x1c00)|value<<10)
}
func (o *PWM_Type) GetSM1CAPTCTRLA_CA0CNT() uint16 {
	return (volatile.LoadUint16(&o.SM1CAPTCTRLA.Reg) & 0x1c00) >> 10
}
func (o *PWM_Type) SetSM1CAPTCTRLA_CA1CNT(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM1CAPTCTRLA.Reg)&^(0xe000)|value<<13)
}
func (o *PWM_Type) GetSM1CAPTCTRLA_CA1CNT() uint16 {
	return (volatile.LoadUint16(&o.SM1CAPTCTRLA.Reg) & 0xe000) >> 13
}

// PWM.SM1CAPTCOMPA: Capture Compare A Register
func (o *PWM_Type) SetSM1CAPTCOMPA_EDGCMPA(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCOMPA.Reg, volatile.LoadUint16(&o.SM1CAPTCOMPA.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetSM1CAPTCOMPA_EDGCMPA() uint16 {
	return volatile.LoadUint16(&o.SM1CAPTCOMPA.Reg) & 0xff
}
func (o *PWM_Type) SetSM1CAPTCOMPA_EDGCNTA(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCOMPA.Reg, volatile.LoadUint16(&o.SM1CAPTCOMPA.Reg)&^(0xff00)|value<<8)
}
func (o *PWM_Type) GetSM1CAPTCOMPA_EDGCNTA() uint16 {
	return (volatile.LoadUint16(&o.SM1CAPTCOMPA.Reg) & 0xff00) >> 8
}

// PWM.SM1CAPTCTRLB: Capture Control B Register
func (o *PWM_Type) SetSM1CAPTCTRLB_ARMB(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM1CAPTCTRLB.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSM1CAPTCTRLB_ARMB() uint16 {
	return volatile.LoadUint16(&o.SM1CAPTCTRLB.Reg) & 0x1
}
func (o *PWM_Type) SetSM1CAPTCTRLB_ONESHOTB(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM1CAPTCTRLB.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSM1CAPTCTRLB_ONESHOTB() uint16 {
	return (volatile.LoadUint16(&o.SM1CAPTCTRLB.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSM1CAPTCTRLB_EDGB0(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM1CAPTCTRLB.Reg)&^(0xc)|value<<2)
}
func (o *PWM_Type) GetSM1CAPTCTRLB_EDGB0() uint16 {
	return (volatile.LoadUint16(&o.SM1CAPTCTRLB.Reg) & 0xc) >> 2
}
func (o *PWM_Type) SetSM1CAPTCTRLB_EDGB1(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM1CAPTCTRLB.Reg)&^(0x30)|value<<4)
}
func (o *PWM_Type) GetSM1CAPTCTRLB_EDGB1() uint16 {
	return (volatile.LoadUint16(&o.SM1CAPTCTRLB.Reg) & 0x30) >> 4
}
func (o *PWM_Type) SetSM1CAPTCTRLB_INP_SELB(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM1CAPTCTRLB.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetSM1CAPTCTRLB_INP_SELB() uint16 {
	return (volatile.LoadUint16(&o.SM1CAPTCTRLB.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetSM1CAPTCTRLB_EDGCNTB_EN(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM1CAPTCTRLB.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetSM1CAPTCTRLB_EDGCNTB_EN() uint16 {
	return (volatile.LoadUint16(&o.SM1CAPTCTRLB.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetSM1CAPTCTRLB_CFBWM(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM1CAPTCTRLB.Reg)&^(0x300)|value<<8)
}
func (o *PWM_Type) GetSM1CAPTCTRLB_CFBWM() uint16 {
	return (volatile.LoadUint16(&o.SM1CAPTCTRLB.Reg) & 0x300) >> 8
}
func (o *PWM_Type) SetSM1CAPTCTRLB_CB0CNT(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM1CAPTCTRLB.Reg)&^(0x1c00)|value<<10)
}
func (o *PWM_Type) GetSM1CAPTCTRLB_CB0CNT() uint16 {
	return (volatile.LoadUint16(&o.SM1CAPTCTRLB.Reg) & 0x1c00) >> 10
}
func (o *PWM_Type) SetSM1CAPTCTRLB_CB1CNT(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM1CAPTCTRLB.Reg)&^(0xe000)|value<<13)
}
func (o *PWM_Type) GetSM1CAPTCTRLB_CB1CNT() uint16 {
	return (volatile.LoadUint16(&o.SM1CAPTCTRLB.Reg) & 0xe000) >> 13
}

// PWM.SM1CAPTCOMPB: Capture Compare B Register
func (o *PWM_Type) SetSM1CAPTCOMPB_EDGCMPB(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCOMPB.Reg, volatile.LoadUint16(&o.SM1CAPTCOMPB.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetSM1CAPTCOMPB_EDGCMPB() uint16 {
	return volatile.LoadUint16(&o.SM1CAPTCOMPB.Reg) & 0xff
}
func (o *PWM_Type) SetSM1CAPTCOMPB_EDGCNTB(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCOMPB.Reg, volatile.LoadUint16(&o.SM1CAPTCOMPB.Reg)&^(0xff00)|value<<8)
}
func (o *PWM_Type) GetSM1CAPTCOMPB_EDGCNTB() uint16 {
	return (volatile.LoadUint16(&o.SM1CAPTCOMPB.Reg) & 0xff00) >> 8
}

// PWM.SM1CAPTCTRLX: Capture Control X Register
func (o *PWM_Type) SetSM1CAPTCTRLX_ARMX(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM1CAPTCTRLX.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSM1CAPTCTRLX_ARMX() uint16 {
	return volatile.LoadUint16(&o.SM1CAPTCTRLX.Reg) & 0x1
}
func (o *PWM_Type) SetSM1CAPTCTRLX_ONESHOTX(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM1CAPTCTRLX.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSM1CAPTCTRLX_ONESHOTX() uint16 {
	return (volatile.LoadUint16(&o.SM1CAPTCTRLX.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSM1CAPTCTRLX_EDGX0(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM1CAPTCTRLX.Reg)&^(0xc)|value<<2)
}
func (o *PWM_Type) GetSM1CAPTCTRLX_EDGX0() uint16 {
	return (volatile.LoadUint16(&o.SM1CAPTCTRLX.Reg) & 0xc) >> 2
}
func (o *PWM_Type) SetSM1CAPTCTRLX_EDGX1(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM1CAPTCTRLX.Reg)&^(0x30)|value<<4)
}
func (o *PWM_Type) GetSM1CAPTCTRLX_EDGX1() uint16 {
	return (volatile.LoadUint16(&o.SM1CAPTCTRLX.Reg) & 0x30) >> 4
}
func (o *PWM_Type) SetSM1CAPTCTRLX_INP_SELX(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM1CAPTCTRLX.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetSM1CAPTCTRLX_INP_SELX() uint16 {
	return (volatile.LoadUint16(&o.SM1CAPTCTRLX.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetSM1CAPTCTRLX_EDGCNTX_EN(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM1CAPTCTRLX.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetSM1CAPTCTRLX_EDGCNTX_EN() uint16 {
	return (volatile.LoadUint16(&o.SM1CAPTCTRLX.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetSM1CAPTCTRLX_CFXWM(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM1CAPTCTRLX.Reg)&^(0x300)|value<<8)
}
func (o *PWM_Type) GetSM1CAPTCTRLX_CFXWM() uint16 {
	return (volatile.LoadUint16(&o.SM1CAPTCTRLX.Reg) & 0x300) >> 8
}
func (o *PWM_Type) SetSM1CAPTCTRLX_CX0CNT(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM1CAPTCTRLX.Reg)&^(0x1c00)|value<<10)
}
func (o *PWM_Type) GetSM1CAPTCTRLX_CX0CNT() uint16 {
	return (volatile.LoadUint16(&o.SM1CAPTCTRLX.Reg) & 0x1c00) >> 10
}
func (o *PWM_Type) SetSM1CAPTCTRLX_CX1CNT(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM1CAPTCTRLX.Reg)&^(0xe000)|value<<13)
}
func (o *PWM_Type) GetSM1CAPTCTRLX_CX1CNT() uint16 {
	return (volatile.LoadUint16(&o.SM1CAPTCTRLX.Reg) & 0xe000) >> 13
}

// PWM.SM1CAPTCOMPX: Capture Compare X Register
func (o *PWM_Type) SetSM1CAPTCOMPX_EDGCMPX(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCOMPX.Reg, volatile.LoadUint16(&o.SM1CAPTCOMPX.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetSM1CAPTCOMPX_EDGCMPX() uint16 {
	return volatile.LoadUint16(&o.SM1CAPTCOMPX.Reg) & 0xff
}
func (o *PWM_Type) SetSM1CAPTCOMPX_EDGCNTX(value uint16) {
	volatile.StoreUint16(&o.SM1CAPTCOMPX.Reg, volatile.LoadUint16(&o.SM1CAPTCOMPX.Reg)&^(0xff00)|value<<8)
}
func (o *PWM_Type) GetSM1CAPTCOMPX_EDGCNTX() uint16 {
	return (volatile.LoadUint16(&o.SM1CAPTCOMPX.Reg) & 0xff00) >> 8
}

// PWM.SM1CVAL0: Capture Value 0 Register
func (o *PWM_Type) SetSM1CVAL0(value uint16) {
	volatile.StoreUint16(&o.SM1CVAL0.Reg, value)
}
func (o *PWM_Type) GetSM1CVAL0() uint16 {
	return volatile.LoadUint16(&o.SM1CVAL0.Reg)
}

// PWM.SM1CVAL0CYC: Capture Value 0 Cycle Register
func (o *PWM_Type) SetSM1CVAL0CYC_CVAL0CYC(value uint16) {
	volatile.StoreUint16(&o.SM1CVAL0CYC.Reg, volatile.LoadUint16(&o.SM1CVAL0CYC.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM1CVAL0CYC_CVAL0CYC() uint16 {
	return volatile.LoadUint16(&o.SM1CVAL0CYC.Reg) & 0xf
}

// PWM.SM1CVAL1: Capture Value 1 Register
func (o *PWM_Type) SetSM1CVAL1(value uint16) {
	volatile.StoreUint16(&o.SM1CVAL1.Reg, value)
}
func (o *PWM_Type) GetSM1CVAL1() uint16 {
	return volatile.LoadUint16(&o.SM1CVAL1.Reg)
}

// PWM.SM1CVAL1CYC: Capture Value 1 Cycle Register
func (o *PWM_Type) SetSM1CVAL1CYC_CVAL1CYC(value uint16) {
	volatile.StoreUint16(&o.SM1CVAL1CYC.Reg, volatile.LoadUint16(&o.SM1CVAL1CYC.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM1CVAL1CYC_CVAL1CYC() uint16 {
	return volatile.LoadUint16(&o.SM1CVAL1CYC.Reg) & 0xf
}

// PWM.SM1CVAL2: Capture Value 2 Register
func (o *PWM_Type) SetSM1CVAL2(value uint16) {
	volatile.StoreUint16(&o.SM1CVAL2.Reg, value)
}
func (o *PWM_Type) GetSM1CVAL2() uint16 {
	return volatile.LoadUint16(&o.SM1CVAL2.Reg)
}

// PWM.SM1CVAL2CYC: Capture Value 2 Cycle Register
func (o *PWM_Type) SetSM1CVAL2CYC_CVAL2CYC(value uint16) {
	volatile.StoreUint16(&o.SM1CVAL2CYC.Reg, volatile.LoadUint16(&o.SM1CVAL2CYC.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM1CVAL2CYC_CVAL2CYC() uint16 {
	return volatile.LoadUint16(&o.SM1CVAL2CYC.Reg) & 0xf
}

// PWM.SM1CVAL3: Capture Value 3 Register
func (o *PWM_Type) SetSM1CVAL3(value uint16) {
	volatile.StoreUint16(&o.SM1CVAL3.Reg, value)
}
func (o *PWM_Type) GetSM1CVAL3() uint16 {
	return volatile.LoadUint16(&o.SM1CVAL3.Reg)
}

// PWM.SM1CVAL3CYC: Capture Value 3 Cycle Register
func (o *PWM_Type) SetSM1CVAL3CYC_CVAL3CYC(value uint16) {
	volatile.StoreUint16(&o.SM1CVAL3CYC.Reg, volatile.LoadUint16(&o.SM1CVAL3CYC.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM1CVAL3CYC_CVAL3CYC() uint16 {
	return volatile.LoadUint16(&o.SM1CVAL3CYC.Reg) & 0xf
}

// PWM.SM1CVAL4: Capture Value 4 Register
func (o *PWM_Type) SetSM1CVAL4(value uint16) {
	volatile.StoreUint16(&o.SM1CVAL4.Reg, value)
}
func (o *PWM_Type) GetSM1CVAL4() uint16 {
	return volatile.LoadUint16(&o.SM1CVAL4.Reg)
}

// PWM.SM1CVAL4CYC: Capture Value 4 Cycle Register
func (o *PWM_Type) SetSM1CVAL4CYC_CVAL4CYC(value uint16) {
	volatile.StoreUint16(&o.SM1CVAL4CYC.Reg, volatile.LoadUint16(&o.SM1CVAL4CYC.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM1CVAL4CYC_CVAL4CYC() uint16 {
	return volatile.LoadUint16(&o.SM1CVAL4CYC.Reg) & 0xf
}

// PWM.SM1CVAL5: Capture Value 5 Register
func (o *PWM_Type) SetSM1CVAL5(value uint16) {
	volatile.StoreUint16(&o.SM1CVAL5.Reg, value)
}
func (o *PWM_Type) GetSM1CVAL5() uint16 {
	return volatile.LoadUint16(&o.SM1CVAL5.Reg)
}

// PWM.SM1CVAL5CYC: Capture Value 5 Cycle Register
func (o *PWM_Type) SetSM1CVAL5CYC_CVAL5CYC(value uint16) {
	volatile.StoreUint16(&o.SM1CVAL5CYC.Reg, volatile.LoadUint16(&o.SM1CVAL5CYC.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM1CVAL5CYC_CVAL5CYC() uint16 {
	return volatile.LoadUint16(&o.SM1CVAL5CYC.Reg) & 0xf
}

// PWM.SM1PHASEDLY: Phase Delay Register
func (o *PWM_Type) SetSM1PHASEDLY(value uint16) {
	volatile.StoreUint16(&o.SM1PHASEDLY.Reg, value)
}
func (o *PWM_Type) GetSM1PHASEDLY() uint16 {
	return volatile.LoadUint16(&o.SM1PHASEDLY.Reg)
}

// PWM.SM2CNT: Counter Register
func (o *PWM_Type) SetSM2CNT(value uint16) {
	volatile.StoreUint16(&o.SM2CNT.Reg, value)
}
func (o *PWM_Type) GetSM2CNT() uint16 {
	return volatile.LoadUint16(&o.SM2CNT.Reg)
}

// PWM.SM2INIT: Initial Count Register
func (o *PWM_Type) SetSM2INIT(value uint16) {
	volatile.StoreUint16(&o.SM2INIT.Reg, value)
}
func (o *PWM_Type) GetSM2INIT() uint16 {
	return volatile.LoadUint16(&o.SM2INIT.Reg)
}

// PWM.SM2CTRL2: Control 2 Register
func (o *PWM_Type) SetSM2CTRL2_CLK_SEL(value uint16) {
	volatile.StoreUint16(&o.SM2CTRL2.Reg, volatile.LoadUint16(&o.SM2CTRL2.Reg)&^(0x3)|value)
}
func (o *PWM_Type) GetSM2CTRL2_CLK_SEL() uint16 {
	return volatile.LoadUint16(&o.SM2CTRL2.Reg) & 0x3
}
func (o *PWM_Type) SetSM2CTRL2_RELOAD_SEL(value uint16) {
	volatile.StoreUint16(&o.SM2CTRL2.Reg, volatile.LoadUint16(&o.SM2CTRL2.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetSM2CTRL2_RELOAD_SEL() uint16 {
	return (volatile.LoadUint16(&o.SM2CTRL2.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetSM2CTRL2_FORCE_SEL(value uint16) {
	volatile.StoreUint16(&o.SM2CTRL2.Reg, volatile.LoadUint16(&o.SM2CTRL2.Reg)&^(0x38)|value<<3)
}
func (o *PWM_Type) GetSM2CTRL2_FORCE_SEL() uint16 {
	return (volatile.LoadUint16(&o.SM2CTRL2.Reg) & 0x38) >> 3
}
func (o *PWM_Type) SetSM2CTRL2_FORCE(value uint16) {
	volatile.StoreUint16(&o.SM2CTRL2.Reg, volatile.LoadUint16(&o.SM2CTRL2.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetSM2CTRL2_FORCE() uint16 {
	return (volatile.LoadUint16(&o.SM2CTRL2.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetSM2CTRL2_FRCEN(value uint16) {
	volatile.StoreUint16(&o.SM2CTRL2.Reg, volatile.LoadUint16(&o.SM2CTRL2.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetSM2CTRL2_FRCEN() uint16 {
	return (volatile.LoadUint16(&o.SM2CTRL2.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetSM2CTRL2_INIT_SEL(value uint16) {
	volatile.StoreUint16(&o.SM2CTRL2.Reg, volatile.LoadUint16(&o.SM2CTRL2.Reg)&^(0x300)|value<<8)
}
func (o *PWM_Type) GetSM2CTRL2_INIT_SEL() uint16 {
	return (volatile.LoadUint16(&o.SM2CTRL2.Reg) & 0x300) >> 8
}
func (o *PWM_Type) SetSM2CTRL2_PWMX_INIT(value uint16) {
	volatile.StoreUint16(&o.SM2CTRL2.Reg, volatile.LoadUint16(&o.SM2CTRL2.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetSM2CTRL2_PWMX_INIT() uint16 {
	return (volatile.LoadUint16(&o.SM2CTRL2.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetSM2CTRL2_PWM45_INIT(value uint16) {
	volatile.StoreUint16(&o.SM2CTRL2.Reg, volatile.LoadUint16(&o.SM2CTRL2.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetSM2CTRL2_PWM45_INIT() uint16 {
	return (volatile.LoadUint16(&o.SM2CTRL2.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetSM2CTRL2_PWM23_INIT(value uint16) {
	volatile.StoreUint16(&o.SM2CTRL2.Reg, volatile.LoadUint16(&o.SM2CTRL2.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetSM2CTRL2_PWM23_INIT() uint16 {
	return (volatile.LoadUint16(&o.SM2CTRL2.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetSM2CTRL2_INDEP(value uint16) {
	volatile.StoreUint16(&o.SM2CTRL2.Reg, volatile.LoadUint16(&o.SM2CTRL2.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetSM2CTRL2_INDEP() uint16 {
	return (volatile.LoadUint16(&o.SM2CTRL2.Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetSM2CTRL2_WAITEN(value uint16) {
	volatile.StoreUint16(&o.SM2CTRL2.Reg, volatile.LoadUint16(&o.SM2CTRL2.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetSM2CTRL2_WAITEN() uint16 {
	return (volatile.LoadUint16(&o.SM2CTRL2.Reg) & 0x4000) >> 14
}
func (o *PWM_Type) SetSM2CTRL2_DBGEN(value uint16) {
	volatile.StoreUint16(&o.SM2CTRL2.Reg, volatile.LoadUint16(&o.SM2CTRL2.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetSM2CTRL2_DBGEN() uint16 {
	return (volatile.LoadUint16(&o.SM2CTRL2.Reg) & 0x8000) >> 15
}

// PWM.SM2CTRL: Control Register
func (o *PWM_Type) SetSM2CTRL_DBLEN(value uint16) {
	volatile.StoreUint16(&o.SM2CTRL.Reg, volatile.LoadUint16(&o.SM2CTRL.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSM2CTRL_DBLEN() uint16 {
	return volatile.LoadUint16(&o.SM2CTRL.Reg) & 0x1
}
func (o *PWM_Type) SetSM2CTRL_DBLX(value uint16) {
	volatile.StoreUint16(&o.SM2CTRL.Reg, volatile.LoadUint16(&o.SM2CTRL.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSM2CTRL_DBLX() uint16 {
	return (volatile.LoadUint16(&o.SM2CTRL.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSM2CTRL_LDMOD(value uint16) {
	volatile.StoreUint16(&o.SM2CTRL.Reg, volatile.LoadUint16(&o.SM2CTRL.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetSM2CTRL_LDMOD() uint16 {
	return (volatile.LoadUint16(&o.SM2CTRL.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetSM2CTRL_SPLIT(value uint16) {
	volatile.StoreUint16(&o.SM2CTRL.Reg, volatile.LoadUint16(&o.SM2CTRL.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetSM2CTRL_SPLIT() uint16 {
	return (volatile.LoadUint16(&o.SM2CTRL.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetSM2CTRL_PRSC(value uint16) {
	volatile.StoreUint16(&o.SM2CTRL.Reg, volatile.LoadUint16(&o.SM2CTRL.Reg)&^(0x70)|value<<4)
}
func (o *PWM_Type) GetSM2CTRL_PRSC() uint16 {
	return (volatile.LoadUint16(&o.SM2CTRL.Reg) & 0x70) >> 4
}
func (o *PWM_Type) SetSM2CTRL_COMPMODE(value uint16) {
	volatile.StoreUint16(&o.SM2CTRL.Reg, volatile.LoadUint16(&o.SM2CTRL.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetSM2CTRL_COMPMODE() uint16 {
	return (volatile.LoadUint16(&o.SM2CTRL.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetSM2CTRL_DT(value uint16) {
	volatile.StoreUint16(&o.SM2CTRL.Reg, volatile.LoadUint16(&o.SM2CTRL.Reg)&^(0x300)|value<<8)
}
func (o *PWM_Type) GetSM2CTRL_DT() uint16 {
	return (volatile.LoadUint16(&o.SM2CTRL.Reg) & 0x300) >> 8
}
func (o *PWM_Type) SetSM2CTRL_FULL(value uint16) {
	volatile.StoreUint16(&o.SM2CTRL.Reg, volatile.LoadUint16(&o.SM2CTRL.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetSM2CTRL_FULL() uint16 {
	return (volatile.LoadUint16(&o.SM2CTRL.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetSM2CTRL_HALF(value uint16) {
	volatile.StoreUint16(&o.SM2CTRL.Reg, volatile.LoadUint16(&o.SM2CTRL.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetSM2CTRL_HALF() uint16 {
	return (volatile.LoadUint16(&o.SM2CTRL.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetSM2CTRL_LDFQ(value uint16) {
	volatile.StoreUint16(&o.SM2CTRL.Reg, volatile.LoadUint16(&o.SM2CTRL.Reg)&^(0xf000)|value<<12)
}
func (o *PWM_Type) GetSM2CTRL_LDFQ() uint16 {
	return (volatile.LoadUint16(&o.SM2CTRL.Reg) & 0xf000) >> 12
}

// PWM.SM2VAL0: Value Register 0
func (o *PWM_Type) SetSM2VAL0(value uint16) {
	volatile.StoreUint16(&o.SM2VAL0.Reg, value)
}
func (o *PWM_Type) GetSM2VAL0() uint16 {
	return volatile.LoadUint16(&o.SM2VAL0.Reg)
}

// PWM.SM2FRACVAL1: Fractional Value Register 1
func (o *PWM_Type) SetSM2FRACVAL1_FRACVAL1(value uint16) {
	volatile.StoreUint16(&o.SM2FRACVAL1.Reg, volatile.LoadUint16(&o.SM2FRACVAL1.Reg)&^(0xf800)|value<<11)
}
func (o *PWM_Type) GetSM2FRACVAL1_FRACVAL1() uint16 {
	return (volatile.LoadUint16(&o.SM2FRACVAL1.Reg) & 0xf800) >> 11
}

// PWM.SM2VAL1: Value Register 1
func (o *PWM_Type) SetSM2VAL1(value uint16) {
	volatile.StoreUint16(&o.SM2VAL1.Reg, value)
}
func (o *PWM_Type) GetSM2VAL1() uint16 {
	return volatile.LoadUint16(&o.SM2VAL1.Reg)
}

// PWM.SM2FRACVAL2: Fractional Value Register 2
func (o *PWM_Type) SetSM2FRACVAL2_FRACVAL2(value uint16) {
	volatile.StoreUint16(&o.SM2FRACVAL2.Reg, volatile.LoadUint16(&o.SM2FRACVAL2.Reg)&^(0xf800)|value<<11)
}
func (o *PWM_Type) GetSM2FRACVAL2_FRACVAL2() uint16 {
	return (volatile.LoadUint16(&o.SM2FRACVAL2.Reg) & 0xf800) >> 11
}

// PWM.SM2VAL2: Value Register 2
func (o *PWM_Type) SetSM2VAL2(value uint16) {
	volatile.StoreUint16(&o.SM2VAL2.Reg, value)
}
func (o *PWM_Type) GetSM2VAL2() uint16 {
	return volatile.LoadUint16(&o.SM2VAL2.Reg)
}

// PWM.SM2FRACVAL3: Fractional Value Register 3
func (o *PWM_Type) SetSM2FRACVAL3_FRACVAL3(value uint16) {
	volatile.StoreUint16(&o.SM2FRACVAL3.Reg, volatile.LoadUint16(&o.SM2FRACVAL3.Reg)&^(0xf800)|value<<11)
}
func (o *PWM_Type) GetSM2FRACVAL3_FRACVAL3() uint16 {
	return (volatile.LoadUint16(&o.SM2FRACVAL3.Reg) & 0xf800) >> 11
}

// PWM.SM2VAL3: Value Register 3
func (o *PWM_Type) SetSM2VAL3(value uint16) {
	volatile.StoreUint16(&o.SM2VAL3.Reg, value)
}
func (o *PWM_Type) GetSM2VAL3() uint16 {
	return volatile.LoadUint16(&o.SM2VAL3.Reg)
}

// PWM.SM2FRACVAL4: Fractional Value Register 4
func (o *PWM_Type) SetSM2FRACVAL4_FRACVAL4(value uint16) {
	volatile.StoreUint16(&o.SM2FRACVAL4.Reg, volatile.LoadUint16(&o.SM2FRACVAL4.Reg)&^(0xf800)|value<<11)
}
func (o *PWM_Type) GetSM2FRACVAL4_FRACVAL4() uint16 {
	return (volatile.LoadUint16(&o.SM2FRACVAL4.Reg) & 0xf800) >> 11
}

// PWM.SM2VAL4: Value Register 4
func (o *PWM_Type) SetSM2VAL4(value uint16) {
	volatile.StoreUint16(&o.SM2VAL4.Reg, value)
}
func (o *PWM_Type) GetSM2VAL4() uint16 {
	return volatile.LoadUint16(&o.SM2VAL4.Reg)
}

// PWM.SM2FRACVAL5: Fractional Value Register 5
func (o *PWM_Type) SetSM2FRACVAL5_FRACVAL5(value uint16) {
	volatile.StoreUint16(&o.SM2FRACVAL5.Reg, volatile.LoadUint16(&o.SM2FRACVAL5.Reg)&^(0xf800)|value<<11)
}
func (o *PWM_Type) GetSM2FRACVAL5_FRACVAL5() uint16 {
	return (volatile.LoadUint16(&o.SM2FRACVAL5.Reg) & 0xf800) >> 11
}

// PWM.SM2VAL5: Value Register 5
func (o *PWM_Type) SetSM2VAL5(value uint16) {
	volatile.StoreUint16(&o.SM2VAL5.Reg, value)
}
func (o *PWM_Type) GetSM2VAL5() uint16 {
	return volatile.LoadUint16(&o.SM2VAL5.Reg)
}

// PWM.SM2FRCTRL: Fractional Control Register
func (o *PWM_Type) SetSM2FRCTRL_FRAC1_EN(value uint16) {
	volatile.StoreUint16(&o.SM2FRCTRL.Reg, volatile.LoadUint16(&o.SM2FRCTRL.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSM2FRCTRL_FRAC1_EN() uint16 {
	return (volatile.LoadUint16(&o.SM2FRCTRL.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSM2FRCTRL_FRAC23_EN(value uint16) {
	volatile.StoreUint16(&o.SM2FRCTRL.Reg, volatile.LoadUint16(&o.SM2FRCTRL.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetSM2FRCTRL_FRAC23_EN() uint16 {
	return (volatile.LoadUint16(&o.SM2FRCTRL.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetSM2FRCTRL_FRAC45_EN(value uint16) {
	volatile.StoreUint16(&o.SM2FRCTRL.Reg, volatile.LoadUint16(&o.SM2FRCTRL.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetSM2FRCTRL_FRAC45_EN() uint16 {
	return (volatile.LoadUint16(&o.SM2FRCTRL.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetSM2FRCTRL_FRAC_PU(value uint16) {
	volatile.StoreUint16(&o.SM2FRCTRL.Reg, volatile.LoadUint16(&o.SM2FRCTRL.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetSM2FRCTRL_FRAC_PU() uint16 {
	return (volatile.LoadUint16(&o.SM2FRCTRL.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetSM2FRCTRL_TEST(value uint16) {
	volatile.StoreUint16(&o.SM2FRCTRL.Reg, volatile.LoadUint16(&o.SM2FRCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetSM2FRCTRL_TEST() uint16 {
	return (volatile.LoadUint16(&o.SM2FRCTRL.Reg) & 0x8000) >> 15
}

// PWM.SM2OCTRL: Output Control Register
func (o *PWM_Type) SetSM2OCTRL_PWMXFS(value uint16) {
	volatile.StoreUint16(&o.SM2OCTRL.Reg, volatile.LoadUint16(&o.SM2OCTRL.Reg)&^(0x3)|value)
}
func (o *PWM_Type) GetSM2OCTRL_PWMXFS() uint16 {
	return volatile.LoadUint16(&o.SM2OCTRL.Reg) & 0x3
}
func (o *PWM_Type) SetSM2OCTRL_PWMBFS(value uint16) {
	volatile.StoreUint16(&o.SM2OCTRL.Reg, volatile.LoadUint16(&o.SM2OCTRL.Reg)&^(0xc)|value<<2)
}
func (o *PWM_Type) GetSM2OCTRL_PWMBFS() uint16 {
	return (volatile.LoadUint16(&o.SM2OCTRL.Reg) & 0xc) >> 2
}
func (o *PWM_Type) SetSM2OCTRL_PWMAFS(value uint16) {
	volatile.StoreUint16(&o.SM2OCTRL.Reg, volatile.LoadUint16(&o.SM2OCTRL.Reg)&^(0x30)|value<<4)
}
func (o *PWM_Type) GetSM2OCTRL_PWMAFS() uint16 {
	return (volatile.LoadUint16(&o.SM2OCTRL.Reg) & 0x30) >> 4
}
func (o *PWM_Type) SetSM2OCTRL_POLX(value uint16) {
	volatile.StoreUint16(&o.SM2OCTRL.Reg, volatile.LoadUint16(&o.SM2OCTRL.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetSM2OCTRL_POLX() uint16 {
	return (volatile.LoadUint16(&o.SM2OCTRL.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetSM2OCTRL_POLB(value uint16) {
	volatile.StoreUint16(&o.SM2OCTRL.Reg, volatile.LoadUint16(&o.SM2OCTRL.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetSM2OCTRL_POLB() uint16 {
	return (volatile.LoadUint16(&o.SM2OCTRL.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetSM2OCTRL_POLA(value uint16) {
	volatile.StoreUint16(&o.SM2OCTRL.Reg, volatile.LoadUint16(&o.SM2OCTRL.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetSM2OCTRL_POLA() uint16 {
	return (volatile.LoadUint16(&o.SM2OCTRL.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetSM2OCTRL_PWMX_IN(value uint16) {
	volatile.StoreUint16(&o.SM2OCTRL.Reg, volatile.LoadUint16(&o.SM2OCTRL.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetSM2OCTRL_PWMX_IN() uint16 {
	return (volatile.LoadUint16(&o.SM2OCTRL.Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetSM2OCTRL_PWMB_IN(value uint16) {
	volatile.StoreUint16(&o.SM2OCTRL.Reg, volatile.LoadUint16(&o.SM2OCTRL.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetSM2OCTRL_PWMB_IN() uint16 {
	return (volatile.LoadUint16(&o.SM2OCTRL.Reg) & 0x4000) >> 14
}
func (o *PWM_Type) SetSM2OCTRL_PWMA_IN(value uint16) {
	volatile.StoreUint16(&o.SM2OCTRL.Reg, volatile.LoadUint16(&o.SM2OCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetSM2OCTRL_PWMA_IN() uint16 {
	return (volatile.LoadUint16(&o.SM2OCTRL.Reg) & 0x8000) >> 15
}

// PWM.SM2STS: Status Register
func (o *PWM_Type) SetSM2STS_CMPF(value uint16) {
	volatile.StoreUint16(&o.SM2STS.Reg, volatile.LoadUint16(&o.SM2STS.Reg)&^(0x3f)|value)
}
func (o *PWM_Type) GetSM2STS_CMPF() uint16 {
	return volatile.LoadUint16(&o.SM2STS.Reg) & 0x3f
}
func (o *PWM_Type) SetSM2STS_CFX0(value uint16) {
	volatile.StoreUint16(&o.SM2STS.Reg, volatile.LoadUint16(&o.SM2STS.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetSM2STS_CFX0() uint16 {
	return (volatile.LoadUint16(&o.SM2STS.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetSM2STS_CFX1(value uint16) {
	volatile.StoreUint16(&o.SM2STS.Reg, volatile.LoadUint16(&o.SM2STS.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetSM2STS_CFX1() uint16 {
	return (volatile.LoadUint16(&o.SM2STS.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetSM2STS_CFB0(value uint16) {
	volatile.StoreUint16(&o.SM2STS.Reg, volatile.LoadUint16(&o.SM2STS.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetSM2STS_CFB0() uint16 {
	return (volatile.LoadUint16(&o.SM2STS.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetSM2STS_CFB1(value uint16) {
	volatile.StoreUint16(&o.SM2STS.Reg, volatile.LoadUint16(&o.SM2STS.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetSM2STS_CFB1() uint16 {
	return (volatile.LoadUint16(&o.SM2STS.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetSM2STS_CFA0(value uint16) {
	volatile.StoreUint16(&o.SM2STS.Reg, volatile.LoadUint16(&o.SM2STS.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetSM2STS_CFA0() uint16 {
	return (volatile.LoadUint16(&o.SM2STS.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetSM2STS_CFA1(value uint16) {
	volatile.StoreUint16(&o.SM2STS.Reg, volatile.LoadUint16(&o.SM2STS.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetSM2STS_CFA1() uint16 {
	return (volatile.LoadUint16(&o.SM2STS.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetSM2STS_RF(value uint16) {
	volatile.StoreUint16(&o.SM2STS.Reg, volatile.LoadUint16(&o.SM2STS.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetSM2STS_RF() uint16 {
	return (volatile.LoadUint16(&o.SM2STS.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetSM2STS_REF(value uint16) {
	volatile.StoreUint16(&o.SM2STS.Reg, volatile.LoadUint16(&o.SM2STS.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetSM2STS_REF() uint16 {
	return (volatile.LoadUint16(&o.SM2STS.Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetSM2STS_RUF(value uint16) {
	volatile.StoreUint16(&o.SM2STS.Reg, volatile.LoadUint16(&o.SM2STS.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetSM2STS_RUF() uint16 {
	return (volatile.LoadUint16(&o.SM2STS.Reg) & 0x4000) >> 14
}

// PWM.SM2INTEN: Interrupt Enable Register
func (o *PWM_Type) SetSM2INTEN_CMPIE(value uint16) {
	volatile.StoreUint16(&o.SM2INTEN.Reg, volatile.LoadUint16(&o.SM2INTEN.Reg)&^(0x3f)|value)
}
func (o *PWM_Type) GetSM2INTEN_CMPIE() uint16 {
	return volatile.LoadUint16(&o.SM2INTEN.Reg) & 0x3f
}
func (o *PWM_Type) SetSM2INTEN_CX0IE(value uint16) {
	volatile.StoreUint16(&o.SM2INTEN.Reg, volatile.LoadUint16(&o.SM2INTEN.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetSM2INTEN_CX0IE() uint16 {
	return (volatile.LoadUint16(&o.SM2INTEN.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetSM2INTEN_CX1IE(value uint16) {
	volatile.StoreUint16(&o.SM2INTEN.Reg, volatile.LoadUint16(&o.SM2INTEN.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetSM2INTEN_CX1IE() uint16 {
	return (volatile.LoadUint16(&o.SM2INTEN.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetSM2INTEN_CB0IE(value uint16) {
	volatile.StoreUint16(&o.SM2INTEN.Reg, volatile.LoadUint16(&o.SM2INTEN.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetSM2INTEN_CB0IE() uint16 {
	return (volatile.LoadUint16(&o.SM2INTEN.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetSM2INTEN_CB1IE(value uint16) {
	volatile.StoreUint16(&o.SM2INTEN.Reg, volatile.LoadUint16(&o.SM2INTEN.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetSM2INTEN_CB1IE() uint16 {
	return (volatile.LoadUint16(&o.SM2INTEN.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetSM2INTEN_CA0IE(value uint16) {
	volatile.StoreUint16(&o.SM2INTEN.Reg, volatile.LoadUint16(&o.SM2INTEN.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetSM2INTEN_CA0IE() uint16 {
	return (volatile.LoadUint16(&o.SM2INTEN.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetSM2INTEN_CA1IE(value uint16) {
	volatile.StoreUint16(&o.SM2INTEN.Reg, volatile.LoadUint16(&o.SM2INTEN.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetSM2INTEN_CA1IE() uint16 {
	return (volatile.LoadUint16(&o.SM2INTEN.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetSM2INTEN_RIE(value uint16) {
	volatile.StoreUint16(&o.SM2INTEN.Reg, volatile.LoadUint16(&o.SM2INTEN.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetSM2INTEN_RIE() uint16 {
	return (volatile.LoadUint16(&o.SM2INTEN.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetSM2INTEN_REIE(value uint16) {
	volatile.StoreUint16(&o.SM2INTEN.Reg, volatile.LoadUint16(&o.SM2INTEN.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetSM2INTEN_REIE() uint16 {
	return (volatile.LoadUint16(&o.SM2INTEN.Reg) & 0x2000) >> 13
}

// PWM.SM2DMAEN: DMA Enable Register
func (o *PWM_Type) SetSM2DMAEN_CX0DE(value uint16) {
	volatile.StoreUint16(&o.SM2DMAEN.Reg, volatile.LoadUint16(&o.SM2DMAEN.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSM2DMAEN_CX0DE() uint16 {
	return volatile.LoadUint16(&o.SM2DMAEN.Reg) & 0x1
}
func (o *PWM_Type) SetSM2DMAEN_CX1DE(value uint16) {
	volatile.StoreUint16(&o.SM2DMAEN.Reg, volatile.LoadUint16(&o.SM2DMAEN.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSM2DMAEN_CX1DE() uint16 {
	return (volatile.LoadUint16(&o.SM2DMAEN.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSM2DMAEN_CB0DE(value uint16) {
	volatile.StoreUint16(&o.SM2DMAEN.Reg, volatile.LoadUint16(&o.SM2DMAEN.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetSM2DMAEN_CB0DE() uint16 {
	return (volatile.LoadUint16(&o.SM2DMAEN.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetSM2DMAEN_CB1DE(value uint16) {
	volatile.StoreUint16(&o.SM2DMAEN.Reg, volatile.LoadUint16(&o.SM2DMAEN.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetSM2DMAEN_CB1DE() uint16 {
	return (volatile.LoadUint16(&o.SM2DMAEN.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetSM2DMAEN_CA0DE(value uint16) {
	volatile.StoreUint16(&o.SM2DMAEN.Reg, volatile.LoadUint16(&o.SM2DMAEN.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetSM2DMAEN_CA0DE() uint16 {
	return (volatile.LoadUint16(&o.SM2DMAEN.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetSM2DMAEN_CA1DE(value uint16) {
	volatile.StoreUint16(&o.SM2DMAEN.Reg, volatile.LoadUint16(&o.SM2DMAEN.Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetSM2DMAEN_CA1DE() uint16 {
	return (volatile.LoadUint16(&o.SM2DMAEN.Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetSM2DMAEN_CAPTDE(value uint16) {
	volatile.StoreUint16(&o.SM2DMAEN.Reg, volatile.LoadUint16(&o.SM2DMAEN.Reg)&^(0xc0)|value<<6)
}
func (o *PWM_Type) GetSM2DMAEN_CAPTDE() uint16 {
	return (volatile.LoadUint16(&o.SM2DMAEN.Reg) & 0xc0) >> 6
}
func (o *PWM_Type) SetSM2DMAEN_FAND(value uint16) {
	volatile.StoreUint16(&o.SM2DMAEN.Reg, volatile.LoadUint16(&o.SM2DMAEN.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetSM2DMAEN_FAND() uint16 {
	return (volatile.LoadUint16(&o.SM2DMAEN.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetSM2DMAEN_VALDE(value uint16) {
	volatile.StoreUint16(&o.SM2DMAEN.Reg, volatile.LoadUint16(&o.SM2DMAEN.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetSM2DMAEN_VALDE() uint16 {
	return (volatile.LoadUint16(&o.SM2DMAEN.Reg) & 0x200) >> 9
}

// PWM.SM2TCTRL: Output Trigger Control Register
func (o *PWM_Type) SetSM2TCTRL_OUT_TRIG_EN(value uint16) {
	volatile.StoreUint16(&o.SM2TCTRL.Reg, volatile.LoadUint16(&o.SM2TCTRL.Reg)&^(0x3f)|value)
}
func (o *PWM_Type) GetSM2TCTRL_OUT_TRIG_EN() uint16 {
	return volatile.LoadUint16(&o.SM2TCTRL.Reg) & 0x3f
}
func (o *PWM_Type) SetSM2TCTRL_TRGFRQ(value uint16) {
	volatile.StoreUint16(&o.SM2TCTRL.Reg, volatile.LoadUint16(&o.SM2TCTRL.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetSM2TCTRL_TRGFRQ() uint16 {
	return (volatile.LoadUint16(&o.SM2TCTRL.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetSM2TCTRL_PWBOT1(value uint16) {
	volatile.StoreUint16(&o.SM2TCTRL.Reg, volatile.LoadUint16(&o.SM2TCTRL.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetSM2TCTRL_PWBOT1() uint16 {
	return (volatile.LoadUint16(&o.SM2TCTRL.Reg) & 0x4000) >> 14
}
func (o *PWM_Type) SetSM2TCTRL_PWAOT0(value uint16) {
	volatile.StoreUint16(&o.SM2TCTRL.Reg, volatile.LoadUint16(&o.SM2TCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetSM2TCTRL_PWAOT0() uint16 {
	return (volatile.LoadUint16(&o.SM2TCTRL.Reg) & 0x8000) >> 15
}

// PWM.SM2DISMAP0: Fault Disable Mapping Register 0
func (o *PWM_Type) SetSM2DISMAP0_DIS0A(value uint16) {
	volatile.StoreUint16(&o.SM2DISMAP0.Reg, volatile.LoadUint16(&o.SM2DISMAP0.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM2DISMAP0_DIS0A() uint16 {
	return volatile.LoadUint16(&o.SM2DISMAP0.Reg) & 0xf
}
func (o *PWM_Type) SetSM2DISMAP0_DIS0B(value uint16) {
	volatile.StoreUint16(&o.SM2DISMAP0.Reg, volatile.LoadUint16(&o.SM2DISMAP0.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetSM2DISMAP0_DIS0B() uint16 {
	return (volatile.LoadUint16(&o.SM2DISMAP0.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetSM2DISMAP0_DIS0X(value uint16) {
	volatile.StoreUint16(&o.SM2DISMAP0.Reg, volatile.LoadUint16(&o.SM2DISMAP0.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetSM2DISMAP0_DIS0X() uint16 {
	return (volatile.LoadUint16(&o.SM2DISMAP0.Reg) & 0xf00) >> 8
}

// PWM.SM2DISMAP1: Fault Disable Mapping Register 1
func (o *PWM_Type) SetSM2DISMAP1_DIS1A(value uint16) {
	volatile.StoreUint16(&o.SM2DISMAP1.Reg, volatile.LoadUint16(&o.SM2DISMAP1.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM2DISMAP1_DIS1A() uint16 {
	return volatile.LoadUint16(&o.SM2DISMAP1.Reg) & 0xf
}
func (o *PWM_Type) SetSM2DISMAP1_DIS1B(value uint16) {
	volatile.StoreUint16(&o.SM2DISMAP1.Reg, volatile.LoadUint16(&o.SM2DISMAP1.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetSM2DISMAP1_DIS1B() uint16 {
	return (volatile.LoadUint16(&o.SM2DISMAP1.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetSM2DISMAP1_DIS1X(value uint16) {
	volatile.StoreUint16(&o.SM2DISMAP1.Reg, volatile.LoadUint16(&o.SM2DISMAP1.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetSM2DISMAP1_DIS1X() uint16 {
	return (volatile.LoadUint16(&o.SM2DISMAP1.Reg) & 0xf00) >> 8
}

// PWM.SM2DTCNT0: Deadtime Count Register 0
func (o *PWM_Type) SetSM2DTCNT0(value uint16) {
	volatile.StoreUint16(&o.SM2DTCNT0.Reg, value)
}
func (o *PWM_Type) GetSM2DTCNT0() uint16 {
	return volatile.LoadUint16(&o.SM2DTCNT0.Reg)
}

// PWM.SM2DTCNT1: Deadtime Count Register 1
func (o *PWM_Type) SetSM2DTCNT1(value uint16) {
	volatile.StoreUint16(&o.SM2DTCNT1.Reg, value)
}
func (o *PWM_Type) GetSM2DTCNT1() uint16 {
	return volatile.LoadUint16(&o.SM2DTCNT1.Reg)
}

// PWM.SM2CAPTCTRLA: Capture Control A Register
func (o *PWM_Type) SetSM2CAPTCTRLA_ARMA(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM2CAPTCTRLA.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSM2CAPTCTRLA_ARMA() uint16 {
	return volatile.LoadUint16(&o.SM2CAPTCTRLA.Reg) & 0x1
}
func (o *PWM_Type) SetSM2CAPTCTRLA_ONESHOTA(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM2CAPTCTRLA.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSM2CAPTCTRLA_ONESHOTA() uint16 {
	return (volatile.LoadUint16(&o.SM2CAPTCTRLA.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSM2CAPTCTRLA_EDGA0(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM2CAPTCTRLA.Reg)&^(0xc)|value<<2)
}
func (o *PWM_Type) GetSM2CAPTCTRLA_EDGA0() uint16 {
	return (volatile.LoadUint16(&o.SM2CAPTCTRLA.Reg) & 0xc) >> 2
}
func (o *PWM_Type) SetSM2CAPTCTRLA_EDGA1(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM2CAPTCTRLA.Reg)&^(0x30)|value<<4)
}
func (o *PWM_Type) GetSM2CAPTCTRLA_EDGA1() uint16 {
	return (volatile.LoadUint16(&o.SM2CAPTCTRLA.Reg) & 0x30) >> 4
}
func (o *PWM_Type) SetSM2CAPTCTRLA_INP_SELA(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM2CAPTCTRLA.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetSM2CAPTCTRLA_INP_SELA() uint16 {
	return (volatile.LoadUint16(&o.SM2CAPTCTRLA.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetSM2CAPTCTRLA_EDGCNTA_EN(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM2CAPTCTRLA.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetSM2CAPTCTRLA_EDGCNTA_EN() uint16 {
	return (volatile.LoadUint16(&o.SM2CAPTCTRLA.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetSM2CAPTCTRLA_CFAWM(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM2CAPTCTRLA.Reg)&^(0x300)|value<<8)
}
func (o *PWM_Type) GetSM2CAPTCTRLA_CFAWM() uint16 {
	return (volatile.LoadUint16(&o.SM2CAPTCTRLA.Reg) & 0x300) >> 8
}
func (o *PWM_Type) SetSM2CAPTCTRLA_CA0CNT(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM2CAPTCTRLA.Reg)&^(0x1c00)|value<<10)
}
func (o *PWM_Type) GetSM2CAPTCTRLA_CA0CNT() uint16 {
	return (volatile.LoadUint16(&o.SM2CAPTCTRLA.Reg) & 0x1c00) >> 10
}
func (o *PWM_Type) SetSM2CAPTCTRLA_CA1CNT(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM2CAPTCTRLA.Reg)&^(0xe000)|value<<13)
}
func (o *PWM_Type) GetSM2CAPTCTRLA_CA1CNT() uint16 {
	return (volatile.LoadUint16(&o.SM2CAPTCTRLA.Reg) & 0xe000) >> 13
}

// PWM.SM2CAPTCOMPA: Capture Compare A Register
func (o *PWM_Type) SetSM2CAPTCOMPA_EDGCMPA(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCOMPA.Reg, volatile.LoadUint16(&o.SM2CAPTCOMPA.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetSM2CAPTCOMPA_EDGCMPA() uint16 {
	return volatile.LoadUint16(&o.SM2CAPTCOMPA.Reg) & 0xff
}
func (o *PWM_Type) SetSM2CAPTCOMPA_EDGCNTA(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCOMPA.Reg, volatile.LoadUint16(&o.SM2CAPTCOMPA.Reg)&^(0xff00)|value<<8)
}
func (o *PWM_Type) GetSM2CAPTCOMPA_EDGCNTA() uint16 {
	return (volatile.LoadUint16(&o.SM2CAPTCOMPA.Reg) & 0xff00) >> 8
}

// PWM.SM2CAPTCTRLB: Capture Control B Register
func (o *PWM_Type) SetSM2CAPTCTRLB_ARMB(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM2CAPTCTRLB.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSM2CAPTCTRLB_ARMB() uint16 {
	return volatile.LoadUint16(&o.SM2CAPTCTRLB.Reg) & 0x1
}
func (o *PWM_Type) SetSM2CAPTCTRLB_ONESHOTB(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM2CAPTCTRLB.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSM2CAPTCTRLB_ONESHOTB() uint16 {
	return (volatile.LoadUint16(&o.SM2CAPTCTRLB.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSM2CAPTCTRLB_EDGB0(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM2CAPTCTRLB.Reg)&^(0xc)|value<<2)
}
func (o *PWM_Type) GetSM2CAPTCTRLB_EDGB0() uint16 {
	return (volatile.LoadUint16(&o.SM2CAPTCTRLB.Reg) & 0xc) >> 2
}
func (o *PWM_Type) SetSM2CAPTCTRLB_EDGB1(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM2CAPTCTRLB.Reg)&^(0x30)|value<<4)
}
func (o *PWM_Type) GetSM2CAPTCTRLB_EDGB1() uint16 {
	return (volatile.LoadUint16(&o.SM2CAPTCTRLB.Reg) & 0x30) >> 4
}
func (o *PWM_Type) SetSM2CAPTCTRLB_INP_SELB(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM2CAPTCTRLB.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetSM2CAPTCTRLB_INP_SELB() uint16 {
	return (volatile.LoadUint16(&o.SM2CAPTCTRLB.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetSM2CAPTCTRLB_EDGCNTB_EN(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM2CAPTCTRLB.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetSM2CAPTCTRLB_EDGCNTB_EN() uint16 {
	return (volatile.LoadUint16(&o.SM2CAPTCTRLB.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetSM2CAPTCTRLB_CFBWM(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM2CAPTCTRLB.Reg)&^(0x300)|value<<8)
}
func (o *PWM_Type) GetSM2CAPTCTRLB_CFBWM() uint16 {
	return (volatile.LoadUint16(&o.SM2CAPTCTRLB.Reg) & 0x300) >> 8
}
func (o *PWM_Type) SetSM2CAPTCTRLB_CB0CNT(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM2CAPTCTRLB.Reg)&^(0x1c00)|value<<10)
}
func (o *PWM_Type) GetSM2CAPTCTRLB_CB0CNT() uint16 {
	return (volatile.LoadUint16(&o.SM2CAPTCTRLB.Reg) & 0x1c00) >> 10
}
func (o *PWM_Type) SetSM2CAPTCTRLB_CB1CNT(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM2CAPTCTRLB.Reg)&^(0xe000)|value<<13)
}
func (o *PWM_Type) GetSM2CAPTCTRLB_CB1CNT() uint16 {
	return (volatile.LoadUint16(&o.SM2CAPTCTRLB.Reg) & 0xe000) >> 13
}

// PWM.SM2CAPTCOMPB: Capture Compare B Register
func (o *PWM_Type) SetSM2CAPTCOMPB_EDGCMPB(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCOMPB.Reg, volatile.LoadUint16(&o.SM2CAPTCOMPB.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetSM2CAPTCOMPB_EDGCMPB() uint16 {
	return volatile.LoadUint16(&o.SM2CAPTCOMPB.Reg) & 0xff
}
func (o *PWM_Type) SetSM2CAPTCOMPB_EDGCNTB(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCOMPB.Reg, volatile.LoadUint16(&o.SM2CAPTCOMPB.Reg)&^(0xff00)|value<<8)
}
func (o *PWM_Type) GetSM2CAPTCOMPB_EDGCNTB() uint16 {
	return (volatile.LoadUint16(&o.SM2CAPTCOMPB.Reg) & 0xff00) >> 8
}

// PWM.SM2CAPTCTRLX: Capture Control X Register
func (o *PWM_Type) SetSM2CAPTCTRLX_ARMX(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM2CAPTCTRLX.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSM2CAPTCTRLX_ARMX() uint16 {
	return volatile.LoadUint16(&o.SM2CAPTCTRLX.Reg) & 0x1
}
func (o *PWM_Type) SetSM2CAPTCTRLX_ONESHOTX(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM2CAPTCTRLX.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSM2CAPTCTRLX_ONESHOTX() uint16 {
	return (volatile.LoadUint16(&o.SM2CAPTCTRLX.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSM2CAPTCTRLX_EDGX0(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM2CAPTCTRLX.Reg)&^(0xc)|value<<2)
}
func (o *PWM_Type) GetSM2CAPTCTRLX_EDGX0() uint16 {
	return (volatile.LoadUint16(&o.SM2CAPTCTRLX.Reg) & 0xc) >> 2
}
func (o *PWM_Type) SetSM2CAPTCTRLX_EDGX1(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM2CAPTCTRLX.Reg)&^(0x30)|value<<4)
}
func (o *PWM_Type) GetSM2CAPTCTRLX_EDGX1() uint16 {
	return (volatile.LoadUint16(&o.SM2CAPTCTRLX.Reg) & 0x30) >> 4
}
func (o *PWM_Type) SetSM2CAPTCTRLX_INP_SELX(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM2CAPTCTRLX.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetSM2CAPTCTRLX_INP_SELX() uint16 {
	return (volatile.LoadUint16(&o.SM2CAPTCTRLX.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetSM2CAPTCTRLX_EDGCNTX_EN(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM2CAPTCTRLX.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetSM2CAPTCTRLX_EDGCNTX_EN() uint16 {
	return (volatile.LoadUint16(&o.SM2CAPTCTRLX.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetSM2CAPTCTRLX_CFXWM(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM2CAPTCTRLX.Reg)&^(0x300)|value<<8)
}
func (o *PWM_Type) GetSM2CAPTCTRLX_CFXWM() uint16 {
	return (volatile.LoadUint16(&o.SM2CAPTCTRLX.Reg) & 0x300) >> 8
}
func (o *PWM_Type) SetSM2CAPTCTRLX_CX0CNT(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM2CAPTCTRLX.Reg)&^(0x1c00)|value<<10)
}
func (o *PWM_Type) GetSM2CAPTCTRLX_CX0CNT() uint16 {
	return (volatile.LoadUint16(&o.SM2CAPTCTRLX.Reg) & 0x1c00) >> 10
}
func (o *PWM_Type) SetSM2CAPTCTRLX_CX1CNT(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM2CAPTCTRLX.Reg)&^(0xe000)|value<<13)
}
func (o *PWM_Type) GetSM2CAPTCTRLX_CX1CNT() uint16 {
	return (volatile.LoadUint16(&o.SM2CAPTCTRLX.Reg) & 0xe000) >> 13
}

// PWM.SM2CAPTCOMPX: Capture Compare X Register
func (o *PWM_Type) SetSM2CAPTCOMPX_EDGCMPX(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCOMPX.Reg, volatile.LoadUint16(&o.SM2CAPTCOMPX.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetSM2CAPTCOMPX_EDGCMPX() uint16 {
	return volatile.LoadUint16(&o.SM2CAPTCOMPX.Reg) & 0xff
}
func (o *PWM_Type) SetSM2CAPTCOMPX_EDGCNTX(value uint16) {
	volatile.StoreUint16(&o.SM2CAPTCOMPX.Reg, volatile.LoadUint16(&o.SM2CAPTCOMPX.Reg)&^(0xff00)|value<<8)
}
func (o *PWM_Type) GetSM2CAPTCOMPX_EDGCNTX() uint16 {
	return (volatile.LoadUint16(&o.SM2CAPTCOMPX.Reg) & 0xff00) >> 8
}

// PWM.SM2CVAL0: Capture Value 0 Register
func (o *PWM_Type) SetSM2CVAL0(value uint16) {
	volatile.StoreUint16(&o.SM2CVAL0.Reg, value)
}
func (o *PWM_Type) GetSM2CVAL0() uint16 {
	return volatile.LoadUint16(&o.SM2CVAL0.Reg)
}

// PWM.SM2CVAL0CYC: Capture Value 0 Cycle Register
func (o *PWM_Type) SetSM2CVAL0CYC_CVAL0CYC(value uint16) {
	volatile.StoreUint16(&o.SM2CVAL0CYC.Reg, volatile.LoadUint16(&o.SM2CVAL0CYC.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM2CVAL0CYC_CVAL0CYC() uint16 {
	return volatile.LoadUint16(&o.SM2CVAL0CYC.Reg) & 0xf
}

// PWM.SM2CVAL1: Capture Value 1 Register
func (o *PWM_Type) SetSM2CVAL1(value uint16) {
	volatile.StoreUint16(&o.SM2CVAL1.Reg, value)
}
func (o *PWM_Type) GetSM2CVAL1() uint16 {
	return volatile.LoadUint16(&o.SM2CVAL1.Reg)
}

// PWM.SM2CVAL1CYC: Capture Value 1 Cycle Register
func (o *PWM_Type) SetSM2CVAL1CYC_CVAL1CYC(value uint16) {
	volatile.StoreUint16(&o.SM2CVAL1CYC.Reg, volatile.LoadUint16(&o.SM2CVAL1CYC.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM2CVAL1CYC_CVAL1CYC() uint16 {
	return volatile.LoadUint16(&o.SM2CVAL1CYC.Reg) & 0xf
}

// PWM.SM2CVAL2: Capture Value 2 Register
func (o *PWM_Type) SetSM2CVAL2(value uint16) {
	volatile.StoreUint16(&o.SM2CVAL2.Reg, value)
}
func (o *PWM_Type) GetSM2CVAL2() uint16 {
	return volatile.LoadUint16(&o.SM2CVAL2.Reg)
}

// PWM.SM2CVAL2CYC: Capture Value 2 Cycle Register
func (o *PWM_Type) SetSM2CVAL2CYC_CVAL2CYC(value uint16) {
	volatile.StoreUint16(&o.SM2CVAL2CYC.Reg, volatile.LoadUint16(&o.SM2CVAL2CYC.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM2CVAL2CYC_CVAL2CYC() uint16 {
	return volatile.LoadUint16(&o.SM2CVAL2CYC.Reg) & 0xf
}

// PWM.SM2CVAL3: Capture Value 3 Register
func (o *PWM_Type) SetSM2CVAL3(value uint16) {
	volatile.StoreUint16(&o.SM2CVAL3.Reg, value)
}
func (o *PWM_Type) GetSM2CVAL3() uint16 {
	return volatile.LoadUint16(&o.SM2CVAL3.Reg)
}

// PWM.SM2CVAL3CYC: Capture Value 3 Cycle Register
func (o *PWM_Type) SetSM2CVAL3CYC_CVAL3CYC(value uint16) {
	volatile.StoreUint16(&o.SM2CVAL3CYC.Reg, volatile.LoadUint16(&o.SM2CVAL3CYC.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM2CVAL3CYC_CVAL3CYC() uint16 {
	return volatile.LoadUint16(&o.SM2CVAL3CYC.Reg) & 0xf
}

// PWM.SM2CVAL4: Capture Value 4 Register
func (o *PWM_Type) SetSM2CVAL4(value uint16) {
	volatile.StoreUint16(&o.SM2CVAL4.Reg, value)
}
func (o *PWM_Type) GetSM2CVAL4() uint16 {
	return volatile.LoadUint16(&o.SM2CVAL4.Reg)
}

// PWM.SM2CVAL4CYC: Capture Value 4 Cycle Register
func (o *PWM_Type) SetSM2CVAL4CYC_CVAL4CYC(value uint16) {
	volatile.StoreUint16(&o.SM2CVAL4CYC.Reg, volatile.LoadUint16(&o.SM2CVAL4CYC.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM2CVAL4CYC_CVAL4CYC() uint16 {
	return volatile.LoadUint16(&o.SM2CVAL4CYC.Reg) & 0xf
}

// PWM.SM2CVAL5: Capture Value 5 Register
func (o *PWM_Type) SetSM2CVAL5(value uint16) {
	volatile.StoreUint16(&o.SM2CVAL5.Reg, value)
}
func (o *PWM_Type) GetSM2CVAL5() uint16 {
	return volatile.LoadUint16(&o.SM2CVAL5.Reg)
}

// PWM.SM2CVAL5CYC: Capture Value 5 Cycle Register
func (o *PWM_Type) SetSM2CVAL5CYC_CVAL5CYC(value uint16) {
	volatile.StoreUint16(&o.SM2CVAL5CYC.Reg, volatile.LoadUint16(&o.SM2CVAL5CYC.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM2CVAL5CYC_CVAL5CYC() uint16 {
	return volatile.LoadUint16(&o.SM2CVAL5CYC.Reg) & 0xf
}

// PWM.SM2PHASEDLY: Phase Delay Register
func (o *PWM_Type) SetSM2PHASEDLY(value uint16) {
	volatile.StoreUint16(&o.SM2PHASEDLY.Reg, value)
}
func (o *PWM_Type) GetSM2PHASEDLY() uint16 {
	return volatile.LoadUint16(&o.SM2PHASEDLY.Reg)
}

// PWM.SM3CNT: Counter Register
func (o *PWM_Type) SetSM3CNT(value uint16) {
	volatile.StoreUint16(&o.SM3CNT.Reg, value)
}
func (o *PWM_Type) GetSM3CNT() uint16 {
	return volatile.LoadUint16(&o.SM3CNT.Reg)
}

// PWM.SM3INIT: Initial Count Register
func (o *PWM_Type) SetSM3INIT(value uint16) {
	volatile.StoreUint16(&o.SM3INIT.Reg, value)
}
func (o *PWM_Type) GetSM3INIT() uint16 {
	return volatile.LoadUint16(&o.SM3INIT.Reg)
}

// PWM.SM3CTRL2: Control 2 Register
func (o *PWM_Type) SetSM3CTRL2_CLK_SEL(value uint16) {
	volatile.StoreUint16(&o.SM3CTRL2.Reg, volatile.LoadUint16(&o.SM3CTRL2.Reg)&^(0x3)|value)
}
func (o *PWM_Type) GetSM3CTRL2_CLK_SEL() uint16 {
	return volatile.LoadUint16(&o.SM3CTRL2.Reg) & 0x3
}
func (o *PWM_Type) SetSM3CTRL2_RELOAD_SEL(value uint16) {
	volatile.StoreUint16(&o.SM3CTRL2.Reg, volatile.LoadUint16(&o.SM3CTRL2.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetSM3CTRL2_RELOAD_SEL() uint16 {
	return (volatile.LoadUint16(&o.SM3CTRL2.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetSM3CTRL2_FORCE_SEL(value uint16) {
	volatile.StoreUint16(&o.SM3CTRL2.Reg, volatile.LoadUint16(&o.SM3CTRL2.Reg)&^(0x38)|value<<3)
}
func (o *PWM_Type) GetSM3CTRL2_FORCE_SEL() uint16 {
	return (volatile.LoadUint16(&o.SM3CTRL2.Reg) & 0x38) >> 3
}
func (o *PWM_Type) SetSM3CTRL2_FORCE(value uint16) {
	volatile.StoreUint16(&o.SM3CTRL2.Reg, volatile.LoadUint16(&o.SM3CTRL2.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetSM3CTRL2_FORCE() uint16 {
	return (volatile.LoadUint16(&o.SM3CTRL2.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetSM3CTRL2_FRCEN(value uint16) {
	volatile.StoreUint16(&o.SM3CTRL2.Reg, volatile.LoadUint16(&o.SM3CTRL2.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetSM3CTRL2_FRCEN() uint16 {
	return (volatile.LoadUint16(&o.SM3CTRL2.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetSM3CTRL2_INIT_SEL(value uint16) {
	volatile.StoreUint16(&o.SM3CTRL2.Reg, volatile.LoadUint16(&o.SM3CTRL2.Reg)&^(0x300)|value<<8)
}
func (o *PWM_Type) GetSM3CTRL2_INIT_SEL() uint16 {
	return (volatile.LoadUint16(&o.SM3CTRL2.Reg) & 0x300) >> 8
}
func (o *PWM_Type) SetSM3CTRL2_PWMX_INIT(value uint16) {
	volatile.StoreUint16(&o.SM3CTRL2.Reg, volatile.LoadUint16(&o.SM3CTRL2.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetSM3CTRL2_PWMX_INIT() uint16 {
	return (volatile.LoadUint16(&o.SM3CTRL2.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetSM3CTRL2_PWM45_INIT(value uint16) {
	volatile.StoreUint16(&o.SM3CTRL2.Reg, volatile.LoadUint16(&o.SM3CTRL2.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetSM3CTRL2_PWM45_INIT() uint16 {
	return (volatile.LoadUint16(&o.SM3CTRL2.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetSM3CTRL2_PWM23_INIT(value uint16) {
	volatile.StoreUint16(&o.SM3CTRL2.Reg, volatile.LoadUint16(&o.SM3CTRL2.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetSM3CTRL2_PWM23_INIT() uint16 {
	return (volatile.LoadUint16(&o.SM3CTRL2.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetSM3CTRL2_INDEP(value uint16) {
	volatile.StoreUint16(&o.SM3CTRL2.Reg, volatile.LoadUint16(&o.SM3CTRL2.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetSM3CTRL2_INDEP() uint16 {
	return (volatile.LoadUint16(&o.SM3CTRL2.Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetSM3CTRL2_WAITEN(value uint16) {
	volatile.StoreUint16(&o.SM3CTRL2.Reg, volatile.LoadUint16(&o.SM3CTRL2.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetSM3CTRL2_WAITEN() uint16 {
	return (volatile.LoadUint16(&o.SM3CTRL2.Reg) & 0x4000) >> 14
}
func (o *PWM_Type) SetSM3CTRL2_DBGEN(value uint16) {
	volatile.StoreUint16(&o.SM3CTRL2.Reg, volatile.LoadUint16(&o.SM3CTRL2.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetSM3CTRL2_DBGEN() uint16 {
	return (volatile.LoadUint16(&o.SM3CTRL2.Reg) & 0x8000) >> 15
}

// PWM.SM3CTRL: Control Register
func (o *PWM_Type) SetSM3CTRL_DBLEN(value uint16) {
	volatile.StoreUint16(&o.SM3CTRL.Reg, volatile.LoadUint16(&o.SM3CTRL.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSM3CTRL_DBLEN() uint16 {
	return volatile.LoadUint16(&o.SM3CTRL.Reg) & 0x1
}
func (o *PWM_Type) SetSM3CTRL_DBLX(value uint16) {
	volatile.StoreUint16(&o.SM3CTRL.Reg, volatile.LoadUint16(&o.SM3CTRL.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSM3CTRL_DBLX() uint16 {
	return (volatile.LoadUint16(&o.SM3CTRL.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSM3CTRL_LDMOD(value uint16) {
	volatile.StoreUint16(&o.SM3CTRL.Reg, volatile.LoadUint16(&o.SM3CTRL.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetSM3CTRL_LDMOD() uint16 {
	return (volatile.LoadUint16(&o.SM3CTRL.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetSM3CTRL_SPLIT(value uint16) {
	volatile.StoreUint16(&o.SM3CTRL.Reg, volatile.LoadUint16(&o.SM3CTRL.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetSM3CTRL_SPLIT() uint16 {
	return (volatile.LoadUint16(&o.SM3CTRL.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetSM3CTRL_PRSC(value uint16) {
	volatile.StoreUint16(&o.SM3CTRL.Reg, volatile.LoadUint16(&o.SM3CTRL.Reg)&^(0x70)|value<<4)
}
func (o *PWM_Type) GetSM3CTRL_PRSC() uint16 {
	return (volatile.LoadUint16(&o.SM3CTRL.Reg) & 0x70) >> 4
}
func (o *PWM_Type) SetSM3CTRL_COMPMODE(value uint16) {
	volatile.StoreUint16(&o.SM3CTRL.Reg, volatile.LoadUint16(&o.SM3CTRL.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetSM3CTRL_COMPMODE() uint16 {
	return (volatile.LoadUint16(&o.SM3CTRL.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetSM3CTRL_DT(value uint16) {
	volatile.StoreUint16(&o.SM3CTRL.Reg, volatile.LoadUint16(&o.SM3CTRL.Reg)&^(0x300)|value<<8)
}
func (o *PWM_Type) GetSM3CTRL_DT() uint16 {
	return (volatile.LoadUint16(&o.SM3CTRL.Reg) & 0x300) >> 8
}
func (o *PWM_Type) SetSM3CTRL_FULL(value uint16) {
	volatile.StoreUint16(&o.SM3CTRL.Reg, volatile.LoadUint16(&o.SM3CTRL.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetSM3CTRL_FULL() uint16 {
	return (volatile.LoadUint16(&o.SM3CTRL.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetSM3CTRL_HALF(value uint16) {
	volatile.StoreUint16(&o.SM3CTRL.Reg, volatile.LoadUint16(&o.SM3CTRL.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetSM3CTRL_HALF() uint16 {
	return (volatile.LoadUint16(&o.SM3CTRL.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetSM3CTRL_LDFQ(value uint16) {
	volatile.StoreUint16(&o.SM3CTRL.Reg, volatile.LoadUint16(&o.SM3CTRL.Reg)&^(0xf000)|value<<12)
}
func (o *PWM_Type) GetSM3CTRL_LDFQ() uint16 {
	return (volatile.LoadUint16(&o.SM3CTRL.Reg) & 0xf000) >> 12
}

// PWM.SM3VAL0: Value Register 0
func (o *PWM_Type) SetSM3VAL0(value uint16) {
	volatile.StoreUint16(&o.SM3VAL0.Reg, value)
}
func (o *PWM_Type) GetSM3VAL0() uint16 {
	return volatile.LoadUint16(&o.SM3VAL0.Reg)
}

// PWM.SM3FRACVAL1: Fractional Value Register 1
func (o *PWM_Type) SetSM3FRACVAL1_FRACVAL1(value uint16) {
	volatile.StoreUint16(&o.SM3FRACVAL1.Reg, volatile.LoadUint16(&o.SM3FRACVAL1.Reg)&^(0xf800)|value<<11)
}
func (o *PWM_Type) GetSM3FRACVAL1_FRACVAL1() uint16 {
	return (volatile.LoadUint16(&o.SM3FRACVAL1.Reg) & 0xf800) >> 11
}

// PWM.SM3VAL1: Value Register 1
func (o *PWM_Type) SetSM3VAL1(value uint16) {
	volatile.StoreUint16(&o.SM3VAL1.Reg, value)
}
func (o *PWM_Type) GetSM3VAL1() uint16 {
	return volatile.LoadUint16(&o.SM3VAL1.Reg)
}

// PWM.SM3FRACVAL2: Fractional Value Register 2
func (o *PWM_Type) SetSM3FRACVAL2_FRACVAL2(value uint16) {
	volatile.StoreUint16(&o.SM3FRACVAL2.Reg, volatile.LoadUint16(&o.SM3FRACVAL2.Reg)&^(0xf800)|value<<11)
}
func (o *PWM_Type) GetSM3FRACVAL2_FRACVAL2() uint16 {
	return (volatile.LoadUint16(&o.SM3FRACVAL2.Reg) & 0xf800) >> 11
}

// PWM.SM3VAL2: Value Register 2
func (o *PWM_Type) SetSM3VAL2(value uint16) {
	volatile.StoreUint16(&o.SM3VAL2.Reg, value)
}
func (o *PWM_Type) GetSM3VAL2() uint16 {
	return volatile.LoadUint16(&o.SM3VAL2.Reg)
}

// PWM.SM3FRACVAL3: Fractional Value Register 3
func (o *PWM_Type) SetSM3FRACVAL3_FRACVAL3(value uint16) {
	volatile.StoreUint16(&o.SM3FRACVAL3.Reg, volatile.LoadUint16(&o.SM3FRACVAL3.Reg)&^(0xf800)|value<<11)
}
func (o *PWM_Type) GetSM3FRACVAL3_FRACVAL3() uint16 {
	return (volatile.LoadUint16(&o.SM3FRACVAL3.Reg) & 0xf800) >> 11
}

// PWM.SM3VAL3: Value Register 3
func (o *PWM_Type) SetSM3VAL3(value uint16) {
	volatile.StoreUint16(&o.SM3VAL3.Reg, value)
}
func (o *PWM_Type) GetSM3VAL3() uint16 {
	return volatile.LoadUint16(&o.SM3VAL3.Reg)
}

// PWM.SM3FRACVAL4: Fractional Value Register 4
func (o *PWM_Type) SetSM3FRACVAL4_FRACVAL4(value uint16) {
	volatile.StoreUint16(&o.SM3FRACVAL4.Reg, volatile.LoadUint16(&o.SM3FRACVAL4.Reg)&^(0xf800)|value<<11)
}
func (o *PWM_Type) GetSM3FRACVAL4_FRACVAL4() uint16 {
	return (volatile.LoadUint16(&o.SM3FRACVAL4.Reg) & 0xf800) >> 11
}

// PWM.SM3VAL4: Value Register 4
func (o *PWM_Type) SetSM3VAL4(value uint16) {
	volatile.StoreUint16(&o.SM3VAL4.Reg, value)
}
func (o *PWM_Type) GetSM3VAL4() uint16 {
	return volatile.LoadUint16(&o.SM3VAL4.Reg)
}

// PWM.SM3FRACVAL5: Fractional Value Register 5
func (o *PWM_Type) SetSM3FRACVAL5_FRACVAL5(value uint16) {
	volatile.StoreUint16(&o.SM3FRACVAL5.Reg, volatile.LoadUint16(&o.SM3FRACVAL5.Reg)&^(0xf800)|value<<11)
}
func (o *PWM_Type) GetSM3FRACVAL5_FRACVAL5() uint16 {
	return (volatile.LoadUint16(&o.SM3FRACVAL5.Reg) & 0xf800) >> 11
}

// PWM.SM3VAL5: Value Register 5
func (o *PWM_Type) SetSM3VAL5(value uint16) {
	volatile.StoreUint16(&o.SM3VAL5.Reg, value)
}
func (o *PWM_Type) GetSM3VAL5() uint16 {
	return volatile.LoadUint16(&o.SM3VAL5.Reg)
}

// PWM.SM3FRCTRL: Fractional Control Register
func (o *PWM_Type) SetSM3FRCTRL_FRAC1_EN(value uint16) {
	volatile.StoreUint16(&o.SM3FRCTRL.Reg, volatile.LoadUint16(&o.SM3FRCTRL.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSM3FRCTRL_FRAC1_EN() uint16 {
	return (volatile.LoadUint16(&o.SM3FRCTRL.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSM3FRCTRL_FRAC23_EN(value uint16) {
	volatile.StoreUint16(&o.SM3FRCTRL.Reg, volatile.LoadUint16(&o.SM3FRCTRL.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetSM3FRCTRL_FRAC23_EN() uint16 {
	return (volatile.LoadUint16(&o.SM3FRCTRL.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetSM3FRCTRL_FRAC45_EN(value uint16) {
	volatile.StoreUint16(&o.SM3FRCTRL.Reg, volatile.LoadUint16(&o.SM3FRCTRL.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetSM3FRCTRL_FRAC45_EN() uint16 {
	return (volatile.LoadUint16(&o.SM3FRCTRL.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetSM3FRCTRL_FRAC_PU(value uint16) {
	volatile.StoreUint16(&o.SM3FRCTRL.Reg, volatile.LoadUint16(&o.SM3FRCTRL.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetSM3FRCTRL_FRAC_PU() uint16 {
	return (volatile.LoadUint16(&o.SM3FRCTRL.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetSM3FRCTRL_TEST(value uint16) {
	volatile.StoreUint16(&o.SM3FRCTRL.Reg, volatile.LoadUint16(&o.SM3FRCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetSM3FRCTRL_TEST() uint16 {
	return (volatile.LoadUint16(&o.SM3FRCTRL.Reg) & 0x8000) >> 15
}

// PWM.SM3OCTRL: Output Control Register
func (o *PWM_Type) SetSM3OCTRL_PWMXFS(value uint16) {
	volatile.StoreUint16(&o.SM3OCTRL.Reg, volatile.LoadUint16(&o.SM3OCTRL.Reg)&^(0x3)|value)
}
func (o *PWM_Type) GetSM3OCTRL_PWMXFS() uint16 {
	return volatile.LoadUint16(&o.SM3OCTRL.Reg) & 0x3
}
func (o *PWM_Type) SetSM3OCTRL_PWMBFS(value uint16) {
	volatile.StoreUint16(&o.SM3OCTRL.Reg, volatile.LoadUint16(&o.SM3OCTRL.Reg)&^(0xc)|value<<2)
}
func (o *PWM_Type) GetSM3OCTRL_PWMBFS() uint16 {
	return (volatile.LoadUint16(&o.SM3OCTRL.Reg) & 0xc) >> 2
}
func (o *PWM_Type) SetSM3OCTRL_PWMAFS(value uint16) {
	volatile.StoreUint16(&o.SM3OCTRL.Reg, volatile.LoadUint16(&o.SM3OCTRL.Reg)&^(0x30)|value<<4)
}
func (o *PWM_Type) GetSM3OCTRL_PWMAFS() uint16 {
	return (volatile.LoadUint16(&o.SM3OCTRL.Reg) & 0x30) >> 4
}
func (o *PWM_Type) SetSM3OCTRL_POLX(value uint16) {
	volatile.StoreUint16(&o.SM3OCTRL.Reg, volatile.LoadUint16(&o.SM3OCTRL.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetSM3OCTRL_POLX() uint16 {
	return (volatile.LoadUint16(&o.SM3OCTRL.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetSM3OCTRL_POLB(value uint16) {
	volatile.StoreUint16(&o.SM3OCTRL.Reg, volatile.LoadUint16(&o.SM3OCTRL.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetSM3OCTRL_POLB() uint16 {
	return (volatile.LoadUint16(&o.SM3OCTRL.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetSM3OCTRL_POLA(value uint16) {
	volatile.StoreUint16(&o.SM3OCTRL.Reg, volatile.LoadUint16(&o.SM3OCTRL.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetSM3OCTRL_POLA() uint16 {
	return (volatile.LoadUint16(&o.SM3OCTRL.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetSM3OCTRL_PWMX_IN(value uint16) {
	volatile.StoreUint16(&o.SM3OCTRL.Reg, volatile.LoadUint16(&o.SM3OCTRL.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetSM3OCTRL_PWMX_IN() uint16 {
	return (volatile.LoadUint16(&o.SM3OCTRL.Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetSM3OCTRL_PWMB_IN(value uint16) {
	volatile.StoreUint16(&o.SM3OCTRL.Reg, volatile.LoadUint16(&o.SM3OCTRL.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetSM3OCTRL_PWMB_IN() uint16 {
	return (volatile.LoadUint16(&o.SM3OCTRL.Reg) & 0x4000) >> 14
}
func (o *PWM_Type) SetSM3OCTRL_PWMA_IN(value uint16) {
	volatile.StoreUint16(&o.SM3OCTRL.Reg, volatile.LoadUint16(&o.SM3OCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetSM3OCTRL_PWMA_IN() uint16 {
	return (volatile.LoadUint16(&o.SM3OCTRL.Reg) & 0x8000) >> 15
}

// PWM.SM3STS: Status Register
func (o *PWM_Type) SetSM3STS_CMPF(value uint16) {
	volatile.StoreUint16(&o.SM3STS.Reg, volatile.LoadUint16(&o.SM3STS.Reg)&^(0x3f)|value)
}
func (o *PWM_Type) GetSM3STS_CMPF() uint16 {
	return volatile.LoadUint16(&o.SM3STS.Reg) & 0x3f
}
func (o *PWM_Type) SetSM3STS_CFX0(value uint16) {
	volatile.StoreUint16(&o.SM3STS.Reg, volatile.LoadUint16(&o.SM3STS.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetSM3STS_CFX0() uint16 {
	return (volatile.LoadUint16(&o.SM3STS.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetSM3STS_CFX1(value uint16) {
	volatile.StoreUint16(&o.SM3STS.Reg, volatile.LoadUint16(&o.SM3STS.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetSM3STS_CFX1() uint16 {
	return (volatile.LoadUint16(&o.SM3STS.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetSM3STS_CFB0(value uint16) {
	volatile.StoreUint16(&o.SM3STS.Reg, volatile.LoadUint16(&o.SM3STS.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetSM3STS_CFB0() uint16 {
	return (volatile.LoadUint16(&o.SM3STS.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetSM3STS_CFB1(value uint16) {
	volatile.StoreUint16(&o.SM3STS.Reg, volatile.LoadUint16(&o.SM3STS.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetSM3STS_CFB1() uint16 {
	return (volatile.LoadUint16(&o.SM3STS.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetSM3STS_CFA0(value uint16) {
	volatile.StoreUint16(&o.SM3STS.Reg, volatile.LoadUint16(&o.SM3STS.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetSM3STS_CFA0() uint16 {
	return (volatile.LoadUint16(&o.SM3STS.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetSM3STS_CFA1(value uint16) {
	volatile.StoreUint16(&o.SM3STS.Reg, volatile.LoadUint16(&o.SM3STS.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetSM3STS_CFA1() uint16 {
	return (volatile.LoadUint16(&o.SM3STS.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetSM3STS_RF(value uint16) {
	volatile.StoreUint16(&o.SM3STS.Reg, volatile.LoadUint16(&o.SM3STS.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetSM3STS_RF() uint16 {
	return (volatile.LoadUint16(&o.SM3STS.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetSM3STS_REF(value uint16) {
	volatile.StoreUint16(&o.SM3STS.Reg, volatile.LoadUint16(&o.SM3STS.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetSM3STS_REF() uint16 {
	return (volatile.LoadUint16(&o.SM3STS.Reg) & 0x2000) >> 13
}
func (o *PWM_Type) SetSM3STS_RUF(value uint16) {
	volatile.StoreUint16(&o.SM3STS.Reg, volatile.LoadUint16(&o.SM3STS.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetSM3STS_RUF() uint16 {
	return (volatile.LoadUint16(&o.SM3STS.Reg) & 0x4000) >> 14
}

// PWM.SM3INTEN: Interrupt Enable Register
func (o *PWM_Type) SetSM3INTEN_CMPIE(value uint16) {
	volatile.StoreUint16(&o.SM3INTEN.Reg, volatile.LoadUint16(&o.SM3INTEN.Reg)&^(0x3f)|value)
}
func (o *PWM_Type) GetSM3INTEN_CMPIE() uint16 {
	return volatile.LoadUint16(&o.SM3INTEN.Reg) & 0x3f
}
func (o *PWM_Type) SetSM3INTEN_CX0IE(value uint16) {
	volatile.StoreUint16(&o.SM3INTEN.Reg, volatile.LoadUint16(&o.SM3INTEN.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetSM3INTEN_CX0IE() uint16 {
	return (volatile.LoadUint16(&o.SM3INTEN.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetSM3INTEN_CX1IE(value uint16) {
	volatile.StoreUint16(&o.SM3INTEN.Reg, volatile.LoadUint16(&o.SM3INTEN.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetSM3INTEN_CX1IE() uint16 {
	return (volatile.LoadUint16(&o.SM3INTEN.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetSM3INTEN_CB0IE(value uint16) {
	volatile.StoreUint16(&o.SM3INTEN.Reg, volatile.LoadUint16(&o.SM3INTEN.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetSM3INTEN_CB0IE() uint16 {
	return (volatile.LoadUint16(&o.SM3INTEN.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetSM3INTEN_CB1IE(value uint16) {
	volatile.StoreUint16(&o.SM3INTEN.Reg, volatile.LoadUint16(&o.SM3INTEN.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetSM3INTEN_CB1IE() uint16 {
	return (volatile.LoadUint16(&o.SM3INTEN.Reg) & 0x200) >> 9
}
func (o *PWM_Type) SetSM3INTEN_CA0IE(value uint16) {
	volatile.StoreUint16(&o.SM3INTEN.Reg, volatile.LoadUint16(&o.SM3INTEN.Reg)&^(0x400)|value<<10)
}
func (o *PWM_Type) GetSM3INTEN_CA0IE() uint16 {
	return (volatile.LoadUint16(&o.SM3INTEN.Reg) & 0x400) >> 10
}
func (o *PWM_Type) SetSM3INTEN_CA1IE(value uint16) {
	volatile.StoreUint16(&o.SM3INTEN.Reg, volatile.LoadUint16(&o.SM3INTEN.Reg)&^(0x800)|value<<11)
}
func (o *PWM_Type) GetSM3INTEN_CA1IE() uint16 {
	return (volatile.LoadUint16(&o.SM3INTEN.Reg) & 0x800) >> 11
}
func (o *PWM_Type) SetSM3INTEN_RIE(value uint16) {
	volatile.StoreUint16(&o.SM3INTEN.Reg, volatile.LoadUint16(&o.SM3INTEN.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetSM3INTEN_RIE() uint16 {
	return (volatile.LoadUint16(&o.SM3INTEN.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetSM3INTEN_REIE(value uint16) {
	volatile.StoreUint16(&o.SM3INTEN.Reg, volatile.LoadUint16(&o.SM3INTEN.Reg)&^(0x2000)|value<<13)
}
func (o *PWM_Type) GetSM3INTEN_REIE() uint16 {
	return (volatile.LoadUint16(&o.SM3INTEN.Reg) & 0x2000) >> 13
}

// PWM.SM3DMAEN: DMA Enable Register
func (o *PWM_Type) SetSM3DMAEN_CX0DE(value uint16) {
	volatile.StoreUint16(&o.SM3DMAEN.Reg, volatile.LoadUint16(&o.SM3DMAEN.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSM3DMAEN_CX0DE() uint16 {
	return volatile.LoadUint16(&o.SM3DMAEN.Reg) & 0x1
}
func (o *PWM_Type) SetSM3DMAEN_CX1DE(value uint16) {
	volatile.StoreUint16(&o.SM3DMAEN.Reg, volatile.LoadUint16(&o.SM3DMAEN.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSM3DMAEN_CX1DE() uint16 {
	return (volatile.LoadUint16(&o.SM3DMAEN.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSM3DMAEN_CB0DE(value uint16) {
	volatile.StoreUint16(&o.SM3DMAEN.Reg, volatile.LoadUint16(&o.SM3DMAEN.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetSM3DMAEN_CB0DE() uint16 {
	return (volatile.LoadUint16(&o.SM3DMAEN.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetSM3DMAEN_CB1DE(value uint16) {
	volatile.StoreUint16(&o.SM3DMAEN.Reg, volatile.LoadUint16(&o.SM3DMAEN.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetSM3DMAEN_CB1DE() uint16 {
	return (volatile.LoadUint16(&o.SM3DMAEN.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetSM3DMAEN_CA0DE(value uint16) {
	volatile.StoreUint16(&o.SM3DMAEN.Reg, volatile.LoadUint16(&o.SM3DMAEN.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetSM3DMAEN_CA0DE() uint16 {
	return (volatile.LoadUint16(&o.SM3DMAEN.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetSM3DMAEN_CA1DE(value uint16) {
	volatile.StoreUint16(&o.SM3DMAEN.Reg, volatile.LoadUint16(&o.SM3DMAEN.Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetSM3DMAEN_CA1DE() uint16 {
	return (volatile.LoadUint16(&o.SM3DMAEN.Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetSM3DMAEN_CAPTDE(value uint16) {
	volatile.StoreUint16(&o.SM3DMAEN.Reg, volatile.LoadUint16(&o.SM3DMAEN.Reg)&^(0xc0)|value<<6)
}
func (o *PWM_Type) GetSM3DMAEN_CAPTDE() uint16 {
	return (volatile.LoadUint16(&o.SM3DMAEN.Reg) & 0xc0) >> 6
}
func (o *PWM_Type) SetSM3DMAEN_FAND(value uint16) {
	volatile.StoreUint16(&o.SM3DMAEN.Reg, volatile.LoadUint16(&o.SM3DMAEN.Reg)&^(0x100)|value<<8)
}
func (o *PWM_Type) GetSM3DMAEN_FAND() uint16 {
	return (volatile.LoadUint16(&o.SM3DMAEN.Reg) & 0x100) >> 8
}
func (o *PWM_Type) SetSM3DMAEN_VALDE(value uint16) {
	volatile.StoreUint16(&o.SM3DMAEN.Reg, volatile.LoadUint16(&o.SM3DMAEN.Reg)&^(0x200)|value<<9)
}
func (o *PWM_Type) GetSM3DMAEN_VALDE() uint16 {
	return (volatile.LoadUint16(&o.SM3DMAEN.Reg) & 0x200) >> 9
}

// PWM.SM3TCTRL: Output Trigger Control Register
func (o *PWM_Type) SetSM3TCTRL_OUT_TRIG_EN(value uint16) {
	volatile.StoreUint16(&o.SM3TCTRL.Reg, volatile.LoadUint16(&o.SM3TCTRL.Reg)&^(0x3f)|value)
}
func (o *PWM_Type) GetSM3TCTRL_OUT_TRIG_EN() uint16 {
	return volatile.LoadUint16(&o.SM3TCTRL.Reg) & 0x3f
}
func (o *PWM_Type) SetSM3TCTRL_TRGFRQ(value uint16) {
	volatile.StoreUint16(&o.SM3TCTRL.Reg, volatile.LoadUint16(&o.SM3TCTRL.Reg)&^(0x1000)|value<<12)
}
func (o *PWM_Type) GetSM3TCTRL_TRGFRQ() uint16 {
	return (volatile.LoadUint16(&o.SM3TCTRL.Reg) & 0x1000) >> 12
}
func (o *PWM_Type) SetSM3TCTRL_PWBOT1(value uint16) {
	volatile.StoreUint16(&o.SM3TCTRL.Reg, volatile.LoadUint16(&o.SM3TCTRL.Reg)&^(0x4000)|value<<14)
}
func (o *PWM_Type) GetSM3TCTRL_PWBOT1() uint16 {
	return (volatile.LoadUint16(&o.SM3TCTRL.Reg) & 0x4000) >> 14
}
func (o *PWM_Type) SetSM3TCTRL_PWAOT0(value uint16) {
	volatile.StoreUint16(&o.SM3TCTRL.Reg, volatile.LoadUint16(&o.SM3TCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetSM3TCTRL_PWAOT0() uint16 {
	return (volatile.LoadUint16(&o.SM3TCTRL.Reg) & 0x8000) >> 15
}

// PWM.SM3DISMAP0: Fault Disable Mapping Register 0
func (o *PWM_Type) SetSM3DISMAP0_DIS0A(value uint16) {
	volatile.StoreUint16(&o.SM3DISMAP0.Reg, volatile.LoadUint16(&o.SM3DISMAP0.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM3DISMAP0_DIS0A() uint16 {
	return volatile.LoadUint16(&o.SM3DISMAP0.Reg) & 0xf
}
func (o *PWM_Type) SetSM3DISMAP0_DIS0B(value uint16) {
	volatile.StoreUint16(&o.SM3DISMAP0.Reg, volatile.LoadUint16(&o.SM3DISMAP0.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetSM3DISMAP0_DIS0B() uint16 {
	return (volatile.LoadUint16(&o.SM3DISMAP0.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetSM3DISMAP0_DIS0X(value uint16) {
	volatile.StoreUint16(&o.SM3DISMAP0.Reg, volatile.LoadUint16(&o.SM3DISMAP0.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetSM3DISMAP0_DIS0X() uint16 {
	return (volatile.LoadUint16(&o.SM3DISMAP0.Reg) & 0xf00) >> 8
}

// PWM.SM3DISMAP1: Fault Disable Mapping Register 1
func (o *PWM_Type) SetSM3DISMAP1_DIS1A(value uint16) {
	volatile.StoreUint16(&o.SM3DISMAP1.Reg, volatile.LoadUint16(&o.SM3DISMAP1.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM3DISMAP1_DIS1A() uint16 {
	return volatile.LoadUint16(&o.SM3DISMAP1.Reg) & 0xf
}
func (o *PWM_Type) SetSM3DISMAP1_DIS1B(value uint16) {
	volatile.StoreUint16(&o.SM3DISMAP1.Reg, volatile.LoadUint16(&o.SM3DISMAP1.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetSM3DISMAP1_DIS1B() uint16 {
	return (volatile.LoadUint16(&o.SM3DISMAP1.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetSM3DISMAP1_DIS1X(value uint16) {
	volatile.StoreUint16(&o.SM3DISMAP1.Reg, volatile.LoadUint16(&o.SM3DISMAP1.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetSM3DISMAP1_DIS1X() uint16 {
	return (volatile.LoadUint16(&o.SM3DISMAP1.Reg) & 0xf00) >> 8
}

// PWM.SM3DTCNT0: Deadtime Count Register 0
func (o *PWM_Type) SetSM3DTCNT0(value uint16) {
	volatile.StoreUint16(&o.SM3DTCNT0.Reg, value)
}
func (o *PWM_Type) GetSM3DTCNT0() uint16 {
	return volatile.LoadUint16(&o.SM3DTCNT0.Reg)
}

// PWM.SM3DTCNT1: Deadtime Count Register 1
func (o *PWM_Type) SetSM3DTCNT1(value uint16) {
	volatile.StoreUint16(&o.SM3DTCNT1.Reg, value)
}
func (o *PWM_Type) GetSM3DTCNT1() uint16 {
	return volatile.LoadUint16(&o.SM3DTCNT1.Reg)
}

// PWM.SM3CAPTCTRLA: Capture Control A Register
func (o *PWM_Type) SetSM3CAPTCTRLA_ARMA(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM3CAPTCTRLA.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSM3CAPTCTRLA_ARMA() uint16 {
	return volatile.LoadUint16(&o.SM3CAPTCTRLA.Reg) & 0x1
}
func (o *PWM_Type) SetSM3CAPTCTRLA_ONESHOTA(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM3CAPTCTRLA.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSM3CAPTCTRLA_ONESHOTA() uint16 {
	return (volatile.LoadUint16(&o.SM3CAPTCTRLA.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSM3CAPTCTRLA_EDGA0(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM3CAPTCTRLA.Reg)&^(0xc)|value<<2)
}
func (o *PWM_Type) GetSM3CAPTCTRLA_EDGA0() uint16 {
	return (volatile.LoadUint16(&o.SM3CAPTCTRLA.Reg) & 0xc) >> 2
}
func (o *PWM_Type) SetSM3CAPTCTRLA_EDGA1(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM3CAPTCTRLA.Reg)&^(0x30)|value<<4)
}
func (o *PWM_Type) GetSM3CAPTCTRLA_EDGA1() uint16 {
	return (volatile.LoadUint16(&o.SM3CAPTCTRLA.Reg) & 0x30) >> 4
}
func (o *PWM_Type) SetSM3CAPTCTRLA_INP_SELA(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM3CAPTCTRLA.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetSM3CAPTCTRLA_INP_SELA() uint16 {
	return (volatile.LoadUint16(&o.SM3CAPTCTRLA.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetSM3CAPTCTRLA_EDGCNTA_EN(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM3CAPTCTRLA.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetSM3CAPTCTRLA_EDGCNTA_EN() uint16 {
	return (volatile.LoadUint16(&o.SM3CAPTCTRLA.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetSM3CAPTCTRLA_CFAWM(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM3CAPTCTRLA.Reg)&^(0x300)|value<<8)
}
func (o *PWM_Type) GetSM3CAPTCTRLA_CFAWM() uint16 {
	return (volatile.LoadUint16(&o.SM3CAPTCTRLA.Reg) & 0x300) >> 8
}
func (o *PWM_Type) SetSM3CAPTCTRLA_CA0CNT(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM3CAPTCTRLA.Reg)&^(0x1c00)|value<<10)
}
func (o *PWM_Type) GetSM3CAPTCTRLA_CA0CNT() uint16 {
	return (volatile.LoadUint16(&o.SM3CAPTCTRLA.Reg) & 0x1c00) >> 10
}
func (o *PWM_Type) SetSM3CAPTCTRLA_CA1CNT(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCTRLA.Reg, volatile.LoadUint16(&o.SM3CAPTCTRLA.Reg)&^(0xe000)|value<<13)
}
func (o *PWM_Type) GetSM3CAPTCTRLA_CA1CNT() uint16 {
	return (volatile.LoadUint16(&o.SM3CAPTCTRLA.Reg) & 0xe000) >> 13
}

// PWM.SM3CAPTCOMPA: Capture Compare A Register
func (o *PWM_Type) SetSM3CAPTCOMPA_EDGCMPA(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCOMPA.Reg, volatile.LoadUint16(&o.SM3CAPTCOMPA.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetSM3CAPTCOMPA_EDGCMPA() uint16 {
	return volatile.LoadUint16(&o.SM3CAPTCOMPA.Reg) & 0xff
}
func (o *PWM_Type) SetSM3CAPTCOMPA_EDGCNTA(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCOMPA.Reg, volatile.LoadUint16(&o.SM3CAPTCOMPA.Reg)&^(0xff00)|value<<8)
}
func (o *PWM_Type) GetSM3CAPTCOMPA_EDGCNTA() uint16 {
	return (volatile.LoadUint16(&o.SM3CAPTCOMPA.Reg) & 0xff00) >> 8
}

// PWM.SM3CAPTCTRLB: Capture Control B Register
func (o *PWM_Type) SetSM3CAPTCTRLB_ARMB(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM3CAPTCTRLB.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSM3CAPTCTRLB_ARMB() uint16 {
	return volatile.LoadUint16(&o.SM3CAPTCTRLB.Reg) & 0x1
}
func (o *PWM_Type) SetSM3CAPTCTRLB_ONESHOTB(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM3CAPTCTRLB.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSM3CAPTCTRLB_ONESHOTB() uint16 {
	return (volatile.LoadUint16(&o.SM3CAPTCTRLB.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSM3CAPTCTRLB_EDGB0(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM3CAPTCTRLB.Reg)&^(0xc)|value<<2)
}
func (o *PWM_Type) GetSM3CAPTCTRLB_EDGB0() uint16 {
	return (volatile.LoadUint16(&o.SM3CAPTCTRLB.Reg) & 0xc) >> 2
}
func (o *PWM_Type) SetSM3CAPTCTRLB_EDGB1(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM3CAPTCTRLB.Reg)&^(0x30)|value<<4)
}
func (o *PWM_Type) GetSM3CAPTCTRLB_EDGB1() uint16 {
	return (volatile.LoadUint16(&o.SM3CAPTCTRLB.Reg) & 0x30) >> 4
}
func (o *PWM_Type) SetSM3CAPTCTRLB_INP_SELB(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM3CAPTCTRLB.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetSM3CAPTCTRLB_INP_SELB() uint16 {
	return (volatile.LoadUint16(&o.SM3CAPTCTRLB.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetSM3CAPTCTRLB_EDGCNTB_EN(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM3CAPTCTRLB.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetSM3CAPTCTRLB_EDGCNTB_EN() uint16 {
	return (volatile.LoadUint16(&o.SM3CAPTCTRLB.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetSM3CAPTCTRLB_CFBWM(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM3CAPTCTRLB.Reg)&^(0x300)|value<<8)
}
func (o *PWM_Type) GetSM3CAPTCTRLB_CFBWM() uint16 {
	return (volatile.LoadUint16(&o.SM3CAPTCTRLB.Reg) & 0x300) >> 8
}
func (o *PWM_Type) SetSM3CAPTCTRLB_CB0CNT(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM3CAPTCTRLB.Reg)&^(0x1c00)|value<<10)
}
func (o *PWM_Type) GetSM3CAPTCTRLB_CB0CNT() uint16 {
	return (volatile.LoadUint16(&o.SM3CAPTCTRLB.Reg) & 0x1c00) >> 10
}
func (o *PWM_Type) SetSM3CAPTCTRLB_CB1CNT(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCTRLB.Reg, volatile.LoadUint16(&o.SM3CAPTCTRLB.Reg)&^(0xe000)|value<<13)
}
func (o *PWM_Type) GetSM3CAPTCTRLB_CB1CNT() uint16 {
	return (volatile.LoadUint16(&o.SM3CAPTCTRLB.Reg) & 0xe000) >> 13
}

// PWM.SM3CAPTCOMPB: Capture Compare B Register
func (o *PWM_Type) SetSM3CAPTCOMPB_EDGCMPB(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCOMPB.Reg, volatile.LoadUint16(&o.SM3CAPTCOMPB.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetSM3CAPTCOMPB_EDGCMPB() uint16 {
	return volatile.LoadUint16(&o.SM3CAPTCOMPB.Reg) & 0xff
}
func (o *PWM_Type) SetSM3CAPTCOMPB_EDGCNTB(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCOMPB.Reg, volatile.LoadUint16(&o.SM3CAPTCOMPB.Reg)&^(0xff00)|value<<8)
}
func (o *PWM_Type) GetSM3CAPTCOMPB_EDGCNTB() uint16 {
	return (volatile.LoadUint16(&o.SM3CAPTCOMPB.Reg) & 0xff00) >> 8
}

// PWM.SM3CAPTCTRLX: Capture Control X Register
func (o *PWM_Type) SetSM3CAPTCTRLX_ARMX(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM3CAPTCTRLX.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSM3CAPTCTRLX_ARMX() uint16 {
	return volatile.LoadUint16(&o.SM3CAPTCTRLX.Reg) & 0x1
}
func (o *PWM_Type) SetSM3CAPTCTRLX_ONESHOTX(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM3CAPTCTRLX.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSM3CAPTCTRLX_ONESHOTX() uint16 {
	return (volatile.LoadUint16(&o.SM3CAPTCTRLX.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSM3CAPTCTRLX_EDGX0(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM3CAPTCTRLX.Reg)&^(0xc)|value<<2)
}
func (o *PWM_Type) GetSM3CAPTCTRLX_EDGX0() uint16 {
	return (volatile.LoadUint16(&o.SM3CAPTCTRLX.Reg) & 0xc) >> 2
}
func (o *PWM_Type) SetSM3CAPTCTRLX_EDGX1(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM3CAPTCTRLX.Reg)&^(0x30)|value<<4)
}
func (o *PWM_Type) GetSM3CAPTCTRLX_EDGX1() uint16 {
	return (volatile.LoadUint16(&o.SM3CAPTCTRLX.Reg) & 0x30) >> 4
}
func (o *PWM_Type) SetSM3CAPTCTRLX_INP_SELX(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM3CAPTCTRLX.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetSM3CAPTCTRLX_INP_SELX() uint16 {
	return (volatile.LoadUint16(&o.SM3CAPTCTRLX.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetSM3CAPTCTRLX_EDGCNTX_EN(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM3CAPTCTRLX.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetSM3CAPTCTRLX_EDGCNTX_EN() uint16 {
	return (volatile.LoadUint16(&o.SM3CAPTCTRLX.Reg) & 0x80) >> 7
}
func (o *PWM_Type) SetSM3CAPTCTRLX_CFXWM(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM3CAPTCTRLX.Reg)&^(0x300)|value<<8)
}
func (o *PWM_Type) GetSM3CAPTCTRLX_CFXWM() uint16 {
	return (volatile.LoadUint16(&o.SM3CAPTCTRLX.Reg) & 0x300) >> 8
}
func (o *PWM_Type) SetSM3CAPTCTRLX_CX0CNT(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM3CAPTCTRLX.Reg)&^(0x1c00)|value<<10)
}
func (o *PWM_Type) GetSM3CAPTCTRLX_CX0CNT() uint16 {
	return (volatile.LoadUint16(&o.SM3CAPTCTRLX.Reg) & 0x1c00) >> 10
}
func (o *PWM_Type) SetSM3CAPTCTRLX_CX1CNT(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCTRLX.Reg, volatile.LoadUint16(&o.SM3CAPTCTRLX.Reg)&^(0xe000)|value<<13)
}
func (o *PWM_Type) GetSM3CAPTCTRLX_CX1CNT() uint16 {
	return (volatile.LoadUint16(&o.SM3CAPTCTRLX.Reg) & 0xe000) >> 13
}

// PWM.SM3CAPTCOMPX: Capture Compare X Register
func (o *PWM_Type) SetSM3CAPTCOMPX_EDGCMPX(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCOMPX.Reg, volatile.LoadUint16(&o.SM3CAPTCOMPX.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetSM3CAPTCOMPX_EDGCMPX() uint16 {
	return volatile.LoadUint16(&o.SM3CAPTCOMPX.Reg) & 0xff
}
func (o *PWM_Type) SetSM3CAPTCOMPX_EDGCNTX(value uint16) {
	volatile.StoreUint16(&o.SM3CAPTCOMPX.Reg, volatile.LoadUint16(&o.SM3CAPTCOMPX.Reg)&^(0xff00)|value<<8)
}
func (o *PWM_Type) GetSM3CAPTCOMPX_EDGCNTX() uint16 {
	return (volatile.LoadUint16(&o.SM3CAPTCOMPX.Reg) & 0xff00) >> 8
}

// PWM.SM3CVAL0: Capture Value 0 Register
func (o *PWM_Type) SetSM3CVAL0(value uint16) {
	volatile.StoreUint16(&o.SM3CVAL0.Reg, value)
}
func (o *PWM_Type) GetSM3CVAL0() uint16 {
	return volatile.LoadUint16(&o.SM3CVAL0.Reg)
}

// PWM.SM3CVAL0CYC: Capture Value 0 Cycle Register
func (o *PWM_Type) SetSM3CVAL0CYC_CVAL0CYC(value uint16) {
	volatile.StoreUint16(&o.SM3CVAL0CYC.Reg, volatile.LoadUint16(&o.SM3CVAL0CYC.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM3CVAL0CYC_CVAL0CYC() uint16 {
	return volatile.LoadUint16(&o.SM3CVAL0CYC.Reg) & 0xf
}

// PWM.SM3CVAL1: Capture Value 1 Register
func (o *PWM_Type) SetSM3CVAL1(value uint16) {
	volatile.StoreUint16(&o.SM3CVAL1.Reg, value)
}
func (o *PWM_Type) GetSM3CVAL1() uint16 {
	return volatile.LoadUint16(&o.SM3CVAL1.Reg)
}

// PWM.SM3CVAL1CYC: Capture Value 1 Cycle Register
func (o *PWM_Type) SetSM3CVAL1CYC_CVAL1CYC(value uint16) {
	volatile.StoreUint16(&o.SM3CVAL1CYC.Reg, volatile.LoadUint16(&o.SM3CVAL1CYC.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM3CVAL1CYC_CVAL1CYC() uint16 {
	return volatile.LoadUint16(&o.SM3CVAL1CYC.Reg) & 0xf
}

// PWM.SM3CVAL2: Capture Value 2 Register
func (o *PWM_Type) SetSM3CVAL2(value uint16) {
	volatile.StoreUint16(&o.SM3CVAL2.Reg, value)
}
func (o *PWM_Type) GetSM3CVAL2() uint16 {
	return volatile.LoadUint16(&o.SM3CVAL2.Reg)
}

// PWM.SM3CVAL2CYC: Capture Value 2 Cycle Register
func (o *PWM_Type) SetSM3CVAL2CYC_CVAL2CYC(value uint16) {
	volatile.StoreUint16(&o.SM3CVAL2CYC.Reg, volatile.LoadUint16(&o.SM3CVAL2CYC.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM3CVAL2CYC_CVAL2CYC() uint16 {
	return volatile.LoadUint16(&o.SM3CVAL2CYC.Reg) & 0xf
}

// PWM.SM3CVAL3: Capture Value 3 Register
func (o *PWM_Type) SetSM3CVAL3(value uint16) {
	volatile.StoreUint16(&o.SM3CVAL3.Reg, value)
}
func (o *PWM_Type) GetSM3CVAL3() uint16 {
	return volatile.LoadUint16(&o.SM3CVAL3.Reg)
}

// PWM.SM3CVAL3CYC: Capture Value 3 Cycle Register
func (o *PWM_Type) SetSM3CVAL3CYC_CVAL3CYC(value uint16) {
	volatile.StoreUint16(&o.SM3CVAL3CYC.Reg, volatile.LoadUint16(&o.SM3CVAL3CYC.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM3CVAL3CYC_CVAL3CYC() uint16 {
	return volatile.LoadUint16(&o.SM3CVAL3CYC.Reg) & 0xf
}

// PWM.SM3CVAL4: Capture Value 4 Register
func (o *PWM_Type) SetSM3CVAL4(value uint16) {
	volatile.StoreUint16(&o.SM3CVAL4.Reg, value)
}
func (o *PWM_Type) GetSM3CVAL4() uint16 {
	return volatile.LoadUint16(&o.SM3CVAL4.Reg)
}

// PWM.SM3CVAL4CYC: Capture Value 4 Cycle Register
func (o *PWM_Type) SetSM3CVAL4CYC_CVAL4CYC(value uint16) {
	volatile.StoreUint16(&o.SM3CVAL4CYC.Reg, volatile.LoadUint16(&o.SM3CVAL4CYC.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM3CVAL4CYC_CVAL4CYC() uint16 {
	return volatile.LoadUint16(&o.SM3CVAL4CYC.Reg) & 0xf
}

// PWM.SM3CVAL5: Capture Value 5 Register
func (o *PWM_Type) SetSM3CVAL5(value uint16) {
	volatile.StoreUint16(&o.SM3CVAL5.Reg, value)
}
func (o *PWM_Type) GetSM3CVAL5() uint16 {
	return volatile.LoadUint16(&o.SM3CVAL5.Reg)
}

// PWM.SM3CVAL5CYC: Capture Value 5 Cycle Register
func (o *PWM_Type) SetSM3CVAL5CYC_CVAL5CYC(value uint16) {
	volatile.StoreUint16(&o.SM3CVAL5CYC.Reg, volatile.LoadUint16(&o.SM3CVAL5CYC.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetSM3CVAL5CYC_CVAL5CYC() uint16 {
	return volatile.LoadUint16(&o.SM3CVAL5CYC.Reg) & 0xf
}

// PWM.SM3PHASEDLY: Phase Delay Register
func (o *PWM_Type) SetSM3PHASEDLY(value uint16) {
	volatile.StoreUint16(&o.SM3PHASEDLY.Reg, value)
}
func (o *PWM_Type) GetSM3PHASEDLY() uint16 {
	return volatile.LoadUint16(&o.SM3PHASEDLY.Reg)
}

// PWM.OUTEN: Output Enable Register
func (o *PWM_Type) SetOUTEN_PWMX_EN(value uint16) {
	volatile.StoreUint16(&o.OUTEN.Reg, volatile.LoadUint16(&o.OUTEN.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetOUTEN_PWMX_EN() uint16 {
	return volatile.LoadUint16(&o.OUTEN.Reg) & 0xf
}
func (o *PWM_Type) SetOUTEN_PWMB_EN(value uint16) {
	volatile.StoreUint16(&o.OUTEN.Reg, volatile.LoadUint16(&o.OUTEN.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetOUTEN_PWMB_EN() uint16 {
	return (volatile.LoadUint16(&o.OUTEN.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetOUTEN_PWMA_EN(value uint16) {
	volatile.StoreUint16(&o.OUTEN.Reg, volatile.LoadUint16(&o.OUTEN.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetOUTEN_PWMA_EN() uint16 {
	return (volatile.LoadUint16(&o.OUTEN.Reg) & 0xf00) >> 8
}

// PWM.MASK: Mask Register
func (o *PWM_Type) SetMASK_MASKX(value uint16) {
	volatile.StoreUint16(&o.MASK.Reg, volatile.LoadUint16(&o.MASK.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetMASK_MASKX() uint16 {
	return volatile.LoadUint16(&o.MASK.Reg) & 0xf
}
func (o *PWM_Type) SetMASK_MASKB(value uint16) {
	volatile.StoreUint16(&o.MASK.Reg, volatile.LoadUint16(&o.MASK.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetMASK_MASKB() uint16 {
	return (volatile.LoadUint16(&o.MASK.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetMASK_MASKA(value uint16) {
	volatile.StoreUint16(&o.MASK.Reg, volatile.LoadUint16(&o.MASK.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetMASK_MASKA() uint16 {
	return (volatile.LoadUint16(&o.MASK.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetMASK_UPDATE_MASK(value uint16) {
	volatile.StoreUint16(&o.MASK.Reg, volatile.LoadUint16(&o.MASK.Reg)&^(0xf000)|value<<12)
}
func (o *PWM_Type) GetMASK_UPDATE_MASK() uint16 {
	return (volatile.LoadUint16(&o.MASK.Reg) & 0xf000) >> 12
}

// PWM.SWCOUT: Software Controlled Output Register
func (o *PWM_Type) SetSWCOUT_SM0OUT45(value uint16) {
	volatile.StoreUint16(&o.SWCOUT.Reg, volatile.LoadUint16(&o.SWCOUT.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetSWCOUT_SM0OUT45() uint16 {
	return volatile.LoadUint16(&o.SWCOUT.Reg) & 0x1
}
func (o *PWM_Type) SetSWCOUT_SM0OUT23(value uint16) {
	volatile.StoreUint16(&o.SWCOUT.Reg, volatile.LoadUint16(&o.SWCOUT.Reg)&^(0x2)|value<<1)
}
func (o *PWM_Type) GetSWCOUT_SM0OUT23() uint16 {
	return (volatile.LoadUint16(&o.SWCOUT.Reg) & 0x2) >> 1
}
func (o *PWM_Type) SetSWCOUT_SM1OUT45(value uint16) {
	volatile.StoreUint16(&o.SWCOUT.Reg, volatile.LoadUint16(&o.SWCOUT.Reg)&^(0x4)|value<<2)
}
func (o *PWM_Type) GetSWCOUT_SM1OUT45() uint16 {
	return (volatile.LoadUint16(&o.SWCOUT.Reg) & 0x4) >> 2
}
func (o *PWM_Type) SetSWCOUT_SM1OUT23(value uint16) {
	volatile.StoreUint16(&o.SWCOUT.Reg, volatile.LoadUint16(&o.SWCOUT.Reg)&^(0x8)|value<<3)
}
func (o *PWM_Type) GetSWCOUT_SM1OUT23() uint16 {
	return (volatile.LoadUint16(&o.SWCOUT.Reg) & 0x8) >> 3
}
func (o *PWM_Type) SetSWCOUT_SM2OUT45(value uint16) {
	volatile.StoreUint16(&o.SWCOUT.Reg, volatile.LoadUint16(&o.SWCOUT.Reg)&^(0x10)|value<<4)
}
func (o *PWM_Type) GetSWCOUT_SM2OUT45() uint16 {
	return (volatile.LoadUint16(&o.SWCOUT.Reg) & 0x10) >> 4
}
func (o *PWM_Type) SetSWCOUT_SM2OUT23(value uint16) {
	volatile.StoreUint16(&o.SWCOUT.Reg, volatile.LoadUint16(&o.SWCOUT.Reg)&^(0x20)|value<<5)
}
func (o *PWM_Type) GetSWCOUT_SM2OUT23() uint16 {
	return (volatile.LoadUint16(&o.SWCOUT.Reg) & 0x20) >> 5
}
func (o *PWM_Type) SetSWCOUT_SM3OUT45(value uint16) {
	volatile.StoreUint16(&o.SWCOUT.Reg, volatile.LoadUint16(&o.SWCOUT.Reg)&^(0x40)|value<<6)
}
func (o *PWM_Type) GetSWCOUT_SM3OUT45() uint16 {
	return (volatile.LoadUint16(&o.SWCOUT.Reg) & 0x40) >> 6
}
func (o *PWM_Type) SetSWCOUT_SM3OUT23(value uint16) {
	volatile.StoreUint16(&o.SWCOUT.Reg, volatile.LoadUint16(&o.SWCOUT.Reg)&^(0x80)|value<<7)
}
func (o *PWM_Type) GetSWCOUT_SM3OUT23() uint16 {
	return (volatile.LoadUint16(&o.SWCOUT.Reg) & 0x80) >> 7
}

// PWM.DTSRCSEL: PWM Source Select Register
func (o *PWM_Type) SetDTSRCSEL_SM0SEL45(value uint16) {
	volatile.StoreUint16(&o.DTSRCSEL.Reg, volatile.LoadUint16(&o.DTSRCSEL.Reg)&^(0x3)|value)
}
func (o *PWM_Type) GetDTSRCSEL_SM0SEL45() uint16 {
	return volatile.LoadUint16(&o.DTSRCSEL.Reg) & 0x3
}
func (o *PWM_Type) SetDTSRCSEL_SM0SEL23(value uint16) {
	volatile.StoreUint16(&o.DTSRCSEL.Reg, volatile.LoadUint16(&o.DTSRCSEL.Reg)&^(0xc)|value<<2)
}
func (o *PWM_Type) GetDTSRCSEL_SM0SEL23() uint16 {
	return (volatile.LoadUint16(&o.DTSRCSEL.Reg) & 0xc) >> 2
}
func (o *PWM_Type) SetDTSRCSEL_SM1SEL45(value uint16) {
	volatile.StoreUint16(&o.DTSRCSEL.Reg, volatile.LoadUint16(&o.DTSRCSEL.Reg)&^(0x30)|value<<4)
}
func (o *PWM_Type) GetDTSRCSEL_SM1SEL45() uint16 {
	return (volatile.LoadUint16(&o.DTSRCSEL.Reg) & 0x30) >> 4
}
func (o *PWM_Type) SetDTSRCSEL_SM1SEL23(value uint16) {
	volatile.StoreUint16(&o.DTSRCSEL.Reg, volatile.LoadUint16(&o.DTSRCSEL.Reg)&^(0xc0)|value<<6)
}
func (o *PWM_Type) GetDTSRCSEL_SM1SEL23() uint16 {
	return (volatile.LoadUint16(&o.DTSRCSEL.Reg) & 0xc0) >> 6
}
func (o *PWM_Type) SetDTSRCSEL_SM2SEL45(value uint16) {
	volatile.StoreUint16(&o.DTSRCSEL.Reg, volatile.LoadUint16(&o.DTSRCSEL.Reg)&^(0x300)|value<<8)
}
func (o *PWM_Type) GetDTSRCSEL_SM2SEL45() uint16 {
	return (volatile.LoadUint16(&o.DTSRCSEL.Reg) & 0x300) >> 8
}
func (o *PWM_Type) SetDTSRCSEL_SM2SEL23(value uint16) {
	volatile.StoreUint16(&o.DTSRCSEL.Reg, volatile.LoadUint16(&o.DTSRCSEL.Reg)&^(0xc00)|value<<10)
}
func (o *PWM_Type) GetDTSRCSEL_SM2SEL23() uint16 {
	return (volatile.LoadUint16(&o.DTSRCSEL.Reg) & 0xc00) >> 10
}
func (o *PWM_Type) SetDTSRCSEL_SM3SEL45(value uint16) {
	volatile.StoreUint16(&o.DTSRCSEL.Reg, volatile.LoadUint16(&o.DTSRCSEL.Reg)&^(0x3000)|value<<12)
}
func (o *PWM_Type) GetDTSRCSEL_SM3SEL45() uint16 {
	return (volatile.LoadUint16(&o.DTSRCSEL.Reg) & 0x3000) >> 12
}
func (o *PWM_Type) SetDTSRCSEL_SM3SEL23(value uint16) {
	volatile.StoreUint16(&o.DTSRCSEL.Reg, volatile.LoadUint16(&o.DTSRCSEL.Reg)&^(0xc000)|value<<14)
}
func (o *PWM_Type) GetDTSRCSEL_SM3SEL23() uint16 {
	return (volatile.LoadUint16(&o.DTSRCSEL.Reg) & 0xc000) >> 14
}

// PWM.MCTRL: Master Control Register
func (o *PWM_Type) SetMCTRL_LDOK(value uint16) {
	volatile.StoreUint16(&o.MCTRL.Reg, volatile.LoadUint16(&o.MCTRL.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetMCTRL_LDOK() uint16 {
	return volatile.LoadUint16(&o.MCTRL.Reg) & 0xf
}
func (o *PWM_Type) SetMCTRL_CLDOK(value uint16) {
	volatile.StoreUint16(&o.MCTRL.Reg, volatile.LoadUint16(&o.MCTRL.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetMCTRL_CLDOK() uint16 {
	return (volatile.LoadUint16(&o.MCTRL.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetMCTRL_RUN(value uint16) {
	volatile.StoreUint16(&o.MCTRL.Reg, volatile.LoadUint16(&o.MCTRL.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetMCTRL_RUN() uint16 {
	return (volatile.LoadUint16(&o.MCTRL.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetMCTRL_IPOL(value uint16) {
	volatile.StoreUint16(&o.MCTRL.Reg, volatile.LoadUint16(&o.MCTRL.Reg)&^(0xf000)|value<<12)
}
func (o *PWM_Type) GetMCTRL_IPOL() uint16 {
	return (volatile.LoadUint16(&o.MCTRL.Reg) & 0xf000) >> 12
}

// PWM.MCTRL2: Master Control 2 Register
func (o *PWM_Type) SetMCTRL2_MONPLL(value uint16) {
	volatile.StoreUint16(&o.MCTRL2.Reg, volatile.LoadUint16(&o.MCTRL2.Reg)&^(0x3)|value)
}
func (o *PWM_Type) GetMCTRL2_MONPLL() uint16 {
	return volatile.LoadUint16(&o.MCTRL2.Reg) & 0x3
}

// PWM.FCTRL0: Fault Control Register
func (o *PWM_Type) SetFCTRL0_FIE(value uint16) {
	volatile.StoreUint16(&o.FCTRL0.Reg, volatile.LoadUint16(&o.FCTRL0.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetFCTRL0_FIE() uint16 {
	return volatile.LoadUint16(&o.FCTRL0.Reg) & 0xf
}
func (o *PWM_Type) SetFCTRL0_FSAFE(value uint16) {
	volatile.StoreUint16(&o.FCTRL0.Reg, volatile.LoadUint16(&o.FCTRL0.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetFCTRL0_FSAFE() uint16 {
	return (volatile.LoadUint16(&o.FCTRL0.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetFCTRL0_FAUTO(value uint16) {
	volatile.StoreUint16(&o.FCTRL0.Reg, volatile.LoadUint16(&o.FCTRL0.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetFCTRL0_FAUTO() uint16 {
	return (volatile.LoadUint16(&o.FCTRL0.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetFCTRL0_FLVL(value uint16) {
	volatile.StoreUint16(&o.FCTRL0.Reg, volatile.LoadUint16(&o.FCTRL0.Reg)&^(0xf000)|value<<12)
}
func (o *PWM_Type) GetFCTRL0_FLVL() uint16 {
	return (volatile.LoadUint16(&o.FCTRL0.Reg) & 0xf000) >> 12
}

// PWM.FSTS0: Fault Status Register
func (o *PWM_Type) SetFSTS0_FFLAG(value uint16) {
	volatile.StoreUint16(&o.FSTS0.Reg, volatile.LoadUint16(&o.FSTS0.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetFSTS0_FFLAG() uint16 {
	return volatile.LoadUint16(&o.FSTS0.Reg) & 0xf
}
func (o *PWM_Type) SetFSTS0_FFULL(value uint16) {
	volatile.StoreUint16(&o.FSTS0.Reg, volatile.LoadUint16(&o.FSTS0.Reg)&^(0xf0)|value<<4)
}
func (o *PWM_Type) GetFSTS0_FFULL() uint16 {
	return (volatile.LoadUint16(&o.FSTS0.Reg) & 0xf0) >> 4
}
func (o *PWM_Type) SetFSTS0_FFPIN(value uint16) {
	volatile.StoreUint16(&o.FSTS0.Reg, volatile.LoadUint16(&o.FSTS0.Reg)&^(0xf00)|value<<8)
}
func (o *PWM_Type) GetFSTS0_FFPIN() uint16 {
	return (volatile.LoadUint16(&o.FSTS0.Reg) & 0xf00) >> 8
}
func (o *PWM_Type) SetFSTS0_FHALF(value uint16) {
	volatile.StoreUint16(&o.FSTS0.Reg, volatile.LoadUint16(&o.FSTS0.Reg)&^(0xf000)|value<<12)
}
func (o *PWM_Type) GetFSTS0_FHALF() uint16 {
	return (volatile.LoadUint16(&o.FSTS0.Reg) & 0xf000) >> 12
}

// PWM.FFILT0: Fault Filter Register
func (o *PWM_Type) SetFFILT0_FILT_PER(value uint16) {
	volatile.StoreUint16(&o.FFILT0.Reg, volatile.LoadUint16(&o.FFILT0.Reg)&^(0xff)|value)
}
func (o *PWM_Type) GetFFILT0_FILT_PER() uint16 {
	return volatile.LoadUint16(&o.FFILT0.Reg) & 0xff
}
func (o *PWM_Type) SetFFILT0_FILT_CNT(value uint16) {
	volatile.StoreUint16(&o.FFILT0.Reg, volatile.LoadUint16(&o.FFILT0.Reg)&^(0x700)|value<<8)
}
func (o *PWM_Type) GetFFILT0_FILT_CNT() uint16 {
	return (volatile.LoadUint16(&o.FFILT0.Reg) & 0x700) >> 8
}
func (o *PWM_Type) SetFFILT0_GSTR(value uint16) {
	volatile.StoreUint16(&o.FFILT0.Reg, volatile.LoadUint16(&o.FFILT0.Reg)&^(0x8000)|value<<15)
}
func (o *PWM_Type) GetFFILT0_GSTR() uint16 {
	return (volatile.LoadUint16(&o.FFILT0.Reg) & 0x8000) >> 15
}

// PWM.FTST0: Fault Test Register
func (o *PWM_Type) SetFTST0_FTEST(value uint16) {
	volatile.StoreUint16(&o.FTST0.Reg, volatile.LoadUint16(&o.FTST0.Reg)&^(0x1)|value)
}
func (o *PWM_Type) GetFTST0_FTEST() uint16 {
	return volatile.LoadUint16(&o.FTST0.Reg) & 0x1
}

// PWM.FCTRL20: Fault Control 2 Register
func (o *PWM_Type) SetFCTRL20_NOCOMB(value uint16) {
	volatile.StoreUint16(&o.FCTRL20.Reg, volatile.LoadUint16(&o.FCTRL20.Reg)&^(0xf)|value)
}
func (o *PWM_Type) GetFCTRL20_NOCOMB() uint16 {
	return volatile.LoadUint16(&o.FCTRL20.Reg) & 0xf
}

// SPDIF
type SPDIF_Type struct {
	SCR    volatile.Register32 // 0x0
	SRCD   volatile.Register32 // 0x4
	SRPC   volatile.Register32 // 0x8
	SIE    volatile.Register32 // 0xC
	SIC    volatile.Register32 // 0x10
	SRL    volatile.Register32 // 0x14
	SRR    volatile.Register32 // 0x18
	SRCSH  volatile.Register32 // 0x1C
	SRCSL  volatile.Register32 // 0x20
	SRU    volatile.Register32 // 0x24
	SRQ    volatile.Register32 // 0x28
	STL    volatile.Register32 // 0x2C
	STR    volatile.Register32 // 0x30
	STCSCH volatile.Register32 // 0x34
	STCSCL volatile.Register32 // 0x38
	_      [8]byte
	SRFM   volatile.Register32 // 0x44
	_      [8]byte
	STC    volatile.Register32 // 0x50
}

// SPDIF.SCR: SPDIF Configuration Register
func (o *SPDIF_Type) SetSCR_USrc_Sel(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x3)|value)
}
func (o *SPDIF_Type) GetSCR_USrc_Sel() uint32 {
	return volatile.LoadUint32(&o.SCR.Reg) & 0x3
}
func (o *SPDIF_Type) SetSCR_TxSel(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x1c)|value<<2)
}
func (o *SPDIF_Type) GetSCR_TxSel() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x1c) >> 2
}
func (o *SPDIF_Type) SetSCR_ValCtrl(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x20)|value<<5)
}
func (o *SPDIF_Type) GetSCR_ValCtrl() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x20) >> 5
}
func (o *SPDIF_Type) SetSCR_DMA_TX_En(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x100)|value<<8)
}
func (o *SPDIF_Type) GetSCR_DMA_TX_En() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x100) >> 8
}
func (o *SPDIF_Type) SetSCR_DMA_Rx_En(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x200)|value<<9)
}
func (o *SPDIF_Type) GetSCR_DMA_Rx_En() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x200) >> 9
}
func (o *SPDIF_Type) SetSCR_TxFIFO_Ctrl(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0xc00)|value<<10)
}
func (o *SPDIF_Type) GetSCR_TxFIFO_Ctrl() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0xc00) >> 10
}
func (o *SPDIF_Type) SetSCR_SOFT_RESET(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x1000)|value<<12)
}
func (o *SPDIF_Type) GetSCR_SOFT_RESET() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x1000) >> 12
}
func (o *SPDIF_Type) SetSCR_LOW_POWER(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x2000)|value<<13)
}
func (o *SPDIF_Type) GetSCR_LOW_POWER() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x2000) >> 13
}
func (o *SPDIF_Type) SetSCR_TxFIFOEmpty_Sel(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x18000)|value<<15)
}
func (o *SPDIF_Type) GetSCR_TxFIFOEmpty_Sel() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x18000) >> 15
}
func (o *SPDIF_Type) SetSCR_TxAutoSync(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x20000)|value<<17)
}
func (o *SPDIF_Type) GetSCR_TxAutoSync() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x20000) >> 17
}
func (o *SPDIF_Type) SetSCR_RxAutoSync(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x40000)|value<<18)
}
func (o *SPDIF_Type) GetSCR_RxAutoSync() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x40000) >> 18
}
func (o *SPDIF_Type) SetSCR_RxFIFOFull_Sel(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x180000)|value<<19)
}
func (o *SPDIF_Type) GetSCR_RxFIFOFull_Sel() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x180000) >> 19
}
func (o *SPDIF_Type) SetSCR_RxFIFO_Rst(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x200000)|value<<21)
}
func (o *SPDIF_Type) GetSCR_RxFIFO_Rst() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x200000) >> 21
}
func (o *SPDIF_Type) SetSCR_RxFIFO_Off_On(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x400000)|value<<22)
}
func (o *SPDIF_Type) GetSCR_RxFIFO_Off_On() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x400000) >> 22
}
func (o *SPDIF_Type) SetSCR_RxFIFO_Ctrl(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x800000)|value<<23)
}
func (o *SPDIF_Type) GetSCR_RxFIFO_Ctrl() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x800000) >> 23
}

// SPDIF.SRCD: CDText Control Register
func (o *SPDIF_Type) SetSRCD_USyncMode(value uint32) {
	volatile.StoreUint32(&o.SRCD.Reg, volatile.LoadUint32(&o.SRCD.Reg)&^(0x2)|value<<1)
}
func (o *SPDIF_Type) GetSRCD_USyncMode() uint32 {
	return (volatile.LoadUint32(&o.SRCD.Reg) & 0x2) >> 1
}

// SPDIF.SRPC: PhaseConfig Register
func (o *SPDIF_Type) SetSRPC_GainSel(value uint32) {
	volatile.StoreUint32(&o.SRPC.Reg, volatile.LoadUint32(&o.SRPC.Reg)&^(0x38)|value<<3)
}
func (o *SPDIF_Type) GetSRPC_GainSel() uint32 {
	return (volatile.LoadUint32(&o.SRPC.Reg) & 0x38) >> 3
}
func (o *SPDIF_Type) SetSRPC_LOCK(value uint32) {
	volatile.StoreUint32(&o.SRPC.Reg, volatile.LoadUint32(&o.SRPC.Reg)&^(0x40)|value<<6)
}
func (o *SPDIF_Type) GetSRPC_LOCK() uint32 {
	return (volatile.LoadUint32(&o.SRPC.Reg) & 0x40) >> 6
}
func (o *SPDIF_Type) SetSRPC_ClkSrc_Sel(value uint32) {
	volatile.StoreUint32(&o.SRPC.Reg, volatile.LoadUint32(&o.SRPC.Reg)&^(0x780)|value<<7)
}
func (o *SPDIF_Type) GetSRPC_ClkSrc_Sel() uint32 {
	return (volatile.LoadUint32(&o.SRPC.Reg) & 0x780) >> 7
}

// SPDIF.SIE: InterruptEn Register
func (o *SPDIF_Type) SetSIE_RxFIFOFul(value uint32) {
	volatile.StoreUint32(&o.SIE.Reg, volatile.LoadUint32(&o.SIE.Reg)&^(0x1)|value)
}
func (o *SPDIF_Type) GetSIE_RxFIFOFul() uint32 {
	return volatile.LoadUint32(&o.SIE.Reg) & 0x1
}
func (o *SPDIF_Type) SetSIE_TxEm(value uint32) {
	volatile.StoreUint32(&o.SIE.Reg, volatile.LoadUint32(&o.SIE.Reg)&^(0x2)|value<<1)
}
func (o *SPDIF_Type) GetSIE_TxEm() uint32 {
	return (volatile.LoadUint32(&o.SIE.Reg) & 0x2) >> 1
}
func (o *SPDIF_Type) SetSIE_LockLoss(value uint32) {
	volatile.StoreUint32(&o.SIE.Reg, volatile.LoadUint32(&o.SIE.Reg)&^(0x4)|value<<2)
}
func (o *SPDIF_Type) GetSIE_LockLoss() uint32 {
	return (volatile.LoadUint32(&o.SIE.Reg) & 0x4) >> 2
}
func (o *SPDIF_Type) SetSIE_RxFIFOResyn(value uint32) {
	volatile.StoreUint32(&o.SIE.Reg, volatile.LoadUint32(&o.SIE.Reg)&^(0x8)|value<<3)
}
func (o *SPDIF_Type) GetSIE_RxFIFOResyn() uint32 {
	return (volatile.LoadUint32(&o.SIE.Reg) & 0x8) >> 3
}
func (o *SPDIF_Type) SetSIE_RxFIFOUnOv(value uint32) {
	volatile.StoreUint32(&o.SIE.Reg, volatile.LoadUint32(&o.SIE.Reg)&^(0x10)|value<<4)
}
func (o *SPDIF_Type) GetSIE_RxFIFOUnOv() uint32 {
	return (volatile.LoadUint32(&o.SIE.Reg) & 0x10) >> 4
}
func (o *SPDIF_Type) SetSIE_UQErr(value uint32) {
	volatile.StoreUint32(&o.SIE.Reg, volatile.LoadUint32(&o.SIE.Reg)&^(0x20)|value<<5)
}
func (o *SPDIF_Type) GetSIE_UQErr() uint32 {
	return (volatile.LoadUint32(&o.SIE.Reg) & 0x20) >> 5
}
func (o *SPDIF_Type) SetSIE_UQSync(value uint32) {
	volatile.StoreUint32(&o.SIE.Reg, volatile.LoadUint32(&o.SIE.Reg)&^(0x40)|value<<6)
}
func (o *SPDIF_Type) GetSIE_UQSync() uint32 {
	return (volatile.LoadUint32(&o.SIE.Reg) & 0x40) >> 6
}
func (o *SPDIF_Type) SetSIE_QRxOv(value uint32) {
	volatile.StoreUint32(&o.SIE.Reg, volatile.LoadUint32(&o.SIE.Reg)&^(0x80)|value<<7)
}
func (o *SPDIF_Type) GetSIE_QRxOv() uint32 {
	return (volatile.LoadUint32(&o.SIE.Reg) & 0x80) >> 7
}
func (o *SPDIF_Type) SetSIE_QRxFul(value uint32) {
	volatile.StoreUint32(&o.SIE.Reg, volatile.LoadUint32(&o.SIE.Reg)&^(0x100)|value<<8)
}
func (o *SPDIF_Type) GetSIE_QRxFul() uint32 {
	return (volatile.LoadUint32(&o.SIE.Reg) & 0x100) >> 8
}
func (o *SPDIF_Type) SetSIE_URxOv(value uint32) {
	volatile.StoreUint32(&o.SIE.Reg, volatile.LoadUint32(&o.SIE.Reg)&^(0x200)|value<<9)
}
func (o *SPDIF_Type) GetSIE_URxOv() uint32 {
	return (volatile.LoadUint32(&o.SIE.Reg) & 0x200) >> 9
}
func (o *SPDIF_Type) SetSIE_URxFul(value uint32) {
	volatile.StoreUint32(&o.SIE.Reg, volatile.LoadUint32(&o.SIE.Reg)&^(0x400)|value<<10)
}
func (o *SPDIF_Type) GetSIE_URxFul() uint32 {
	return (volatile.LoadUint32(&o.SIE.Reg) & 0x400) >> 10
}
func (o *SPDIF_Type) SetSIE_BitErr(value uint32) {
	volatile.StoreUint32(&o.SIE.Reg, volatile.LoadUint32(&o.SIE.Reg)&^(0x4000)|value<<14)
}
func (o *SPDIF_Type) GetSIE_BitErr() uint32 {
	return (volatile.LoadUint32(&o.SIE.Reg) & 0x4000) >> 14
}
func (o *SPDIF_Type) SetSIE_SymErr(value uint32) {
	volatile.StoreUint32(&o.SIE.Reg, volatile.LoadUint32(&o.SIE.Reg)&^(0x8000)|value<<15)
}
func (o *SPDIF_Type) GetSIE_SymErr() uint32 {
	return (volatile.LoadUint32(&o.SIE.Reg) & 0x8000) >> 15
}
func (o *SPDIF_Type) SetSIE_ValNoGood(value uint32) {
	volatile.StoreUint32(&o.SIE.Reg, volatile.LoadUint32(&o.SIE.Reg)&^(0x10000)|value<<16)
}
func (o *SPDIF_Type) GetSIE_ValNoGood() uint32 {
	return (volatile.LoadUint32(&o.SIE.Reg) & 0x10000) >> 16
}
func (o *SPDIF_Type) SetSIE_CNew(value uint32) {
	volatile.StoreUint32(&o.SIE.Reg, volatile.LoadUint32(&o.SIE.Reg)&^(0x20000)|value<<17)
}
func (o *SPDIF_Type) GetSIE_CNew() uint32 {
	return (volatile.LoadUint32(&o.SIE.Reg) & 0x20000) >> 17
}
func (o *SPDIF_Type) SetSIE_TxResyn(value uint32) {
	volatile.StoreUint32(&o.SIE.Reg, volatile.LoadUint32(&o.SIE.Reg)&^(0x40000)|value<<18)
}
func (o *SPDIF_Type) GetSIE_TxResyn() uint32 {
	return (volatile.LoadUint32(&o.SIE.Reg) & 0x40000) >> 18
}
func (o *SPDIF_Type) SetSIE_TxUnOv(value uint32) {
	volatile.StoreUint32(&o.SIE.Reg, volatile.LoadUint32(&o.SIE.Reg)&^(0x80000)|value<<19)
}
func (o *SPDIF_Type) GetSIE_TxUnOv() uint32 {
	return (volatile.LoadUint32(&o.SIE.Reg) & 0x80000) >> 19
}
func (o *SPDIF_Type) SetSIE_Lock(value uint32) {
	volatile.StoreUint32(&o.SIE.Reg, volatile.LoadUint32(&o.SIE.Reg)&^(0x100000)|value<<20)
}
func (o *SPDIF_Type) GetSIE_Lock() uint32 {
	return (volatile.LoadUint32(&o.SIE.Reg) & 0x100000) >> 20
}

// SPDIF.SIC: InterruptClear Register
func (o *SPDIF_Type) SetSIC_LockLoss(value uint32) {
	volatile.StoreUint32(&o.SIC.Reg, volatile.LoadUint32(&o.SIC.Reg)&^(0x4)|value<<2)
}
func (o *SPDIF_Type) GetSIC_LockLoss() uint32 {
	return (volatile.LoadUint32(&o.SIC.Reg) & 0x4) >> 2
}
func (o *SPDIF_Type) SetSIC_RxFIFOResyn(value uint32) {
	volatile.StoreUint32(&o.SIC.Reg, volatile.LoadUint32(&o.SIC.Reg)&^(0x8)|value<<3)
}
func (o *SPDIF_Type) GetSIC_RxFIFOResyn() uint32 {
	return (volatile.LoadUint32(&o.SIC.Reg) & 0x8) >> 3
}
func (o *SPDIF_Type) SetSIC_RxFIFOUnOv(value uint32) {
	volatile.StoreUint32(&o.SIC.Reg, volatile.LoadUint32(&o.SIC.Reg)&^(0x10)|value<<4)
}
func (o *SPDIF_Type) GetSIC_RxFIFOUnOv() uint32 {
	return (volatile.LoadUint32(&o.SIC.Reg) & 0x10) >> 4
}
func (o *SPDIF_Type) SetSIC_UQErr(value uint32) {
	volatile.StoreUint32(&o.SIC.Reg, volatile.LoadUint32(&o.SIC.Reg)&^(0x20)|value<<5)
}
func (o *SPDIF_Type) GetSIC_UQErr() uint32 {
	return (volatile.LoadUint32(&o.SIC.Reg) & 0x20) >> 5
}
func (o *SPDIF_Type) SetSIC_UQSync(value uint32) {
	volatile.StoreUint32(&o.SIC.Reg, volatile.LoadUint32(&o.SIC.Reg)&^(0x40)|value<<6)
}
func (o *SPDIF_Type) GetSIC_UQSync() uint32 {
	return (volatile.LoadUint32(&o.SIC.Reg) & 0x40) >> 6
}
func (o *SPDIF_Type) SetSIC_QRxOv(value uint32) {
	volatile.StoreUint32(&o.SIC.Reg, volatile.LoadUint32(&o.SIC.Reg)&^(0x80)|value<<7)
}
func (o *SPDIF_Type) GetSIC_QRxOv() uint32 {
	return (volatile.LoadUint32(&o.SIC.Reg) & 0x80) >> 7
}
func (o *SPDIF_Type) SetSIC_URxOv(value uint32) {
	volatile.StoreUint32(&o.SIC.Reg, volatile.LoadUint32(&o.SIC.Reg)&^(0x200)|value<<9)
}
func (o *SPDIF_Type) GetSIC_URxOv() uint32 {
	return (volatile.LoadUint32(&o.SIC.Reg) & 0x200) >> 9
}
func (o *SPDIF_Type) SetSIC_BitErr(value uint32) {
	volatile.StoreUint32(&o.SIC.Reg, volatile.LoadUint32(&o.SIC.Reg)&^(0x4000)|value<<14)
}
func (o *SPDIF_Type) GetSIC_BitErr() uint32 {
	return (volatile.LoadUint32(&o.SIC.Reg) & 0x4000) >> 14
}
func (o *SPDIF_Type) SetSIC_SymErr(value uint32) {
	volatile.StoreUint32(&o.SIC.Reg, volatile.LoadUint32(&o.SIC.Reg)&^(0x8000)|value<<15)
}
func (o *SPDIF_Type) GetSIC_SymErr() uint32 {
	return (volatile.LoadUint32(&o.SIC.Reg) & 0x8000) >> 15
}
func (o *SPDIF_Type) SetSIC_ValNoGood(value uint32) {
	volatile.StoreUint32(&o.SIC.Reg, volatile.LoadUint32(&o.SIC.Reg)&^(0x10000)|value<<16)
}
func (o *SPDIF_Type) GetSIC_ValNoGood() uint32 {
	return (volatile.LoadUint32(&o.SIC.Reg) & 0x10000) >> 16
}
func (o *SPDIF_Type) SetSIC_CNew(value uint32) {
	volatile.StoreUint32(&o.SIC.Reg, volatile.LoadUint32(&o.SIC.Reg)&^(0x20000)|value<<17)
}
func (o *SPDIF_Type) GetSIC_CNew() uint32 {
	return (volatile.LoadUint32(&o.SIC.Reg) & 0x20000) >> 17
}
func (o *SPDIF_Type) SetSIC_TxResyn(value uint32) {
	volatile.StoreUint32(&o.SIC.Reg, volatile.LoadUint32(&o.SIC.Reg)&^(0x40000)|value<<18)
}
func (o *SPDIF_Type) GetSIC_TxResyn() uint32 {
	return (volatile.LoadUint32(&o.SIC.Reg) & 0x40000) >> 18
}
func (o *SPDIF_Type) SetSIC_TxUnOv(value uint32) {
	volatile.StoreUint32(&o.SIC.Reg, volatile.LoadUint32(&o.SIC.Reg)&^(0x80000)|value<<19)
}
func (o *SPDIF_Type) GetSIC_TxUnOv() uint32 {
	return (volatile.LoadUint32(&o.SIC.Reg) & 0x80000) >> 19
}
func (o *SPDIF_Type) SetSIC_Lock(value uint32) {
	volatile.StoreUint32(&o.SIC.Reg, volatile.LoadUint32(&o.SIC.Reg)&^(0x100000)|value<<20)
}
func (o *SPDIF_Type) GetSIC_Lock() uint32 {
	return (volatile.LoadUint32(&o.SIC.Reg) & 0x100000) >> 20
}

// SPDIF.SRL: SPDIFRxLeft Register
func (o *SPDIF_Type) SetSRL_RxDataLeft(value uint32) {
	volatile.StoreUint32(&o.SRL.Reg, volatile.LoadUint32(&o.SRL.Reg)&^(0xffffff)|value)
}
func (o *SPDIF_Type) GetSRL_RxDataLeft() uint32 {
	return volatile.LoadUint32(&o.SRL.Reg) & 0xffffff
}

// SPDIF.SRR: SPDIFRxRight Register
func (o *SPDIF_Type) SetSRR_RxDataRight(value uint32) {
	volatile.StoreUint32(&o.SRR.Reg, volatile.LoadUint32(&o.SRR.Reg)&^(0xffffff)|value)
}
func (o *SPDIF_Type) GetSRR_RxDataRight() uint32 {
	return volatile.LoadUint32(&o.SRR.Reg) & 0xffffff
}

// SPDIF.SRCSH: SPDIFRxCChannel_h Register
func (o *SPDIF_Type) SetSRCSH_RxCChannel_h(value uint32) {
	volatile.StoreUint32(&o.SRCSH.Reg, volatile.LoadUint32(&o.SRCSH.Reg)&^(0xffffff)|value)
}
func (o *SPDIF_Type) GetSRCSH_RxCChannel_h() uint32 {
	return volatile.LoadUint32(&o.SRCSH.Reg) & 0xffffff
}

// SPDIF.SRCSL: SPDIFRxCChannel_l Register
func (o *SPDIF_Type) SetSRCSL_RxCChannel_l(value uint32) {
	volatile.StoreUint32(&o.SRCSL.Reg, volatile.LoadUint32(&o.SRCSL.Reg)&^(0xffffff)|value)
}
func (o *SPDIF_Type) GetSRCSL_RxCChannel_l() uint32 {
	return volatile.LoadUint32(&o.SRCSL.Reg) & 0xffffff
}

// SPDIF.SRU: UchannelRx Register
func (o *SPDIF_Type) SetSRU_RxUChannel(value uint32) {
	volatile.StoreUint32(&o.SRU.Reg, volatile.LoadUint32(&o.SRU.Reg)&^(0xffffff)|value)
}
func (o *SPDIF_Type) GetSRU_RxUChannel() uint32 {
	return volatile.LoadUint32(&o.SRU.Reg) & 0xffffff
}

// SPDIF.SRQ: QchannelRx Register
func (o *SPDIF_Type) SetSRQ_RxQChannel(value uint32) {
	volatile.StoreUint32(&o.SRQ.Reg, volatile.LoadUint32(&o.SRQ.Reg)&^(0xffffff)|value)
}
func (o *SPDIF_Type) GetSRQ_RxQChannel() uint32 {
	return volatile.LoadUint32(&o.SRQ.Reg) & 0xffffff
}

// SPDIF.STL: SPDIFTxLeft Register
func (o *SPDIF_Type) SetSTL_TxDataLeft(value uint32) {
	volatile.StoreUint32(&o.STL.Reg, volatile.LoadUint32(&o.STL.Reg)&^(0xffffff)|value)
}
func (o *SPDIF_Type) GetSTL_TxDataLeft() uint32 {
	return volatile.LoadUint32(&o.STL.Reg) & 0xffffff
}

// SPDIF.STR: SPDIFTxRight Register
func (o *SPDIF_Type) SetSTR_TxDataRight(value uint32) {
	volatile.StoreUint32(&o.STR.Reg, volatile.LoadUint32(&o.STR.Reg)&^(0xffffff)|value)
}
func (o *SPDIF_Type) GetSTR_TxDataRight() uint32 {
	return volatile.LoadUint32(&o.STR.Reg) & 0xffffff
}

// SPDIF.STCSCH: SPDIFTxCChannelCons_h Register
func (o *SPDIF_Type) SetSTCSCH_TxCChannelCons_h(value uint32) {
	volatile.StoreUint32(&o.STCSCH.Reg, volatile.LoadUint32(&o.STCSCH.Reg)&^(0xffffff)|value)
}
func (o *SPDIF_Type) GetSTCSCH_TxCChannelCons_h() uint32 {
	return volatile.LoadUint32(&o.STCSCH.Reg) & 0xffffff
}

// SPDIF.STCSCL: SPDIFTxCChannelCons_l Register
func (o *SPDIF_Type) SetSTCSCL_TxCChannelCons_l(value uint32) {
	volatile.StoreUint32(&o.STCSCL.Reg, volatile.LoadUint32(&o.STCSCL.Reg)&^(0xffffff)|value)
}
func (o *SPDIF_Type) GetSTCSCL_TxCChannelCons_l() uint32 {
	return volatile.LoadUint32(&o.STCSCL.Reg) & 0xffffff
}

// SPDIF.SRFM: FreqMeas Register
func (o *SPDIF_Type) SetSRFM_FreqMeas(value uint32) {
	volatile.StoreUint32(&o.SRFM.Reg, volatile.LoadUint32(&o.SRFM.Reg)&^(0xffffff)|value)
}
func (o *SPDIF_Type) GetSRFM_FreqMeas() uint32 {
	return volatile.LoadUint32(&o.SRFM.Reg) & 0xffffff
}

// SPDIF.STC: SPDIFTxClk Register
func (o *SPDIF_Type) SetSTC_TxClk_DF(value uint32) {
	volatile.StoreUint32(&o.STC.Reg, volatile.LoadUint32(&o.STC.Reg)&^(0x7f)|value)
}
func (o *SPDIF_Type) GetSTC_TxClk_DF() uint32 {
	return volatile.LoadUint32(&o.STC.Reg) & 0x7f
}
func (o *SPDIF_Type) SetSTC_TX_ALL_CLK_EN(value uint32) {
	volatile.StoreUint32(&o.STC.Reg, volatile.LoadUint32(&o.STC.Reg)&^(0x80)|value<<7)
}
func (o *SPDIF_Type) GetSTC_TX_ALL_CLK_EN() uint32 {
	return (volatile.LoadUint32(&o.STC.Reg) & 0x80) >> 7
}
func (o *SPDIF_Type) SetSTC_TxClk_Source(value uint32) {
	volatile.StoreUint32(&o.STC.Reg, volatile.LoadUint32(&o.STC.Reg)&^(0x700)|value<<8)
}
func (o *SPDIF_Type) GetSTC_TxClk_Source() uint32 {
	return (volatile.LoadUint32(&o.STC.Reg) & 0x700) >> 8
}
func (o *SPDIF_Type) SetSTC_SYSCLK_DF(value uint32) {
	volatile.StoreUint32(&o.STC.Reg, volatile.LoadUint32(&o.STC.Reg)&^(0xff800)|value<<11)
}
func (o *SPDIF_Type) GetSTC_SYSCLK_DF() uint32 {
	return (volatile.LoadUint32(&o.STC.Reg) & 0xff800) >> 11
}

// I2S
type I2S_Type struct {
	VERID volatile.Register32    // 0x0
	PARAM volatile.Register32    // 0x4
	TCSR  volatile.Register32    // 0x8
	TCR1  volatile.Register32    // 0xC
	TCR2  volatile.Register32    // 0x10
	TCR3  volatile.Register32    // 0x14
	TCR4  volatile.Register32    // 0x18
	TCR5  volatile.Register32    // 0x1C
	TDR   [2]volatile.Register32 // 0x20
	_     [24]byte
	TFR   [2]volatile.Register32 // 0x40
	_     [24]byte
	TMR   volatile.Register32 // 0x60
	_     [36]byte
	RCSR  volatile.Register32    // 0x88
	RCR1  volatile.Register32    // 0x8C
	RCR2  volatile.Register32    // 0x90
	RCR3  volatile.Register32    // 0x94
	RCR4  volatile.Register32    // 0x98
	RCR5  volatile.Register32    // 0x9C
	RDR   [2]volatile.Register32 // 0xA0
	_     [24]byte
	RFR   [2]volatile.Register32 // 0xC0
	_     [24]byte
	RMR   volatile.Register32 // 0xE0
}

// I2S.VERID: Version ID Register
func (o *I2S_Type) SetVERID_FEATURE(value uint32) {
	volatile.StoreUint32(&o.VERID.Reg, volatile.LoadUint32(&o.VERID.Reg)&^(0xffff)|value)
}
func (o *I2S_Type) GetVERID_FEATURE() uint32 {
	return volatile.LoadUint32(&o.VERID.Reg) & 0xffff
}
func (o *I2S_Type) SetVERID_MINOR(value uint32) {
	volatile.StoreUint32(&o.VERID.Reg, volatile.LoadUint32(&o.VERID.Reg)&^(0xff0000)|value<<16)
}
func (o *I2S_Type) GetVERID_MINOR() uint32 {
	return (volatile.LoadUint32(&o.VERID.Reg) & 0xff0000) >> 16
}
func (o *I2S_Type) SetVERID_MAJOR(value uint32) {
	volatile.StoreUint32(&o.VERID.Reg, volatile.LoadUint32(&o.VERID.Reg)&^(0xff000000)|value<<24)
}
func (o *I2S_Type) GetVERID_MAJOR() uint32 {
	return (volatile.LoadUint32(&o.VERID.Reg) & 0xff000000) >> 24
}

// I2S.PARAM: Parameter Register
func (o *I2S_Type) SetPARAM_DATALINE(value uint32) {
	volatile.StoreUint32(&o.PARAM.Reg, volatile.LoadUint32(&o.PARAM.Reg)&^(0xf)|value)
}
func (o *I2S_Type) GetPARAM_DATALINE() uint32 {
	return volatile.LoadUint32(&o.PARAM.Reg) & 0xf
}
func (o *I2S_Type) SetPARAM_FIFO(value uint32) {
	volatile.StoreUint32(&o.PARAM.Reg, volatile.LoadUint32(&o.PARAM.Reg)&^(0xf00)|value<<8)
}
func (o *I2S_Type) GetPARAM_FIFO() uint32 {
	return (volatile.LoadUint32(&o.PARAM.Reg) & 0xf00) >> 8
}
func (o *I2S_Type) SetPARAM_FRAME(value uint32) {
	volatile.StoreUint32(&o.PARAM.Reg, volatile.LoadUint32(&o.PARAM.Reg)&^(0xf0000)|value<<16)
}
func (o *I2S_Type) GetPARAM_FRAME() uint32 {
	return (volatile.LoadUint32(&o.PARAM.Reg) & 0xf0000) >> 16
}

// I2S.TCSR: SAI Transmit Control Register
func (o *I2S_Type) SetTCSR_FRDE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetTCSR_FRDE() uint32 {
	return volatile.LoadUint32(&o.TCSR.Reg) & 0x1
}
func (o *I2S_Type) SetTCSR_FWDE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetTCSR_FWDE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetTCSR_FRIE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x100)|value<<8)
}
func (o *I2S_Type) GetTCSR_FRIE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x100) >> 8
}
func (o *I2S_Type) SetTCSR_FWIE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x200)|value<<9)
}
func (o *I2S_Type) GetTCSR_FWIE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x200) >> 9
}
func (o *I2S_Type) SetTCSR_FEIE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x400)|value<<10)
}
func (o *I2S_Type) GetTCSR_FEIE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x400) >> 10
}
func (o *I2S_Type) SetTCSR_SEIE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x800)|value<<11)
}
func (o *I2S_Type) GetTCSR_SEIE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x800) >> 11
}
func (o *I2S_Type) SetTCSR_WSIE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x1000)|value<<12)
}
func (o *I2S_Type) GetTCSR_WSIE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x1000) >> 12
}
func (o *I2S_Type) SetTCSR_FRF(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x10000)|value<<16)
}
func (o *I2S_Type) GetTCSR_FRF() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x10000) >> 16
}
func (o *I2S_Type) SetTCSR_FWF(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x20000)|value<<17)
}
func (o *I2S_Type) GetTCSR_FWF() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x20000) >> 17
}
func (o *I2S_Type) SetTCSR_FEF(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x40000)|value<<18)
}
func (o *I2S_Type) GetTCSR_FEF() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x40000) >> 18
}
func (o *I2S_Type) SetTCSR_SEF(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x80000)|value<<19)
}
func (o *I2S_Type) GetTCSR_SEF() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x80000) >> 19
}
func (o *I2S_Type) SetTCSR_WSF(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x100000)|value<<20)
}
func (o *I2S_Type) GetTCSR_WSF() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x100000) >> 20
}
func (o *I2S_Type) SetTCSR_SR(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x1000000)|value<<24)
}
func (o *I2S_Type) GetTCSR_SR() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x1000000) >> 24
}
func (o *I2S_Type) SetTCSR_FR(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x2000000)|value<<25)
}
func (o *I2S_Type) GetTCSR_FR() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x2000000) >> 25
}
func (o *I2S_Type) SetTCSR_BCE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x10000000)|value<<28)
}
func (o *I2S_Type) GetTCSR_BCE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x10000000) >> 28
}
func (o *I2S_Type) SetTCSR_DBGE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x20000000)|value<<29)
}
func (o *I2S_Type) GetTCSR_DBGE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x20000000) >> 29
}
func (o *I2S_Type) SetTCSR_STOPE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x40000000)|value<<30)
}
func (o *I2S_Type) GetTCSR_STOPE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x40000000) >> 30
}
func (o *I2S_Type) SetTCSR_TE(value uint32) {
	volatile.StoreUint32(&o.TCSR.Reg, volatile.LoadUint32(&o.TCSR.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S_Type) GetTCSR_TE() uint32 {
	return (volatile.LoadUint32(&o.TCSR.Reg) & 0x80000000) >> 31
}

// I2S.TCR1: SAI Transmit Configuration 1 Register
func (o *I2S_Type) SetTCR1_TFW(value uint32) {
	volatile.StoreUint32(&o.TCR1.Reg, volatile.LoadUint32(&o.TCR1.Reg)&^(0x1f)|value)
}
func (o *I2S_Type) GetTCR1_TFW() uint32 {
	return volatile.LoadUint32(&o.TCR1.Reg) & 0x1f
}

// I2S.TCR2: SAI Transmit Configuration 2 Register
func (o *I2S_Type) SetTCR2_DIV(value uint32) {
	volatile.StoreUint32(&o.TCR2.Reg, volatile.LoadUint32(&o.TCR2.Reg)&^(0xff)|value)
}
func (o *I2S_Type) GetTCR2_DIV() uint32 {
	return volatile.LoadUint32(&o.TCR2.Reg) & 0xff
}
func (o *I2S_Type) SetTCR2_BCD(value uint32) {
	volatile.StoreUint32(&o.TCR2.Reg, volatile.LoadUint32(&o.TCR2.Reg)&^(0x1000000)|value<<24)
}
func (o *I2S_Type) GetTCR2_BCD() uint32 {
	return (volatile.LoadUint32(&o.TCR2.Reg) & 0x1000000) >> 24
}
func (o *I2S_Type) SetTCR2_BCP(value uint32) {
	volatile.StoreUint32(&o.TCR2.Reg, volatile.LoadUint32(&o.TCR2.Reg)&^(0x2000000)|value<<25)
}
func (o *I2S_Type) GetTCR2_BCP() uint32 {
	return (volatile.LoadUint32(&o.TCR2.Reg) & 0x2000000) >> 25
}
func (o *I2S_Type) SetTCR2_MSEL(value uint32) {
	volatile.StoreUint32(&o.TCR2.Reg, volatile.LoadUint32(&o.TCR2.Reg)&^(0xc000000)|value<<26)
}
func (o *I2S_Type) GetTCR2_MSEL() uint32 {
	return (volatile.LoadUint32(&o.TCR2.Reg) & 0xc000000) >> 26
}
func (o *I2S_Type) SetTCR2_BCI(value uint32) {
	volatile.StoreUint32(&o.TCR2.Reg, volatile.LoadUint32(&o.TCR2.Reg)&^(0x10000000)|value<<28)
}
func (o *I2S_Type) GetTCR2_BCI() uint32 {
	return (volatile.LoadUint32(&o.TCR2.Reg) & 0x10000000) >> 28
}
func (o *I2S_Type) SetTCR2_BCS(value uint32) {
	volatile.StoreUint32(&o.TCR2.Reg, volatile.LoadUint32(&o.TCR2.Reg)&^(0x20000000)|value<<29)
}
func (o *I2S_Type) GetTCR2_BCS() uint32 {
	return (volatile.LoadUint32(&o.TCR2.Reg) & 0x20000000) >> 29
}
func (o *I2S_Type) SetTCR2_SYNC(value uint32) {
	volatile.StoreUint32(&o.TCR2.Reg, volatile.LoadUint32(&o.TCR2.Reg)&^(0xc0000000)|value<<30)
}
func (o *I2S_Type) GetTCR2_SYNC() uint32 {
	return (volatile.LoadUint32(&o.TCR2.Reg) & 0xc0000000) >> 30
}

// I2S.TCR3: SAI Transmit Configuration 3 Register
func (o *I2S_Type) SetTCR3_WDFL(value uint32) {
	volatile.StoreUint32(&o.TCR3.Reg, volatile.LoadUint32(&o.TCR3.Reg)&^(0x1f)|value)
}
func (o *I2S_Type) GetTCR3_WDFL() uint32 {
	return volatile.LoadUint32(&o.TCR3.Reg) & 0x1f
}
func (o *I2S_Type) SetTCR3_TCE(value uint32) {
	volatile.StoreUint32(&o.TCR3.Reg, volatile.LoadUint32(&o.TCR3.Reg)&^(0x30000)|value<<16)
}
func (o *I2S_Type) GetTCR3_TCE() uint32 {
	return (volatile.LoadUint32(&o.TCR3.Reg) & 0x30000) >> 16
}
func (o *I2S_Type) SetTCR3_CFR(value uint32) {
	volatile.StoreUint32(&o.TCR3.Reg, volatile.LoadUint32(&o.TCR3.Reg)&^(0x3000000)|value<<24)
}
func (o *I2S_Type) GetTCR3_CFR() uint32 {
	return (volatile.LoadUint32(&o.TCR3.Reg) & 0x3000000) >> 24
}

// I2S.TCR4: SAI Transmit Configuration 4 Register
func (o *I2S_Type) SetTCR4_FSD(value uint32) {
	volatile.StoreUint32(&o.TCR4.Reg, volatile.LoadUint32(&o.TCR4.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetTCR4_FSD() uint32 {
	return volatile.LoadUint32(&o.TCR4.Reg) & 0x1
}
func (o *I2S_Type) SetTCR4_FSP(value uint32) {
	volatile.StoreUint32(&o.TCR4.Reg, volatile.LoadUint32(&o.TCR4.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetTCR4_FSP() uint32 {
	return (volatile.LoadUint32(&o.TCR4.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetTCR4_ONDEM(value uint32) {
	volatile.StoreUint32(&o.TCR4.Reg, volatile.LoadUint32(&o.TCR4.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetTCR4_ONDEM() uint32 {
	return (volatile.LoadUint32(&o.TCR4.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetTCR4_FSE(value uint32) {
	volatile.StoreUint32(&o.TCR4.Reg, volatile.LoadUint32(&o.TCR4.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetTCR4_FSE() uint32 {
	return (volatile.LoadUint32(&o.TCR4.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetTCR4_MF(value uint32) {
	volatile.StoreUint32(&o.TCR4.Reg, volatile.LoadUint32(&o.TCR4.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetTCR4_MF() uint32 {
	return (volatile.LoadUint32(&o.TCR4.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetTCR4_CHMOD(value uint32) {
	volatile.StoreUint32(&o.TCR4.Reg, volatile.LoadUint32(&o.TCR4.Reg)&^(0x20)|value<<5)
}
func (o *I2S_Type) GetTCR4_CHMOD() uint32 {
	return (volatile.LoadUint32(&o.TCR4.Reg) & 0x20) >> 5
}
func (o *I2S_Type) SetTCR4_SYWD(value uint32) {
	volatile.StoreUint32(&o.TCR4.Reg, volatile.LoadUint32(&o.TCR4.Reg)&^(0x1f00)|value<<8)
}
func (o *I2S_Type) GetTCR4_SYWD() uint32 {
	return (volatile.LoadUint32(&o.TCR4.Reg) & 0x1f00) >> 8
}
func (o *I2S_Type) SetTCR4_FRSZ(value uint32) {
	volatile.StoreUint32(&o.TCR4.Reg, volatile.LoadUint32(&o.TCR4.Reg)&^(0x1f0000)|value<<16)
}
func (o *I2S_Type) GetTCR4_FRSZ() uint32 {
	return (volatile.LoadUint32(&o.TCR4.Reg) & 0x1f0000) >> 16
}
func (o *I2S_Type) SetTCR4_FPACK(value uint32) {
	volatile.StoreUint32(&o.TCR4.Reg, volatile.LoadUint32(&o.TCR4.Reg)&^(0x3000000)|value<<24)
}
func (o *I2S_Type) GetTCR4_FPACK() uint32 {
	return (volatile.LoadUint32(&o.TCR4.Reg) & 0x3000000) >> 24
}
func (o *I2S_Type) SetTCR4_FCOMB(value uint32) {
	volatile.StoreUint32(&o.TCR4.Reg, volatile.LoadUint32(&o.TCR4.Reg)&^(0xc000000)|value<<26)
}
func (o *I2S_Type) GetTCR4_FCOMB() uint32 {
	return (volatile.LoadUint32(&o.TCR4.Reg) & 0xc000000) >> 26
}
func (o *I2S_Type) SetTCR4_FCONT(value uint32) {
	volatile.StoreUint32(&o.TCR4.Reg, volatile.LoadUint32(&o.TCR4.Reg)&^(0x10000000)|value<<28)
}
func (o *I2S_Type) GetTCR4_FCONT() uint32 {
	return (volatile.LoadUint32(&o.TCR4.Reg) & 0x10000000) >> 28
}

// I2S.TCR5: SAI Transmit Configuration 5 Register
func (o *I2S_Type) SetTCR5_FBT(value uint32) {
	volatile.StoreUint32(&o.TCR5.Reg, volatile.LoadUint32(&o.TCR5.Reg)&^(0x1f00)|value<<8)
}
func (o *I2S_Type) GetTCR5_FBT() uint32 {
	return (volatile.LoadUint32(&o.TCR5.Reg) & 0x1f00) >> 8
}
func (o *I2S_Type) SetTCR5_W0W(value uint32) {
	volatile.StoreUint32(&o.TCR5.Reg, volatile.LoadUint32(&o.TCR5.Reg)&^(0x1f0000)|value<<16)
}
func (o *I2S_Type) GetTCR5_W0W() uint32 {
	return (volatile.LoadUint32(&o.TCR5.Reg) & 0x1f0000) >> 16
}
func (o *I2S_Type) SetTCR5_WNW(value uint32) {
	volatile.StoreUint32(&o.TCR5.Reg, volatile.LoadUint32(&o.TCR5.Reg)&^(0x1f000000)|value<<24)
}
func (o *I2S_Type) GetTCR5_WNW() uint32 {
	return (volatile.LoadUint32(&o.TCR5.Reg) & 0x1f000000) >> 24
}

// I2S.TDR: SAI Transmit Data Register
func (o *I2S_Type) SetTDR(idx int, value uint32) {
	volatile.StoreUint32(&o.TDR[idx].Reg, value)
}
func (o *I2S_Type) GetTDR(idx int) uint32 {
	return volatile.LoadUint32(&o.TDR[idx].Reg)
}

// I2S.TFR: SAI Transmit FIFO Register
func (o *I2S_Type) SetTFR_RFP(idx int, value uint32) {
	volatile.StoreUint32(&o.TFR[idx].Reg, volatile.LoadUint32(&o.TFR[idx].Reg)&^(0x3f)|value)
}
func (o *I2S_Type) GetTFR_RFP(idx int) uint32 {
	return volatile.LoadUint32(&o.TFR[idx].Reg) & 0x3f
}
func (o *I2S_Type) SetTFR_WFP(idx int, value uint32) {
	volatile.StoreUint32(&o.TFR[idx].Reg, volatile.LoadUint32(&o.TFR[idx].Reg)&^(0x3f0000)|value<<16)
}
func (o *I2S_Type) GetTFR_WFP(idx int) uint32 {
	return (volatile.LoadUint32(&o.TFR[idx].Reg) & 0x3f0000) >> 16
}
func (o *I2S_Type) SetTFR_WCP(idx int, value uint32) {
	volatile.StoreUint32(&o.TFR[idx].Reg, volatile.LoadUint32(&o.TFR[idx].Reg)&^(0x80000000)|value<<31)
}
func (o *I2S_Type) GetTFR_WCP(idx int) uint32 {
	return (volatile.LoadUint32(&o.TFR[idx].Reg) & 0x80000000) >> 31
}

// I2S.TMR: SAI Transmit Mask Register
func (o *I2S_Type) SetTMR(value uint32) {
	volatile.StoreUint32(&o.TMR.Reg, value)
}
func (o *I2S_Type) GetTMR() uint32 {
	return volatile.LoadUint32(&o.TMR.Reg)
}

// I2S.RCSR: SAI Receive Control Register
func (o *I2S_Type) SetRCSR_FRDE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetRCSR_FRDE() uint32 {
	return volatile.LoadUint32(&o.RCSR.Reg) & 0x1
}
func (o *I2S_Type) SetRCSR_FWDE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetRCSR_FWDE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetRCSR_FRIE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x100)|value<<8)
}
func (o *I2S_Type) GetRCSR_FRIE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x100) >> 8
}
func (o *I2S_Type) SetRCSR_FWIE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x200)|value<<9)
}
func (o *I2S_Type) GetRCSR_FWIE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x200) >> 9
}
func (o *I2S_Type) SetRCSR_FEIE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x400)|value<<10)
}
func (o *I2S_Type) GetRCSR_FEIE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x400) >> 10
}
func (o *I2S_Type) SetRCSR_SEIE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x800)|value<<11)
}
func (o *I2S_Type) GetRCSR_SEIE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x800) >> 11
}
func (o *I2S_Type) SetRCSR_WSIE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x1000)|value<<12)
}
func (o *I2S_Type) GetRCSR_WSIE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x1000) >> 12
}
func (o *I2S_Type) SetRCSR_FRF(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x10000)|value<<16)
}
func (o *I2S_Type) GetRCSR_FRF() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x10000) >> 16
}
func (o *I2S_Type) SetRCSR_FWF(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x20000)|value<<17)
}
func (o *I2S_Type) GetRCSR_FWF() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x20000) >> 17
}
func (o *I2S_Type) SetRCSR_FEF(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x40000)|value<<18)
}
func (o *I2S_Type) GetRCSR_FEF() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x40000) >> 18
}
func (o *I2S_Type) SetRCSR_SEF(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x80000)|value<<19)
}
func (o *I2S_Type) GetRCSR_SEF() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x80000) >> 19
}
func (o *I2S_Type) SetRCSR_WSF(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x100000)|value<<20)
}
func (o *I2S_Type) GetRCSR_WSF() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x100000) >> 20
}
func (o *I2S_Type) SetRCSR_SR(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x1000000)|value<<24)
}
func (o *I2S_Type) GetRCSR_SR() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x1000000) >> 24
}
func (o *I2S_Type) SetRCSR_FR(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x2000000)|value<<25)
}
func (o *I2S_Type) GetRCSR_FR() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x2000000) >> 25
}
func (o *I2S_Type) SetRCSR_BCE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x10000000)|value<<28)
}
func (o *I2S_Type) GetRCSR_BCE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x10000000) >> 28
}
func (o *I2S_Type) SetRCSR_DBGE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x20000000)|value<<29)
}
func (o *I2S_Type) GetRCSR_DBGE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x20000000) >> 29
}
func (o *I2S_Type) SetRCSR_STOPE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x40000000)|value<<30)
}
func (o *I2S_Type) GetRCSR_STOPE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x40000000) >> 30
}
func (o *I2S_Type) SetRCSR_RE(value uint32) {
	volatile.StoreUint32(&o.RCSR.Reg, volatile.LoadUint32(&o.RCSR.Reg)&^(0x80000000)|value<<31)
}
func (o *I2S_Type) GetRCSR_RE() uint32 {
	return (volatile.LoadUint32(&o.RCSR.Reg) & 0x80000000) >> 31
}

// I2S.RCR1: SAI Receive Configuration 1 Register
func (o *I2S_Type) SetRCR1_RFW(value uint32) {
	volatile.StoreUint32(&o.RCR1.Reg, volatile.LoadUint32(&o.RCR1.Reg)&^(0x1f)|value)
}
func (o *I2S_Type) GetRCR1_RFW() uint32 {
	return volatile.LoadUint32(&o.RCR1.Reg) & 0x1f
}

// I2S.RCR2: SAI Receive Configuration 2 Register
func (o *I2S_Type) SetRCR2_DIV(value uint32) {
	volatile.StoreUint32(&o.RCR2.Reg, volatile.LoadUint32(&o.RCR2.Reg)&^(0xff)|value)
}
func (o *I2S_Type) GetRCR2_DIV() uint32 {
	return volatile.LoadUint32(&o.RCR2.Reg) & 0xff
}
func (o *I2S_Type) SetRCR2_BCD(value uint32) {
	volatile.StoreUint32(&o.RCR2.Reg, volatile.LoadUint32(&o.RCR2.Reg)&^(0x1000000)|value<<24)
}
func (o *I2S_Type) GetRCR2_BCD() uint32 {
	return (volatile.LoadUint32(&o.RCR2.Reg) & 0x1000000) >> 24
}
func (o *I2S_Type) SetRCR2_BCP(value uint32) {
	volatile.StoreUint32(&o.RCR2.Reg, volatile.LoadUint32(&o.RCR2.Reg)&^(0x2000000)|value<<25)
}
func (o *I2S_Type) GetRCR2_BCP() uint32 {
	return (volatile.LoadUint32(&o.RCR2.Reg) & 0x2000000) >> 25
}
func (o *I2S_Type) SetRCR2_MSEL(value uint32) {
	volatile.StoreUint32(&o.RCR2.Reg, volatile.LoadUint32(&o.RCR2.Reg)&^(0xc000000)|value<<26)
}
func (o *I2S_Type) GetRCR2_MSEL() uint32 {
	return (volatile.LoadUint32(&o.RCR2.Reg) & 0xc000000) >> 26
}
func (o *I2S_Type) SetRCR2_BCI(value uint32) {
	volatile.StoreUint32(&o.RCR2.Reg, volatile.LoadUint32(&o.RCR2.Reg)&^(0x10000000)|value<<28)
}
func (o *I2S_Type) GetRCR2_BCI() uint32 {
	return (volatile.LoadUint32(&o.RCR2.Reg) & 0x10000000) >> 28
}
func (o *I2S_Type) SetRCR2_BCS(value uint32) {
	volatile.StoreUint32(&o.RCR2.Reg, volatile.LoadUint32(&o.RCR2.Reg)&^(0x20000000)|value<<29)
}
func (o *I2S_Type) GetRCR2_BCS() uint32 {
	return (volatile.LoadUint32(&o.RCR2.Reg) & 0x20000000) >> 29
}
func (o *I2S_Type) SetRCR2_SYNC(value uint32) {
	volatile.StoreUint32(&o.RCR2.Reg, volatile.LoadUint32(&o.RCR2.Reg)&^(0xc0000000)|value<<30)
}
func (o *I2S_Type) GetRCR2_SYNC() uint32 {
	return (volatile.LoadUint32(&o.RCR2.Reg) & 0xc0000000) >> 30
}

// I2S.RCR3: SAI Receive Configuration 3 Register
func (o *I2S_Type) SetRCR3_WDFL(value uint32) {
	volatile.StoreUint32(&o.RCR3.Reg, volatile.LoadUint32(&o.RCR3.Reg)&^(0x1f)|value)
}
func (o *I2S_Type) GetRCR3_WDFL() uint32 {
	return volatile.LoadUint32(&o.RCR3.Reg) & 0x1f
}
func (o *I2S_Type) SetRCR3_RCE(value uint32) {
	volatile.StoreUint32(&o.RCR3.Reg, volatile.LoadUint32(&o.RCR3.Reg)&^(0x30000)|value<<16)
}
func (o *I2S_Type) GetRCR3_RCE() uint32 {
	return (volatile.LoadUint32(&o.RCR3.Reg) & 0x30000) >> 16
}
func (o *I2S_Type) SetRCR3_CFR(value uint32) {
	volatile.StoreUint32(&o.RCR3.Reg, volatile.LoadUint32(&o.RCR3.Reg)&^(0x3000000)|value<<24)
}
func (o *I2S_Type) GetRCR3_CFR() uint32 {
	return (volatile.LoadUint32(&o.RCR3.Reg) & 0x3000000) >> 24
}

// I2S.RCR4: SAI Receive Configuration 4 Register
func (o *I2S_Type) SetRCR4_FSD(value uint32) {
	volatile.StoreUint32(&o.RCR4.Reg, volatile.LoadUint32(&o.RCR4.Reg)&^(0x1)|value)
}
func (o *I2S_Type) GetRCR4_FSD() uint32 {
	return volatile.LoadUint32(&o.RCR4.Reg) & 0x1
}
func (o *I2S_Type) SetRCR4_FSP(value uint32) {
	volatile.StoreUint32(&o.RCR4.Reg, volatile.LoadUint32(&o.RCR4.Reg)&^(0x2)|value<<1)
}
func (o *I2S_Type) GetRCR4_FSP() uint32 {
	return (volatile.LoadUint32(&o.RCR4.Reg) & 0x2) >> 1
}
func (o *I2S_Type) SetRCR4_ONDEM(value uint32) {
	volatile.StoreUint32(&o.RCR4.Reg, volatile.LoadUint32(&o.RCR4.Reg)&^(0x4)|value<<2)
}
func (o *I2S_Type) GetRCR4_ONDEM() uint32 {
	return (volatile.LoadUint32(&o.RCR4.Reg) & 0x4) >> 2
}
func (o *I2S_Type) SetRCR4_FSE(value uint32) {
	volatile.StoreUint32(&o.RCR4.Reg, volatile.LoadUint32(&o.RCR4.Reg)&^(0x8)|value<<3)
}
func (o *I2S_Type) GetRCR4_FSE() uint32 {
	return (volatile.LoadUint32(&o.RCR4.Reg) & 0x8) >> 3
}
func (o *I2S_Type) SetRCR4_MF(value uint32) {
	volatile.StoreUint32(&o.RCR4.Reg, volatile.LoadUint32(&o.RCR4.Reg)&^(0x10)|value<<4)
}
func (o *I2S_Type) GetRCR4_MF() uint32 {
	return (volatile.LoadUint32(&o.RCR4.Reg) & 0x10) >> 4
}
func (o *I2S_Type) SetRCR4_SYWD(value uint32) {
	volatile.StoreUint32(&o.RCR4.Reg, volatile.LoadUint32(&o.RCR4.Reg)&^(0x1f00)|value<<8)
}
func (o *I2S_Type) GetRCR4_SYWD() uint32 {
	return (volatile.LoadUint32(&o.RCR4.Reg) & 0x1f00) >> 8
}
func (o *I2S_Type) SetRCR4_FRSZ(value uint32) {
	volatile.StoreUint32(&o.RCR4.Reg, volatile.LoadUint32(&o.RCR4.Reg)&^(0x1f0000)|value<<16)
}
func (o *I2S_Type) GetRCR4_FRSZ() uint32 {
	return (volatile.LoadUint32(&o.RCR4.Reg) & 0x1f0000) >> 16
}
func (o *I2S_Type) SetRCR4_FPACK(value uint32) {
	volatile.StoreUint32(&o.RCR4.Reg, volatile.LoadUint32(&o.RCR4.Reg)&^(0x3000000)|value<<24)
}
func (o *I2S_Type) GetRCR4_FPACK() uint32 {
	return (volatile.LoadUint32(&o.RCR4.Reg) & 0x3000000) >> 24
}
func (o *I2S_Type) SetRCR4_FCOMB(value uint32) {
	volatile.StoreUint32(&o.RCR4.Reg, volatile.LoadUint32(&o.RCR4.Reg)&^(0xc000000)|value<<26)
}
func (o *I2S_Type) GetRCR4_FCOMB() uint32 {
	return (volatile.LoadUint32(&o.RCR4.Reg) & 0xc000000) >> 26
}
func (o *I2S_Type) SetRCR4_FCONT(value uint32) {
	volatile.StoreUint32(&o.RCR4.Reg, volatile.LoadUint32(&o.RCR4.Reg)&^(0x10000000)|value<<28)
}
func (o *I2S_Type) GetRCR4_FCONT() uint32 {
	return (volatile.LoadUint32(&o.RCR4.Reg) & 0x10000000) >> 28
}

// I2S.RCR5: SAI Receive Configuration 5 Register
func (o *I2S_Type) SetRCR5_FBT(value uint32) {
	volatile.StoreUint32(&o.RCR5.Reg, volatile.LoadUint32(&o.RCR5.Reg)&^(0x1f00)|value<<8)
}
func (o *I2S_Type) GetRCR5_FBT() uint32 {
	return (volatile.LoadUint32(&o.RCR5.Reg) & 0x1f00) >> 8
}
func (o *I2S_Type) SetRCR5_W0W(value uint32) {
	volatile.StoreUint32(&o.RCR5.Reg, volatile.LoadUint32(&o.RCR5.Reg)&^(0x1f0000)|value<<16)
}
func (o *I2S_Type) GetRCR5_W0W() uint32 {
	return (volatile.LoadUint32(&o.RCR5.Reg) & 0x1f0000) >> 16
}
func (o *I2S_Type) SetRCR5_WNW(value uint32) {
	volatile.StoreUint32(&o.RCR5.Reg, volatile.LoadUint32(&o.RCR5.Reg)&^(0x1f000000)|value<<24)
}
func (o *I2S_Type) GetRCR5_WNW() uint32 {
	return (volatile.LoadUint32(&o.RCR5.Reg) & 0x1f000000) >> 24
}

// I2S.RDR: SAI Receive Data Register
func (o *I2S_Type) SetRDR(idx int, value uint32) {
	volatile.StoreUint32(&o.RDR[idx].Reg, value)
}
func (o *I2S_Type) GetRDR(idx int) uint32 {
	return volatile.LoadUint32(&o.RDR[idx].Reg)
}

// I2S.RFR: SAI Receive FIFO Register
func (o *I2S_Type) SetRFR_RFP(idx int, value uint32) {
	volatile.StoreUint32(&o.RFR[idx].Reg, volatile.LoadUint32(&o.RFR[idx].Reg)&^(0x3f)|value)
}
func (o *I2S_Type) GetRFR_RFP(idx int) uint32 {
	return volatile.LoadUint32(&o.RFR[idx].Reg) & 0x3f
}
func (o *I2S_Type) SetRFR_RCP(idx int, value uint32) {
	volatile.StoreUint32(&o.RFR[idx].Reg, volatile.LoadUint32(&o.RFR[idx].Reg)&^(0x8000)|value<<15)
}
func (o *I2S_Type) GetRFR_RCP(idx int) uint32 {
	return (volatile.LoadUint32(&o.RFR[idx].Reg) & 0x8000) >> 15
}
func (o *I2S_Type) SetRFR_WFP(idx int, value uint32) {
	volatile.StoreUint32(&o.RFR[idx].Reg, volatile.LoadUint32(&o.RFR[idx].Reg)&^(0x3f0000)|value<<16)
}
func (o *I2S_Type) GetRFR_WFP(idx int) uint32 {
	return (volatile.LoadUint32(&o.RFR[idx].Reg) & 0x3f0000) >> 16
}

// I2S.RMR: SAI Receive Mask Register
func (o *I2S_Type) SetRMR(value uint32) {
	volatile.StoreUint32(&o.RMR.Reg, value)
}
func (o *I2S_Type) GetRMR() uint32 {
	return volatile.LoadUint32(&o.RMR.Reg)
}

// GPT
type GPT_Type struct {
	CR   volatile.Register32 // 0x0
	PR   volatile.Register32 // 0x4
	SR   volatile.Register32 // 0x8
	IR   volatile.Register32 // 0xC
	OCR1 volatile.Register32 // 0x10
	OCR2 volatile.Register32 // 0x14
	OCR3 volatile.Register32 // 0x18
	ICR1 volatile.Register32 // 0x1C
	ICR2 volatile.Register32 // 0x20
	CNT  volatile.Register32 // 0x24
}

// GPT.CR: GPT Control Register
func (o *GPT_Type) SetCR_EN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1)|value)
}
func (o *GPT_Type) GetCR_EN() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0x1
}
func (o *GPT_Type) SetCR_ENMOD(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x2)|value<<1)
}
func (o *GPT_Type) GetCR_ENMOD() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x2) >> 1
}
func (o *GPT_Type) SetCR_DBGEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x4)|value<<2)
}
func (o *GPT_Type) GetCR_DBGEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x4) >> 2
}
func (o *GPT_Type) SetCR_WAITEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8)|value<<3)
}
func (o *GPT_Type) GetCR_WAITEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8) >> 3
}
func (o *GPT_Type) SetCR_DOZEEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10)|value<<4)
}
func (o *GPT_Type) GetCR_DOZEEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10) >> 4
}
func (o *GPT_Type) SetCR_STOPEN(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20)|value<<5)
}
func (o *GPT_Type) GetCR_STOPEN() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20) >> 5
}
func (o *GPT_Type) SetCR_CLKSRC(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1c0)|value<<6)
}
func (o *GPT_Type) GetCR_CLKSRC() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1c0) >> 6
}
func (o *GPT_Type) SetCR_FRR(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x200)|value<<9)
}
func (o *GPT_Type) GetCR_FRR() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x200) >> 9
}
func (o *GPT_Type) SetCR_EN_24M(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x400)|value<<10)
}
func (o *GPT_Type) GetCR_EN_24M() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x400) >> 10
}
func (o *GPT_Type) SetCR_SWR(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT_Type) GetCR_SWR() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000) >> 15
}
func (o *GPT_Type) SetCR_IM1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x30000)|value<<16)
}
func (o *GPT_Type) GetCR_IM1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x30000) >> 16
}
func (o *GPT_Type) SetCR_IM2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xc0000)|value<<18)
}
func (o *GPT_Type) GetCR_IM2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xc0000) >> 18
}
func (o *GPT_Type) SetCR_OM1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x700000)|value<<20)
}
func (o *GPT_Type) GetCR_OM1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x700000) >> 20
}
func (o *GPT_Type) SetCR_OM2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x3800000)|value<<23)
}
func (o *GPT_Type) GetCR_OM2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x3800000) >> 23
}
func (o *GPT_Type) SetCR_OM3(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x1c000000)|value<<26)
}
func (o *GPT_Type) GetCR_OM3() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x1c000000) >> 26
}
func (o *GPT_Type) SetCR_FO1(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT_Type) GetCR_FO1() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x20000000) >> 29
}
func (o *GPT_Type) SetCR_FO2(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x40000000)|value<<30)
}
func (o *GPT_Type) GetCR_FO2() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x40000000) >> 30
}
func (o *GPT_Type) SetCR_FO3(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT_Type) GetCR_FO3() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x80000000) >> 31
}

// GPT.PR: GPT Prescaler Register
func (o *GPT_Type) SetPR_PRESCALER(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0xfff)|value)
}
func (o *GPT_Type) GetPR_PRESCALER() uint32 {
	return volatile.LoadUint32(&o.PR.Reg) & 0xfff
}
func (o *GPT_Type) SetPR_PRESCALER24M(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0xf000)|value<<12)
}
func (o *GPT_Type) GetPR_PRESCALER24M() uint32 {
	return (volatile.LoadUint32(&o.PR.Reg) & 0xf000) >> 12
}

// GPT.SR: GPT Status Register
func (o *GPT_Type) SetSR_OF1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *GPT_Type) GetSR_OF1() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *GPT_Type) SetSR_OF2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *GPT_Type) GetSR_OF2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *GPT_Type) SetSR_OF3(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *GPT_Type) GetSR_OF3() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *GPT_Type) SetSR_IF1(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *GPT_Type) GetSR_IF1() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *GPT_Type) SetSR_IF2(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *GPT_Type) GetSR_IF2() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *GPT_Type) SetSR_ROV(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x20)|value<<5)
}
func (o *GPT_Type) GetSR_ROV() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x20) >> 5
}

// GPT.IR: GPT Interrupt Register
func (o *GPT_Type) SetIR_OF1IE(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x1)|value)
}
func (o *GPT_Type) GetIR_OF1IE() uint32 {
	return volatile.LoadUint32(&o.IR.Reg) & 0x1
}
func (o *GPT_Type) SetIR_OF2IE(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x2)|value<<1)
}
func (o *GPT_Type) GetIR_OF2IE() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x2) >> 1
}
func (o *GPT_Type) SetIR_OF3IE(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x4)|value<<2)
}
func (o *GPT_Type) GetIR_OF3IE() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x4) >> 2
}
func (o *GPT_Type) SetIR_IF1IE(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x8)|value<<3)
}
func (o *GPT_Type) GetIR_IF1IE() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x8) >> 3
}
func (o *GPT_Type) SetIR_IF2IE(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x10)|value<<4)
}
func (o *GPT_Type) GetIR_IF2IE() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x10) >> 4
}
func (o *GPT_Type) SetIR_ROVIE(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x20)|value<<5)
}
func (o *GPT_Type) GetIR_ROVIE() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x20) >> 5
}

// GPT.OCR1: GPT Output Compare Register 1
func (o *GPT_Type) SetOCR1(value uint32) {
	volatile.StoreUint32(&o.OCR1.Reg, value)
}
func (o *GPT_Type) GetOCR1() uint32 {
	return volatile.LoadUint32(&o.OCR1.Reg)
}

// GPT.OCR2: GPT Output Compare Register 2
func (o *GPT_Type) SetOCR2(value uint32) {
	volatile.StoreUint32(&o.OCR2.Reg, value)
}
func (o *GPT_Type) GetOCR2() uint32 {
	return volatile.LoadUint32(&o.OCR2.Reg)
}

// GPT.OCR3: GPT Output Compare Register 3
func (o *GPT_Type) SetOCR3(value uint32) {
	volatile.StoreUint32(&o.OCR3.Reg, value)
}
func (o *GPT_Type) GetOCR3() uint32 {
	return volatile.LoadUint32(&o.OCR3.Reg)
}

// GPT.ICR1: GPT Input Capture Register 1
func (o *GPT_Type) SetICR1(value uint32) {
	volatile.StoreUint32(&o.ICR1.Reg, value)
}
func (o *GPT_Type) GetICR1() uint32 {
	return volatile.LoadUint32(&o.ICR1.Reg)
}

// GPT.ICR2: GPT Input Capture Register 2
func (o *GPT_Type) SetICR2(value uint32) {
	volatile.StoreUint32(&o.ICR2.Reg, value)
}
func (o *GPT_Type) GetICR2() uint32 {
	return volatile.LoadUint32(&o.ICR2.Reg)
}

// GPT.CNT: GPT Counter Register
func (o *GPT_Type) SetCNT(value uint32) {
	volatile.StoreUint32(&o.CNT.Reg, value)
}
func (o *GPT_Type) GetCNT() uint32 {
	return volatile.LoadUint32(&o.CNT.Reg)
}

// no description available
type OCOTP_Type struct {
	HW_OCOTP_CTRL           volatile.Register32 // 0x0
	HW_OCOTP_CTRL_SET       volatile.Register32 // 0x4
	HW_OCOTP_CTRL_CLR       volatile.Register32 // 0x8
	HW_OCOTP_CTRL_TOG       volatile.Register32 // 0xC
	HW_OCOTP_TIMING         volatile.Register32 // 0x10
	_                       [12]byte
	HW_OCOTP_DATA           volatile.Register32 // 0x20
	_                       [12]byte
	HW_OCOTP_READ_CTRL      volatile.Register32 // 0x30
	_                       [12]byte
	HW_OCOTP_READ_FUSE_DATA volatile.Register32 // 0x40
	_                       [12]byte
	HW_OCOTP_SW_STICKY      volatile.Register32 // 0x50
	_                       [12]byte
	HW_OCOTP_SCS            volatile.Register32 // 0x60
	HW_OCOTP_SCS_SET        volatile.Register32 // 0x64
	HW_OCOTP_SCS_CLR        volatile.Register32 // 0x68
	HW_OCOTP_SCS_TOG        volatile.Register32 // 0x6C
	_                       [32]byte
	HW_OCOTP_VERSION        volatile.Register32 // 0x90
	_                       [108]byte
	HW_OCOTP_TIMING2        volatile.Register32 // 0x100
	_                       [764]byte
	HW_OCOTP_LOCK           volatile.Register32 // 0x400
	_                       [12]byte
	HW_OCOTP_CFG0           volatile.Register32 // 0x410
	_                       [12]byte
	HW_OCOTP_CFG1           volatile.Register32 // 0x420
	_                       [12]byte
	HW_OCOTP_CFG2           volatile.Register32 // 0x430
	_                       [12]byte
	HW_OCOTP_CFG3           volatile.Register32 // 0x440
	_                       [12]byte
	HW_OCOTP_CFG4           volatile.Register32 // 0x450
	_                       [12]byte
	HW_OCOTP_CFG5           volatile.Register32 // 0x460
	_                       [12]byte
	HW_OCOTP_CFG6           volatile.Register32 // 0x470
	_                       [12]byte
	HW_OCOTP_MEM0           volatile.Register32 // 0x480
	_                       [12]byte
	HW_OCOTP_MEM1           volatile.Register32 // 0x490
	_                       [12]byte
	HW_OCOTP_MEM2           volatile.Register32 // 0x4A0
	_                       [12]byte
	HW_OCOTP_MEM3           volatile.Register32 // 0x4B0
	_                       [12]byte
	HW_OCOTP_MEM4           volatile.Register32 // 0x4C0
	_                       [12]byte
	HW_OCOTP_ANA0           volatile.Register32 // 0x4D0
	_                       [12]byte
	HW_OCOTP_ANA1           volatile.Register32 // 0x4E0
	_                       [12]byte
	HW_OCOTP_ANA2           volatile.Register32 // 0x4F0
	_                       [140]byte
	HW_OCOTP_SRK0           volatile.Register32 // 0x580
	_                       [12]byte
	HW_OCOTP_SRK1           volatile.Register32 // 0x590
	_                       [12]byte
	HW_OCOTP_SRK2           volatile.Register32 // 0x5A0
	_                       [12]byte
	HW_OCOTP_SRK3           volatile.Register32 // 0x5B0
	_                       [12]byte
	HW_OCOTP_SRK4           volatile.Register32 // 0x5C0
	_                       [12]byte
	HW_OCOTP_SRK5           volatile.Register32 // 0x5D0
	_                       [12]byte
	HW_OCOTP_SRK6           volatile.Register32 // 0x5E0
	_                       [12]byte
	HW_OCOTP_SRK7           volatile.Register32 // 0x5F0
	_                       [12]byte
	HW_OCOTP_SJC_RESP0      volatile.Register32 // 0x600
	_                       [12]byte
	HW_OCOTP_SJC_RESP1      volatile.Register32 // 0x610
	_                       [12]byte
	HW_OCOTP_MAC0           volatile.Register32 // 0x620
	_                       [12]byte
	HW_OCOTP_MAC1           volatile.Register32 // 0x630
	_                       [12]byte
	HW_OCOTP_GP3            volatile.Register32 // 0x640
	_                       [28]byte
	HW_OCOTP_GP1            volatile.Register32 // 0x660
	_                       [12]byte
	HW_OCOTP_GP2            volatile.Register32 // 0x670
	_                       [12]byte
	HW_OCOTP_SW_GP1         volatile.Register32 // 0x680
	_                       [12]byte
	HW_OCOTP_SW_GP20        volatile.Register32 // 0x690
	_                       [12]byte
	HW_OCOTP_SW_GP21        volatile.Register32 // 0x6A0
	_                       [12]byte
	HW_OCOTP_SW_GP22        volatile.Register32 // 0x6B0
	_                       [12]byte
	HW_OCOTP_SW_GP23        volatile.Register32 // 0x6C0
	_                       [12]byte
	HW_OCOTP_MISC_CONF0     volatile.Register32 // 0x6D0
	_                       [12]byte
	HW_OCOTP_MISC_CONF1     volatile.Register32 // 0x6E0
	_                       [12]byte
	HW_OCOTP_SRK_REVOKE     volatile.Register32 // 0x6F0
}

// OCOTP.HW_OCOTP_CTRL: OTP Controller Control Register
func (o *OCOTP_Type) SetHW_OCOTP_CTRL_ADDR(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_CTRL.Reg, volatile.LoadUint32(&o.HW_OCOTP_CTRL.Reg)&^(0x3f)|value)
}
func (o *OCOTP_Type) GetHW_OCOTP_CTRL_ADDR() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_CTRL.Reg) & 0x3f
}
func (o *OCOTP_Type) SetHW_OCOTP_CTRL_BUSY(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_CTRL.Reg, volatile.LoadUint32(&o.HW_OCOTP_CTRL.Reg)&^(0x100)|value<<8)
}
func (o *OCOTP_Type) GetHW_OCOTP_CTRL_BUSY() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_CTRL.Reg) & 0x100) >> 8
}
func (o *OCOTP_Type) SetHW_OCOTP_CTRL_ERROR(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_CTRL.Reg, volatile.LoadUint32(&o.HW_OCOTP_CTRL.Reg)&^(0x200)|value<<9)
}
func (o *OCOTP_Type) GetHW_OCOTP_CTRL_ERROR() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_CTRL.Reg) & 0x200) >> 9
}
func (o *OCOTP_Type) SetHW_OCOTP_CTRL_RELOAD_SHADOWS(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_CTRL.Reg, volatile.LoadUint32(&o.HW_OCOTP_CTRL.Reg)&^(0x400)|value<<10)
}
func (o *OCOTP_Type) GetHW_OCOTP_CTRL_RELOAD_SHADOWS() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_CTRL.Reg) & 0x400) >> 10
}
func (o *OCOTP_Type) SetHW_OCOTP_CTRL_WR_UNLOCK(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_CTRL.Reg, volatile.LoadUint32(&o.HW_OCOTP_CTRL.Reg)&^(0xffff0000)|value<<16)
}
func (o *OCOTP_Type) GetHW_OCOTP_CTRL_WR_UNLOCK() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_CTRL.Reg) & 0xffff0000) >> 16
}

// OCOTP.HW_OCOTP_CTRL_SET: OTP Controller Control Register
func (o *OCOTP_Type) SetHW_OCOTP_CTRL_SET_ADDR(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_CTRL_SET.Reg, volatile.LoadUint32(&o.HW_OCOTP_CTRL_SET.Reg)&^(0x3f)|value)
}
func (o *OCOTP_Type) GetHW_OCOTP_CTRL_SET_ADDR() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_CTRL_SET.Reg) & 0x3f
}
func (o *OCOTP_Type) SetHW_OCOTP_CTRL_SET_BUSY(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_CTRL_SET.Reg, volatile.LoadUint32(&o.HW_OCOTP_CTRL_SET.Reg)&^(0x100)|value<<8)
}
func (o *OCOTP_Type) GetHW_OCOTP_CTRL_SET_BUSY() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_CTRL_SET.Reg) & 0x100) >> 8
}
func (o *OCOTP_Type) SetHW_OCOTP_CTRL_SET_ERROR(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_CTRL_SET.Reg, volatile.LoadUint32(&o.HW_OCOTP_CTRL_SET.Reg)&^(0x200)|value<<9)
}
func (o *OCOTP_Type) GetHW_OCOTP_CTRL_SET_ERROR() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_CTRL_SET.Reg) & 0x200) >> 9
}
func (o *OCOTP_Type) SetHW_OCOTP_CTRL_SET_RELOAD_SHADOWS(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_CTRL_SET.Reg, volatile.LoadUint32(&o.HW_OCOTP_CTRL_SET.Reg)&^(0x400)|value<<10)
}
func (o *OCOTP_Type) GetHW_OCOTP_CTRL_SET_RELOAD_SHADOWS() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_CTRL_SET.Reg) & 0x400) >> 10
}
func (o *OCOTP_Type) SetHW_OCOTP_CTRL_SET_WR_UNLOCK(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_CTRL_SET.Reg, volatile.LoadUint32(&o.HW_OCOTP_CTRL_SET.Reg)&^(0xffff0000)|value<<16)
}
func (o *OCOTP_Type) GetHW_OCOTP_CTRL_SET_WR_UNLOCK() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_CTRL_SET.Reg) & 0xffff0000) >> 16
}

// OCOTP.HW_OCOTP_CTRL_CLR: OTP Controller Control Register
func (o *OCOTP_Type) SetHW_OCOTP_CTRL_CLR_ADDR(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_CTRL_CLR.Reg, volatile.LoadUint32(&o.HW_OCOTP_CTRL_CLR.Reg)&^(0x3f)|value)
}
func (o *OCOTP_Type) GetHW_OCOTP_CTRL_CLR_ADDR() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_CTRL_CLR.Reg) & 0x3f
}
func (o *OCOTP_Type) SetHW_OCOTP_CTRL_CLR_BUSY(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_CTRL_CLR.Reg, volatile.LoadUint32(&o.HW_OCOTP_CTRL_CLR.Reg)&^(0x100)|value<<8)
}
func (o *OCOTP_Type) GetHW_OCOTP_CTRL_CLR_BUSY() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_CTRL_CLR.Reg) & 0x100) >> 8
}
func (o *OCOTP_Type) SetHW_OCOTP_CTRL_CLR_ERROR(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_CTRL_CLR.Reg, volatile.LoadUint32(&o.HW_OCOTP_CTRL_CLR.Reg)&^(0x200)|value<<9)
}
func (o *OCOTP_Type) GetHW_OCOTP_CTRL_CLR_ERROR() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_CTRL_CLR.Reg) & 0x200) >> 9
}
func (o *OCOTP_Type) SetHW_OCOTP_CTRL_CLR_RELOAD_SHADOWS(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_CTRL_CLR.Reg, volatile.LoadUint32(&o.HW_OCOTP_CTRL_CLR.Reg)&^(0x400)|value<<10)
}
func (o *OCOTP_Type) GetHW_OCOTP_CTRL_CLR_RELOAD_SHADOWS() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_CTRL_CLR.Reg) & 0x400) >> 10
}
func (o *OCOTP_Type) SetHW_OCOTP_CTRL_CLR_WR_UNLOCK(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_CTRL_CLR.Reg, volatile.LoadUint32(&o.HW_OCOTP_CTRL_CLR.Reg)&^(0xffff0000)|value<<16)
}
func (o *OCOTP_Type) GetHW_OCOTP_CTRL_CLR_WR_UNLOCK() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_CTRL_CLR.Reg) & 0xffff0000) >> 16
}

// OCOTP.HW_OCOTP_CTRL_TOG: OTP Controller Control Register
func (o *OCOTP_Type) SetHW_OCOTP_CTRL_TOG_ADDR(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_CTRL_TOG.Reg, volatile.LoadUint32(&o.HW_OCOTP_CTRL_TOG.Reg)&^(0x3f)|value)
}
func (o *OCOTP_Type) GetHW_OCOTP_CTRL_TOG_ADDR() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_CTRL_TOG.Reg) & 0x3f
}
func (o *OCOTP_Type) SetHW_OCOTP_CTRL_TOG_BUSY(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_CTRL_TOG.Reg, volatile.LoadUint32(&o.HW_OCOTP_CTRL_TOG.Reg)&^(0x100)|value<<8)
}
func (o *OCOTP_Type) GetHW_OCOTP_CTRL_TOG_BUSY() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_CTRL_TOG.Reg) & 0x100) >> 8
}
func (o *OCOTP_Type) SetHW_OCOTP_CTRL_TOG_ERROR(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_CTRL_TOG.Reg, volatile.LoadUint32(&o.HW_OCOTP_CTRL_TOG.Reg)&^(0x200)|value<<9)
}
func (o *OCOTP_Type) GetHW_OCOTP_CTRL_TOG_ERROR() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_CTRL_TOG.Reg) & 0x200) >> 9
}
func (o *OCOTP_Type) SetHW_OCOTP_CTRL_TOG_RELOAD_SHADOWS(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_CTRL_TOG.Reg, volatile.LoadUint32(&o.HW_OCOTP_CTRL_TOG.Reg)&^(0x400)|value<<10)
}
func (o *OCOTP_Type) GetHW_OCOTP_CTRL_TOG_RELOAD_SHADOWS() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_CTRL_TOG.Reg) & 0x400) >> 10
}
func (o *OCOTP_Type) SetHW_OCOTP_CTRL_TOG_WR_UNLOCK(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_CTRL_TOG.Reg, volatile.LoadUint32(&o.HW_OCOTP_CTRL_TOG.Reg)&^(0xffff0000)|value<<16)
}
func (o *OCOTP_Type) GetHW_OCOTP_CTRL_TOG_WR_UNLOCK() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_CTRL_TOG.Reg) & 0xffff0000) >> 16
}

// OCOTP.HW_OCOTP_TIMING: OTP Controller Timing Register
func (o *OCOTP_Type) SetHW_OCOTP_TIMING_STROBE_PROG(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_TIMING.Reg, volatile.LoadUint32(&o.HW_OCOTP_TIMING.Reg)&^(0xfff)|value)
}
func (o *OCOTP_Type) GetHW_OCOTP_TIMING_STROBE_PROG() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_TIMING.Reg) & 0xfff
}
func (o *OCOTP_Type) SetHW_OCOTP_TIMING_RELAX(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_TIMING.Reg, volatile.LoadUint32(&o.HW_OCOTP_TIMING.Reg)&^(0xf000)|value<<12)
}
func (o *OCOTP_Type) GetHW_OCOTP_TIMING_RELAX() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_TIMING.Reg) & 0xf000) >> 12
}
func (o *OCOTP_Type) SetHW_OCOTP_TIMING_STROBE_READ(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_TIMING.Reg, volatile.LoadUint32(&o.HW_OCOTP_TIMING.Reg)&^(0x3f0000)|value<<16)
}
func (o *OCOTP_Type) GetHW_OCOTP_TIMING_STROBE_READ() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_TIMING.Reg) & 0x3f0000) >> 16
}
func (o *OCOTP_Type) SetHW_OCOTP_TIMING_WAIT(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_TIMING.Reg, volatile.LoadUint32(&o.HW_OCOTP_TIMING.Reg)&^(0xfc00000)|value<<22)
}
func (o *OCOTP_Type) GetHW_OCOTP_TIMING_WAIT() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_TIMING.Reg) & 0xfc00000) >> 22
}

// OCOTP.HW_OCOTP_DATA: OTP Controller Write Data Register
func (o *OCOTP_Type) SetHW_OCOTP_DATA(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_DATA.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_DATA() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_DATA.Reg)
}

// OCOTP.HW_OCOTP_READ_CTRL: OTP Controller Write Data Register
func (o *OCOTP_Type) SetHW_OCOTP_READ_CTRL_READ_FUSE(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_READ_CTRL.Reg, volatile.LoadUint32(&o.HW_OCOTP_READ_CTRL.Reg)&^(0x1)|value)
}
func (o *OCOTP_Type) GetHW_OCOTP_READ_CTRL_READ_FUSE() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_READ_CTRL.Reg) & 0x1
}

// OCOTP.HW_OCOTP_READ_FUSE_DATA: OTP Controller Read Data Register
func (o *OCOTP_Type) SetHW_OCOTP_READ_FUSE_DATA(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_READ_FUSE_DATA.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_READ_FUSE_DATA() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_READ_FUSE_DATA.Reg)
}

// OCOTP.HW_OCOTP_SW_STICKY: Sticky bit Register
func (o *OCOTP_Type) SetHW_OCOTP_SW_STICKY_SRK_REVOKE_LOCK(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SW_STICKY.Reg, volatile.LoadUint32(&o.HW_OCOTP_SW_STICKY.Reg)&^(0x2)|value<<1)
}
func (o *OCOTP_Type) GetHW_OCOTP_SW_STICKY_SRK_REVOKE_LOCK() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_SW_STICKY.Reg) & 0x2) >> 1
}
func (o *OCOTP_Type) SetHW_OCOTP_SW_STICKY_FIELD_RETURN_LOCK(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SW_STICKY.Reg, volatile.LoadUint32(&o.HW_OCOTP_SW_STICKY.Reg)&^(0x4)|value<<2)
}
func (o *OCOTP_Type) GetHW_OCOTP_SW_STICKY_FIELD_RETURN_LOCK() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_SW_STICKY.Reg) & 0x4) >> 2
}

// OCOTP.HW_OCOTP_SCS: Software Controllable Signals Register
func (o *OCOTP_Type) SetHW_OCOTP_SCS_HAB_JDE(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SCS.Reg, volatile.LoadUint32(&o.HW_OCOTP_SCS.Reg)&^(0x1)|value)
}
func (o *OCOTP_Type) GetHW_OCOTP_SCS_HAB_JDE() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_SCS.Reg) & 0x1
}
func (o *OCOTP_Type) SetHW_OCOTP_SCS_SPARE(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SCS.Reg, volatile.LoadUint32(&o.HW_OCOTP_SCS.Reg)&^(0x7ffffffe)|value<<1)
}
func (o *OCOTP_Type) GetHW_OCOTP_SCS_SPARE() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_SCS.Reg) & 0x7ffffffe) >> 1
}
func (o *OCOTP_Type) SetHW_OCOTP_SCS_LOCK(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SCS.Reg, volatile.LoadUint32(&o.HW_OCOTP_SCS.Reg)&^(0x80000000)|value<<31)
}
func (o *OCOTP_Type) GetHW_OCOTP_SCS_LOCK() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_SCS.Reg) & 0x80000000) >> 31
}

// OCOTP.HW_OCOTP_SCS_SET: Software Controllable Signals Register
func (o *OCOTP_Type) SetHW_OCOTP_SCS_SET_HAB_JDE(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SCS_SET.Reg, volatile.LoadUint32(&o.HW_OCOTP_SCS_SET.Reg)&^(0x1)|value)
}
func (o *OCOTP_Type) GetHW_OCOTP_SCS_SET_HAB_JDE() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_SCS_SET.Reg) & 0x1
}
func (o *OCOTP_Type) SetHW_OCOTP_SCS_SET_SPARE(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SCS_SET.Reg, volatile.LoadUint32(&o.HW_OCOTP_SCS_SET.Reg)&^(0x7ffffffe)|value<<1)
}
func (o *OCOTP_Type) GetHW_OCOTP_SCS_SET_SPARE() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_SCS_SET.Reg) & 0x7ffffffe) >> 1
}
func (o *OCOTP_Type) SetHW_OCOTP_SCS_SET_LOCK(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SCS_SET.Reg, volatile.LoadUint32(&o.HW_OCOTP_SCS_SET.Reg)&^(0x80000000)|value<<31)
}
func (o *OCOTP_Type) GetHW_OCOTP_SCS_SET_LOCK() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_SCS_SET.Reg) & 0x80000000) >> 31
}

// OCOTP.HW_OCOTP_SCS_CLR: Software Controllable Signals Register
func (o *OCOTP_Type) SetHW_OCOTP_SCS_CLR_HAB_JDE(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SCS_CLR.Reg, volatile.LoadUint32(&o.HW_OCOTP_SCS_CLR.Reg)&^(0x1)|value)
}
func (o *OCOTP_Type) GetHW_OCOTP_SCS_CLR_HAB_JDE() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_SCS_CLR.Reg) & 0x1
}
func (o *OCOTP_Type) SetHW_OCOTP_SCS_CLR_SPARE(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SCS_CLR.Reg, volatile.LoadUint32(&o.HW_OCOTP_SCS_CLR.Reg)&^(0x7ffffffe)|value<<1)
}
func (o *OCOTP_Type) GetHW_OCOTP_SCS_CLR_SPARE() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_SCS_CLR.Reg) & 0x7ffffffe) >> 1
}
func (o *OCOTP_Type) SetHW_OCOTP_SCS_CLR_LOCK(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SCS_CLR.Reg, volatile.LoadUint32(&o.HW_OCOTP_SCS_CLR.Reg)&^(0x80000000)|value<<31)
}
func (o *OCOTP_Type) GetHW_OCOTP_SCS_CLR_LOCK() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_SCS_CLR.Reg) & 0x80000000) >> 31
}

// OCOTP.HW_OCOTP_SCS_TOG: Software Controllable Signals Register
func (o *OCOTP_Type) SetHW_OCOTP_SCS_TOG_HAB_JDE(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SCS_TOG.Reg, volatile.LoadUint32(&o.HW_OCOTP_SCS_TOG.Reg)&^(0x1)|value)
}
func (o *OCOTP_Type) GetHW_OCOTP_SCS_TOG_HAB_JDE() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_SCS_TOG.Reg) & 0x1
}
func (o *OCOTP_Type) SetHW_OCOTP_SCS_TOG_SPARE(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SCS_TOG.Reg, volatile.LoadUint32(&o.HW_OCOTP_SCS_TOG.Reg)&^(0x7ffffffe)|value<<1)
}
func (o *OCOTP_Type) GetHW_OCOTP_SCS_TOG_SPARE() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_SCS_TOG.Reg) & 0x7ffffffe) >> 1
}
func (o *OCOTP_Type) SetHW_OCOTP_SCS_TOG_LOCK(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SCS_TOG.Reg, volatile.LoadUint32(&o.HW_OCOTP_SCS_TOG.Reg)&^(0x80000000)|value<<31)
}
func (o *OCOTP_Type) GetHW_OCOTP_SCS_TOG_LOCK() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_SCS_TOG.Reg) & 0x80000000) >> 31
}

// OCOTP.HW_OCOTP_VERSION: OTP Controller Version Register
func (o *OCOTP_Type) SetHW_OCOTP_VERSION_STEP(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_VERSION.Reg, volatile.LoadUint32(&o.HW_OCOTP_VERSION.Reg)&^(0xffff)|value)
}
func (o *OCOTP_Type) GetHW_OCOTP_VERSION_STEP() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_VERSION.Reg) & 0xffff
}
func (o *OCOTP_Type) SetHW_OCOTP_VERSION_MINOR(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_VERSION.Reg, volatile.LoadUint32(&o.HW_OCOTP_VERSION.Reg)&^(0xff0000)|value<<16)
}
func (o *OCOTP_Type) GetHW_OCOTP_VERSION_MINOR() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_VERSION.Reg) & 0xff0000) >> 16
}
func (o *OCOTP_Type) SetHW_OCOTP_VERSION_MAJOR(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_VERSION.Reg, volatile.LoadUint32(&o.HW_OCOTP_VERSION.Reg)&^(0xff000000)|value<<24)
}
func (o *OCOTP_Type) GetHW_OCOTP_VERSION_MAJOR() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_VERSION.Reg) & 0xff000000) >> 24
}

// OCOTP.HW_OCOTP_TIMING2: OTP Controller Timing Register 2
func (o *OCOTP_Type) SetHW_OCOTP_TIMING2_RELAX_PROG(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_TIMING2.Reg, volatile.LoadUint32(&o.HW_OCOTP_TIMING2.Reg)&^(0xfff)|value)
}
func (o *OCOTP_Type) GetHW_OCOTP_TIMING2_RELAX_PROG() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_TIMING2.Reg) & 0xfff
}
func (o *OCOTP_Type) SetHW_OCOTP_TIMING2_RELAX_READ(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_TIMING2.Reg, volatile.LoadUint32(&o.HW_OCOTP_TIMING2.Reg)&^(0x3f0000)|value<<16)
}
func (o *OCOTP_Type) GetHW_OCOTP_TIMING2_RELAX_READ() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_TIMING2.Reg) & 0x3f0000) >> 16
}
func (o *OCOTP_Type) SetHW_OCOTP_TIMING2_RELAX1(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_TIMING2.Reg, volatile.LoadUint32(&o.HW_OCOTP_TIMING2.Reg)&^(0x3fc00000)|value<<22)
}
func (o *OCOTP_Type) GetHW_OCOTP_TIMING2_RELAX1() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_TIMING2.Reg) & 0x3fc00000) >> 22
}

// OCOTP.HW_OCOTP_LOCK: Value of OTP Bank0 Word0 (Lock controls)
func (o *OCOTP_Type) SetHW_OCOTP_LOCK_TESTER(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_LOCK.Reg, volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg)&^(0x3)|value)
}
func (o *OCOTP_Type) GetHW_OCOTP_LOCK_TESTER() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg) & 0x3
}
func (o *OCOTP_Type) SetHW_OCOTP_LOCK_BOOT_CFG(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_LOCK.Reg, volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg)&^(0xc)|value<<2)
}
func (o *OCOTP_Type) GetHW_OCOTP_LOCK_BOOT_CFG() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg) & 0xc) >> 2
}
func (o *OCOTP_Type) SetHW_OCOTP_LOCK_MEM_TRIM(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_LOCK.Reg, volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg)&^(0x30)|value<<4)
}
func (o *OCOTP_Type) GetHW_OCOTP_LOCK_MEM_TRIM() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg) & 0x30) >> 4
}
func (o *OCOTP_Type) SetHW_OCOTP_LOCK_SJC_RESP(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_LOCK.Reg, volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg)&^(0x40)|value<<6)
}
func (o *OCOTP_Type) GetHW_OCOTP_LOCK_SJC_RESP() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg) & 0x40) >> 6
}
func (o *OCOTP_Type) SetHW_OCOTP_LOCK_MAC_ADDR(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_LOCK.Reg, volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg)&^(0x300)|value<<8)
}
func (o *OCOTP_Type) GetHW_OCOTP_LOCK_MAC_ADDR() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg) & 0x300) >> 8
}
func (o *OCOTP_Type) SetHW_OCOTP_LOCK_GP1(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_LOCK.Reg, volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg)&^(0xc00)|value<<10)
}
func (o *OCOTP_Type) GetHW_OCOTP_LOCK_GP1() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg) & 0xc00) >> 10
}
func (o *OCOTP_Type) SetHW_OCOTP_LOCK_GP2(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_LOCK.Reg, volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg)&^(0x3000)|value<<12)
}
func (o *OCOTP_Type) GetHW_OCOTP_LOCK_GP2() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg) & 0x3000) >> 12
}
func (o *OCOTP_Type) SetHW_OCOTP_LOCK_OTPMK_MSB(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_LOCK.Reg, volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg)&^(0x8000)|value<<15)
}
func (o *OCOTP_Type) GetHW_OCOTP_LOCK_OTPMK_MSB() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg) & 0x8000) >> 15
}
func (o *OCOTP_Type) SetHW_OCOTP_LOCK_SW_GP1(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_LOCK.Reg, volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg)&^(0x10000)|value<<16)
}
func (o *OCOTP_Type) GetHW_OCOTP_LOCK_SW_GP1() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg) & 0x10000) >> 16
}
func (o *OCOTP_Type) SetHW_OCOTP_LOCK_OTPMK_LSB(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_LOCK.Reg, volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg)&^(0x20000)|value<<17)
}
func (o *OCOTP_Type) GetHW_OCOTP_LOCK_OTPMK_LSB() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg) & 0x20000) >> 17
}
func (o *OCOTP_Type) SetHW_OCOTP_LOCK_ANALOG(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_LOCK.Reg, volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg)&^(0xc0000)|value<<18)
}
func (o *OCOTP_Type) GetHW_OCOTP_LOCK_ANALOG() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg) & 0xc0000) >> 18
}
func (o *OCOTP_Type) SetHW_OCOTP_LOCK_OTPMK_CRC(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_LOCK.Reg, volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg)&^(0x100000)|value<<20)
}
func (o *OCOTP_Type) GetHW_OCOTP_LOCK_OTPMK_CRC() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg) & 0x100000) >> 20
}
func (o *OCOTP_Type) SetHW_OCOTP_LOCK_SW_GP2_LOCK(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_LOCK.Reg, volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg)&^(0x200000)|value<<21)
}
func (o *OCOTP_Type) GetHW_OCOTP_LOCK_SW_GP2_LOCK() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg) & 0x200000) >> 21
}
func (o *OCOTP_Type) SetHW_OCOTP_LOCK_MISC_CONF(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_LOCK.Reg, volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg)&^(0x400000)|value<<22)
}
func (o *OCOTP_Type) GetHW_OCOTP_LOCK_MISC_CONF() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg) & 0x400000) >> 22
}
func (o *OCOTP_Type) SetHW_OCOTP_LOCK_SW_GP2_RLOCK(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_LOCK.Reg, volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg)&^(0x800000)|value<<23)
}
func (o *OCOTP_Type) GetHW_OCOTP_LOCK_SW_GP2_RLOCK() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg) & 0x800000) >> 23
}
func (o *OCOTP_Type) SetHW_OCOTP_LOCK_GP3(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_LOCK.Reg, volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg)&^(0xc000000)|value<<26)
}
func (o *OCOTP_Type) GetHW_OCOTP_LOCK_GP3() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg) & 0xc000000) >> 26
}
func (o *OCOTP_Type) SetHW_OCOTP_LOCK_FIELD_RETURN(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_LOCK.Reg, volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg)&^(0xf0000000)|value<<28)
}
func (o *OCOTP_Type) GetHW_OCOTP_LOCK_FIELD_RETURN() uint32 {
	return (volatile.LoadUint32(&o.HW_OCOTP_LOCK.Reg) & 0xf0000000) >> 28
}

// OCOTP.HW_OCOTP_CFG0: Value of OTP Bank0 Word1 (Configuration and Manufacturing Info.)
func (o *OCOTP_Type) SetHW_OCOTP_CFG0(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_CFG0.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_CFG0() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_CFG0.Reg)
}

// OCOTP.HW_OCOTP_CFG1: Value of OTP Bank0 Word2 (Configuration and Manufacturing Info.)
func (o *OCOTP_Type) SetHW_OCOTP_CFG1(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_CFG1.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_CFG1() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_CFG1.Reg)
}

// OCOTP.HW_OCOTP_CFG2: Value of OTP Bank0 Word3 (Configuration and Manufacturing Info.)
func (o *OCOTP_Type) SetHW_OCOTP_CFG2(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_CFG2.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_CFG2() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_CFG2.Reg)
}

// OCOTP.HW_OCOTP_CFG3: Value of OTP Bank0 Word4 (Configuration and Manufacturing Info.)
func (o *OCOTP_Type) SetHW_OCOTP_CFG3(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_CFG3.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_CFG3() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_CFG3.Reg)
}

// OCOTP.HW_OCOTP_CFG4: Value of OTP Bank0 Word5 (Configuration and Manufacturing Info.)
func (o *OCOTP_Type) SetHW_OCOTP_CFG4(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_CFG4.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_CFG4() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_CFG4.Reg)
}

// OCOTP.HW_OCOTP_CFG5: Value of OTP Bank0 Word6 (Configuration and Manufacturing Info.)
func (o *OCOTP_Type) SetHW_OCOTP_CFG5(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_CFG5.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_CFG5() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_CFG5.Reg)
}

// OCOTP.HW_OCOTP_CFG6: Value of OTP Bank0 Word7 (Configuration and Manufacturing Info.)
func (o *OCOTP_Type) SetHW_OCOTP_CFG6(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_CFG6.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_CFG6() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_CFG6.Reg)
}

// OCOTP.HW_OCOTP_MEM0: Value of OTP Bank1 Word0 (Memory Related Info.)
func (o *OCOTP_Type) SetHW_OCOTP_MEM0(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_MEM0.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_MEM0() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_MEM0.Reg)
}

// OCOTP.HW_OCOTP_MEM1: Value of OTP Bank1 Word1 (Memory Related Info.)
func (o *OCOTP_Type) SetHW_OCOTP_MEM1(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_MEM1.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_MEM1() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_MEM1.Reg)
}

// OCOTP.HW_OCOTP_MEM2: Value of OTP Bank1 Word2 (Memory Related Info.)
func (o *OCOTP_Type) SetHW_OCOTP_MEM2(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_MEM2.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_MEM2() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_MEM2.Reg)
}

// OCOTP.HW_OCOTP_MEM3: Value of OTP Bank1 Word3 (Memory Related Info.)
func (o *OCOTP_Type) SetHW_OCOTP_MEM3(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_MEM3.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_MEM3() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_MEM3.Reg)
}

// OCOTP.HW_OCOTP_MEM4: Value of OTP Bank1 Word4 (Memory Related Info.)
func (o *OCOTP_Type) SetHW_OCOTP_MEM4(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_MEM4.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_MEM4() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_MEM4.Reg)
}

// OCOTP.HW_OCOTP_ANA0: Value of OTP Bank1 Word5 (Analog Info.)
func (o *OCOTP_Type) SetHW_OCOTP_ANA0(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_ANA0.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_ANA0() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_ANA0.Reg)
}

// OCOTP.HW_OCOTP_ANA1: Value of OTP Bank1 Word6 (Analog Info.)
func (o *OCOTP_Type) SetHW_OCOTP_ANA1(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_ANA1.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_ANA1() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_ANA1.Reg)
}

// OCOTP.HW_OCOTP_ANA2: Value of OTP Bank1 Word7 (Analog Info.)
func (o *OCOTP_Type) SetHW_OCOTP_ANA2(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_ANA2.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_ANA2() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_ANA2.Reg)
}

// OCOTP.HW_OCOTP_SRK0: Shadow Register for OTP Bank3 Word0 (SRK Hash)
func (o *OCOTP_Type) SetHW_OCOTP_SRK0(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SRK0.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_SRK0() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_SRK0.Reg)
}

// OCOTP.HW_OCOTP_SRK1: Shadow Register for OTP Bank3 Word1 (SRK Hash)
func (o *OCOTP_Type) SetHW_OCOTP_SRK1(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SRK1.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_SRK1() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_SRK1.Reg)
}

// OCOTP.HW_OCOTP_SRK2: Shadow Register for OTP Bank3 Word2 (SRK Hash)
func (o *OCOTP_Type) SetHW_OCOTP_SRK2(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SRK2.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_SRK2() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_SRK2.Reg)
}

// OCOTP.HW_OCOTP_SRK3: Shadow Register for OTP Bank3 Word3 (SRK Hash)
func (o *OCOTP_Type) SetHW_OCOTP_SRK3(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SRK3.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_SRK3() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_SRK3.Reg)
}

// OCOTP.HW_OCOTP_SRK4: Shadow Register for OTP Bank3 Word4 (SRK Hash)
func (o *OCOTP_Type) SetHW_OCOTP_SRK4(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SRK4.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_SRK4() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_SRK4.Reg)
}

// OCOTP.HW_OCOTP_SRK5: Shadow Register for OTP Bank3 Word5 (SRK Hash)
func (o *OCOTP_Type) SetHW_OCOTP_SRK5(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SRK5.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_SRK5() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_SRK5.Reg)
}

// OCOTP.HW_OCOTP_SRK6: Shadow Register for OTP Bank3 Word6 (SRK Hash)
func (o *OCOTP_Type) SetHW_OCOTP_SRK6(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SRK6.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_SRK6() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_SRK6.Reg)
}

// OCOTP.HW_OCOTP_SRK7: Shadow Register for OTP Bank3 Word7 (SRK Hash)
func (o *OCOTP_Type) SetHW_OCOTP_SRK7(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SRK7.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_SRK7() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_SRK7.Reg)
}

// OCOTP.HW_OCOTP_SJC_RESP0: Value of OTP Bank4 Word0 (Secure JTAG Response Field)
func (o *OCOTP_Type) SetHW_OCOTP_SJC_RESP0(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SJC_RESP0.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_SJC_RESP0() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_SJC_RESP0.Reg)
}

// OCOTP.HW_OCOTP_SJC_RESP1: Value of OTP Bank4 Word1 (Secure JTAG Response Field)
func (o *OCOTP_Type) SetHW_OCOTP_SJC_RESP1(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SJC_RESP1.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_SJC_RESP1() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_SJC_RESP1.Reg)
}

// OCOTP.HW_OCOTP_MAC0: Value of OTP Bank4 Word2 (MAC Address)
func (o *OCOTP_Type) SetHW_OCOTP_MAC0(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_MAC0.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_MAC0() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_MAC0.Reg)
}

// OCOTP.HW_OCOTP_MAC1: Value of OTP Bank4 Word3 (MAC Address)
func (o *OCOTP_Type) SetHW_OCOTP_MAC1(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_MAC1.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_MAC1() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_MAC1.Reg)
}

// OCOTP.HW_OCOTP_GP3: Value of OTP Bank4 Word4 (MAC Address)
func (o *OCOTP_Type) SetHW_OCOTP_GP3(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_GP3.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_GP3() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_GP3.Reg)
}

// OCOTP.HW_OCOTP_GP1: Value of OTP Bank4 Word6 (General Purpose Customer Defined Info)
func (o *OCOTP_Type) SetHW_OCOTP_GP1(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_GP1.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_GP1() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_GP1.Reg)
}

// OCOTP.HW_OCOTP_GP2: Value of OTP Bank4 Word7 (General Purpose Customer Defined Info)
func (o *OCOTP_Type) SetHW_OCOTP_GP2(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_GP2.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_GP2() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_GP2.Reg)
}

// OCOTP.HW_OCOTP_SW_GP1: Value of OTP Bank5 Word0 (SW GP1)
func (o *OCOTP_Type) SetHW_OCOTP_SW_GP1(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SW_GP1.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_SW_GP1() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_SW_GP1.Reg)
}

// OCOTP.HW_OCOTP_SW_GP20: Value of OTP Bank5 Word1 (SW GP2)
func (o *OCOTP_Type) SetHW_OCOTP_SW_GP20(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SW_GP20.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_SW_GP20() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_SW_GP20.Reg)
}

// OCOTP.HW_OCOTP_SW_GP21: Value of OTP Bank5 Word2 (SW GP2)
func (o *OCOTP_Type) SetHW_OCOTP_SW_GP21(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SW_GP21.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_SW_GP21() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_SW_GP21.Reg)
}

// OCOTP.HW_OCOTP_SW_GP22: Value of OTP Bank5 Word3 (SW GP2)
func (o *OCOTP_Type) SetHW_OCOTP_SW_GP22(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SW_GP22.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_SW_GP22() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_SW_GP22.Reg)
}

// OCOTP.HW_OCOTP_SW_GP23: Value of OTP Bank5 Word4 (SW GP2)
func (o *OCOTP_Type) SetHW_OCOTP_SW_GP23(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SW_GP23.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_SW_GP23() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_SW_GP23.Reg)
}

// OCOTP.HW_OCOTP_MISC_CONF0: Value of OTP Bank5 Word5 (Misc Conf)
func (o *OCOTP_Type) SetHW_OCOTP_MISC_CONF0(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_MISC_CONF0.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_MISC_CONF0() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_MISC_CONF0.Reg)
}

// OCOTP.HW_OCOTP_MISC_CONF1: Value of OTP Bank5 Word6 (Misc Conf)
func (o *OCOTP_Type) SetHW_OCOTP_MISC_CONF1(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_MISC_CONF1.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_MISC_CONF1() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_MISC_CONF1.Reg)
}

// OCOTP.HW_OCOTP_SRK_REVOKE: Value of OTP Bank5 Word7 (SRK Revoke)
func (o *OCOTP_Type) SetHW_OCOTP_SRK_REVOKE(value uint32) {
	volatile.StoreUint32(&o.HW_OCOTP_SRK_REVOKE.Reg, value)
}
func (o *OCOTP_Type) GetHW_OCOTP_SRK_REVOKE() uint32 {
	return volatile.LoadUint32(&o.HW_OCOTP_SRK_REVOKE.Reg)
}

// IOMUXC
type IOMUXC_Type struct {
	_                            [16]byte
	SW_MUX_CTL_PAD_GPIO_AD_14    volatile.Register32 // 0x10
	SW_MUX_CTL_PAD_GPIO_AD_13    volatile.Register32 // 0x14
	SW_MUX_CTL_PAD_GPIO_AD_12    volatile.Register32 // 0x18
	SW_MUX_CTL_PAD_GPIO_AD_11    volatile.Register32 // 0x1C
	SW_MUX_CTL_PAD_GPIO_AD_10    volatile.Register32 // 0x20
	SW_MUX_CTL_PAD_GPIO_AD_09    volatile.Register32 // 0x24
	SW_MUX_CTL_PAD_GPIO_AD_08    volatile.Register32 // 0x28
	SW_MUX_CTL_PAD_GPIO_AD_07    volatile.Register32 // 0x2C
	SW_MUX_CTL_PAD_GPIO_AD_06    volatile.Register32 // 0x30
	SW_MUX_CTL_PAD_GPIO_AD_05    volatile.Register32 // 0x34
	SW_MUX_CTL_PAD_GPIO_AD_04    volatile.Register32 // 0x38
	SW_MUX_CTL_PAD_GPIO_AD_03    volatile.Register32 // 0x3C
	SW_MUX_CTL_PAD_GPIO_AD_02    volatile.Register32 // 0x40
	SW_MUX_CTL_PAD_GPIO_AD_01    volatile.Register32 // 0x44
	SW_MUX_CTL_PAD_GPIO_AD_00    volatile.Register32 // 0x48
	SW_MUX_CTL_PAD_GPIO_SD_14    volatile.Register32 // 0x4C
	SW_MUX_CTL_PAD_GPIO_SD_13    volatile.Register32 // 0x50
	SW_MUX_CTL_PAD_GPIO_SD_12    volatile.Register32 // 0x54
	SW_MUX_CTL_PAD_GPIO_SD_11    volatile.Register32 // 0x58
	SW_MUX_CTL_PAD_GPIO_SD_10    volatile.Register32 // 0x5C
	SW_MUX_CTL_PAD_GPIO_SD_09    volatile.Register32 // 0x60
	SW_MUX_CTL_PAD_GPIO_SD_08    volatile.Register32 // 0x64
	SW_MUX_CTL_PAD_GPIO_SD_07    volatile.Register32 // 0x68
	SW_MUX_CTL_PAD_GPIO_SD_06    volatile.Register32 // 0x6C
	SW_MUX_CTL_PAD_GPIO_SD_05    volatile.Register32 // 0x70
	SW_MUX_CTL_PAD_GPIO_SD_04    volatile.Register32 // 0x74
	SW_MUX_CTL_PAD_GPIO_SD_03    volatile.Register32 // 0x78
	SW_MUX_CTL_PAD_GPIO_SD_02    volatile.Register32 // 0x7C
	SW_MUX_CTL_PAD_GPIO_SD_01    volatile.Register32 // 0x80
	SW_MUX_CTL_PAD_GPIO_SD_00    volatile.Register32 // 0x84
	SW_MUX_CTL_PAD_GPIO_13       volatile.Register32 // 0x88
	SW_MUX_CTL_PAD_GPIO_12       volatile.Register32 // 0x8C
	SW_MUX_CTL_PAD_GPIO_11       volatile.Register32 // 0x90
	SW_MUX_CTL_PAD_GPIO_10       volatile.Register32 // 0x94
	SW_MUX_CTL_PAD_GPIO_09       volatile.Register32 // 0x98
	SW_MUX_CTL_PAD_GPIO_08       volatile.Register32 // 0x9C
	SW_MUX_CTL_PAD_GPIO_07       volatile.Register32 // 0xA0
	SW_MUX_CTL_PAD_GPIO_06       volatile.Register32 // 0xA4
	SW_MUX_CTL_PAD_GPIO_05       volatile.Register32 // 0xA8
	SW_MUX_CTL_PAD_GPIO_04       volatile.Register32 // 0xAC
	SW_MUX_CTL_PAD_GPIO_03       volatile.Register32 // 0xB0
	SW_MUX_CTL_PAD_GPIO_02       volatile.Register32 // 0xB4
	SW_MUX_CTL_PAD_GPIO_01       volatile.Register32 // 0xB8
	SW_MUX_CTL_PAD_GPIO_00       volatile.Register32 // 0xBC
	SW_PAD_CTL_PAD_GPIO_AD_14    volatile.Register32 // 0xC0
	SW_PAD_CTL_PAD_GPIO_AD_13    volatile.Register32 // 0xC4
	SW_PAD_CTL_PAD_GPIO_AD_12    volatile.Register32 // 0xC8
	SW_PAD_CTL_PAD_GPIO_AD_11    volatile.Register32 // 0xCC
	SW_PAD_CTL_PAD_GPIO_AD_10    volatile.Register32 // 0xD0
	SW_PAD_CTL_PAD_GPIO_AD_09    volatile.Register32 // 0xD4
	SW_PAD_CTL_PAD_GPIO_AD_08    volatile.Register32 // 0xD8
	SW_PAD_CTL_PAD_GPIO_AD_07    volatile.Register32 // 0xDC
	SW_PAD_CTL_PAD_GPIO_AD_06    volatile.Register32 // 0xE0
	SW_PAD_CTL_PAD_GPIO_AD_05    volatile.Register32 // 0xE4
	SW_PAD_CTL_PAD_GPIO_AD_04    volatile.Register32 // 0xE8
	SW_PAD_CTL_PAD_GPIO_AD_03    volatile.Register32 // 0xEC
	SW_PAD_CTL_PAD_GPIO_AD_02    volatile.Register32 // 0xF0
	SW_PAD_CTL_PAD_GPIO_AD_01    volatile.Register32 // 0xF4
	SW_PAD_CTL_PAD_GPIO_AD_00    volatile.Register32 // 0xF8
	SW_PAD_CTL_PAD_GPIO_SD_14    volatile.Register32 // 0xFC
	SW_PAD_CTL_PAD_GPIO_SD_13    volatile.Register32 // 0x100
	SW_PAD_CTL_PAD_GPIO_SD_12    volatile.Register32 // 0x104
	SW_PAD_CTL_PAD_GPIO_SD_11    volatile.Register32 // 0x108
	SW_PAD_CTL_PAD_GPIO_SD_10    volatile.Register32 // 0x10C
	SW_PAD_CTL_PAD_GPIO_SD_09    volatile.Register32 // 0x110
	SW_PAD_CTL_PAD_GPIO_SD_08    volatile.Register32 // 0x114
	SW_PAD_CTL_PAD_GPIO_SD_07    volatile.Register32 // 0x118
	SW_PAD_CTL_PAD_GPIO_SD_06    volatile.Register32 // 0x11C
	SW_PAD_CTL_PAD_GPIO_SD_05    volatile.Register32 // 0x120
	SW_PAD_CTL_PAD_GPIO_SD_04    volatile.Register32 // 0x124
	SW_PAD_CTL_PAD_GPIO_SD_03    volatile.Register32 // 0x128
	SW_PAD_CTL_PAD_GPIO_SD_02    volatile.Register32 // 0x12C
	SW_PAD_CTL_PAD_GPIO_SD_01    volatile.Register32 // 0x130
	SW_PAD_CTL_PAD_GPIO_SD_00    volatile.Register32 // 0x134
	SW_PAD_CTL_PAD_GPIO_13       volatile.Register32 // 0x138
	SW_PAD_CTL_PAD_GPIO_12       volatile.Register32 // 0x13C
	SW_PAD_CTL_PAD_GPIO_11       volatile.Register32 // 0x140
	SW_PAD_CTL_PAD_GPIO_10       volatile.Register32 // 0x144
	SW_PAD_CTL_PAD_GPIO_09       volatile.Register32 // 0x148
	SW_PAD_CTL_PAD_GPIO_08       volatile.Register32 // 0x14C
	SW_PAD_CTL_PAD_GPIO_07       volatile.Register32 // 0x150
	SW_PAD_CTL_PAD_GPIO_06       volatile.Register32 // 0x154
	SW_PAD_CTL_PAD_GPIO_05       volatile.Register32 // 0x158
	SW_PAD_CTL_PAD_GPIO_04       volatile.Register32 // 0x15C
	SW_PAD_CTL_PAD_GPIO_03       volatile.Register32 // 0x160
	SW_PAD_CTL_PAD_GPIO_02       volatile.Register32 // 0x164
	SW_PAD_CTL_PAD_GPIO_01       volatile.Register32 // 0x168
	SW_PAD_CTL_PAD_GPIO_00       volatile.Register32 // 0x16C
	USB_OTG_ID_SELECT_INPUT      volatile.Register32 // 0x170
	FLEXPWM1_PWMA_SELECT_INPUT_0 volatile.Register32 // 0x174
	FLEXPWM1_PWMA_SELECT_INPUT_1 volatile.Register32 // 0x178
	FLEXPWM1_PWMA_SELECT_INPUT_2 volatile.Register32 // 0x17C
	FLEXPWM1_PWMA_SELECT_INPUT_3 volatile.Register32 // 0x180
	FLEXPWM1_PWMB_SELECT_INPUT_0 volatile.Register32 // 0x184
	FLEXPWM1_PWMB_SELECT_INPUT_1 volatile.Register32 // 0x188
	FLEXPWM1_PWMB_SELECT_INPUT_2 volatile.Register32 // 0x18C
	FLEXPWM1_PWMB_SELECT_INPUT_3 volatile.Register32 // 0x190
	FLEXSPI_DQS_FA_SELECT_INPUT  volatile.Register32 // 0x194
	FLEXSPI_DQS_FB_SELECT_INPUT  volatile.Register32 // 0x198
	KPP_COL_SELECT_INPUT_0       volatile.Register32 // 0x19C
	KPP_COL_SELECT_INPUT_1       volatile.Register32 // 0x1A0
	KPP_COL_SELECT_INPUT_2       volatile.Register32 // 0x1A4
	KPP_COL_SELECT_INPUT_3       volatile.Register32 // 0x1A8
	KPP_ROW_SELECT_INPUT_0       volatile.Register32 // 0x1AC
	KPP_ROW_SELECT_INPUT_1       volatile.Register32 // 0x1B0
	KPP_ROW_SELECT_INPUT_2       volatile.Register32 // 0x1B4
	KPP_ROW_SELECT_INPUT_3       volatile.Register32 // 0x1B8
	LPI2C1_HREQ_SELECT_INPUT     volatile.Register32 // 0x1BC
	LPI2C1_SCL_SELECT_INPUT      volatile.Register32 // 0x1C0
	LPI2C1_SDA_SELECT_INPUT      volatile.Register32 // 0x1C4
	LPI2C2_SCL_SELECT_INPUT      volatile.Register32 // 0x1C8
	LPI2C2_SDA_SELECT_INPUT      volatile.Register32 // 0x1CC
	LPSPI1_PCS_SELECT_INPUT_0    volatile.Register32 // 0x1D0
	LPSPI1_SCK_SELECT_INPUT      volatile.Register32 // 0x1D4
	LPSPI1_SDI_SELECT_INPUT      volatile.Register32 // 0x1D8
	LPSPI1_SDO_SELECT_INPUT      volatile.Register32 // 0x1DC
	LPSPI2_PCS_SELECT_INPUT_0    volatile.Register32 // 0x1E0
	LPSPI2_SCK_SELECT_INPUT      volatile.Register32 // 0x1E4
	LPSPI2_SDI_SELECT_INPUT      volatile.Register32 // 0x1E8
	LPSPI2_SDO_SELECT_INPUT      volatile.Register32 // 0x1EC
	LPUART1_RXD_SELECT_INPUT     volatile.Register32 // 0x1F0
	LPUART1_TXD_SELECT_INPUT     volatile.Register32 // 0x1F4
	LPUART2_RXD_SELECT_INPUT     volatile.Register32 // 0x1F8
	LPUART2_TXD_SELECT_INPUT     volatile.Register32 // 0x1FC
	LPUART3_RXD_SELECT_INPUT     volatile.Register32 // 0x200
	LPUART3_TXD_SELECT_INPUT     volatile.Register32 // 0x204
	LPUART4_RXD_SELECT_INPUT     volatile.Register32 // 0x208
	LPUART4_TXD_SELECT_INPUT     volatile.Register32 // 0x20C
	NMI_GLUE_NMI_SELECT_INPUT    volatile.Register32 // 0x210
	SPDIF_IN1_SELECT_INPUT       volatile.Register32 // 0x214
	SPDIF_TX_CLK2_SELECT_INPUT   volatile.Register32 // 0x218
	USB_OTG_OC_SELECT_INPUT      volatile.Register32 // 0x21C
	XEV_GLUE_RXEV_SELECT_INPUT   volatile.Register32 // 0x220
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_AD_14: SW_MUX_CTL_PAD_GPIO_AD_14 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_14_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_14.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_14.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_14_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_14.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_14_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_14.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_14.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_14_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_14.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_AD_13: SW_MUX_CTL_PAD_GPIO_AD_13 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_13_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_13.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_13.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_13_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_13.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_13_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_13.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_13.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_13_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_13.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_AD_12: SW_MUX_CTL_PAD_GPIO_AD_12 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_12_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_12.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_12.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_12_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_12.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_12_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_12.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_12.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_12_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_12.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_AD_11: SW_MUX_CTL_PAD_GPIO_AD_11 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_11_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_11.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_11.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_11_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_11.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_11_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_11.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_11.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_11_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_11.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_AD_10: SW_MUX_CTL_PAD_GPIO_AD_10 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_10_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_10.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_10.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_10_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_10.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_10_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_10.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_10.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_10_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_10.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_AD_09: SW_MUX_CTL_PAD_GPIO_AD_09 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_09_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_09.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_09.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_09_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_09.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_09_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_09.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_09.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_09_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_09.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_AD_08: SW_MUX_CTL_PAD_GPIO_AD_08 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_08_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_08.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_08.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_08_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_08.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_08_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_08.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_08.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_08_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_08.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_AD_07: SW_MUX_CTL_PAD_GPIO_AD_07 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_07_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_07.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_07.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_07_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_07.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_07_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_07.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_07.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_07_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_07.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_AD_06: SW_MUX_CTL_PAD_GPIO_AD_06 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_06_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_06.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_06.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_06_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_06.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_06_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_06.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_06.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_06_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_06.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_AD_05: SW_MUX_CTL_PAD_GPIO_AD_05 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_05_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_05.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_05.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_05_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_05.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_05_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_05.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_05.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_05_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_05.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_AD_04: SW_MUX_CTL_PAD_GPIO_AD_04 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_04_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_04.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_04.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_04_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_04.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_04_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_04.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_04.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_04_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_04.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_AD_03: SW_MUX_CTL_PAD_GPIO_AD_03 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_03_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_03.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_03.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_03_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_03.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_03_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_03.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_03.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_03_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_03.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_AD_02: SW_MUX_CTL_PAD_GPIO_AD_02 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_02_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_02.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_02.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_02_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_02.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_02_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_02.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_02.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_02_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_02.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_AD_01: SW_MUX_CTL_PAD_GPIO_AD_01 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_01_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_01.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_01.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_01_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_01.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_01_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_01.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_01.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_01_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_01.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_AD_00: SW_MUX_CTL_PAD_GPIO_AD_00 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_00_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_00.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_00.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_00_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_00.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_AD_00_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_00.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_00.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_AD_00_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_AD_00.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_SD_14: SW_MUX_CTL_PAD_GPIO_SD_14 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_14_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_14.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_14.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_14_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_14.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_14_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_14.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_14.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_14_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_14.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_SD_13: SW_MUX_CTL_PAD_GPIO_SD_13 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_13_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_13.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_13.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_13_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_13.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_13_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_13.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_13.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_13_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_13.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_SD_12: SW_MUX_CTL_PAD_GPIO_SD_12 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_12_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_12.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_12.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_12_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_12.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_12_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_12.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_12.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_12_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_12.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_SD_11: SW_MUX_CTL_PAD_GPIO_SD_11 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_11_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_11.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_11.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_11_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_11.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_11_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_11.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_11.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_11_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_11.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_SD_10: SW_MUX_CTL_PAD_GPIO_SD_10 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_10_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_10.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_10.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_10_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_10.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_10_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_10.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_10.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_10_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_10.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_SD_09: SW_MUX_CTL_PAD_GPIO_SD_09 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_09_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_09.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_09.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_09_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_09.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_09_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_09.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_09.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_09_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_09.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_SD_08: SW_MUX_CTL_PAD_GPIO_SD_08 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_08_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_08.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_08.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_08_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_08.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_08_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_08.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_08.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_08_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_08.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_SD_07: SW_MUX_CTL_PAD_GPIO_SD_07 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_07_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_07.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_07.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_07_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_07.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_07_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_07.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_07.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_07_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_07.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_SD_06: SW_MUX_CTL_PAD_GPIO_SD_06 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_06_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_06.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_06.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_06_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_06.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_06_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_06.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_06.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_06_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_06.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_SD_05: SW_MUX_CTL_PAD_GPIO_SD_05 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_05_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_05.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_05.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_05_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_05.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_05_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_05.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_05.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_05_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_05.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_SD_04: SW_MUX_CTL_PAD_GPIO_SD_04 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_04_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_04.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_04.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_04_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_04.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_04_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_04.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_04.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_04_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_04.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_SD_03: SW_MUX_CTL_PAD_GPIO_SD_03 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_03_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_03.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_03.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_03_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_03.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_03_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_03.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_03.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_03_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_03.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_SD_02: SW_MUX_CTL_PAD_GPIO_SD_02 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_02_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_02.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_02.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_02_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_02.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_02_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_02.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_02.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_02_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_02.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_SD_01: SW_MUX_CTL_PAD_GPIO_SD_01 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_01_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_01.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_01.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_01_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_01.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_01_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_01.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_01.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_01_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_01.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_SD_00: SW_MUX_CTL_PAD_GPIO_SD_00 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_00_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_00.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_00.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_00_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_00.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_SD_00_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_00.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_00.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_SD_00_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_SD_00.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_13: SW_MUX_CTL_PAD_GPIO_13 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_13_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_13.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_13.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_13_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_13.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_13_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_13.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_13.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_13_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_13.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_12: SW_MUX_CTL_PAD_GPIO_12 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_12_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_12.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_12.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_12_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_12.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_12_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_12.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_12.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_12_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_12.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_11: SW_MUX_CTL_PAD_GPIO_11 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_11_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_11.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_11.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_11_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_11.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_11_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_11.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_11.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_11_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_11.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_10: SW_MUX_CTL_PAD_GPIO_10 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_10_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_10.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_10.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_10_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_10.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_10_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_10.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_10.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_10_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_10.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_09: SW_MUX_CTL_PAD_GPIO_09 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_09_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_09.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_09.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_09_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_09.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_09_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_09.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_09.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_09_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_09.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_08: SW_MUX_CTL_PAD_GPIO_08 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_08_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_08.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_08.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_08_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_08.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_08_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_08.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_08.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_08_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_08.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_07: SW_MUX_CTL_PAD_GPIO_07 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_07_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_07.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_07.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_07_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_07.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_07_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_07.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_07.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_07_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_07.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_06: SW_MUX_CTL_PAD_GPIO_06 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_06_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_06.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_06.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_06_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_06.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_06_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_06.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_06.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_06_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_06.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_05: SW_MUX_CTL_PAD_GPIO_05 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_05_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_05.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_05.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_05_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_05.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_05_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_05.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_05.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_05_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_05.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_04: SW_MUX_CTL_PAD_GPIO_04 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_04_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_04.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_04.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_04_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_04.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_04_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_04.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_04.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_04_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_04.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_03: SW_MUX_CTL_PAD_GPIO_03 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_03_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_03.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_03.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_03_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_03.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_03_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_03.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_03.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_03_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_03.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_02: SW_MUX_CTL_PAD_GPIO_02 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_02_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_02.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_02.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_02_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_02.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_02_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_02.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_02.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_02_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_02.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_01: SW_MUX_CTL_PAD_GPIO_01 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_01_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_01.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_01.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_01_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_01.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_01_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_01.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_01.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_01_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_01.Reg) & 0x10) >> 4
}

// IOMUXC.SW_MUX_CTL_PAD_GPIO_00: SW_MUX_CTL_PAD_GPIO_00 SW MUX Control Register
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_00_MUX_MODE(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_00.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_00.Reg)&^(0x7)|value)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_00_MUX_MODE() uint32 {
	return volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_00.Reg) & 0x7
}
func (o *IOMUXC_Type) SetSW_MUX_CTL_PAD_GPIO_00_SION(value uint32) {
	volatile.StoreUint32(&o.SW_MUX_CTL_PAD_GPIO_00.Reg, volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_00.Reg)&^(0x10)|value<<4)
}
func (o *IOMUXC_Type) GetSW_MUX_CTL_PAD_GPIO_00_SION() uint32 {
	return (volatile.LoadUint32(&o.SW_MUX_CTL_PAD_GPIO_00.Reg) & 0x10) >> 4
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_AD_14: SW_PAD_CTL_PAD_GPIO_AD_14 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_14_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_14.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_14.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_14_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_14.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_14_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_14.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_14.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_14_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_14.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_14_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_14.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_14.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_14_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_14.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_14_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_14.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_14.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_14_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_14.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_14_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_14.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_14.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_14_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_14.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_14_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_14.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_14.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_14_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_14.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_14_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_14.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_14.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_14_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_14.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_14_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_14.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_14.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_14_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_14.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_AD_13: SW_PAD_CTL_PAD_GPIO_AD_13 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_13_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_13.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_13.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_13_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_13.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_13_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_13.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_13.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_13_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_13.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_13_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_13.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_13.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_13_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_13.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_13_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_13.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_13.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_13_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_13.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_13_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_13.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_13.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_13_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_13.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_13_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_13.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_13.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_13_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_13.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_13_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_13.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_13.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_13_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_13.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_13_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_13.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_13.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_13_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_13.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_AD_12: SW_PAD_CTL_PAD_GPIO_AD_12 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_12_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_12.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_12.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_12_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_12.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_12_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_12.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_12.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_12_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_12.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_12_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_12.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_12.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_12_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_12.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_12_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_12.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_12.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_12_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_12.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_12_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_12.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_12.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_12_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_12.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_12_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_12.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_12.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_12_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_12.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_12_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_12.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_12.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_12_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_12.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_12_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_12.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_12.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_12_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_12.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_AD_11: SW_PAD_CTL_PAD_GPIO_AD_11 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_11_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_11.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_11.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_11_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_11.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_11_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_11.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_11.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_11_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_11.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_11_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_11.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_11.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_11_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_11.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_11_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_11.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_11.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_11_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_11.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_11_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_11.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_11.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_11_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_11.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_11_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_11.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_11.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_11_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_11.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_11_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_11.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_11.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_11_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_11.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_11_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_11.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_11.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_11_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_11.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_AD_10: SW_PAD_CTL_PAD_GPIO_AD_10 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_10_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_10.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_10.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_10_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_10.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_10_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_10.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_10.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_10_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_10.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_10_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_10.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_10.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_10_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_10.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_10_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_10.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_10.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_10_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_10.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_10_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_10.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_10.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_10_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_10.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_10_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_10.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_10.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_10_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_10.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_10_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_10.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_10.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_10_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_10.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_10_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_10.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_10.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_10_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_10.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_AD_09: SW_PAD_CTL_PAD_GPIO_AD_09 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_09_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_09.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_09.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_09_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_09.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_09_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_09.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_09.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_09_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_09.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_09_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_09.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_09.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_09_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_09.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_09_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_09.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_09.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_09_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_09.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_09_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_09.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_09.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_09_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_09.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_09_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_09.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_09.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_09_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_09.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_09_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_09.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_09.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_09_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_09.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_09_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_09.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_09.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_09_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_09.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_AD_08: SW_PAD_CTL_PAD_GPIO_AD_08 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_08_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_08.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_08.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_08_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_08.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_08_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_08.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_08.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_08_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_08.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_08_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_08.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_08.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_08_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_08.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_08_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_08.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_08.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_08_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_08.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_08_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_08.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_08.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_08_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_08.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_08_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_08.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_08.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_08_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_08.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_08_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_08.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_08.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_08_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_08.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_08_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_08.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_08.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_08_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_08.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_AD_07: SW_PAD_CTL_PAD_GPIO_AD_07 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_07_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_07.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_07.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_07_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_07.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_07_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_07.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_07.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_07_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_07.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_07_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_07.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_07.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_07_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_07.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_07_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_07.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_07.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_07_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_07.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_07_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_07.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_07.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_07_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_07.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_07_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_07.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_07.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_07_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_07.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_07_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_07.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_07.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_07_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_07.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_07_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_07.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_07.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_07_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_07.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_AD_06: SW_PAD_CTL_PAD_GPIO_AD_06 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_06_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_06.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_06.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_06_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_06.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_06_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_06.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_06.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_06_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_06.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_06_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_06.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_06.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_06_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_06.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_06_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_06.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_06.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_06_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_06.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_06_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_06.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_06.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_06_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_06.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_06_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_06.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_06.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_06_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_06.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_06_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_06.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_06.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_06_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_06.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_06_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_06.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_06.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_06_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_06.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_AD_05: SW_PAD_CTL_PAD_GPIO_AD_05 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_05_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_05.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_05.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_05_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_05.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_05_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_05.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_05.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_05_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_05.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_05_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_05.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_05.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_05_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_05.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_05_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_05.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_05.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_05_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_05.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_05_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_05.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_05.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_05_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_05.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_05_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_05.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_05.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_05_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_05.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_05_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_05.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_05.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_05_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_05.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_05_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_05.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_05.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_05_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_05.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_AD_04: SW_PAD_CTL_PAD_GPIO_AD_04 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_04_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_04.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_04.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_04_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_04.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_04_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_04.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_04.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_04_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_04.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_04_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_04.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_04.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_04_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_04.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_04_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_04.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_04.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_04_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_04.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_04_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_04.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_04.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_04_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_04.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_04_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_04.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_04.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_04_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_04.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_04_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_04.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_04.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_04_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_04.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_04_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_04.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_04.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_04_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_04.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_AD_03: SW_PAD_CTL_PAD_GPIO_AD_03 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_03_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_03.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_03.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_03_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_03.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_03_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_03.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_03.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_03_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_03.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_03_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_03.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_03.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_03_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_03.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_03_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_03.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_03.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_03_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_03.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_03_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_03.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_03.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_03_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_03.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_03_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_03.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_03.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_03_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_03.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_03_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_03.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_03.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_03_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_03.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_03_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_03.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_03.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_03_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_03.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_AD_02: SW_PAD_CTL_PAD_GPIO_AD_02 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_02_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_02.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_02.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_02_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_02.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_02_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_02.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_02.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_02_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_02.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_02_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_02.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_02.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_02_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_02.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_02_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_02.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_02.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_02_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_02.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_02_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_02.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_02.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_02_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_02.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_02_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_02.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_02.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_02_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_02.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_02_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_02.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_02.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_02_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_02.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_02_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_02.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_02.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_02_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_02.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_AD_01: SW_PAD_CTL_PAD_GPIO_AD_01 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_01_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_01.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_01.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_01_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_01.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_01_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_01.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_01.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_01_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_01.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_01_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_01.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_01.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_01_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_01.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_01_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_01.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_01.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_01_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_01.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_01_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_01.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_01.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_01_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_01.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_01_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_01.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_01.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_01_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_01.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_01_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_01.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_01.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_01_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_01.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_01_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_01.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_01.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_01_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_01.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_AD_00: SW_PAD_CTL_PAD_GPIO_AD_00 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_00_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_00.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_00.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_00_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_00.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_00_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_00.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_00.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_00_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_00.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_00_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_00.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_00.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_00_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_00.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_00_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_00.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_00.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_00_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_00.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_00_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_00.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_00.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_00_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_00.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_00_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_00.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_00.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_00_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_00.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_00_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_00.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_00.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_00_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_00.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_AD_00_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_00.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_00.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_AD_00_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_AD_00.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_SD_14: SW_PAD_CTL_PAD_GPIO_SD_14 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_14_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_14.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_14.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_14_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_14.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_14_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_14.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_14.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_14_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_14.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_14_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_14.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_14.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_14_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_14.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_14_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_14.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_14.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_14_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_14.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_14_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_14.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_14.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_14_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_14.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_14_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_14.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_14.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_14_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_14.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_14_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_14.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_14.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_14_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_14.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_14_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_14.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_14.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_14_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_14.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_SD_13: SW_PAD_CTL_PAD_GPIO_SD_13 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_13_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_13.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_13.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_13_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_13.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_13_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_13.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_13.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_13_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_13.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_13_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_13.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_13.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_13_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_13.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_13_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_13.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_13.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_13_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_13.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_13_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_13.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_13.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_13_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_13.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_13_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_13.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_13.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_13_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_13.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_13_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_13.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_13.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_13_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_13.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_13_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_13.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_13.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_13_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_13.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_SD_12: SW_PAD_CTL_PAD_GPIO_SD_12 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_12_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_12.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_12.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_12_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_12.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_12_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_12.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_12.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_12_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_12.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_12_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_12.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_12.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_12_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_12.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_12_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_12.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_12.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_12_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_12.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_12_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_12.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_12.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_12_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_12.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_12_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_12.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_12.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_12_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_12.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_12_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_12.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_12.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_12_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_12.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_12_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_12.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_12.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_12_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_12.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_SD_11: SW_PAD_CTL_PAD_GPIO_SD_11 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_11_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_11.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_11.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_11_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_11.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_11_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_11.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_11.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_11_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_11.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_11_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_11.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_11.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_11_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_11.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_11_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_11.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_11.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_11_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_11.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_11_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_11.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_11.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_11_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_11.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_11_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_11.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_11.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_11_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_11.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_11_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_11.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_11.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_11_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_11.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_11_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_11.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_11.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_11_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_11.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_SD_10: SW_PAD_CTL_PAD_GPIO_SD_10 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_10_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_10.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_10.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_10_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_10.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_10_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_10.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_10.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_10_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_10.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_10_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_10.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_10.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_10_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_10.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_10_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_10.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_10.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_10_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_10.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_10_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_10.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_10.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_10_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_10.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_10_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_10.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_10.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_10_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_10.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_10_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_10.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_10.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_10_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_10.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_10_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_10.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_10.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_10_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_10.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_SD_09: SW_PAD_CTL_PAD_GPIO_SD_09 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_09_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_09.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_09.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_09_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_09.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_09_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_09.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_09.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_09_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_09.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_09_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_09.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_09.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_09_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_09.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_09_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_09.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_09.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_09_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_09.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_09_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_09.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_09.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_09_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_09.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_09_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_09.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_09.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_09_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_09.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_09_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_09.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_09.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_09_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_09.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_09_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_09.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_09.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_09_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_09.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_SD_08: SW_PAD_CTL_PAD_GPIO_SD_08 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_08_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_08.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_08.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_08_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_08.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_08_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_08.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_08.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_08_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_08.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_08_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_08.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_08.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_08_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_08.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_08_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_08.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_08.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_08_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_08.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_08_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_08.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_08.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_08_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_08.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_08_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_08.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_08.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_08_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_08.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_08_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_08.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_08.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_08_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_08.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_08_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_08.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_08.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_08_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_08.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_SD_07: SW_PAD_CTL_PAD_GPIO_SD_07 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_07_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_07.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_07.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_07_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_07.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_07_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_07.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_07.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_07_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_07.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_07_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_07.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_07.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_07_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_07.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_07_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_07.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_07.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_07_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_07.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_07_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_07.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_07.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_07_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_07.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_07_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_07.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_07.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_07_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_07.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_07_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_07.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_07.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_07_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_07.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_07_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_07.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_07.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_07_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_07.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_SD_06: SW_PAD_CTL_PAD_GPIO_SD_06 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_06_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_06.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_06.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_06_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_06.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_06_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_06.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_06.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_06_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_06.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_06_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_06.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_06.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_06_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_06.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_06_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_06.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_06.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_06_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_06.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_06_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_06.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_06.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_06_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_06.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_06_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_06.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_06.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_06_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_06.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_06_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_06.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_06.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_06_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_06.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_06_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_06.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_06.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_06_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_06.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_SD_05: SW_PAD_CTL_PAD_GPIO_SD_05 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_05_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_05.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_05.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_05_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_05.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_05_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_05.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_05.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_05_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_05.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_05_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_05.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_05.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_05_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_05.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_05_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_05.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_05.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_05_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_05.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_05_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_05.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_05.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_05_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_05.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_05_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_05.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_05.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_05_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_05.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_05_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_05.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_05.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_05_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_05.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_05_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_05.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_05.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_05_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_05.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_SD_04: SW_PAD_CTL_PAD_GPIO_SD_04 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_04_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_04.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_04.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_04_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_04.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_04_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_04.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_04.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_04_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_04.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_04_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_04.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_04.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_04_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_04.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_04_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_04.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_04.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_04_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_04.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_04_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_04.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_04.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_04_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_04.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_04_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_04.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_04.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_04_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_04.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_04_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_04.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_04.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_04_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_04.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_04_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_04.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_04.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_04_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_04.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_SD_03: SW_PAD_CTL_PAD_GPIO_SD_03 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_03_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_03.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_03.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_03_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_03.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_03_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_03.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_03.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_03_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_03.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_03_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_03.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_03.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_03_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_03.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_03_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_03.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_03.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_03_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_03.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_03_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_03.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_03.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_03_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_03.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_03_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_03.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_03.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_03_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_03.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_03_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_03.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_03.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_03_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_03.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_03_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_03.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_03.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_03_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_03.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_SD_02: SW_PAD_CTL_PAD_GPIO_SD_02 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_02_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_02.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_02.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_02_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_02.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_02_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_02.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_02.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_02_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_02.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_02_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_02.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_02.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_02_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_02.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_02_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_02.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_02.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_02_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_02.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_02_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_02.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_02.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_02_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_02.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_02_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_02.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_02.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_02_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_02.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_02_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_02.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_02.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_02_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_02.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_02_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_02.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_02.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_02_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_02.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_SD_01: SW_PAD_CTL_PAD_GPIO_SD_01 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_01_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_01.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_01.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_01_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_01.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_01_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_01.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_01.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_01_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_01.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_01_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_01.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_01.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_01_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_01.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_01_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_01.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_01.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_01_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_01.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_01_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_01.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_01.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_01_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_01.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_01_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_01.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_01.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_01_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_01.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_01_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_01.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_01.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_01_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_01.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_01_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_01.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_01.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_01_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_01.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_SD_00: SW_PAD_CTL_PAD_GPIO_SD_00 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_00_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_00.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_00.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_00_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_00.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_00_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_00.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_00.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_00_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_00.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_00_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_00.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_00.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_00_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_00.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_00_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_00.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_00.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_00_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_00.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_00_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_00.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_00.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_00_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_00.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_00_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_00.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_00.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_00_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_00.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_00_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_00.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_00.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_00_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_00.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_SD_00_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_00.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_00.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_SD_00_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_SD_00.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_13: SW_PAD_CTL_PAD_GPIO_13 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_13_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_13.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_13.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_13_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_13.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_13_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_13.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_13.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_13_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_13.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_13_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_13.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_13.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_13_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_13.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_13_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_13.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_13.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_13_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_13.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_13_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_13.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_13.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_13_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_13.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_13_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_13.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_13.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_13_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_13.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_13_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_13.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_13.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_13_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_13.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_13_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_13.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_13.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_13_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_13.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_12: SW_PAD_CTL_PAD_GPIO_12 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_12_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_12.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_12.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_12_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_12.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_12_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_12.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_12.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_12_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_12.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_12_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_12.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_12.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_12_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_12.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_12_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_12.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_12.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_12_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_12.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_12_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_12.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_12.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_12_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_12.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_12_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_12.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_12.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_12_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_12.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_12_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_12.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_12.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_12_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_12.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_12_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_12.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_12.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_12_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_12.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_11: SW_PAD_CTL_PAD_GPIO_11 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_11_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_11.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_11.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_11_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_11.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_11_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_11.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_11.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_11_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_11.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_11_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_11.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_11.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_11_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_11.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_11_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_11.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_11.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_11_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_11.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_11_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_11.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_11.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_11_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_11.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_11_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_11.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_11.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_11_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_11.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_11_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_11.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_11.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_11_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_11.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_11_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_11.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_11.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_11_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_11.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_10: SW_PAD_CTL_PAD_GPIO_10 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_10_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_10.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_10.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_10_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_10.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_10_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_10.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_10.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_10_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_10.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_10_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_10.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_10.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_10_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_10.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_10_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_10.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_10.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_10_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_10.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_10_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_10.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_10.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_10_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_10.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_10_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_10.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_10.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_10_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_10.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_10_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_10.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_10.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_10_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_10.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_10_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_10.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_10.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_10_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_10.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_09: SW_PAD_CTL_PAD_GPIO_09 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_09_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_09.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_09.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_09_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_09.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_09_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_09.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_09.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_09_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_09.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_09_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_09.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_09.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_09_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_09.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_09_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_09.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_09.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_09_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_09.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_09_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_09.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_09.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_09_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_09.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_09_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_09.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_09.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_09_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_09.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_09_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_09.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_09.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_09_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_09.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_09_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_09.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_09.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_09_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_09.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_08: SW_PAD_CTL_PAD_GPIO_08 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_08_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_08.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_08.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_08_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_08.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_08_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_08.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_08.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_08_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_08.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_08_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_08.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_08.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_08_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_08.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_08_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_08.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_08.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_08_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_08.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_08_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_08.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_08.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_08_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_08.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_08_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_08.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_08.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_08_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_08.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_08_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_08.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_08.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_08_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_08.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_08_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_08.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_08.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_08_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_08.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_07: SW_PAD_CTL_PAD_GPIO_07 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_07_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_07.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_07.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_07_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_07.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_07_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_07.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_07.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_07_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_07.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_07_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_07.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_07.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_07_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_07.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_07_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_07.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_07.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_07_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_07.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_07_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_07.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_07.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_07_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_07.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_07_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_07.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_07.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_07_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_07.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_07_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_07.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_07.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_07_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_07.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_07_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_07.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_07.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_07_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_07.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_06: SW_PAD_CTL_PAD_GPIO_06 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_06_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_06.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_06.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_06_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_06.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_06_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_06.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_06.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_06_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_06.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_06_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_06.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_06.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_06_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_06.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_06_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_06.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_06.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_06_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_06.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_06_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_06.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_06.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_06_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_06.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_06_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_06.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_06.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_06_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_06.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_06_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_06.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_06.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_06_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_06.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_06_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_06.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_06.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_06_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_06.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_05: SW_PAD_CTL_PAD_GPIO_05 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_05_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_05.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_05.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_05_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_05.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_05_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_05.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_05.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_05_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_05.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_05_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_05.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_05.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_05_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_05.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_05_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_05.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_05.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_05_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_05.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_05_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_05.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_05.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_05_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_05.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_05_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_05.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_05.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_05_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_05.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_05_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_05.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_05.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_05_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_05.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_05_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_05.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_05.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_05_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_05.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_04: SW_PAD_CTL_PAD_GPIO_04 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_04_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_04.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_04.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_04_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_04.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_04_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_04.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_04.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_04_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_04.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_04_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_04.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_04.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_04_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_04.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_04_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_04.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_04.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_04_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_04.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_04_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_04.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_04.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_04_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_04.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_04_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_04.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_04.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_04_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_04.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_04_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_04.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_04.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_04_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_04.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_04_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_04.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_04.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_04_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_04.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_03: SW_PAD_CTL_PAD_GPIO_03 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_03_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_03.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_03.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_03_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_03.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_03_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_03.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_03.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_03_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_03.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_03_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_03.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_03.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_03_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_03.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_03_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_03.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_03.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_03_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_03.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_03_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_03.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_03.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_03_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_03.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_03_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_03.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_03.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_03_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_03.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_03_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_03.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_03.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_03_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_03.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_03_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_03.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_03.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_03_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_03.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_02: SW_PAD_CTL_PAD_GPIO_02 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_02_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_02.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_02.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_02_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_02.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_02_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_02.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_02.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_02_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_02.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_02_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_02.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_02.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_02_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_02.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_02_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_02.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_02.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_02_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_02.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_02_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_02.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_02.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_02_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_02.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_02_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_02.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_02.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_02_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_02.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_02_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_02.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_02.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_02_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_02.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_02_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_02.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_02.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_02_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_02.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_01: SW_PAD_CTL_PAD_GPIO_01 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_01_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_01.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_01.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_01_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_01.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_01_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_01.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_01.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_01_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_01.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_01_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_01.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_01.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_01_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_01.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_01_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_01.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_01.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_01_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_01.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_01_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_01.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_01.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_01_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_01.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_01_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_01.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_01.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_01_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_01.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_01_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_01.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_01.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_01_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_01.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_01_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_01.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_01.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_01_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_01.Reg) & 0x10000) >> 16
}

// IOMUXC.SW_PAD_CTL_PAD_GPIO_00: SW_PAD_CTL_PAD_GPIO_00 SW PAD Control Register
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_00_SRE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_00.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_00.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_00_SRE() uint32 {
	return volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_00.Reg) & 0x1
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_00_DSE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_00.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_00.Reg)&^(0x38)|value<<3)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_00_DSE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_00.Reg) & 0x38) >> 3
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_00_SPEED(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_00.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_00.Reg)&^(0xc0)|value<<6)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_00_SPEED() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_00.Reg) & 0xc0) >> 6
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_00_ODE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_00.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_00.Reg)&^(0x800)|value<<11)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_00_ODE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_00.Reg) & 0x800) >> 11
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_00_PKE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_00.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_00.Reg)&^(0x1000)|value<<12)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_00_PKE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_00.Reg) & 0x1000) >> 12
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_00_PUE(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_00.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_00.Reg)&^(0x2000)|value<<13)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_00_PUE() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_00.Reg) & 0x2000) >> 13
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_00_PUS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_00.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_00.Reg)&^(0xc000)|value<<14)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_00_PUS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_00.Reg) & 0xc000) >> 14
}
func (o *IOMUXC_Type) SetSW_PAD_CTL_PAD_GPIO_00_HYS(value uint32) {
	volatile.StoreUint32(&o.SW_PAD_CTL_PAD_GPIO_00.Reg, volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_00.Reg)&^(0x10000)|value<<16)
}
func (o *IOMUXC_Type) GetSW_PAD_CTL_PAD_GPIO_00_HYS() uint32 {
	return (volatile.LoadUint32(&o.SW_PAD_CTL_PAD_GPIO_00.Reg) & 0x10000) >> 16
}

// IOMUXC.USB_OTG_ID_SELECT_INPUT: USB_OTG_ID_SELECT_INPUT DAISY Register
func (o *IOMUXC_Type) SetUSB_OTG_ID_SELECT_INPUT_DAISY(value uint32) {
	volatile.StoreUint32(&o.USB_OTG_ID_SELECT_INPUT.Reg, volatile.LoadUint32(&o.USB_OTG_ID_SELECT_INPUT.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetUSB_OTG_ID_SELECT_INPUT_DAISY() uint32 {
	return volatile.LoadUint32(&o.USB_OTG_ID_SELECT_INPUT.Reg) & 0x1
}

// IOMUXC.FLEXPWM1_PWMA_SELECT_INPUT_0: FLEXPWM1_PWMA_SELECT_INPUT_0 DAISY Register
func (o *IOMUXC_Type) SetFLEXPWM1_PWMA_SELECT_INPUT_0_DAISY(value uint32) {
	volatile.StoreUint32(&o.FLEXPWM1_PWMA_SELECT_INPUT_0.Reg, volatile.LoadUint32(&o.FLEXPWM1_PWMA_SELECT_INPUT_0.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetFLEXPWM1_PWMA_SELECT_INPUT_0_DAISY() uint32 {
	return volatile.LoadUint32(&o.FLEXPWM1_PWMA_SELECT_INPUT_0.Reg) & 0x1
}

// IOMUXC.FLEXPWM1_PWMA_SELECT_INPUT_1: FLEXPWM1_PWMA_SELECT_INPUT_1 DAISY Register
func (o *IOMUXC_Type) SetFLEXPWM1_PWMA_SELECT_INPUT_1_DAISY(value uint32) {
	volatile.StoreUint32(&o.FLEXPWM1_PWMA_SELECT_INPUT_1.Reg, volatile.LoadUint32(&o.FLEXPWM1_PWMA_SELECT_INPUT_1.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetFLEXPWM1_PWMA_SELECT_INPUT_1_DAISY() uint32 {
	return volatile.LoadUint32(&o.FLEXPWM1_PWMA_SELECT_INPUT_1.Reg) & 0x1
}

// IOMUXC.FLEXPWM1_PWMA_SELECT_INPUT_2: FLEXPWM1_PWMA_SELECT_INPUT_2 DAISY Register
func (o *IOMUXC_Type) SetFLEXPWM1_PWMA_SELECT_INPUT_2_DAISY(value uint32) {
	volatile.StoreUint32(&o.FLEXPWM1_PWMA_SELECT_INPUT_2.Reg, volatile.LoadUint32(&o.FLEXPWM1_PWMA_SELECT_INPUT_2.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetFLEXPWM1_PWMA_SELECT_INPUT_2_DAISY() uint32 {
	return volatile.LoadUint32(&o.FLEXPWM1_PWMA_SELECT_INPUT_2.Reg) & 0x1
}

// IOMUXC.FLEXPWM1_PWMA_SELECT_INPUT_3: FLEXPWM1_PWMA_SELECT_INPUT_3 DAISY Register
func (o *IOMUXC_Type) SetFLEXPWM1_PWMA_SELECT_INPUT_3_DAISY(value uint32) {
	volatile.StoreUint32(&o.FLEXPWM1_PWMA_SELECT_INPUT_3.Reg, volatile.LoadUint32(&o.FLEXPWM1_PWMA_SELECT_INPUT_3.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetFLEXPWM1_PWMA_SELECT_INPUT_3_DAISY() uint32 {
	return volatile.LoadUint32(&o.FLEXPWM1_PWMA_SELECT_INPUT_3.Reg) & 0x1
}

// IOMUXC.FLEXPWM1_PWMB_SELECT_INPUT_0: FLEXPWM1_PWMB_SELECT_INPUT_0 DAISY Register
func (o *IOMUXC_Type) SetFLEXPWM1_PWMB_SELECT_INPUT_0_DAISY(value uint32) {
	volatile.StoreUint32(&o.FLEXPWM1_PWMB_SELECT_INPUT_0.Reg, volatile.LoadUint32(&o.FLEXPWM1_PWMB_SELECT_INPUT_0.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetFLEXPWM1_PWMB_SELECT_INPUT_0_DAISY() uint32 {
	return volatile.LoadUint32(&o.FLEXPWM1_PWMB_SELECT_INPUT_0.Reg) & 0x1
}

// IOMUXC.FLEXPWM1_PWMB_SELECT_INPUT_1: FLEXPWM1_PWMB_SELECT_INPUT_1 DAISY Register
func (o *IOMUXC_Type) SetFLEXPWM1_PWMB_SELECT_INPUT_1_DAISY(value uint32) {
	volatile.StoreUint32(&o.FLEXPWM1_PWMB_SELECT_INPUT_1.Reg, volatile.LoadUint32(&o.FLEXPWM1_PWMB_SELECT_INPUT_1.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetFLEXPWM1_PWMB_SELECT_INPUT_1_DAISY() uint32 {
	return volatile.LoadUint32(&o.FLEXPWM1_PWMB_SELECT_INPUT_1.Reg) & 0x1
}

// IOMUXC.FLEXPWM1_PWMB_SELECT_INPUT_2: FLEXPWM1_PWMB_SELECT_INPUT_2 DAISY Register
func (o *IOMUXC_Type) SetFLEXPWM1_PWMB_SELECT_INPUT_2_DAISY(value uint32) {
	volatile.StoreUint32(&o.FLEXPWM1_PWMB_SELECT_INPUT_2.Reg, volatile.LoadUint32(&o.FLEXPWM1_PWMB_SELECT_INPUT_2.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetFLEXPWM1_PWMB_SELECT_INPUT_2_DAISY() uint32 {
	return volatile.LoadUint32(&o.FLEXPWM1_PWMB_SELECT_INPUT_2.Reg) & 0x1
}

// IOMUXC.FLEXPWM1_PWMB_SELECT_INPUT_3: FLEXPWM1_PWMB_SELECT_INPUT_3 DAISY Register
func (o *IOMUXC_Type) SetFLEXPWM1_PWMB_SELECT_INPUT_3_DAISY(value uint32) {
	volatile.StoreUint32(&o.FLEXPWM1_PWMB_SELECT_INPUT_3.Reg, volatile.LoadUint32(&o.FLEXPWM1_PWMB_SELECT_INPUT_3.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetFLEXPWM1_PWMB_SELECT_INPUT_3_DAISY() uint32 {
	return volatile.LoadUint32(&o.FLEXPWM1_PWMB_SELECT_INPUT_3.Reg) & 0x1
}

// IOMUXC.FLEXSPI_DQS_FA_SELECT_INPUT: FLEXSPI_DQS_FA_SELECT_INPUT DAISY Register
func (o *IOMUXC_Type) SetFLEXSPI_DQS_FA_SELECT_INPUT_DAISY(value uint32) {
	volatile.StoreUint32(&o.FLEXSPI_DQS_FA_SELECT_INPUT.Reg, volatile.LoadUint32(&o.FLEXSPI_DQS_FA_SELECT_INPUT.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetFLEXSPI_DQS_FA_SELECT_INPUT_DAISY() uint32 {
	return volatile.LoadUint32(&o.FLEXSPI_DQS_FA_SELECT_INPUT.Reg) & 0x1
}

// IOMUXC.FLEXSPI_DQS_FB_SELECT_INPUT: FLEXSPI_DQS_FB_SELECT_INPUT DAISY Register
func (o *IOMUXC_Type) SetFLEXSPI_DQS_FB_SELECT_INPUT_DAISY(value uint32) {
	volatile.StoreUint32(&o.FLEXSPI_DQS_FB_SELECT_INPUT.Reg, volatile.LoadUint32(&o.FLEXSPI_DQS_FB_SELECT_INPUT.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetFLEXSPI_DQS_FB_SELECT_INPUT_DAISY() uint32 {
	return volatile.LoadUint32(&o.FLEXSPI_DQS_FB_SELECT_INPUT.Reg) & 0x1
}

// IOMUXC.KPP_COL_SELECT_INPUT_0: KPP_COL_SELECT_INPUT_0 DAISY Register
func (o *IOMUXC_Type) SetKPP_COL_SELECT_INPUT_0_DAISY(value uint32) {
	volatile.StoreUint32(&o.KPP_COL_SELECT_INPUT_0.Reg, volatile.LoadUint32(&o.KPP_COL_SELECT_INPUT_0.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetKPP_COL_SELECT_INPUT_0_DAISY() uint32 {
	return volatile.LoadUint32(&o.KPP_COL_SELECT_INPUT_0.Reg) & 0x1
}

// IOMUXC.KPP_COL_SELECT_INPUT_1: KPP_COL_SELECT_INPUT_1 DAISY Register
func (o *IOMUXC_Type) SetKPP_COL_SELECT_INPUT_1_DAISY(value uint32) {
	volatile.StoreUint32(&o.KPP_COL_SELECT_INPUT_1.Reg, volatile.LoadUint32(&o.KPP_COL_SELECT_INPUT_1.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetKPP_COL_SELECT_INPUT_1_DAISY() uint32 {
	return volatile.LoadUint32(&o.KPP_COL_SELECT_INPUT_1.Reg) & 0x1
}

// IOMUXC.KPP_COL_SELECT_INPUT_2: KPP_COL_SELECT_INPUT_2 DAISY Register
func (o *IOMUXC_Type) SetKPP_COL_SELECT_INPUT_2_DAISY(value uint32) {
	volatile.StoreUint32(&o.KPP_COL_SELECT_INPUT_2.Reg, volatile.LoadUint32(&o.KPP_COL_SELECT_INPUT_2.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetKPP_COL_SELECT_INPUT_2_DAISY() uint32 {
	return volatile.LoadUint32(&o.KPP_COL_SELECT_INPUT_2.Reg) & 0x1
}

// IOMUXC.KPP_COL_SELECT_INPUT_3: KPP_COL_SELECT_INPUT_3 DAISY Register
func (o *IOMUXC_Type) SetKPP_COL_SELECT_INPUT_3_DAISY(value uint32) {
	volatile.StoreUint32(&o.KPP_COL_SELECT_INPUT_3.Reg, volatile.LoadUint32(&o.KPP_COL_SELECT_INPUT_3.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetKPP_COL_SELECT_INPUT_3_DAISY() uint32 {
	return volatile.LoadUint32(&o.KPP_COL_SELECT_INPUT_3.Reg) & 0x1
}

// IOMUXC.KPP_ROW_SELECT_INPUT_0: KPP_ROW_SELECT_INPUT_0 DAISY Register
func (o *IOMUXC_Type) SetKPP_ROW_SELECT_INPUT_0_DAISY(value uint32) {
	volatile.StoreUint32(&o.KPP_ROW_SELECT_INPUT_0.Reg, volatile.LoadUint32(&o.KPP_ROW_SELECT_INPUT_0.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetKPP_ROW_SELECT_INPUT_0_DAISY() uint32 {
	return volatile.LoadUint32(&o.KPP_ROW_SELECT_INPUT_0.Reg) & 0x1
}

// IOMUXC.KPP_ROW_SELECT_INPUT_1: KPP_ROW_SELECT_INPUT_1 DAISY Register
func (o *IOMUXC_Type) SetKPP_ROW_SELECT_INPUT_1_DAISY(value uint32) {
	volatile.StoreUint32(&o.KPP_ROW_SELECT_INPUT_1.Reg, volatile.LoadUint32(&o.KPP_ROW_SELECT_INPUT_1.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetKPP_ROW_SELECT_INPUT_1_DAISY() uint32 {
	return volatile.LoadUint32(&o.KPP_ROW_SELECT_INPUT_1.Reg) & 0x1
}

// IOMUXC.KPP_ROW_SELECT_INPUT_2: KPP_ROW_SELECT_INPUT_2 DAISY Register
func (o *IOMUXC_Type) SetKPP_ROW_SELECT_INPUT_2_DAISY(value uint32) {
	volatile.StoreUint32(&o.KPP_ROW_SELECT_INPUT_2.Reg, volatile.LoadUint32(&o.KPP_ROW_SELECT_INPUT_2.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetKPP_ROW_SELECT_INPUT_2_DAISY() uint32 {
	return volatile.LoadUint32(&o.KPP_ROW_SELECT_INPUT_2.Reg) & 0x1
}

// IOMUXC.KPP_ROW_SELECT_INPUT_3: KPP_ROW_SELECT_INPUT_3 DAISY Register
func (o *IOMUXC_Type) SetKPP_ROW_SELECT_INPUT_3_DAISY(value uint32) {
	volatile.StoreUint32(&o.KPP_ROW_SELECT_INPUT_3.Reg, volatile.LoadUint32(&o.KPP_ROW_SELECT_INPUT_3.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetKPP_ROW_SELECT_INPUT_3_DAISY() uint32 {
	return volatile.LoadUint32(&o.KPP_ROW_SELECT_INPUT_3.Reg) & 0x1
}

// IOMUXC.LPI2C1_HREQ_SELECT_INPUT: LPI2C1_HREQ_SELECT_INPUT DAISY Register
func (o *IOMUXC_Type) SetLPI2C1_HREQ_SELECT_INPUT_DAISY(value uint32) {
	volatile.StoreUint32(&o.LPI2C1_HREQ_SELECT_INPUT.Reg, volatile.LoadUint32(&o.LPI2C1_HREQ_SELECT_INPUT.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetLPI2C1_HREQ_SELECT_INPUT_DAISY() uint32 {
	return volatile.LoadUint32(&o.LPI2C1_HREQ_SELECT_INPUT.Reg) & 0x1
}

// IOMUXC.LPI2C1_SCL_SELECT_INPUT: LPI2C1_SCL_SELECT_INPUT DAISY Register
func (o *IOMUXC_Type) SetLPI2C1_SCL_SELECT_INPUT_DAISY(value uint32) {
	volatile.StoreUint32(&o.LPI2C1_SCL_SELECT_INPUT.Reg, volatile.LoadUint32(&o.LPI2C1_SCL_SELECT_INPUT.Reg)&^(0x3)|value)
}
func (o *IOMUXC_Type) GetLPI2C1_SCL_SELECT_INPUT_DAISY() uint32 {
	return volatile.LoadUint32(&o.LPI2C1_SCL_SELECT_INPUT.Reg) & 0x3
}

// IOMUXC.LPI2C1_SDA_SELECT_INPUT: LPI2C1_SDA_SELECT_INPUT DAISY Register
func (o *IOMUXC_Type) SetLPI2C1_SDA_SELECT_INPUT_DAISY(value uint32) {
	volatile.StoreUint32(&o.LPI2C1_SDA_SELECT_INPUT.Reg, volatile.LoadUint32(&o.LPI2C1_SDA_SELECT_INPUT.Reg)&^(0x3)|value)
}
func (o *IOMUXC_Type) GetLPI2C1_SDA_SELECT_INPUT_DAISY() uint32 {
	return volatile.LoadUint32(&o.LPI2C1_SDA_SELECT_INPUT.Reg) & 0x3
}

// IOMUXC.LPI2C2_SCL_SELECT_INPUT: LPI2C2_SCL_SELECT_INPUT DAISY Register
func (o *IOMUXC_Type) SetLPI2C2_SCL_SELECT_INPUT_DAISY(value uint32) {
	volatile.StoreUint32(&o.LPI2C2_SCL_SELECT_INPUT.Reg, volatile.LoadUint32(&o.LPI2C2_SCL_SELECT_INPUT.Reg)&^(0x3)|value)
}
func (o *IOMUXC_Type) GetLPI2C2_SCL_SELECT_INPUT_DAISY() uint32 {
	return volatile.LoadUint32(&o.LPI2C2_SCL_SELECT_INPUT.Reg) & 0x3
}

// IOMUXC.LPI2C2_SDA_SELECT_INPUT: LPI2C2_SDA_SELECT_INPUT DAISY Register
func (o *IOMUXC_Type) SetLPI2C2_SDA_SELECT_INPUT_DAISY(value uint32) {
	volatile.StoreUint32(&o.LPI2C2_SDA_SELECT_INPUT.Reg, volatile.LoadUint32(&o.LPI2C2_SDA_SELECT_INPUT.Reg)&^(0x3)|value)
}
func (o *IOMUXC_Type) GetLPI2C2_SDA_SELECT_INPUT_DAISY() uint32 {
	return volatile.LoadUint32(&o.LPI2C2_SDA_SELECT_INPUT.Reg) & 0x3
}

// IOMUXC.LPSPI1_PCS_SELECT_INPUT_0: LPSPI1_PCS_SELECT_INPUT_0 DAISY Register
func (o *IOMUXC_Type) SetLPSPI1_PCS_SELECT_INPUT_0_DAISY(value uint32) {
	volatile.StoreUint32(&o.LPSPI1_PCS_SELECT_INPUT_0.Reg, volatile.LoadUint32(&o.LPSPI1_PCS_SELECT_INPUT_0.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetLPSPI1_PCS_SELECT_INPUT_0_DAISY() uint32 {
	return volatile.LoadUint32(&o.LPSPI1_PCS_SELECT_INPUT_0.Reg) & 0x1
}

// IOMUXC.LPSPI1_SCK_SELECT_INPUT: LPSPI1_SCK_SELECT_INPUT DAISY Register
func (o *IOMUXC_Type) SetLPSPI1_SCK_SELECT_INPUT_DAISY(value uint32) {
	volatile.StoreUint32(&o.LPSPI1_SCK_SELECT_INPUT.Reg, volatile.LoadUint32(&o.LPSPI1_SCK_SELECT_INPUT.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetLPSPI1_SCK_SELECT_INPUT_DAISY() uint32 {
	return volatile.LoadUint32(&o.LPSPI1_SCK_SELECT_INPUT.Reg) & 0x1
}

// IOMUXC.LPSPI1_SDI_SELECT_INPUT: LPSPI1_SDI_SELECT_INPUT DAISY Register
func (o *IOMUXC_Type) SetLPSPI1_SDI_SELECT_INPUT_DAISY(value uint32) {
	volatile.StoreUint32(&o.LPSPI1_SDI_SELECT_INPUT.Reg, volatile.LoadUint32(&o.LPSPI1_SDI_SELECT_INPUT.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetLPSPI1_SDI_SELECT_INPUT_DAISY() uint32 {
	return volatile.LoadUint32(&o.LPSPI1_SDI_SELECT_INPUT.Reg) & 0x1
}

// IOMUXC.LPSPI1_SDO_SELECT_INPUT: LPSPI1_SDO_SELECT_INPUT DAISY Register
func (o *IOMUXC_Type) SetLPSPI1_SDO_SELECT_INPUT_DAISY(value uint32) {
	volatile.StoreUint32(&o.LPSPI1_SDO_SELECT_INPUT.Reg, volatile.LoadUint32(&o.LPSPI1_SDO_SELECT_INPUT.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetLPSPI1_SDO_SELECT_INPUT_DAISY() uint32 {
	return volatile.LoadUint32(&o.LPSPI1_SDO_SELECT_INPUT.Reg) & 0x1
}

// IOMUXC.LPSPI2_PCS_SELECT_INPUT_0: LPSPI2_PCS_SELECT_INPUT_0 DAISY Register
func (o *IOMUXC_Type) SetLPSPI2_PCS_SELECT_INPUT_0_DAISY(value uint32) {
	volatile.StoreUint32(&o.LPSPI2_PCS_SELECT_INPUT_0.Reg, volatile.LoadUint32(&o.LPSPI2_PCS_SELECT_INPUT_0.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetLPSPI2_PCS_SELECT_INPUT_0_DAISY() uint32 {
	return volatile.LoadUint32(&o.LPSPI2_PCS_SELECT_INPUT_0.Reg) & 0x1
}

// IOMUXC.LPSPI2_SCK_SELECT_INPUT: LPSPI2_SCK_SELECT_INPUT DAISY Register
func (o *IOMUXC_Type) SetLPSPI2_SCK_SELECT_INPUT_DAISY(value uint32) {
	volatile.StoreUint32(&o.LPSPI2_SCK_SELECT_INPUT.Reg, volatile.LoadUint32(&o.LPSPI2_SCK_SELECT_INPUT.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetLPSPI2_SCK_SELECT_INPUT_DAISY() uint32 {
	return volatile.LoadUint32(&o.LPSPI2_SCK_SELECT_INPUT.Reg) & 0x1
}

// IOMUXC.LPSPI2_SDI_SELECT_INPUT: LPSPI2_SDI_SELECT_INPUT DAISY Register
func (o *IOMUXC_Type) SetLPSPI2_SDI_SELECT_INPUT_DAISY(value uint32) {
	volatile.StoreUint32(&o.LPSPI2_SDI_SELECT_INPUT.Reg, volatile.LoadUint32(&o.LPSPI2_SDI_SELECT_INPUT.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetLPSPI2_SDI_SELECT_INPUT_DAISY() uint32 {
	return volatile.LoadUint32(&o.LPSPI2_SDI_SELECT_INPUT.Reg) & 0x1
}

// IOMUXC.LPSPI2_SDO_SELECT_INPUT: LPSPI2_SDO_SELECT_INPUT DAISY Register
func (o *IOMUXC_Type) SetLPSPI2_SDO_SELECT_INPUT_DAISY(value uint32) {
	volatile.StoreUint32(&o.LPSPI2_SDO_SELECT_INPUT.Reg, volatile.LoadUint32(&o.LPSPI2_SDO_SELECT_INPUT.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetLPSPI2_SDO_SELECT_INPUT_DAISY() uint32 {
	return volatile.LoadUint32(&o.LPSPI2_SDO_SELECT_INPUT.Reg) & 0x1
}

// IOMUXC.LPUART1_RXD_SELECT_INPUT: LPUART1_RXD_SELECT_INPUT DAISY Register
func (o *IOMUXC_Type) SetLPUART1_RXD_SELECT_INPUT_DAISY(value uint32) {
	volatile.StoreUint32(&o.LPUART1_RXD_SELECT_INPUT.Reg, volatile.LoadUint32(&o.LPUART1_RXD_SELECT_INPUT.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetLPUART1_RXD_SELECT_INPUT_DAISY() uint32 {
	return volatile.LoadUint32(&o.LPUART1_RXD_SELECT_INPUT.Reg) & 0x1
}

// IOMUXC.LPUART1_TXD_SELECT_INPUT: LPUART1_TXD_SELECT_INPUT DAISY Register
func (o *IOMUXC_Type) SetLPUART1_TXD_SELECT_INPUT_DAISY(value uint32) {
	volatile.StoreUint32(&o.LPUART1_TXD_SELECT_INPUT.Reg, volatile.LoadUint32(&o.LPUART1_TXD_SELECT_INPUT.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetLPUART1_TXD_SELECT_INPUT_DAISY() uint32 {
	return volatile.LoadUint32(&o.LPUART1_TXD_SELECT_INPUT.Reg) & 0x1
}

// IOMUXC.LPUART2_RXD_SELECT_INPUT: LPUART2_RXD_SELECT_INPUT DAISY Register
func (o *IOMUXC_Type) SetLPUART2_RXD_SELECT_INPUT_DAISY(value uint32) {
	volatile.StoreUint32(&o.LPUART2_RXD_SELECT_INPUT.Reg, volatile.LoadUint32(&o.LPUART2_RXD_SELECT_INPUT.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetLPUART2_RXD_SELECT_INPUT_DAISY() uint32 {
	return volatile.LoadUint32(&o.LPUART2_RXD_SELECT_INPUT.Reg) & 0x1
}

// IOMUXC.LPUART2_TXD_SELECT_INPUT: LPUART2_TXD_SELECT_INPUT DAISY Register
func (o *IOMUXC_Type) SetLPUART2_TXD_SELECT_INPUT_DAISY(value uint32) {
	volatile.StoreUint32(&o.LPUART2_TXD_SELECT_INPUT.Reg, volatile.LoadUint32(&o.LPUART2_TXD_SELECT_INPUT.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetLPUART2_TXD_SELECT_INPUT_DAISY() uint32 {
	return volatile.LoadUint32(&o.LPUART2_TXD_SELECT_INPUT.Reg) & 0x1
}

// IOMUXC.LPUART3_RXD_SELECT_INPUT: LPUART3_RXD_SELECT_INPUT DAISY Register
func (o *IOMUXC_Type) SetLPUART3_RXD_SELECT_INPUT_DAISY(value uint32) {
	volatile.StoreUint32(&o.LPUART3_RXD_SELECT_INPUT.Reg, volatile.LoadUint32(&o.LPUART3_RXD_SELECT_INPUT.Reg)&^(0x3)|value)
}
func (o *IOMUXC_Type) GetLPUART3_RXD_SELECT_INPUT_DAISY() uint32 {
	return volatile.LoadUint32(&o.LPUART3_RXD_SELECT_INPUT.Reg) & 0x3
}

// IOMUXC.LPUART3_TXD_SELECT_INPUT: LPUART3_TXD_SELECT_INPUT DAISY Register
func (o *IOMUXC_Type) SetLPUART3_TXD_SELECT_INPUT_DAISY(value uint32) {
	volatile.StoreUint32(&o.LPUART3_TXD_SELECT_INPUT.Reg, volatile.LoadUint32(&o.LPUART3_TXD_SELECT_INPUT.Reg)&^(0x3)|value)
}
func (o *IOMUXC_Type) GetLPUART3_TXD_SELECT_INPUT_DAISY() uint32 {
	return volatile.LoadUint32(&o.LPUART3_TXD_SELECT_INPUT.Reg) & 0x3
}

// IOMUXC.LPUART4_RXD_SELECT_INPUT: LPUART4_RXD_SELECT_INPUT DAISY Register
func (o *IOMUXC_Type) SetLPUART4_RXD_SELECT_INPUT_DAISY(value uint32) {
	volatile.StoreUint32(&o.LPUART4_RXD_SELECT_INPUT.Reg, volatile.LoadUint32(&o.LPUART4_RXD_SELECT_INPUT.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetLPUART4_RXD_SELECT_INPUT_DAISY() uint32 {
	return volatile.LoadUint32(&o.LPUART4_RXD_SELECT_INPUT.Reg) & 0x1
}

// IOMUXC.LPUART4_TXD_SELECT_INPUT: LPUART4_TXD_SELECT_INPUT DAISY Register
func (o *IOMUXC_Type) SetLPUART4_TXD_SELECT_INPUT_DAISY(value uint32) {
	volatile.StoreUint32(&o.LPUART4_TXD_SELECT_INPUT.Reg, volatile.LoadUint32(&o.LPUART4_TXD_SELECT_INPUT.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetLPUART4_TXD_SELECT_INPUT_DAISY() uint32 {
	return volatile.LoadUint32(&o.LPUART4_TXD_SELECT_INPUT.Reg) & 0x1
}

// IOMUXC.NMI_GLUE_NMI_SELECT_INPUT: NMI_GLUE_NMI_SELECT_INPUT DAISY Register
func (o *IOMUXC_Type) SetNMI_GLUE_NMI_SELECT_INPUT_DAISY(value uint32) {
	volatile.StoreUint32(&o.NMI_GLUE_NMI_SELECT_INPUT.Reg, volatile.LoadUint32(&o.NMI_GLUE_NMI_SELECT_INPUT.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetNMI_GLUE_NMI_SELECT_INPUT_DAISY() uint32 {
	return volatile.LoadUint32(&o.NMI_GLUE_NMI_SELECT_INPUT.Reg) & 0x1
}

// IOMUXC.SPDIF_IN1_SELECT_INPUT: SPDIF_IN1_SELECT_INPUT DAISY Register
func (o *IOMUXC_Type) SetSPDIF_IN1_SELECT_INPUT_DAISY(value uint32) {
	volatile.StoreUint32(&o.SPDIF_IN1_SELECT_INPUT.Reg, volatile.LoadUint32(&o.SPDIF_IN1_SELECT_INPUT.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSPDIF_IN1_SELECT_INPUT_DAISY() uint32 {
	return volatile.LoadUint32(&o.SPDIF_IN1_SELECT_INPUT.Reg) & 0x1
}

// IOMUXC.SPDIF_TX_CLK2_SELECT_INPUT: SPDIF_TX_CLK2_SELECT_INPUT DAISY Register
func (o *IOMUXC_Type) SetSPDIF_TX_CLK2_SELECT_INPUT_DAISY(value uint32) {
	volatile.StoreUint32(&o.SPDIF_TX_CLK2_SELECT_INPUT.Reg, volatile.LoadUint32(&o.SPDIF_TX_CLK2_SELECT_INPUT.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetSPDIF_TX_CLK2_SELECT_INPUT_DAISY() uint32 {
	return volatile.LoadUint32(&o.SPDIF_TX_CLK2_SELECT_INPUT.Reg) & 0x1
}

// IOMUXC.USB_OTG_OC_SELECT_INPUT: USB_OTG_OC_SELECT_INPUT DAISY Register
func (o *IOMUXC_Type) SetUSB_OTG_OC_SELECT_INPUT_DAISY(value uint32) {
	volatile.StoreUint32(&o.USB_OTG_OC_SELECT_INPUT.Reg, volatile.LoadUint32(&o.USB_OTG_OC_SELECT_INPUT.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetUSB_OTG_OC_SELECT_INPUT_DAISY() uint32 {
	return volatile.LoadUint32(&o.USB_OTG_OC_SELECT_INPUT.Reg) & 0x1
}

// IOMUXC.XEV_GLUE_RXEV_SELECT_INPUT: XEV_GLUE_RXEV_SELECT_INPUT DAISY Register
func (o *IOMUXC_Type) SetXEV_GLUE_RXEV_SELECT_INPUT_DAISY(value uint32) {
	volatile.StoreUint32(&o.XEV_GLUE_RXEV_SELECT_INPUT.Reg, volatile.LoadUint32(&o.XEV_GLUE_RXEV_SELECT_INPUT.Reg)&^(0x1)|value)
}
func (o *IOMUXC_Type) GetXEV_GLUE_RXEV_SELECT_INPUT_DAISY() uint32 {
	return volatile.LoadUint32(&o.XEV_GLUE_RXEV_SELECT_INPUT.Reg) & 0x1
}

// KPP Registers
type KPP_Type struct {
	KPCR volatile.Register16 // 0x0
	KPSR volatile.Register16 // 0x2
	KDDR volatile.Register16 // 0x4
	KPDR volatile.Register16 // 0x6
}

// KPP.KPCR: Keypad Control Register
func (o *KPP_Type) SetKPCR_KRE(value uint16) {
	volatile.StoreUint16(&o.KPCR.Reg, volatile.LoadUint16(&o.KPCR.Reg)&^(0xff)|value)
}
func (o *KPP_Type) GetKPCR_KRE() uint16 {
	return volatile.LoadUint16(&o.KPCR.Reg) & 0xff
}
func (o *KPP_Type) SetKPCR_KCO(value uint16) {
	volatile.StoreUint16(&o.KPCR.Reg, volatile.LoadUint16(&o.KPCR.Reg)&^(0xff00)|value<<8)
}
func (o *KPP_Type) GetKPCR_KCO() uint16 {
	return (volatile.LoadUint16(&o.KPCR.Reg) & 0xff00) >> 8
}

// KPP.KPSR: Keypad Status Register
func (o *KPP_Type) SetKPSR_KPKD(value uint16) {
	volatile.StoreUint16(&o.KPSR.Reg, volatile.LoadUint16(&o.KPSR.Reg)&^(0x1)|value)
}
func (o *KPP_Type) GetKPSR_KPKD() uint16 {
	return volatile.LoadUint16(&o.KPSR.Reg) & 0x1
}
func (o *KPP_Type) SetKPSR_KPKR(value uint16) {
	volatile.StoreUint16(&o.KPSR.Reg, volatile.LoadUint16(&o.KPSR.Reg)&^(0x2)|value<<1)
}
func (o *KPP_Type) GetKPSR_KPKR() uint16 {
	return (volatile.LoadUint16(&o.KPSR.Reg) & 0x2) >> 1
}
func (o *KPP_Type) SetKPSR_KDSC(value uint16) {
	volatile.StoreUint16(&o.KPSR.Reg, volatile.LoadUint16(&o.KPSR.Reg)&^(0x4)|value<<2)
}
func (o *KPP_Type) GetKPSR_KDSC() uint16 {
	return (volatile.LoadUint16(&o.KPSR.Reg) & 0x4) >> 2
}
func (o *KPP_Type) SetKPSR_KRSS(value uint16) {
	volatile.StoreUint16(&o.KPSR.Reg, volatile.LoadUint16(&o.KPSR.Reg)&^(0x8)|value<<3)
}
func (o *KPP_Type) GetKPSR_KRSS() uint16 {
	return (volatile.LoadUint16(&o.KPSR.Reg) & 0x8) >> 3
}
func (o *KPP_Type) SetKPSR_KDIE(value uint16) {
	volatile.StoreUint16(&o.KPSR.Reg, volatile.LoadUint16(&o.KPSR.Reg)&^(0x100)|value<<8)
}
func (o *KPP_Type) GetKPSR_KDIE() uint16 {
	return (volatile.LoadUint16(&o.KPSR.Reg) & 0x100) >> 8
}
func (o *KPP_Type) SetKPSR_KRIE(value uint16) {
	volatile.StoreUint16(&o.KPSR.Reg, volatile.LoadUint16(&o.KPSR.Reg)&^(0x200)|value<<9)
}
func (o *KPP_Type) GetKPSR_KRIE() uint16 {
	return (volatile.LoadUint16(&o.KPSR.Reg) & 0x200) >> 9
}

// KPP.KDDR: Keypad Data Direction Register
func (o *KPP_Type) SetKDDR_KRDD(value uint16) {
	volatile.StoreUint16(&o.KDDR.Reg, volatile.LoadUint16(&o.KDDR.Reg)&^(0xff)|value)
}
func (o *KPP_Type) GetKDDR_KRDD() uint16 {
	return volatile.LoadUint16(&o.KDDR.Reg) & 0xff
}
func (o *KPP_Type) SetKDDR_KCDD(value uint16) {
	volatile.StoreUint16(&o.KDDR.Reg, volatile.LoadUint16(&o.KDDR.Reg)&^(0xff00)|value<<8)
}
func (o *KPP_Type) GetKDDR_KCDD() uint16 {
	return (volatile.LoadUint16(&o.KDDR.Reg) & 0xff00) >> 8
}

// KPP.KPDR: Keypad Data Register
func (o *KPP_Type) SetKPDR_KRD(value uint16) {
	volatile.StoreUint16(&o.KPDR.Reg, volatile.LoadUint16(&o.KPDR.Reg)&^(0xff)|value)
}
func (o *KPP_Type) GetKPDR_KRD() uint16 {
	return volatile.LoadUint16(&o.KPDR.Reg) & 0xff
}
func (o *KPP_Type) SetKPDR_KCD(value uint16) {
	volatile.StoreUint16(&o.KPDR.Reg, volatile.LoadUint16(&o.KPDR.Reg)&^(0xff00)|value<<8)
}
func (o *KPP_Type) GetKPDR_KCD() uint16 {
	return (volatile.LoadUint16(&o.KPDR.Reg) & 0xff00) >> 8
}

// System Control Block
type SCB_Type struct {
	_          [8]byte
	ACTLR      volatile.Register32 // 0x8
	_          [3316]byte
	CPUID      volatile.Register32 // 0xD00
	ICSR       volatile.Register32 // 0xD04
	VTOR       volatile.Register32 // 0xD08
	AIRCR      volatile.Register32 // 0xD0C
	SCR        volatile.Register32 // 0xD10
	CCR        volatile.Register32 // 0xD14
	SHPR1      volatile.Register32 // 0xD18
	SHPR2      volatile.Register32 // 0xD1C
	SHPR3      volatile.Register32 // 0xD20
	SHCSR      volatile.Register32 // 0xD24
	CFSR       volatile.Register32 // 0xD28
	HFSR       volatile.Register32 // 0xD2C
	DFSR       volatile.Register32 // 0xD30
	MMFAR      volatile.Register32 // 0xD34
	BFAR       volatile.Register32 // 0xD38
	_          [4]byte
	ID_PFR0    volatile.Register32 // 0xD40
	ID_PFR1    volatile.Register32 // 0xD44
	ID_DFR0    volatile.Register32 // 0xD48
	ID_AFR0    volatile.Register32 // 0xD4C
	ID_MMFR0   volatile.Register32 // 0xD50
	ID_MMFR1   volatile.Register32 // 0xD54
	ID_MMFR2   volatile.Register32 // 0xD58
	ID_MMFR3   volatile.Register32 // 0xD5C
	ID_ISAR0   volatile.Register32 // 0xD60
	ID_ISAR1   volatile.Register32 // 0xD64
	ID_ISAR2   volatile.Register32 // 0xD68
	ID_ISAR3   volatile.Register32 // 0xD6C
	ID_ISAR4   volatile.Register32 // 0xD70
	_          [4]byte
	CLIDR      volatile.Register32 // 0xD78
	CTR        volatile.Register32 // 0xD7C
	CCSIDR     volatile.Register32 // 0xD80
	CSSELR     volatile.Register32 // 0xD84
	CPACR      volatile.Register32 // 0xD88
	_          [372]byte
	STIR       volatile.Register32 // 0xF00
	_          [76]byte
	ICIALLU    volatile.Register32 // 0xF50
	_          [4]byte
	ICIMVAU    volatile.Register32 // 0xF58
	DCIMVAC    volatile.Register32 // 0xF5C
	DCISW      volatile.Register32 // 0xF60
	DCCMVAU    volatile.Register32 // 0xF64
	DCCMVAC    volatile.Register32 // 0xF68
	DCCSW      volatile.Register32 // 0xF6C
	DCCIMVAC   volatile.Register32 // 0xF70
	DCCISW     volatile.Register32 // 0xF74
	_          [24]byte
	CM7_ITCMCR volatile.Register32 // 0xF90
	CM7_DTCMCR volatile.Register32 // 0xF94
	CM7_AHBPCR volatile.Register32 // 0xF98
	CM7_CACR   volatile.Register32 // 0xF9C
	CM7_AHBSCR volatile.Register32 // 0xFA0
	_          [4]byte
	CM7_ABFSR  volatile.Register32 // 0xFA8
}

// SCB.ACTLR: Auxiliary Control Register,
func (o *SCB_Type) SetACTLR_DISFOLD(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x4)|value<<2)
}
func (o *SCB_Type) GetACTLR_DISFOLD() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x4) >> 2
}
func (o *SCB_Type) SetACTLR_FPEXCODIS(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x400)|value<<10)
}
func (o *SCB_Type) GetACTLR_FPEXCODIS() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x400) >> 10
}
func (o *SCB_Type) SetACTLR_DISRAMODE(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x800)|value<<11)
}
func (o *SCB_Type) GetACTLR_DISRAMODE() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x800) >> 11
}
func (o *SCB_Type) SetACTLR_DISITMATBFLUSH(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x1000)|value<<12)
}
func (o *SCB_Type) GetACTLR_DISITMATBFLUSH() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x1000) >> 12
}
func (o *SCB_Type) SetACTLR_DISBTACREAD(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x2000)|value<<13)
}
func (o *SCB_Type) GetACTLR_DISBTACREAD() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x2000) >> 13
}
func (o *SCB_Type) SetACTLR_DISBTACALLOC(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x4000)|value<<14)
}
func (o *SCB_Type) GetACTLR_DISBTACALLOC() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x4000) >> 14
}
func (o *SCB_Type) SetACTLR_DISCRITAXIRUR(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x8000)|value<<15)
}
func (o *SCB_Type) GetACTLR_DISCRITAXIRUR() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x8000) >> 15
}
func (o *SCB_Type) SetACTLR_DISDI(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x1f0000)|value<<16)
}
func (o *SCB_Type) GetACTLR_DISDI() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x1f0000) >> 16
}
func (o *SCB_Type) SetACTLR_DISISSCH1(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x3e00000)|value<<21)
}
func (o *SCB_Type) GetACTLR_DISISSCH1() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x3e00000) >> 21
}
func (o *SCB_Type) SetACTLR_DISDYNADD(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x4000000)|value<<26)
}
func (o *SCB_Type) GetACTLR_DISDYNADD() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x4000000) >> 26
}
func (o *SCB_Type) SetACTLR_DISCRITAXIRUW(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x8000000)|value<<27)
}
func (o *SCB_Type) GetACTLR_DISCRITAXIRUW() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x8000000) >> 27
}
func (o *SCB_Type) SetACTLR_DISFPUISSOPT(value uint32) {
	volatile.StoreUint32(&o.ACTLR.Reg, volatile.LoadUint32(&o.ACTLR.Reg)&^(0x10000000)|value<<28)
}
func (o *SCB_Type) GetACTLR_DISFPUISSOPT() uint32 {
	return (volatile.LoadUint32(&o.ACTLR.Reg) & 0x10000000) >> 28
}

// SCB.CPUID: CPUID Base Register
func (o *SCB_Type) SetCPUID_REVISION(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xf)|value)
}
func (o *SCB_Type) GetCPUID_REVISION() uint32 {
	return volatile.LoadUint32(&o.CPUID.Reg) & 0xf
}
func (o *SCB_Type) SetCPUID_PARTNO(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xfff0)|value<<4)
}
func (o *SCB_Type) GetCPUID_PARTNO() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xfff0) >> 4
}
func (o *SCB_Type) SetCPUID_ARCHITECTURE(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xf0000)|value<<16)
}
func (o *SCB_Type) GetCPUID_ARCHITECTURE() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xf0000) >> 16
}
func (o *SCB_Type) SetCPUID_VARIANT(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xf00000)|value<<20)
}
func (o *SCB_Type) GetCPUID_VARIANT() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xf00000) >> 20
}
func (o *SCB_Type) SetCPUID_IMPLEMENTER(value uint32) {
	volatile.StoreUint32(&o.CPUID.Reg, volatile.LoadUint32(&o.CPUID.Reg)&^(0xff000000)|value<<24)
}
func (o *SCB_Type) GetCPUID_IMPLEMENTER() uint32 {
	return (volatile.LoadUint32(&o.CPUID.Reg) & 0xff000000) >> 24
}

// SCB.ICSR: Interrupt Control and State Register
func (o *SCB_Type) SetICSR_VECTACTIVE(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x1ff)|value)
}
func (o *SCB_Type) GetICSR_VECTACTIVE() uint32 {
	return volatile.LoadUint32(&o.ICSR.Reg) & 0x1ff
}
func (o *SCB_Type) SetICSR_RETTOBASE(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x800)|value<<11)
}
func (o *SCB_Type) GetICSR_RETTOBASE() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x800) >> 11
}
func (o *SCB_Type) SetICSR_VECTPENDING(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x1ff000)|value<<12)
}
func (o *SCB_Type) GetICSR_VECTPENDING() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x1ff000) >> 12
}
func (o *SCB_Type) SetICSR_ISRPENDING(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x400000)|value<<22)
}
func (o *SCB_Type) GetICSR_ISRPENDING() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x400000) >> 22
}
func (o *SCB_Type) SetICSR_PENDSTCLR(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x2000000)|value<<25)
}
func (o *SCB_Type) GetICSR_PENDSTCLR() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x2000000) >> 25
}
func (o *SCB_Type) SetICSR_PENDSTSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x4000000)|value<<26)
}
func (o *SCB_Type) GetICSR_PENDSTSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x4000000) >> 26
}
func (o *SCB_Type) SetICSR_PENDSVCLR(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x8000000)|value<<27)
}
func (o *SCB_Type) GetICSR_PENDSVCLR() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x8000000) >> 27
}
func (o *SCB_Type) SetICSR_PENDSVSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x10000000)|value<<28)
}
func (o *SCB_Type) GetICSR_PENDSVSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x10000000) >> 28
}
func (o *SCB_Type) SetICSR_NMIPENDSET(value uint32) {
	volatile.StoreUint32(&o.ICSR.Reg, volatile.LoadUint32(&o.ICSR.Reg)&^(0x80000000)|value<<31)
}
func (o *SCB_Type) GetICSR_NMIPENDSET() uint32 {
	return (volatile.LoadUint32(&o.ICSR.Reg) & 0x80000000) >> 31
}

// SCB.VTOR: Vector Table Offset Register
func (o *SCB_Type) SetVTOR_TBLOFF(value uint32) {
	volatile.StoreUint32(&o.VTOR.Reg, volatile.LoadUint32(&o.VTOR.Reg)&^(0xffffff80)|value<<7)
}
func (o *SCB_Type) GetVTOR_TBLOFF() uint32 {
	return (volatile.LoadUint32(&o.VTOR.Reg) & 0xffffff80) >> 7
}

// SCB.AIRCR: Application Interrupt and Reset Control Register
func (o *SCB_Type) SetAIRCR_VECTRESET(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x1)|value)
}
func (o *SCB_Type) GetAIRCR_VECTRESET() uint32 {
	return volatile.LoadUint32(&o.AIRCR.Reg) & 0x1
}
func (o *SCB_Type) SetAIRCR_VECTCLRACTIVE(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetAIRCR_VECTCLRACTIVE() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetAIRCR_SYSRESETREQ(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x4)|value<<2)
}
func (o *SCB_Type) GetAIRCR_SYSRESETREQ() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x4) >> 2
}
func (o *SCB_Type) SetAIRCR_PRIGROUP(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x700)|value<<8)
}
func (o *SCB_Type) GetAIRCR_PRIGROUP() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x700) >> 8
}
func (o *SCB_Type) SetAIRCR_ENDIANNESS(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0x8000)|value<<15)
}
func (o *SCB_Type) GetAIRCR_ENDIANNESS() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0x8000) >> 15
}
func (o *SCB_Type) SetAIRCR_VECTKEY(value uint32) {
	volatile.StoreUint32(&o.AIRCR.Reg, volatile.LoadUint32(&o.AIRCR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SCB_Type) GetAIRCR_VECTKEY() uint32 {
	return (volatile.LoadUint32(&o.AIRCR.Reg) & 0xffff0000) >> 16
}

// SCB.SCR: System Control Register
func (o *SCB_Type) SetSCR_SLEEPONEXIT(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetSCR_SLEEPONEXIT() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetSCR_SLEEPDEEP(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x4)|value<<2)
}
func (o *SCB_Type) GetSCR_SLEEPDEEP() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x4) >> 2
}
func (o *SCB_Type) SetSCR_SEVONPEND(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *SCB_Type) GetSCR_SEVONPEND() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0x10) >> 4
}

// SCB.CCR: Configuration and Control Register
func (o *SCB_Type) SetCCR_NONBASETHRDENA(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x1)|value)
}
func (o *SCB_Type) GetCCR_NONBASETHRDENA() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0x1
}
func (o *SCB_Type) SetCCR_USERSETMPEND(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetCCR_USERSETMPEND() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetCCR_UNALIGN_TRP(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x8)|value<<3)
}
func (o *SCB_Type) GetCCR_UNALIGN_TRP() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x8) >> 3
}
func (o *SCB_Type) SetCCR_DIV_0_TRP(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x10)|value<<4)
}
func (o *SCB_Type) GetCCR_DIV_0_TRP() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x10) >> 4
}
func (o *SCB_Type) SetCCR_BFHFNMIGN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x100)|value<<8)
}
func (o *SCB_Type) GetCCR_BFHFNMIGN() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x100) >> 8
}
func (o *SCB_Type) SetCCR_STKALIGN(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x200)|value<<9)
}
func (o *SCB_Type) GetCCR_STKALIGN() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x200) >> 9
}
func (o *SCB_Type) SetCCR_DC(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x10000)|value<<16)
}
func (o *SCB_Type) GetCCR_DC() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x10000) >> 16
}
func (o *SCB_Type) SetCCR_IC(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x20000)|value<<17)
}
func (o *SCB_Type) GetCCR_IC() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x20000) >> 17
}
func (o *SCB_Type) SetCCR_BP(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x40000)|value<<18)
}
func (o *SCB_Type) GetCCR_BP() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x40000) >> 18
}

// SCB.SHPR1: System Handler Priority Register 1
func (o *SCB_Type) SetSHPR1_PRI_4(value uint32) {
	volatile.StoreUint32(&o.SHPR1.Reg, volatile.LoadUint32(&o.SHPR1.Reg)&^(0xff)|value)
}
func (o *SCB_Type) GetSHPR1_PRI_4() uint32 {
	return volatile.LoadUint32(&o.SHPR1.Reg) & 0xff
}
func (o *SCB_Type) SetSHPR1_PRI_5(value uint32) {
	volatile.StoreUint32(&o.SHPR1.Reg, volatile.LoadUint32(&o.SHPR1.Reg)&^(0xff00)|value<<8)
}
func (o *SCB_Type) GetSHPR1_PRI_5() uint32 {
	return (volatile.LoadUint32(&o.SHPR1.Reg) & 0xff00) >> 8
}
func (o *SCB_Type) SetSHPR1_PRI_6(value uint32) {
	volatile.StoreUint32(&o.SHPR1.Reg, volatile.LoadUint32(&o.SHPR1.Reg)&^(0xff0000)|value<<16)
}
func (o *SCB_Type) GetSHPR1_PRI_6() uint32 {
	return (volatile.LoadUint32(&o.SHPR1.Reg) & 0xff0000) >> 16
}

// SCB.SHPR2: System Handler Priority Register 2
func (o *SCB_Type) SetSHPR2_PRI_11(value uint32) {
	volatile.StoreUint32(&o.SHPR2.Reg, volatile.LoadUint32(&o.SHPR2.Reg)&^(0xff000000)|value<<24)
}
func (o *SCB_Type) GetSHPR2_PRI_11() uint32 {
	return (volatile.LoadUint32(&o.SHPR2.Reg) & 0xff000000) >> 24
}

// SCB.SHPR3: System Handler Priority Register 3
func (o *SCB_Type) SetSHPR3_PRI_14(value uint32) {
	volatile.StoreUint32(&o.SHPR3.Reg, volatile.LoadUint32(&o.SHPR3.Reg)&^(0xff0000)|value<<16)
}
func (o *SCB_Type) GetSHPR3_PRI_14() uint32 {
	return (volatile.LoadUint32(&o.SHPR3.Reg) & 0xff0000) >> 16
}
func (o *SCB_Type) SetSHPR3_PRI_15(value uint32) {
	volatile.StoreUint32(&o.SHPR3.Reg, volatile.LoadUint32(&o.SHPR3.Reg)&^(0xff000000)|value<<24)
}
func (o *SCB_Type) GetSHPR3_PRI_15() uint32 {
	return (volatile.LoadUint32(&o.SHPR3.Reg) & 0xff000000) >> 24
}

// SCB.SHCSR: System Handler Control and State Register
func (o *SCB_Type) SetSHCSR_MEMFAULTACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x1)|value)
}
func (o *SCB_Type) GetSHCSR_MEMFAULTACT() uint32 {
	return volatile.LoadUint32(&o.SHCSR.Reg) & 0x1
}
func (o *SCB_Type) SetSHCSR_BUSFAULTACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetSHCSR_BUSFAULTACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetSHCSR_USGFAULTACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x8)|value<<3)
}
func (o *SCB_Type) GetSHCSR_USGFAULTACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x8) >> 3
}
func (o *SCB_Type) SetSHCSR_SVCALLACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x80)|value<<7)
}
func (o *SCB_Type) GetSHCSR_SVCALLACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x80) >> 7
}
func (o *SCB_Type) SetSHCSR_MONITORACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x100)|value<<8)
}
func (o *SCB_Type) GetSHCSR_MONITORACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x100) >> 8
}
func (o *SCB_Type) SetSHCSR_PENDSVACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x400)|value<<10)
}
func (o *SCB_Type) GetSHCSR_PENDSVACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x400) >> 10
}
func (o *SCB_Type) SetSHCSR_SYSTICKACT(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x800)|value<<11)
}
func (o *SCB_Type) GetSHCSR_SYSTICKACT() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x800) >> 11
}
func (o *SCB_Type) SetSHCSR_USGFAULTPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x1000)|value<<12)
}
func (o *SCB_Type) GetSHCSR_USGFAULTPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x1000) >> 12
}
func (o *SCB_Type) SetSHCSR_MEMFAULTPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x2000)|value<<13)
}
func (o *SCB_Type) GetSHCSR_MEMFAULTPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x2000) >> 13
}
func (o *SCB_Type) SetSHCSR_BUSFAULTPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x4000)|value<<14)
}
func (o *SCB_Type) GetSHCSR_BUSFAULTPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x4000) >> 14
}
func (o *SCB_Type) SetSHCSR_SVCALLPENDED(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x8000)|value<<15)
}
func (o *SCB_Type) GetSHCSR_SVCALLPENDED() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x8000) >> 15
}
func (o *SCB_Type) SetSHCSR_MEMFAULTENA(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x10000)|value<<16)
}
func (o *SCB_Type) GetSHCSR_MEMFAULTENA() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x10000) >> 16
}
func (o *SCB_Type) SetSHCSR_BUSFAULTENA(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x20000)|value<<17)
}
func (o *SCB_Type) GetSHCSR_BUSFAULTENA() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x20000) >> 17
}
func (o *SCB_Type) SetSHCSR_USGFAULTENA(value uint32) {
	volatile.StoreUint32(&o.SHCSR.Reg, volatile.LoadUint32(&o.SHCSR.Reg)&^(0x40000)|value<<18)
}
func (o *SCB_Type) GetSHCSR_USGFAULTENA() uint32 {
	return (volatile.LoadUint32(&o.SHCSR.Reg) & 0x40000) >> 18
}

// SCB.CFSR: Configurable Fault Status Register
func (o *SCB_Type) SetCFSR_IACCVIOL(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x1)|value)
}
func (o *SCB_Type) GetCFSR_IACCVIOL() uint32 {
	return volatile.LoadUint32(&o.CFSR.Reg) & 0x1
}
func (o *SCB_Type) SetCFSR_DACCVIOL(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetCFSR_DACCVIOL() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetCFSR_MUNSTKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x8)|value<<3)
}
func (o *SCB_Type) GetCFSR_MUNSTKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x8) >> 3
}
func (o *SCB_Type) SetCFSR_MSTKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x10)|value<<4)
}
func (o *SCB_Type) GetCFSR_MSTKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x10) >> 4
}
func (o *SCB_Type) SetCFSR_MLSPERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x20)|value<<5)
}
func (o *SCB_Type) GetCFSR_MLSPERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x20) >> 5
}
func (o *SCB_Type) SetCFSR_MMARVALID(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x80)|value<<7)
}
func (o *SCB_Type) GetCFSR_MMARVALID() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x80) >> 7
}
func (o *SCB_Type) SetCFSR_IBUSERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x100)|value<<8)
}
func (o *SCB_Type) GetCFSR_IBUSERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x100) >> 8
}
func (o *SCB_Type) SetCFSR_PRECISERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x200)|value<<9)
}
func (o *SCB_Type) GetCFSR_PRECISERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x200) >> 9
}
func (o *SCB_Type) SetCFSR_IMPRECISERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x400)|value<<10)
}
func (o *SCB_Type) GetCFSR_IMPRECISERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x400) >> 10
}
func (o *SCB_Type) SetCFSR_UNSTKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x800)|value<<11)
}
func (o *SCB_Type) GetCFSR_UNSTKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x800) >> 11
}
func (o *SCB_Type) SetCFSR_STKERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x1000)|value<<12)
}
func (o *SCB_Type) GetCFSR_STKERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x1000) >> 12
}
func (o *SCB_Type) SetCFSR_LSPERR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x2000)|value<<13)
}
func (o *SCB_Type) GetCFSR_LSPERR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x2000) >> 13
}
func (o *SCB_Type) SetCFSR_BFARVALID(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x8000)|value<<15)
}
func (o *SCB_Type) GetCFSR_BFARVALID() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x8000) >> 15
}
func (o *SCB_Type) SetCFSR_UNDEFINSTR(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x10000)|value<<16)
}
func (o *SCB_Type) GetCFSR_UNDEFINSTR() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x10000) >> 16
}
func (o *SCB_Type) SetCFSR_INVSTATE(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x20000)|value<<17)
}
func (o *SCB_Type) GetCFSR_INVSTATE() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x20000) >> 17
}
func (o *SCB_Type) SetCFSR_INVPC(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x40000)|value<<18)
}
func (o *SCB_Type) GetCFSR_INVPC() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x40000) >> 18
}
func (o *SCB_Type) SetCFSR_NOCP(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x80000)|value<<19)
}
func (o *SCB_Type) GetCFSR_NOCP() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x80000) >> 19
}
func (o *SCB_Type) SetCFSR_UNALIGNED(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x1000000)|value<<24)
}
func (o *SCB_Type) GetCFSR_UNALIGNED() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x1000000) >> 24
}
func (o *SCB_Type) SetCFSR_DIVBYZERO(value uint32) {
	volatile.StoreUint32(&o.CFSR.Reg, volatile.LoadUint32(&o.CFSR.Reg)&^(0x2000000)|value<<25)
}
func (o *SCB_Type) GetCFSR_DIVBYZERO() uint32 {
	return (volatile.LoadUint32(&o.CFSR.Reg) & 0x2000000) >> 25
}

// SCB.HFSR: HardFault Status register
func (o *SCB_Type) SetHFSR_VECTTBL(value uint32) {
	volatile.StoreUint32(&o.HFSR.Reg, volatile.LoadUint32(&o.HFSR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetHFSR_VECTTBL() uint32 {
	return (volatile.LoadUint32(&o.HFSR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetHFSR_FORCED(value uint32) {
	volatile.StoreUint32(&o.HFSR.Reg, volatile.LoadUint32(&o.HFSR.Reg)&^(0x40000000)|value<<30)
}
func (o *SCB_Type) GetHFSR_FORCED() uint32 {
	return (volatile.LoadUint32(&o.HFSR.Reg) & 0x40000000) >> 30
}
func (o *SCB_Type) SetHFSR_DEBUGEVT(value uint32) {
	volatile.StoreUint32(&o.HFSR.Reg, volatile.LoadUint32(&o.HFSR.Reg)&^(0x80000000)|value<<31)
}
func (o *SCB_Type) GetHFSR_DEBUGEVT() uint32 {
	return (volatile.LoadUint32(&o.HFSR.Reg) & 0x80000000) >> 31
}

// SCB.DFSR: Debug Fault Status Register
func (o *SCB_Type) SetDFSR_HALTED(value uint32) {
	volatile.StoreUint32(&o.DFSR.Reg, volatile.LoadUint32(&o.DFSR.Reg)&^(0x1)|value)
}
func (o *SCB_Type) GetDFSR_HALTED() uint32 {
	return volatile.LoadUint32(&o.DFSR.Reg) & 0x1
}
func (o *SCB_Type) SetDFSR_BKPT(value uint32) {
	volatile.StoreUint32(&o.DFSR.Reg, volatile.LoadUint32(&o.DFSR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetDFSR_BKPT() uint32 {
	return (volatile.LoadUint32(&o.DFSR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetDFSR_DWTTRAP(value uint32) {
	volatile.StoreUint32(&o.DFSR.Reg, volatile.LoadUint32(&o.DFSR.Reg)&^(0x4)|value<<2)
}
func (o *SCB_Type) GetDFSR_DWTTRAP() uint32 {
	return (volatile.LoadUint32(&o.DFSR.Reg) & 0x4) >> 2
}
func (o *SCB_Type) SetDFSR_VCATCH(value uint32) {
	volatile.StoreUint32(&o.DFSR.Reg, volatile.LoadUint32(&o.DFSR.Reg)&^(0x8)|value<<3)
}
func (o *SCB_Type) GetDFSR_VCATCH() uint32 {
	return (volatile.LoadUint32(&o.DFSR.Reg) & 0x8) >> 3
}
func (o *SCB_Type) SetDFSR_EXTERNAL(value uint32) {
	volatile.StoreUint32(&o.DFSR.Reg, volatile.LoadUint32(&o.DFSR.Reg)&^(0x10)|value<<4)
}
func (o *SCB_Type) GetDFSR_EXTERNAL() uint32 {
	return (volatile.LoadUint32(&o.DFSR.Reg) & 0x10) >> 4
}

// SCB.MMFAR: MemManage Fault Address Register
func (o *SCB_Type) SetMMFAR(value uint32) {
	volatile.StoreUint32(&o.MMFAR.Reg, value)
}
func (o *SCB_Type) GetMMFAR() uint32 {
	return volatile.LoadUint32(&o.MMFAR.Reg)
}

// SCB.BFAR: BusFault Address Register
func (o *SCB_Type) SetBFAR(value uint32) {
	volatile.StoreUint32(&o.BFAR.Reg, value)
}
func (o *SCB_Type) GetBFAR() uint32 {
	return volatile.LoadUint32(&o.BFAR.Reg)
}

// SCB.ID_PFR0: Processor Feature Register 0
func (o *SCB_Type) SetID_PFR0_STATE0(value uint32) {
	volatile.StoreUint32(&o.ID_PFR0.Reg, volatile.LoadUint32(&o.ID_PFR0.Reg)&^(0xf)|value)
}
func (o *SCB_Type) GetID_PFR0_STATE0() uint32 {
	return volatile.LoadUint32(&o.ID_PFR0.Reg) & 0xf
}
func (o *SCB_Type) SetID_PFR0_STATE1(value uint32) {
	volatile.StoreUint32(&o.ID_PFR0.Reg, volatile.LoadUint32(&o.ID_PFR0.Reg)&^(0xf0)|value<<4)
}
func (o *SCB_Type) GetID_PFR0_STATE1() uint32 {
	return (volatile.LoadUint32(&o.ID_PFR0.Reg) & 0xf0) >> 4
}
func (o *SCB_Type) SetID_PFR0_STATE2(value uint32) {
	volatile.StoreUint32(&o.ID_PFR0.Reg, volatile.LoadUint32(&o.ID_PFR0.Reg)&^(0xf00)|value<<8)
}
func (o *SCB_Type) GetID_PFR0_STATE2() uint32 {
	return (volatile.LoadUint32(&o.ID_PFR0.Reg) & 0xf00) >> 8
}
func (o *SCB_Type) SetID_PFR0_STATE3(value uint32) {
	volatile.StoreUint32(&o.ID_PFR0.Reg, volatile.LoadUint32(&o.ID_PFR0.Reg)&^(0xf000)|value<<12)
}
func (o *SCB_Type) GetID_PFR0_STATE3() uint32 {
	return (volatile.LoadUint32(&o.ID_PFR0.Reg) & 0xf000) >> 12
}

// SCB.ID_PFR1: Processor Feature Register 1
func (o *SCB_Type) SetID_PFR1_PROGMODEL(value uint32) {
	volatile.StoreUint32(&o.ID_PFR1.Reg, volatile.LoadUint32(&o.ID_PFR1.Reg)&^(0xf00)|value<<8)
}
func (o *SCB_Type) GetID_PFR1_PROGMODEL() uint32 {
	return (volatile.LoadUint32(&o.ID_PFR1.Reg) & 0xf00) >> 8
}

// SCB.ID_DFR0: Debug Feature Register
func (o *SCB_Type) SetID_DFR0_DEBUGMODEL(value uint32) {
	volatile.StoreUint32(&o.ID_DFR0.Reg, volatile.LoadUint32(&o.ID_DFR0.Reg)&^(0xf00000)|value<<20)
}
func (o *SCB_Type) GetID_DFR0_DEBUGMODEL() uint32 {
	return (volatile.LoadUint32(&o.ID_DFR0.Reg) & 0xf00000) >> 20
}

// SCB.ID_AFR0: Auxiliary Feature Register
func (o *SCB_Type) SetID_AFR0_IMPLEMENTATION_DEFINED0(value uint32) {
	volatile.StoreUint32(&o.ID_AFR0.Reg, volatile.LoadUint32(&o.ID_AFR0.Reg)&^(0xf)|value)
}
func (o *SCB_Type) GetID_AFR0_IMPLEMENTATION_DEFINED0() uint32 {
	return volatile.LoadUint32(&o.ID_AFR0.Reg) & 0xf
}
func (o *SCB_Type) SetID_AFR0_IMPLEMENTATION_DEFINED1(value uint32) {
	volatile.StoreUint32(&o.ID_AFR0.Reg, volatile.LoadUint32(&o.ID_AFR0.Reg)&^(0xf0)|value<<4)
}
func (o *SCB_Type) GetID_AFR0_IMPLEMENTATION_DEFINED1() uint32 {
	return (volatile.LoadUint32(&o.ID_AFR0.Reg) & 0xf0) >> 4
}
func (o *SCB_Type) SetID_AFR0_IMPLEMENTATION_DEFINED2(value uint32) {
	volatile.StoreUint32(&o.ID_AFR0.Reg, volatile.LoadUint32(&o.ID_AFR0.Reg)&^(0xf00)|value<<8)
}
func (o *SCB_Type) GetID_AFR0_IMPLEMENTATION_DEFINED2() uint32 {
	return (volatile.LoadUint32(&o.ID_AFR0.Reg) & 0xf00) >> 8
}
func (o *SCB_Type) SetID_AFR0_IMPLEMENTATION_DEFINED3(value uint32) {
	volatile.StoreUint32(&o.ID_AFR0.Reg, volatile.LoadUint32(&o.ID_AFR0.Reg)&^(0xf000)|value<<12)
}
func (o *SCB_Type) GetID_AFR0_IMPLEMENTATION_DEFINED3() uint32 {
	return (volatile.LoadUint32(&o.ID_AFR0.Reg) & 0xf000) >> 12
}

// SCB.ID_MMFR0: Memory Model Feature Register 0
func (o *SCB_Type) SetID_MMFR0_PMSASUPPORT(value uint32) {
	volatile.StoreUint32(&o.ID_MMFR0.Reg, volatile.LoadUint32(&o.ID_MMFR0.Reg)&^(0xf0)|value<<4)
}
func (o *SCB_Type) GetID_MMFR0_PMSASUPPORT() uint32 {
	return (volatile.LoadUint32(&o.ID_MMFR0.Reg) & 0xf0) >> 4
}
func (o *SCB_Type) SetID_MMFR0_OUTERMOST_SHAREABILITY(value uint32) {
	volatile.StoreUint32(&o.ID_MMFR0.Reg, volatile.LoadUint32(&o.ID_MMFR0.Reg)&^(0xf00)|value<<8)
}
func (o *SCB_Type) GetID_MMFR0_OUTERMOST_SHAREABILITY() uint32 {
	return (volatile.LoadUint32(&o.ID_MMFR0.Reg) & 0xf00) >> 8
}
func (o *SCB_Type) SetID_MMFR0_SHAREABILITY_LEVELS(value uint32) {
	volatile.StoreUint32(&o.ID_MMFR0.Reg, volatile.LoadUint32(&o.ID_MMFR0.Reg)&^(0xf000)|value<<12)
}
func (o *SCB_Type) GetID_MMFR0_SHAREABILITY_LEVELS() uint32 {
	return (volatile.LoadUint32(&o.ID_MMFR0.Reg) & 0xf000) >> 12
}
func (o *SCB_Type) SetID_MMFR0_TCM_SUPPORT(value uint32) {
	volatile.StoreUint32(&o.ID_MMFR0.Reg, volatile.LoadUint32(&o.ID_MMFR0.Reg)&^(0xf0000)|value<<16)
}
func (o *SCB_Type) GetID_MMFR0_TCM_SUPPORT() uint32 {
	return (volatile.LoadUint32(&o.ID_MMFR0.Reg) & 0xf0000) >> 16
}
func (o *SCB_Type) SetID_MMFR0_AUXILIARY_REGISTERS(value uint32) {
	volatile.StoreUint32(&o.ID_MMFR0.Reg, volatile.LoadUint32(&o.ID_MMFR0.Reg)&^(0xf00000)|value<<20)
}
func (o *SCB_Type) GetID_MMFR0_AUXILIARY_REGISTERS() uint32 {
	return (volatile.LoadUint32(&o.ID_MMFR0.Reg) & 0xf00000) >> 20
}

// SCB.ID_MMFR1: Memory Model Feature Register 1
func (o *SCB_Type) SetID_MMFR1(value uint32) {
	volatile.StoreUint32(&o.ID_MMFR1.Reg, value)
}
func (o *SCB_Type) GetID_MMFR1() uint32 {
	return volatile.LoadUint32(&o.ID_MMFR1.Reg)
}

// SCB.ID_MMFR2: Memory Model Feature Register 2
func (o *SCB_Type) SetID_MMFR2_WFI_STALL(value uint32) {
	volatile.StoreUint32(&o.ID_MMFR2.Reg, volatile.LoadUint32(&o.ID_MMFR2.Reg)&^(0xf000000)|value<<24)
}
func (o *SCB_Type) GetID_MMFR2_WFI_STALL() uint32 {
	return (volatile.LoadUint32(&o.ID_MMFR2.Reg) & 0xf000000) >> 24
}

// SCB.ID_MMFR3: Memory Model Feature Register 3
func (o *SCB_Type) SetID_MMFR3(value uint32) {
	volatile.StoreUint32(&o.ID_MMFR3.Reg, value)
}
func (o *SCB_Type) GetID_MMFR3() uint32 {
	return volatile.LoadUint32(&o.ID_MMFR3.Reg)
}

// SCB.ID_ISAR0: Instruction Set Attributes Register 0
func (o *SCB_Type) SetID_ISAR0_BITCOUNT_INSTRS(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR0.Reg, volatile.LoadUint32(&o.ID_ISAR0.Reg)&^(0xf0)|value<<4)
}
func (o *SCB_Type) GetID_ISAR0_BITCOUNT_INSTRS() uint32 {
	return (volatile.LoadUint32(&o.ID_ISAR0.Reg) & 0xf0) >> 4
}
func (o *SCB_Type) SetID_ISAR0_BITFIELD_INSTRS(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR0.Reg, volatile.LoadUint32(&o.ID_ISAR0.Reg)&^(0xf00)|value<<8)
}
func (o *SCB_Type) GetID_ISAR0_BITFIELD_INSTRS() uint32 {
	return (volatile.LoadUint32(&o.ID_ISAR0.Reg) & 0xf00) >> 8
}
func (o *SCB_Type) SetID_ISAR0_CMPBRANCH_INSTRS(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR0.Reg, volatile.LoadUint32(&o.ID_ISAR0.Reg)&^(0xf000)|value<<12)
}
func (o *SCB_Type) GetID_ISAR0_CMPBRANCH_INSTRS() uint32 {
	return (volatile.LoadUint32(&o.ID_ISAR0.Reg) & 0xf000) >> 12
}
func (o *SCB_Type) SetID_ISAR0_COPROC_INSTRS(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR0.Reg, volatile.LoadUint32(&o.ID_ISAR0.Reg)&^(0xf0000)|value<<16)
}
func (o *SCB_Type) GetID_ISAR0_COPROC_INSTRS() uint32 {
	return (volatile.LoadUint32(&o.ID_ISAR0.Reg) & 0xf0000) >> 16
}
func (o *SCB_Type) SetID_ISAR0_DEBUG_INSTRS(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR0.Reg, volatile.LoadUint32(&o.ID_ISAR0.Reg)&^(0xf00000)|value<<20)
}
func (o *SCB_Type) GetID_ISAR0_DEBUG_INSTRS() uint32 {
	return (volatile.LoadUint32(&o.ID_ISAR0.Reg) & 0xf00000) >> 20
}
func (o *SCB_Type) SetID_ISAR0_DIVIDE_INSTRS(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR0.Reg, volatile.LoadUint32(&o.ID_ISAR0.Reg)&^(0xf000000)|value<<24)
}
func (o *SCB_Type) GetID_ISAR0_DIVIDE_INSTRS() uint32 {
	return (volatile.LoadUint32(&o.ID_ISAR0.Reg) & 0xf000000) >> 24
}

// SCB.ID_ISAR1: Instruction Set Attributes Register 1
func (o *SCB_Type) SetID_ISAR1_EXTEND_INSTRS(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR1.Reg, volatile.LoadUint32(&o.ID_ISAR1.Reg)&^(0xf000)|value<<12)
}
func (o *SCB_Type) GetID_ISAR1_EXTEND_INSTRS() uint32 {
	return (volatile.LoadUint32(&o.ID_ISAR1.Reg) & 0xf000) >> 12
}
func (o *SCB_Type) SetID_ISAR1_IFTHEN_INSTRS(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR1.Reg, volatile.LoadUint32(&o.ID_ISAR1.Reg)&^(0xf0000)|value<<16)
}
func (o *SCB_Type) GetID_ISAR1_IFTHEN_INSTRS() uint32 {
	return (volatile.LoadUint32(&o.ID_ISAR1.Reg) & 0xf0000) >> 16
}
func (o *SCB_Type) SetID_ISAR1_IMMEDIATE_INSTRS(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR1.Reg, volatile.LoadUint32(&o.ID_ISAR1.Reg)&^(0xf00000)|value<<20)
}
func (o *SCB_Type) GetID_ISAR1_IMMEDIATE_INSTRS() uint32 {
	return (volatile.LoadUint32(&o.ID_ISAR1.Reg) & 0xf00000) >> 20
}
func (o *SCB_Type) SetID_ISAR1_INTERWORK_INSTRS(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR1.Reg, volatile.LoadUint32(&o.ID_ISAR1.Reg)&^(0xf000000)|value<<24)
}
func (o *SCB_Type) GetID_ISAR1_INTERWORK_INSTRS() uint32 {
	return (volatile.LoadUint32(&o.ID_ISAR1.Reg) & 0xf000000) >> 24
}

// SCB.ID_ISAR2: Instruction Set Attributes Register 2
func (o *SCB_Type) SetID_ISAR2_LOADSTORE_INSTRS(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR2.Reg, volatile.LoadUint32(&o.ID_ISAR2.Reg)&^(0xf)|value)
}
func (o *SCB_Type) GetID_ISAR2_LOADSTORE_INSTRS() uint32 {
	return volatile.LoadUint32(&o.ID_ISAR2.Reg) & 0xf
}
func (o *SCB_Type) SetID_ISAR2_MEMHINT_INSTRS(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR2.Reg, volatile.LoadUint32(&o.ID_ISAR2.Reg)&^(0xf0)|value<<4)
}
func (o *SCB_Type) GetID_ISAR2_MEMHINT_INSTRS() uint32 {
	return (volatile.LoadUint32(&o.ID_ISAR2.Reg) & 0xf0) >> 4
}
func (o *SCB_Type) SetID_ISAR2_MULTIACCESSINT_INSTRS(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR2.Reg, volatile.LoadUint32(&o.ID_ISAR2.Reg)&^(0xf00)|value<<8)
}
func (o *SCB_Type) GetID_ISAR2_MULTIACCESSINT_INSTRS() uint32 {
	return (volatile.LoadUint32(&o.ID_ISAR2.Reg) & 0xf00) >> 8
}
func (o *SCB_Type) SetID_ISAR2_MULT_INSTRS(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR2.Reg, volatile.LoadUint32(&o.ID_ISAR2.Reg)&^(0xf000)|value<<12)
}
func (o *SCB_Type) GetID_ISAR2_MULT_INSTRS() uint32 {
	return (volatile.LoadUint32(&o.ID_ISAR2.Reg) & 0xf000) >> 12
}
func (o *SCB_Type) SetID_ISAR2_MULTS_INSTRS(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR2.Reg, volatile.LoadUint32(&o.ID_ISAR2.Reg)&^(0xf0000)|value<<16)
}
func (o *SCB_Type) GetID_ISAR2_MULTS_INSTRS() uint32 {
	return (volatile.LoadUint32(&o.ID_ISAR2.Reg) & 0xf0000) >> 16
}
func (o *SCB_Type) SetID_ISAR2_MULTU_INSTRS(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR2.Reg, volatile.LoadUint32(&o.ID_ISAR2.Reg)&^(0xf00000)|value<<20)
}
func (o *SCB_Type) GetID_ISAR2_MULTU_INSTRS() uint32 {
	return (volatile.LoadUint32(&o.ID_ISAR2.Reg) & 0xf00000) >> 20
}
func (o *SCB_Type) SetID_ISAR2_REVERSAL_INSTRS(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR2.Reg, volatile.LoadUint32(&o.ID_ISAR2.Reg)&^(0xf0000000)|value<<28)
}
func (o *SCB_Type) GetID_ISAR2_REVERSAL_INSTRS() uint32 {
	return (volatile.LoadUint32(&o.ID_ISAR2.Reg) & 0xf0000000) >> 28
}

// SCB.ID_ISAR3: Instruction Set Attributes Register 3
func (o *SCB_Type) SetID_ISAR3_SATURATE_INSTRS(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR3.Reg, volatile.LoadUint32(&o.ID_ISAR3.Reg)&^(0xf)|value)
}
func (o *SCB_Type) GetID_ISAR3_SATURATE_INSTRS() uint32 {
	return volatile.LoadUint32(&o.ID_ISAR3.Reg) & 0xf
}
func (o *SCB_Type) SetID_ISAR3_SIMD_INSTRS(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR3.Reg, volatile.LoadUint32(&o.ID_ISAR3.Reg)&^(0xf0)|value<<4)
}
func (o *SCB_Type) GetID_ISAR3_SIMD_INSTRS() uint32 {
	return (volatile.LoadUint32(&o.ID_ISAR3.Reg) & 0xf0) >> 4
}
func (o *SCB_Type) SetID_ISAR3_SVC_INSTRS(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR3.Reg, volatile.LoadUint32(&o.ID_ISAR3.Reg)&^(0xf00)|value<<8)
}
func (o *SCB_Type) GetID_ISAR3_SVC_INSTRS() uint32 {
	return (volatile.LoadUint32(&o.ID_ISAR3.Reg) & 0xf00) >> 8
}
func (o *SCB_Type) SetID_ISAR3_SYNCHPRIM_INSTRS(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR3.Reg, volatile.LoadUint32(&o.ID_ISAR3.Reg)&^(0xf000)|value<<12)
}
func (o *SCB_Type) GetID_ISAR3_SYNCHPRIM_INSTRS() uint32 {
	return (volatile.LoadUint32(&o.ID_ISAR3.Reg) & 0xf000) >> 12
}
func (o *SCB_Type) SetID_ISAR3_TABBRANCH_INSTRS(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR3.Reg, volatile.LoadUint32(&o.ID_ISAR3.Reg)&^(0xf0000)|value<<16)
}
func (o *SCB_Type) GetID_ISAR3_TABBRANCH_INSTRS() uint32 {
	return (volatile.LoadUint32(&o.ID_ISAR3.Reg) & 0xf0000) >> 16
}
func (o *SCB_Type) SetID_ISAR3_THUMBCOPY_INSTRS(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR3.Reg, volatile.LoadUint32(&o.ID_ISAR3.Reg)&^(0xf00000)|value<<20)
}
func (o *SCB_Type) GetID_ISAR3_THUMBCOPY_INSTRS() uint32 {
	return (volatile.LoadUint32(&o.ID_ISAR3.Reg) & 0xf00000) >> 20
}
func (o *SCB_Type) SetID_ISAR3_TRUENOP_INSTRS(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR3.Reg, volatile.LoadUint32(&o.ID_ISAR3.Reg)&^(0xf000000)|value<<24)
}
func (o *SCB_Type) GetID_ISAR3_TRUENOP_INSTRS() uint32 {
	return (volatile.LoadUint32(&o.ID_ISAR3.Reg) & 0xf000000) >> 24
}

// SCB.ID_ISAR4: Instruction Set Attributes Register 4
func (o *SCB_Type) SetID_ISAR4_UNPRIV_INSTRS(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR4.Reg, volatile.LoadUint32(&o.ID_ISAR4.Reg)&^(0xf)|value)
}
func (o *SCB_Type) GetID_ISAR4_UNPRIV_INSTRS() uint32 {
	return volatile.LoadUint32(&o.ID_ISAR4.Reg) & 0xf
}
func (o *SCB_Type) SetID_ISAR4_WITHSHIFTS_INSTRS(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR4.Reg, volatile.LoadUint32(&o.ID_ISAR4.Reg)&^(0xf0)|value<<4)
}
func (o *SCB_Type) GetID_ISAR4_WITHSHIFTS_INSTRS() uint32 {
	return (volatile.LoadUint32(&o.ID_ISAR4.Reg) & 0xf0) >> 4
}
func (o *SCB_Type) SetID_ISAR4_WRITEBACK_INSTRS(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR4.Reg, volatile.LoadUint32(&o.ID_ISAR4.Reg)&^(0xf00)|value<<8)
}
func (o *SCB_Type) GetID_ISAR4_WRITEBACK_INSTRS() uint32 {
	return (volatile.LoadUint32(&o.ID_ISAR4.Reg) & 0xf00) >> 8
}
func (o *SCB_Type) SetID_ISAR4_BARRIER_INSTRS(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR4.Reg, volatile.LoadUint32(&o.ID_ISAR4.Reg)&^(0xf0000)|value<<16)
}
func (o *SCB_Type) GetID_ISAR4_BARRIER_INSTRS() uint32 {
	return (volatile.LoadUint32(&o.ID_ISAR4.Reg) & 0xf0000) >> 16
}
func (o *SCB_Type) SetID_ISAR4_SYNCHPRIM_INSTRS_FRAC(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR4.Reg, volatile.LoadUint32(&o.ID_ISAR4.Reg)&^(0xf00000)|value<<20)
}
func (o *SCB_Type) GetID_ISAR4_SYNCHPRIM_INSTRS_FRAC() uint32 {
	return (volatile.LoadUint32(&o.ID_ISAR4.Reg) & 0xf00000) >> 20
}
func (o *SCB_Type) SetID_ISAR4_PSR_M_INSTRS(value uint32) {
	volatile.StoreUint32(&o.ID_ISAR4.Reg, volatile.LoadUint32(&o.ID_ISAR4.Reg)&^(0xf000000)|value<<24)
}
func (o *SCB_Type) GetID_ISAR4_PSR_M_INSTRS() uint32 {
	return (volatile.LoadUint32(&o.ID_ISAR4.Reg) & 0xf000000) >> 24
}

// SCB.CLIDR: Cache Level ID register
func (o *SCB_Type) SetCLIDR_CL1(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0x7)|value)
}
func (o *SCB_Type) GetCLIDR_CL1() uint32 {
	return volatile.LoadUint32(&o.CLIDR.Reg) & 0x7
}
func (o *SCB_Type) SetCLIDR_CL2(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0x38)|value<<3)
}
func (o *SCB_Type) GetCLIDR_CL2() uint32 {
	return (volatile.LoadUint32(&o.CLIDR.Reg) & 0x38) >> 3
}
func (o *SCB_Type) SetCLIDR_CL3(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0x1c0)|value<<6)
}
func (o *SCB_Type) GetCLIDR_CL3() uint32 {
	return (volatile.LoadUint32(&o.CLIDR.Reg) & 0x1c0) >> 6
}
func (o *SCB_Type) SetCLIDR_CL4(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0xe00)|value<<9)
}
func (o *SCB_Type) GetCLIDR_CL4() uint32 {
	return (volatile.LoadUint32(&o.CLIDR.Reg) & 0xe00) >> 9
}
func (o *SCB_Type) SetCLIDR_CL5(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0x7000)|value<<12)
}
func (o *SCB_Type) GetCLIDR_CL5() uint32 {
	return (volatile.LoadUint32(&o.CLIDR.Reg) & 0x7000) >> 12
}
func (o *SCB_Type) SetCLIDR_CL6(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0x38000)|value<<15)
}
func (o *SCB_Type) GetCLIDR_CL6() uint32 {
	return (volatile.LoadUint32(&o.CLIDR.Reg) & 0x38000) >> 15
}
func (o *SCB_Type) SetCLIDR_CL7(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0x1c0000)|value<<18)
}
func (o *SCB_Type) GetCLIDR_CL7() uint32 {
	return (volatile.LoadUint32(&o.CLIDR.Reg) & 0x1c0000) >> 18
}
func (o *SCB_Type) SetCLIDR_LOUIS(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0xe00000)|value<<21)
}
func (o *SCB_Type) GetCLIDR_LOUIS() uint32 {
	return (volatile.LoadUint32(&o.CLIDR.Reg) & 0xe00000) >> 21
}
func (o *SCB_Type) SetCLIDR_LOC(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0x7000000)|value<<24)
}
func (o *SCB_Type) GetCLIDR_LOC() uint32 {
	return (volatile.LoadUint32(&o.CLIDR.Reg) & 0x7000000) >> 24
}
func (o *SCB_Type) SetCLIDR_LOU(value uint32) {
	volatile.StoreUint32(&o.CLIDR.Reg, volatile.LoadUint32(&o.CLIDR.Reg)&^(0x38000000)|value<<27)
}
func (o *SCB_Type) GetCLIDR_LOU() uint32 {
	return (volatile.LoadUint32(&o.CLIDR.Reg) & 0x38000000) >> 27
}

// SCB.CTR: Cache Type register
func (o *SCB_Type) SetCTR_IMINLINE(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0xf)|value)
}
func (o *SCB_Type) GetCTR_IMINLINE() uint32 {
	return volatile.LoadUint32(&o.CTR.Reg) & 0xf
}
func (o *SCB_Type) SetCTR_DMINLINE(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0xf0000)|value<<16)
}
func (o *SCB_Type) GetCTR_DMINLINE() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0xf0000) >> 16
}
func (o *SCB_Type) SetCTR_ERG(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0xf00000)|value<<20)
}
func (o *SCB_Type) GetCTR_ERG() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0xf00000) >> 20
}
func (o *SCB_Type) SetCTR_CWG(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0xf000000)|value<<24)
}
func (o *SCB_Type) GetCTR_CWG() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0xf000000) >> 24
}
func (o *SCB_Type) SetCTR_FORMAT(value uint32) {
	volatile.StoreUint32(&o.CTR.Reg, volatile.LoadUint32(&o.CTR.Reg)&^(0xe0000000)|value<<29)
}
func (o *SCB_Type) GetCTR_FORMAT() uint32 {
	return (volatile.LoadUint32(&o.CTR.Reg) & 0xe0000000) >> 29
}

// SCB.CCSIDR: Cache Size ID Register
func (o *SCB_Type) SetCCSIDR_LINESIZE(value uint32) {
	volatile.StoreUint32(&o.CCSIDR.Reg, volatile.LoadUint32(&o.CCSIDR.Reg)&^(0x7)|value)
}
func (o *SCB_Type) GetCCSIDR_LINESIZE() uint32 {
	return volatile.LoadUint32(&o.CCSIDR.Reg) & 0x7
}
func (o *SCB_Type) SetCCSIDR_ASSOCIATIVITY(value uint32) {
	volatile.StoreUint32(&o.CCSIDR.Reg, volatile.LoadUint32(&o.CCSIDR.Reg)&^(0x1ff8)|value<<3)
}
func (o *SCB_Type) GetCCSIDR_ASSOCIATIVITY() uint32 {
	return (volatile.LoadUint32(&o.CCSIDR.Reg) & 0x1ff8) >> 3
}
func (o *SCB_Type) SetCCSIDR_NUMSETS(value uint32) {
	volatile.StoreUint32(&o.CCSIDR.Reg, volatile.LoadUint32(&o.CCSIDR.Reg)&^(0xfffe000)|value<<13)
}
func (o *SCB_Type) GetCCSIDR_NUMSETS() uint32 {
	return (volatile.LoadUint32(&o.CCSIDR.Reg) & 0xfffe000) >> 13
}
func (o *SCB_Type) SetCCSIDR_WA(value uint32) {
	volatile.StoreUint32(&o.CCSIDR.Reg, volatile.LoadUint32(&o.CCSIDR.Reg)&^(0x10000000)|value<<28)
}
func (o *SCB_Type) GetCCSIDR_WA() uint32 {
	return (volatile.LoadUint32(&o.CCSIDR.Reg) & 0x10000000) >> 28
}
func (o *SCB_Type) SetCCSIDR_RA(value uint32) {
	volatile.StoreUint32(&o.CCSIDR.Reg, volatile.LoadUint32(&o.CCSIDR.Reg)&^(0x20000000)|value<<29)
}
func (o *SCB_Type) GetCCSIDR_RA() uint32 {
	return (volatile.LoadUint32(&o.CCSIDR.Reg) & 0x20000000) >> 29
}
func (o *SCB_Type) SetCCSIDR_WB(value uint32) {
	volatile.StoreUint32(&o.CCSIDR.Reg, volatile.LoadUint32(&o.CCSIDR.Reg)&^(0x40000000)|value<<30)
}
func (o *SCB_Type) GetCCSIDR_WB() uint32 {
	return (volatile.LoadUint32(&o.CCSIDR.Reg) & 0x40000000) >> 30
}
func (o *SCB_Type) SetCCSIDR_WT(value uint32) {
	volatile.StoreUint32(&o.CCSIDR.Reg, volatile.LoadUint32(&o.CCSIDR.Reg)&^(0x80000000)|value<<31)
}
func (o *SCB_Type) GetCCSIDR_WT() uint32 {
	return (volatile.LoadUint32(&o.CCSIDR.Reg) & 0x80000000) >> 31
}

// SCB.CSSELR: Cache Size Selection Register
func (o *SCB_Type) SetCSSELR_IND(value uint32) {
	volatile.StoreUint32(&o.CSSELR.Reg, volatile.LoadUint32(&o.CSSELR.Reg)&^(0x1)|value)
}
func (o *SCB_Type) GetCSSELR_IND() uint32 {
	return volatile.LoadUint32(&o.CSSELR.Reg) & 0x1
}
func (o *SCB_Type) SetCSSELR_LEVEL(value uint32) {
	volatile.StoreUint32(&o.CSSELR.Reg, volatile.LoadUint32(&o.CSSELR.Reg)&^(0xe)|value<<1)
}
func (o *SCB_Type) GetCSSELR_LEVEL() uint32 {
	return (volatile.LoadUint32(&o.CSSELR.Reg) & 0xe) >> 1
}

// SCB.CPACR: Coprocessor Access Control Register
func (o *SCB_Type) SetCPACR_CP0(value uint32) {
	volatile.StoreUint32(&o.CPACR.Reg, volatile.LoadUint32(&o.CPACR.Reg)&^(0x3)|value)
}
func (o *SCB_Type) GetCPACR_CP0() uint32 {
	return volatile.LoadUint32(&o.CPACR.Reg) & 0x3
}
func (o *SCB_Type) SetCPACR_CP1(value uint32) {
	volatile.StoreUint32(&o.CPACR.Reg, volatile.LoadUint32(&o.CPACR.Reg)&^(0xc)|value<<2)
}
func (o *SCB_Type) GetCPACR_CP1() uint32 {
	return (volatile.LoadUint32(&o.CPACR.Reg) & 0xc) >> 2
}
func (o *SCB_Type) SetCPACR_CP2(value uint32) {
	volatile.StoreUint32(&o.CPACR.Reg, volatile.LoadUint32(&o.CPACR.Reg)&^(0x30)|value<<4)
}
func (o *SCB_Type) GetCPACR_CP2() uint32 {
	return (volatile.LoadUint32(&o.CPACR.Reg) & 0x30) >> 4
}
func (o *SCB_Type) SetCPACR_CP3(value uint32) {
	volatile.StoreUint32(&o.CPACR.Reg, volatile.LoadUint32(&o.CPACR.Reg)&^(0xc0)|value<<6)
}
func (o *SCB_Type) GetCPACR_CP3() uint32 {
	return (volatile.LoadUint32(&o.CPACR.Reg) & 0xc0) >> 6
}
func (o *SCB_Type) SetCPACR_CP4(value uint32) {
	volatile.StoreUint32(&o.CPACR.Reg, volatile.LoadUint32(&o.CPACR.Reg)&^(0x300)|value<<8)
}
func (o *SCB_Type) GetCPACR_CP4() uint32 {
	return (volatile.LoadUint32(&o.CPACR.Reg) & 0x300) >> 8
}
func (o *SCB_Type) SetCPACR_CP5(value uint32) {
	volatile.StoreUint32(&o.CPACR.Reg, volatile.LoadUint32(&o.CPACR.Reg)&^(0xc00)|value<<10)
}
func (o *SCB_Type) GetCPACR_CP5() uint32 {
	return (volatile.LoadUint32(&o.CPACR.Reg) & 0xc00) >> 10
}
func (o *SCB_Type) SetCPACR_CP6(value uint32) {
	volatile.StoreUint32(&o.CPACR.Reg, volatile.LoadUint32(&o.CPACR.Reg)&^(0x3000)|value<<12)
}
func (o *SCB_Type) GetCPACR_CP6() uint32 {
	return (volatile.LoadUint32(&o.CPACR.Reg) & 0x3000) >> 12
}
func (o *SCB_Type) SetCPACR_CP7(value uint32) {
	volatile.StoreUint32(&o.CPACR.Reg, volatile.LoadUint32(&o.CPACR.Reg)&^(0xc000)|value<<14)
}
func (o *SCB_Type) GetCPACR_CP7() uint32 {
	return (volatile.LoadUint32(&o.CPACR.Reg) & 0xc000) >> 14
}
func (o *SCB_Type) SetCPACR_CP10(value uint32) {
	volatile.StoreUint32(&o.CPACR.Reg, volatile.LoadUint32(&o.CPACR.Reg)&^(0x300000)|value<<20)
}
func (o *SCB_Type) GetCPACR_CP10() uint32 {
	return (volatile.LoadUint32(&o.CPACR.Reg) & 0x300000) >> 20
}
func (o *SCB_Type) SetCPACR_CP11(value uint32) {
	volatile.StoreUint32(&o.CPACR.Reg, volatile.LoadUint32(&o.CPACR.Reg)&^(0xc00000)|value<<22)
}
func (o *SCB_Type) GetCPACR_CP11() uint32 {
	return (volatile.LoadUint32(&o.CPACR.Reg) & 0xc00000) >> 22
}

// SCB.STIR: Instruction cache invalidate all to Point of Unification (PoU)
func (o *SCB_Type) SetSTIR_INTID(value uint32) {
	volatile.StoreUint32(&o.STIR.Reg, volatile.LoadUint32(&o.STIR.Reg)&^(0x1ff)|value)
}
func (o *SCB_Type) GetSTIR_INTID() uint32 {
	return volatile.LoadUint32(&o.STIR.Reg) & 0x1ff
}

// SCB.ICIALLU: Instruction cache invalidate all to Point of Unification (PoU)
func (o *SCB_Type) SetICIALLU(value uint32) {
	volatile.StoreUint32(&o.ICIALLU.Reg, value)
}
func (o *SCB_Type) GetICIALLU() uint32 {
	return volatile.LoadUint32(&o.ICIALLU.Reg)
}

// SCB.ICIMVAU: Instruction cache invalidate by address to PoU
func (o *SCB_Type) SetICIMVAU(value uint32) {
	volatile.StoreUint32(&o.ICIMVAU.Reg, value)
}
func (o *SCB_Type) GetICIMVAU() uint32 {
	return volatile.LoadUint32(&o.ICIMVAU.Reg)
}

// SCB.DCIMVAC: Data cache invalidate by address to Point of Coherency (PoC)
func (o *SCB_Type) SetDCIMVAC(value uint32) {
	volatile.StoreUint32(&o.DCIMVAC.Reg, value)
}
func (o *SCB_Type) GetDCIMVAC() uint32 {
	return volatile.LoadUint32(&o.DCIMVAC.Reg)
}

// SCB.DCISW: Data cache invalidate by set/way
func (o *SCB_Type) SetDCISW(value uint32) {
	volatile.StoreUint32(&o.DCISW.Reg, value)
}
func (o *SCB_Type) GetDCISW() uint32 {
	return volatile.LoadUint32(&o.DCISW.Reg)
}

// SCB.DCCMVAU: Data cache by address to PoU
func (o *SCB_Type) SetDCCMVAU(value uint32) {
	volatile.StoreUint32(&o.DCCMVAU.Reg, value)
}
func (o *SCB_Type) GetDCCMVAU() uint32 {
	return volatile.LoadUint32(&o.DCCMVAU.Reg)
}

// SCB.DCCMVAC: Data cache clean by address to PoC
func (o *SCB_Type) SetDCCMVAC(value uint32) {
	volatile.StoreUint32(&o.DCCMVAC.Reg, value)
}
func (o *SCB_Type) GetDCCMVAC() uint32 {
	return volatile.LoadUint32(&o.DCCMVAC.Reg)
}

// SCB.DCCSW: Data cache clean by set/way
func (o *SCB_Type) SetDCCSW(value uint32) {
	volatile.StoreUint32(&o.DCCSW.Reg, value)
}
func (o *SCB_Type) GetDCCSW() uint32 {
	return volatile.LoadUint32(&o.DCCSW.Reg)
}

// SCB.DCCIMVAC: Data cache clean and invalidate by address to PoC
func (o *SCB_Type) SetDCCIMVAC(value uint32) {
	volatile.StoreUint32(&o.DCCIMVAC.Reg, value)
}
func (o *SCB_Type) GetDCCIMVAC() uint32 {
	return volatile.LoadUint32(&o.DCCIMVAC.Reg)
}

// SCB.DCCISW: Data cache clean and invalidate by set/way
func (o *SCB_Type) SetDCCISW(value uint32) {
	volatile.StoreUint32(&o.DCCISW.Reg, value)
}
func (o *SCB_Type) GetDCCISW() uint32 {
	return volatile.LoadUint32(&o.DCCISW.Reg)
}

// SCB.CM7_ITCMCR: Instruction Tightly-Coupled Memory Control Register
func (o *SCB_Type) SetCM7_ITCMCR_EN(value uint32) {
	volatile.StoreUint32(&o.CM7_ITCMCR.Reg, volatile.LoadUint32(&o.CM7_ITCMCR.Reg)&^(0x1)|value)
}
func (o *SCB_Type) GetCM7_ITCMCR_EN() uint32 {
	return volatile.LoadUint32(&o.CM7_ITCMCR.Reg) & 0x1
}
func (o *SCB_Type) SetCM7_ITCMCR_RMW(value uint32) {
	volatile.StoreUint32(&o.CM7_ITCMCR.Reg, volatile.LoadUint32(&o.CM7_ITCMCR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetCM7_ITCMCR_RMW() uint32 {
	return (volatile.LoadUint32(&o.CM7_ITCMCR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetCM7_ITCMCR_RETEN(value uint32) {
	volatile.StoreUint32(&o.CM7_ITCMCR.Reg, volatile.LoadUint32(&o.CM7_ITCMCR.Reg)&^(0x4)|value<<2)
}
func (o *SCB_Type) GetCM7_ITCMCR_RETEN() uint32 {
	return (volatile.LoadUint32(&o.CM7_ITCMCR.Reg) & 0x4) >> 2
}
func (o *SCB_Type) SetCM7_ITCMCR_SZ(value uint32) {
	volatile.StoreUint32(&o.CM7_ITCMCR.Reg, volatile.LoadUint32(&o.CM7_ITCMCR.Reg)&^(0x78)|value<<3)
}
func (o *SCB_Type) GetCM7_ITCMCR_SZ() uint32 {
	return (volatile.LoadUint32(&o.CM7_ITCMCR.Reg) & 0x78) >> 3
}

// SCB.CM7_DTCMCR: Data Tightly-Coupled Memory Control Register
func (o *SCB_Type) SetCM7_DTCMCR_EN(value uint32) {
	volatile.StoreUint32(&o.CM7_DTCMCR.Reg, volatile.LoadUint32(&o.CM7_DTCMCR.Reg)&^(0x1)|value)
}
func (o *SCB_Type) GetCM7_DTCMCR_EN() uint32 {
	return volatile.LoadUint32(&o.CM7_DTCMCR.Reg) & 0x1
}
func (o *SCB_Type) SetCM7_DTCMCR_RMW(value uint32) {
	volatile.StoreUint32(&o.CM7_DTCMCR.Reg, volatile.LoadUint32(&o.CM7_DTCMCR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetCM7_DTCMCR_RMW() uint32 {
	return (volatile.LoadUint32(&o.CM7_DTCMCR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetCM7_DTCMCR_RETEN(value uint32) {
	volatile.StoreUint32(&o.CM7_DTCMCR.Reg, volatile.LoadUint32(&o.CM7_DTCMCR.Reg)&^(0x4)|value<<2)
}
func (o *SCB_Type) GetCM7_DTCMCR_RETEN() uint32 {
	return (volatile.LoadUint32(&o.CM7_DTCMCR.Reg) & 0x4) >> 2
}
func (o *SCB_Type) SetCM7_DTCMCR_SZ(value uint32) {
	volatile.StoreUint32(&o.CM7_DTCMCR.Reg, volatile.LoadUint32(&o.CM7_DTCMCR.Reg)&^(0x78)|value<<3)
}
func (o *SCB_Type) GetCM7_DTCMCR_SZ() uint32 {
	return (volatile.LoadUint32(&o.CM7_DTCMCR.Reg) & 0x78) >> 3
}

// SCB.CM7_AHBPCR: AHBP Control Register
func (o *SCB_Type) SetCM7_AHBPCR_EN(value uint32) {
	volatile.StoreUint32(&o.CM7_AHBPCR.Reg, volatile.LoadUint32(&o.CM7_AHBPCR.Reg)&^(0x1)|value)
}
func (o *SCB_Type) GetCM7_AHBPCR_EN() uint32 {
	return volatile.LoadUint32(&o.CM7_AHBPCR.Reg) & 0x1
}
func (o *SCB_Type) SetCM7_AHBPCR_SZ(value uint32) {
	volatile.StoreUint32(&o.CM7_AHBPCR.Reg, volatile.LoadUint32(&o.CM7_AHBPCR.Reg)&^(0xe)|value<<1)
}
func (o *SCB_Type) GetCM7_AHBPCR_SZ() uint32 {
	return (volatile.LoadUint32(&o.CM7_AHBPCR.Reg) & 0xe) >> 1
}

// SCB.CM7_CACR: L1 Cache Control Register
func (o *SCB_Type) SetCM7_CACR_SIWT(value uint32) {
	volatile.StoreUint32(&o.CM7_CACR.Reg, volatile.LoadUint32(&o.CM7_CACR.Reg)&^(0x1)|value)
}
func (o *SCB_Type) GetCM7_CACR_SIWT() uint32 {
	return volatile.LoadUint32(&o.CM7_CACR.Reg) & 0x1
}
func (o *SCB_Type) SetCM7_CACR_ECCDIS(value uint32) {
	volatile.StoreUint32(&o.CM7_CACR.Reg, volatile.LoadUint32(&o.CM7_CACR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetCM7_CACR_ECCDIS() uint32 {
	return (volatile.LoadUint32(&o.CM7_CACR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetCM7_CACR_FORCEWT(value uint32) {
	volatile.StoreUint32(&o.CM7_CACR.Reg, volatile.LoadUint32(&o.CM7_CACR.Reg)&^(0x4)|value<<2)
}
func (o *SCB_Type) GetCM7_CACR_FORCEWT() uint32 {
	return (volatile.LoadUint32(&o.CM7_CACR.Reg) & 0x4) >> 2
}

// SCB.CM7_AHBSCR: AHB Slave Control Register
func (o *SCB_Type) SetCM7_AHBSCR_CTL(value uint32) {
	volatile.StoreUint32(&o.CM7_AHBSCR.Reg, volatile.LoadUint32(&o.CM7_AHBSCR.Reg)&^(0x3)|value)
}
func (o *SCB_Type) GetCM7_AHBSCR_CTL() uint32 {
	return volatile.LoadUint32(&o.CM7_AHBSCR.Reg) & 0x3
}
func (o *SCB_Type) SetCM7_AHBSCR_TPRI(value uint32) {
	volatile.StoreUint32(&o.CM7_AHBSCR.Reg, volatile.LoadUint32(&o.CM7_AHBSCR.Reg)&^(0x7fc)|value<<2)
}
func (o *SCB_Type) GetCM7_AHBSCR_TPRI() uint32 {
	return (volatile.LoadUint32(&o.CM7_AHBSCR.Reg) & 0x7fc) >> 2
}
func (o *SCB_Type) SetCM7_AHBSCR_INITCOUNT(value uint32) {
	volatile.StoreUint32(&o.CM7_AHBSCR.Reg, volatile.LoadUint32(&o.CM7_AHBSCR.Reg)&^(0xf800)|value<<11)
}
func (o *SCB_Type) GetCM7_AHBSCR_INITCOUNT() uint32 {
	return (volatile.LoadUint32(&o.CM7_AHBSCR.Reg) & 0xf800) >> 11
}

// SCB.CM7_ABFSR: Auxiliary Bus Fault Status Register
func (o *SCB_Type) SetCM7_ABFSR_ITCM(value uint32) {
	volatile.StoreUint32(&o.CM7_ABFSR.Reg, volatile.LoadUint32(&o.CM7_ABFSR.Reg)&^(0x1)|value)
}
func (o *SCB_Type) GetCM7_ABFSR_ITCM() uint32 {
	return volatile.LoadUint32(&o.CM7_ABFSR.Reg) & 0x1
}
func (o *SCB_Type) SetCM7_ABFSR_DTCM(value uint32) {
	volatile.StoreUint32(&o.CM7_ABFSR.Reg, volatile.LoadUint32(&o.CM7_ABFSR.Reg)&^(0x2)|value<<1)
}
func (o *SCB_Type) GetCM7_ABFSR_DTCM() uint32 {
	return (volatile.LoadUint32(&o.CM7_ABFSR.Reg) & 0x2) >> 1
}
func (o *SCB_Type) SetCM7_ABFSR_AHBP(value uint32) {
	volatile.StoreUint32(&o.CM7_ABFSR.Reg, volatile.LoadUint32(&o.CM7_ABFSR.Reg)&^(0x4)|value<<2)
}
func (o *SCB_Type) GetCM7_ABFSR_AHBP() uint32 {
	return (volatile.LoadUint32(&o.CM7_ABFSR.Reg) & 0x4) >> 2
}
func (o *SCB_Type) SetCM7_ABFSR_AXIM(value uint32) {
	volatile.StoreUint32(&o.CM7_ABFSR.Reg, volatile.LoadUint32(&o.CM7_ABFSR.Reg)&^(0x8)|value<<3)
}
func (o *SCB_Type) GetCM7_ABFSR_AXIM() uint32 {
	return (volatile.LoadUint32(&o.CM7_ABFSR.Reg) & 0x8) >> 3
}
func (o *SCB_Type) SetCM7_ABFSR_EPPB(value uint32) {
	volatile.StoreUint32(&o.CM7_ABFSR.Reg, volatile.LoadUint32(&o.CM7_ABFSR.Reg)&^(0x10)|value<<4)
}
func (o *SCB_Type) GetCM7_ABFSR_EPPB() uint32 {
	return (volatile.LoadUint32(&o.CM7_ABFSR.Reg) & 0x10) >> 4
}
func (o *SCB_Type) SetCM7_ABFSR_AXIMTYPE(value uint32) {
	volatile.StoreUint32(&o.CM7_ABFSR.Reg, volatile.LoadUint32(&o.CM7_ABFSR.Reg)&^(0x300)|value<<8)
}
func (o *SCB_Type) GetCM7_ABFSR_AXIMTYPE() uint32 {
	return (volatile.LoadUint32(&o.CM7_ABFSR.Reg) & 0x300) >> 8
}

// Nested Vectored Interrupt Controller
type NVIC_Type struct {
	NVICISER0 volatile.Register32 // 0x0
	NVICISER1 volatile.Register32 // 0x4
	NVICISER2 volatile.Register32 // 0x8
	NVICISER3 volatile.Register32 // 0xC
	_         [112]byte
	NVICICER0 volatile.Register32 // 0x80
	NVICICER1 volatile.Register32 // 0x84
	NVICICER2 volatile.Register32 // 0x88
	NVICICER3 volatile.Register32 // 0x8C
	_         [112]byte
	NVICISPR0 volatile.Register32 // 0x100
	NVICISPR1 volatile.Register32 // 0x104
	NVICISPR2 volatile.Register32 // 0x108
	NVICISPR3 volatile.Register32 // 0x10C
	_         [112]byte
	NVICICPR0 volatile.Register32 // 0x180
	NVICICPR1 volatile.Register32 // 0x184
	NVICICPR2 volatile.Register32 // 0x188
	NVICICPR3 volatile.Register32 // 0x18C
	_         [112]byte
	NVICIABR0 volatile.Register32 // 0x200
	NVICIABR1 volatile.Register32 // 0x204
	NVICIABR2 volatile.Register32 // 0x208
	NVICIABR3 volatile.Register32 // 0x20C
	_         [240]byte
	NVICIP0   volatile.Register8 // 0x300
	NVICIP1   volatile.Register8 // 0x301
	NVICIP2   volatile.Register8 // 0x302
	NVICIP3   volatile.Register8 // 0x303
	NVICIP4   volatile.Register8 // 0x304
	NVICIP5   volatile.Register8 // 0x305
	NVICIP6   volatile.Register8 // 0x306
	NVICIP7   volatile.Register8 // 0x307
	NVICIP8   volatile.Register8 // 0x308
	NVICIP9   volatile.Register8 // 0x309
	NVICIP10  volatile.Register8 // 0x30A
	NVICIP11  volatile.Register8 // 0x30B
	NVICIP12  volatile.Register8 // 0x30C
	NVICIP13  volatile.Register8 // 0x30D
	NVICIP14  volatile.Register8 // 0x30E
	NVICIP15  volatile.Register8 // 0x30F
	NVICIP16  volatile.Register8 // 0x310
	NVICIP17  volatile.Register8 // 0x311
	NVICIP18  volatile.Register8 // 0x312
	NVICIP19  volatile.Register8 // 0x313
	NVICIP20  volatile.Register8 // 0x314
	NVICIP21  volatile.Register8 // 0x315
	NVICIP22  volatile.Register8 // 0x316
	NVICIP23  volatile.Register8 // 0x317
	NVICIP24  volatile.Register8 // 0x318
	NVICIP25  volatile.Register8 // 0x319
	NVICIP26  volatile.Register8 // 0x31A
	NVICIP27  volatile.Register8 // 0x31B
	NVICIP28  volatile.Register8 // 0x31C
	NVICIP29  volatile.Register8 // 0x31D
	NVICIP30  volatile.Register8 // 0x31E
	NVICIP31  volatile.Register8 // 0x31F
	NVICIP32  volatile.Register8 // 0x320
	NVICIP33  volatile.Register8 // 0x321
	NVICIP34  volatile.Register8 // 0x322
	NVICIP35  volatile.Register8 // 0x323
	NVICIP36  volatile.Register8 // 0x324
	NVICIP37  volatile.Register8 // 0x325
	NVICIP38  volatile.Register8 // 0x326
	NVICIP39  volatile.Register8 // 0x327
	NVICIP40  volatile.Register8 // 0x328
	NVICIP41  volatile.Register8 // 0x329
	NVICIP42  volatile.Register8 // 0x32A
	NVICIP43  volatile.Register8 // 0x32B
	NVICIP44  volatile.Register8 // 0x32C
	NVICIP45  volatile.Register8 // 0x32D
	NVICIP46  volatile.Register8 // 0x32E
	NVICIP47  volatile.Register8 // 0x32F
	NVICIP48  volatile.Register8 // 0x330
	NVICIP49  volatile.Register8 // 0x331
	NVICIP50  volatile.Register8 // 0x332
	NVICIP51  volatile.Register8 // 0x333
	NVICIP52  volatile.Register8 // 0x334
	NVICIP53  volatile.Register8 // 0x335
	NVICIP54  volatile.Register8 // 0x336
	NVICIP55  volatile.Register8 // 0x337
	NVICIP56  volatile.Register8 // 0x338
	NVICIP57  volatile.Register8 // 0x339
	NVICIP58  volatile.Register8 // 0x33A
	NVICIP59  volatile.Register8 // 0x33B
	NVICIP60  volatile.Register8 // 0x33C
	NVICIP61  volatile.Register8 // 0x33D
	NVICIP62  volatile.Register8 // 0x33E
	NVICIP63  volatile.Register8 // 0x33F
	NVICIP64  volatile.Register8 // 0x340
	NVICIP65  volatile.Register8 // 0x341
	NVICIP66  volatile.Register8 // 0x342
	NVICIP67  volatile.Register8 // 0x343
	NVICIP68  volatile.Register8 // 0x344
	NVICIP69  volatile.Register8 // 0x345
	NVICIP70  volatile.Register8 // 0x346
	NVICIP71  volatile.Register8 // 0x347
	NVICIP72  volatile.Register8 // 0x348
	NVICIP73  volatile.Register8 // 0x349
	NVICIP74  volatile.Register8 // 0x34A
	NVICIP75  volatile.Register8 // 0x34B
	NVICIP76  volatile.Register8 // 0x34C
	NVICIP77  volatile.Register8 // 0x34D
	NVICIP78  volatile.Register8 // 0x34E
	NVICIP79  volatile.Register8 // 0x34F
	_         [2736]byte
	NVICSTIR  volatile.Register32 // 0xE00
}

// NVIC.NVICISER0: Interrupt Set Enable Register n
func (o *NVIC_Type) SetNVICISER0(value uint32) {
	volatile.StoreUint32(&o.NVICISER0.Reg, value)
}
func (o *NVIC_Type) GetNVICISER0() uint32 {
	return volatile.LoadUint32(&o.NVICISER0.Reg)
}

// NVIC.NVICISER1: Interrupt Set Enable Register n
func (o *NVIC_Type) SetNVICISER1(value uint32) {
	volatile.StoreUint32(&o.NVICISER1.Reg, value)
}
func (o *NVIC_Type) GetNVICISER1() uint32 {
	return volatile.LoadUint32(&o.NVICISER1.Reg)
}

// NVIC.NVICISER2: Interrupt Set Enable Register n
func (o *NVIC_Type) SetNVICISER2(value uint32) {
	volatile.StoreUint32(&o.NVICISER2.Reg, value)
}
func (o *NVIC_Type) GetNVICISER2() uint32 {
	return volatile.LoadUint32(&o.NVICISER2.Reg)
}

// NVIC.NVICISER3: Interrupt Set Enable Register n
func (o *NVIC_Type) SetNVICISER3(value uint32) {
	volatile.StoreUint32(&o.NVICISER3.Reg, value)
}
func (o *NVIC_Type) GetNVICISER3() uint32 {
	return volatile.LoadUint32(&o.NVICISER3.Reg)
}

// NVIC.NVICICER0: Interrupt Clear Enable Register n
func (o *NVIC_Type) SetNVICICER0(value uint32) {
	volatile.StoreUint32(&o.NVICICER0.Reg, value)
}
func (o *NVIC_Type) GetNVICICER0() uint32 {
	return volatile.LoadUint32(&o.NVICICER0.Reg)
}

// NVIC.NVICICER1: Interrupt Clear Enable Register n
func (o *NVIC_Type) SetNVICICER1(value uint32) {
	volatile.StoreUint32(&o.NVICICER1.Reg, value)
}
func (o *NVIC_Type) GetNVICICER1() uint32 {
	return volatile.LoadUint32(&o.NVICICER1.Reg)
}

// NVIC.NVICICER2: Interrupt Clear Enable Register n
func (o *NVIC_Type) SetNVICICER2(value uint32) {
	volatile.StoreUint32(&o.NVICICER2.Reg, value)
}
func (o *NVIC_Type) GetNVICICER2() uint32 {
	return volatile.LoadUint32(&o.NVICICER2.Reg)
}

// NVIC.NVICICER3: Interrupt Clear Enable Register n
func (o *NVIC_Type) SetNVICICER3(value uint32) {
	volatile.StoreUint32(&o.NVICICER3.Reg, value)
}
func (o *NVIC_Type) GetNVICICER3() uint32 {
	return volatile.LoadUint32(&o.NVICICER3.Reg)
}

// NVIC.NVICISPR0: Interrupt Set Pending Register n
func (o *NVIC_Type) SetNVICISPR0(value uint32) {
	volatile.StoreUint32(&o.NVICISPR0.Reg, value)
}
func (o *NVIC_Type) GetNVICISPR0() uint32 {
	return volatile.LoadUint32(&o.NVICISPR0.Reg)
}

// NVIC.NVICISPR1: Interrupt Set Pending Register n
func (o *NVIC_Type) SetNVICISPR1(value uint32) {
	volatile.StoreUint32(&o.NVICISPR1.Reg, value)
}
func (o *NVIC_Type) GetNVICISPR1() uint32 {
	return volatile.LoadUint32(&o.NVICISPR1.Reg)
}

// NVIC.NVICISPR2: Interrupt Set Pending Register n
func (o *NVIC_Type) SetNVICISPR2(value uint32) {
	volatile.StoreUint32(&o.NVICISPR2.Reg, value)
}
func (o *NVIC_Type) GetNVICISPR2() uint32 {
	return volatile.LoadUint32(&o.NVICISPR2.Reg)
}

// NVIC.NVICISPR3: Interrupt Set Pending Register n
func (o *NVIC_Type) SetNVICISPR3(value uint32) {
	volatile.StoreUint32(&o.NVICISPR3.Reg, value)
}
func (o *NVIC_Type) GetNVICISPR3() uint32 {
	return volatile.LoadUint32(&o.NVICISPR3.Reg)
}

// NVIC.NVICICPR0: Interrupt Clear Pending Register n
func (o *NVIC_Type) SetNVICICPR0(value uint32) {
	volatile.StoreUint32(&o.NVICICPR0.Reg, value)
}
func (o *NVIC_Type) GetNVICICPR0() uint32 {
	return volatile.LoadUint32(&o.NVICICPR0.Reg)
}

// NVIC.NVICICPR1: Interrupt Clear Pending Register n
func (o *NVIC_Type) SetNVICICPR1(value uint32) {
	volatile.StoreUint32(&o.NVICICPR1.Reg, value)
}
func (o *NVIC_Type) GetNVICICPR1() uint32 {
	return volatile.LoadUint32(&o.NVICICPR1.Reg)
}

// NVIC.NVICICPR2: Interrupt Clear Pending Register n
func (o *NVIC_Type) SetNVICICPR2(value uint32) {
	volatile.StoreUint32(&o.NVICICPR2.Reg, value)
}
func (o *NVIC_Type) GetNVICICPR2() uint32 {
	return volatile.LoadUint32(&o.NVICICPR2.Reg)
}

// NVIC.NVICICPR3: Interrupt Clear Pending Register n
func (o *NVIC_Type) SetNVICICPR3(value uint32) {
	volatile.StoreUint32(&o.NVICICPR3.Reg, value)
}
func (o *NVIC_Type) GetNVICICPR3() uint32 {
	return volatile.LoadUint32(&o.NVICICPR3.Reg)
}

// NVIC.NVICIABR0: Interrupt Active bit Register n
func (o *NVIC_Type) SetNVICIABR0(value uint32) {
	volatile.StoreUint32(&o.NVICIABR0.Reg, value)
}
func (o *NVIC_Type) GetNVICIABR0() uint32 {
	return volatile.LoadUint32(&o.NVICIABR0.Reg)
}

// NVIC.NVICIABR1: Interrupt Active bit Register n
func (o *NVIC_Type) SetNVICIABR1(value uint32) {
	volatile.StoreUint32(&o.NVICIABR1.Reg, value)
}
func (o *NVIC_Type) GetNVICIABR1() uint32 {
	return volatile.LoadUint32(&o.NVICIABR1.Reg)
}

// NVIC.NVICIABR2: Interrupt Active bit Register n
func (o *NVIC_Type) SetNVICIABR2(value uint32) {
	volatile.StoreUint32(&o.NVICIABR2.Reg, value)
}
func (o *NVIC_Type) GetNVICIABR2() uint32 {
	return volatile.LoadUint32(&o.NVICIABR2.Reg)
}

// NVIC.NVICIABR3: Interrupt Active bit Register n
func (o *NVIC_Type) SetNVICIABR3(value uint32) {
	volatile.StoreUint32(&o.NVICIABR3.Reg, value)
}
func (o *NVIC_Type) GetNVICIABR3() uint32 {
	return volatile.LoadUint32(&o.NVICIABR3.Reg)
}

// NVIC.NVICIP0: Interrupt Priority Register 0
func (o *NVIC_Type) SetNVICIP0_PRI0(value uint8) {
	volatile.StoreUint8(&o.NVICIP0.Reg, volatile.LoadUint8(&o.NVICIP0.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP0_PRI0() uint8 {
	return (volatile.LoadUint8(&o.NVICIP0.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP1: Interrupt Priority Register 1
func (o *NVIC_Type) SetNVICIP1_PRI1(value uint8) {
	volatile.StoreUint8(&o.NVICIP1.Reg, volatile.LoadUint8(&o.NVICIP1.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP1_PRI1() uint8 {
	return (volatile.LoadUint8(&o.NVICIP1.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP2: Interrupt Priority Register 2
func (o *NVIC_Type) SetNVICIP2_PRI2(value uint8) {
	volatile.StoreUint8(&o.NVICIP2.Reg, volatile.LoadUint8(&o.NVICIP2.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP2_PRI2() uint8 {
	return (volatile.LoadUint8(&o.NVICIP2.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP3: Interrupt Priority Register 3
func (o *NVIC_Type) SetNVICIP3_PRI3(value uint8) {
	volatile.StoreUint8(&o.NVICIP3.Reg, volatile.LoadUint8(&o.NVICIP3.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP3_PRI3() uint8 {
	return (volatile.LoadUint8(&o.NVICIP3.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP4: Interrupt Priority Register 4
func (o *NVIC_Type) SetNVICIP4_PRI4(value uint8) {
	volatile.StoreUint8(&o.NVICIP4.Reg, volatile.LoadUint8(&o.NVICIP4.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP4_PRI4() uint8 {
	return (volatile.LoadUint8(&o.NVICIP4.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP5: Interrupt Priority Register 5
func (o *NVIC_Type) SetNVICIP5_PRI5(value uint8) {
	volatile.StoreUint8(&o.NVICIP5.Reg, volatile.LoadUint8(&o.NVICIP5.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP5_PRI5() uint8 {
	return (volatile.LoadUint8(&o.NVICIP5.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP6: Interrupt Priority Register 6
func (o *NVIC_Type) SetNVICIP6_PRI6(value uint8) {
	volatile.StoreUint8(&o.NVICIP6.Reg, volatile.LoadUint8(&o.NVICIP6.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP6_PRI6() uint8 {
	return (volatile.LoadUint8(&o.NVICIP6.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP7: Interrupt Priority Register 7
func (o *NVIC_Type) SetNVICIP7_PRI7(value uint8) {
	volatile.StoreUint8(&o.NVICIP7.Reg, volatile.LoadUint8(&o.NVICIP7.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP7_PRI7() uint8 {
	return (volatile.LoadUint8(&o.NVICIP7.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP8: Interrupt Priority Register 8
func (o *NVIC_Type) SetNVICIP8_PRI8(value uint8) {
	volatile.StoreUint8(&o.NVICIP8.Reg, volatile.LoadUint8(&o.NVICIP8.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP8_PRI8() uint8 {
	return (volatile.LoadUint8(&o.NVICIP8.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP9: Interrupt Priority Register 9
func (o *NVIC_Type) SetNVICIP9_PRI9(value uint8) {
	volatile.StoreUint8(&o.NVICIP9.Reg, volatile.LoadUint8(&o.NVICIP9.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP9_PRI9() uint8 {
	return (volatile.LoadUint8(&o.NVICIP9.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP10: Interrupt Priority Register 10
func (o *NVIC_Type) SetNVICIP10_PRI10(value uint8) {
	volatile.StoreUint8(&o.NVICIP10.Reg, volatile.LoadUint8(&o.NVICIP10.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP10_PRI10() uint8 {
	return (volatile.LoadUint8(&o.NVICIP10.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP11: Interrupt Priority Register 11
func (o *NVIC_Type) SetNVICIP11_PRI11(value uint8) {
	volatile.StoreUint8(&o.NVICIP11.Reg, volatile.LoadUint8(&o.NVICIP11.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP11_PRI11() uint8 {
	return (volatile.LoadUint8(&o.NVICIP11.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP12: Interrupt Priority Register 12
func (o *NVIC_Type) SetNVICIP12_PRI12(value uint8) {
	volatile.StoreUint8(&o.NVICIP12.Reg, volatile.LoadUint8(&o.NVICIP12.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP12_PRI12() uint8 {
	return (volatile.LoadUint8(&o.NVICIP12.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP13: Interrupt Priority Register 13
func (o *NVIC_Type) SetNVICIP13_PRI13(value uint8) {
	volatile.StoreUint8(&o.NVICIP13.Reg, volatile.LoadUint8(&o.NVICIP13.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP13_PRI13() uint8 {
	return (volatile.LoadUint8(&o.NVICIP13.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP14: Interrupt Priority Register 14
func (o *NVIC_Type) SetNVICIP14_PRI14(value uint8) {
	volatile.StoreUint8(&o.NVICIP14.Reg, volatile.LoadUint8(&o.NVICIP14.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP14_PRI14() uint8 {
	return (volatile.LoadUint8(&o.NVICIP14.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP15: Interrupt Priority Register 15
func (o *NVIC_Type) SetNVICIP15_PRI15(value uint8) {
	volatile.StoreUint8(&o.NVICIP15.Reg, volatile.LoadUint8(&o.NVICIP15.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP15_PRI15() uint8 {
	return (volatile.LoadUint8(&o.NVICIP15.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP16: Interrupt Priority Register 16
func (o *NVIC_Type) SetNVICIP16_PRI16(value uint8) {
	volatile.StoreUint8(&o.NVICIP16.Reg, volatile.LoadUint8(&o.NVICIP16.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP16_PRI16() uint8 {
	return (volatile.LoadUint8(&o.NVICIP16.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP17: Interrupt Priority Register 17
func (o *NVIC_Type) SetNVICIP17_PRI17(value uint8) {
	volatile.StoreUint8(&o.NVICIP17.Reg, volatile.LoadUint8(&o.NVICIP17.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP17_PRI17() uint8 {
	return (volatile.LoadUint8(&o.NVICIP17.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP18: Interrupt Priority Register 18
func (o *NVIC_Type) SetNVICIP18_PRI18(value uint8) {
	volatile.StoreUint8(&o.NVICIP18.Reg, volatile.LoadUint8(&o.NVICIP18.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP18_PRI18() uint8 {
	return (volatile.LoadUint8(&o.NVICIP18.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP19: Interrupt Priority Register 19
func (o *NVIC_Type) SetNVICIP19_PRI19(value uint8) {
	volatile.StoreUint8(&o.NVICIP19.Reg, volatile.LoadUint8(&o.NVICIP19.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP19_PRI19() uint8 {
	return (volatile.LoadUint8(&o.NVICIP19.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP20: Interrupt Priority Register 20
func (o *NVIC_Type) SetNVICIP20_PRI20(value uint8) {
	volatile.StoreUint8(&o.NVICIP20.Reg, volatile.LoadUint8(&o.NVICIP20.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP20_PRI20() uint8 {
	return (volatile.LoadUint8(&o.NVICIP20.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP21: Interrupt Priority Register 21
func (o *NVIC_Type) SetNVICIP21_PRI21(value uint8) {
	volatile.StoreUint8(&o.NVICIP21.Reg, volatile.LoadUint8(&o.NVICIP21.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP21_PRI21() uint8 {
	return (volatile.LoadUint8(&o.NVICIP21.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP22: Interrupt Priority Register 22
func (o *NVIC_Type) SetNVICIP22_PRI22(value uint8) {
	volatile.StoreUint8(&o.NVICIP22.Reg, volatile.LoadUint8(&o.NVICIP22.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP22_PRI22() uint8 {
	return (volatile.LoadUint8(&o.NVICIP22.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP23: Interrupt Priority Register 23
func (o *NVIC_Type) SetNVICIP23_PRI23(value uint8) {
	volatile.StoreUint8(&o.NVICIP23.Reg, volatile.LoadUint8(&o.NVICIP23.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP23_PRI23() uint8 {
	return (volatile.LoadUint8(&o.NVICIP23.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP24: Interrupt Priority Register 24
func (o *NVIC_Type) SetNVICIP24_PRI24(value uint8) {
	volatile.StoreUint8(&o.NVICIP24.Reg, volatile.LoadUint8(&o.NVICIP24.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP24_PRI24() uint8 {
	return (volatile.LoadUint8(&o.NVICIP24.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP25: Interrupt Priority Register 25
func (o *NVIC_Type) SetNVICIP25_PRI25(value uint8) {
	volatile.StoreUint8(&o.NVICIP25.Reg, volatile.LoadUint8(&o.NVICIP25.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP25_PRI25() uint8 {
	return (volatile.LoadUint8(&o.NVICIP25.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP26: Interrupt Priority Register 26
func (o *NVIC_Type) SetNVICIP26_PRI26(value uint8) {
	volatile.StoreUint8(&o.NVICIP26.Reg, volatile.LoadUint8(&o.NVICIP26.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP26_PRI26() uint8 {
	return (volatile.LoadUint8(&o.NVICIP26.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP27: Interrupt Priority Register 27
func (o *NVIC_Type) SetNVICIP27_PRI27(value uint8) {
	volatile.StoreUint8(&o.NVICIP27.Reg, volatile.LoadUint8(&o.NVICIP27.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP27_PRI27() uint8 {
	return (volatile.LoadUint8(&o.NVICIP27.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP28: Interrupt Priority Register 28
func (o *NVIC_Type) SetNVICIP28_PRI28(value uint8) {
	volatile.StoreUint8(&o.NVICIP28.Reg, volatile.LoadUint8(&o.NVICIP28.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP28_PRI28() uint8 {
	return (volatile.LoadUint8(&o.NVICIP28.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP29: Interrupt Priority Register 29
func (o *NVIC_Type) SetNVICIP29_PRI29(value uint8) {
	volatile.StoreUint8(&o.NVICIP29.Reg, volatile.LoadUint8(&o.NVICIP29.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP29_PRI29() uint8 {
	return (volatile.LoadUint8(&o.NVICIP29.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP30: Interrupt Priority Register 30
func (o *NVIC_Type) SetNVICIP30_PRI30(value uint8) {
	volatile.StoreUint8(&o.NVICIP30.Reg, volatile.LoadUint8(&o.NVICIP30.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP30_PRI30() uint8 {
	return (volatile.LoadUint8(&o.NVICIP30.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP31: Interrupt Priority Register 31
func (o *NVIC_Type) SetNVICIP31_PRI31(value uint8) {
	volatile.StoreUint8(&o.NVICIP31.Reg, volatile.LoadUint8(&o.NVICIP31.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP31_PRI31() uint8 {
	return (volatile.LoadUint8(&o.NVICIP31.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP32: Interrupt Priority Register 32
func (o *NVIC_Type) SetNVICIP32_PRI32(value uint8) {
	volatile.StoreUint8(&o.NVICIP32.Reg, volatile.LoadUint8(&o.NVICIP32.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP32_PRI32() uint8 {
	return (volatile.LoadUint8(&o.NVICIP32.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP33: Interrupt Priority Register 33
func (o *NVIC_Type) SetNVICIP33_PRI33(value uint8) {
	volatile.StoreUint8(&o.NVICIP33.Reg, volatile.LoadUint8(&o.NVICIP33.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP33_PRI33() uint8 {
	return (volatile.LoadUint8(&o.NVICIP33.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP34: Interrupt Priority Register 34
func (o *NVIC_Type) SetNVICIP34_PRI34(value uint8) {
	volatile.StoreUint8(&o.NVICIP34.Reg, volatile.LoadUint8(&o.NVICIP34.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP34_PRI34() uint8 {
	return (volatile.LoadUint8(&o.NVICIP34.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP35: Interrupt Priority Register 35
func (o *NVIC_Type) SetNVICIP35_PRI35(value uint8) {
	volatile.StoreUint8(&o.NVICIP35.Reg, volatile.LoadUint8(&o.NVICIP35.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP35_PRI35() uint8 {
	return (volatile.LoadUint8(&o.NVICIP35.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP36: Interrupt Priority Register 36
func (o *NVIC_Type) SetNVICIP36_PRI36(value uint8) {
	volatile.StoreUint8(&o.NVICIP36.Reg, volatile.LoadUint8(&o.NVICIP36.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP36_PRI36() uint8 {
	return (volatile.LoadUint8(&o.NVICIP36.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP37: Interrupt Priority Register 37
func (o *NVIC_Type) SetNVICIP37_PRI37(value uint8) {
	volatile.StoreUint8(&o.NVICIP37.Reg, volatile.LoadUint8(&o.NVICIP37.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP37_PRI37() uint8 {
	return (volatile.LoadUint8(&o.NVICIP37.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP38: Interrupt Priority Register 38
func (o *NVIC_Type) SetNVICIP38_PRI38(value uint8) {
	volatile.StoreUint8(&o.NVICIP38.Reg, volatile.LoadUint8(&o.NVICIP38.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP38_PRI38() uint8 {
	return (volatile.LoadUint8(&o.NVICIP38.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP39: Interrupt Priority Register 39
func (o *NVIC_Type) SetNVICIP39_PRI39(value uint8) {
	volatile.StoreUint8(&o.NVICIP39.Reg, volatile.LoadUint8(&o.NVICIP39.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP39_PRI39() uint8 {
	return (volatile.LoadUint8(&o.NVICIP39.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP40: Interrupt Priority Register 40
func (o *NVIC_Type) SetNVICIP40_PRI40(value uint8) {
	volatile.StoreUint8(&o.NVICIP40.Reg, volatile.LoadUint8(&o.NVICIP40.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP40_PRI40() uint8 {
	return (volatile.LoadUint8(&o.NVICIP40.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP41: Interrupt Priority Register 41
func (o *NVIC_Type) SetNVICIP41_PRI41(value uint8) {
	volatile.StoreUint8(&o.NVICIP41.Reg, volatile.LoadUint8(&o.NVICIP41.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP41_PRI41() uint8 {
	return (volatile.LoadUint8(&o.NVICIP41.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP42: Interrupt Priority Register 42
func (o *NVIC_Type) SetNVICIP42_PRI42(value uint8) {
	volatile.StoreUint8(&o.NVICIP42.Reg, volatile.LoadUint8(&o.NVICIP42.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP42_PRI42() uint8 {
	return (volatile.LoadUint8(&o.NVICIP42.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP43: Interrupt Priority Register 43
func (o *NVIC_Type) SetNVICIP43_PRI43(value uint8) {
	volatile.StoreUint8(&o.NVICIP43.Reg, volatile.LoadUint8(&o.NVICIP43.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP43_PRI43() uint8 {
	return (volatile.LoadUint8(&o.NVICIP43.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP44: Interrupt Priority Register 44
func (o *NVIC_Type) SetNVICIP44_PRI44(value uint8) {
	volatile.StoreUint8(&o.NVICIP44.Reg, volatile.LoadUint8(&o.NVICIP44.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP44_PRI44() uint8 {
	return (volatile.LoadUint8(&o.NVICIP44.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP45: Interrupt Priority Register 45
func (o *NVIC_Type) SetNVICIP45_PRI45(value uint8) {
	volatile.StoreUint8(&o.NVICIP45.Reg, volatile.LoadUint8(&o.NVICIP45.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP45_PRI45() uint8 {
	return (volatile.LoadUint8(&o.NVICIP45.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP46: Interrupt Priority Register 46
func (o *NVIC_Type) SetNVICIP46_PRI46(value uint8) {
	volatile.StoreUint8(&o.NVICIP46.Reg, volatile.LoadUint8(&o.NVICIP46.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP46_PRI46() uint8 {
	return (volatile.LoadUint8(&o.NVICIP46.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP47: Interrupt Priority Register 47
func (o *NVIC_Type) SetNVICIP47_PRI47(value uint8) {
	volatile.StoreUint8(&o.NVICIP47.Reg, volatile.LoadUint8(&o.NVICIP47.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP47_PRI47() uint8 {
	return (volatile.LoadUint8(&o.NVICIP47.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP48: Interrupt Priority Register 48
func (o *NVIC_Type) SetNVICIP48_PRI48(value uint8) {
	volatile.StoreUint8(&o.NVICIP48.Reg, volatile.LoadUint8(&o.NVICIP48.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP48_PRI48() uint8 {
	return (volatile.LoadUint8(&o.NVICIP48.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP49: Interrupt Priority Register 49
func (o *NVIC_Type) SetNVICIP49_PRI49(value uint8) {
	volatile.StoreUint8(&o.NVICIP49.Reg, volatile.LoadUint8(&o.NVICIP49.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP49_PRI49() uint8 {
	return (volatile.LoadUint8(&o.NVICIP49.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP50: Interrupt Priority Register 50
func (o *NVIC_Type) SetNVICIP50_PRI50(value uint8) {
	volatile.StoreUint8(&o.NVICIP50.Reg, volatile.LoadUint8(&o.NVICIP50.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP50_PRI50() uint8 {
	return (volatile.LoadUint8(&o.NVICIP50.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP51: Interrupt Priority Register 51
func (o *NVIC_Type) SetNVICIP51_PRI51(value uint8) {
	volatile.StoreUint8(&o.NVICIP51.Reg, volatile.LoadUint8(&o.NVICIP51.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP51_PRI51() uint8 {
	return (volatile.LoadUint8(&o.NVICIP51.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP52: Interrupt Priority Register 52
func (o *NVIC_Type) SetNVICIP52_PRI52(value uint8) {
	volatile.StoreUint8(&o.NVICIP52.Reg, volatile.LoadUint8(&o.NVICIP52.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP52_PRI52() uint8 {
	return (volatile.LoadUint8(&o.NVICIP52.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP53: Interrupt Priority Register 53
func (o *NVIC_Type) SetNVICIP53_PRI53(value uint8) {
	volatile.StoreUint8(&o.NVICIP53.Reg, volatile.LoadUint8(&o.NVICIP53.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP53_PRI53() uint8 {
	return (volatile.LoadUint8(&o.NVICIP53.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP54: Interrupt Priority Register 54
func (o *NVIC_Type) SetNVICIP54_PRI54(value uint8) {
	volatile.StoreUint8(&o.NVICIP54.Reg, volatile.LoadUint8(&o.NVICIP54.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP54_PRI54() uint8 {
	return (volatile.LoadUint8(&o.NVICIP54.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP55: Interrupt Priority Register 55
func (o *NVIC_Type) SetNVICIP55_PRI55(value uint8) {
	volatile.StoreUint8(&o.NVICIP55.Reg, volatile.LoadUint8(&o.NVICIP55.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP55_PRI55() uint8 {
	return (volatile.LoadUint8(&o.NVICIP55.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP56: Interrupt Priority Register 56
func (o *NVIC_Type) SetNVICIP56_PRI56(value uint8) {
	volatile.StoreUint8(&o.NVICIP56.Reg, volatile.LoadUint8(&o.NVICIP56.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP56_PRI56() uint8 {
	return (volatile.LoadUint8(&o.NVICIP56.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP57: Interrupt Priority Register 57
func (o *NVIC_Type) SetNVICIP57_PRI57(value uint8) {
	volatile.StoreUint8(&o.NVICIP57.Reg, volatile.LoadUint8(&o.NVICIP57.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP57_PRI57() uint8 {
	return (volatile.LoadUint8(&o.NVICIP57.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP58: Interrupt Priority Register 58
func (o *NVIC_Type) SetNVICIP58_PRI58(value uint8) {
	volatile.StoreUint8(&o.NVICIP58.Reg, volatile.LoadUint8(&o.NVICIP58.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP58_PRI58() uint8 {
	return (volatile.LoadUint8(&o.NVICIP58.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP59: Interrupt Priority Register 59
func (o *NVIC_Type) SetNVICIP59_PRI59(value uint8) {
	volatile.StoreUint8(&o.NVICIP59.Reg, volatile.LoadUint8(&o.NVICIP59.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP59_PRI59() uint8 {
	return (volatile.LoadUint8(&o.NVICIP59.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP60: Interrupt Priority Register 60
func (o *NVIC_Type) SetNVICIP60_PRI60(value uint8) {
	volatile.StoreUint8(&o.NVICIP60.Reg, volatile.LoadUint8(&o.NVICIP60.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP60_PRI60() uint8 {
	return (volatile.LoadUint8(&o.NVICIP60.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP61: Interrupt Priority Register 61
func (o *NVIC_Type) SetNVICIP61_PRI61(value uint8) {
	volatile.StoreUint8(&o.NVICIP61.Reg, volatile.LoadUint8(&o.NVICIP61.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP61_PRI61() uint8 {
	return (volatile.LoadUint8(&o.NVICIP61.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP62: Interrupt Priority Register 62
func (o *NVIC_Type) SetNVICIP62_PRI62(value uint8) {
	volatile.StoreUint8(&o.NVICIP62.Reg, volatile.LoadUint8(&o.NVICIP62.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP62_PRI62() uint8 {
	return (volatile.LoadUint8(&o.NVICIP62.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP63: Interrupt Priority Register 63
func (o *NVIC_Type) SetNVICIP63_PRI63(value uint8) {
	volatile.StoreUint8(&o.NVICIP63.Reg, volatile.LoadUint8(&o.NVICIP63.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP63_PRI63() uint8 {
	return (volatile.LoadUint8(&o.NVICIP63.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP64: Interrupt Priority Register 64
func (o *NVIC_Type) SetNVICIP64_PRI64(value uint8) {
	volatile.StoreUint8(&o.NVICIP64.Reg, volatile.LoadUint8(&o.NVICIP64.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP64_PRI64() uint8 {
	return (volatile.LoadUint8(&o.NVICIP64.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP65: Interrupt Priority Register 65
func (o *NVIC_Type) SetNVICIP65_PRI65(value uint8) {
	volatile.StoreUint8(&o.NVICIP65.Reg, volatile.LoadUint8(&o.NVICIP65.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP65_PRI65() uint8 {
	return (volatile.LoadUint8(&o.NVICIP65.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP66: Interrupt Priority Register 66
func (o *NVIC_Type) SetNVICIP66_PRI66(value uint8) {
	volatile.StoreUint8(&o.NVICIP66.Reg, volatile.LoadUint8(&o.NVICIP66.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP66_PRI66() uint8 {
	return (volatile.LoadUint8(&o.NVICIP66.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP67: Interrupt Priority Register 67
func (o *NVIC_Type) SetNVICIP67_PRI67(value uint8) {
	volatile.StoreUint8(&o.NVICIP67.Reg, volatile.LoadUint8(&o.NVICIP67.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP67_PRI67() uint8 {
	return (volatile.LoadUint8(&o.NVICIP67.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP68: Interrupt Priority Register 68
func (o *NVIC_Type) SetNVICIP68_PRI68(value uint8) {
	volatile.StoreUint8(&o.NVICIP68.Reg, volatile.LoadUint8(&o.NVICIP68.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP68_PRI68() uint8 {
	return (volatile.LoadUint8(&o.NVICIP68.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP69: Interrupt Priority Register 69
func (o *NVIC_Type) SetNVICIP69_PRI69(value uint8) {
	volatile.StoreUint8(&o.NVICIP69.Reg, volatile.LoadUint8(&o.NVICIP69.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP69_PRI69() uint8 {
	return (volatile.LoadUint8(&o.NVICIP69.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP70: Interrupt Priority Register 70
func (o *NVIC_Type) SetNVICIP70_PRI70(value uint8) {
	volatile.StoreUint8(&o.NVICIP70.Reg, volatile.LoadUint8(&o.NVICIP70.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP70_PRI70() uint8 {
	return (volatile.LoadUint8(&o.NVICIP70.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP71: Interrupt Priority Register 71
func (o *NVIC_Type) SetNVICIP71_PRI71(value uint8) {
	volatile.StoreUint8(&o.NVICIP71.Reg, volatile.LoadUint8(&o.NVICIP71.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP71_PRI71() uint8 {
	return (volatile.LoadUint8(&o.NVICIP71.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP72: Interrupt Priority Register 72
func (o *NVIC_Type) SetNVICIP72_PRI72(value uint8) {
	volatile.StoreUint8(&o.NVICIP72.Reg, volatile.LoadUint8(&o.NVICIP72.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP72_PRI72() uint8 {
	return (volatile.LoadUint8(&o.NVICIP72.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP73: Interrupt Priority Register 73
func (o *NVIC_Type) SetNVICIP73_PRI73(value uint8) {
	volatile.StoreUint8(&o.NVICIP73.Reg, volatile.LoadUint8(&o.NVICIP73.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP73_PRI73() uint8 {
	return (volatile.LoadUint8(&o.NVICIP73.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP74: Interrupt Priority Register 74
func (o *NVIC_Type) SetNVICIP74_PRI74(value uint8) {
	volatile.StoreUint8(&o.NVICIP74.Reg, volatile.LoadUint8(&o.NVICIP74.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP74_PRI74() uint8 {
	return (volatile.LoadUint8(&o.NVICIP74.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP75: Interrupt Priority Register 75
func (o *NVIC_Type) SetNVICIP75_PRI75(value uint8) {
	volatile.StoreUint8(&o.NVICIP75.Reg, volatile.LoadUint8(&o.NVICIP75.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP75_PRI75() uint8 {
	return (volatile.LoadUint8(&o.NVICIP75.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP76: Interrupt Priority Register 76
func (o *NVIC_Type) SetNVICIP76_PRI76(value uint8) {
	volatile.StoreUint8(&o.NVICIP76.Reg, volatile.LoadUint8(&o.NVICIP76.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP76_PRI76() uint8 {
	return (volatile.LoadUint8(&o.NVICIP76.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP77: Interrupt Priority Register 77
func (o *NVIC_Type) SetNVICIP77_PRI77(value uint8) {
	volatile.StoreUint8(&o.NVICIP77.Reg, volatile.LoadUint8(&o.NVICIP77.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP77_PRI77() uint8 {
	return (volatile.LoadUint8(&o.NVICIP77.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP78: Interrupt Priority Register 78
func (o *NVIC_Type) SetNVICIP78_PRI78(value uint8) {
	volatile.StoreUint8(&o.NVICIP78.Reg, volatile.LoadUint8(&o.NVICIP78.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP78_PRI78() uint8 {
	return (volatile.LoadUint8(&o.NVICIP78.Reg) & 0xf0) >> 4
}

// NVIC.NVICIP79: Interrupt Priority Register 79
func (o *NVIC_Type) SetNVICIP79_PRI79(value uint8) {
	volatile.StoreUint8(&o.NVICIP79.Reg, volatile.LoadUint8(&o.NVICIP79.Reg)&^(0xf0)|value<<4)
}
func (o *NVIC_Type) GetNVICIP79_PRI79() uint8 {
	return (volatile.LoadUint8(&o.NVICIP79.Reg) & 0xf0) >> 4
}

// NVIC.NVICSTIR: Software Trigger Interrupt Register
func (o *NVIC_Type) SetNVICSTIR_INTID(value uint32) {
	volatile.StoreUint32(&o.NVICSTIR.Reg, volatile.LoadUint32(&o.NVICSTIR.Reg)&^(0x1ff)|value)
}
func (o *NVIC_Type) GetNVICSTIR_INTID() uint32 {
	return volatile.LoadUint32(&o.NVICSTIR.Reg) & 0x1ff
}

// Constants for AIPSTZ1: AIPSTZ Control Registers
const (
	// MPR: Master Priviledge Registers
	// Position of MPROT5 field.
	AIPSTZ_MPR_MPROT5_Pos = 0x8
	// Bit mask of MPROT5 field.
	AIPSTZ_MPR_MPROT5_Msk = 0xf00
	// Accesses from this master are forced to user-mode (ips_supervisor_access is forced to zero) regardless of the hprot[1] access attribute.
	AIPSTZ_MPR_MPROT5_MPL0 = 0x0
	// Accesses from this master are not forced to user-mode. The hprot[1] access attribute is used directly to determine ips_supervisor_access.
	AIPSTZ_MPR_MPROT5_MPL1 = 0x1
	// Position of MPROT3 field.
	AIPSTZ_MPR_MPROT3_Pos = 0x10
	// Bit mask of MPROT3 field.
	AIPSTZ_MPR_MPROT3_Msk = 0xf0000
	// Accesses from this master are forced to user-mode (ips_supervisor_access is forced to zero) regardless of the hprot[1] access attribute.
	AIPSTZ_MPR_MPROT3_MPL0 = 0x0
	// Accesses from this master are not forced to user-mode. The hprot[1] access attribute is used directly to determine ips_supervisor_access.
	AIPSTZ_MPR_MPROT3_MPL1 = 0x1
	// Position of MPROT2 field.
	AIPSTZ_MPR_MPROT2_Pos = 0x14
	// Bit mask of MPROT2 field.
	AIPSTZ_MPR_MPROT2_Msk = 0xf00000
	// Accesses from this master are forced to user-mode (ips_supervisor_access is forced to zero) regardless of the hprot[1] access attribute.
	AIPSTZ_MPR_MPROT2_MPL0 = 0x0
	// Accesses from this master are not forced to user-mode. The hprot[1] access attribute is used directly to determine ips_supervisor_access.
	AIPSTZ_MPR_MPROT2_MPL1 = 0x1
	// Position of MPROT1 field.
	AIPSTZ_MPR_MPROT1_Pos = 0x18
	// Bit mask of MPROT1 field.
	AIPSTZ_MPR_MPROT1_Msk = 0xf000000
	// Accesses from this master are forced to user-mode (ips_supervisor_access is forced to zero) regardless of the hprot[1] access attribute.
	AIPSTZ_MPR_MPROT1_MPL0 = 0x0
	// Accesses from this master are not forced to user-mode. The hprot[1] access attribute is used directly to determine ips_supervisor_access.
	AIPSTZ_MPR_MPROT1_MPL1 = 0x1
	// Position of MPROT0 field.
	AIPSTZ_MPR_MPROT0_Pos = 0x1c
	// Bit mask of MPROT0 field.
	AIPSTZ_MPR_MPROT0_Msk = 0xf0000000
	// Accesses from this master are forced to user-mode (ips_supervisor_access is forced to zero) regardless of the hprot[1] access attribute.
	AIPSTZ_MPR_MPROT0_MPL0 = 0x0
	// Accesses from this master are not forced to user-mode. The hprot[1] access attribute is used directly to determine ips_supervisor_access.
	AIPSTZ_MPR_MPROT0_MPL1 = 0x1

	// OPACR: Off-Platform Peripheral Access Control Registers
	// Position of OPAC7 field.
	AIPSTZ_OPACR_OPAC7_Pos = 0x0
	// Bit mask of OPAC7 field.
	AIPSTZ_OPACR_OPAC7_Msk = 0xf
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR_OPAC7_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR_OPAC7_TP1 = 0x1
	// Position of OPAC6 field.
	AIPSTZ_OPACR_OPAC6_Pos = 0x4
	// Bit mask of OPAC6 field.
	AIPSTZ_OPACR_OPAC6_Msk = 0xf0
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR_OPAC6_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR_OPAC6_TP1 = 0x1
	// Position of OPAC5 field.
	AIPSTZ_OPACR_OPAC5_Pos = 0x8
	// Bit mask of OPAC5 field.
	AIPSTZ_OPACR_OPAC5_Msk = 0xf00
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR_OPAC5_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR_OPAC5_TP1 = 0x1
	// Position of OPAC4 field.
	AIPSTZ_OPACR_OPAC4_Pos = 0xc
	// Bit mask of OPAC4 field.
	AIPSTZ_OPACR_OPAC4_Msk = 0xf000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR_OPAC4_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR_OPAC4_TP1 = 0x1
	// Position of OPAC3 field.
	AIPSTZ_OPACR_OPAC3_Pos = 0x10
	// Bit mask of OPAC3 field.
	AIPSTZ_OPACR_OPAC3_Msk = 0xf0000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR_OPAC3_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR_OPAC3_TP1 = 0x1
	// Position of OPAC2 field.
	AIPSTZ_OPACR_OPAC2_Pos = 0x14
	// Bit mask of OPAC2 field.
	AIPSTZ_OPACR_OPAC2_Msk = 0xf00000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR_OPAC2_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR_OPAC2_TP1 = 0x1
	// Position of OPAC1 field.
	AIPSTZ_OPACR_OPAC1_Pos = 0x18
	// Bit mask of OPAC1 field.
	AIPSTZ_OPACR_OPAC1_Msk = 0xf000000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR_OPAC1_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR_OPAC1_TP1 = 0x1
	// Position of OPAC0 field.
	AIPSTZ_OPACR_OPAC0_Pos = 0x1c
	// Bit mask of OPAC0 field.
	AIPSTZ_OPACR_OPAC0_Msk = 0xf0000000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR_OPAC0_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR_OPAC0_TP1 = 0x1

	// OPACR1: Off-Platform Peripheral Access Control Registers
	// Position of OPAC15 field.
	AIPSTZ_OPACR1_OPAC15_Pos = 0x0
	// Bit mask of OPAC15 field.
	AIPSTZ_OPACR1_OPAC15_Msk = 0xf
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR1_OPAC15_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR1_OPAC15_TP1 = 0x1
	// Position of OPAC14 field.
	AIPSTZ_OPACR1_OPAC14_Pos = 0x4
	// Bit mask of OPAC14 field.
	AIPSTZ_OPACR1_OPAC14_Msk = 0xf0
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR1_OPAC14_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR1_OPAC14_TP1 = 0x1
	// Position of OPAC13 field.
	AIPSTZ_OPACR1_OPAC13_Pos = 0x8
	// Bit mask of OPAC13 field.
	AIPSTZ_OPACR1_OPAC13_Msk = 0xf00
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR1_OPAC13_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR1_OPAC13_TP1 = 0x1
	// Position of OPAC12 field.
	AIPSTZ_OPACR1_OPAC12_Pos = 0xc
	// Bit mask of OPAC12 field.
	AIPSTZ_OPACR1_OPAC12_Msk = 0xf000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR1_OPAC12_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR1_OPAC12_TP1 = 0x1
	// Position of OPAC11 field.
	AIPSTZ_OPACR1_OPAC11_Pos = 0x10
	// Bit mask of OPAC11 field.
	AIPSTZ_OPACR1_OPAC11_Msk = 0xf0000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR1_OPAC11_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR1_OPAC11_TP1 = 0x1
	// Position of OPAC10 field.
	AIPSTZ_OPACR1_OPAC10_Pos = 0x14
	// Bit mask of OPAC10 field.
	AIPSTZ_OPACR1_OPAC10_Msk = 0xf00000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR1_OPAC10_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR1_OPAC10_TP1 = 0x1
	// Position of OPAC9 field.
	AIPSTZ_OPACR1_OPAC9_Pos = 0x18
	// Bit mask of OPAC9 field.
	AIPSTZ_OPACR1_OPAC9_Msk = 0xf000000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR1_OPAC9_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR1_OPAC9_TP1 = 0x1
	// Position of OPAC8 field.
	AIPSTZ_OPACR1_OPAC8_Pos = 0x1c
	// Bit mask of OPAC8 field.
	AIPSTZ_OPACR1_OPAC8_Msk = 0xf0000000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR1_OPAC8_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR1_OPAC8_TP1 = 0x1

	// OPACR2: Off-Platform Peripheral Access Control Registers
	// Position of OPAC23 field.
	AIPSTZ_OPACR2_OPAC23_Pos = 0x0
	// Bit mask of OPAC23 field.
	AIPSTZ_OPACR2_OPAC23_Msk = 0xf
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR2_OPAC23_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR2_OPAC23_TP1 = 0x1
	// Position of OPAC22 field.
	AIPSTZ_OPACR2_OPAC22_Pos = 0x4
	// Bit mask of OPAC22 field.
	AIPSTZ_OPACR2_OPAC22_Msk = 0xf0
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR2_OPAC22_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR2_OPAC22_TP1 = 0x1
	// Position of OPAC21 field.
	AIPSTZ_OPACR2_OPAC21_Pos = 0x8
	// Bit mask of OPAC21 field.
	AIPSTZ_OPACR2_OPAC21_Msk = 0xf00
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR2_OPAC21_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR2_OPAC21_TP1 = 0x1
	// Position of OPAC20 field.
	AIPSTZ_OPACR2_OPAC20_Pos = 0xc
	// Bit mask of OPAC20 field.
	AIPSTZ_OPACR2_OPAC20_Msk = 0xf000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR2_OPAC20_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR2_OPAC20_TP1 = 0x1
	// Position of OPAC19 field.
	AIPSTZ_OPACR2_OPAC19_Pos = 0x10
	// Bit mask of OPAC19 field.
	AIPSTZ_OPACR2_OPAC19_Msk = 0xf0000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR2_OPAC19_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR2_OPAC19_TP1 = 0x1
	// Position of OPAC18 field.
	AIPSTZ_OPACR2_OPAC18_Pos = 0x14
	// Bit mask of OPAC18 field.
	AIPSTZ_OPACR2_OPAC18_Msk = 0xf00000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR2_OPAC18_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR2_OPAC18_TP1 = 0x1
	// Position of OPAC17 field.
	AIPSTZ_OPACR2_OPAC17_Pos = 0x18
	// Bit mask of OPAC17 field.
	AIPSTZ_OPACR2_OPAC17_Msk = 0xf000000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR2_OPAC17_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR2_OPAC17_TP1 = 0x1
	// Position of OPAC16 field.
	AIPSTZ_OPACR2_OPAC16_Pos = 0x1c
	// Bit mask of OPAC16 field.
	AIPSTZ_OPACR2_OPAC16_Msk = 0xf0000000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR2_OPAC16_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR2_OPAC16_TP1 = 0x1

	// OPACR3: Off-Platform Peripheral Access Control Registers
	// Position of OPAC31 field.
	AIPSTZ_OPACR3_OPAC31_Pos = 0x0
	// Bit mask of OPAC31 field.
	AIPSTZ_OPACR3_OPAC31_Msk = 0xf
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR3_OPAC31_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR3_OPAC31_TP1 = 0x1
	// Position of OPAC30 field.
	AIPSTZ_OPACR3_OPAC30_Pos = 0x4
	// Bit mask of OPAC30 field.
	AIPSTZ_OPACR3_OPAC30_Msk = 0xf0
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR3_OPAC30_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR3_OPAC30_TP1 = 0x1
	// Position of OPAC29 field.
	AIPSTZ_OPACR3_OPAC29_Pos = 0x8
	// Bit mask of OPAC29 field.
	AIPSTZ_OPACR3_OPAC29_Msk = 0xf00
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR3_OPAC29_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR3_OPAC29_TP1 = 0x1
	// Position of OPAC28 field.
	AIPSTZ_OPACR3_OPAC28_Pos = 0xc
	// Bit mask of OPAC28 field.
	AIPSTZ_OPACR3_OPAC28_Msk = 0xf000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR3_OPAC28_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR3_OPAC28_TP1 = 0x1
	// Position of OPAC27 field.
	AIPSTZ_OPACR3_OPAC27_Pos = 0x10
	// Bit mask of OPAC27 field.
	AIPSTZ_OPACR3_OPAC27_Msk = 0xf0000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR3_OPAC27_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR3_OPAC27_TP1 = 0x1
	// Position of OPAC26 field.
	AIPSTZ_OPACR3_OPAC26_Pos = 0x14
	// Bit mask of OPAC26 field.
	AIPSTZ_OPACR3_OPAC26_Msk = 0xf00000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR3_OPAC26_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR3_OPAC26_TP1 = 0x1
	// Position of OPAC25 field.
	AIPSTZ_OPACR3_OPAC25_Pos = 0x18
	// Bit mask of OPAC25 field.
	AIPSTZ_OPACR3_OPAC25_Msk = 0xf000000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR3_OPAC25_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR3_OPAC25_TP1 = 0x1
	// Position of OPAC24 field.
	AIPSTZ_OPACR3_OPAC24_Pos = 0x1c
	// Bit mask of OPAC24 field.
	AIPSTZ_OPACR3_OPAC24_Msk = 0xf0000000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR3_OPAC24_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR3_OPAC24_TP1 = 0x1

	// OPACR4: Off-Platform Peripheral Access Control Registers
	// Position of OPAC33 field.
	AIPSTZ_OPACR4_OPAC33_Pos = 0x18
	// Bit mask of OPAC33 field.
	AIPSTZ_OPACR4_OPAC33_Msk = 0xf000000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR4_OPAC33_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR4_OPAC33_TP1 = 0x1
	// Position of OPAC32 field.
	AIPSTZ_OPACR4_OPAC32_Pos = 0x1c
	// Bit mask of OPAC32 field.
	AIPSTZ_OPACR4_OPAC32_Msk = 0xf0000000
	// Accesses from an untrusted master are allowed.
	AIPSTZ_OPACR4_OPAC32_TP0 = 0x0
	// Accesses from an untrusted master are not allowed. If an access is attempted by an untrusted master, the access is terminated with an error response and no peripheral access is initiated on the IPS bus.
	AIPSTZ_OPACR4_OPAC32_TP1 = 0x1
)

// Constants for DCDC: DCDC
const (
	// REG0: DCDC Register 0
	// Position of PWD_ZCD field.
	DCDC_REG0_PWD_ZCD_Pos = 0x0
	// Bit mask of PWD_ZCD field.
	DCDC_REG0_PWD_ZCD_Msk = 0x1
	// Bit PWD_ZCD.
	DCDC_REG0_PWD_ZCD = 0x1
	// Position of DISABLE_AUTO_CLK_SWITCH field.
	DCDC_REG0_DISABLE_AUTO_CLK_SWITCH_Pos = 0x1
	// Bit mask of DISABLE_AUTO_CLK_SWITCH field.
	DCDC_REG0_DISABLE_AUTO_CLK_SWITCH_Msk = 0x2
	// Bit DISABLE_AUTO_CLK_SWITCH.
	DCDC_REG0_DISABLE_AUTO_CLK_SWITCH = 0x2
	// Position of SEL_CLK field.
	DCDC_REG0_SEL_CLK_Pos = 0x2
	// Bit mask of SEL_CLK field.
	DCDC_REG0_SEL_CLK_Msk = 0x4
	// Bit SEL_CLK.
	DCDC_REG0_SEL_CLK = 0x4
	// Position of PWD_OSC_INT field.
	DCDC_REG0_PWD_OSC_INT_Pos = 0x3
	// Bit mask of PWD_OSC_INT field.
	DCDC_REG0_PWD_OSC_INT_Msk = 0x8
	// Bit PWD_OSC_INT.
	DCDC_REG0_PWD_OSC_INT = 0x8
	// Position of PWD_CUR_SNS_CMP field.
	DCDC_REG0_PWD_CUR_SNS_CMP_Pos = 0x4
	// Bit mask of PWD_CUR_SNS_CMP field.
	DCDC_REG0_PWD_CUR_SNS_CMP_Msk = 0x10
	// Bit PWD_CUR_SNS_CMP.
	DCDC_REG0_PWD_CUR_SNS_CMP = 0x10
	// Position of CUR_SNS_THRSH field.
	DCDC_REG0_CUR_SNS_THRSH_Pos = 0x5
	// Bit mask of CUR_SNS_THRSH field.
	DCDC_REG0_CUR_SNS_THRSH_Msk = 0xe0
	// Position of PWD_OVERCUR_DET field.
	DCDC_REG0_PWD_OVERCUR_DET_Pos = 0x8
	// Bit mask of PWD_OVERCUR_DET field.
	DCDC_REG0_PWD_OVERCUR_DET_Msk = 0x100
	// Bit PWD_OVERCUR_DET.
	DCDC_REG0_PWD_OVERCUR_DET = 0x100
	// Position of OVERCUR_TRIG_ADJ field.
	DCDC_REG0_OVERCUR_TRIG_ADJ_Pos = 0x9
	// Bit mask of OVERCUR_TRIG_ADJ field.
	DCDC_REG0_OVERCUR_TRIG_ADJ_Msk = 0x600
	// Position of PWD_CMP_BATT_DET field.
	DCDC_REG0_PWD_CMP_BATT_DET_Pos = 0xb
	// Bit mask of PWD_CMP_BATT_DET field.
	DCDC_REG0_PWD_CMP_BATT_DET_Msk = 0x800
	// Bit PWD_CMP_BATT_DET.
	DCDC_REG0_PWD_CMP_BATT_DET = 0x800
	// Position of ADJ_POSLIMIT_BUCK field.
	DCDC_REG0_ADJ_POSLIMIT_BUCK_Pos = 0xc
	// Bit mask of ADJ_POSLIMIT_BUCK field.
	DCDC_REG0_ADJ_POSLIMIT_BUCK_Msk = 0xf000
	// Position of EN_LP_OVERLOAD_SNS field.
	DCDC_REG0_EN_LP_OVERLOAD_SNS_Pos = 0x10
	// Bit mask of EN_LP_OVERLOAD_SNS field.
	DCDC_REG0_EN_LP_OVERLOAD_SNS_Msk = 0x10000
	// Bit EN_LP_OVERLOAD_SNS.
	DCDC_REG0_EN_LP_OVERLOAD_SNS = 0x10000
	// Position of PWD_HIGH_VOLT_DET field.
	DCDC_REG0_PWD_HIGH_VOLT_DET_Pos = 0x11
	// Bit mask of PWD_HIGH_VOLT_DET field.
	DCDC_REG0_PWD_HIGH_VOLT_DET_Msk = 0x20000
	// Bit PWD_HIGH_VOLT_DET.
	DCDC_REG0_PWD_HIGH_VOLT_DET = 0x20000
	// Position of LP_OVERLOAD_THRSH field.
	DCDC_REG0_LP_OVERLOAD_THRSH_Pos = 0x12
	// Bit mask of LP_OVERLOAD_THRSH field.
	DCDC_REG0_LP_OVERLOAD_THRSH_Msk = 0xc0000
	// Position of LP_OVERLOAD_FREQ_SEL field.
	DCDC_REG0_LP_OVERLOAD_FREQ_SEL_Pos = 0x14
	// Bit mask of LP_OVERLOAD_FREQ_SEL field.
	DCDC_REG0_LP_OVERLOAD_FREQ_SEL_Msk = 0x100000
	// Bit LP_OVERLOAD_FREQ_SEL.
	DCDC_REG0_LP_OVERLOAD_FREQ_SEL = 0x100000
	// Position of LP_HIGH_HYS field.
	DCDC_REG0_LP_HIGH_HYS_Pos = 0x15
	// Bit mask of LP_HIGH_HYS field.
	DCDC_REG0_LP_HIGH_HYS_Msk = 0x200000
	// Bit LP_HIGH_HYS.
	DCDC_REG0_LP_HIGH_HYS = 0x200000
	// Position of PWD_CMP_OFFSET field.
	DCDC_REG0_PWD_CMP_OFFSET_Pos = 0x1a
	// Bit mask of PWD_CMP_OFFSET field.
	DCDC_REG0_PWD_CMP_OFFSET_Msk = 0x4000000
	// Bit PWD_CMP_OFFSET.
	DCDC_REG0_PWD_CMP_OFFSET = 0x4000000
	// Position of XTALOK_DISABLE field.
	DCDC_REG0_XTALOK_DISABLE_Pos = 0x1b
	// Bit mask of XTALOK_DISABLE field.
	DCDC_REG0_XTALOK_DISABLE_Msk = 0x8000000
	// Bit XTALOK_DISABLE.
	DCDC_REG0_XTALOK_DISABLE = 0x8000000
	// Position of CURRENT_ALERT_RESET field.
	DCDC_REG0_CURRENT_ALERT_RESET_Pos = 0x1c
	// Bit mask of CURRENT_ALERT_RESET field.
	DCDC_REG0_CURRENT_ALERT_RESET_Msk = 0x10000000
	// Bit CURRENT_ALERT_RESET.
	DCDC_REG0_CURRENT_ALERT_RESET = 0x10000000
	// Position of XTAL_24M_OK field.
	DCDC_REG0_XTAL_24M_OK_Pos = 0x1d
	// Bit mask of XTAL_24M_OK field.
	DCDC_REG0_XTAL_24M_OK_Msk = 0x20000000
	// Bit XTAL_24M_OK.
	DCDC_REG0_XTAL_24M_OK = 0x20000000
	// Position of STS_DC_OK field.
	DCDC_REG0_STS_DC_OK_Pos = 0x1f
	// Bit mask of STS_DC_OK field.
	DCDC_REG0_STS_DC_OK_Msk = 0x80000000
	// Bit STS_DC_OK.
	DCDC_REG0_STS_DC_OK = 0x80000000

	// REG1: DCDC Register 1
	// Position of REG_FBK_SEL field.
	DCDC_REG1_REG_FBK_SEL_Pos = 0x7
	// Bit mask of REG_FBK_SEL field.
	DCDC_REG1_REG_FBK_SEL_Msk = 0x180
	// Position of REG_RLOAD_SW field.
	DCDC_REG1_REG_RLOAD_SW_Pos = 0x9
	// Bit mask of REG_RLOAD_SW field.
	DCDC_REG1_REG_RLOAD_SW_Msk = 0x200
	// Bit REG_RLOAD_SW.
	DCDC_REG1_REG_RLOAD_SW = 0x200
	// Position of LP_CMP_ISRC_SEL field.
	DCDC_REG1_LP_CMP_ISRC_SEL_Pos = 0xc
	// Bit mask of LP_CMP_ISRC_SEL field.
	DCDC_REG1_LP_CMP_ISRC_SEL_Msk = 0x3000
	// Position of LOOPCTRL_HST_THRESH field.
	DCDC_REG1_LOOPCTRL_HST_THRESH_Pos = 0x15
	// Bit mask of LOOPCTRL_HST_THRESH field.
	DCDC_REG1_LOOPCTRL_HST_THRESH_Msk = 0x200000
	// Bit LOOPCTRL_HST_THRESH.
	DCDC_REG1_LOOPCTRL_HST_THRESH = 0x200000
	// Position of LOOPCTRL_EN_HYST field.
	DCDC_REG1_LOOPCTRL_EN_HYST_Pos = 0x17
	// Bit mask of LOOPCTRL_EN_HYST field.
	DCDC_REG1_LOOPCTRL_EN_HYST_Msk = 0x800000
	// Bit LOOPCTRL_EN_HYST.
	DCDC_REG1_LOOPCTRL_EN_HYST = 0x800000
	// Position of VBG_TRIM field.
	DCDC_REG1_VBG_TRIM_Pos = 0x18
	// Bit mask of VBG_TRIM field.
	DCDC_REG1_VBG_TRIM_Msk = 0x1f000000

	// REG2: DCDC Register 2
	// Position of LOOPCTRL_DC_C field.
	DCDC_REG2_LOOPCTRL_DC_C_Pos = 0x0
	// Bit mask of LOOPCTRL_DC_C field.
	DCDC_REG2_LOOPCTRL_DC_C_Msk = 0x3
	// Position of LOOPCTRL_DC_R field.
	DCDC_REG2_LOOPCTRL_DC_R_Pos = 0x2
	// Bit mask of LOOPCTRL_DC_R field.
	DCDC_REG2_LOOPCTRL_DC_R_Msk = 0x3c
	// Position of LOOPCTRL_DC_FF field.
	DCDC_REG2_LOOPCTRL_DC_FF_Pos = 0x6
	// Bit mask of LOOPCTRL_DC_FF field.
	DCDC_REG2_LOOPCTRL_DC_FF_Msk = 0x1c0
	// Position of LOOPCTRL_EN_RCSCALE field.
	DCDC_REG2_LOOPCTRL_EN_RCSCALE_Pos = 0x9
	// Bit mask of LOOPCTRL_EN_RCSCALE field.
	DCDC_REG2_LOOPCTRL_EN_RCSCALE_Msk = 0xe00
	// Position of LOOPCTRL_RCSCALE_THRSH field.
	DCDC_REG2_LOOPCTRL_RCSCALE_THRSH_Pos = 0xc
	// Bit mask of LOOPCTRL_RCSCALE_THRSH field.
	DCDC_REG2_LOOPCTRL_RCSCALE_THRSH_Msk = 0x1000
	// Bit LOOPCTRL_RCSCALE_THRSH.
	DCDC_REG2_LOOPCTRL_RCSCALE_THRSH = 0x1000
	// Position of LOOPCTRL_HYST_SIGN field.
	DCDC_REG2_LOOPCTRL_HYST_SIGN_Pos = 0xd
	// Bit mask of LOOPCTRL_HYST_SIGN field.
	DCDC_REG2_LOOPCTRL_HYST_SIGN_Msk = 0x2000
	// Bit LOOPCTRL_HYST_SIGN.
	DCDC_REG2_LOOPCTRL_HYST_SIGN = 0x2000
	// Position of BATTMONITOR_EN_BATADJ field.
	DCDC_REG2_BATTMONITOR_EN_BATADJ_Pos = 0xf
	// Bit mask of BATTMONITOR_EN_BATADJ field.
	DCDC_REG2_BATTMONITOR_EN_BATADJ_Msk = 0x8000
	// Bit BATTMONITOR_EN_BATADJ.
	DCDC_REG2_BATTMONITOR_EN_BATADJ = 0x8000
	// Position of DISABLE_PULSE_SKIP field.
	DCDC_REG2_DISABLE_PULSE_SKIP_Pos = 0x1b
	// Bit mask of DISABLE_PULSE_SKIP field.
	DCDC_REG2_DISABLE_PULSE_SKIP_Msk = 0x8000000
	// Bit DISABLE_PULSE_SKIP.
	DCDC_REG2_DISABLE_PULSE_SKIP = 0x8000000
	// Position of DCM_SET_CTRL field.
	DCDC_REG2_DCM_SET_CTRL_Pos = 0x1c
	// Bit mask of DCM_SET_CTRL field.
	DCDC_REG2_DCM_SET_CTRL_Msk = 0x10000000
	// Bit DCM_SET_CTRL.
	DCDC_REG2_DCM_SET_CTRL = 0x10000000

	// REG3: DCDC Register 3
	// Position of TRG field.
	DCDC_REG3_TRG_Pos = 0x0
	// Bit mask of TRG field.
	DCDC_REG3_TRG_Msk = 0x1f
	// Position of TARGET_LP field.
	DCDC_REG3_TARGET_LP_Pos = 0x8
	// Bit mask of TARGET_LP field.
	DCDC_REG3_TARGET_LP_Msk = 0x700
	// Position of MINPWR_DC_HALFCLK field.
	DCDC_REG3_MINPWR_DC_HALFCLK_Pos = 0x18
	// Bit mask of MINPWR_DC_HALFCLK field.
	DCDC_REG3_MINPWR_DC_HALFCLK_Msk = 0x1000000
	// Bit MINPWR_DC_HALFCLK.
	DCDC_REG3_MINPWR_DC_HALFCLK = 0x1000000
	// Position of MISC_DELAY_TIMING field.
	DCDC_REG3_MISC_DELAY_TIMING_Pos = 0x1b
	// Bit mask of MISC_DELAY_TIMING field.
	DCDC_REG3_MISC_DELAY_TIMING_Msk = 0x8000000
	// Bit MISC_DELAY_TIMING.
	DCDC_REG3_MISC_DELAY_TIMING = 0x8000000
	// Position of MISC_DISABLEFET_LOGIC field.
	DCDC_REG3_MISC_DISABLEFET_LOGIC_Pos = 0x1c
	// Bit mask of MISC_DISABLEFET_LOGIC field.
	DCDC_REG3_MISC_DISABLEFET_LOGIC_Msk = 0x10000000
	// Bit MISC_DISABLEFET_LOGIC.
	DCDC_REG3_MISC_DISABLEFET_LOGIC = 0x10000000
	// Position of DISABLE_STEP field.
	DCDC_REG3_DISABLE_STEP_Pos = 0x1e
	// Bit mask of DISABLE_STEP field.
	DCDC_REG3_DISABLE_STEP_Msk = 0x40000000
	// Bit DISABLE_STEP.
	DCDC_REG3_DISABLE_STEP = 0x40000000
)

// Constants for PIT: PIT
const (
	// MCR: PIT Module Control Register
	// Position of FRZ field.
	PIT_MCR_FRZ_Pos = 0x0
	// Bit mask of FRZ field.
	PIT_MCR_FRZ_Msk = 0x1
	// Bit FRZ.
	PIT_MCR_FRZ = 0x1
	// Timers continue to run in Debug mode.
	PIT_MCR_FRZ_FRZ_0 = 0x0
	// Timers are stopped in Debug mode.
	PIT_MCR_FRZ_FRZ_1 = 0x1
	// Position of MDIS field.
	PIT_MCR_MDIS_Pos = 0x1
	// Bit mask of MDIS field.
	PIT_MCR_MDIS_Msk = 0x2
	// Bit MDIS.
	PIT_MCR_MDIS = 0x2
	// Clock for standard PIT timers is enabled.
	PIT_MCR_MDIS_MDIS_0 = 0x0
	// Clock for standard PIT timers is disabled.
	PIT_MCR_MDIS_MDIS_1 = 0x1

	// LTMR64H: PIT Upper Lifetime Timer Register
	// Position of LTH field.
	PIT_LTMR64H_LTH_Pos = 0x0
	// Bit mask of LTH field.
	PIT_LTMR64H_LTH_Msk = 0xffffffff

	// LTMR64L: PIT Lower Lifetime Timer Register
	// Position of LTL field.
	PIT_LTMR64L_LTL_Pos = 0x0
	// Bit mask of LTL field.
	PIT_LTMR64L_LTL_Msk = 0xffffffff

	// TIMER.LDVAL: Timer Load Value Register
	// Position of TSV field.
	PIT_TIMER_LDVAL_TSV_Pos = 0x0
	// Bit mask of TSV field.
	PIT_TIMER_LDVAL_TSV_Msk = 0xffffffff

	// TIMER.CVAL: Current Timer Value Register
	// Position of TVL field.
	PIT_TIMER_CVAL_TVL_Pos = 0x0
	// Bit mask of TVL field.
	PIT_TIMER_CVAL_TVL_Msk = 0xffffffff

	// TIMER.TCTRL: Timer Control Register
	// Position of TEN field.
	PIT_TIMER_TCTRL_TEN_Pos = 0x0
	// Bit mask of TEN field.
	PIT_TIMER_TCTRL_TEN_Msk = 0x1
	// Bit TEN.
	PIT_TIMER_TCTRL_TEN = 0x1
	// Timer n is disabled.
	PIT_TIMER_TCTRL_TEN_TEN_0 = 0x0
	// Timer n is enabled.
	PIT_TIMER_TCTRL_TEN_TEN_1 = 0x1
	// Position of TIE field.
	PIT_TIMER_TCTRL_TIE_Pos = 0x1
	// Bit mask of TIE field.
	PIT_TIMER_TCTRL_TIE_Msk = 0x2
	// Bit TIE.
	PIT_TIMER_TCTRL_TIE = 0x2
	// Interrupt requests from Timer n are disabled.
	PIT_TIMER_TCTRL_TIE_TIE_0 = 0x0
	// Interrupt is requested whenever TIF is set.
	PIT_TIMER_TCTRL_TIE_TIE_1 = 0x1
	// Position of CHN field.
	PIT_TIMER_TCTRL_CHN_Pos = 0x2
	// Bit mask of CHN field.
	PIT_TIMER_TCTRL_CHN_Msk = 0x4
	// Bit CHN.
	PIT_TIMER_TCTRL_CHN = 0x4
	// Timer is not chained.
	PIT_TIMER_TCTRL_CHN_CHN_0 = 0x0
	// Timer is chained to a previous timer. For example, for channel 2, if this field is set, Timer 2 is chained to Timer 1.
	PIT_TIMER_TCTRL_CHN_CHN_1 = 0x1

	// TIMER.TFLG: Timer Flag Register
	// Position of TIF field.
	PIT_TIMER_TFLG_TIF_Pos = 0x0
	// Bit mask of TIF field.
	PIT_TIMER_TFLG_TIF_Msk = 0x1
	// Bit TIF.
	PIT_TIMER_TFLG_TIF = 0x1
	// Timeout has not yet occurred.
	PIT_TIMER_TFLG_TIF_TIF_0 = 0x0
	// Timeout has occurred.
	PIT_TIMER_TFLG_TIF_TIF_1 = 0x1
)

// Constants for ADC_ETC: ADC_ETC
const (
	// CTRL: ADC_ETC Global Control Register
	// Position of TRIG_ENABLE field.
	ADC_ETC_CTRL_TRIG_ENABLE_Pos = 0x0
	// Bit mask of TRIG_ENABLE field.
	ADC_ETC_CTRL_TRIG_ENABLE_Msk = 0xff
	// Position of EXT0_TRIG_ENABLE field.
	ADC_ETC_CTRL_EXT0_TRIG_ENABLE_Pos = 0x8
	// Bit mask of EXT0_TRIG_ENABLE field.
	ADC_ETC_CTRL_EXT0_TRIG_ENABLE_Msk = 0x100
	// Bit EXT0_TRIG_ENABLE.
	ADC_ETC_CTRL_EXT0_TRIG_ENABLE = 0x100
	// Position of EXT0_TRIG_PRIORITY field.
	ADC_ETC_CTRL_EXT0_TRIG_PRIORITY_Pos = 0x9
	// Bit mask of EXT0_TRIG_PRIORITY field.
	ADC_ETC_CTRL_EXT0_TRIG_PRIORITY_Msk = 0xe00
	// Position of EXT1_TRIG_ENABLE field.
	ADC_ETC_CTRL_EXT1_TRIG_ENABLE_Pos = 0xc
	// Bit mask of EXT1_TRIG_ENABLE field.
	ADC_ETC_CTRL_EXT1_TRIG_ENABLE_Msk = 0x1000
	// Bit EXT1_TRIG_ENABLE.
	ADC_ETC_CTRL_EXT1_TRIG_ENABLE = 0x1000
	// Position of EXT1_TRIG_PRIORITY field.
	ADC_ETC_CTRL_EXT1_TRIG_PRIORITY_Pos = 0xd
	// Bit mask of EXT1_TRIG_PRIORITY field.
	ADC_ETC_CTRL_EXT1_TRIG_PRIORITY_Msk = 0xe000
	// Position of PRE_DIVIDER field.
	ADC_ETC_CTRL_PRE_DIVIDER_Pos = 0x10
	// Bit mask of PRE_DIVIDER field.
	ADC_ETC_CTRL_PRE_DIVIDER_Msk = 0xff0000
	// Position of DMA_MODE_SEL field.
	ADC_ETC_CTRL_DMA_MODE_SEL_Pos = 0x1d
	// Bit mask of DMA_MODE_SEL field.
	ADC_ETC_CTRL_DMA_MODE_SEL_Msk = 0x20000000
	// Bit DMA_MODE_SEL.
	ADC_ETC_CTRL_DMA_MODE_SEL = 0x20000000
	// Position of TSC_BYPASS field.
	ADC_ETC_CTRL_TSC_BYPASS_Pos = 0x1e
	// Bit mask of TSC_BYPASS field.
	ADC_ETC_CTRL_TSC_BYPASS_Msk = 0x40000000
	// Bit TSC_BYPASS.
	ADC_ETC_CTRL_TSC_BYPASS = 0x40000000
	// Position of SOFTRST field.
	ADC_ETC_CTRL_SOFTRST_Pos = 0x1f
	// Bit mask of SOFTRST field.
	ADC_ETC_CTRL_SOFTRST_Msk = 0x80000000
	// Bit SOFTRST.
	ADC_ETC_CTRL_SOFTRST = 0x80000000

	// DONE0_1_IRQ: ETC DONE0 and DONE1 IRQ State Register
	// Position of TRIG0_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG0_DONE0_Pos = 0x0
	// Bit mask of TRIG0_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG0_DONE0_Msk = 0x1
	// Bit TRIG0_DONE0.
	ADC_ETC_DONE0_1_IRQ_TRIG0_DONE0 = 0x1
	// Position of TRIG1_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG1_DONE0_Pos = 0x1
	// Bit mask of TRIG1_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG1_DONE0_Msk = 0x2
	// Bit TRIG1_DONE0.
	ADC_ETC_DONE0_1_IRQ_TRIG1_DONE0 = 0x2
	// Position of TRIG2_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG2_DONE0_Pos = 0x2
	// Bit mask of TRIG2_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG2_DONE0_Msk = 0x4
	// Bit TRIG2_DONE0.
	ADC_ETC_DONE0_1_IRQ_TRIG2_DONE0 = 0x4
	// Position of TRIG3_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG3_DONE0_Pos = 0x3
	// Bit mask of TRIG3_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG3_DONE0_Msk = 0x8
	// Bit TRIG3_DONE0.
	ADC_ETC_DONE0_1_IRQ_TRIG3_DONE0 = 0x8
	// Position of TRIG4_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG4_DONE0_Pos = 0x4
	// Bit mask of TRIG4_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG4_DONE0_Msk = 0x10
	// Bit TRIG4_DONE0.
	ADC_ETC_DONE0_1_IRQ_TRIG4_DONE0 = 0x10
	// Position of TRIG5_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG5_DONE0_Pos = 0x5
	// Bit mask of TRIG5_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG5_DONE0_Msk = 0x20
	// Bit TRIG5_DONE0.
	ADC_ETC_DONE0_1_IRQ_TRIG5_DONE0 = 0x20
	// Position of TRIG6_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG6_DONE0_Pos = 0x6
	// Bit mask of TRIG6_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG6_DONE0_Msk = 0x40
	// Bit TRIG6_DONE0.
	ADC_ETC_DONE0_1_IRQ_TRIG6_DONE0 = 0x40
	// Position of TRIG7_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG7_DONE0_Pos = 0x7
	// Bit mask of TRIG7_DONE0 field.
	ADC_ETC_DONE0_1_IRQ_TRIG7_DONE0_Msk = 0x80
	// Bit TRIG7_DONE0.
	ADC_ETC_DONE0_1_IRQ_TRIG7_DONE0 = 0x80
	// Position of TRIG0_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG0_DONE1_Pos = 0x10
	// Bit mask of TRIG0_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG0_DONE1_Msk = 0x10000
	// Bit TRIG0_DONE1.
	ADC_ETC_DONE0_1_IRQ_TRIG0_DONE1 = 0x10000
	// Position of TRIG1_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG1_DONE1_Pos = 0x11
	// Bit mask of TRIG1_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG1_DONE1_Msk = 0x20000
	// Bit TRIG1_DONE1.
	ADC_ETC_DONE0_1_IRQ_TRIG1_DONE1 = 0x20000
	// Position of TRIG2_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG2_DONE1_Pos = 0x12
	// Bit mask of TRIG2_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG2_DONE1_Msk = 0x40000
	// Bit TRIG2_DONE1.
	ADC_ETC_DONE0_1_IRQ_TRIG2_DONE1 = 0x40000
	// Position of TRIG3_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG3_DONE1_Pos = 0x13
	// Bit mask of TRIG3_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG3_DONE1_Msk = 0x80000
	// Bit TRIG3_DONE1.
	ADC_ETC_DONE0_1_IRQ_TRIG3_DONE1 = 0x80000
	// Position of TRIG4_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG4_DONE1_Pos = 0x14
	// Bit mask of TRIG4_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG4_DONE1_Msk = 0x100000
	// Bit TRIG4_DONE1.
	ADC_ETC_DONE0_1_IRQ_TRIG4_DONE1 = 0x100000
	// Position of TRIG5_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG5_DONE1_Pos = 0x15
	// Bit mask of TRIG5_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG5_DONE1_Msk = 0x200000
	// Bit TRIG5_DONE1.
	ADC_ETC_DONE0_1_IRQ_TRIG5_DONE1 = 0x200000
	// Position of TRIG6_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG6_DONE1_Pos = 0x16
	// Bit mask of TRIG6_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG6_DONE1_Msk = 0x400000
	// Bit TRIG6_DONE1.
	ADC_ETC_DONE0_1_IRQ_TRIG6_DONE1 = 0x400000
	// Position of TRIG7_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG7_DONE1_Pos = 0x17
	// Bit mask of TRIG7_DONE1 field.
	ADC_ETC_DONE0_1_IRQ_TRIG7_DONE1_Msk = 0x800000
	// Bit TRIG7_DONE1.
	ADC_ETC_DONE0_1_IRQ_TRIG7_DONE1 = 0x800000

	// DONE2_ERR_IRQ: ETC DONE_2 and DONE_ERR IRQ State Register
	// Position of TRIG0_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG0_DONE2_Pos = 0x0
	// Bit mask of TRIG0_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG0_DONE2_Msk = 0x1
	// Bit TRIG0_DONE2.
	ADC_ETC_DONE2_ERR_IRQ_TRIG0_DONE2 = 0x1
	// Position of TRIG1_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG1_DONE2_Pos = 0x1
	// Bit mask of TRIG1_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG1_DONE2_Msk = 0x2
	// Bit TRIG1_DONE2.
	ADC_ETC_DONE2_ERR_IRQ_TRIG1_DONE2 = 0x2
	// Position of TRIG2_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG2_DONE2_Pos = 0x2
	// Bit mask of TRIG2_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG2_DONE2_Msk = 0x4
	// Bit TRIG2_DONE2.
	ADC_ETC_DONE2_ERR_IRQ_TRIG2_DONE2 = 0x4
	// Position of TRIG3_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG3_DONE2_Pos = 0x3
	// Bit mask of TRIG3_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG3_DONE2_Msk = 0x8
	// Bit TRIG3_DONE2.
	ADC_ETC_DONE2_ERR_IRQ_TRIG3_DONE2 = 0x8
	// Position of TRIG4_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG4_DONE2_Pos = 0x4
	// Bit mask of TRIG4_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG4_DONE2_Msk = 0x10
	// Bit TRIG4_DONE2.
	ADC_ETC_DONE2_ERR_IRQ_TRIG4_DONE2 = 0x10
	// Position of TRIG5_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG5_DONE2_Pos = 0x5
	// Bit mask of TRIG5_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG5_DONE2_Msk = 0x20
	// Bit TRIG5_DONE2.
	ADC_ETC_DONE2_ERR_IRQ_TRIG5_DONE2 = 0x20
	// Position of TRIG6_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG6_DONE2_Pos = 0x6
	// Bit mask of TRIG6_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG6_DONE2_Msk = 0x40
	// Bit TRIG6_DONE2.
	ADC_ETC_DONE2_ERR_IRQ_TRIG6_DONE2 = 0x40
	// Position of TRIG7_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG7_DONE2_Pos = 0x7
	// Bit mask of TRIG7_DONE2 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG7_DONE2_Msk = 0x80
	// Bit TRIG7_DONE2.
	ADC_ETC_DONE2_ERR_IRQ_TRIG7_DONE2 = 0x80
	// Position of TRIG0_DONE3 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG0_DONE3_Pos = 0x8
	// Bit mask of TRIG0_DONE3 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG0_DONE3_Msk = 0x100
	// Bit TRIG0_DONE3.
	ADC_ETC_DONE2_ERR_IRQ_TRIG0_DONE3 = 0x100
	// Position of TRIG1_DONE3 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG1_DONE3_Pos = 0x9
	// Bit mask of TRIG1_DONE3 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG1_DONE3_Msk = 0x200
	// Bit TRIG1_DONE3.
	ADC_ETC_DONE2_ERR_IRQ_TRIG1_DONE3 = 0x200
	// Position of TRIG2_DONE3 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG2_DONE3_Pos = 0xa
	// Bit mask of TRIG2_DONE3 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG2_DONE3_Msk = 0x400
	// Bit TRIG2_DONE3.
	ADC_ETC_DONE2_ERR_IRQ_TRIG2_DONE3 = 0x400
	// Position of TRIG3_DONE3 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG3_DONE3_Pos = 0xb
	// Bit mask of TRIG3_DONE3 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG3_DONE3_Msk = 0x800
	// Bit TRIG3_DONE3.
	ADC_ETC_DONE2_ERR_IRQ_TRIG3_DONE3 = 0x800
	// Position of TRIG4_DONE3 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG4_DONE3_Pos = 0xc
	// Bit mask of TRIG4_DONE3 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG4_DONE3_Msk = 0x1000
	// Bit TRIG4_DONE3.
	ADC_ETC_DONE2_ERR_IRQ_TRIG4_DONE3 = 0x1000
	// Position of TRIG5_DONE3 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG5_DONE3_Pos = 0xd
	// Bit mask of TRIG5_DONE3 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG5_DONE3_Msk = 0x2000
	// Bit TRIG5_DONE3.
	ADC_ETC_DONE2_ERR_IRQ_TRIG5_DONE3 = 0x2000
	// Position of TRIG6_DONE3 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG6_DONE3_Pos = 0xe
	// Bit mask of TRIG6_DONE3 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG6_DONE3_Msk = 0x4000
	// Bit TRIG6_DONE3.
	ADC_ETC_DONE2_ERR_IRQ_TRIG6_DONE3 = 0x4000
	// Position of TRIG7_DONE3 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG7_DONE3_Pos = 0xf
	// Bit mask of TRIG7_DONE3 field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG7_DONE3_Msk = 0x8000
	// Bit TRIG7_DONE3.
	ADC_ETC_DONE2_ERR_IRQ_TRIG7_DONE3 = 0x8000
	// Position of TRIG0_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG0_ERR_Pos = 0x10
	// Bit mask of TRIG0_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG0_ERR_Msk = 0x10000
	// Bit TRIG0_ERR.
	ADC_ETC_DONE2_ERR_IRQ_TRIG0_ERR = 0x10000
	// Position of TRIG1_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG1_ERR_Pos = 0x11
	// Bit mask of TRIG1_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG1_ERR_Msk = 0x20000
	// Bit TRIG1_ERR.
	ADC_ETC_DONE2_ERR_IRQ_TRIG1_ERR = 0x20000
	// Position of TRIG2_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG2_ERR_Pos = 0x12
	// Bit mask of TRIG2_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG2_ERR_Msk = 0x40000
	// Bit TRIG2_ERR.
	ADC_ETC_DONE2_ERR_IRQ_TRIG2_ERR = 0x40000
	// Position of TRIG3_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG3_ERR_Pos = 0x13
	// Bit mask of TRIG3_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG3_ERR_Msk = 0x80000
	// Bit TRIG3_ERR.
	ADC_ETC_DONE2_ERR_IRQ_TRIG3_ERR = 0x80000
	// Position of TRIG4_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG4_ERR_Pos = 0x14
	// Bit mask of TRIG4_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG4_ERR_Msk = 0x100000
	// Bit TRIG4_ERR.
	ADC_ETC_DONE2_ERR_IRQ_TRIG4_ERR = 0x100000
	// Position of TRIG5_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG5_ERR_Pos = 0x15
	// Bit mask of TRIG5_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG5_ERR_Msk = 0x200000
	// Bit TRIG5_ERR.
	ADC_ETC_DONE2_ERR_IRQ_TRIG5_ERR = 0x200000
	// Position of TRIG6_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG6_ERR_Pos = 0x16
	// Bit mask of TRIG6_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG6_ERR_Msk = 0x400000
	// Bit TRIG6_ERR.
	ADC_ETC_DONE2_ERR_IRQ_TRIG6_ERR = 0x400000
	// Position of TRIG7_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG7_ERR_Pos = 0x17
	// Bit mask of TRIG7_ERR field.
	ADC_ETC_DONE2_ERR_IRQ_TRIG7_ERR_Msk = 0x800000
	// Bit TRIG7_ERR.
	ADC_ETC_DONE2_ERR_IRQ_TRIG7_ERR = 0x800000

	// DMA_CTRL: ETC DMA control Register
	// Position of TRIG0_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG0_ENABLE_Pos = 0x0
	// Bit mask of TRIG0_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG0_ENABLE_Msk = 0x1
	// Bit TRIG0_ENABLE.
	ADC_ETC_DMA_CTRL_TRIG0_ENABLE = 0x1
	// Position of TRIG1_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG1_ENABLE_Pos = 0x1
	// Bit mask of TRIG1_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG1_ENABLE_Msk = 0x2
	// Bit TRIG1_ENABLE.
	ADC_ETC_DMA_CTRL_TRIG1_ENABLE = 0x2
	// Position of TRIG2_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG2_ENABLE_Pos = 0x2
	// Bit mask of TRIG2_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG2_ENABLE_Msk = 0x4
	// Bit TRIG2_ENABLE.
	ADC_ETC_DMA_CTRL_TRIG2_ENABLE = 0x4
	// Position of TRIG3_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG3_ENABLE_Pos = 0x3
	// Bit mask of TRIG3_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG3_ENABLE_Msk = 0x8
	// Bit TRIG3_ENABLE.
	ADC_ETC_DMA_CTRL_TRIG3_ENABLE = 0x8
	// Position of TRIG4_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG4_ENABLE_Pos = 0x4
	// Bit mask of TRIG4_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG4_ENABLE_Msk = 0x10
	// Bit TRIG4_ENABLE.
	ADC_ETC_DMA_CTRL_TRIG4_ENABLE = 0x10
	// Position of TRIG5_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG5_ENABLE_Pos = 0x5
	// Bit mask of TRIG5_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG5_ENABLE_Msk = 0x20
	// Bit TRIG5_ENABLE.
	ADC_ETC_DMA_CTRL_TRIG5_ENABLE = 0x20
	// Position of TRIG6_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG6_ENABLE_Pos = 0x6
	// Bit mask of TRIG6_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG6_ENABLE_Msk = 0x40
	// Bit TRIG6_ENABLE.
	ADC_ETC_DMA_CTRL_TRIG6_ENABLE = 0x40
	// Position of TRIG7_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG7_ENABLE_Pos = 0x7
	// Bit mask of TRIG7_ENABLE field.
	ADC_ETC_DMA_CTRL_TRIG7_ENABLE_Msk = 0x80
	// Bit TRIG7_ENABLE.
	ADC_ETC_DMA_CTRL_TRIG7_ENABLE = 0x80
	// Position of TRIG0_REQ field.
	ADC_ETC_DMA_CTRL_TRIG0_REQ_Pos = 0x10
	// Bit mask of TRIG0_REQ field.
	ADC_ETC_DMA_CTRL_TRIG0_REQ_Msk = 0x10000
	// Bit TRIG0_REQ.
	ADC_ETC_DMA_CTRL_TRIG0_REQ = 0x10000
	// Position of TRIG1_REQ field.
	ADC_ETC_DMA_CTRL_TRIG1_REQ_Pos = 0x11
	// Bit mask of TRIG1_REQ field.
	ADC_ETC_DMA_CTRL_TRIG1_REQ_Msk = 0x20000
	// Bit TRIG1_REQ.
	ADC_ETC_DMA_CTRL_TRIG1_REQ = 0x20000
	// Position of TRIG2_REQ field.
	ADC_ETC_DMA_CTRL_TRIG2_REQ_Pos = 0x12
	// Bit mask of TRIG2_REQ field.
	ADC_ETC_DMA_CTRL_TRIG2_REQ_Msk = 0x40000
	// Bit TRIG2_REQ.
	ADC_ETC_DMA_CTRL_TRIG2_REQ = 0x40000
	// Position of TRIG3_REQ field.
	ADC_ETC_DMA_CTRL_TRIG3_REQ_Pos = 0x13
	// Bit mask of TRIG3_REQ field.
	ADC_ETC_DMA_CTRL_TRIG3_REQ_Msk = 0x80000
	// Bit TRIG3_REQ.
	ADC_ETC_DMA_CTRL_TRIG3_REQ = 0x80000
	// Position of TRIG4_REQ field.
	ADC_ETC_DMA_CTRL_TRIG4_REQ_Pos = 0x14
	// Bit mask of TRIG4_REQ field.
	ADC_ETC_DMA_CTRL_TRIG4_REQ_Msk = 0x100000
	// Bit TRIG4_REQ.
	ADC_ETC_DMA_CTRL_TRIG4_REQ = 0x100000
	// Position of TRIG5_REQ field.
	ADC_ETC_DMA_CTRL_TRIG5_REQ_Pos = 0x15
	// Bit mask of TRIG5_REQ field.
	ADC_ETC_DMA_CTRL_TRIG5_REQ_Msk = 0x200000
	// Bit TRIG5_REQ.
	ADC_ETC_DMA_CTRL_TRIG5_REQ = 0x200000
	// Position of TRIG6_REQ field.
	ADC_ETC_DMA_CTRL_TRIG6_REQ_Pos = 0x16
	// Bit mask of TRIG6_REQ field.
	ADC_ETC_DMA_CTRL_TRIG6_REQ_Msk = 0x400000
	// Bit TRIG6_REQ.
	ADC_ETC_DMA_CTRL_TRIG6_REQ = 0x400000
	// Position of TRIG7_REQ field.
	ADC_ETC_DMA_CTRL_TRIG7_REQ_Pos = 0x17
	// Bit mask of TRIG7_REQ field.
	ADC_ETC_DMA_CTRL_TRIG7_REQ_Msk = 0x800000
	// Bit TRIG7_REQ.
	ADC_ETC_DMA_CTRL_TRIG7_REQ = 0x800000

	// TRIG0_CTRL: ETC_TRIG Control Register
	// Position of SW_TRIG field.
	ADC_ETC_TRIG0_CTRL_SW_TRIG_Pos = 0x0
	// Bit mask of SW_TRIG field.
	ADC_ETC_TRIG0_CTRL_SW_TRIG_Msk = 0x1
	// Bit SW_TRIG.
	ADC_ETC_TRIG0_CTRL_SW_TRIG = 0x1
	// Position of TRIG_MODE field.
	ADC_ETC_TRIG0_CTRL_TRIG_MODE_Pos = 0x4
	// Bit mask of TRIG_MODE field.
	ADC_ETC_TRIG0_CTRL_TRIG_MODE_Msk = 0x10
	// Bit TRIG_MODE.
	ADC_ETC_TRIG0_CTRL_TRIG_MODE = 0x10
	// Position of TRIG_CHAIN field.
	ADC_ETC_TRIG0_CTRL_TRIG_CHAIN_Pos = 0x8
	// Bit mask of TRIG_CHAIN field.
	ADC_ETC_TRIG0_CTRL_TRIG_CHAIN_Msk = 0x700
	// Position of TRIG_PRIORITY field.
	ADC_ETC_TRIG0_CTRL_TRIG_PRIORITY_Pos = 0xc
	// Bit mask of TRIG_PRIORITY field.
	ADC_ETC_TRIG0_CTRL_TRIG_PRIORITY_Msk = 0x7000
	// Position of SYNC_MODE field.
	ADC_ETC_TRIG0_CTRL_SYNC_MODE_Pos = 0x10
	// Bit mask of SYNC_MODE field.
	ADC_ETC_TRIG0_CTRL_SYNC_MODE_Msk = 0x10000
	// Bit SYNC_MODE.
	ADC_ETC_TRIG0_CTRL_SYNC_MODE = 0x10000
	// Position of CHAINx_DONE field.
	ADC_ETC_TRIG0_CTRL_CHAINx_DONE_Pos = 0x18
	// Bit mask of CHAINx_DONE field.
	ADC_ETC_TRIG0_CTRL_CHAINx_DONE_Msk = 0xff000000

	// TRIG0_COUNTER: ETC_TRIG Counter Register
	// Position of INIT_DELAY field.
	ADC_ETC_TRIG0_COUNTER_INIT_DELAY_Pos = 0x0
	// Bit mask of INIT_DELAY field.
	ADC_ETC_TRIG0_COUNTER_INIT_DELAY_Msk = 0xffff
	// Position of SAMPLE_INTERVAL field.
	ADC_ETC_TRIG0_COUNTER_SAMPLE_INTERVAL_Pos = 0x10
	// Bit mask of SAMPLE_INTERVAL field.
	ADC_ETC_TRIG0_COUNTER_SAMPLE_INTERVAL_Msk = 0xffff0000

	// TRIG0_CHAIN_1_0: ETC_TRIG Chain 0/1 Register
	// Position of CSEL0 field.
	ADC_ETC_TRIG0_CHAIN_1_0_CSEL0_Pos = 0x0
	// Bit mask of CSEL0 field.
	ADC_ETC_TRIG0_CHAIN_1_0_CSEL0_Msk = 0xf
	// Position of HWTS0 field.
	ADC_ETC_TRIG0_CHAIN_1_0_HWTS0_Pos = 0x4
	// Bit mask of HWTS0 field.
	ADC_ETC_TRIG0_CHAIN_1_0_HWTS0_Msk = 0xff0
	// Position of B2B0 field.
	ADC_ETC_TRIG0_CHAIN_1_0_B2B0_Pos = 0xc
	// Bit mask of B2B0 field.
	ADC_ETC_TRIG0_CHAIN_1_0_B2B0_Msk = 0x1000
	// Bit B2B0.
	ADC_ETC_TRIG0_CHAIN_1_0_B2B0 = 0x1000
	// Position of IE0 field.
	ADC_ETC_TRIG0_CHAIN_1_0_IE0_Pos = 0xd
	// Bit mask of IE0 field.
	ADC_ETC_TRIG0_CHAIN_1_0_IE0_Msk = 0x6000
	// Position of IE0_EN field.
	ADC_ETC_TRIG0_CHAIN_1_0_IE0_EN_Pos = 0xf
	// Bit mask of IE0_EN field.
	ADC_ETC_TRIG0_CHAIN_1_0_IE0_EN_Msk = 0x8000
	// Bit IE0_EN.
	ADC_ETC_TRIG0_CHAIN_1_0_IE0_EN = 0x8000
	// Position of CSEL1 field.
	ADC_ETC_TRIG0_CHAIN_1_0_CSEL1_Pos = 0x10
	// Bit mask of CSEL1 field.
	ADC_ETC_TRIG0_CHAIN_1_0_CSEL1_Msk = 0xf0000
	// Position of HWTS1 field.
	ADC_ETC_TRIG0_CHAIN_1_0_HWTS1_Pos = 0x14
	// Bit mask of HWTS1 field.
	ADC_ETC_TRIG0_CHAIN_1_0_HWTS1_Msk = 0xff00000
	// Position of B2B1 field.
	ADC_ETC_TRIG0_CHAIN_1_0_B2B1_Pos = 0x1c
	// Bit mask of B2B1 field.
	ADC_ETC_TRIG0_CHAIN_1_0_B2B1_Msk = 0x10000000
	// Bit B2B1.
	ADC_ETC_TRIG0_CHAIN_1_0_B2B1 = 0x10000000
	// Position of IE1 field.
	ADC_ETC_TRIG0_CHAIN_1_0_IE1_Pos = 0x1d
	// Bit mask of IE1 field.
	ADC_ETC_TRIG0_CHAIN_1_0_IE1_Msk = 0x60000000
	// Position of IE1_EN field.
	ADC_ETC_TRIG0_CHAIN_1_0_IE1_EN_Pos = 0x1f
	// Bit mask of IE1_EN field.
	ADC_ETC_TRIG0_CHAIN_1_0_IE1_EN_Msk = 0x80000000
	// Bit IE1_EN.
	ADC_ETC_TRIG0_CHAIN_1_0_IE1_EN = 0x80000000

	// TRIG0_CHAIN_3_2: ETC_TRIG Chain 2/3 Register
	// Position of CSEL2 field.
	ADC_ETC_TRIG0_CHAIN_3_2_CSEL2_Pos = 0x0
	// Bit mask of CSEL2 field.
	ADC_ETC_TRIG0_CHAIN_3_2_CSEL2_Msk = 0xf
	// Position of HWTS2 field.
	ADC_ETC_TRIG0_CHAIN_3_2_HWTS2_Pos = 0x4
	// Bit mask of HWTS2 field.
	ADC_ETC_TRIG0_CHAIN_3_2_HWTS2_Msk = 0xff0
	// Position of B2B2 field.
	ADC_ETC_TRIG0_CHAIN_3_2_B2B2_Pos = 0xc
	// Bit mask of B2B2 field.
	ADC_ETC_TRIG0_CHAIN_3_2_B2B2_Msk = 0x1000
	// Bit B2B2.
	ADC_ETC_TRIG0_CHAIN_3_2_B2B2 = 0x1000
	// Position of IE2 field.
	ADC_ETC_TRIG0_CHAIN_3_2_IE2_Pos = 0xd
	// Bit mask of IE2 field.
	ADC_ETC_TRIG0_CHAIN_3_2_IE2_Msk = 0x6000
	// Position of IE2_EN field.
	ADC_ETC_TRIG0_CHAIN_3_2_IE2_EN_Pos = 0xf
	// Bit mask of IE2_EN field.
	ADC_ETC_TRIG0_CHAIN_3_2_IE2_EN_Msk = 0x8000
	// Bit IE2_EN.
	ADC_ETC_TRIG0_CHAIN_3_2_IE2_EN = 0x8000
	// Position of CSEL3 field.
	ADC_ETC_TRIG0_CHAIN_3_2_CSEL3_Pos = 0x10
	// Bit mask of CSEL3 field.
	ADC_ETC_TRIG0_CHAIN_3_2_CSEL3_Msk = 0xf0000
	// Position of HWTS3 field.
	ADC_ETC_TRIG0_CHAIN_3_2_HWTS3_Pos = 0x14
	// Bit mask of HWTS3 field.
	ADC_ETC_TRIG0_CHAIN_3_2_HWTS3_Msk = 0xff00000
	// Position of B2B3 field.
	ADC_ETC_TRIG0_CHAIN_3_2_B2B3_Pos = 0x1c
	// Bit mask of B2B3 field.
	ADC_ETC_TRIG0_CHAIN_3_2_B2B3_Msk = 0x10000000
	// Bit B2B3.
	ADC_ETC_TRIG0_CHAIN_3_2_B2B3 = 0x10000000
	// Position of IE3 field.
	ADC_ETC_TRIG0_CHAIN_3_2_IE3_Pos = 0x1d
	// Bit mask of IE3 field.
	ADC_ETC_TRIG0_CHAIN_3_2_IE3_Msk = 0x60000000
	// Position of IE3_EN field.
	ADC_ETC_TRIG0_CHAIN_3_2_IE3_EN_Pos = 0x1f
	// Bit mask of IE3_EN field.
	ADC_ETC_TRIG0_CHAIN_3_2_IE3_EN_Msk = 0x80000000
	// Bit IE3_EN.
	ADC_ETC_TRIG0_CHAIN_3_2_IE3_EN = 0x80000000

	// TRIG0_CHAIN_5_4: ETC_TRIG Chain 4/5 Register
	// Position of CSEL4 field.
	ADC_ETC_TRIG0_CHAIN_5_4_CSEL4_Pos = 0x0
	// Bit mask of CSEL4 field.
	ADC_ETC_TRIG0_CHAIN_5_4_CSEL4_Msk = 0xf
	// Position of HWTS4 field.
	ADC_ETC_TRIG0_CHAIN_5_4_HWTS4_Pos = 0x4
	// Bit mask of HWTS4 field.
	ADC_ETC_TRIG0_CHAIN_5_4_HWTS4_Msk = 0xff0
	// Position of B2B4 field.
	ADC_ETC_TRIG0_CHAIN_5_4_B2B4_Pos = 0xc
	// Bit mask of B2B4 field.
	ADC_ETC_TRIG0_CHAIN_5_4_B2B4_Msk = 0x1000
	// Bit B2B4.
	ADC_ETC_TRIG0_CHAIN_5_4_B2B4 = 0x1000
	// Position of IE4 field.
	ADC_ETC_TRIG0_CHAIN_5_4_IE4_Pos = 0xd
	// Bit mask of IE4 field.
	ADC_ETC_TRIG0_CHAIN_5_4_IE4_Msk = 0x6000
	// Position of IE4_EN field.
	ADC_ETC_TRIG0_CHAIN_5_4_IE4_EN_Pos = 0xf
	// Bit mask of IE4_EN field.
	ADC_ETC_TRIG0_CHAIN_5_4_IE4_EN_Msk = 0x8000
	// Bit IE4_EN.
	ADC_ETC_TRIG0_CHAIN_5_4_IE4_EN = 0x8000
	// Position of CSEL5 field.
	ADC_ETC_TRIG0_CHAIN_5_4_CSEL5_Pos = 0x10
	// Bit mask of CSEL5 field.
	ADC_ETC_TRIG0_CHAIN_5_4_CSEL5_Msk = 0xf0000
	// Position of HWTS5 field.
	ADC_ETC_TRIG0_CHAIN_5_4_HWTS5_Pos = 0x14
	// Bit mask of HWTS5 field.
	ADC_ETC_TRIG0_CHAIN_5_4_HWTS5_Msk = 0xff00000
	// Position of B2B5 field.
	ADC_ETC_TRIG0_CHAIN_5_4_B2B5_Pos = 0x1c
	// Bit mask of B2B5 field.
	ADC_ETC_TRIG0_CHAIN_5_4_B2B5_Msk = 0x10000000
	// Bit B2B5.
	ADC_ETC_TRIG0_CHAIN_5_4_B2B5 = 0x10000000
	// Position of IE5 field.
	ADC_ETC_TRIG0_CHAIN_5_4_IE5_Pos = 0x1d
	// Bit mask of IE5 field.
	ADC_ETC_TRIG0_CHAIN_5_4_IE5_Msk = 0x60000000
	// Position of IE5_EN field.
	ADC_ETC_TRIG0_CHAIN_5_4_IE5_EN_Pos = 0x1f
	// Bit mask of IE5_EN field.
	ADC_ETC_TRIG0_CHAIN_5_4_IE5_EN_Msk = 0x80000000
	// Bit IE5_EN.
	ADC_ETC_TRIG0_CHAIN_5_4_IE5_EN = 0x80000000

	// TRIG0_CHAIN_7_6: ETC_TRIG Chain 6/7 Register
	// Position of CSEL6 field.
	ADC_ETC_TRIG0_CHAIN_7_6_CSEL6_Pos = 0x0
	// Bit mask of CSEL6 field.
	ADC_ETC_TRIG0_CHAIN_7_6_CSEL6_Msk = 0xf
	// Position of HWTS6 field.
	ADC_ETC_TRIG0_CHAIN_7_6_HWTS6_Pos = 0x4
	// Bit mask of HWTS6 field.
	ADC_ETC_TRIG0_CHAIN_7_6_HWTS6_Msk = 0xff0
	// Position of B2B6 field.
	ADC_ETC_TRIG0_CHAIN_7_6_B2B6_Pos = 0xc
	// Bit mask of B2B6 field.
	ADC_ETC_TRIG0_CHAIN_7_6_B2B6_Msk = 0x1000
	// Bit B2B6.
	ADC_ETC_TRIG0_CHAIN_7_6_B2B6 = 0x1000
	// Position of IE6 field.
	ADC_ETC_TRIG0_CHAIN_7_6_IE6_Pos = 0xd
	// Bit mask of IE6 field.
	ADC_ETC_TRIG0_CHAIN_7_6_IE6_Msk = 0x6000
	// Position of IE6_EN field.
	ADC_ETC_TRIG0_CHAIN_7_6_IE6_EN_Pos = 0xf
	// Bit mask of IE6_EN field.
	ADC_ETC_TRIG0_CHAIN_7_6_IE6_EN_Msk = 0x8000
	// Bit IE6_EN.
	ADC_ETC_TRIG0_CHAIN_7_6_IE6_EN = 0x8000
	// Position of CSEL7 field.
	ADC_ETC_TRIG0_CHAIN_7_6_CSEL7_Pos = 0x10
	// Bit mask of CSEL7 field.
	ADC_ETC_TRIG0_CHAIN_7_6_CSEL7_Msk = 0xf0000
	// Position of HWTS7 field.
	ADC_ETC_TRIG0_CHAIN_7_6_HWTS7_Pos = 0x14
	// Bit mask of HWTS7 field.
	ADC_ETC_TRIG0_CHAIN_7_6_HWTS7_Msk = 0xff00000
	// Position of B2B7 field.
	ADC_ETC_TRIG0_CHAIN_7_6_B2B7_Pos = 0x1c
	// Bit mask of B2B7 field.
	ADC_ETC_TRIG0_CHAIN_7_6_B2B7_Msk = 0x10000000
	// Bit B2B7.
	ADC_ETC_TRIG0_CHAIN_7_6_B2B7 = 0x10000000
	// Position of IE7 field.
	ADC_ETC_TRIG0_CHAIN_7_6_IE7_Pos = 0x1d
	// Bit mask of IE7 field.
	ADC_ETC_TRIG0_CHAIN_7_6_IE7_Msk = 0x60000000
	// Position of IE7_EN field.
	ADC_ETC_TRIG0_CHAIN_7_6_IE7_EN_Pos = 0x1f
	// Bit mask of IE7_EN field.
	ADC_ETC_TRIG0_CHAIN_7_6_IE7_EN_Msk = 0x80000000
	// Bit IE7_EN.
	ADC_ETC_TRIG0_CHAIN_7_6_IE7_EN = 0x80000000

	// TRIG0_RESULT_1_0: ETC_TRIG Result Data 1/0 Register
	// Position of DATA0 field.
	ADC_ETC_TRIG0_RESULT_1_0_DATA0_Pos = 0x0
	// Bit mask of DATA0 field.
	ADC_ETC_TRIG0_RESULT_1_0_DATA0_Msk = 0xfff
	// Position of DATA1 field.
	ADC_ETC_TRIG0_RESULT_1_0_DATA1_Pos = 0x10
	// Bit mask of DATA1 field.
	ADC_ETC_TRIG0_RESULT_1_0_DATA1_Msk = 0xfff0000

	// TRIG0_RESULT_3_2: ETC_TRIG Result Data 3/2 Register
	// Position of DATA2 field.
	ADC_ETC_TRIG0_RESULT_3_2_DATA2_Pos = 0x0
	// Bit mask of DATA2 field.
	ADC_ETC_TRIG0_RESULT_3_2_DATA2_Msk = 0xfff
	// Position of DATA3 field.
	ADC_ETC_TRIG0_RESULT_3_2_DATA3_Pos = 0x10
	// Bit mask of DATA3 field.
	ADC_ETC_TRIG0_RESULT_3_2_DATA3_Msk = 0xfff0000

	// TRIG0_RESULT_5_4: ETC_TRIG Result Data 5/4 Register
	// Position of DATA4 field.
	ADC_ETC_TRIG0_RESULT_5_4_DATA4_Pos = 0x0
	// Bit mask of DATA4 field.
	ADC_ETC_TRIG0_RESULT_5_4_DATA4_Msk = 0xfff
	// Position of DATA5 field.
	ADC_ETC_TRIG0_RESULT_5_4_DATA5_Pos = 0x10
	// Bit mask of DATA5 field.
	ADC_ETC_TRIG0_RESULT_5_4_DATA5_Msk = 0xfff0000

	// TRIG0_RESULT_7_6: ETC_TRIG Result Data 7/6 Register
	// Position of DATA6 field.
	ADC_ETC_TRIG0_RESULT_7_6_DATA6_Pos = 0x0
	// Bit mask of DATA6 field.
	ADC_ETC_TRIG0_RESULT_7_6_DATA6_Msk = 0xfff
	// Position of DATA7 field.
	ADC_ETC_TRIG0_RESULT_7_6_DATA7_Pos = 0x10
	// Bit mask of DATA7 field.
	ADC_ETC_TRIG0_RESULT_7_6_DATA7_Msk = 0xfff0000

	// TRIG1_CTRL: ETC_TRIG Control Register
	// Position of SW_TRIG field.
	ADC_ETC_TRIG1_CTRL_SW_TRIG_Pos = 0x0
	// Bit mask of SW_TRIG field.
	ADC_ETC_TRIG1_CTRL_SW_TRIG_Msk = 0x1
	// Bit SW_TRIG.
	ADC_ETC_TRIG1_CTRL_SW_TRIG = 0x1
	// Position of TRIG_MODE field.
	ADC_ETC_TRIG1_CTRL_TRIG_MODE_Pos = 0x4
	// Bit mask of TRIG_MODE field.
	ADC_ETC_TRIG1_CTRL_TRIG_MODE_Msk = 0x10
	// Bit TRIG_MODE.
	ADC_ETC_TRIG1_CTRL_TRIG_MODE = 0x10
	// Position of TRIG_CHAIN field.
	ADC_ETC_TRIG1_CTRL_TRIG_CHAIN_Pos = 0x8
	// Bit mask of TRIG_CHAIN field.
	ADC_ETC_TRIG1_CTRL_TRIG_CHAIN_Msk = 0x700
	// Position of TRIG_PRIORITY field.
	ADC_ETC_TRIG1_CTRL_TRIG_PRIORITY_Pos = 0xc
	// Bit mask of TRIG_PRIORITY field.
	ADC_ETC_TRIG1_CTRL_TRIG_PRIORITY_Msk = 0x7000
	// Position of SYNC_MODE field.
	ADC_ETC_TRIG1_CTRL_SYNC_MODE_Pos = 0x10
	// Bit mask of SYNC_MODE field.
	ADC_ETC_TRIG1_CTRL_SYNC_MODE_Msk = 0x10000
	// Bit SYNC_MODE.
	ADC_ETC_TRIG1_CTRL_SYNC_MODE = 0x10000
	// Position of CHAINx_DONE field.
	ADC_ETC_TRIG1_CTRL_CHAINx_DONE_Pos = 0x18
	// Bit mask of CHAINx_DONE field.
	ADC_ETC_TRIG1_CTRL_CHAINx_DONE_Msk = 0xff000000

	// TRIG1_COUNTER: ETC_TRIG Counter Register
	// Position of INIT_DELAY field.
	ADC_ETC_TRIG1_COUNTER_INIT_DELAY_Pos = 0x0
	// Bit mask of INIT_DELAY field.
	ADC_ETC_TRIG1_COUNTER_INIT_DELAY_Msk = 0xffff
	// Position of SAMPLE_INTERVAL field.
	ADC_ETC_TRIG1_COUNTER_SAMPLE_INTERVAL_Pos = 0x10
	// Bit mask of SAMPLE_INTERVAL field.
	ADC_ETC_TRIG1_COUNTER_SAMPLE_INTERVAL_Msk = 0xffff0000

	// TRIG1_CHAIN_1_0: ETC_TRIG Chain 0/1 Register
	// Position of CSEL0 field.
	ADC_ETC_TRIG1_CHAIN_1_0_CSEL0_Pos = 0x0
	// Bit mask of CSEL0 field.
	ADC_ETC_TRIG1_CHAIN_1_0_CSEL0_Msk = 0xf
	// Position of HWTS0 field.
	ADC_ETC_TRIG1_CHAIN_1_0_HWTS0_Pos = 0x4
	// Bit mask of HWTS0 field.
	ADC_ETC_TRIG1_CHAIN_1_0_HWTS0_Msk = 0xff0
	// Position of B2B0 field.
	ADC_ETC_TRIG1_CHAIN_1_0_B2B0_Pos = 0xc
	// Bit mask of B2B0 field.
	ADC_ETC_TRIG1_CHAIN_1_0_B2B0_Msk = 0x1000
	// Bit B2B0.
	ADC_ETC_TRIG1_CHAIN_1_0_B2B0 = 0x1000
	// Position of IE0 field.
	ADC_ETC_TRIG1_CHAIN_1_0_IE0_Pos = 0xd
	// Bit mask of IE0 field.
	ADC_ETC_TRIG1_CHAIN_1_0_IE0_Msk = 0x6000
	// Position of IE0_EN field.
	ADC_ETC_TRIG1_CHAIN_1_0_IE0_EN_Pos = 0xf
	// Bit mask of IE0_EN field.
	ADC_ETC_TRIG1_CHAIN_1_0_IE0_EN_Msk = 0x8000
	// Bit IE0_EN.
	ADC_ETC_TRIG1_CHAIN_1_0_IE0_EN = 0x8000
	// Position of CSEL1 field.
	ADC_ETC_TRIG1_CHAIN_1_0_CSEL1_Pos = 0x10
	// Bit mask of CSEL1 field.
	ADC_ETC_TRIG1_CHAIN_1_0_CSEL1_Msk = 0xf0000
	// Position of HWTS1 field.
	ADC_ETC_TRIG1_CHAIN_1_0_HWTS1_Pos = 0x14
	// Bit mask of HWTS1 field.
	ADC_ETC_TRIG1_CHAIN_1_0_HWTS1_Msk = 0xff00000
	// Position of B2B1 field.
	ADC_ETC_TRIG1_CHAIN_1_0_B2B1_Pos = 0x1c
	// Bit mask of B2B1 field.
	ADC_ETC_TRIG1_CHAIN_1_0_B2B1_Msk = 0x10000000
	// Bit B2B1.
	ADC_ETC_TRIG1_CHAIN_1_0_B2B1 = 0x10000000
	// Position of IE1 field.
	ADC_ETC_TRIG1_CHAIN_1_0_IE1_Pos = 0x1d
	// Bit mask of IE1 field.
	ADC_ETC_TRIG1_CHAIN_1_0_IE1_Msk = 0x60000000
	// Position of IE1_EN field.
	ADC_ETC_TRIG1_CHAIN_1_0_IE1_EN_Pos = 0x1f
	// Bit mask of IE1_EN field.
	ADC_ETC_TRIG1_CHAIN_1_0_IE1_EN_Msk = 0x80000000
	// Bit IE1_EN.
	ADC_ETC_TRIG1_CHAIN_1_0_IE1_EN = 0x80000000

	// TRIG1_CHAIN_3_2: ETC_TRIG Chain 2/3 Register
	// Position of CSEL2 field.
	ADC_ETC_TRIG1_CHAIN_3_2_CSEL2_Pos = 0x0
	// Bit mask of CSEL2 field.
	ADC_ETC_TRIG1_CHAIN_3_2_CSEL2_Msk = 0xf
	// Position of HWTS2 field.
	ADC_ETC_TRIG1_CHAIN_3_2_HWTS2_Pos = 0x4
	// Bit mask of HWTS2 field.
	ADC_ETC_TRIG1_CHAIN_3_2_HWTS2_Msk = 0xff0
	// Position of B2B2 field.
	ADC_ETC_TRIG1_CHAIN_3_2_B2B2_Pos = 0xc
	// Bit mask of B2B2 field.
	ADC_ETC_TRIG1_CHAIN_3_2_B2B2_Msk = 0x1000
	// Bit B2B2.
	ADC_ETC_TRIG1_CHAIN_3_2_B2B2 = 0x1000
	// Position of IE2 field.
	ADC_ETC_TRIG1_CHAIN_3_2_IE2_Pos = 0xd
	// Bit mask of IE2 field.
	ADC_ETC_TRIG1_CHAIN_3_2_IE2_Msk = 0x6000
	// Position of IE2_EN field.
	ADC_ETC_TRIG1_CHAIN_3_2_IE2_EN_Pos = 0xf
	// Bit mask of IE2_EN field.
	ADC_ETC_TRIG1_CHAIN_3_2_IE2_EN_Msk = 0x8000
	// Bit IE2_EN.
	ADC_ETC_TRIG1_CHAIN_3_2_IE2_EN = 0x8000
	// Position of CSEL3 field.
	ADC_ETC_TRIG1_CHAIN_3_2_CSEL3_Pos = 0x10
	// Bit mask of CSEL3 field.
	ADC_ETC_TRIG1_CHAIN_3_2_CSEL3_Msk = 0xf0000
	// Position of HWTS3 field.
	ADC_ETC_TRIG1_CHAIN_3_2_HWTS3_Pos = 0x14
	// Bit mask of HWTS3 field.
	ADC_ETC_TRIG1_CHAIN_3_2_HWTS3_Msk = 0xff00000
	// Position of B2B3 field.
	ADC_ETC_TRIG1_CHAIN_3_2_B2B3_Pos = 0x1c
	// Bit mask of B2B3 field.
	ADC_ETC_TRIG1_CHAIN_3_2_B2B3_Msk = 0x10000000
	// Bit B2B3.
	ADC_ETC_TRIG1_CHAIN_3_2_B2B3 = 0x10000000
	// Position of IE3 field.
	ADC_ETC_TRIG1_CHAIN_3_2_IE3_Pos = 0x1d
	// Bit mask of IE3 field.
	ADC_ETC_TRIG1_CHAIN_3_2_IE3_Msk = 0x60000000
	// Position of IE3_EN field.
	ADC_ETC_TRIG1_CHAIN_3_2_IE3_EN_Pos = 0x1f
	// Bit mask of IE3_EN field.
	ADC_ETC_TRIG1_CHAIN_3_2_IE3_EN_Msk = 0x80000000
	// Bit IE3_EN.
	ADC_ETC_TRIG1_CHAIN_3_2_IE3_EN = 0x80000000

	// TRIG1_CHAIN_5_4: ETC_TRIG Chain 4/5 Register
	// Position of CSEL4 field.
	ADC_ETC_TRIG1_CHAIN_5_4_CSEL4_Pos = 0x0
	// Bit mask of CSEL4 field.
	ADC_ETC_TRIG1_CHAIN_5_4_CSEL4_Msk = 0xf
	// Position of HWTS4 field.
	ADC_ETC_TRIG1_CHAIN_5_4_HWTS4_Pos = 0x4
	// Bit mask of HWTS4 field.
	ADC_ETC_TRIG1_CHAIN_5_4_HWTS4_Msk = 0xff0
	// Position of B2B4 field.
	ADC_ETC_TRIG1_CHAIN_5_4_B2B4_Pos = 0xc
	// Bit mask of B2B4 field.
	ADC_ETC_TRIG1_CHAIN_5_4_B2B4_Msk = 0x1000
	// Bit B2B4.
	ADC_ETC_TRIG1_CHAIN_5_4_B2B4 = 0x1000
	// Position of IE4 field.
	ADC_ETC_TRIG1_CHAIN_5_4_IE4_Pos = 0xd
	// Bit mask of IE4 field.
	ADC_ETC_TRIG1_CHAIN_5_4_IE4_Msk = 0x6000
	// Position of IE4_EN field.
	ADC_ETC_TRIG1_CHAIN_5_4_IE4_EN_Pos = 0xf
	// Bit mask of IE4_EN field.
	ADC_ETC_TRIG1_CHAIN_5_4_IE4_EN_Msk = 0x8000
	// Bit IE4_EN.
	ADC_ETC_TRIG1_CHAIN_5_4_IE4_EN = 0x8000
	// Position of CSEL5 field.
	ADC_ETC_TRIG1_CHAIN_5_4_CSEL5_Pos = 0x10
	// Bit mask of CSEL5 field.
	ADC_ETC_TRIG1_CHAIN_5_4_CSEL5_Msk = 0xf0000
	// Position of HWTS5 field.
	ADC_ETC_TRIG1_CHAIN_5_4_HWTS5_Pos = 0x14
	// Bit mask of HWTS5 field.
	ADC_ETC_TRIG1_CHAIN_5_4_HWTS5_Msk = 0xff00000
	// Position of B2B5 field.
	ADC_ETC_TRIG1_CHAIN_5_4_B2B5_Pos = 0x1c
	// Bit mask of B2B5 field.
	ADC_ETC_TRIG1_CHAIN_5_4_B2B5_Msk = 0x10000000
	// Bit B2B5.
	ADC_ETC_TRIG1_CHAIN_5_4_B2B5 = 0x10000000
	// Position of IE5 field.
	ADC_ETC_TRIG1_CHAIN_5_4_IE5_Pos = 0x1d
	// Bit mask of IE5 field.
	ADC_ETC_TRIG1_CHAIN_5_4_IE5_Msk = 0x60000000
	// Position of IE5_EN field.
	ADC_ETC_TRIG1_CHAIN_5_4_IE5_EN_Pos = 0x1f
	// Bit mask of IE5_EN field.
	ADC_ETC_TRIG1_CHAIN_5_4_IE5_EN_Msk = 0x80000000
	// Bit IE5_EN.
	ADC_ETC_TRIG1_CHAIN_5_4_IE5_EN = 0x80000000

	// TRIG1_CHAIN_7_6: ETC_TRIG Chain 6/7 Register
	// Position of CSEL6 field.
	ADC_ETC_TRIG1_CHAIN_7_6_CSEL6_Pos = 0x0
	// Bit mask of CSEL6 field.
	ADC_ETC_TRIG1_CHAIN_7_6_CSEL6_Msk = 0xf
	// Position of HWTS6 field.
	ADC_ETC_TRIG1_CHAIN_7_6_HWTS6_Pos = 0x4
	// Bit mask of HWTS6 field.
	ADC_ETC_TRIG1_CHAIN_7_6_HWTS6_Msk = 0xff0
	// Position of B2B6 field.
	ADC_ETC_TRIG1_CHAIN_7_6_B2B6_Pos = 0xc
	// Bit mask of B2B6 field.
	ADC_ETC_TRIG1_CHAIN_7_6_B2B6_Msk = 0x1000
	// Bit B2B6.
	ADC_ETC_TRIG1_CHAIN_7_6_B2B6 = 0x1000
	// Position of IE6 field.
	ADC_ETC_TRIG1_CHAIN_7_6_IE6_Pos = 0xd
	// Bit mask of IE6 field.
	ADC_ETC_TRIG1_CHAIN_7_6_IE6_Msk = 0x6000
	// Position of IE6_EN field.
	ADC_ETC_TRIG1_CHAIN_7_6_IE6_EN_Pos = 0xf
	// Bit mask of IE6_EN field.
	ADC_ETC_TRIG1_CHAIN_7_6_IE6_EN_Msk = 0x8000
	// Bit IE6_EN.
	ADC_ETC_TRIG1_CHAIN_7_6_IE6_EN = 0x8000
	// Position of CSEL7 field.
	ADC_ETC_TRIG1_CHAIN_7_6_CSEL7_Pos = 0x10
	// Bit mask of CSEL7 field.
	ADC_ETC_TRIG1_CHAIN_7_6_CSEL7_Msk = 0xf0000
	// Position of HWTS7 field.
	ADC_ETC_TRIG1_CHAIN_7_6_HWTS7_Pos = 0x14
	// Bit mask of HWTS7 field.
	ADC_ETC_TRIG1_CHAIN_7_6_HWTS7_Msk = 0xff00000
	// Position of B2B7 field.
	ADC_ETC_TRIG1_CHAIN_7_6_B2B7_Pos = 0x1c
	// Bit mask of B2B7 field.
	ADC_ETC_TRIG1_CHAIN_7_6_B2B7_Msk = 0x10000000
	// Bit B2B7.
	ADC_ETC_TRIG1_CHAIN_7_6_B2B7 = 0x10000000
	// Position of IE7 field.
	ADC_ETC_TRIG1_CHAIN_7_6_IE7_Pos = 0x1d
	// Bit mask of IE7 field.
	ADC_ETC_TRIG1_CHAIN_7_6_IE7_Msk = 0x60000000
	// Position of IE7_EN field.
	ADC_ETC_TRIG1_CHAIN_7_6_IE7_EN_Pos = 0x1f
	// Bit mask of IE7_EN field.
	ADC_ETC_TRIG1_CHAIN_7_6_IE7_EN_Msk = 0x80000000
	// Bit IE7_EN.
	ADC_ETC_TRIG1_CHAIN_7_6_IE7_EN = 0x80000000

	// TRIG1_RESULT_1_0: ETC_TRIG Result Data 1/0 Register
	// Position of DATA0 field.
	ADC_ETC_TRIG1_RESULT_1_0_DATA0_Pos = 0x0
	// Bit mask of DATA0 field.
	ADC_ETC_TRIG1_RESULT_1_0_DATA0_Msk = 0xfff
	// Position of DATA1 field.
	ADC_ETC_TRIG1_RESULT_1_0_DATA1_Pos = 0x10
	// Bit mask of DATA1 field.
	ADC_ETC_TRIG1_RESULT_1_0_DATA1_Msk = 0xfff0000

	// TRIG1_RESULT_3_2: ETC_TRIG Result Data 3/2 Register
	// Position of DATA2 field.
	ADC_ETC_TRIG1_RESULT_3_2_DATA2_Pos = 0x0
	// Bit mask of DATA2 field.
	ADC_ETC_TRIG1_RESULT_3_2_DATA2_Msk = 0xfff
	// Position of DATA3 field.
	ADC_ETC_TRIG1_RESULT_3_2_DATA3_Pos = 0x10
	// Bit mask of DATA3 field.
	ADC_ETC_TRIG1_RESULT_3_2_DATA3_Msk = 0xfff0000

	// TRIG1_RESULT_5_4: ETC_TRIG Result Data 5/4 Register
	// Position of DATA4 field.
	ADC_ETC_TRIG1_RESULT_5_4_DATA4_Pos = 0x0
	// Bit mask of DATA4 field.
	ADC_ETC_TRIG1_RESULT_5_4_DATA4_Msk = 0xfff
	// Position of DATA5 field.
	ADC_ETC_TRIG1_RESULT_5_4_DATA5_Pos = 0x10
	// Bit mask of DATA5 field.
	ADC_ETC_TRIG1_RESULT_5_4_DATA5_Msk = 0xfff0000

	// TRIG1_RESULT_7_6: ETC_TRIG Result Data 7/6 Register
	// Position of DATA6 field.
	ADC_ETC_TRIG1_RESULT_7_6_DATA6_Pos = 0x0
	// Bit mask of DATA6 field.
	ADC_ETC_TRIG1_RESULT_7_6_DATA6_Msk = 0xfff
	// Position of DATA7 field.
	ADC_ETC_TRIG1_RESULT_7_6_DATA7_Pos = 0x10
	// Bit mask of DATA7 field.
	ADC_ETC_TRIG1_RESULT_7_6_DATA7_Msk = 0xfff0000

	// TRIG2_CTRL: ETC_TRIG Control Register
	// Position of SW_TRIG field.
	ADC_ETC_TRIG2_CTRL_SW_TRIG_Pos = 0x0
	// Bit mask of SW_TRIG field.
	ADC_ETC_TRIG2_CTRL_SW_TRIG_Msk = 0x1
	// Bit SW_TRIG.
	ADC_ETC_TRIG2_CTRL_SW_TRIG = 0x1
	// Position of TRIG_MODE field.
	ADC_ETC_TRIG2_CTRL_TRIG_MODE_Pos = 0x4
	// Bit mask of TRIG_MODE field.
	ADC_ETC_TRIG2_CTRL_TRIG_MODE_Msk = 0x10
	// Bit TRIG_MODE.
	ADC_ETC_TRIG2_CTRL_TRIG_MODE = 0x10
	// Position of TRIG_CHAIN field.
	ADC_ETC_TRIG2_CTRL_TRIG_CHAIN_Pos = 0x8
	// Bit mask of TRIG_CHAIN field.
	ADC_ETC_TRIG2_CTRL_TRIG_CHAIN_Msk = 0x700
	// Position of TRIG_PRIORITY field.
	ADC_ETC_TRIG2_CTRL_TRIG_PRIORITY_Pos = 0xc
	// Bit mask of TRIG_PRIORITY field.
	ADC_ETC_TRIG2_CTRL_TRIG_PRIORITY_Msk = 0x7000
	// Position of SYNC_MODE field.
	ADC_ETC_TRIG2_CTRL_SYNC_MODE_Pos = 0x10
	// Bit mask of SYNC_MODE field.
	ADC_ETC_TRIG2_CTRL_SYNC_MODE_Msk = 0x10000
	// Bit SYNC_MODE.
	ADC_ETC_TRIG2_CTRL_SYNC_MODE = 0x10000
	// Position of CHAINx_DONE field.
	ADC_ETC_TRIG2_CTRL_CHAINx_DONE_Pos = 0x18
	// Bit mask of CHAINx_DONE field.
	ADC_ETC_TRIG2_CTRL_CHAINx_DONE_Msk = 0xff000000

	// TRIG2_COUNTER: ETC_TRIG Counter Register
	// Position of INIT_DELAY field.
	ADC_ETC_TRIG2_COUNTER_INIT_DELAY_Pos = 0x0
	// Bit mask of INIT_DELAY field.
	ADC_ETC_TRIG2_COUNTER_INIT_DELAY_Msk = 0xffff
	// Position of SAMPLE_INTERVAL field.
	ADC_ETC_TRIG2_COUNTER_SAMPLE_INTERVAL_Pos = 0x10
	// Bit mask of SAMPLE_INTERVAL field.
	ADC_ETC_TRIG2_COUNTER_SAMPLE_INTERVAL_Msk = 0xffff0000

	// TRIG2_CHAIN_1_0: ETC_TRIG Chain 0/1 Register
	// Position of CSEL0 field.
	ADC_ETC_TRIG2_CHAIN_1_0_CSEL0_Pos = 0x0
	// Bit mask of CSEL0 field.
	ADC_ETC_TRIG2_CHAIN_1_0_CSEL0_Msk = 0xf
	// Position of HWTS0 field.
	ADC_ETC_TRIG2_CHAIN_1_0_HWTS0_Pos = 0x4
	// Bit mask of HWTS0 field.
	ADC_ETC_TRIG2_CHAIN_1_0_HWTS0_Msk = 0xff0
	// Position of B2B0 field.
	ADC_ETC_TRIG2_CHAIN_1_0_B2B0_Pos = 0xc
	// Bit mask of B2B0 field.
	ADC_ETC_TRIG2_CHAIN_1_0_B2B0_Msk = 0x1000
	// Bit B2B0.
	ADC_ETC_TRIG2_CHAIN_1_0_B2B0 = 0x1000
	// Position of IE0 field.
	ADC_ETC_TRIG2_CHAIN_1_0_IE0_Pos = 0xd
	// Bit mask of IE0 field.
	ADC_ETC_TRIG2_CHAIN_1_0_IE0_Msk = 0x6000
	// Position of IE0_EN field.
	ADC_ETC_TRIG2_CHAIN_1_0_IE0_EN_Pos = 0xf
	// Bit mask of IE0_EN field.
	ADC_ETC_TRIG2_CHAIN_1_0_IE0_EN_Msk = 0x8000
	// Bit IE0_EN.
	ADC_ETC_TRIG2_CHAIN_1_0_IE0_EN = 0x8000
	// Position of CSEL1 field.
	ADC_ETC_TRIG2_CHAIN_1_0_CSEL1_Pos = 0x10
	// Bit mask of CSEL1 field.
	ADC_ETC_TRIG2_CHAIN_1_0_CSEL1_Msk = 0xf0000
	// Position of HWTS1 field.
	ADC_ETC_TRIG2_CHAIN_1_0_HWTS1_Pos = 0x14
	// Bit mask of HWTS1 field.
	ADC_ETC_TRIG2_CHAIN_1_0_HWTS1_Msk = 0xff00000
	// Position of B2B1 field.
	ADC_ETC_TRIG2_CHAIN_1_0_B2B1_Pos = 0x1c
	// Bit mask of B2B1 field.
	ADC_ETC_TRIG2_CHAIN_1_0_B2B1_Msk = 0x10000000
	// Bit B2B1.
	ADC_ETC_TRIG2_CHAIN_1_0_B2B1 = 0x10000000
	// Position of IE1 field.
	ADC_ETC_TRIG2_CHAIN_1_0_IE1_Pos = 0x1d
	// Bit mask of IE1 field.
	ADC_ETC_TRIG2_CHAIN_1_0_IE1_Msk = 0x60000000
	// Position of IE1_EN field.
	ADC_ETC_TRIG2_CHAIN_1_0_IE1_EN_Pos = 0x1f
	// Bit mask of IE1_EN field.
	ADC_ETC_TRIG2_CHAIN_1_0_IE1_EN_Msk = 0x80000000
	// Bit IE1_EN.
	ADC_ETC_TRIG2_CHAIN_1_0_IE1_EN = 0x80000000

	// TRIG2_CHAIN_3_2: ETC_TRIG Chain 2/3 Register
	// Position of CSEL2 field.
	ADC_ETC_TRIG2_CHAIN_3_2_CSEL2_Pos = 0x0
	// Bit mask of CSEL2 field.
	ADC_ETC_TRIG2_CHAIN_3_2_CSEL2_Msk = 0xf
	// Position of HWTS2 field.
	ADC_ETC_TRIG2_CHAIN_3_2_HWTS2_Pos = 0x4
	// Bit mask of HWTS2 field.
	ADC_ETC_TRIG2_CHAIN_3_2_HWTS2_Msk = 0xff0
	// Position of B2B2 field.
	ADC_ETC_TRIG2_CHAIN_3_2_B2B2_Pos = 0xc
	// Bit mask of B2B2 field.
	ADC_ETC_TRIG2_CHAIN_3_2_B2B2_Msk = 0x1000
	// Bit B2B2.
	ADC_ETC_TRIG2_CHAIN_3_2_B2B2 = 0x1000
	// Position of IE2 field.
	ADC_ETC_TRIG2_CHAIN_3_2_IE2_Pos = 0xd
	// Bit mask of IE2 field.
	ADC_ETC_TRIG2_CHAIN_3_2_IE2_Msk = 0x6000
	// Position of IE2_EN field.
	ADC_ETC_TRIG2_CHAIN_3_2_IE2_EN_Pos = 0xf
	// Bit mask of IE2_EN field.
	ADC_ETC_TRIG2_CHAIN_3_2_IE2_EN_Msk = 0x8000
	// Bit IE2_EN.
	ADC_ETC_TRIG2_CHAIN_3_2_IE2_EN = 0x8000
	// Position of CSEL3 field.
	ADC_ETC_TRIG2_CHAIN_3_2_CSEL3_Pos = 0x10
	// Bit mask of CSEL3 field.
	ADC_ETC_TRIG2_CHAIN_3_2_CSEL3_Msk = 0xf0000
	// Position of HWTS3 field.
	ADC_ETC_TRIG2_CHAIN_3_2_HWTS3_Pos = 0x14
	// Bit mask of HWTS3 field.
	ADC_ETC_TRIG2_CHAIN_3_2_HWTS3_Msk = 0xff00000
	// Position of B2B3 field.
	ADC_ETC_TRIG2_CHAIN_3_2_B2B3_Pos = 0x1c
	// Bit mask of B2B3 field.
	ADC_ETC_TRIG2_CHAIN_3_2_B2B3_Msk = 0x10000000
	// Bit B2B3.
	ADC_ETC_TRIG2_CHAIN_3_2_B2B3 = 0x10000000
	// Position of IE3 field.
	ADC_ETC_TRIG2_CHAIN_3_2_IE3_Pos = 0x1d
	// Bit mask of IE3 field.
	ADC_ETC_TRIG2_CHAIN_3_2_IE3_Msk = 0x60000000
	// Position of IE3_EN field.
	ADC_ETC_TRIG2_CHAIN_3_2_IE3_EN_Pos = 0x1f
	// Bit mask of IE3_EN field.
	ADC_ETC_TRIG2_CHAIN_3_2_IE3_EN_Msk = 0x80000000
	// Bit IE3_EN.
	ADC_ETC_TRIG2_CHAIN_3_2_IE3_EN = 0x80000000

	// TRIG2_CHAIN_5_4: ETC_TRIG Chain 4/5 Register
	// Position of CSEL4 field.
	ADC_ETC_TRIG2_CHAIN_5_4_CSEL4_Pos = 0x0
	// Bit mask of CSEL4 field.
	ADC_ETC_TRIG2_CHAIN_5_4_CSEL4_Msk = 0xf
	// Position of HWTS4 field.
	ADC_ETC_TRIG2_CHAIN_5_4_HWTS4_Pos = 0x4
	// Bit mask of HWTS4 field.
	ADC_ETC_TRIG2_CHAIN_5_4_HWTS4_Msk = 0xff0
	// Position of B2B4 field.
	ADC_ETC_TRIG2_CHAIN_5_4_B2B4_Pos = 0xc
	// Bit mask of B2B4 field.
	ADC_ETC_TRIG2_CHAIN_5_4_B2B4_Msk = 0x1000
	// Bit B2B4.
	ADC_ETC_TRIG2_CHAIN_5_4_B2B4 = 0x1000
	// Position of IE4 field.
	ADC_ETC_TRIG2_CHAIN_5_4_IE4_Pos = 0xd
	// Bit mask of IE4 field.
	ADC_ETC_TRIG2_CHAIN_5_4_IE4_Msk = 0x6000
	// Position of IE4_EN field.
	ADC_ETC_TRIG2_CHAIN_5_4_IE4_EN_Pos = 0xf
	// Bit mask of IE4_EN field.
	ADC_ETC_TRIG2_CHAIN_5_4_IE4_EN_Msk = 0x8000
	// Bit IE4_EN.
	ADC_ETC_TRIG2_CHAIN_5_4_IE4_EN = 0x8000
	// Position of CSEL5 field.
	ADC_ETC_TRIG2_CHAIN_5_4_CSEL5_Pos = 0x10
	// Bit mask of CSEL5 field.
	ADC_ETC_TRIG2_CHAIN_5_4_CSEL5_Msk = 0xf0000
	// Position of HWTS5 field.
	ADC_ETC_TRIG2_CHAIN_5_4_HWTS5_Pos = 0x14
	// Bit mask of HWTS5 field.
	ADC_ETC_TRIG2_CHAIN_5_4_HWTS5_Msk = 0xff00000
	// Position of B2B5 field.
	ADC_ETC_TRIG2_CHAIN_5_4_B2B5_Pos = 0x1c
	// Bit mask of B2B5 field.
	ADC_ETC_TRIG2_CHAIN_5_4_B2B5_Msk = 0x10000000
	// Bit B2B5.
	ADC_ETC_TRIG2_CHAIN_5_4_B2B5 = 0x10000000
	// Position of IE5 field.
	ADC_ETC_TRIG2_CHAIN_5_4_IE5_Pos = 0x1d
	// Bit mask of IE5 field.
	ADC_ETC_TRIG2_CHAIN_5_4_IE5_Msk = 0x60000000
	// Position of IE5_EN field.
	ADC_ETC_TRIG2_CHAIN_5_4_IE5_EN_Pos = 0x1f
	// Bit mask of IE5_EN field.
	ADC_ETC_TRIG2_CHAIN_5_4_IE5_EN_Msk = 0x80000000
	// Bit IE5_EN.
	ADC_ETC_TRIG2_CHAIN_5_4_IE5_EN = 0x80000000

	// TRIG2_CHAIN_7_6: ETC_TRIG Chain 6/7 Register
	// Position of CSEL6 field.
	ADC_ETC_TRIG2_CHAIN_7_6_CSEL6_Pos = 0x0
	// Bit mask of CSEL6 field.
	ADC_ETC_TRIG2_CHAIN_7_6_CSEL6_Msk = 0xf
	// Position of HWTS6 field.
	ADC_ETC_TRIG2_CHAIN_7_6_HWTS6_Pos = 0x4
	// Bit mask of HWTS6 field.
	ADC_ETC_TRIG2_CHAIN_7_6_HWTS6_Msk = 0xff0
	// Position of B2B6 field.
	ADC_ETC_TRIG2_CHAIN_7_6_B2B6_Pos = 0xc
	// Bit mask of B2B6 field.
	ADC_ETC_TRIG2_CHAIN_7_6_B2B6_Msk = 0x1000
	// Bit B2B6.
	ADC_ETC_TRIG2_CHAIN_7_6_B2B6 = 0x1000
	// Position of IE6 field.
	ADC_ETC_TRIG2_CHAIN_7_6_IE6_Pos = 0xd
	// Bit mask of IE6 field.
	ADC_ETC_TRIG2_CHAIN_7_6_IE6_Msk = 0x6000
	// Position of IE6_EN field.
	ADC_ETC_TRIG2_CHAIN_7_6_IE6_EN_Pos = 0xf
	// Bit mask of IE6_EN field.
	ADC_ETC_TRIG2_CHAIN_7_6_IE6_EN_Msk = 0x8000
	// Bit IE6_EN.
	ADC_ETC_TRIG2_CHAIN_7_6_IE6_EN = 0x8000
	// Position of CSEL7 field.
	ADC_ETC_TRIG2_CHAIN_7_6_CSEL7_Pos = 0x10
	// Bit mask of CSEL7 field.
	ADC_ETC_TRIG2_CHAIN_7_6_CSEL7_Msk = 0xf0000
	// Position of HWTS7 field.
	ADC_ETC_TRIG2_CHAIN_7_6_HWTS7_Pos = 0x14
	// Bit mask of HWTS7 field.
	ADC_ETC_TRIG2_CHAIN_7_6_HWTS7_Msk = 0xff00000
	// Position of B2B7 field.
	ADC_ETC_TRIG2_CHAIN_7_6_B2B7_Pos = 0x1c
	// Bit mask of B2B7 field.
	ADC_ETC_TRIG2_CHAIN_7_6_B2B7_Msk = 0x10000000
	// Bit B2B7.
	ADC_ETC_TRIG2_CHAIN_7_6_B2B7 = 0x10000000
	// Position of IE7 field.
	ADC_ETC_TRIG2_CHAIN_7_6_IE7_Pos = 0x1d
	// Bit mask of IE7 field.
	ADC_ETC_TRIG2_CHAIN_7_6_IE7_Msk = 0x60000000
	// Position of IE7_EN field.
	ADC_ETC_TRIG2_CHAIN_7_6_IE7_EN_Pos = 0x1f
	// Bit mask of IE7_EN field.
	ADC_ETC_TRIG2_CHAIN_7_6_IE7_EN_Msk = 0x80000000
	// Bit IE7_EN.
	ADC_ETC_TRIG2_CHAIN_7_6_IE7_EN = 0x80000000

	// TRIG2_RESULT_1_0: ETC_TRIG Result Data 1/0 Register
	// Position of DATA0 field.
	ADC_ETC_TRIG2_RESULT_1_0_DATA0_Pos = 0x0
	// Bit mask of DATA0 field.
	ADC_ETC_TRIG2_RESULT_1_0_DATA0_Msk = 0xfff
	// Position of DATA1 field.
	ADC_ETC_TRIG2_RESULT_1_0_DATA1_Pos = 0x10
	// Bit mask of DATA1 field.
	ADC_ETC_TRIG2_RESULT_1_0_DATA1_Msk = 0xfff0000

	// TRIG2_RESULT_3_2: ETC_TRIG Result Data 3/2 Register
	// Position of DATA2 field.
	ADC_ETC_TRIG2_RESULT_3_2_DATA2_Pos = 0x0
	// Bit mask of DATA2 field.
	ADC_ETC_TRIG2_RESULT_3_2_DATA2_Msk = 0xfff
	// Position of DATA3 field.
	ADC_ETC_TRIG2_RESULT_3_2_DATA3_Pos = 0x10
	// Bit mask of DATA3 field.
	ADC_ETC_TRIG2_RESULT_3_2_DATA3_Msk = 0xfff0000

	// TRIG2_RESULT_5_4: ETC_TRIG Result Data 5/4 Register
	// Position of DATA4 field.
	ADC_ETC_TRIG2_RESULT_5_4_DATA4_Pos = 0x0
	// Bit mask of DATA4 field.
	ADC_ETC_TRIG2_RESULT_5_4_DATA4_Msk = 0xfff
	// Position of DATA5 field.
	ADC_ETC_TRIG2_RESULT_5_4_DATA5_Pos = 0x10
	// Bit mask of DATA5 field.
	ADC_ETC_TRIG2_RESULT_5_4_DATA5_Msk = 0xfff0000

	// TRIG2_RESULT_7_6: ETC_TRIG Result Data 7/6 Register
	// Position of DATA6 field.
	ADC_ETC_TRIG2_RESULT_7_6_DATA6_Pos = 0x0
	// Bit mask of DATA6 field.
	ADC_ETC_TRIG2_RESULT_7_6_DATA6_Msk = 0xfff
	// Position of DATA7 field.
	ADC_ETC_TRIG2_RESULT_7_6_DATA7_Pos = 0x10
	// Bit mask of DATA7 field.
	ADC_ETC_TRIG2_RESULT_7_6_DATA7_Msk = 0xfff0000

	// TRIG3_CTRL: ETC_TRIG Control Register
	// Position of SW_TRIG field.
	ADC_ETC_TRIG3_CTRL_SW_TRIG_Pos = 0x0
	// Bit mask of SW_TRIG field.
	ADC_ETC_TRIG3_CTRL_SW_TRIG_Msk = 0x1
	// Bit SW_TRIG.
	ADC_ETC_TRIG3_CTRL_SW_TRIG = 0x1
	// Position of TRIG_MODE field.
	ADC_ETC_TRIG3_CTRL_TRIG_MODE_Pos = 0x4
	// Bit mask of TRIG_MODE field.
	ADC_ETC_TRIG3_CTRL_TRIG_MODE_Msk = 0x10
	// Bit TRIG_MODE.
	ADC_ETC_TRIG3_CTRL_TRIG_MODE = 0x10
	// Position of TRIG_CHAIN field.
	ADC_ETC_TRIG3_CTRL_TRIG_CHAIN_Pos = 0x8
	// Bit mask of TRIG_CHAIN field.
	ADC_ETC_TRIG3_CTRL_TRIG_CHAIN_Msk = 0x700
	// Position of TRIG_PRIORITY field.
	ADC_ETC_TRIG3_CTRL_TRIG_PRIORITY_Pos = 0xc
	// Bit mask of TRIG_PRIORITY field.
	ADC_ETC_TRIG3_CTRL_TRIG_PRIORITY_Msk = 0x7000
	// Position of SYNC_MODE field.
	ADC_ETC_TRIG3_CTRL_SYNC_MODE_Pos = 0x10
	// Bit mask of SYNC_MODE field.
	ADC_ETC_TRIG3_CTRL_SYNC_MODE_Msk = 0x10000
	// Bit SYNC_MODE.
	ADC_ETC_TRIG3_CTRL_SYNC_MODE = 0x10000
	// Position of CHAINx_DONE field.
	ADC_ETC_TRIG3_CTRL_CHAINx_DONE_Pos = 0x18
	// Bit mask of CHAINx_DONE field.
	ADC_ETC_TRIG3_CTRL_CHAINx_DONE_Msk = 0xff000000

	// TRIG3_COUNTER: ETC_TRIG Counter Register
	// Position of INIT_DELAY field.
	ADC_ETC_TRIG3_COUNTER_INIT_DELAY_Pos = 0x0
	// Bit mask of INIT_DELAY field.
	ADC_ETC_TRIG3_COUNTER_INIT_DELAY_Msk = 0xffff
	// Position of SAMPLE_INTERVAL field.
	ADC_ETC_TRIG3_COUNTER_SAMPLE_INTERVAL_Pos = 0x10
	// Bit mask of SAMPLE_INTERVAL field.
	ADC_ETC_TRIG3_COUNTER_SAMPLE_INTERVAL_Msk = 0xffff0000

	// TRIG3_CHAIN_1_0: ETC_TRIG Chain 0/1 Register
	// Position of CSEL0 field.
	ADC_ETC_TRIG3_CHAIN_1_0_CSEL0_Pos = 0x0
	// Bit mask of CSEL0 field.
	ADC_ETC_TRIG3_CHAIN_1_0_CSEL0_Msk = 0xf
	// Position of HWTS0 field.
	ADC_ETC_TRIG3_CHAIN_1_0_HWTS0_Pos = 0x4
	// Bit mask of HWTS0 field.
	ADC_ETC_TRIG3_CHAIN_1_0_HWTS0_Msk = 0xff0
	// Position of B2B0 field.
	ADC_ETC_TRIG3_CHAIN_1_0_B2B0_Pos = 0xc
	// Bit mask of B2B0 field.
	ADC_ETC_TRIG3_CHAIN_1_0_B2B0_Msk = 0x1000
	// Bit B2B0.
	ADC_ETC_TRIG3_CHAIN_1_0_B2B0 = 0x1000
	// Position of IE0 field.
	ADC_ETC_TRIG3_CHAIN_1_0_IE0_Pos = 0xd
	// Bit mask of IE0 field.
	ADC_ETC_TRIG3_CHAIN_1_0_IE0_Msk = 0x6000
	// Position of IE0_EN field.
	ADC_ETC_TRIG3_CHAIN_1_0_IE0_EN_Pos = 0xf
	// Bit mask of IE0_EN field.
	ADC_ETC_TRIG3_CHAIN_1_0_IE0_EN_Msk = 0x8000
	// Bit IE0_EN.
	ADC_ETC_TRIG3_CHAIN_1_0_IE0_EN = 0x8000
	// Position of CSEL1 field.
	ADC_ETC_TRIG3_CHAIN_1_0_CSEL1_Pos = 0x10
	// Bit mask of CSEL1 field.
	ADC_ETC_TRIG3_CHAIN_1_0_CSEL1_Msk = 0xf0000
	// Position of HWTS1 field.
	ADC_ETC_TRIG3_CHAIN_1_0_HWTS1_Pos = 0x14
	// Bit mask of HWTS1 field.
	ADC_ETC_TRIG3_CHAIN_1_0_HWTS1_Msk = 0xff00000
	// Position of B2B1 field.
	ADC_ETC_TRIG3_CHAIN_1_0_B2B1_Pos = 0x1c
	// Bit mask of B2B1 field.
	ADC_ETC_TRIG3_CHAIN_1_0_B2B1_Msk = 0x10000000
	// Bit B2B1.
	ADC_ETC_TRIG3_CHAIN_1_0_B2B1 = 0x10000000
	// Position of IE1 field.
	ADC_ETC_TRIG3_CHAIN_1_0_IE1_Pos = 0x1d
	// Bit mask of IE1 field.
	ADC_ETC_TRIG3_CHAIN_1_0_IE1_Msk = 0x60000000
	// Position of IE1_EN field.
	ADC_ETC_TRIG3_CHAIN_1_0_IE1_EN_Pos = 0x1f
	// Bit mask of IE1_EN field.
	ADC_ETC_TRIG3_CHAIN_1_0_IE1_EN_Msk = 0x80000000
	// Bit IE1_EN.
	ADC_ETC_TRIG3_CHAIN_1_0_IE1_EN = 0x80000000

	// TRIG3_CHAIN_3_2: ETC_TRIG Chain 2/3 Register
	// Position of CSEL2 field.
	ADC_ETC_TRIG3_CHAIN_3_2_CSEL2_Pos = 0x0
	// Bit mask of CSEL2 field.
	ADC_ETC_TRIG3_CHAIN_3_2_CSEL2_Msk = 0xf
	// Position of HWTS2 field.
	ADC_ETC_TRIG3_CHAIN_3_2_HWTS2_Pos = 0x4
	// Bit mask of HWTS2 field.
	ADC_ETC_TRIG3_CHAIN_3_2_HWTS2_Msk = 0xff0
	// Position of B2B2 field.
	ADC_ETC_TRIG3_CHAIN_3_2_B2B2_Pos = 0xc
	// Bit mask of B2B2 field.
	ADC_ETC_TRIG3_CHAIN_3_2_B2B2_Msk = 0x1000
	// Bit B2B2.
	ADC_ETC_TRIG3_CHAIN_3_2_B2B2 = 0x1000
	// Position of IE2 field.
	ADC_ETC_TRIG3_CHAIN_3_2_IE2_Pos = 0xd
	// Bit mask of IE2 field.
	ADC_ETC_TRIG3_CHAIN_3_2_IE2_Msk = 0x6000
	// Position of IE2_EN field.
	ADC_ETC_TRIG3_CHAIN_3_2_IE2_EN_Pos = 0xf
	// Bit mask of IE2_EN field.
	ADC_ETC_TRIG3_CHAIN_3_2_IE2_EN_Msk = 0x8000
	// Bit IE2_EN.
	ADC_ETC_TRIG3_CHAIN_3_2_IE2_EN = 0x8000
	// Position of CSEL3 field.
	ADC_ETC_TRIG3_CHAIN_3_2_CSEL3_Pos = 0x10
	// Bit mask of CSEL3 field.
	ADC_ETC_TRIG3_CHAIN_3_2_CSEL3_Msk = 0xf0000
	// Position of HWTS3 field.
	ADC_ETC_TRIG3_CHAIN_3_2_HWTS3_Pos = 0x14
	// Bit mask of HWTS3 field.
	ADC_ETC_TRIG3_CHAIN_3_2_HWTS3_Msk = 0xff00000
	// Position of B2B3 field.
	ADC_ETC_TRIG3_CHAIN_3_2_B2B3_Pos = 0x1c
	// Bit mask of B2B3 field.
	ADC_ETC_TRIG3_CHAIN_3_2_B2B3_Msk = 0x10000000
	// Bit B2B3.
	ADC_ETC_TRIG3_CHAIN_3_2_B2B3 = 0x10000000
	// Position of IE3 field.
	ADC_ETC_TRIG3_CHAIN_3_2_IE3_Pos = 0x1d
	// Bit mask of IE3 field.
	ADC_ETC_TRIG3_CHAIN_3_2_IE3_Msk = 0x60000000
	// Position of IE3_EN field.
	ADC_ETC_TRIG3_CHAIN_3_2_IE3_EN_Pos = 0x1f
	// Bit mask of IE3_EN field.
	ADC_ETC_TRIG3_CHAIN_3_2_IE3_EN_Msk = 0x80000000
	// Bit IE3_EN.
	ADC_ETC_TRIG3_CHAIN_3_2_IE3_EN = 0x80000000

	// TRIG3_CHAIN_5_4: ETC_TRIG Chain 4/5 Register
	// Position of CSEL4 field.
	ADC_ETC_TRIG3_CHAIN_5_4_CSEL4_Pos = 0x0
	// Bit mask of CSEL4 field.
	ADC_ETC_TRIG3_CHAIN_5_4_CSEL4_Msk = 0xf
	// Position of HWTS4 field.
	ADC_ETC_TRIG3_CHAIN_5_4_HWTS4_Pos = 0x4
	// Bit mask of HWTS4 field.
	ADC_ETC_TRIG3_CHAIN_5_4_HWTS4_Msk = 0xff0
	// Position of B2B4 field.
	ADC_ETC_TRIG3_CHAIN_5_4_B2B4_Pos = 0xc
	// Bit mask of B2B4 field.
	ADC_ETC_TRIG3_CHAIN_5_4_B2B4_Msk = 0x1000
	// Bit B2B4.
	ADC_ETC_TRIG3_CHAIN_5_4_B2B4 = 0x1000
	// Position of IE4 field.
	ADC_ETC_TRIG3_CHAIN_5_4_IE4_Pos = 0xd
	// Bit mask of IE4 field.
	ADC_ETC_TRIG3_CHAIN_5_4_IE4_Msk = 0x6000
	// Position of IE4_EN field.
	ADC_ETC_TRIG3_CHAIN_5_4_IE4_EN_Pos = 0xf
	// Bit mask of IE4_EN field.
	ADC_ETC_TRIG3_CHAIN_5_4_IE4_EN_Msk = 0x8000
	// Bit IE4_EN.
	ADC_ETC_TRIG3_CHAIN_5_4_IE4_EN = 0x8000
	// Position of CSEL5 field.
	ADC_ETC_TRIG3_CHAIN_5_4_CSEL5_Pos = 0x10
	// Bit mask of CSEL5 field.
	ADC_ETC_TRIG3_CHAIN_5_4_CSEL5_Msk = 0xf0000
	// Position of HWTS5 field.
	ADC_ETC_TRIG3_CHAIN_5_4_HWTS5_Pos = 0x14
	// Bit mask of HWTS5 field.
	ADC_ETC_TRIG3_CHAIN_5_4_HWTS5_Msk = 0xff00000
	// Position of B2B5 field.
	ADC_ETC_TRIG3_CHAIN_5_4_B2B5_Pos = 0x1c
	// Bit mask of B2B5 field.
	ADC_ETC_TRIG3_CHAIN_5_4_B2B5_Msk = 0x10000000
	// Bit B2B5.
	ADC_ETC_TRIG3_CHAIN_5_4_B2B5 = 0x10000000
	// Position of IE5 field.
	ADC_ETC_TRIG3_CHAIN_5_4_IE5_Pos = 0x1d
	// Bit mask of IE5 field.
	ADC_ETC_TRIG3_CHAIN_5_4_IE5_Msk = 0x60000000
	// Position of IE5_EN field.
	ADC_ETC_TRIG3_CHAIN_5_4_IE5_EN_Pos = 0x1f
	// Bit mask of IE5_EN field.
	ADC_ETC_TRIG3_CHAIN_5_4_IE5_EN_Msk = 0x80000000
	// Bit IE5_EN.
	ADC_ETC_TRIG3_CHAIN_5_4_IE5_EN = 0x80000000

	// TRIG3_CHAIN_7_6: ETC_TRIG Chain 6/7 Register
	// Position of CSEL6 field.
	ADC_ETC_TRIG3_CHAIN_7_6_CSEL6_Pos = 0x0
	// Bit mask of CSEL6 field.
	ADC_ETC_TRIG3_CHAIN_7_6_CSEL6_Msk = 0xf
	// Position of HWTS6 field.
	ADC_ETC_TRIG3_CHAIN_7_6_HWTS6_Pos = 0x4
	// Bit mask of HWTS6 field.
	ADC_ETC_TRIG3_CHAIN_7_6_HWTS6_Msk = 0xff0
	// Position of B2B6 field.
	ADC_ETC_TRIG3_CHAIN_7_6_B2B6_Pos = 0xc
	// Bit mask of B2B6 field.
	ADC_ETC_TRIG3_CHAIN_7_6_B2B6_Msk = 0x1000
	// Bit B2B6.
	ADC_ETC_TRIG3_CHAIN_7_6_B2B6 = 0x1000
	// Position of IE6 field.
	ADC_ETC_TRIG3_CHAIN_7_6_IE6_Pos = 0xd
	// Bit mask of IE6 field.
	ADC_ETC_TRIG3_CHAIN_7_6_IE6_Msk = 0x6000
	// Position of IE6_EN field.
	ADC_ETC_TRIG3_CHAIN_7_6_IE6_EN_Pos = 0xf
	// Bit mask of IE6_EN field.
	ADC_ETC_TRIG3_CHAIN_7_6_IE6_EN_Msk = 0x8000
	// Bit IE6_EN.
	ADC_ETC_TRIG3_CHAIN_7_6_IE6_EN = 0x8000
	// Position of CSEL7 field.
	ADC_ETC_TRIG3_CHAIN_7_6_CSEL7_Pos = 0x10
	// Bit mask of CSEL7 field.
	ADC_ETC_TRIG3_CHAIN_7_6_CSEL7_Msk = 0xf0000
	// Position of HWTS7 field.
	ADC_ETC_TRIG3_CHAIN_7_6_HWTS7_Pos = 0x14
	// Bit mask of HWTS7 field.
	ADC_ETC_TRIG3_CHAIN_7_6_HWTS7_Msk = 0xff00000
	// Position of B2B7 field.
	ADC_ETC_TRIG3_CHAIN_7_6_B2B7_Pos = 0x1c
	// Bit mask of B2B7 field.
	ADC_ETC_TRIG3_CHAIN_7_6_B2B7_Msk = 0x10000000
	// Bit B2B7.
	ADC_ETC_TRIG3_CHAIN_7_6_B2B7 = 0x10000000
	// Position of IE7 field.
	ADC_ETC_TRIG3_CHAIN_7_6_IE7_Pos = 0x1d
	// Bit mask of IE7 field.
	ADC_ETC_TRIG3_CHAIN_7_6_IE7_Msk = 0x60000000
	// Position of IE7_EN field.
	ADC_ETC_TRIG3_CHAIN_7_6_IE7_EN_Pos = 0x1f
	// Bit mask of IE7_EN field.
	ADC_ETC_TRIG3_CHAIN_7_6_IE7_EN_Msk = 0x80000000
	// Bit IE7_EN.
	ADC_ETC_TRIG3_CHAIN_7_6_IE7_EN = 0x80000000

	// TRIG3_RESULT_1_0: ETC_TRIG Result Data 1/0 Register
	// Position of DATA0 field.
	ADC_ETC_TRIG3_RESULT_1_0_DATA0_Pos = 0x0
	// Bit mask of DATA0 field.
	ADC_ETC_TRIG3_RESULT_1_0_DATA0_Msk = 0xfff
	// Position of DATA1 field.
	ADC_ETC_TRIG3_RESULT_1_0_DATA1_Pos = 0x10
	// Bit mask of DATA1 field.
	ADC_ETC_TRIG3_RESULT_1_0_DATA1_Msk = 0xfff0000

	// TRIG3_RESULT_3_2: ETC_TRIG Result Data 3/2 Register
	// Position of DATA2 field.
	ADC_ETC_TRIG3_RESULT_3_2_DATA2_Pos = 0x0
	// Bit mask of DATA2 field.
	ADC_ETC_TRIG3_RESULT_3_2_DATA2_Msk = 0xfff
	// Position of DATA3 field.
	ADC_ETC_TRIG3_RESULT_3_2_DATA3_Pos = 0x10
	// Bit mask of DATA3 field.
	ADC_ETC_TRIG3_RESULT_3_2_DATA3_Msk = 0xfff0000

	// TRIG3_RESULT_5_4: ETC_TRIG Result Data 5/4 Register
	// Position of DATA4 field.
	ADC_ETC_TRIG3_RESULT_5_4_DATA4_Pos = 0x0
	// Bit mask of DATA4 field.
	ADC_ETC_TRIG3_RESULT_5_4_DATA4_Msk = 0xfff
	// Position of DATA5 field.
	ADC_ETC_TRIG3_RESULT_5_4_DATA5_Pos = 0x10
	// Bit mask of DATA5 field.
	ADC_ETC_TRIG3_RESULT_5_4_DATA5_Msk = 0xfff0000

	// TRIG3_RESULT_7_6: ETC_TRIG Result Data 7/6 Register
	// Position of DATA6 field.
	ADC_ETC_TRIG3_RESULT_7_6_DATA6_Pos = 0x0
	// Bit mask of DATA6 field.
	ADC_ETC_TRIG3_RESULT_7_6_DATA6_Msk = 0xfff
	// Position of DATA7 field.
	ADC_ETC_TRIG3_RESULT_7_6_DATA7_Pos = 0x10
	// Bit mask of DATA7 field.
	ADC_ETC_TRIG3_RESULT_7_6_DATA7_Msk = 0xfff0000
)

// Constants for AOI: AND/OR/INVERT module
const (
	// BFCRT010: Boolean Function Term 0 and 1 Configuration Register for EVENTn
	// Position of PT1_DC field.
	AOI_BFCRT01_PT1_DC_Pos = 0x0
	// Bit mask of PT1_DC field.
	AOI_BFCRT01_PT1_DC_Msk = 0x3
	// Force the D input in this product term to a logical zero
	AOI_BFCRT01_PT1_DC_PT1_DC_0 = 0x0
	// Pass the D input in this product term
	AOI_BFCRT01_PT1_DC_PT1_DC_1 = 0x1
	// Complement the D input in this product term
	AOI_BFCRT01_PT1_DC_PT1_DC_2 = 0x2
	// Force the D input in this product term to a logical one
	AOI_BFCRT01_PT1_DC_PT1_DC_3 = 0x3
	// Position of PT1_CC field.
	AOI_BFCRT01_PT1_CC_Pos = 0x2
	// Bit mask of PT1_CC field.
	AOI_BFCRT01_PT1_CC_Msk = 0xc
	// Force the C input in this product term to a logical zero
	AOI_BFCRT01_PT1_CC_PT1_CC_0 = 0x0
	// Pass the C input in this product term
	AOI_BFCRT01_PT1_CC_PT1_CC_1 = 0x1
	// Complement the C input in this product term
	AOI_BFCRT01_PT1_CC_PT1_CC_2 = 0x2
	// Force the C input in this product term to a logical one
	AOI_BFCRT01_PT1_CC_PT1_CC_3 = 0x3
	// Position of PT1_BC field.
	AOI_BFCRT01_PT1_BC_Pos = 0x4
	// Bit mask of PT1_BC field.
	AOI_BFCRT01_PT1_BC_Msk = 0x30
	// Force the B input in this product term to a logical zero
	AOI_BFCRT01_PT1_BC_PT1_BC_0 = 0x0
	// Pass the B input in this product term
	AOI_BFCRT01_PT1_BC_PT1_BC_1 = 0x1
	// Complement the B input in this product term
	AOI_BFCRT01_PT1_BC_PT1_BC_2 = 0x2
	// Force the B input in this product term to a logical one
	AOI_BFCRT01_PT1_BC_PT1_BC_3 = 0x3
	// Position of PT1_AC field.
	AOI_BFCRT01_PT1_AC_Pos = 0x6
	// Bit mask of PT1_AC field.
	AOI_BFCRT01_PT1_AC_Msk = 0xc0
	// Force the A input in this product term to a logical zero
	AOI_BFCRT01_PT1_AC_PT1_AC_0 = 0x0
	// Pass the A input in this product term
	AOI_BFCRT01_PT1_AC_PT1_AC_1 = 0x1
	// Complement the A input in this product term
	AOI_BFCRT01_PT1_AC_PT1_AC_2 = 0x2
	// Force the A input in this product term to a logical one
	AOI_BFCRT01_PT1_AC_PT1_AC_3 = 0x3
	// Position of PT0_DC field.
	AOI_BFCRT01_PT0_DC_Pos = 0x8
	// Bit mask of PT0_DC field.
	AOI_BFCRT01_PT0_DC_Msk = 0x300
	// Force the D input in this product term to a logical zero
	AOI_BFCRT01_PT0_DC_PT0_DC_0 = 0x0
	// Pass the D input in this product term
	AOI_BFCRT01_PT0_DC_PT0_DC_1 = 0x1
	// Complement the D input in this product term
	AOI_BFCRT01_PT0_DC_PT0_DC_2 = 0x2
	// Force the D input in this product term to a logical one
	AOI_BFCRT01_PT0_DC_PT0_DC_3 = 0x3
	// Position of PT0_CC field.
	AOI_BFCRT01_PT0_CC_Pos = 0xa
	// Bit mask of PT0_CC field.
	AOI_BFCRT01_PT0_CC_Msk = 0xc00
	// Force the C input in this product term to a logical zero
	AOI_BFCRT01_PT0_CC_PT0_CC_0 = 0x0
	// Pass the C input in this product term
	AOI_BFCRT01_PT0_CC_PT0_CC_1 = 0x1
	// Complement the C input in this product term
	AOI_BFCRT01_PT0_CC_PT0_CC_2 = 0x2
	// Force the C input in this product term to a logical one
	AOI_BFCRT01_PT0_CC_PT0_CC_3 = 0x3
	// Position of PT0_BC field.
	AOI_BFCRT01_PT0_BC_Pos = 0xc
	// Bit mask of PT0_BC field.
	AOI_BFCRT01_PT0_BC_Msk = 0x3000
	// Force the B input in this product term to a logical zero
	AOI_BFCRT01_PT0_BC_PT0_BC_0 = 0x0
	// Pass the B input in this product term
	AOI_BFCRT01_PT0_BC_PT0_BC_1 = 0x1
	// Complement the B input in this product term
	AOI_BFCRT01_PT0_BC_PT0_BC_2 = 0x2
	// Force the B input in this product term to a logical one
	AOI_BFCRT01_PT0_BC_PT0_BC_3 = 0x3
	// Position of PT0_AC field.
	AOI_BFCRT01_PT0_AC_Pos = 0xe
	// Bit mask of PT0_AC field.
	AOI_BFCRT01_PT0_AC_Msk = 0xc000
	// Force the A input in this product term to a logical zero
	AOI_BFCRT01_PT0_AC_PT0_AC_0 = 0x0
	// Pass the A input in this product term
	AOI_BFCRT01_PT0_AC_PT0_AC_1 = 0x1
	// Complement the A input in this product term
	AOI_BFCRT01_PT0_AC_PT0_AC_2 = 0x2
	// Force the A input in this product term to a logical one
	AOI_BFCRT01_PT0_AC_PT0_AC_3 = 0x3

	// BFCRT230: Boolean Function Term 2 and 3 Configuration Register for EVENTn
	// Position of PT3_DC field.
	AOI_BFCRT23_PT3_DC_Pos = 0x0
	// Bit mask of PT3_DC field.
	AOI_BFCRT23_PT3_DC_Msk = 0x3
	// Force the D input in this product term to a logical zero
	AOI_BFCRT23_PT3_DC_PT3_DC_0 = 0x0
	// Pass the D input in this product term
	AOI_BFCRT23_PT3_DC_PT3_DC_1 = 0x1
	// Complement the D input in this product term
	AOI_BFCRT23_PT3_DC_PT3_DC_2 = 0x2
	// Force the D input in this product term to a logical one
	AOI_BFCRT23_PT3_DC_PT3_DC_3 = 0x3
	// Position of PT3_CC field.
	AOI_BFCRT23_PT3_CC_Pos = 0x2
	// Bit mask of PT3_CC field.
	AOI_BFCRT23_PT3_CC_Msk = 0xc
	// Force the C input in this product term to a logical zero
	AOI_BFCRT23_PT3_CC_PT3_CC_0 = 0x0
	// Pass the C input in this product term
	AOI_BFCRT23_PT3_CC_PT3_CC_1 = 0x1
	// Complement the C input in this product term
	AOI_BFCRT23_PT3_CC_PT3_CC_2 = 0x2
	// Force the C input in this product term to a logical one
	AOI_BFCRT23_PT3_CC_PT3_CC_3 = 0x3
	// Position of PT3_BC field.
	AOI_BFCRT23_PT3_BC_Pos = 0x4
	// Bit mask of PT3_BC field.
	AOI_BFCRT23_PT3_BC_Msk = 0x30
	// Force the B input in this product term to a logical zero
	AOI_BFCRT23_PT3_BC_PT3_BC_0 = 0x0
	// Pass the B input in this product term
	AOI_BFCRT23_PT3_BC_PT3_BC_1 = 0x1
	// Complement the B input in this product term
	AOI_BFCRT23_PT3_BC_PT3_BC_2 = 0x2
	// Force the B input in this product term to a logical one
	AOI_BFCRT23_PT3_BC_PT3_BC_3 = 0x3
	// Position of PT3_AC field.
	AOI_BFCRT23_PT3_AC_Pos = 0x6
	// Bit mask of PT3_AC field.
	AOI_BFCRT23_PT3_AC_Msk = 0xc0
	// Force the A input in this product term to a logical zero
	AOI_BFCRT23_PT3_AC_PT3_AC_0 = 0x0
	// Pass the A input in this product term
	AOI_BFCRT23_PT3_AC_PT3_AC_1 = 0x1
	// Complement the A input in this product term
	AOI_BFCRT23_PT3_AC_PT3_AC_2 = 0x2
	// Force the A input in this product term to a logical one
	AOI_BFCRT23_PT3_AC_PT3_AC_3 = 0x3
	// Position of PT2_DC field.
	AOI_BFCRT23_PT2_DC_Pos = 0x8
	// Bit mask of PT2_DC field.
	AOI_BFCRT23_PT2_DC_Msk = 0x300
	// Force the D input in this product term to a logical zero
	AOI_BFCRT23_PT2_DC_PT2_DC_0 = 0x0
	// Pass the D input in this product term
	AOI_BFCRT23_PT2_DC_PT2_DC_1 = 0x1
	// Complement the D input in this product term
	AOI_BFCRT23_PT2_DC_PT2_DC_2 = 0x2
	// Force the D input in this product term to a logical one
	AOI_BFCRT23_PT2_DC_PT2_DC_3 = 0x3
	// Position of PT2_CC field.
	AOI_BFCRT23_PT2_CC_Pos = 0xa
	// Bit mask of PT2_CC field.
	AOI_BFCRT23_PT2_CC_Msk = 0xc00
	// Force the C input in this product term to a logical zero
	AOI_BFCRT23_PT2_CC_PT2_CC_0 = 0x0
	// Pass the C input in this product term
	AOI_BFCRT23_PT2_CC_PT2_CC_1 = 0x1
	// Complement the C input in this product term
	AOI_BFCRT23_PT2_CC_PT2_CC_2 = 0x2
	// Force the C input in this product term to a logical one
	AOI_BFCRT23_PT2_CC_PT2_CC_3 = 0x3
	// Position of PT2_BC field.
	AOI_BFCRT23_PT2_BC_Pos = 0xc
	// Bit mask of PT2_BC field.
	AOI_BFCRT23_PT2_BC_Msk = 0x3000
	// Force the B input in this product term to a logical zero
	AOI_BFCRT23_PT2_BC_PT2_BC_0 = 0x0
	// Pass the B input in this product term
	AOI_BFCRT23_PT2_BC_PT2_BC_1 = 0x1
	// Complement the B input in this product term
	AOI_BFCRT23_PT2_BC_PT2_BC_2 = 0x2
	// Force the B input in this product term to a logical one
	AOI_BFCRT23_PT2_BC_PT2_BC_3 = 0x3
	// Position of PT2_AC field.
	AOI_BFCRT23_PT2_AC_Pos = 0xe
	// Bit mask of PT2_AC field.
	AOI_BFCRT23_PT2_AC_Msk = 0xc000
	// Force the A input in this product term to a logical zero
	AOI_BFCRT23_PT2_AC_PT2_AC_0 = 0x0
	// Pass the A input in this product term
	AOI_BFCRT23_PT2_AC_PT2_AC_1 = 0x1
	// Complement the A input in this product term
	AOI_BFCRT23_PT2_AC_PT2_AC_2 = 0x2
	// Force the A input in this product term to a logical one
	AOI_BFCRT23_PT2_AC_PT2_AC_3 = 0x3
)

// Constants for XBARA: Crossbar Switch
const (
	// SEL0: Crossbar A Select Register 0
	// Position of SEL0 field.
	XBARA_SEL0_SEL0_Pos = 0x0
	// Bit mask of SEL0 field.
	XBARA_SEL0_SEL0_Msk = 0x7f
	// Position of SEL1 field.
	XBARA_SEL0_SEL1_Pos = 0x8
	// Bit mask of SEL1 field.
	XBARA_SEL0_SEL1_Msk = 0x7f00

	// SEL1: Crossbar A Select Register 1
	// Position of SEL2 field.
	XBARA_SEL1_SEL2_Pos = 0x0
	// Bit mask of SEL2 field.
	XBARA_SEL1_SEL2_Msk = 0x7f
	// Position of SEL3 field.
	XBARA_SEL1_SEL3_Pos = 0x8
	// Bit mask of SEL3 field.
	XBARA_SEL1_SEL3_Msk = 0x7f00

	// SEL2: Crossbar A Select Register 2
	// Position of SEL4 field.
	XBARA_SEL2_SEL4_Pos = 0x0
	// Bit mask of SEL4 field.
	XBARA_SEL2_SEL4_Msk = 0x7f
	// Position of SEL5 field.
	XBARA_SEL2_SEL5_Pos = 0x8
	// Bit mask of SEL5 field.
	XBARA_SEL2_SEL5_Msk = 0x7f00

	// SEL3: Crossbar A Select Register 3
	// Position of SEL6 field.
	XBARA_SEL3_SEL6_Pos = 0x0
	// Bit mask of SEL6 field.
	XBARA_SEL3_SEL6_Msk = 0x7f
	// Position of SEL7 field.
	XBARA_SEL3_SEL7_Pos = 0x8
	// Bit mask of SEL7 field.
	XBARA_SEL3_SEL7_Msk = 0x7f00

	// SEL4: Crossbar A Select Register 4
	// Position of SEL8 field.
	XBARA_SEL4_SEL8_Pos = 0x0
	// Bit mask of SEL8 field.
	XBARA_SEL4_SEL8_Msk = 0x7f
	// Position of SEL9 field.
	XBARA_SEL4_SEL9_Pos = 0x8
	// Bit mask of SEL9 field.
	XBARA_SEL4_SEL9_Msk = 0x7f00

	// SEL5: Crossbar A Select Register 5
	// Position of SEL10 field.
	XBARA_SEL5_SEL10_Pos = 0x0
	// Bit mask of SEL10 field.
	XBARA_SEL5_SEL10_Msk = 0x7f
	// Position of SEL11 field.
	XBARA_SEL5_SEL11_Pos = 0x8
	// Bit mask of SEL11 field.
	XBARA_SEL5_SEL11_Msk = 0x7f00

	// SEL6: Crossbar A Select Register 6
	// Position of SEL12 field.
	XBARA_SEL6_SEL12_Pos = 0x0
	// Bit mask of SEL12 field.
	XBARA_SEL6_SEL12_Msk = 0x7f
	// Position of SEL13 field.
	XBARA_SEL6_SEL13_Pos = 0x8
	// Bit mask of SEL13 field.
	XBARA_SEL6_SEL13_Msk = 0x7f00

	// SEL7: Crossbar A Select Register 7
	// Position of SEL14 field.
	XBARA_SEL7_SEL14_Pos = 0x0
	// Bit mask of SEL14 field.
	XBARA_SEL7_SEL14_Msk = 0x7f
	// Position of SEL15 field.
	XBARA_SEL7_SEL15_Pos = 0x8
	// Bit mask of SEL15 field.
	XBARA_SEL7_SEL15_Msk = 0x7f00

	// SEL8: Crossbar A Select Register 8
	// Position of SEL16 field.
	XBARA_SEL8_SEL16_Pos = 0x0
	// Bit mask of SEL16 field.
	XBARA_SEL8_SEL16_Msk = 0x7f
	// Position of SEL17 field.
	XBARA_SEL8_SEL17_Pos = 0x8
	// Bit mask of SEL17 field.
	XBARA_SEL8_SEL17_Msk = 0x7f00

	// SEL9: Crossbar A Select Register 9
	// Position of SEL18 field.
	XBARA_SEL9_SEL18_Pos = 0x0
	// Bit mask of SEL18 field.
	XBARA_SEL9_SEL18_Msk = 0x7f
	// Position of SEL19 field.
	XBARA_SEL9_SEL19_Pos = 0x8
	// Bit mask of SEL19 field.
	XBARA_SEL9_SEL19_Msk = 0x7f00

	// SEL10: Crossbar A Select Register 10
	// Position of SEL20 field.
	XBARA_SEL10_SEL20_Pos = 0x0
	// Bit mask of SEL20 field.
	XBARA_SEL10_SEL20_Msk = 0x7f
	// Position of SEL21 field.
	XBARA_SEL10_SEL21_Pos = 0x8
	// Bit mask of SEL21 field.
	XBARA_SEL10_SEL21_Msk = 0x7f00

	// SEL11: Crossbar A Select Register 11
	// Position of SEL22 field.
	XBARA_SEL11_SEL22_Pos = 0x0
	// Bit mask of SEL22 field.
	XBARA_SEL11_SEL22_Msk = 0x7f
	// Position of SEL23 field.
	XBARA_SEL11_SEL23_Pos = 0x8
	// Bit mask of SEL23 field.
	XBARA_SEL11_SEL23_Msk = 0x7f00

	// SEL12: Crossbar A Select Register 12
	// Position of SEL24 field.
	XBARA_SEL12_SEL24_Pos = 0x0
	// Bit mask of SEL24 field.
	XBARA_SEL12_SEL24_Msk = 0x7f
	// Position of SEL25 field.
	XBARA_SEL12_SEL25_Pos = 0x8
	// Bit mask of SEL25 field.
	XBARA_SEL12_SEL25_Msk = 0x7f00

	// SEL13: Crossbar A Select Register 13
	// Position of SEL26 field.
	XBARA_SEL13_SEL26_Pos = 0x0
	// Bit mask of SEL26 field.
	XBARA_SEL13_SEL26_Msk = 0x7f
	// Position of SEL27 field.
	XBARA_SEL13_SEL27_Pos = 0x8
	// Bit mask of SEL27 field.
	XBARA_SEL13_SEL27_Msk = 0x7f00

	// SEL14: Crossbar A Select Register 14
	// Position of SEL28 field.
	XBARA_SEL14_SEL28_Pos = 0x0
	// Bit mask of SEL28 field.
	XBARA_SEL14_SEL28_Msk = 0x7f
	// Position of SEL29 field.
	XBARA_SEL14_SEL29_Pos = 0x8
	// Bit mask of SEL29 field.
	XBARA_SEL14_SEL29_Msk = 0x7f00

	// SEL15: Crossbar A Select Register 15
	// Position of SEL30 field.
	XBARA_SEL15_SEL30_Pos = 0x0
	// Bit mask of SEL30 field.
	XBARA_SEL15_SEL30_Msk = 0x7f
	// Position of SEL31 field.
	XBARA_SEL15_SEL31_Pos = 0x8
	// Bit mask of SEL31 field.
	XBARA_SEL15_SEL31_Msk = 0x7f00

	// SEL16: Crossbar A Select Register 16
	// Position of SEL32 field.
	XBARA_SEL16_SEL32_Pos = 0x0
	// Bit mask of SEL32 field.
	XBARA_SEL16_SEL32_Msk = 0x7f
	// Position of SEL33 field.
	XBARA_SEL16_SEL33_Pos = 0x8
	// Bit mask of SEL33 field.
	XBARA_SEL16_SEL33_Msk = 0x7f00

	// SEL17: Crossbar A Select Register 17
	// Position of SEL34 field.
	XBARA_SEL17_SEL34_Pos = 0x0
	// Bit mask of SEL34 field.
	XBARA_SEL17_SEL34_Msk = 0x7f
	// Position of SEL35 field.
	XBARA_SEL17_SEL35_Pos = 0x8
	// Bit mask of SEL35 field.
	XBARA_SEL17_SEL35_Msk = 0x7f00

	// SEL18: Crossbar A Select Register 18
	// Position of SEL36 field.
	XBARA_SEL18_SEL36_Pos = 0x0
	// Bit mask of SEL36 field.
	XBARA_SEL18_SEL36_Msk = 0x7f
	// Position of SEL37 field.
	XBARA_SEL18_SEL37_Pos = 0x8
	// Bit mask of SEL37 field.
	XBARA_SEL18_SEL37_Msk = 0x7f00

	// SEL19: Crossbar A Select Register 19
	// Position of SEL38 field.
	XBARA_SEL19_SEL38_Pos = 0x0
	// Bit mask of SEL38 field.
	XBARA_SEL19_SEL38_Msk = 0x7f
	// Position of SEL39 field.
	XBARA_SEL19_SEL39_Pos = 0x8
	// Bit mask of SEL39 field.
	XBARA_SEL19_SEL39_Msk = 0x7f00

	// SEL20: Crossbar A Select Register 20
	// Position of SEL40 field.
	XBARA_SEL20_SEL40_Pos = 0x0
	// Bit mask of SEL40 field.
	XBARA_SEL20_SEL40_Msk = 0x7f
	// Position of SEL41 field.
	XBARA_SEL20_SEL41_Pos = 0x8
	// Bit mask of SEL41 field.
	XBARA_SEL20_SEL41_Msk = 0x7f00

	// SEL21: Crossbar A Select Register 21
	// Position of SEL42 field.
	XBARA_SEL21_SEL42_Pos = 0x0
	// Bit mask of SEL42 field.
	XBARA_SEL21_SEL42_Msk = 0x7f
	// Position of SEL43 field.
	XBARA_SEL21_SEL43_Pos = 0x8
	// Bit mask of SEL43 field.
	XBARA_SEL21_SEL43_Msk = 0x7f00

	// SEL22: Crossbar A Select Register 22
	// Position of SEL44 field.
	XBARA_SEL22_SEL44_Pos = 0x0
	// Bit mask of SEL44 field.
	XBARA_SEL22_SEL44_Msk = 0x7f
	// Position of SEL45 field.
	XBARA_SEL22_SEL45_Pos = 0x8
	// Bit mask of SEL45 field.
	XBARA_SEL22_SEL45_Msk = 0x7f00

	// SEL23: Crossbar A Select Register 23
	// Position of SEL46 field.
	XBARA_SEL23_SEL46_Pos = 0x0
	// Bit mask of SEL46 field.
	XBARA_SEL23_SEL46_Msk = 0x7f
	// Position of SEL47 field.
	XBARA_SEL23_SEL47_Pos = 0x8
	// Bit mask of SEL47 field.
	XBARA_SEL23_SEL47_Msk = 0x7f00

	// SEL24: Crossbar A Select Register 24
	// Position of SEL48 field.
	XBARA_SEL24_SEL48_Pos = 0x0
	// Bit mask of SEL48 field.
	XBARA_SEL24_SEL48_Msk = 0x7f
	// Position of SEL49 field.
	XBARA_SEL24_SEL49_Pos = 0x8
	// Bit mask of SEL49 field.
	XBARA_SEL24_SEL49_Msk = 0x7f00

	// SEL25: Crossbar A Select Register 25
	// Position of SEL50 field.
	XBARA_SEL25_SEL50_Pos = 0x0
	// Bit mask of SEL50 field.
	XBARA_SEL25_SEL50_Msk = 0x7f
	// Position of SEL51 field.
	XBARA_SEL25_SEL51_Pos = 0x8
	// Bit mask of SEL51 field.
	XBARA_SEL25_SEL51_Msk = 0x7f00

	// SEL26: Crossbar A Select Register 26
	// Position of SEL52 field.
	XBARA_SEL26_SEL52_Pos = 0x0
	// Bit mask of SEL52 field.
	XBARA_SEL26_SEL52_Msk = 0x7f
	// Position of SEL53 field.
	XBARA_SEL26_SEL53_Pos = 0x8
	// Bit mask of SEL53 field.
	XBARA_SEL26_SEL53_Msk = 0x7f00

	// SEL27: Crossbar A Select Register 27
	// Position of SEL54 field.
	XBARA_SEL27_SEL54_Pos = 0x0
	// Bit mask of SEL54 field.
	XBARA_SEL27_SEL54_Msk = 0x7f
	// Position of SEL55 field.
	XBARA_SEL27_SEL55_Pos = 0x8
	// Bit mask of SEL55 field.
	XBARA_SEL27_SEL55_Msk = 0x7f00

	// SEL28: Crossbar A Select Register 28
	// Position of SEL56 field.
	XBARA_SEL28_SEL56_Pos = 0x0
	// Bit mask of SEL56 field.
	XBARA_SEL28_SEL56_Msk = 0x7f
	// Position of SEL57 field.
	XBARA_SEL28_SEL57_Pos = 0x8
	// Bit mask of SEL57 field.
	XBARA_SEL28_SEL57_Msk = 0x7f00

	// SEL29: Crossbar A Select Register 29
	// Position of SEL58 field.
	XBARA_SEL29_SEL58_Pos = 0x0
	// Bit mask of SEL58 field.
	XBARA_SEL29_SEL58_Msk = 0x7f
	// Position of SEL59 field.
	XBARA_SEL29_SEL59_Pos = 0x8
	// Bit mask of SEL59 field.
	XBARA_SEL29_SEL59_Msk = 0x7f00

	// SEL30: Crossbar A Select Register 30
	// Position of SEL60 field.
	XBARA_SEL30_SEL60_Pos = 0x0
	// Bit mask of SEL60 field.
	XBARA_SEL30_SEL60_Msk = 0x7f
	// Position of SEL61 field.
	XBARA_SEL30_SEL61_Pos = 0x8
	// Bit mask of SEL61 field.
	XBARA_SEL30_SEL61_Msk = 0x7f00

	// SEL31: Crossbar A Select Register 31
	// Position of SEL62 field.
	XBARA_SEL31_SEL62_Pos = 0x0
	// Bit mask of SEL62 field.
	XBARA_SEL31_SEL62_Msk = 0x7f
	// Position of SEL63 field.
	XBARA_SEL31_SEL63_Pos = 0x8
	// Bit mask of SEL63 field.
	XBARA_SEL31_SEL63_Msk = 0x7f00

	// SEL32: Crossbar A Select Register 32
	// Position of SEL64 field.
	XBARA_SEL32_SEL64_Pos = 0x0
	// Bit mask of SEL64 field.
	XBARA_SEL32_SEL64_Msk = 0x7f
	// Position of SEL65 field.
	XBARA_SEL32_SEL65_Pos = 0x8
	// Bit mask of SEL65 field.
	XBARA_SEL32_SEL65_Msk = 0x7f00

	// SEL33: Crossbar A Select Register 33
	// Position of SEL66 field.
	XBARA_SEL33_SEL66_Pos = 0x0
	// Bit mask of SEL66 field.
	XBARA_SEL33_SEL66_Msk = 0x7f
	// Position of SEL67 field.
	XBARA_SEL33_SEL67_Pos = 0x8
	// Bit mask of SEL67 field.
	XBARA_SEL33_SEL67_Msk = 0x7f00

	// SEL34: Crossbar A Select Register 34
	// Position of SEL68 field.
	XBARA_SEL34_SEL68_Pos = 0x0
	// Bit mask of SEL68 field.
	XBARA_SEL34_SEL68_Msk = 0x7f
	// Position of SEL69 field.
	XBARA_SEL34_SEL69_Pos = 0x8
	// Bit mask of SEL69 field.
	XBARA_SEL34_SEL69_Msk = 0x7f00

	// SEL35: Crossbar A Select Register 35
	// Position of SEL70 field.
	XBARA_SEL35_SEL70_Pos = 0x0
	// Bit mask of SEL70 field.
	XBARA_SEL35_SEL70_Msk = 0x7f
	// Position of SEL71 field.
	XBARA_SEL35_SEL71_Pos = 0x8
	// Bit mask of SEL71 field.
	XBARA_SEL35_SEL71_Msk = 0x7f00

	// SEL36: Crossbar A Select Register 36
	// Position of SEL72 field.
	XBARA_SEL36_SEL72_Pos = 0x0
	// Bit mask of SEL72 field.
	XBARA_SEL36_SEL72_Msk = 0x7f
	// Position of SEL73 field.
	XBARA_SEL36_SEL73_Pos = 0x8
	// Bit mask of SEL73 field.
	XBARA_SEL36_SEL73_Msk = 0x7f00

	// SEL37: Crossbar A Select Register 37
	// Position of SEL74 field.
	XBARA_SEL37_SEL74_Pos = 0x0
	// Bit mask of SEL74 field.
	XBARA_SEL37_SEL74_Msk = 0x7f
	// Position of SEL75 field.
	XBARA_SEL37_SEL75_Pos = 0x8
	// Bit mask of SEL75 field.
	XBARA_SEL37_SEL75_Msk = 0x7f00

	// SEL38: Crossbar A Select Register 38
	// Position of SEL76 field.
	XBARA_SEL38_SEL76_Pos = 0x0
	// Bit mask of SEL76 field.
	XBARA_SEL38_SEL76_Msk = 0x7f
	// Position of SEL77 field.
	XBARA_SEL38_SEL77_Pos = 0x8
	// Bit mask of SEL77 field.
	XBARA_SEL38_SEL77_Msk = 0x7f00

	// SEL39: Crossbar A Select Register 39
	// Position of SEL78 field.
	XBARA_SEL39_SEL78_Pos = 0x0
	// Bit mask of SEL78 field.
	XBARA_SEL39_SEL78_Msk = 0x7f
	// Position of SEL79 field.
	XBARA_SEL39_SEL79_Pos = 0x8
	// Bit mask of SEL79 field.
	XBARA_SEL39_SEL79_Msk = 0x7f00

	// SEL40: Crossbar A Select Register 40
	// Position of SEL80 field.
	XBARA_SEL40_SEL80_Pos = 0x0
	// Bit mask of SEL80 field.
	XBARA_SEL40_SEL80_Msk = 0x7f
	// Position of SEL81 field.
	XBARA_SEL40_SEL81_Pos = 0x8
	// Bit mask of SEL81 field.
	XBARA_SEL40_SEL81_Msk = 0x7f00

	// SEL41: Crossbar A Select Register 41
	// Position of SEL82 field.
	XBARA_SEL41_SEL82_Pos = 0x0
	// Bit mask of SEL82 field.
	XBARA_SEL41_SEL82_Msk = 0x7f
	// Position of SEL83 field.
	XBARA_SEL41_SEL83_Pos = 0x8
	// Bit mask of SEL83 field.
	XBARA_SEL41_SEL83_Msk = 0x7f00

	// SEL42: Crossbar A Select Register 42
	// Position of SEL84 field.
	XBARA_SEL42_SEL84_Pos = 0x0
	// Bit mask of SEL84 field.
	XBARA_SEL42_SEL84_Msk = 0x7f
	// Position of SEL85 field.
	XBARA_SEL42_SEL85_Pos = 0x8
	// Bit mask of SEL85 field.
	XBARA_SEL42_SEL85_Msk = 0x7f00

	// SEL43: Crossbar A Select Register 43
	// Position of SEL86 field.
	XBARA_SEL43_SEL86_Pos = 0x0
	// Bit mask of SEL86 field.
	XBARA_SEL43_SEL86_Msk = 0x7f
	// Position of SEL87 field.
	XBARA_SEL43_SEL87_Pos = 0x8
	// Bit mask of SEL87 field.
	XBARA_SEL43_SEL87_Msk = 0x7f00

	// SEL44: Crossbar A Select Register 44
	// Position of SEL88 field.
	XBARA_SEL44_SEL88_Pos = 0x0
	// Bit mask of SEL88 field.
	XBARA_SEL44_SEL88_Msk = 0x7f
	// Position of SEL89 field.
	XBARA_SEL44_SEL89_Pos = 0x8
	// Bit mask of SEL89 field.
	XBARA_SEL44_SEL89_Msk = 0x7f00

	// SEL45: Crossbar A Select Register 45
	// Position of SEL90 field.
	XBARA_SEL45_SEL90_Pos = 0x0
	// Bit mask of SEL90 field.
	XBARA_SEL45_SEL90_Msk = 0x7f
	// Position of SEL91 field.
	XBARA_SEL45_SEL91_Pos = 0x8
	// Bit mask of SEL91 field.
	XBARA_SEL45_SEL91_Msk = 0x7f00

	// SEL46: Crossbar A Select Register 46
	// Position of SEL92 field.
	XBARA_SEL46_SEL92_Pos = 0x0
	// Bit mask of SEL92 field.
	XBARA_SEL46_SEL92_Msk = 0x7f
	// Position of SEL93 field.
	XBARA_SEL46_SEL93_Pos = 0x8
	// Bit mask of SEL93 field.
	XBARA_SEL46_SEL93_Msk = 0x7f00

	// SEL47: Crossbar A Select Register 47
	// Position of SEL94 field.
	XBARA_SEL47_SEL94_Pos = 0x0
	// Bit mask of SEL94 field.
	XBARA_SEL47_SEL94_Msk = 0x7f
	// Position of SEL95 field.
	XBARA_SEL47_SEL95_Pos = 0x8
	// Bit mask of SEL95 field.
	XBARA_SEL47_SEL95_Msk = 0x7f00

	// SEL48: Crossbar A Select Register 48
	// Position of SEL96 field.
	XBARA_SEL48_SEL96_Pos = 0x0
	// Bit mask of SEL96 field.
	XBARA_SEL48_SEL96_Msk = 0x7f
	// Position of SEL97 field.
	XBARA_SEL48_SEL97_Pos = 0x8
	// Bit mask of SEL97 field.
	XBARA_SEL48_SEL97_Msk = 0x7f00

	// SEL49: Crossbar A Select Register 49
	// Position of SEL98 field.
	XBARA_SEL49_SEL98_Pos = 0x0
	// Bit mask of SEL98 field.
	XBARA_SEL49_SEL98_Msk = 0x7f
	// Position of SEL99 field.
	XBARA_SEL49_SEL99_Pos = 0x8
	// Bit mask of SEL99 field.
	XBARA_SEL49_SEL99_Msk = 0x7f00

	// SEL50: Crossbar A Select Register 50
	// Position of SEL100 field.
	XBARA_SEL50_SEL100_Pos = 0x0
	// Bit mask of SEL100 field.
	XBARA_SEL50_SEL100_Msk = 0x7f
	// Position of SEL101 field.
	XBARA_SEL50_SEL101_Pos = 0x8
	// Bit mask of SEL101 field.
	XBARA_SEL50_SEL101_Msk = 0x7f00

	// SEL51: Crossbar A Select Register 51
	// Position of SEL102 field.
	XBARA_SEL51_SEL102_Pos = 0x0
	// Bit mask of SEL102 field.
	XBARA_SEL51_SEL102_Msk = 0x7f
	// Position of SEL103 field.
	XBARA_SEL51_SEL103_Pos = 0x8
	// Bit mask of SEL103 field.
	XBARA_SEL51_SEL103_Msk = 0x7f00

	// SEL52: Crossbar A Select Register 52
	// Position of SEL104 field.
	XBARA_SEL52_SEL104_Pos = 0x0
	// Bit mask of SEL104 field.
	XBARA_SEL52_SEL104_Msk = 0x7f
	// Position of SEL105 field.
	XBARA_SEL52_SEL105_Pos = 0x8
	// Bit mask of SEL105 field.
	XBARA_SEL52_SEL105_Msk = 0x7f00

	// SEL53: Crossbar A Select Register 53
	// Position of SEL106 field.
	XBARA_SEL53_SEL106_Pos = 0x0
	// Bit mask of SEL106 field.
	XBARA_SEL53_SEL106_Msk = 0x7f
	// Position of SEL107 field.
	XBARA_SEL53_SEL107_Pos = 0x8
	// Bit mask of SEL107 field.
	XBARA_SEL53_SEL107_Msk = 0x7f00

	// SEL54: Crossbar A Select Register 54
	// Position of SEL108 field.
	XBARA_SEL54_SEL108_Pos = 0x0
	// Bit mask of SEL108 field.
	XBARA_SEL54_SEL108_Msk = 0x7f
	// Position of SEL109 field.
	XBARA_SEL54_SEL109_Pos = 0x8
	// Bit mask of SEL109 field.
	XBARA_SEL54_SEL109_Msk = 0x7f00

	// SEL55: Crossbar A Select Register 55
	// Position of SEL110 field.
	XBARA_SEL55_SEL110_Pos = 0x0
	// Bit mask of SEL110 field.
	XBARA_SEL55_SEL110_Msk = 0x7f
	// Position of SEL111 field.
	XBARA_SEL55_SEL111_Pos = 0x8
	// Bit mask of SEL111 field.
	XBARA_SEL55_SEL111_Msk = 0x7f00

	// SEL56: Crossbar A Select Register 56
	// Position of SEL112 field.
	XBARA_SEL56_SEL112_Pos = 0x0
	// Bit mask of SEL112 field.
	XBARA_SEL56_SEL112_Msk = 0x7f
	// Position of SEL113 field.
	XBARA_SEL56_SEL113_Pos = 0x8
	// Bit mask of SEL113 field.
	XBARA_SEL56_SEL113_Msk = 0x7f00

	// SEL57: Crossbar A Select Register 57
	// Position of SEL114 field.
	XBARA_SEL57_SEL114_Pos = 0x0
	// Bit mask of SEL114 field.
	XBARA_SEL57_SEL114_Msk = 0x7f
	// Position of SEL115 field.
	XBARA_SEL57_SEL115_Pos = 0x8
	// Bit mask of SEL115 field.
	XBARA_SEL57_SEL115_Msk = 0x7f00

	// SEL58: Crossbar A Select Register 58
	// Position of SEL116 field.
	XBARA_SEL58_SEL116_Pos = 0x0
	// Bit mask of SEL116 field.
	XBARA_SEL58_SEL116_Msk = 0x7f
	// Position of SEL117 field.
	XBARA_SEL58_SEL117_Pos = 0x8
	// Bit mask of SEL117 field.
	XBARA_SEL58_SEL117_Msk = 0x7f00

	// SEL59: Crossbar A Select Register 59
	// Position of SEL118 field.
	XBARA_SEL59_SEL118_Pos = 0x0
	// Bit mask of SEL118 field.
	XBARA_SEL59_SEL118_Msk = 0x7f
	// Position of SEL119 field.
	XBARA_SEL59_SEL119_Pos = 0x8
	// Bit mask of SEL119 field.
	XBARA_SEL59_SEL119_Msk = 0x7f00

	// SEL60: Crossbar A Select Register 60
	// Position of SEL120 field.
	XBARA_SEL60_SEL120_Pos = 0x0
	// Bit mask of SEL120 field.
	XBARA_SEL60_SEL120_Msk = 0x7f
	// Position of SEL121 field.
	XBARA_SEL60_SEL121_Pos = 0x8
	// Bit mask of SEL121 field.
	XBARA_SEL60_SEL121_Msk = 0x7f00

	// SEL61: Crossbar A Select Register 61
	// Position of SEL122 field.
	XBARA_SEL61_SEL122_Pos = 0x0
	// Bit mask of SEL122 field.
	XBARA_SEL61_SEL122_Msk = 0x7f
	// Position of SEL123 field.
	XBARA_SEL61_SEL123_Pos = 0x8
	// Bit mask of SEL123 field.
	XBARA_SEL61_SEL123_Msk = 0x7f00

	// SEL62: Crossbar A Select Register 62
	// Position of SEL124 field.
	XBARA_SEL62_SEL124_Pos = 0x0
	// Bit mask of SEL124 field.
	XBARA_SEL62_SEL124_Msk = 0x7f
	// Position of SEL125 field.
	XBARA_SEL62_SEL125_Pos = 0x8
	// Bit mask of SEL125 field.
	XBARA_SEL62_SEL125_Msk = 0x7f00

	// SEL63: Crossbar A Select Register 63
	// Position of SEL126 field.
	XBARA_SEL63_SEL126_Pos = 0x0
	// Bit mask of SEL126 field.
	XBARA_SEL63_SEL126_Msk = 0x7f
	// Position of SEL127 field.
	XBARA_SEL63_SEL127_Pos = 0x8
	// Bit mask of SEL127 field.
	XBARA_SEL63_SEL127_Msk = 0x7f00

	// SEL64: Crossbar A Select Register 64
	// Position of SEL128 field.
	XBARA_SEL64_SEL128_Pos = 0x0
	// Bit mask of SEL128 field.
	XBARA_SEL64_SEL128_Msk = 0x7f
	// Position of SEL129 field.
	XBARA_SEL64_SEL129_Pos = 0x8
	// Bit mask of SEL129 field.
	XBARA_SEL64_SEL129_Msk = 0x7f00

	// SEL65: Crossbar A Select Register 65
	// Position of SEL130 field.
	XBARA_SEL65_SEL130_Pos = 0x0
	// Bit mask of SEL130 field.
	XBARA_SEL65_SEL130_Msk = 0x7f
	// Position of SEL131 field.
	XBARA_SEL65_SEL131_Pos = 0x8
	// Bit mask of SEL131 field.
	XBARA_SEL65_SEL131_Msk = 0x7f00

	// CTRL0: Crossbar A Control Register 0
	// Position of DEN0 field.
	XBARA_CTRL0_DEN0_Pos = 0x0
	// Bit mask of DEN0 field.
	XBARA_CTRL0_DEN0_Msk = 0x1
	// Bit DEN0.
	XBARA_CTRL0_DEN0 = 0x1
	// DMA disabled
	XBARA_CTRL0_DEN0_DEN0_0 = 0x0
	// DMA enabled
	XBARA_CTRL0_DEN0_DEN0_1 = 0x1
	// Position of IEN0 field.
	XBARA_CTRL0_IEN0_Pos = 0x1
	// Bit mask of IEN0 field.
	XBARA_CTRL0_IEN0_Msk = 0x2
	// Bit IEN0.
	XBARA_CTRL0_IEN0 = 0x2
	// Interrupt disabled
	XBARA_CTRL0_IEN0_IEN0_0 = 0x0
	// Interrupt enabled
	XBARA_CTRL0_IEN0_IEN0_1 = 0x1
	// Position of EDGE0 field.
	XBARA_CTRL0_EDGE0_Pos = 0x2
	// Bit mask of EDGE0 field.
	XBARA_CTRL0_EDGE0_Msk = 0xc
	// STS0 never asserts
	XBARA_CTRL0_EDGE0_EDGE0_0 = 0x0
	// STS0 asserts on rising edges of XBAR_OUT0
	XBARA_CTRL0_EDGE0_EDGE0_1 = 0x1
	// STS0 asserts on falling edges of XBAR_OUT0
	XBARA_CTRL0_EDGE0_EDGE0_2 = 0x2
	// STS0 asserts on rising and falling edges of XBAR_OUT0
	XBARA_CTRL0_EDGE0_EDGE0_3 = 0x3
	// Position of STS0 field.
	XBARA_CTRL0_STS0_Pos = 0x4
	// Bit mask of STS0 field.
	XBARA_CTRL0_STS0_Msk = 0x10
	// Bit STS0.
	XBARA_CTRL0_STS0 = 0x10
	// Active edge not yet detected on XBAR_OUT0
	XBARA_CTRL0_STS0_STS0_0 = 0x0
	// Active edge detected on XBAR_OUT0
	XBARA_CTRL0_STS0_STS0_1 = 0x1
	// Position of DEN1 field.
	XBARA_CTRL0_DEN1_Pos = 0x8
	// Bit mask of DEN1 field.
	XBARA_CTRL0_DEN1_Msk = 0x100
	// Bit DEN1.
	XBARA_CTRL0_DEN1 = 0x100
	// DMA disabled
	XBARA_CTRL0_DEN1_DEN1_0 = 0x0
	// DMA enabled
	XBARA_CTRL0_DEN1_DEN1_1 = 0x1
	// Position of IEN1 field.
	XBARA_CTRL0_IEN1_Pos = 0x9
	// Bit mask of IEN1 field.
	XBARA_CTRL0_IEN1_Msk = 0x200
	// Bit IEN1.
	XBARA_CTRL0_IEN1 = 0x200
	// Interrupt disabled
	XBARA_CTRL0_IEN1_IEN1_0 = 0x0
	// Interrupt enabled
	XBARA_CTRL0_IEN1_IEN1_1 = 0x1
	// Position of EDGE1 field.
	XBARA_CTRL0_EDGE1_Pos = 0xa
	// Bit mask of EDGE1 field.
	XBARA_CTRL0_EDGE1_Msk = 0xc00
	// STS1 never asserts
	XBARA_CTRL0_EDGE1_EDGE1_0 = 0x0
	// STS1 asserts on rising edges of XBAR_OUT1
	XBARA_CTRL0_EDGE1_EDGE1_1 = 0x1
	// STS1 asserts on falling edges of XBAR_OUT1
	XBARA_CTRL0_EDGE1_EDGE1_2 = 0x2
	// STS1 asserts on rising and falling edges of XBAR_OUT1
	XBARA_CTRL0_EDGE1_EDGE1_3 = 0x3
	// Position of STS1 field.
	XBARA_CTRL0_STS1_Pos = 0xc
	// Bit mask of STS1 field.
	XBARA_CTRL0_STS1_Msk = 0x1000
	// Bit STS1.
	XBARA_CTRL0_STS1 = 0x1000
	// Active edge not yet detected on XBAR_OUT1
	XBARA_CTRL0_STS1_STS1_0 = 0x0
	// Active edge detected on XBAR_OUT1
	XBARA_CTRL0_STS1_STS1_1 = 0x1

	// CTRL1: Crossbar A Control Register 1
	// Position of DEN2 field.
	XBARA_CTRL1_DEN2_Pos = 0x0
	// Bit mask of DEN2 field.
	XBARA_CTRL1_DEN2_Msk = 0x1
	// Bit DEN2.
	XBARA_CTRL1_DEN2 = 0x1
	// DMA disabled
	XBARA_CTRL1_DEN2_DEN2_0 = 0x0
	// DMA enabled
	XBARA_CTRL1_DEN2_DEN2_1 = 0x1
	// Position of IEN2 field.
	XBARA_CTRL1_IEN2_Pos = 0x1
	// Bit mask of IEN2 field.
	XBARA_CTRL1_IEN2_Msk = 0x2
	// Bit IEN2.
	XBARA_CTRL1_IEN2 = 0x2
	// Interrupt disabled
	XBARA_CTRL1_IEN2_IEN2_0 = 0x0
	// Interrupt enabled
	XBARA_CTRL1_IEN2_IEN2_1 = 0x1
	// Position of EDGE2 field.
	XBARA_CTRL1_EDGE2_Pos = 0x2
	// Bit mask of EDGE2 field.
	XBARA_CTRL1_EDGE2_Msk = 0xc
	// STS2 never asserts
	XBARA_CTRL1_EDGE2_EDGE2_0 = 0x0
	// STS2 asserts on rising edges of XBAR_OUT2
	XBARA_CTRL1_EDGE2_EDGE2_1 = 0x1
	// STS2 asserts on falling edges of XBAR_OUT2
	XBARA_CTRL1_EDGE2_EDGE2_2 = 0x2
	// STS2 asserts on rising and falling edges of XBAR_OUT2
	XBARA_CTRL1_EDGE2_EDGE2_3 = 0x3
	// Position of STS2 field.
	XBARA_CTRL1_STS2_Pos = 0x4
	// Bit mask of STS2 field.
	XBARA_CTRL1_STS2_Msk = 0x10
	// Bit STS2.
	XBARA_CTRL1_STS2 = 0x10
	// Active edge not yet detected on XBAR_OUT2
	XBARA_CTRL1_STS2_STS2_0 = 0x0
	// Active edge detected on XBAR_OUT2
	XBARA_CTRL1_STS2_STS2_1 = 0x1
	// Position of DEN3 field.
	XBARA_CTRL1_DEN3_Pos = 0x8
	// Bit mask of DEN3 field.
	XBARA_CTRL1_DEN3_Msk = 0x100
	// Bit DEN3.
	XBARA_CTRL1_DEN3 = 0x100
	// DMA disabled
	XBARA_CTRL1_DEN3_DEN3_0 = 0x0
	// DMA enabled
	XBARA_CTRL1_DEN3_DEN3_1 = 0x1
	// Position of IEN3 field.
	XBARA_CTRL1_IEN3_Pos = 0x9
	// Bit mask of IEN3 field.
	XBARA_CTRL1_IEN3_Msk = 0x200
	// Bit IEN3.
	XBARA_CTRL1_IEN3 = 0x200
	// Interrupt disabled
	XBARA_CTRL1_IEN3_IEN3_0 = 0x0
	// Interrupt enabled
	XBARA_CTRL1_IEN3_IEN3_1 = 0x1
	// Position of EDGE3 field.
	XBARA_CTRL1_EDGE3_Pos = 0xa
	// Bit mask of EDGE3 field.
	XBARA_CTRL1_EDGE3_Msk = 0xc00
	// STS3 never asserts
	XBARA_CTRL1_EDGE3_EDGE3_0 = 0x0
	// STS3 asserts on rising edges of XBAR_OUT3
	XBARA_CTRL1_EDGE3_EDGE3_1 = 0x1
	// STS3 asserts on falling edges of XBAR_OUT3
	XBARA_CTRL1_EDGE3_EDGE3_2 = 0x2
	// STS3 asserts on rising and falling edges of XBAR_OUT3
	XBARA_CTRL1_EDGE3_EDGE3_3 = 0x3
	// Position of STS3 field.
	XBARA_CTRL1_STS3_Pos = 0xc
	// Bit mask of STS3 field.
	XBARA_CTRL1_STS3_Msk = 0x1000
	// Bit STS3.
	XBARA_CTRL1_STS3 = 0x1000
	// Active edge not yet detected on XBAR_OUT3
	XBARA_CTRL1_STS3_STS3_0 = 0x0
	// Active edge detected on XBAR_OUT3
	XBARA_CTRL1_STS3_STS3_1 = 0x1
)

// Constants for FLEXSPI: FlexSPI
const (
	// MCR0: Module Control Register 0
	// Position of SWRESET field.
	FlexSPI_MCR0_SWRESET_Pos = 0x0
	// Bit mask of SWRESET field.
	FlexSPI_MCR0_SWRESET_Msk = 0x1
	// Bit SWRESET.
	FlexSPI_MCR0_SWRESET = 0x1
	// Position of MDIS field.
	FlexSPI_MCR0_MDIS_Pos = 0x1
	// Bit mask of MDIS field.
	FlexSPI_MCR0_MDIS_Msk = 0x2
	// Bit MDIS.
	FlexSPI_MCR0_MDIS = 0x2
	// Position of RXCLKSRC field.
	FlexSPI_MCR0_RXCLKSRC_Pos = 0x4
	// Bit mask of RXCLKSRC field.
	FlexSPI_MCR0_RXCLKSRC_Msk = 0x30
	// Dummy Read strobe generated by FlexSPI Controller and loopback internally.
	FlexSPI_MCR0_RXCLKSRC_RXCLKSRC_0 = 0x0
	// Dummy Read strobe generated by FlexSPI Controller and loopback from DQS pad.
	FlexSPI_MCR0_RXCLKSRC_RXCLKSRC_1 = 0x1
	// Flash provided Read strobe and input from DQS pad
	FlexSPI_MCR0_RXCLKSRC_RXCLKSRC_3 = 0x3
	// Position of ARDFEN field.
	FlexSPI_MCR0_ARDFEN_Pos = 0x6
	// Bit mask of ARDFEN field.
	FlexSPI_MCR0_ARDFEN_Msk = 0x40
	// Bit ARDFEN.
	FlexSPI_MCR0_ARDFEN = 0x40
	// IP RX FIFO should be read by IP Bus. AHB Bus read access to IP RX FIFO memory space will get bus error response.
	FlexSPI_MCR0_ARDFEN_ARDFEN_0 = 0x0
	// IP RX FIFO should be read by AHB Bus. IP Bus read access to IP RX FIFO memory space will always return data zero but no bus error response.
	FlexSPI_MCR0_ARDFEN_ARDFEN_1 = 0x1
	// Position of ATDFEN field.
	FlexSPI_MCR0_ATDFEN_Pos = 0x7
	// Bit mask of ATDFEN field.
	FlexSPI_MCR0_ATDFEN_Msk = 0x80
	// Bit ATDFEN.
	FlexSPI_MCR0_ATDFEN = 0x80
	// IP TX FIFO should be written by IP Bus. AHB Bus write access to IP TX FIFO memory space will get bus error response.
	FlexSPI_MCR0_ATDFEN_ATDFEN_0 = 0x0
	// IP TX FIFO should be written by AHB Bus. IP Bus write access to IP TX FIFO memory space will be ignored but no bus error response.
	FlexSPI_MCR0_ATDFEN_ATDFEN_1 = 0x1
	// Position of SERCLKDIV field.
	FlexSPI_MCR0_SERCLKDIV_Pos = 0x8
	// Bit mask of SERCLKDIV field.
	FlexSPI_MCR0_SERCLKDIV_Msk = 0x700
	// Divided by 1
	FlexSPI_MCR0_SERCLKDIV_SERCLKDIV_0 = 0x0
	// Divided by 2
	FlexSPI_MCR0_SERCLKDIV_SERCLKDIV_1 = 0x1
	// Divided by 3
	FlexSPI_MCR0_SERCLKDIV_SERCLKDIV_2 = 0x2
	// Divided by 4
	FlexSPI_MCR0_SERCLKDIV_SERCLKDIV_3 = 0x3
	// Divided by 5
	FlexSPI_MCR0_SERCLKDIV_SERCLKDIV_4 = 0x4
	// Divided by 6
	FlexSPI_MCR0_SERCLKDIV_SERCLKDIV_5 = 0x5
	// Divided by 7
	FlexSPI_MCR0_SERCLKDIV_SERCLKDIV_6 = 0x6
	// Divided by 8
	FlexSPI_MCR0_SERCLKDIV_SERCLKDIV_7 = 0x7
	// Position of HSEN field.
	FlexSPI_MCR0_HSEN_Pos = 0xb
	// Bit mask of HSEN field.
	FlexSPI_MCR0_HSEN_Msk = 0x800
	// Bit HSEN.
	FlexSPI_MCR0_HSEN = 0x800
	// Disable divide by 2 of serial flash clock for half speed commands.
	FlexSPI_MCR0_HSEN_HSEN_0 = 0x0
	// Enable divide by 2 of serial flash clock for half speed commands.
	FlexSPI_MCR0_HSEN_HSEN_1 = 0x1
	// Position of DOZEEN field.
	FlexSPI_MCR0_DOZEEN_Pos = 0xc
	// Bit mask of DOZEEN field.
	FlexSPI_MCR0_DOZEEN_Msk = 0x1000
	// Bit DOZEEN.
	FlexSPI_MCR0_DOZEEN = 0x1000
	// Doze mode support disabled. AHB clock and serial clock will not be gated off when there is doze mode request from system.
	FlexSPI_MCR0_DOZEEN_DOZEEN_0 = 0x0
	// Doze mode support enabled. AHB clock and serial clock will be gated off when there is doze mode request from system.
	FlexSPI_MCR0_DOZEEN_DOZEEN_1 = 0x1
	// Position of COMBINATIONEN field.
	FlexSPI_MCR0_COMBINATIONEN_Pos = 0xd
	// Bit mask of COMBINATIONEN field.
	FlexSPI_MCR0_COMBINATIONEN_Msk = 0x2000
	// Bit COMBINATIONEN.
	FlexSPI_MCR0_COMBINATIONEN = 0x2000
	// Disable.
	FlexSPI_MCR0_COMBINATIONEN_COMBINATIONEN_0 = 0x0
	// Enable.
	FlexSPI_MCR0_COMBINATIONEN_COMBINATIONEN_1 = 0x1
	// Position of SCKFREERUNEN field.
	FlexSPI_MCR0_SCKFREERUNEN_Pos = 0xe
	// Bit mask of SCKFREERUNEN field.
	FlexSPI_MCR0_SCKFREERUNEN_Msk = 0x4000
	// Bit SCKFREERUNEN.
	FlexSPI_MCR0_SCKFREERUNEN = 0x4000
	// Disable.
	FlexSPI_MCR0_SCKFREERUNEN_SCKFREERUNEN_0 = 0x0
	// Enable.
	FlexSPI_MCR0_SCKFREERUNEN_SCKFREERUNEN_1 = 0x1
	// Position of IPGRANTWAIT field.
	FlexSPI_MCR0_IPGRANTWAIT_Pos = 0x10
	// Bit mask of IPGRANTWAIT field.
	FlexSPI_MCR0_IPGRANTWAIT_Msk = 0xff0000
	// Position of AHBGRANTWAIT field.
	FlexSPI_MCR0_AHBGRANTWAIT_Pos = 0x18
	// Bit mask of AHBGRANTWAIT field.
	FlexSPI_MCR0_AHBGRANTWAIT_Msk = 0xff000000

	// MCR1: Module Control Register 1
	// Position of AHBBUSWAIT field.
	FlexSPI_MCR1_AHBBUSWAIT_Pos = 0x0
	// Bit mask of AHBBUSWAIT field.
	FlexSPI_MCR1_AHBBUSWAIT_Msk = 0xffff
	// Position of SEQWAIT field.
	FlexSPI_MCR1_SEQWAIT_Pos = 0x10
	// Bit mask of SEQWAIT field.
	FlexSPI_MCR1_SEQWAIT_Msk = 0xffff0000

	// MCR2: Module Control Register 2
	// Position of CLRAHBBUFOPT field.
	FlexSPI_MCR2_CLRAHBBUFOPT_Pos = 0xb
	// Bit mask of CLRAHBBUFOPT field.
	FlexSPI_MCR2_CLRAHBBUFOPT_Msk = 0x800
	// Bit CLRAHBBUFOPT.
	FlexSPI_MCR2_CLRAHBBUFOPT = 0x800
	// AHB RX/TX Buffer will not be cleaned automatically when FlexSPI return Stop mode ACK.
	FlexSPI_MCR2_CLRAHBBUFOPT_CLRAHBBUFOPT_0 = 0x0
	// AHB RX/TX Buffer will be cleaned automatically when FlexSPI return Stop mode ACK.
	FlexSPI_MCR2_CLRAHBBUFOPT_CLRAHBBUFOPT_1 = 0x1
	// Position of CLRLEARNPHASE field.
	FlexSPI_MCR2_CLRLEARNPHASE_Pos = 0xe
	// Bit mask of CLRLEARNPHASE field.
	FlexSPI_MCR2_CLRLEARNPHASE_Msk = 0x4000
	// Bit CLRLEARNPHASE.
	FlexSPI_MCR2_CLRLEARNPHASE = 0x4000
	// Position of SAMEDEVICEEN field.
	FlexSPI_MCR2_SAMEDEVICEEN_Pos = 0xf
	// Bit mask of SAMEDEVICEEN field.
	FlexSPI_MCR2_SAMEDEVICEEN_Msk = 0x8000
	// Bit SAMEDEVICEEN.
	FlexSPI_MCR2_SAMEDEVICEEN = 0x8000
	// In Individual mode, FLSHA1CRx/FLSHA2CRx/FLSHB1CRx/FLSHB2CRx register setting will be applied to Flash A1/A2/B1/B2 separately. In Parallel mode, FLSHA1CRx register setting will be applied to Flash A1 and B1, FLSHA2CRx register setting will be applied to Flash A2 and B2. FLSHB1CRx/FLSHB2CRx register settings will be ignored.
	FlexSPI_MCR2_SAMEDEVICEEN_SAMEDEVICEEN_0 = 0x0
	// FLSHA1CR0/FLSHA1CR1/FLSHA1CR2 register settings will be applied to Flash A1/A2/B1/B2. FLSHA2CRx/FLSHB1CRx/FLSHB2CRx will be ignored.
	FlexSPI_MCR2_SAMEDEVICEEN_SAMEDEVICEEN_1 = 0x1
	// Position of SCKBDIFFOPT field.
	FlexSPI_MCR2_SCKBDIFFOPT_Pos = 0x13
	// Bit mask of SCKBDIFFOPT field.
	FlexSPI_MCR2_SCKBDIFFOPT_Msk = 0x80000
	// Bit SCKBDIFFOPT.
	FlexSPI_MCR2_SCKBDIFFOPT = 0x80000
	// B_SCLK pad is used as port B SCLK clock output. Port B flash access is available.
	FlexSPI_MCR2_SCKBDIFFOPT_SCKBDIFFOPT_0 = 0x0
	// B_SCLK pad is used as port A SCLK inverted clock output (Differential clock to A_SCLK). Port B flash access is not available.
	FlexSPI_MCR2_SCKBDIFFOPT_SCKBDIFFOPT_1 = 0x1
	// Position of RESUMEWAIT field.
	FlexSPI_MCR2_RESUMEWAIT_Pos = 0x18
	// Bit mask of RESUMEWAIT field.
	FlexSPI_MCR2_RESUMEWAIT_Msk = 0xff000000

	// AHBCR: AHB Bus Control Register
	// Position of APAREN field.
	FlexSPI_AHBCR_APAREN_Pos = 0x0
	// Bit mask of APAREN field.
	FlexSPI_AHBCR_APAREN_Msk = 0x1
	// Bit APAREN.
	FlexSPI_AHBCR_APAREN = 0x1
	// Flash will be accessed in Individual mode.
	FlexSPI_AHBCR_APAREN_APAREN_0 = 0x0
	// Flash will be accessed in Parallel mode.
	FlexSPI_AHBCR_APAREN_APAREN_1 = 0x1
	// Position of CLRAHBRXBUF field.
	FlexSPI_AHBCR_CLRAHBRXBUF_Pos = 0x1
	// Bit mask of CLRAHBRXBUF field.
	FlexSPI_AHBCR_CLRAHBRXBUF_Msk = 0x2
	// Bit CLRAHBRXBUF.
	FlexSPI_AHBCR_CLRAHBRXBUF = 0x2
	// Position of CLRAHBTXBUF field.
	FlexSPI_AHBCR_CLRAHBTXBUF_Pos = 0x2
	// Bit mask of CLRAHBTXBUF field.
	FlexSPI_AHBCR_CLRAHBTXBUF_Msk = 0x4
	// Bit CLRAHBTXBUF.
	FlexSPI_AHBCR_CLRAHBTXBUF = 0x4
	// Position of CACHABLEEN field.
	FlexSPI_AHBCR_CACHABLEEN_Pos = 0x3
	// Bit mask of CACHABLEEN field.
	FlexSPI_AHBCR_CACHABLEEN_Msk = 0x8
	// Bit CACHABLEEN.
	FlexSPI_AHBCR_CACHABLEEN = 0x8
	// Disabled. When there is AHB bus cachable read access, FlexSPI will not check whether it hit AHB TX Buffer.
	FlexSPI_AHBCR_CACHABLEEN_CACHABLEEN_0 = 0x0
	// Enabled. When there is AHB bus cachable read access, FlexSPI will check whether it hit AHB TX Buffer first.
	FlexSPI_AHBCR_CACHABLEEN_CACHABLEEN_1 = 0x1
	// Position of BUFFERABLEEN field.
	FlexSPI_AHBCR_BUFFERABLEEN_Pos = 0x4
	// Bit mask of BUFFERABLEEN field.
	FlexSPI_AHBCR_BUFFERABLEEN_Msk = 0x10
	// Bit BUFFERABLEEN.
	FlexSPI_AHBCR_BUFFERABLEEN = 0x10
	// Disabled. For all AHB write access (no matter bufferable or non-bufferable ), FlexSPI will return AHB Bus ready after all data is transmitted to External device and AHB command finished.
	FlexSPI_AHBCR_BUFFERABLEEN_BUFFERABLEEN_0 = 0x0
	// Enabled. For AHB bufferable write access, FlexSPI will return AHB Bus ready when the AHB command is granted by arbitrator and will not wait for AHB command finished.
	FlexSPI_AHBCR_BUFFERABLEEN_BUFFERABLEEN_1 = 0x1
	// Position of PREFETCHEN field.
	FlexSPI_AHBCR_PREFETCHEN_Pos = 0x5
	// Bit mask of PREFETCHEN field.
	FlexSPI_AHBCR_PREFETCHEN_Msk = 0x20
	// Bit PREFETCHEN.
	FlexSPI_AHBCR_PREFETCHEN = 0x20
	// Position of READADDROPT field.
	FlexSPI_AHBCR_READADDROPT_Pos = 0x6
	// Bit mask of READADDROPT field.
	FlexSPI_AHBCR_READADDROPT_Msk = 0x40
	// Bit READADDROPT.
	FlexSPI_AHBCR_READADDROPT = 0x40
	// There is AHB read burst start address alignment limitation when flash is accessed in parallel mode or flash is wordaddressable.
	FlexSPI_AHBCR_READADDROPT_READADDROPT_0 = 0x0
	// There is no AHB read burst start address alignment limitation. FlexSPI will fetch more data than AHB burst required to meet the alignment requirement.
	FlexSPI_AHBCR_READADDROPT_READADDROPT_1 = 0x1
	// Position of READSZALIGN field.
	FlexSPI_AHBCR_READSZALIGN_Pos = 0xa
	// Bit mask of READSZALIGN field.
	FlexSPI_AHBCR_READSZALIGN_Msk = 0x400
	// Bit READSZALIGN.
	FlexSPI_AHBCR_READSZALIGN = 0x400
	// AHB read size will be decided by other register setting like PREFETCH_EN,OTFAD_EN...
	FlexSPI_AHBCR_READSZALIGN_READSZALIGN_0 = 0x0
	// AHB read size to up size to 8 bytes aligned, no prefetching
	FlexSPI_AHBCR_READSZALIGN_READSZALIGN_1 = 0x1

	// INTEN: Interrupt Enable Register
	// Position of IPCMDDONEEN field.
	FlexSPI_INTEN_IPCMDDONEEN_Pos = 0x0
	// Bit mask of IPCMDDONEEN field.
	FlexSPI_INTEN_IPCMDDONEEN_Msk = 0x1
	// Bit IPCMDDONEEN.
	FlexSPI_INTEN_IPCMDDONEEN = 0x1
	// Position of IPCMDGEEN field.
	FlexSPI_INTEN_IPCMDGEEN_Pos = 0x1
	// Bit mask of IPCMDGEEN field.
	FlexSPI_INTEN_IPCMDGEEN_Msk = 0x2
	// Bit IPCMDGEEN.
	FlexSPI_INTEN_IPCMDGEEN = 0x2
	// Position of AHBCMDGEEN field.
	FlexSPI_INTEN_AHBCMDGEEN_Pos = 0x2
	// Bit mask of AHBCMDGEEN field.
	FlexSPI_INTEN_AHBCMDGEEN_Msk = 0x4
	// Bit AHBCMDGEEN.
	FlexSPI_INTEN_AHBCMDGEEN = 0x4
	// Position of IPCMDERREN field.
	FlexSPI_INTEN_IPCMDERREN_Pos = 0x3
	// Bit mask of IPCMDERREN field.
	FlexSPI_INTEN_IPCMDERREN_Msk = 0x8
	// Bit IPCMDERREN.
	FlexSPI_INTEN_IPCMDERREN = 0x8
	// Position of AHBCMDERREN field.
	FlexSPI_INTEN_AHBCMDERREN_Pos = 0x4
	// Bit mask of AHBCMDERREN field.
	FlexSPI_INTEN_AHBCMDERREN_Msk = 0x10
	// Bit AHBCMDERREN.
	FlexSPI_INTEN_AHBCMDERREN = 0x10
	// Position of IPRXWAEN field.
	FlexSPI_INTEN_IPRXWAEN_Pos = 0x5
	// Bit mask of IPRXWAEN field.
	FlexSPI_INTEN_IPRXWAEN_Msk = 0x20
	// Bit IPRXWAEN.
	FlexSPI_INTEN_IPRXWAEN = 0x20
	// Position of IPTXWEEN field.
	FlexSPI_INTEN_IPTXWEEN_Pos = 0x6
	// Bit mask of IPTXWEEN field.
	FlexSPI_INTEN_IPTXWEEN_Msk = 0x40
	// Bit IPTXWEEN.
	FlexSPI_INTEN_IPTXWEEN = 0x40
	// Position of SCKSTOPBYRDEN field.
	FlexSPI_INTEN_SCKSTOPBYRDEN_Pos = 0x8
	// Bit mask of SCKSTOPBYRDEN field.
	FlexSPI_INTEN_SCKSTOPBYRDEN_Msk = 0x100
	// Bit SCKSTOPBYRDEN.
	FlexSPI_INTEN_SCKSTOPBYRDEN = 0x100
	// Position of SCKSTOPBYWREN field.
	FlexSPI_INTEN_SCKSTOPBYWREN_Pos = 0x9
	// Bit mask of SCKSTOPBYWREN field.
	FlexSPI_INTEN_SCKSTOPBYWREN_Msk = 0x200
	// Bit SCKSTOPBYWREN.
	FlexSPI_INTEN_SCKSTOPBYWREN = 0x200
	// Position of AHBBUSERROREN field.
	FlexSPI_INTEN_AHBBUSERROREN_Pos = 0xa
	// Bit mask of AHBBUSERROREN field.
	FlexSPI_INTEN_AHBBUSERROREN_Msk = 0x400
	// Bit AHBBUSERROREN.
	FlexSPI_INTEN_AHBBUSERROREN = 0x400
	// Position of SEQTIMEOUTEN field.
	FlexSPI_INTEN_SEQTIMEOUTEN_Pos = 0xb
	// Bit mask of SEQTIMEOUTEN field.
	FlexSPI_INTEN_SEQTIMEOUTEN_Msk = 0x800
	// Bit SEQTIMEOUTEN.
	FlexSPI_INTEN_SEQTIMEOUTEN = 0x800
	// Position of KEYDONEEN field.
	FlexSPI_INTEN_KEYDONEEN_Pos = 0xc
	// Bit mask of KEYDONEEN field.
	FlexSPI_INTEN_KEYDONEEN_Msk = 0x1000
	// Bit KEYDONEEN.
	FlexSPI_INTEN_KEYDONEEN = 0x1000
	// Position of KEYERROREN field.
	FlexSPI_INTEN_KEYERROREN_Pos = 0xd
	// Bit mask of KEYERROREN field.
	FlexSPI_INTEN_KEYERROREN_Msk = 0x2000
	// Bit KEYERROREN.
	FlexSPI_INTEN_KEYERROREN = 0x2000

	// INTR: Interrupt Register
	// Position of IPCMDDONE field.
	FlexSPI_INTR_IPCMDDONE_Pos = 0x0
	// Bit mask of IPCMDDONE field.
	FlexSPI_INTR_IPCMDDONE_Msk = 0x1
	// Bit IPCMDDONE.
	FlexSPI_INTR_IPCMDDONE = 0x1
	// Position of IPCMDGE field.
	FlexSPI_INTR_IPCMDGE_Pos = 0x1
	// Bit mask of IPCMDGE field.
	FlexSPI_INTR_IPCMDGE_Msk = 0x2
	// Bit IPCMDGE.
	FlexSPI_INTR_IPCMDGE = 0x2
	// Position of AHBCMDGE field.
	FlexSPI_INTR_AHBCMDGE_Pos = 0x2
	// Bit mask of AHBCMDGE field.
	FlexSPI_INTR_AHBCMDGE_Msk = 0x4
	// Bit AHBCMDGE.
	FlexSPI_INTR_AHBCMDGE = 0x4
	// Position of IPCMDERR field.
	FlexSPI_INTR_IPCMDERR_Pos = 0x3
	// Bit mask of IPCMDERR field.
	FlexSPI_INTR_IPCMDERR_Msk = 0x8
	// Bit IPCMDERR.
	FlexSPI_INTR_IPCMDERR = 0x8
	// Position of AHBCMDERR field.
	FlexSPI_INTR_AHBCMDERR_Pos = 0x4
	// Bit mask of AHBCMDERR field.
	FlexSPI_INTR_AHBCMDERR_Msk = 0x10
	// Bit AHBCMDERR.
	FlexSPI_INTR_AHBCMDERR = 0x10
	// Position of IPRXWA field.
	FlexSPI_INTR_IPRXWA_Pos = 0x5
	// Bit mask of IPRXWA field.
	FlexSPI_INTR_IPRXWA_Msk = 0x20
	// Bit IPRXWA.
	FlexSPI_INTR_IPRXWA = 0x20
	// Position of IPTXWE field.
	FlexSPI_INTR_IPTXWE_Pos = 0x6
	// Bit mask of IPTXWE field.
	FlexSPI_INTR_IPTXWE_Msk = 0x40
	// Bit IPTXWE.
	FlexSPI_INTR_IPTXWE = 0x40
	// Position of SCKSTOPBYRD field.
	FlexSPI_INTR_SCKSTOPBYRD_Pos = 0x8
	// Bit mask of SCKSTOPBYRD field.
	FlexSPI_INTR_SCKSTOPBYRD_Msk = 0x100
	// Bit SCKSTOPBYRD.
	FlexSPI_INTR_SCKSTOPBYRD = 0x100
	// Position of SCKSTOPBYWR field.
	FlexSPI_INTR_SCKSTOPBYWR_Pos = 0x9
	// Bit mask of SCKSTOPBYWR field.
	FlexSPI_INTR_SCKSTOPBYWR_Msk = 0x200
	// Bit SCKSTOPBYWR.
	FlexSPI_INTR_SCKSTOPBYWR = 0x200
	// Position of AHBBUSERROR field.
	FlexSPI_INTR_AHBBUSERROR_Pos = 0xa
	// Bit mask of AHBBUSERROR field.
	FlexSPI_INTR_AHBBUSERROR_Msk = 0x400
	// Bit AHBBUSERROR.
	FlexSPI_INTR_AHBBUSERROR = 0x400
	// Position of SEQTIMEOUT field.
	FlexSPI_INTR_SEQTIMEOUT_Pos = 0xb
	// Bit mask of SEQTIMEOUT field.
	FlexSPI_INTR_SEQTIMEOUT_Msk = 0x800
	// Bit SEQTIMEOUT.
	FlexSPI_INTR_SEQTIMEOUT = 0x800
	// Position of KEYDONE field.
	FlexSPI_INTR_KEYDONE_Pos = 0xc
	// Bit mask of KEYDONE field.
	FlexSPI_INTR_KEYDONE_Msk = 0x1000
	// Bit KEYDONE.
	FlexSPI_INTR_KEYDONE = 0x1000
	// Position of KEYERROR field.
	FlexSPI_INTR_KEYERROR_Pos = 0xd
	// Bit mask of KEYERROR field.
	FlexSPI_INTR_KEYERROR_Msk = 0x2000
	// Bit KEYERROR.
	FlexSPI_INTR_KEYERROR = 0x2000

	// LUTKEY: LUT Key Register
	// Position of KEY field.
	FlexSPI_LUTKEY_KEY_Pos = 0x0
	// Bit mask of KEY field.
	FlexSPI_LUTKEY_KEY_Msk = 0xffffffff

	// LUTCR: LUT Control Register
	// Position of LOCK field.
	FlexSPI_LUTCR_LOCK_Pos = 0x0
	// Bit mask of LOCK field.
	FlexSPI_LUTCR_LOCK_Msk = 0x1
	// Bit LOCK.
	FlexSPI_LUTCR_LOCK = 0x1
	// Position of UNLOCK field.
	FlexSPI_LUTCR_UNLOCK_Pos = 0x1
	// Bit mask of UNLOCK field.
	FlexSPI_LUTCR_UNLOCK_Msk = 0x2
	// Bit UNLOCK.
	FlexSPI_LUTCR_UNLOCK = 0x2

	// AHBRXBUF0CR0: AHB RX Buffer 0 Control Register 0
	// Position of BUFSZ field.
	FlexSPI_AHBRXBUF0CR0_BUFSZ_Pos = 0x0
	// Bit mask of BUFSZ field.
	FlexSPI_AHBRXBUF0CR0_BUFSZ_Msk = 0xff
	// Position of MSTRID field.
	FlexSPI_AHBRXBUF0CR0_MSTRID_Pos = 0x10
	// Bit mask of MSTRID field.
	FlexSPI_AHBRXBUF0CR0_MSTRID_Msk = 0xf0000
	// Position of PRIORITY field.
	FlexSPI_AHBRXBUF0CR0_PRIORITY_Pos = 0x18
	// Bit mask of PRIORITY field.
	FlexSPI_AHBRXBUF0CR0_PRIORITY_Msk = 0x3000000
	// Position of PREFETCHEN field.
	FlexSPI_AHBRXBUF0CR0_PREFETCHEN_Pos = 0x1f
	// Bit mask of PREFETCHEN field.
	FlexSPI_AHBRXBUF0CR0_PREFETCHEN_Msk = 0x80000000
	// Bit PREFETCHEN.
	FlexSPI_AHBRXBUF0CR0_PREFETCHEN = 0x80000000

	// AHBRXBUF1CR0: AHB RX Buffer 1 Control Register 0
	// Position of BUFSZ field.
	FlexSPI_AHBRXBUF1CR0_BUFSZ_Pos = 0x0
	// Bit mask of BUFSZ field.
	FlexSPI_AHBRXBUF1CR0_BUFSZ_Msk = 0xff
	// Position of MSTRID field.
	FlexSPI_AHBRXBUF1CR0_MSTRID_Pos = 0x10
	// Bit mask of MSTRID field.
	FlexSPI_AHBRXBUF1CR0_MSTRID_Msk = 0xf0000
	// Position of PRIORITY field.
	FlexSPI_AHBRXBUF1CR0_PRIORITY_Pos = 0x18
	// Bit mask of PRIORITY field.
	FlexSPI_AHBRXBUF1CR0_PRIORITY_Msk = 0x3000000
	// Position of PREFETCHEN field.
	FlexSPI_AHBRXBUF1CR0_PREFETCHEN_Pos = 0x1f
	// Bit mask of PREFETCHEN field.
	FlexSPI_AHBRXBUF1CR0_PREFETCHEN_Msk = 0x80000000
	// Bit PREFETCHEN.
	FlexSPI_AHBRXBUF1CR0_PREFETCHEN = 0x80000000

	// AHBRXBUF2CR0: AHB RX Buffer 2 Control Register 0
	// Position of BUFSZ field.
	FlexSPI_AHBRXBUF2CR0_BUFSZ_Pos = 0x0
	// Bit mask of BUFSZ field.
	FlexSPI_AHBRXBUF2CR0_BUFSZ_Msk = 0xff
	// Position of MSTRID field.
	FlexSPI_AHBRXBUF2CR0_MSTRID_Pos = 0x10
	// Bit mask of MSTRID field.
	FlexSPI_AHBRXBUF2CR0_MSTRID_Msk = 0xf0000
	// Position of PRIORITY field.
	FlexSPI_AHBRXBUF2CR0_PRIORITY_Pos = 0x18
	// Bit mask of PRIORITY field.
	FlexSPI_AHBRXBUF2CR0_PRIORITY_Msk = 0x3000000
	// Position of PREFETCHEN field.
	FlexSPI_AHBRXBUF2CR0_PREFETCHEN_Pos = 0x1f
	// Bit mask of PREFETCHEN field.
	FlexSPI_AHBRXBUF2CR0_PREFETCHEN_Msk = 0x80000000
	// Bit PREFETCHEN.
	FlexSPI_AHBRXBUF2CR0_PREFETCHEN = 0x80000000

	// AHBRXBUF3CR0: AHB RX Buffer 3 Control Register 0
	// Position of BUFSZ field.
	FlexSPI_AHBRXBUF3CR0_BUFSZ_Pos = 0x0
	// Bit mask of BUFSZ field.
	FlexSPI_AHBRXBUF3CR0_BUFSZ_Msk = 0xff
	// Position of MSTRID field.
	FlexSPI_AHBRXBUF3CR0_MSTRID_Pos = 0x10
	// Bit mask of MSTRID field.
	FlexSPI_AHBRXBUF3CR0_MSTRID_Msk = 0xf0000
	// Position of PRIORITY field.
	FlexSPI_AHBRXBUF3CR0_PRIORITY_Pos = 0x18
	// Bit mask of PRIORITY field.
	FlexSPI_AHBRXBUF3CR0_PRIORITY_Msk = 0x3000000
	// Position of PREFETCHEN field.
	FlexSPI_AHBRXBUF3CR0_PREFETCHEN_Pos = 0x1f
	// Bit mask of PREFETCHEN field.
	FlexSPI_AHBRXBUF3CR0_PREFETCHEN_Msk = 0x80000000
	// Bit PREFETCHEN.
	FlexSPI_AHBRXBUF3CR0_PREFETCHEN = 0x80000000

	// FLSHA1CR0: Flash Control Register 0
	// Position of FLSHSZ field.
	FlexSPI_FLSHA1CR0_FLSHSZ_Pos = 0x0
	// Bit mask of FLSHSZ field.
	FlexSPI_FLSHA1CR0_FLSHSZ_Msk = 0x7fffff

	// FLSHA2CR0: Flash Control Register 0
	// Position of FLSHSZ field.
	FlexSPI_FLSHA2CR0_FLSHSZ_Pos = 0x0
	// Bit mask of FLSHSZ field.
	FlexSPI_FLSHA2CR0_FLSHSZ_Msk = 0x7fffff

	// FLSHB1CR0: Flash Control Register 0
	// Position of FLSHSZ field.
	FlexSPI_FLSHB1CR0_FLSHSZ_Pos = 0x0
	// Bit mask of FLSHSZ field.
	FlexSPI_FLSHB1CR0_FLSHSZ_Msk = 0x7fffff

	// FLSHB2CR0: Flash Control Register 0
	// Position of FLSHSZ field.
	FlexSPI_FLSHB2CR0_FLSHSZ_Pos = 0x0
	// Bit mask of FLSHSZ field.
	FlexSPI_FLSHB2CR0_FLSHSZ_Msk = 0x7fffff

	// FLSHCR1A1: Flash Control Register 1
	// Position of TCSS field.
	FlexSPI_FLSHCR1_TCSS_Pos = 0x0
	// Bit mask of TCSS field.
	FlexSPI_FLSHCR1_TCSS_Msk = 0x1f
	// Position of TCSH field.
	FlexSPI_FLSHCR1_TCSH_Pos = 0x5
	// Bit mask of TCSH field.
	FlexSPI_FLSHCR1_TCSH_Msk = 0x3e0
	// Position of WA field.
	FlexSPI_FLSHCR1_WA_Pos = 0xa
	// Bit mask of WA field.
	FlexSPI_FLSHCR1_WA_Msk = 0x400
	// Bit WA.
	FlexSPI_FLSHCR1_WA = 0x400
	// Position of CAS field.
	FlexSPI_FLSHCR1_CAS_Pos = 0xb
	// Bit mask of CAS field.
	FlexSPI_FLSHCR1_CAS_Msk = 0x7800
	// Position of CSINTERVALUNIT field.
	FlexSPI_FLSHCR1_CSINTERVALUNIT_Pos = 0xf
	// Bit mask of CSINTERVALUNIT field.
	FlexSPI_FLSHCR1_CSINTERVALUNIT_Msk = 0x8000
	// Bit CSINTERVALUNIT.
	FlexSPI_FLSHCR1_CSINTERVALUNIT = 0x8000
	// The CS interval unit is 1 serial clock cycle
	FlexSPI_FLSHCR1_CSINTERVALUNIT_CSINTERVALUNIT_0 = 0x0
	// The CS interval unit is 256 serial clock cycle
	FlexSPI_FLSHCR1_CSINTERVALUNIT_CSINTERVALUNIT_1 = 0x1
	// Position of CSINTERVAL field.
	FlexSPI_FLSHCR1_CSINTERVAL_Pos = 0x10
	// Bit mask of CSINTERVAL field.
	FlexSPI_FLSHCR1_CSINTERVAL_Msk = 0xffff0000

	// FLSHCR2A1: Flash Control Register 2
	// Position of ARDSEQID field.
	FlexSPI_FLSHCR2_ARDSEQID_Pos = 0x0
	// Bit mask of ARDSEQID field.
	FlexSPI_FLSHCR2_ARDSEQID_Msk = 0xf
	// Position of ARDSEQNUM field.
	FlexSPI_FLSHCR2_ARDSEQNUM_Pos = 0x5
	// Bit mask of ARDSEQNUM field.
	FlexSPI_FLSHCR2_ARDSEQNUM_Msk = 0xe0
	// Position of AWRSEQID field.
	FlexSPI_FLSHCR2_AWRSEQID_Pos = 0x8
	// Bit mask of AWRSEQID field.
	FlexSPI_FLSHCR2_AWRSEQID_Msk = 0xf00
	// Position of AWRSEQNUM field.
	FlexSPI_FLSHCR2_AWRSEQNUM_Pos = 0xd
	// Bit mask of AWRSEQNUM field.
	FlexSPI_FLSHCR2_AWRSEQNUM_Msk = 0xe000
	// Position of AWRWAIT field.
	FlexSPI_FLSHCR2_AWRWAIT_Pos = 0x10
	// Bit mask of AWRWAIT field.
	FlexSPI_FLSHCR2_AWRWAIT_Msk = 0xfff0000
	// Position of AWRWAITUNIT field.
	FlexSPI_FLSHCR2_AWRWAITUNIT_Pos = 0x1c
	// Bit mask of AWRWAITUNIT field.
	FlexSPI_FLSHCR2_AWRWAITUNIT_Msk = 0x70000000
	// The AWRWAIT unit is 2 ahb clock cycle
	FlexSPI_FLSHCR2_AWRWAITUNIT_AWRWAITUNIT_0 = 0x0
	// The AWRWAIT unit is 8 ahb clock cycle
	FlexSPI_FLSHCR2_AWRWAITUNIT_AWRWAITUNIT_1 = 0x1
	// The AWRWAIT unit is 32 ahb clock cycle
	FlexSPI_FLSHCR2_AWRWAITUNIT_AWRWAITUNIT_2 = 0x2
	// The AWRWAIT unit is 128 ahb clock cycle
	FlexSPI_FLSHCR2_AWRWAITUNIT_AWRWAITUNIT_3 = 0x3
	// The AWRWAIT unit is 512 ahb clock cycle
	FlexSPI_FLSHCR2_AWRWAITUNIT_AWRWAITUNIT_4 = 0x4
	// The AWRWAIT unit is 2048 ahb clock cycle
	FlexSPI_FLSHCR2_AWRWAITUNIT_AWRWAITUNIT_5 = 0x5
	// The AWRWAIT unit is 8192 ahb clock cycle
	FlexSPI_FLSHCR2_AWRWAITUNIT_AWRWAITUNIT_6 = 0x6
	// The AWRWAIT unit is 32768 ahb clock cycle
	FlexSPI_FLSHCR2_AWRWAITUNIT_AWRWAITUNIT_7 = 0x7
	// Position of CLRINSTRPTR field.
	FlexSPI_FLSHCR2_CLRINSTRPTR_Pos = 0x1f
	// Bit mask of CLRINSTRPTR field.
	FlexSPI_FLSHCR2_CLRINSTRPTR_Msk = 0x80000000
	// Bit CLRINSTRPTR.
	FlexSPI_FLSHCR2_CLRINSTRPTR = 0x80000000

	// FLSHCR4: Flash Control Register 4
	// Position of WMOPT1 field.
	FlexSPI_FLSHCR4_WMOPT1_Pos = 0x0
	// Bit mask of WMOPT1 field.
	FlexSPI_FLSHCR4_WMOPT1_Msk = 0x1
	// Bit WMOPT1.
	FlexSPI_FLSHCR4_WMOPT1 = 0x1
	// DQS pin will be used as Write Mask when writing to external device. There is no limitation on AHB write burst start address alignment when flash is accessed in individual mode.
	FlexSPI_FLSHCR4_WMOPT1_WMOPT1_0 = 0x0
	// DQS pin will not be used as Write Mask when writing to external device. There is limitation on AHB write burst start address alignment when flash is accessed in individual mode.
	FlexSPI_FLSHCR4_WMOPT1_WMOPT1_1 = 0x1
	// Position of WMENA field.
	FlexSPI_FLSHCR4_WMENA_Pos = 0x2
	// Bit mask of WMENA field.
	FlexSPI_FLSHCR4_WMENA_Msk = 0x4
	// Bit WMENA.
	FlexSPI_FLSHCR4_WMENA = 0x4
	// Write mask is disabled, DQS(RWDS) pin will be un-driven when writing to external device.
	FlexSPI_FLSHCR4_WMENA_WMENA_0 = 0x0
	// Write mask is enabled, DQS(RWDS) pin will be driven by FlexSPI as write mask output when writing to external device.
	FlexSPI_FLSHCR4_WMENA_WMENA_1 = 0x1
	// Position of WMENB field.
	FlexSPI_FLSHCR4_WMENB_Pos = 0x3
	// Bit mask of WMENB field.
	FlexSPI_FLSHCR4_WMENB_Msk = 0x8
	// Bit WMENB.
	FlexSPI_FLSHCR4_WMENB = 0x8
	// Write mask is disabled, DQS(RWDS) pin will be un-driven when writing to external device.
	FlexSPI_FLSHCR4_WMENB_WMENB_0 = 0x0
	// Write mask is enabled, DQS(RWDS) pin will be driven by FlexSPI as write mask output when writing to external device.
	FlexSPI_FLSHCR4_WMENB_WMENB_1 = 0x1

	// IPCR0: IP Control Register 0
	// Position of SFAR field.
	FlexSPI_IPCR0_SFAR_Pos = 0x0
	// Bit mask of SFAR field.
	FlexSPI_IPCR0_SFAR_Msk = 0xffffffff

	// IPCR1: IP Control Register 1
	// Position of IDATSZ field.
	FlexSPI_IPCR1_IDATSZ_Pos = 0x0
	// Bit mask of IDATSZ field.
	FlexSPI_IPCR1_IDATSZ_Msk = 0xffff
	// Position of ISEQID field.
	FlexSPI_IPCR1_ISEQID_Pos = 0x10
	// Bit mask of ISEQID field.
	FlexSPI_IPCR1_ISEQID_Msk = 0xf0000
	// Position of ISEQNUM field.
	FlexSPI_IPCR1_ISEQNUM_Pos = 0x18
	// Bit mask of ISEQNUM field.
	FlexSPI_IPCR1_ISEQNUM_Msk = 0x7000000
	// Position of IPAREN field.
	FlexSPI_IPCR1_IPAREN_Pos = 0x1f
	// Bit mask of IPAREN field.
	FlexSPI_IPCR1_IPAREN_Msk = 0x80000000
	// Bit IPAREN.
	FlexSPI_IPCR1_IPAREN = 0x80000000
	// Flash will be accessed in Individual mode.
	FlexSPI_IPCR1_IPAREN_IPAREN_0 = 0x0
	// Flash will be accessed in Parallel mode.
	FlexSPI_IPCR1_IPAREN_IPAREN_1 = 0x1

	// IPCMD: IP Command Register
	// Position of TRG field.
	FlexSPI_IPCMD_TRG_Pos = 0x0
	// Bit mask of TRG field.
	FlexSPI_IPCMD_TRG_Msk = 0x1
	// Bit TRG.
	FlexSPI_IPCMD_TRG = 0x1

	// IPRXFCR: IP RX FIFO Control Register
	// Position of CLRIPRXF field.
	FlexSPI_IPRXFCR_CLRIPRXF_Pos = 0x0
	// Bit mask of CLRIPRXF field.
	FlexSPI_IPRXFCR_CLRIPRXF_Msk = 0x1
	// Bit CLRIPRXF.
	FlexSPI_IPRXFCR_CLRIPRXF = 0x1
	// Position of RXDMAEN field.
	FlexSPI_IPRXFCR_RXDMAEN_Pos = 0x1
	// Bit mask of RXDMAEN field.
	FlexSPI_IPRXFCR_RXDMAEN_Msk = 0x2
	// Bit RXDMAEN.
	FlexSPI_IPRXFCR_RXDMAEN = 0x2
	// IP RX FIFO would be read by processor.
	FlexSPI_IPRXFCR_RXDMAEN_RXDMAEN_0 = 0x0
	// IP RX FIFO would be read by DMA.
	FlexSPI_IPRXFCR_RXDMAEN_RXDMAEN_1 = 0x1
	// Position of RXWMRK field.
	FlexSPI_IPRXFCR_RXWMRK_Pos = 0x2
	// Bit mask of RXWMRK field.
	FlexSPI_IPRXFCR_RXWMRK_Msk = 0x3c

	// IPTXFCR: IP TX FIFO Control Register
	// Position of CLRIPTXF field.
	FlexSPI_IPTXFCR_CLRIPTXF_Pos = 0x0
	// Bit mask of CLRIPTXF field.
	FlexSPI_IPTXFCR_CLRIPTXF_Msk = 0x1
	// Bit CLRIPTXF.
	FlexSPI_IPTXFCR_CLRIPTXF = 0x1
	// Position of TXDMAEN field.
	FlexSPI_IPTXFCR_TXDMAEN_Pos = 0x1
	// Bit mask of TXDMAEN field.
	FlexSPI_IPTXFCR_TXDMAEN_Msk = 0x2
	// Bit TXDMAEN.
	FlexSPI_IPTXFCR_TXDMAEN = 0x2
	// IP TX FIFO would be filled by processor.
	FlexSPI_IPTXFCR_TXDMAEN_TXDMAEN_0 = 0x0
	// IP TX FIFO would be filled by DMA.
	FlexSPI_IPTXFCR_TXDMAEN_TXDMAEN_1 = 0x1
	// Position of TXWMRK field.
	FlexSPI_IPTXFCR_TXWMRK_Pos = 0x2
	// Bit mask of TXWMRK field.
	FlexSPI_IPTXFCR_TXWMRK_Msk = 0x3c

	// DLLCRA: DLL Control Register 0
	// Position of DLLEN field.
	FlexSPI_DLLCR_DLLEN_Pos = 0x0
	// Bit mask of DLLEN field.
	FlexSPI_DLLCR_DLLEN_Msk = 0x1
	// Bit DLLEN.
	FlexSPI_DLLCR_DLLEN = 0x1
	// Position of DLLRESET field.
	FlexSPI_DLLCR_DLLRESET_Pos = 0x1
	// Bit mask of DLLRESET field.
	FlexSPI_DLLCR_DLLRESET_Msk = 0x2
	// Bit DLLRESET.
	FlexSPI_DLLCR_DLLRESET = 0x2
	// Position of SLVDLYTARGET field.
	FlexSPI_DLLCR_SLVDLYTARGET_Pos = 0x3
	// Bit mask of SLVDLYTARGET field.
	FlexSPI_DLLCR_SLVDLYTARGET_Msk = 0x78
	// Position of OVRDEN field.
	FlexSPI_DLLCR_OVRDEN_Pos = 0x8
	// Bit mask of OVRDEN field.
	FlexSPI_DLLCR_OVRDEN_Msk = 0x100
	// Bit OVRDEN.
	FlexSPI_DLLCR_OVRDEN = 0x100
	// Position of OVRDVAL field.
	FlexSPI_DLLCR_OVRDVAL_Pos = 0x9
	// Bit mask of OVRDVAL field.
	FlexSPI_DLLCR_OVRDVAL_Msk = 0x7e00

	// STS0: Status Register 0
	// Position of SEQIDLE field.
	FlexSPI_STS0_SEQIDLE_Pos = 0x0
	// Bit mask of SEQIDLE field.
	FlexSPI_STS0_SEQIDLE_Msk = 0x1
	// Bit SEQIDLE.
	FlexSPI_STS0_SEQIDLE = 0x1
	// Position of ARBIDLE field.
	FlexSPI_STS0_ARBIDLE_Pos = 0x1
	// Bit mask of ARBIDLE field.
	FlexSPI_STS0_ARBIDLE_Msk = 0x2
	// Bit ARBIDLE.
	FlexSPI_STS0_ARBIDLE = 0x2
	// Position of ARBCMDSRC field.
	FlexSPI_STS0_ARBCMDSRC_Pos = 0x2
	// Bit mask of ARBCMDSRC field.
	FlexSPI_STS0_ARBCMDSRC_Msk = 0xc
	// Triggered by AHB read command (triggered by AHB read).
	FlexSPI_STS0_ARBCMDSRC_ARBCMDSRC_0 = 0x0
	// Triggered by AHB write command (triggered by AHB Write).
	FlexSPI_STS0_ARBCMDSRC_ARBCMDSRC_1 = 0x1
	// Triggered by IP command (triggered by setting register bit IPCMD.TRG).
	FlexSPI_STS0_ARBCMDSRC_ARBCMDSRC_2 = 0x2
	// Triggered by suspended command (resumed).
	FlexSPI_STS0_ARBCMDSRC_ARBCMDSRC_3 = 0x3

	// STS1: Status Register 1
	// Position of AHBCMDERRID field.
	FlexSPI_STS1_AHBCMDERRID_Pos = 0x0
	// Bit mask of AHBCMDERRID field.
	FlexSPI_STS1_AHBCMDERRID_Msk = 0xf
	// Position of AHBCMDERRCODE field.
	FlexSPI_STS1_AHBCMDERRCODE_Pos = 0x8
	// Bit mask of AHBCMDERRCODE field.
	FlexSPI_STS1_AHBCMDERRCODE_Msk = 0xf00
	// No error.
	FlexSPI_STS1_AHBCMDERRCODE_AHBCMDERRCODE_0 = 0x0
	// AHB Write command with JMP_ON_CS instruction used in the sequence.
	FlexSPI_STS1_AHBCMDERRCODE_AHBCMDERRCODE_2 = 0x2
	// There is unknown instruction opcode in the sequence.
	FlexSPI_STS1_AHBCMDERRCODE_AHBCMDERRCODE_3 = 0x3
	// Instruction DUMMY_SDR/DUMMY_RWDS_SDR used in DDR sequence.
	FlexSPI_STS1_AHBCMDERRCODE_AHBCMDERRCODE_4 = 0x4
	// Instruction DUMMY_DDR/DUMMY_RWDS_DDR used in SDR sequence.
	FlexSPI_STS1_AHBCMDERRCODE_AHBCMDERRCODE_5 = 0x5
	// Sequence execution timeout.
	FlexSPI_STS1_AHBCMDERRCODE_AHBCMDERRCODE_14 = 0xe
	// Position of IPCMDERRID field.
	FlexSPI_STS1_IPCMDERRID_Pos = 0x10
	// Bit mask of IPCMDERRID field.
	FlexSPI_STS1_IPCMDERRID_Msk = 0xf0000
	// Position of IPCMDERRCODE field.
	FlexSPI_STS1_IPCMDERRCODE_Pos = 0x18
	// Bit mask of IPCMDERRCODE field.
	FlexSPI_STS1_IPCMDERRCODE_Msk = 0xf000000
	// No error.
	FlexSPI_STS1_IPCMDERRCODE_IPCMDERRCODE_0 = 0x0
	// IP command with JMP_ON_CS instruction used in the sequence.
	FlexSPI_STS1_IPCMDERRCODE_IPCMDERRCODE_2 = 0x2
	// There is unknown instruction opcode in the sequence.
	FlexSPI_STS1_IPCMDERRCODE_IPCMDERRCODE_3 = 0x3
	// Instruction DUMMY_SDR/DUMMY_RWDS_SDR used in DDR sequence.
	FlexSPI_STS1_IPCMDERRCODE_IPCMDERRCODE_4 = 0x4
	// Instruction DUMMY_DDR/DUMMY_RWDS_DDR used in SDR sequence.
	FlexSPI_STS1_IPCMDERRCODE_IPCMDERRCODE_5 = 0x5
	// Flash access start address exceed the whole flash address range (A1/A2/B1/B2).
	FlexSPI_STS1_IPCMDERRCODE_IPCMDERRCODE_6 = 0x6
	// Sequence execution timeout.
	FlexSPI_STS1_IPCMDERRCODE_IPCMDERRCODE_14 = 0xe
	// Flash boundary crossed.
	FlexSPI_STS1_IPCMDERRCODE_IPCMDERRCODE_15 = 0xf

	// STS2: Status Register 2
	// Position of ASLVLOCK field.
	FlexSPI_STS2_ASLVLOCK_Pos = 0x0
	// Bit mask of ASLVLOCK field.
	FlexSPI_STS2_ASLVLOCK_Msk = 0x1
	// Bit ASLVLOCK.
	FlexSPI_STS2_ASLVLOCK = 0x1
	// Position of AREFLOCK field.
	FlexSPI_STS2_AREFLOCK_Pos = 0x1
	// Bit mask of AREFLOCK field.
	FlexSPI_STS2_AREFLOCK_Msk = 0x2
	// Bit AREFLOCK.
	FlexSPI_STS2_AREFLOCK = 0x2
	// Position of ASLVSEL field.
	FlexSPI_STS2_ASLVSEL_Pos = 0x2
	// Bit mask of ASLVSEL field.
	FlexSPI_STS2_ASLVSEL_Msk = 0xfc
	// Position of AREFSEL field.
	FlexSPI_STS2_AREFSEL_Pos = 0x8
	// Bit mask of AREFSEL field.
	FlexSPI_STS2_AREFSEL_Msk = 0x3f00
	// Position of BSLVLOCK field.
	FlexSPI_STS2_BSLVLOCK_Pos = 0x10
	// Bit mask of BSLVLOCK field.
	FlexSPI_STS2_BSLVLOCK_Msk = 0x10000
	// Bit BSLVLOCK.
	FlexSPI_STS2_BSLVLOCK = 0x10000
	// Position of BREFLOCK field.
	FlexSPI_STS2_BREFLOCK_Pos = 0x11
	// Bit mask of BREFLOCK field.
	FlexSPI_STS2_BREFLOCK_Msk = 0x20000
	// Bit BREFLOCK.
	FlexSPI_STS2_BREFLOCK = 0x20000
	// Position of BSLVSEL field.
	FlexSPI_STS2_BSLVSEL_Pos = 0x12
	// Bit mask of BSLVSEL field.
	FlexSPI_STS2_BSLVSEL_Msk = 0xfc0000
	// Position of BREFSEL field.
	FlexSPI_STS2_BREFSEL_Pos = 0x18
	// Bit mask of BREFSEL field.
	FlexSPI_STS2_BREFSEL_Msk = 0x3f000000

	// AHBSPNDSTS: AHB Suspend Status Register
	// Position of ACTIVE field.
	FlexSPI_AHBSPNDSTS_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	FlexSPI_AHBSPNDSTS_ACTIVE_Msk = 0x1
	// Bit ACTIVE.
	FlexSPI_AHBSPNDSTS_ACTIVE = 0x1
	// Position of BUFID field.
	FlexSPI_AHBSPNDSTS_BUFID_Pos = 0x1
	// Bit mask of BUFID field.
	FlexSPI_AHBSPNDSTS_BUFID_Msk = 0xe
	// Position of DATLFT field.
	FlexSPI_AHBSPNDSTS_DATLFT_Pos = 0x10
	// Bit mask of DATLFT field.
	FlexSPI_AHBSPNDSTS_DATLFT_Msk = 0xffff0000

	// IPRXFSTS: IP RX FIFO Status Register
	// Position of FILL field.
	FlexSPI_IPRXFSTS_FILL_Pos = 0x0
	// Bit mask of FILL field.
	FlexSPI_IPRXFSTS_FILL_Msk = 0xff
	// Position of RDCNTR field.
	FlexSPI_IPRXFSTS_RDCNTR_Pos = 0x10
	// Bit mask of RDCNTR field.
	FlexSPI_IPRXFSTS_RDCNTR_Msk = 0xffff0000

	// IPTXFSTS: IP TX FIFO Status Register
	// Position of FILL field.
	FlexSPI_IPTXFSTS_FILL_Pos = 0x0
	// Bit mask of FILL field.
	FlexSPI_IPTXFSTS_FILL_Msk = 0xff
	// Position of WRCNTR field.
	FlexSPI_IPTXFSTS_WRCNTR_Pos = 0x10
	// Bit mask of WRCNTR field.
	FlexSPI_IPTXFSTS_WRCNTR_Msk = 0xffff0000

	// RFDR: IP RX FIFO Data Register 0
	// Position of RXDATA field.
	FlexSPI_RFDR_RXDATA_Pos = 0x0
	// Bit mask of RXDATA field.
	FlexSPI_RFDR_RXDATA_Msk = 0xffffffff

	// TFDR: IP TX FIFO Data Register 0
	// Position of TXDATA field.
	FlexSPI_TFDR_TXDATA_Pos = 0x0
	// Bit mask of TXDATA field.
	FlexSPI_TFDR_TXDATA_Msk = 0xffffffff

	// LUT: LUT 0
	// Position of OPERAND0 field.
	FlexSPI_LUT_OPERAND0_Pos = 0x0
	// Bit mask of OPERAND0 field.
	FlexSPI_LUT_OPERAND0_Msk = 0xff
	// Position of NUM_PADS0 field.
	FlexSPI_LUT_NUM_PADS0_Pos = 0x8
	// Bit mask of NUM_PADS0 field.
	FlexSPI_LUT_NUM_PADS0_Msk = 0x300
	// Position of OPCODE0 field.
	FlexSPI_LUT_OPCODE0_Pos = 0xa
	// Bit mask of OPCODE0 field.
	FlexSPI_LUT_OPCODE0_Msk = 0xfc00
	// Position of OPERAND1 field.
	FlexSPI_LUT_OPERAND1_Pos = 0x10
	// Bit mask of OPERAND1 field.
	FlexSPI_LUT_OPERAND1_Msk = 0xff0000
	// Position of NUM_PADS1 field.
	FlexSPI_LUT_NUM_PADS1_Pos = 0x18
	// Bit mask of NUM_PADS1 field.
	FlexSPI_LUT_NUM_PADS1_Msk = 0x3000000
	// Position of OPCODE1 field.
	FlexSPI_LUT_OPCODE1_Pos = 0x1a
	// Bit mask of OPCODE1 field.
	FlexSPI_LUT_OPCODE1_Msk = 0xfc000000
)

// Constants for OTFAD: OTFAD
const (
	// CR: Control Register
	// Position of IRQE field.
	OTFAD_CR_IRQE_Pos = 0x0
	// Bit mask of IRQE field.
	OTFAD_CR_IRQE_Msk = 0x1
	// Bit IRQE.
	OTFAD_CR_IRQE = 0x1
	// SR[KBERR] = 1 does not generate an interrupt request.
	OTFAD_CR_IRQE_IRQE_0 = 0x0
	// SR[KBERR] = 1 generates an interrupt request.
	OTFAD_CR_IRQE_IRQE_1 = 0x1
	// Position of FERR field.
	OTFAD_CR_FERR_Pos = 0x1
	// Bit mask of FERR field.
	OTFAD_CR_FERR_Msk = 0x2
	// Bit FERR.
	OTFAD_CR_FERR = 0x2
	// No effect on the SR[KBERE] indicator.
	OTFAD_CR_FERR_FERR_0 = 0x0
	// SR[KBERR] is immediately set after a write with this data bit set.
	OTFAD_CR_FERR_FERR_1 = 0x1
	// Position of FSVM field.
	OTFAD_CR_FSVM_Pos = 0x2
	// Bit mask of FSVM field.
	OTFAD_CR_FSVM_Msk = 0x4
	// Bit FSVM.
	OTFAD_CR_FSVM = 0x4
	// No effect on the operating mode.
	OTFAD_CR_FSVM_FSVM_0 = 0x0
	// Force entry into SVM after a write with this data bit set and the data bit associated with FLDM cleared. SR[MODE] signals the operating mode.
	OTFAD_CR_FSVM_FSVM_1 = 0x1
	// Position of FLDM field.
	OTFAD_CR_FLDM_Pos = 0x3
	// Bit mask of FLDM field.
	OTFAD_CR_FLDM_Msk = 0x8
	// Bit FLDM.
	OTFAD_CR_FLDM = 0x8
	// No effect on the operating mode.
	OTFAD_CR_FLDM_FLDM_0 = 0x0
	// Force entry into LDM after a write with this data bit set. SR[MODE] signals the operating mode.
	OTFAD_CR_FLDM_FLDM_1 = 0x1
	// Position of KBSE field.
	OTFAD_CR_KBSE_Pos = 0x4
	// Bit mask of KBSE field.
	OTFAD_CR_KBSE_Msk = 0x10
	// Bit KBSE.
	OTFAD_CR_KBSE = 0x10
	// Key blob KEK scrambling is disabled.
	OTFAD_CR_KBSE_KBSE_0 = 0x0
	// Key blob KEK scrambling is enabled.
	OTFAD_CR_KBSE_KBSE_1 = 0x1
	// Position of KBPE field.
	OTFAD_CR_KBPE_Pos = 0x5
	// Bit mask of KBPE field.
	OTFAD_CR_KBPE_Msk = 0x20
	// Bit KBPE.
	OTFAD_CR_KBPE = 0x20
	// Key blob processing is disabled.
	OTFAD_CR_KBPE_KBPE_0 = 0x0
	// Key blob processing is enabled.
	OTFAD_CR_KBPE_KBPE_1 = 0x1
	// Position of KBCE field.
	OTFAD_CR_KBCE_Pos = 0x6
	// Bit mask of KBCE field.
	OTFAD_CR_KBCE_Msk = 0x40
	// Bit KBCE.
	OTFAD_CR_KBCE = 0x40
	// CRC-32 during key blob processing is disabled.
	OTFAD_CR_KBCE_KBCE_0 = 0x0
	// CRC-32 during key blob processing is enabled.
	OTFAD_CR_KBCE_KBCE_1 = 0x1
	// Position of RRAE field.
	OTFAD_CR_RRAE_Pos = 0x7
	// Bit mask of RRAE field.
	OTFAD_CR_RRAE_Msk = 0x80
	// Bit RRAE.
	OTFAD_CR_RRAE = 0x80
	// Register access is fully enabled. The OTFAD programming model registers can be accessed "normally".
	OTFAD_CR_RRAE_RRAE_0 = 0x0
	// Register access is restricted and only the CR, SR and optional MDPC registers can be accessed; others are treated as RAZ/WI.
	OTFAD_CR_RRAE_RRAE_1 = 0x1
	// Position of SKBP field.
	OTFAD_CR_SKBP_Pos = 0x1e
	// Bit mask of SKBP field.
	OTFAD_CR_SKBP_Msk = 0x40000000
	// Bit SKBP.
	OTFAD_CR_SKBP = 0x40000000
	// Key blob processing is not initiated.
	OTFAD_CR_SKBP_SKBP_0 = 0x0
	// Properly-enabled key blob processing is initiated.
	OTFAD_CR_SKBP_SKBP_1 = 0x1
	// Position of GE field.
	OTFAD_CR_GE_Pos = 0x1f
	// Bit mask of GE field.
	OTFAD_CR_GE_Msk = 0x80000000
	// Bit GE.
	OTFAD_CR_GE = 0x80000000
	// OTFAD has decryption disabled. All data fetched by the FlexSPI bypasses OTFAD processing.
	OTFAD_CR_GE_GE_0 = 0x0
	// OTFAD has decryption enabled, and processes data fetched by the FlexSPI as defined by the hardware configuration.
	OTFAD_CR_GE_GE_1 = 0x1

	// SR: Status Register
	// Position of KBERR field.
	OTFAD_SR_KBERR_Pos = 0x0
	// Bit mask of KBERR field.
	OTFAD_SR_KBERR_Msk = 0x1
	// Bit KBERR.
	OTFAD_SR_KBERR = 0x1
	// No key blob error detected.
	OTFAD_SR_KBERR_KBERR_0 = 0x0
	// One or more key blob errors has been detected.
	OTFAD_SR_KBERR_KBERR_1 = 0x1
	// Position of MDPCP field.
	OTFAD_SR_MDPCP_Pos = 0x1
	// Bit mask of MDPCP field.
	OTFAD_SR_MDPCP_Msk = 0x2
	// Bit MDPCP.
	OTFAD_SR_MDPCP = 0x2
	// Position of MODE field.
	OTFAD_SR_MODE_Pos = 0x2
	// Bit mask of MODE field.
	OTFAD_SR_MODE_Msk = 0xc
	// Operating in Normal mode (NRM)
	OTFAD_SR_MODE_MODE_0 = 0x0
	// Unused (reserved)
	OTFAD_SR_MODE_MODE_1 = 0x1
	// Operating in Security Violation Mode (SVM)
	OTFAD_SR_MODE_MODE_2 = 0x2
	// Operating in Logically Disabled Mode (LDM)
	OTFAD_SR_MODE_MODE_3 = 0x3
	// Position of NCTX field.
	OTFAD_SR_NCTX_Pos = 0x4
	// Bit mask of NCTX field.
	OTFAD_SR_NCTX_Msk = 0xf0
	// Position of CTXER0 field.
	OTFAD_SR_CTXER0_Pos = 0x8
	// Bit mask of CTXER0 field.
	OTFAD_SR_CTXER0_Msk = 0x100
	// Bit CTXER0.
	OTFAD_SR_CTXER0 = 0x100
	// No key blob error was detected for context "n".
	OTFAD_SR_CTXER0_NOERROR = 0x0
	// Either a key blob integrity error or a key blob CRC error was detected in context "n".
	OTFAD_SR_CTXER0_ERROR = 0x1
	// Position of CTXER1 field.
	OTFAD_SR_CTXER1_Pos = 0x9
	// Bit mask of CTXER1 field.
	OTFAD_SR_CTXER1_Msk = 0x200
	// Bit CTXER1.
	OTFAD_SR_CTXER1 = 0x200
	// No key blob error was detected for context "n".
	OTFAD_SR_CTXER1_NOERROR = 0x0
	// Either a key blob integrity error or a key blob CRC error was detected in context "n".
	OTFAD_SR_CTXER1_ERROR = 0x1
	// Position of CTXER2 field.
	OTFAD_SR_CTXER2_Pos = 0xa
	// Bit mask of CTXER2 field.
	OTFAD_SR_CTXER2_Msk = 0x400
	// Bit CTXER2.
	OTFAD_SR_CTXER2 = 0x400
	// No key blob error was detected for context "n".
	OTFAD_SR_CTXER2_NOERROR = 0x0
	// Either a key blob integrity error or a key blob CRC error was detected in context "n".
	OTFAD_SR_CTXER2_ERROR = 0x1
	// Position of CTXER3 field.
	OTFAD_SR_CTXER3_Pos = 0xb
	// Bit mask of CTXER3 field.
	OTFAD_SR_CTXER3_Msk = 0x800
	// Bit CTXER3.
	OTFAD_SR_CTXER3 = 0x800
	// No key blob error was detected for context "n".
	OTFAD_SR_CTXER3_NOERROR = 0x0
	// Either a key blob integrity error or a key blob CRC error was detected in context "n".
	OTFAD_SR_CTXER3_ERROR = 0x1
	// Position of CTXIE0 field.
	OTFAD_SR_CTXIE0_Pos = 0x10
	// Bit mask of CTXIE0 field.
	OTFAD_SR_CTXIE0_Msk = 0x10000
	// Bit CTXIE0.
	OTFAD_SR_CTXIE0 = 0x10000
	// No key blob integrity error was detected for context "n".
	OTFAD_SR_CTXIE0_NOINTEGRITYERR = 0x0
	// A key blob integrity error was detected in context "n".
	OTFAD_SR_CTXIE0_INTEGRITYERR = 0x1
	// Position of CTXIE1 field.
	OTFAD_SR_CTXIE1_Pos = 0x11
	// Bit mask of CTXIE1 field.
	OTFAD_SR_CTXIE1_Msk = 0x20000
	// Bit CTXIE1.
	OTFAD_SR_CTXIE1 = 0x20000
	// No key blob integrity error was detected for context "n".
	OTFAD_SR_CTXIE1_NOINTEGRITYERR = 0x0
	// A key blob integrity error was detected in context "n".
	OTFAD_SR_CTXIE1_INTEGRITYERR = 0x1
	// Position of CTXIE2 field.
	OTFAD_SR_CTXIE2_Pos = 0x12
	// Bit mask of CTXIE2 field.
	OTFAD_SR_CTXIE2_Msk = 0x40000
	// Bit CTXIE2.
	OTFAD_SR_CTXIE2 = 0x40000
	// No key blob integrity error was detected for context "n".
	OTFAD_SR_CTXIE2_NOINTEGRITYERR = 0x0
	// A key blob integrity error was detected in context "n".
	OTFAD_SR_CTXIE2_INTEGRITYERR = 0x1
	// Position of CTXIE3 field.
	OTFAD_SR_CTXIE3_Pos = 0x13
	// Bit mask of CTXIE3 field.
	OTFAD_SR_CTXIE3_Msk = 0x80000
	// Bit CTXIE3.
	OTFAD_SR_CTXIE3 = 0x80000
	// No key blob integrity error was detected for context "n".
	OTFAD_SR_CTXIE3_NOINTEGRITYERR = 0x0
	// A key blob integrity error was detected in context "n".
	OTFAD_SR_CTXIE3_INTEGRITYERR = 0x1
	// Position of HRL field.
	OTFAD_SR_HRL_Pos = 0x18
	// Bit mask of HRL field.
	OTFAD_SR_HRL_Msk = 0xf000000
	// Position of RRAM field.
	OTFAD_SR_RRAM_Pos = 0x1c
	// Bit mask of RRAM field.
	OTFAD_SR_RRAM_Msk = 0x10000000
	// Bit RRAM.
	OTFAD_SR_RRAM = 0x10000000
	// Register access is fully enabled. The OTFAD programming model registers can be accessed "normally".
	OTFAD_SR_RRAM_RRAM_0 = 0x0
	// Register access is restricted and only the CR, SR and optional MDPC registers can be accessed; others are treated as RAZ/WI.
	OTFAD_SR_RRAM_RRAM_1 = 0x1
	// Position of GEM field.
	OTFAD_SR_GEM_Pos = 0x1d
	// Bit mask of GEM field.
	OTFAD_SR_GEM_Msk = 0x20000000
	// Bit GEM.
	OTFAD_SR_GEM = 0x20000000
	// OTFAD is disabled. All data fetched by the FlexSPI bypasses OTFAD processing.
	OTFAD_SR_GEM_GEM_0 = 0x0
	// OTFAD is enabled, and processes data fetched by the FlexSPI as defined by the hardware configuration.
	OTFAD_SR_GEM_GEM_1 = 0x1
	// Position of KBPE field.
	OTFAD_SR_KBPE_Pos = 0x1e
	// Bit mask of KBPE field.
	OTFAD_SR_KBPE_Msk = 0x40000000
	// Bit KBPE.
	OTFAD_SR_KBPE = 0x40000000
	// Key blob processing is not enabled.
	OTFAD_SR_KBPE_KBPE_0 = 0x0
	// Key blob processing is enabled.
	OTFAD_SR_KBPE_KBPE_1 = 0x1
	// Position of KBD field.
	OTFAD_SR_KBD_Pos = 0x1f
	// Bit mask of KBD field.
	OTFAD_SR_KBD_Msk = 0x80000000
	// Bit KBD.
	OTFAD_SR_KBD = 0x80000000
	// Key blob processing was not enabled, or is not complete.
	OTFAD_SR_KBD_KBD_0 = 0x0
	// Key blob processing was enabled and is complete.
	OTFAD_SR_KBD_KBD_1 = 0x1

	// CTX.CTX_KEY0: AES Key Word
	// Position of KEY field.
	OTFAD_CTX_CTX_KEY_KEY_Pos = 0x0
	// Bit mask of KEY field.
	OTFAD_CTX_CTX_KEY_KEY_Msk = 0xffffffff

	// CTX.CTX_KEY1: AES Key Word

	// CTX.CTX_KEY2: AES Key Word

	// CTX.CTX_KEY3: AES Key Word

	// CTX.CTX_CTR0: AES Counter Word
	// Position of CTR field.
	OTFAD_CTX_CTX_CTR_CTR_Pos = 0x0
	// Bit mask of CTR field.
	OTFAD_CTX_CTX_CTR_CTR_Msk = 0xffffffff

	// CTX.CTX_CTR1: AES Counter Word

	// CTX.CTX_RGD_W0: AES Region Descriptor Word0
	// Position of SRTADDR field.
	OTFAD_CTX_CTX_RGD_W0_SRTADDR_Pos = 0xa
	// Bit mask of SRTADDR field.
	OTFAD_CTX_CTX_RGD_W0_SRTADDR_Msk = 0xfffffc00

	// CTX.CTX_RGD_W1: AES Region Descriptor Word1
	// Position of VLD field.
	OTFAD_CTX_CTX_RGD_W1_VLD_Pos = 0x0
	// Bit mask of VLD field.
	OTFAD_CTX_CTX_RGD_W1_VLD_Msk = 0x1
	// Bit VLD.
	OTFAD_CTX_CTX_RGD_W1_VLD = 0x1
	// Context is invalid.
	OTFAD_CTX_CTX_RGD_W1_VLD_VLD_0 = 0x0
	// Context is valid.
	OTFAD_CTX_CTX_RGD_W1_VLD_VLD_1 = 0x1
	// Position of ADE field.
	OTFAD_CTX_CTX_RGD_W1_ADE_Pos = 0x1
	// Bit mask of ADE field.
	OTFAD_CTX_CTX_RGD_W1_ADE_Msk = 0x2
	// Bit ADE.
	OTFAD_CTX_CTX_RGD_W1_ADE = 0x2
	// Bypass the fetched data.
	OTFAD_CTX_CTX_RGD_W1_ADE_ADE_0 = 0x0
	// Perform the CTR-AES128 mode decryption on the fetched data.
	OTFAD_CTX_CTX_RGD_W1_ADE_ADE_1 = 0x1
	// Position of RO field.
	OTFAD_CTX_CTX_RGD_W1_RO_Pos = 0x2
	// Bit mask of RO field.
	OTFAD_CTX_CTX_RGD_W1_RO_Msk = 0x4
	// Bit RO.
	OTFAD_CTX_CTX_RGD_W1_RO = 0x4
	// The context registers can be accessed normally (as defined by SR[RRAM]).
	OTFAD_CTX_CTX_RGD_W1_RO_RO_0 = 0x0
	// The context registers are read-only and accesses may be further restricted based on SR[RRAM].
	OTFAD_CTX_CTX_RGD_W1_RO_RO_1 = 0x1
	// Position of ENDADDR field.
	OTFAD_CTX_CTX_RGD_W1_ENDADDR_Pos = 0xa
	// Bit mask of ENDADDR field.
	OTFAD_CTX_CTX_RGD_W1_ENDADDR_Msk = 0xfffffc00
)

// Constants for IOMUXC_SNVS_GPR: IOMUXC
const (
	// GPR3: GPR3 General Purpose Register
	// Position of LPSR_MODE_ENABLE field.
	IOMUXC_SNVS_GPR_GPR3_LPSR_MODE_ENABLE_Pos = 0x0
	// Bit mask of LPSR_MODE_ENABLE field.
	IOMUXC_SNVS_GPR_GPR3_LPSR_MODE_ENABLE_Msk = 0x1
	// Bit LPSR_MODE_ENABLE.
	IOMUXC_SNVS_GPR_GPR3_LPSR_MODE_ENABLE = 0x1
	// Position of DCDC_STATUS_CAPT_CLR field.
	IOMUXC_SNVS_GPR_GPR3_DCDC_STATUS_CAPT_CLR_Pos = 0x1
	// Bit mask of DCDC_STATUS_CAPT_CLR field.
	IOMUXC_SNVS_GPR_GPR3_DCDC_STATUS_CAPT_CLR_Msk = 0x2
	// Bit DCDC_STATUS_CAPT_CLR.
	IOMUXC_SNVS_GPR_GPR3_DCDC_STATUS_CAPT_CLR = 0x2
	// Position of POR_PULL_TYPE field.
	IOMUXC_SNVS_GPR_GPR3_POR_PULL_TYPE_Pos = 0x2
	// Bit mask of POR_PULL_TYPE field.
	IOMUXC_SNVS_GPR_GPR3_POR_PULL_TYPE_Msk = 0xc
	// Position of DCDC_IN_LOW_VOL field.
	IOMUXC_SNVS_GPR_GPR3_DCDC_IN_LOW_VOL_Pos = 0x10
	// Bit mask of DCDC_IN_LOW_VOL field.
	IOMUXC_SNVS_GPR_GPR3_DCDC_IN_LOW_VOL_Msk = 0x10000
	// Bit DCDC_IN_LOW_VOL.
	IOMUXC_SNVS_GPR_GPR3_DCDC_IN_LOW_VOL = 0x10000
	// Position of DCDC_OVER_CUR field.
	IOMUXC_SNVS_GPR_GPR3_DCDC_OVER_CUR_Pos = 0x11
	// Bit mask of DCDC_OVER_CUR field.
	IOMUXC_SNVS_GPR_GPR3_DCDC_OVER_CUR_Msk = 0x20000
	// Bit DCDC_OVER_CUR.
	IOMUXC_SNVS_GPR_GPR3_DCDC_OVER_CUR = 0x20000
	// Position of DCDC_OVER_VOL field.
	IOMUXC_SNVS_GPR_GPR3_DCDC_OVER_VOL_Pos = 0x12
	// Bit mask of DCDC_OVER_VOL field.
	IOMUXC_SNVS_GPR_GPR3_DCDC_OVER_VOL_Msk = 0x40000
	// Bit DCDC_OVER_VOL.
	IOMUXC_SNVS_GPR_GPR3_DCDC_OVER_VOL = 0x40000
	// Position of DCDC_STS_DC_OK field.
	IOMUXC_SNVS_GPR_GPR3_DCDC_STS_DC_OK_Pos = 0x13
	// Bit mask of DCDC_STS_DC_OK field.
	IOMUXC_SNVS_GPR_GPR3_DCDC_STS_DC_OK_Msk = 0x80000
	// Bit DCDC_STS_DC_OK.
	IOMUXC_SNVS_GPR_GPR3_DCDC_STS_DC_OK = 0x80000
)

// Constants for IOMUXC_SNVS: IOMUXC_SNVS
const (
	// SW_MUX_CTL_PAD_PMIC_ON_REQ: SW_MUX_CTL_PAD_PMIC_ON_REQ SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_ON_REQ_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_ON_REQ_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: SNVS_LP_PMIC_ON_REQ of instance: snvs_lp
	IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_ON_REQ_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT5 mux port: GPIO5_IO00 of instance: gpio5
	IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_ON_REQ_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_ON_REQ_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_ON_REQ_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_ON_REQ_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_ON_REQ_SION_DISABLED = 0x0
	// Force input path of pad PMIC_ON_REQ
	IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_ON_REQ_SION_ENABLED = 0x1

	// SW_PAD_CTL_PAD_TEST_MODE: SW_PAD_CTL_PAD_TEST_MODE SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_SPEED_Msk = 0xc0
	// medium(100MHz)
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_SPEED_SPEED = 0x2
	// Position of ODE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PUE = 0x2000
	// Keeper
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_POR_B: SW_PAD_CTL_PAD_POR_B SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_SPEED_Msk = 0xc0
	// medium(100MHz)
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_SPEED_SPEED = 0x2
	// Position of ODE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PUE = 0x2000
	// Keeper
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_ONOFF: SW_PAD_CTL_PAD_ONOFF SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_SPEED_Msk = 0xc0
	// medium(100MHz)
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_SPEED_SPEED = 0x2
	// Position of ODE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PUE = 0x2000
	// Keeper
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_PMIC_ON_REQ: SW_PAD_CTL_PAD_PMIC_ON_REQ SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V)
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V = 0x1
	// R0/2
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_SPEED_Msk = 0xc0
	// medium(100MHz)
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_SPEED_SPEED = 0x2
	// Position of ODE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PUE = 0x2000
	// Keeper
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_HYS_HYS_1_Hysteresis_Enabled = 0x1
)

// Constants for IOMUXC_GPR: IOMUXC_GPR
const (
	// GPR1: GPR1 General Purpose Register
	// Position of SAI1_MCLK1_SEL field.
	IOMUXC_GPR_GPR1_SAI1_MCLK1_SEL_Pos = 0x0
	// Bit mask of SAI1_MCLK1_SEL field.
	IOMUXC_GPR_GPR1_SAI1_MCLK1_SEL_Msk = 0x7
	// ccm.ssi1_clk_root
	IOMUXC_GPR_GPR1_SAI1_MCLK1_SEL_SAI1_MCLK1_SEL_0 = 0x0
	// ccm.ssi3_clk_root
	IOMUXC_GPR_GPR1_SAI1_MCLK1_SEL_SAI1_MCLK1_SEL_2 = 0x2
	// iomux.sai1_ipg_clk_sai_mclk
	IOMUXC_GPR_GPR1_SAI1_MCLK1_SEL_SAI1_MCLK1_SEL_3 = 0x3
	// iomux.sai3_ipg_clk_sai_mclk
	IOMUXC_GPR_GPR1_SAI1_MCLK1_SEL_SAI1_MCLK1_SEL_5 = 0x5
	// Position of SAI1_MCLK2_SEL field.
	IOMUXC_GPR_GPR1_SAI1_MCLK2_SEL_Pos = 0x3
	// Bit mask of SAI1_MCLK2_SEL field.
	IOMUXC_GPR_GPR1_SAI1_MCLK2_SEL_Msk = 0x38
	// ccm.ssi1_clk_root
	IOMUXC_GPR_GPR1_SAI1_MCLK2_SEL_SAI1_MCLK2_SEL_0 = 0x0
	// ccm.ssi3_clk_root
	IOMUXC_GPR_GPR1_SAI1_MCLK2_SEL_SAI1_MCLK2_SEL_2 = 0x2
	// iomux.sai1_ipg_clk_sai_mclk
	IOMUXC_GPR_GPR1_SAI1_MCLK2_SEL_SAI1_MCLK2_SEL_3 = 0x3
	// iomux.sai3_ipg_clk_sai_mclk
	IOMUXC_GPR_GPR1_SAI1_MCLK2_SEL_SAI1_MCLK2_SEL_5 = 0x5
	// Position of SAI1_MCLK3_SEL field.
	IOMUXC_GPR_GPR1_SAI1_MCLK3_SEL_Pos = 0x6
	// Bit mask of SAI1_MCLK3_SEL field.
	IOMUXC_GPR_GPR1_SAI1_MCLK3_SEL_Msk = 0xc0
	// ccm.spdif0_clk_root
	IOMUXC_GPR_GPR1_SAI1_MCLK3_SEL_SAI1_MCLK3_SEL_0 = 0x0
	// SPDIF_EXT_CLK
	IOMUXC_GPR_GPR1_SAI1_MCLK3_SEL_SAI1_MCLK3_SEL_1 = 0x1
	// spdif.spdif_srclk
	IOMUXC_GPR_GPR1_SAI1_MCLK3_SEL_SAI1_MCLK3_SEL_2 = 0x2
	// spdif.spdif_outclock
	IOMUXC_GPR_GPR1_SAI1_MCLK3_SEL_SAI1_MCLK3_SEL_3 = 0x3
	// Position of SAI3_MCLK3_SEL field.
	IOMUXC_GPR_GPR1_SAI3_MCLK3_SEL_Pos = 0xa
	// Bit mask of SAI3_MCLK3_SEL field.
	IOMUXC_GPR_GPR1_SAI3_MCLK3_SEL_Msk = 0xc00
	// ccm.spdif0_clk_root
	IOMUXC_GPR_GPR1_SAI3_MCLK3_SEL_SAI3_MCLK3_SEL_0 = 0x0
	// SPDIF_EXT_CLK
	IOMUXC_GPR_GPR1_SAI3_MCLK3_SEL_SAI3_MCLK3_SEL_1 = 0x1
	// spdif.spdif_srclk
	IOMUXC_GPR_GPR1_SAI3_MCLK3_SEL_SAI3_MCLK3_SEL_2 = 0x2
	// spdif.spdif_outclock
	IOMUXC_GPR_GPR1_SAI3_MCLK3_SEL_SAI3_MCLK3_SEL_3 = 0x3
	// Position of GINT field.
	IOMUXC_GPR_GPR1_GINT_Pos = 0xc
	// Bit mask of GINT field.
	IOMUXC_GPR_GPR1_GINT_Msk = 0x1000
	// Bit GINT.
	IOMUXC_GPR_GPR1_GINT = 0x1000
	// Global interrupt request is not asserted.
	IOMUXC_GPR_GPR1_GINT_GINT_0 = 0x0
	// Global interrupt request is asserted.
	IOMUXC_GPR_GPR1_GINT_GINT_1 = 0x1
	// Position of SAI1_MCLK_DIR field.
	IOMUXC_GPR_GPR1_SAI1_MCLK_DIR_Pos = 0x13
	// Bit mask of SAI1_MCLK_DIR field.
	IOMUXC_GPR_GPR1_SAI1_MCLK_DIR_Msk = 0x80000
	// Bit SAI1_MCLK_DIR.
	IOMUXC_GPR_GPR1_SAI1_MCLK_DIR = 0x80000
	// sai1.MCLK is input signal
	IOMUXC_GPR_GPR1_SAI1_MCLK_DIR_SAI1_MCLK_DIR_0 = 0x0
	// sai1.MCLK is output signal
	IOMUXC_GPR_GPR1_SAI1_MCLK_DIR_SAI1_MCLK_DIR_1 = 0x1
	// Position of SAI3_MCLK_DIR field.
	IOMUXC_GPR_GPR1_SAI3_MCLK_DIR_Pos = 0x15
	// Bit mask of SAI3_MCLK_DIR field.
	IOMUXC_GPR_GPR1_SAI3_MCLK_DIR_Msk = 0x200000
	// Bit SAI3_MCLK_DIR.
	IOMUXC_GPR_GPR1_SAI3_MCLK_DIR = 0x200000
	// sai3.MCLK is input signal
	IOMUXC_GPR_GPR1_SAI3_MCLK_DIR_SAI3_MCLK_DIR_0 = 0x0
	// sai3.MCLK is output signal
	IOMUXC_GPR_GPR1_SAI3_MCLK_DIR_SAI3_MCLK_DIR_1 = 0x1
	// Position of EXC_MON field.
	IOMUXC_GPR_GPR1_EXC_MON_Pos = 0x16
	// Bit mask of EXC_MON field.
	IOMUXC_GPR_GPR1_EXC_MON_Msk = 0x400000
	// Bit EXC_MON.
	IOMUXC_GPR_GPR1_EXC_MON = 0x400000
	// OKAY response
	IOMUXC_GPR_GPR1_EXC_MON_EXC_MON_0 = 0x0
	// SLVError response
	IOMUXC_GPR_GPR1_EXC_MON_EXC_MON_1 = 0x1
	// Position of CM7_FORCE_HCLK_EN field.
	IOMUXC_GPR_GPR1_CM7_FORCE_HCLK_EN_Pos = 0x1f
	// Bit mask of CM7_FORCE_HCLK_EN field.
	IOMUXC_GPR_GPR1_CM7_FORCE_HCLK_EN_Msk = 0x80000000
	// Bit CM7_FORCE_HCLK_EN.
	IOMUXC_GPR_GPR1_CM7_FORCE_HCLK_EN = 0x80000000
	// AHB clock is not running (gated) when CM7 is sleeping and TCM is not accessible.
	IOMUXC_GPR_GPR1_CM7_FORCE_HCLK_EN_CM7_FORCE_HCLK_EN_0 = 0x0
	// AHB clock is running (enabled) when CM7 is sleeping and TCM is accessible.
	IOMUXC_GPR_GPR1_CM7_FORCE_HCLK_EN_CM7_FORCE_HCLK_EN_1 = 0x1

	// GPR2: GPR2 General Purpose Register
	// Position of AXBS_P_M0_HIGH_PRIORITY field.
	IOMUXC_GPR_GPR2_AXBS_P_M0_HIGH_PRIORITY_Pos = 0x3
	// Bit mask of AXBS_P_M0_HIGH_PRIORITY field.
	IOMUXC_GPR_GPR2_AXBS_P_M0_HIGH_PRIORITY_Msk = 0x8
	// Bit AXBS_P_M0_HIGH_PRIORITY.
	IOMUXC_GPR_GPR2_AXBS_P_M0_HIGH_PRIORITY = 0x8
	// AXBS_P M0 master doesn't have high priority
	IOMUXC_GPR_GPR2_AXBS_P_M0_HIGH_PRIORITY_AXBS_P_M0_HIGH_PRIORITY_0 = 0x0
	// AXBS_P M0 master has high priority
	IOMUXC_GPR_GPR2_AXBS_P_M0_HIGH_PRIORITY_AXBS_P_M0_HIGH_PRIORITY_1 = 0x1
	// Position of AXBS_P_M1_HIGH_PRIORITY field.
	IOMUXC_GPR_GPR2_AXBS_P_M1_HIGH_PRIORITY_Pos = 0x4
	// Bit mask of AXBS_P_M1_HIGH_PRIORITY field.
	IOMUXC_GPR_GPR2_AXBS_P_M1_HIGH_PRIORITY_Msk = 0x10
	// Bit AXBS_P_M1_HIGH_PRIORITY.
	IOMUXC_GPR_GPR2_AXBS_P_M1_HIGH_PRIORITY = 0x10
	// AXBS_P M1 master does not have high priority
	IOMUXC_GPR_GPR2_AXBS_P_M1_HIGH_PRIORITY_AXBS_P_M1_HIGH_PRIORITY_0 = 0x0
	// AXBS_P M1 master has high priority
	IOMUXC_GPR_GPR2_AXBS_P_M1_HIGH_PRIORITY_AXBS_P_M1_HIGH_PRIORITY_1 = 0x1
	// Position of AXBS_P_FORCE_ROUND_ROBIN field.
	IOMUXC_GPR_GPR2_AXBS_P_FORCE_ROUND_ROBIN_Pos = 0x5
	// Bit mask of AXBS_P_FORCE_ROUND_ROBIN field.
	IOMUXC_GPR_GPR2_AXBS_P_FORCE_ROUND_ROBIN_Msk = 0x20
	// Bit AXBS_P_FORCE_ROUND_ROBIN.
	IOMUXC_GPR_GPR2_AXBS_P_FORCE_ROUND_ROBIN = 0x20
	// AXBS_P masters are not arbitored in round robin, depending on M0/M1 master priority settings.
	IOMUXC_GPR_GPR2_AXBS_P_FORCE_ROUND_ROBIN_AXBS_P_FORCE_ROUND_ROBIN_0 = 0x0
	// AXBS_P masters are arbitored in round robin
	IOMUXC_GPR_GPR2_AXBS_P_FORCE_ROUND_ROBIN_AXBS_P_FORCE_ROUND_ROBIN_1 = 0x1
	// Position of L2_MEM_EN_POWERSAVING field.
	IOMUXC_GPR_GPR2_L2_MEM_EN_POWERSAVING_Pos = 0xc
	// Bit mask of L2_MEM_EN_POWERSAVING field.
	IOMUXC_GPR_GPR2_L2_MEM_EN_POWERSAVING_Msk = 0x1000
	// Bit L2_MEM_EN_POWERSAVING.
	IOMUXC_GPR_GPR2_L2_MEM_EN_POWERSAVING = 0x1000
	// Enters power saving mode only when chip is in SUSPEND mode
	IOMUXC_GPR_GPR2_L2_MEM_EN_POWERSAVING_L2_MEM_EN_POWERSAVING_0 = 0x0
	// Controlled by L2_MEM_DEEPSLEEP bitfield
	IOMUXC_GPR_GPR2_L2_MEM_EN_POWERSAVING_L2_MEM_EN_POWERSAVING_1 = 0x1
	// Position of RAM_AUTO_CLK_GATING_EN field.
	IOMUXC_GPR_GPR2_RAM_AUTO_CLK_GATING_EN_Pos = 0xd
	// Bit mask of RAM_AUTO_CLK_GATING_EN field.
	IOMUXC_GPR_GPR2_RAM_AUTO_CLK_GATING_EN_Msk = 0x2000
	// Bit RAM_AUTO_CLK_GATING_EN.
	IOMUXC_GPR_GPR2_RAM_AUTO_CLK_GATING_EN = 0x2000
	// disable automatically gate off RAM clock
	IOMUXC_GPR_GPR2_RAM_AUTO_CLK_GATING_EN_RAM_AUTO_CLK_GATING_EN_0 = 0x0
	// enable automatically gate off RAM clock
	IOMUXC_GPR_GPR2_RAM_AUTO_CLK_GATING_EN_RAM_AUTO_CLK_GATING_EN_1 = 0x1
	// Position of L2_MEM_DEEPSLEEP field.
	IOMUXC_GPR_GPR2_L2_MEM_DEEPSLEEP_Pos = 0xe
	// Bit mask of L2_MEM_DEEPSLEEP field.
	IOMUXC_GPR_GPR2_L2_MEM_DEEPSLEEP_Msk = 0x4000
	// Bit L2_MEM_DEEPSLEEP.
	IOMUXC_GPR_GPR2_L2_MEM_DEEPSLEEP = 0x4000
	// No force sleep control supported, memory deep sleep mode only entered when whole system in stop mode (OCRAM in normal mode)
	IOMUXC_GPR_GPR2_L2_MEM_DEEPSLEEP_L2_MEM_DEEPSLEEP_0 = 0x0
	// Force memory into deep sleep mode (OCRAM in power saving mode)
	IOMUXC_GPR_GPR2_L2_MEM_DEEPSLEEP_L2_MEM_DEEPSLEEP_1 = 0x1
	// Position of MQS_CLK_DIV field.
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_Pos = 0x10
	// Bit mask of MQS_CLK_DIV field.
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_Msk = 0xff0000
	// mclk frequency = hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_MQS_CLK_DIV_0 = 0x0
	// mclk frequency = 1/2 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_MQS_CLK_DIV_1 = 0x1
	// mclk frequency = 1/3 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_MQS_CLK_DIV_2 = 0x2
	// mclk frequency = 1/256 * hmclk frequency
	IOMUXC_GPR_GPR2_MQS_CLK_DIV_MQS_CLK_DIV_255 = 0xff
	// Position of MQS_SW_RST field.
	IOMUXC_GPR_GPR2_MQS_SW_RST_Pos = 0x18
	// Bit mask of MQS_SW_RST field.
	IOMUXC_GPR_GPR2_MQS_SW_RST_Msk = 0x1000000
	// Bit MQS_SW_RST.
	IOMUXC_GPR_GPR2_MQS_SW_RST = 0x1000000
	// Exit software reset for MQS
	IOMUXC_GPR_GPR2_MQS_SW_RST_MQS_SW_RST_0 = 0x0
	// Enable software reset for MQS
	IOMUXC_GPR_GPR2_MQS_SW_RST_MQS_SW_RST_1 = 0x1
	// Position of MQS_EN field.
	IOMUXC_GPR_GPR2_MQS_EN_Pos = 0x19
	// Bit mask of MQS_EN field.
	IOMUXC_GPR_GPR2_MQS_EN_Msk = 0x2000000
	// Bit MQS_EN.
	IOMUXC_GPR_GPR2_MQS_EN = 0x2000000
	// Disable MQS
	IOMUXC_GPR_GPR2_MQS_EN_MQS_EN_0 = 0x0
	// Enable MQS
	IOMUXC_GPR_GPR2_MQS_EN_MQS_EN_1 = 0x1
	// Position of MQS_OVERSAMPLE field.
	IOMUXC_GPR_GPR2_MQS_OVERSAMPLE_Pos = 0x1a
	// Bit mask of MQS_OVERSAMPLE field.
	IOMUXC_GPR_GPR2_MQS_OVERSAMPLE_Msk = 0x4000000
	// Bit MQS_OVERSAMPLE.
	IOMUXC_GPR_GPR2_MQS_OVERSAMPLE = 0x4000000
	// 32
	IOMUXC_GPR_GPR2_MQS_OVERSAMPLE_MQS_OVERSAMPLE_0 = 0x0
	// 64
	IOMUXC_GPR_GPR2_MQS_OVERSAMPLE_MQS_OVERSAMPLE_1 = 0x1

	// GPR3: GPR3 General Purpose Register
	// Position of DCP_KEY_SEL field.
	IOMUXC_GPR_GPR3_DCP_KEY_SEL_Pos = 0x4
	// Bit mask of DCP_KEY_SEL field.
	IOMUXC_GPR_GPR3_DCP_KEY_SEL_Msk = 0x10
	// Bit DCP_KEY_SEL.
	IOMUXC_GPR_GPR3_DCP_KEY_SEL = 0x10
	// Select [127:0] from SNVS Master Key as DCP key
	IOMUXC_GPR_GPR3_DCP_KEY_SEL_DCP_KEY_SEL_0 = 0x0
	// Select [255:128] from SNVS Master Key as DCP key
	IOMUXC_GPR_GPR3_DCP_KEY_SEL_DCP_KEY_SEL_1 = 0x1

	// GPR4: GPR4 General Purpose Register
	// Position of EDMA_STOP_REQ field.
	IOMUXC_GPR_GPR4_EDMA_STOP_REQ_Pos = 0x0
	// Bit mask of EDMA_STOP_REQ field.
	IOMUXC_GPR_GPR4_EDMA_STOP_REQ_Msk = 0x1
	// Bit EDMA_STOP_REQ.
	IOMUXC_GPR_GPR4_EDMA_STOP_REQ = 0x1
	// stop request off
	IOMUXC_GPR_GPR4_EDMA_STOP_REQ_EDMA_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR4_EDMA_STOP_REQ_EDMA_STOP_REQ_1 = 0x1
	// Position of TRNG_STOP_REQ field.
	IOMUXC_GPR_GPR4_TRNG_STOP_REQ_Pos = 0x3
	// Bit mask of TRNG_STOP_REQ field.
	IOMUXC_GPR_GPR4_TRNG_STOP_REQ_Msk = 0x8
	// Bit TRNG_STOP_REQ.
	IOMUXC_GPR_GPR4_TRNG_STOP_REQ = 0x8
	// stop request off
	IOMUXC_GPR_GPR4_TRNG_STOP_REQ_TRNG_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR4_TRNG_STOP_REQ_TRNG_STOP_REQ_1 = 0x1
	// Position of SAI1_STOP_REQ field.
	IOMUXC_GPR_GPR4_SAI1_STOP_REQ_Pos = 0x5
	// Bit mask of SAI1_STOP_REQ field.
	IOMUXC_GPR_GPR4_SAI1_STOP_REQ_Msk = 0x20
	// Bit SAI1_STOP_REQ.
	IOMUXC_GPR_GPR4_SAI1_STOP_REQ = 0x20
	// stop request off
	IOMUXC_GPR_GPR4_SAI1_STOP_REQ_SAI1_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR4_SAI1_STOP_REQ_SAI1_STOP_REQ_1 = 0x1
	// Position of SAI3_STOP_REQ field.
	IOMUXC_GPR_GPR4_SAI3_STOP_REQ_Pos = 0x7
	// Bit mask of SAI3_STOP_REQ field.
	IOMUXC_GPR_GPR4_SAI3_STOP_REQ_Msk = 0x80
	// Bit SAI3_STOP_REQ.
	IOMUXC_GPR_GPR4_SAI3_STOP_REQ = 0x80
	// stop request off
	IOMUXC_GPR_GPR4_SAI3_STOP_REQ_SAI3_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR4_SAI3_STOP_REQ_SAI3_STOP_REQ_1 = 0x1
	// Position of PIT_STOP_REQ field.
	IOMUXC_GPR_GPR4_PIT_STOP_REQ_Pos = 0xa
	// Bit mask of PIT_STOP_REQ field.
	IOMUXC_GPR_GPR4_PIT_STOP_REQ_Msk = 0x400
	// Bit PIT_STOP_REQ.
	IOMUXC_GPR_GPR4_PIT_STOP_REQ = 0x400
	// stop request off
	IOMUXC_GPR_GPR4_PIT_STOP_REQ_PIT_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR4_PIT_STOP_REQ_PIT_STOP_REQ_1 = 0x1
	// Position of FLEXSPI_STOP_REQ field.
	IOMUXC_GPR_GPR4_FLEXSPI_STOP_REQ_Pos = 0xb
	// Bit mask of FLEXSPI_STOP_REQ field.
	IOMUXC_GPR_GPR4_FLEXSPI_STOP_REQ_Msk = 0x800
	// Bit FLEXSPI_STOP_REQ.
	IOMUXC_GPR_GPR4_FLEXSPI_STOP_REQ = 0x800
	// stop request off
	IOMUXC_GPR_GPR4_FLEXSPI_STOP_REQ_FLEXSPI_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR4_FLEXSPI_STOP_REQ_FLEXSPI_STOP_REQ_1 = 0x1
	// Position of FLEXIO1_STOP_REQ field.
	IOMUXC_GPR_GPR4_FLEXIO1_STOP_REQ_Pos = 0xc
	// Bit mask of FLEXIO1_STOP_REQ field.
	IOMUXC_GPR_GPR4_FLEXIO1_STOP_REQ_Msk = 0x1000
	// Bit FLEXIO1_STOP_REQ.
	IOMUXC_GPR_GPR4_FLEXIO1_STOP_REQ = 0x1000
	// stop request off
	IOMUXC_GPR_GPR4_FLEXIO1_STOP_REQ_FLEXIO1_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR4_FLEXIO1_STOP_REQ_FLEXIO1_STOP_REQ_1 = 0x1
	// Position of EDMA_STOP_ACK field.
	IOMUXC_GPR_GPR4_EDMA_STOP_ACK_Pos = 0x10
	// Bit mask of EDMA_STOP_ACK field.
	IOMUXC_GPR_GPR4_EDMA_STOP_ACK_Msk = 0x10000
	// Bit EDMA_STOP_ACK.
	IOMUXC_GPR_GPR4_EDMA_STOP_ACK = 0x10000
	// EDMA stop acknowledge is not asserted
	IOMUXC_GPR_GPR4_EDMA_STOP_ACK_EDMA_STOP_ACK_0 = 0x0
	// EDMA stop acknowledge is asserted (EDMA is in STOP mode).
	IOMUXC_GPR_GPR4_EDMA_STOP_ACK_EDMA_STOP_ACK_1 = 0x1
	// Position of TRNG_STOP_ACK field.
	IOMUXC_GPR_GPR4_TRNG_STOP_ACK_Pos = 0x13
	// Bit mask of TRNG_STOP_ACK field.
	IOMUXC_GPR_GPR4_TRNG_STOP_ACK_Msk = 0x80000
	// Bit TRNG_STOP_ACK.
	IOMUXC_GPR_GPR4_TRNG_STOP_ACK = 0x80000
	// TRNG stop acknowledge is not asserted
	IOMUXC_GPR_GPR4_TRNG_STOP_ACK_TRNG_STOP_ACK_0 = 0x0
	// TRNG stop acknowledge is asserted
	IOMUXC_GPR_GPR4_TRNG_STOP_ACK_TRNG_STOP_ACK_1 = 0x1
	// Position of SAI1_STOP_ACK field.
	IOMUXC_GPR_GPR4_SAI1_STOP_ACK_Pos = 0x15
	// Bit mask of SAI1_STOP_ACK field.
	IOMUXC_GPR_GPR4_SAI1_STOP_ACK_Msk = 0x200000
	// Bit SAI1_STOP_ACK.
	IOMUXC_GPR_GPR4_SAI1_STOP_ACK = 0x200000
	// SAI1 stop acknowledge is not asserted
	IOMUXC_GPR_GPR4_SAI1_STOP_ACK_SAI1_STOP_ACK_0 = 0x0
	// SAI1 stop acknowledge is asserted
	IOMUXC_GPR_GPR4_SAI1_STOP_ACK_SAI1_STOP_ACK_1 = 0x1
	// Position of SAI3_STOP_ACK field.
	IOMUXC_GPR_GPR4_SAI3_STOP_ACK_Pos = 0x17
	// Bit mask of SAI3_STOP_ACK field.
	IOMUXC_GPR_GPR4_SAI3_STOP_ACK_Msk = 0x800000
	// Bit SAI3_STOP_ACK.
	IOMUXC_GPR_GPR4_SAI3_STOP_ACK = 0x800000
	// SAI3 stop acknowledge is not asserted
	IOMUXC_GPR_GPR4_SAI3_STOP_ACK_SAI3_STOP_ACK_0 = 0x0
	// SAI3 stop acknowledge is asserted
	IOMUXC_GPR_GPR4_SAI3_STOP_ACK_SAI3_STOP_ACK_1 = 0x1
	// Position of PIT_STOP_ACK field.
	IOMUXC_GPR_GPR4_PIT_STOP_ACK_Pos = 0x1a
	// Bit mask of PIT_STOP_ACK field.
	IOMUXC_GPR_GPR4_PIT_STOP_ACK_Msk = 0x4000000
	// Bit PIT_STOP_ACK.
	IOMUXC_GPR_GPR4_PIT_STOP_ACK = 0x4000000
	// PIT stop acknowledge is not asserted
	IOMUXC_GPR_GPR4_PIT_STOP_ACK_PIT_STOP_ACK_0 = 0x0
	// PIT stop acknowledge is asserted
	IOMUXC_GPR_GPR4_PIT_STOP_ACK_PIT_STOP_ACK_1 = 0x1
	// Position of FLEXSPI_STOP_ACK field.
	IOMUXC_GPR_GPR4_FLEXSPI_STOP_ACK_Pos = 0x1b
	// Bit mask of FLEXSPI_STOP_ACK field.
	IOMUXC_GPR_GPR4_FLEXSPI_STOP_ACK_Msk = 0x8000000
	// Bit FLEXSPI_STOP_ACK.
	IOMUXC_GPR_GPR4_FLEXSPI_STOP_ACK = 0x8000000
	// FLEXSPI stop acknowledge is not asserted
	IOMUXC_GPR_GPR4_FLEXSPI_STOP_ACK_FLEXSPI_STOP_ACK_0 = 0x0
	// FLEXSPI stop acknowledge is asserted
	IOMUXC_GPR_GPR4_FLEXSPI_STOP_ACK_FLEXSPI_STOP_ACK_1 = 0x1
	// Position of FLEXIO1_STOP_ACK field.
	IOMUXC_GPR_GPR4_FLEXIO1_STOP_ACK_Pos = 0x1c
	// Bit mask of FLEXIO1_STOP_ACK field.
	IOMUXC_GPR_GPR4_FLEXIO1_STOP_ACK_Msk = 0x10000000
	// Bit FLEXIO1_STOP_ACK.
	IOMUXC_GPR_GPR4_FLEXIO1_STOP_ACK = 0x10000000
	// FLEXIO1 stop acknowledge is not asserted
	IOMUXC_GPR_GPR4_FLEXIO1_STOP_ACK_FLEXIO1_STOP_ACK_0 = 0x0
	// FLEXIO1 stop acknowledge is asserted
	IOMUXC_GPR_GPR4_FLEXIO1_STOP_ACK_FLEXIO1_STOP_ACK_1 = 0x1

	// GPR5: GPR5 General Purpose Register
	// Position of WDOG1_MASK field.
	IOMUXC_GPR_GPR5_WDOG1_MASK_Pos = 0x6
	// Bit mask of WDOG1_MASK field.
	IOMUXC_GPR_GPR5_WDOG1_MASK_Msk = 0x40
	// Bit WDOG1_MASK.
	IOMUXC_GPR_GPR5_WDOG1_MASK = 0x40
	// WDOG1 Timeout behaves normally
	IOMUXC_GPR_GPR5_WDOG1_MASK_WDOG1_MASK_0 = 0x0
	// WDOG1 Timeout is masked
	IOMUXC_GPR_GPR5_WDOG1_MASK_WDOG1_MASK_1 = 0x1
	// Position of WDOG2_MASK field.
	IOMUXC_GPR_GPR5_WDOG2_MASK_Pos = 0x7
	// Bit mask of WDOG2_MASK field.
	IOMUXC_GPR_GPR5_WDOG2_MASK_Msk = 0x80
	// Bit WDOG2_MASK.
	IOMUXC_GPR_GPR5_WDOG2_MASK = 0x80
	// WDOG2 Timeout behaves normally
	IOMUXC_GPR_GPR5_WDOG2_MASK_WDOG2_MASK_0 = 0x0
	// WDOG2 Timeout is masked
	IOMUXC_GPR_GPR5_WDOG2_MASK_WDOG2_MASK_1 = 0x1
	// Position of VREF_1M_CLK_GPT1 field.
	IOMUXC_GPR_GPR5_VREF_1M_CLK_GPT1_Pos = 0x1c
	// Bit mask of VREF_1M_CLK_GPT1 field.
	IOMUXC_GPR_GPR5_VREF_1M_CLK_GPT1_Msk = 0x10000000
	// Bit VREF_1M_CLK_GPT1.
	IOMUXC_GPR_GPR5_VREF_1M_CLK_GPT1 = 0x10000000
	// GPT1 ipg_clk_highfreq driven by IPG_PERCLK
	IOMUXC_GPR_GPR5_VREF_1M_CLK_GPT1_VREF_1M_CLK_GPT1_0 = 0x0
	// GPT1 ipg_clk_highfreq driven by anatop 1 MHz clock
	IOMUXC_GPR_GPR5_VREF_1M_CLK_GPT1_VREF_1M_CLK_GPT1_1 = 0x1
	// Position of VREF_1M_CLK_GPT2 field.
	IOMUXC_GPR_GPR5_VREF_1M_CLK_GPT2_Pos = 0x1d
	// Bit mask of VREF_1M_CLK_GPT2 field.
	IOMUXC_GPR_GPR5_VREF_1M_CLK_GPT2_Msk = 0x20000000
	// Bit VREF_1M_CLK_GPT2.
	IOMUXC_GPR_GPR5_VREF_1M_CLK_GPT2 = 0x20000000
	// GPT2 ipg_clk_highfreq driven by IPG_PERCLK
	IOMUXC_GPR_GPR5_VREF_1M_CLK_GPT2_VREF_1M_CLK_GPT2_0 = 0x0
	// GPT2 ipg_clk_highfreq driven by anatop 1 MHz clock
	IOMUXC_GPR_GPR5_VREF_1M_CLK_GPT2_VREF_1M_CLK_GPT2_1 = 0x1

	// GPR6: GPR6 General Purpose Register
	// Position of IOMUXC_XBAR_DIR_SEL_2 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_2_Pos = 0x10
	// Bit mask of IOMUXC_XBAR_DIR_SEL_2 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_2_Msk = 0x10000
	// Bit IOMUXC_XBAR_DIR_SEL_2.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_2 = 0x10000
	// XBAR_INOUT as input
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_2_IOMUXC_XBAR_DIR_SEL_2_0 = 0x0
	// XBAR_INOUT as output
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_2_IOMUXC_XBAR_DIR_SEL_2_1 = 0x1
	// Position of IOMUXC_XBAR_DIR_SEL_3 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_3_Pos = 0x11
	// Bit mask of IOMUXC_XBAR_DIR_SEL_3 field.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_3_Msk = 0x20000
	// Bit IOMUXC_XBAR_DIR_SEL_3.
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_3 = 0x20000
	// XBAR_INOUT as input
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_3_IOMUXC_XBAR_DIR_SEL_3_0 = 0x0
	// XBAR_INOUT as output
	IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_3_IOMUXC_XBAR_DIR_SEL_3_1 = 0x1

	// GPR7: GPR7 General Purpose Register
	// Position of LPI2C1_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPI2C1_STOP_REQ_Pos = 0x0
	// Bit mask of LPI2C1_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPI2C1_STOP_REQ_Msk = 0x1
	// Bit LPI2C1_STOP_REQ.
	IOMUXC_GPR_GPR7_LPI2C1_STOP_REQ = 0x1
	// stop request off
	IOMUXC_GPR_GPR7_LPI2C1_STOP_REQ_LPI2C1_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR7_LPI2C1_STOP_REQ_LPI2C1_STOP_REQ_1 = 0x1
	// Position of LPI2C2_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPI2C2_STOP_REQ_Pos = 0x1
	// Bit mask of LPI2C2_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPI2C2_STOP_REQ_Msk = 0x2
	// Bit LPI2C2_STOP_REQ.
	IOMUXC_GPR_GPR7_LPI2C2_STOP_REQ = 0x2
	// stop request off
	IOMUXC_GPR_GPR7_LPI2C2_STOP_REQ_LPI2C2_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR7_LPI2C2_STOP_REQ_LPI2C2_STOP_REQ_1 = 0x1
	// Position of LPSPI1_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPSPI1_STOP_REQ_Pos = 0x4
	// Bit mask of LPSPI1_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPSPI1_STOP_REQ_Msk = 0x10
	// Bit LPSPI1_STOP_REQ.
	IOMUXC_GPR_GPR7_LPSPI1_STOP_REQ = 0x10
	// stop request off
	IOMUXC_GPR_GPR7_LPSPI1_STOP_REQ_LPSPI1_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR7_LPSPI1_STOP_REQ_LPSPI1_STOP_REQ_1 = 0x1
	// Position of LPSPI2_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPSPI2_STOP_REQ_Pos = 0x5
	// Bit mask of LPSPI2_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPSPI2_STOP_REQ_Msk = 0x20
	// Bit LPSPI2_STOP_REQ.
	IOMUXC_GPR_GPR7_LPSPI2_STOP_REQ = 0x20
	// stop request off
	IOMUXC_GPR_GPR7_LPSPI2_STOP_REQ_LPSPI2_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR7_LPSPI2_STOP_REQ_LPSPI2_STOP_REQ_1 = 0x1
	// Position of LPUART1_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPUART1_STOP_REQ_Pos = 0x8
	// Bit mask of LPUART1_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPUART1_STOP_REQ_Msk = 0x100
	// Bit LPUART1_STOP_REQ.
	IOMUXC_GPR_GPR7_LPUART1_STOP_REQ = 0x100
	// stop request off
	IOMUXC_GPR_GPR7_LPUART1_STOP_REQ_LPUART1_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR7_LPUART1_STOP_REQ_LPUART1_STOP_REQ_1 = 0x1
	// Position of LPUART2_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPUART2_STOP_REQ_Pos = 0x9
	// Bit mask of LPUART2_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPUART2_STOP_REQ_Msk = 0x200
	// Bit LPUART2_STOP_REQ.
	IOMUXC_GPR_GPR7_LPUART2_STOP_REQ = 0x200
	// stop request off
	IOMUXC_GPR_GPR7_LPUART2_STOP_REQ_LPUART2_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR7_LPUART2_STOP_REQ_LPUART2_STOP_REQ_1 = 0x1
	// Position of LPUART3_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPUART3_STOP_REQ_Pos = 0xa
	// Bit mask of LPUART3_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPUART3_STOP_REQ_Msk = 0x400
	// Bit LPUART3_STOP_REQ.
	IOMUXC_GPR_GPR7_LPUART3_STOP_REQ = 0x400
	// stop request off
	IOMUXC_GPR_GPR7_LPUART3_STOP_REQ_LPUART3_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR7_LPUART3_STOP_REQ_LPUART3_STOP_REQ_1 = 0x1
	// Position of LPUART4_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPUART4_STOP_REQ_Pos = 0xb
	// Bit mask of LPUART4_STOP_REQ field.
	IOMUXC_GPR_GPR7_LPUART4_STOP_REQ_Msk = 0x800
	// Bit LPUART4_STOP_REQ.
	IOMUXC_GPR_GPR7_LPUART4_STOP_REQ = 0x800
	// stop request off
	IOMUXC_GPR_GPR7_LPUART4_STOP_REQ_LPUART4_STOP_REQ_0 = 0x0
	// stop request on
	IOMUXC_GPR_GPR7_LPUART4_STOP_REQ_LPUART4_STOP_REQ_1 = 0x1
	// Position of LPI2C1_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPI2C1_STOP_ACK_Pos = 0x10
	// Bit mask of LPI2C1_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPI2C1_STOP_ACK_Msk = 0x10000
	// Bit LPI2C1_STOP_ACK.
	IOMUXC_GPR_GPR7_LPI2C1_STOP_ACK = 0x10000
	// stop acknowledge is not asserted
	IOMUXC_GPR_GPR7_LPI2C1_STOP_ACK_LPI2C1_STOP_ACK_0 = 0x0
	// stop acknowledge is asserted (the module is in Stop mode)
	IOMUXC_GPR_GPR7_LPI2C1_STOP_ACK_LPI2C1_STOP_ACK_1 = 0x1
	// Position of LPI2C2_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPI2C2_STOP_ACK_Pos = 0x11
	// Bit mask of LPI2C2_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPI2C2_STOP_ACK_Msk = 0x20000
	// Bit LPI2C2_STOP_ACK.
	IOMUXC_GPR_GPR7_LPI2C2_STOP_ACK = 0x20000
	// stop acknowledge is not asserted
	IOMUXC_GPR_GPR7_LPI2C2_STOP_ACK_LPI2C2_STOP_ACK_0 = 0x0
	// stop acknowledge is asserted
	IOMUXC_GPR_GPR7_LPI2C2_STOP_ACK_LPI2C2_STOP_ACK_1 = 0x1
	// Position of LPSPI1_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPSPI1_STOP_ACK_Pos = 0x14
	// Bit mask of LPSPI1_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPSPI1_STOP_ACK_Msk = 0x100000
	// Bit LPSPI1_STOP_ACK.
	IOMUXC_GPR_GPR7_LPSPI1_STOP_ACK = 0x100000
	// stop acknowledge is not asserted
	IOMUXC_GPR_GPR7_LPSPI1_STOP_ACK_LPSPI1_STOP_ACK_0 = 0x0
	// stop acknowledge is asserted
	IOMUXC_GPR_GPR7_LPSPI1_STOP_ACK_LPSPI1_STOP_ACK_1 = 0x1
	// Position of LPSPI2_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPSPI2_STOP_ACK_Pos = 0x15
	// Bit mask of LPSPI2_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPSPI2_STOP_ACK_Msk = 0x200000
	// Bit LPSPI2_STOP_ACK.
	IOMUXC_GPR_GPR7_LPSPI2_STOP_ACK = 0x200000
	// stop acknowledge is not asserted
	IOMUXC_GPR_GPR7_LPSPI2_STOP_ACK_LPSPI2_STOP_ACK_0 = 0x0
	// stop acknowledge is asserted
	IOMUXC_GPR_GPR7_LPSPI2_STOP_ACK_LPSPI2_STOP_ACK_1 = 0x1
	// Position of LPUART1_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPUART1_STOP_ACK_Pos = 0x18
	// Bit mask of LPUART1_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPUART1_STOP_ACK_Msk = 0x1000000
	// Bit LPUART1_STOP_ACK.
	IOMUXC_GPR_GPR7_LPUART1_STOP_ACK = 0x1000000
	// stop acknowledge is not asserted
	IOMUXC_GPR_GPR7_LPUART1_STOP_ACK_LPUART1_STOP_ACK_0 = 0x0
	// stop acknowledge is asserted
	IOMUXC_GPR_GPR7_LPUART1_STOP_ACK_LPUART1_STOP_ACK_1 = 0x1
	// Position of LPUART2_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPUART2_STOP_ACK_Pos = 0x19
	// Bit mask of LPUART2_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPUART2_STOP_ACK_Msk = 0x2000000
	// Bit LPUART2_STOP_ACK.
	IOMUXC_GPR_GPR7_LPUART2_STOP_ACK = 0x2000000
	// stop acknowledge is not asserted
	IOMUXC_GPR_GPR7_LPUART2_STOP_ACK_LPUART2_STOP_ACK_0 = 0x0
	// stop acknowledge is asserted
	IOMUXC_GPR_GPR7_LPUART2_STOP_ACK_LPUART2_STOP_ACK_1 = 0x1
	// Position of LPUART3_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPUART3_STOP_ACK_Pos = 0x1a
	// Bit mask of LPUART3_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPUART3_STOP_ACK_Msk = 0x4000000
	// Bit LPUART3_STOP_ACK.
	IOMUXC_GPR_GPR7_LPUART3_STOP_ACK = 0x4000000
	// stop acknowledge is not asserted
	IOMUXC_GPR_GPR7_LPUART3_STOP_ACK_LPUART3_STOP_ACK_0 = 0x0
	// stop acknowledge is asserted
	IOMUXC_GPR_GPR7_LPUART3_STOP_ACK_LPUART3_STOP_ACK_1 = 0x1
	// Position of LPUART4_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPUART4_STOP_ACK_Pos = 0x1b
	// Bit mask of LPUART4_STOP_ACK field.
	IOMUXC_GPR_GPR7_LPUART4_STOP_ACK_Msk = 0x8000000
	// Bit LPUART4_STOP_ACK.
	IOMUXC_GPR_GPR7_LPUART4_STOP_ACK = 0x8000000
	// stop acknowledge is not asserted
	IOMUXC_GPR_GPR7_LPUART4_STOP_ACK_LPUART4_STOP_ACK_0 = 0x0
	// stop acknowledge is asserted
	IOMUXC_GPR_GPR7_LPUART4_STOP_ACK_LPUART4_STOP_ACK_1 = 0x1

	// GPR8: GPR8 General Purpose Register
	// Position of LPI2C1_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPI2C1_IPG_STOP_MODE_Pos = 0x0
	// Bit mask of LPI2C1_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPI2C1_IPG_STOP_MODE_Msk = 0x1
	// Bit LPI2C1_IPG_STOP_MODE.
	IOMUXC_GPR_GPR8_LPI2C1_IPG_STOP_MODE = 0x1
	// the module is functional in Stop mode
	IOMUXC_GPR_GPR8_LPI2C1_IPG_STOP_MODE_LPI2C1_IPG_STOP_MODE_0 = 0x0
	// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
	IOMUXC_GPR_GPR8_LPI2C1_IPG_STOP_MODE_LPI2C1_IPG_STOP_MODE_1 = 0x1
	// Position of LPI2C1_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPI2C1_IPG_DOZE_Pos = 0x1
	// Bit mask of LPI2C1_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPI2C1_IPG_DOZE_Msk = 0x2
	// Bit LPI2C1_IPG_DOZE.
	IOMUXC_GPR_GPR8_LPI2C1_IPG_DOZE = 0x2
	// not in doze mode
	IOMUXC_GPR_GPR8_LPI2C1_IPG_DOZE_LPI2C1_IPG_DOZE_0 = 0x0
	// in doze mode
	IOMUXC_GPR_GPR8_LPI2C1_IPG_DOZE_LPI2C1_IPG_DOZE_1 = 0x1
	// Position of LPI2C2_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPI2C2_IPG_STOP_MODE_Pos = 0x2
	// Bit mask of LPI2C2_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPI2C2_IPG_STOP_MODE_Msk = 0x4
	// Bit LPI2C2_IPG_STOP_MODE.
	IOMUXC_GPR_GPR8_LPI2C2_IPG_STOP_MODE = 0x4
	// the module is functional in Stop mode
	IOMUXC_GPR_GPR8_LPI2C2_IPG_STOP_MODE_LPI2C2_IPG_STOP_MODE_0 = 0x0
	// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
	IOMUXC_GPR_GPR8_LPI2C2_IPG_STOP_MODE_LPI2C2_IPG_STOP_MODE_1 = 0x1
	// Position of LPI2C2_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPI2C2_IPG_DOZE_Pos = 0x3
	// Bit mask of LPI2C2_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPI2C2_IPG_DOZE_Msk = 0x8
	// Bit LPI2C2_IPG_DOZE.
	IOMUXC_GPR_GPR8_LPI2C2_IPG_DOZE = 0x8
	// not in doze mode
	IOMUXC_GPR_GPR8_LPI2C2_IPG_DOZE_LPI2C2_IPG_DOZE_0 = 0x0
	// in doze mode
	IOMUXC_GPR_GPR8_LPI2C2_IPG_DOZE_LPI2C2_IPG_DOZE_1 = 0x1
	// Position of LPSPI1_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPSPI1_IPG_STOP_MODE_Pos = 0x8
	// Bit mask of LPSPI1_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPSPI1_IPG_STOP_MODE_Msk = 0x100
	// Bit LPSPI1_IPG_STOP_MODE.
	IOMUXC_GPR_GPR8_LPSPI1_IPG_STOP_MODE = 0x100
	// the module is functional in Stop mode
	IOMUXC_GPR_GPR8_LPSPI1_IPG_STOP_MODE_LPSPI1_IPG_STOP_MODE_0 = 0x0
	// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
	IOMUXC_GPR_GPR8_LPSPI1_IPG_STOP_MODE_LPSPI1_IPG_STOP_MODE_1 = 0x1
	// Position of LPSPI1_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPSPI1_IPG_DOZE_Pos = 0x9
	// Bit mask of LPSPI1_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPSPI1_IPG_DOZE_Msk = 0x200
	// Bit LPSPI1_IPG_DOZE.
	IOMUXC_GPR_GPR8_LPSPI1_IPG_DOZE = 0x200
	// not in doze mode
	IOMUXC_GPR_GPR8_LPSPI1_IPG_DOZE_LPSPI1_IPG_DOZE_0 = 0x0
	// in doze mode
	IOMUXC_GPR_GPR8_LPSPI1_IPG_DOZE_LPSPI1_IPG_DOZE_1 = 0x1
	// Position of LPSPI2_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPSPI2_IPG_STOP_MODE_Pos = 0xa
	// Bit mask of LPSPI2_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPSPI2_IPG_STOP_MODE_Msk = 0x400
	// Bit LPSPI2_IPG_STOP_MODE.
	IOMUXC_GPR_GPR8_LPSPI2_IPG_STOP_MODE = 0x400
	// the module is functional in Stop mode
	IOMUXC_GPR_GPR8_LPSPI2_IPG_STOP_MODE_LPSPI2_IPG_STOP_MODE_0 = 0x0
	// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
	IOMUXC_GPR_GPR8_LPSPI2_IPG_STOP_MODE_LPSPI2_IPG_STOP_MODE_1 = 0x1
	// Position of LPSPI2_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPSPI2_IPG_DOZE_Pos = 0xb
	// Bit mask of LPSPI2_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPSPI2_IPG_DOZE_Msk = 0x800
	// Bit LPSPI2_IPG_DOZE.
	IOMUXC_GPR_GPR8_LPSPI2_IPG_DOZE = 0x800
	// not in doze mode
	IOMUXC_GPR_GPR8_LPSPI2_IPG_DOZE_LPSPI2_IPG_DOZE_0 = 0x0
	// in doze mode
	IOMUXC_GPR_GPR8_LPSPI2_IPG_DOZE_LPSPI2_IPG_DOZE_1 = 0x1
	// Position of LPUART1_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPUART1_IPG_STOP_MODE_Pos = 0x10
	// Bit mask of LPUART1_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPUART1_IPG_STOP_MODE_Msk = 0x10000
	// Bit LPUART1_IPG_STOP_MODE.
	IOMUXC_GPR_GPR8_LPUART1_IPG_STOP_MODE = 0x10000
	// the module is functional in Stop mode
	IOMUXC_GPR_GPR8_LPUART1_IPG_STOP_MODE_LPUART1_IPG_STOP_MODE_0 = 0x0
	// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
	IOMUXC_GPR_GPR8_LPUART1_IPG_STOP_MODE_LPUART1_IPG_STOP_MODE_1 = 0x1
	// Position of LPUART1_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPUART1_IPG_DOZE_Pos = 0x11
	// Bit mask of LPUART1_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPUART1_IPG_DOZE_Msk = 0x20000
	// Bit LPUART1_IPG_DOZE.
	IOMUXC_GPR_GPR8_LPUART1_IPG_DOZE = 0x20000
	// not in doze mode
	IOMUXC_GPR_GPR8_LPUART1_IPG_DOZE_LPUART1_IPG_DOZE_0 = 0x0
	// in doze mode
	IOMUXC_GPR_GPR8_LPUART1_IPG_DOZE_LPUART1_IPG_DOZE_1 = 0x1
	// Position of LPUART2_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPUART2_IPG_STOP_MODE_Pos = 0x12
	// Bit mask of LPUART2_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPUART2_IPG_STOP_MODE_Msk = 0x40000
	// Bit LPUART2_IPG_STOP_MODE.
	IOMUXC_GPR_GPR8_LPUART2_IPG_STOP_MODE = 0x40000
	// the module is functional in Stop mode
	IOMUXC_GPR_GPR8_LPUART2_IPG_STOP_MODE_LPUART2_IPG_STOP_MODE_0 = 0x0
	// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
	IOMUXC_GPR_GPR8_LPUART2_IPG_STOP_MODE_LPUART2_IPG_STOP_MODE_1 = 0x1
	// Position of LPUART2_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPUART2_IPG_DOZE_Pos = 0x13
	// Bit mask of LPUART2_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPUART2_IPG_DOZE_Msk = 0x80000
	// Bit LPUART2_IPG_DOZE.
	IOMUXC_GPR_GPR8_LPUART2_IPG_DOZE = 0x80000
	// not in doze mode
	IOMUXC_GPR_GPR8_LPUART2_IPG_DOZE_LPUART2_IPG_DOZE_0 = 0x0
	// in doze mode
	IOMUXC_GPR_GPR8_LPUART2_IPG_DOZE_LPUART2_IPG_DOZE_1 = 0x1
	// Position of LPUART3_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPUART3_IPG_STOP_MODE_Pos = 0x14
	// Bit mask of LPUART3_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPUART3_IPG_STOP_MODE_Msk = 0x100000
	// Bit LPUART3_IPG_STOP_MODE.
	IOMUXC_GPR_GPR8_LPUART3_IPG_STOP_MODE = 0x100000
	// the module is functional in Stop mode
	IOMUXC_GPR_GPR8_LPUART3_IPG_STOP_MODE_LPUART3_IPG_STOP_MODE_0 = 0x0
	// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
	IOMUXC_GPR_GPR8_LPUART3_IPG_STOP_MODE_LPUART3_IPG_STOP_MODE_1 = 0x1
	// Position of LPUART3_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPUART3_IPG_DOZE_Pos = 0x15
	// Bit mask of LPUART3_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPUART3_IPG_DOZE_Msk = 0x200000
	// Bit LPUART3_IPG_DOZE.
	IOMUXC_GPR_GPR8_LPUART3_IPG_DOZE = 0x200000
	// not in doze mode
	IOMUXC_GPR_GPR8_LPUART3_IPG_DOZE_LPUART3_IPG_DOZE_0 = 0x0
	// in doze mode
	IOMUXC_GPR_GPR8_LPUART3_IPG_DOZE_LPUART3_IPG_DOZE_1 = 0x1
	// Position of LPUART4_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPUART4_IPG_STOP_MODE_Pos = 0x16
	// Bit mask of LPUART4_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR8_LPUART4_IPG_STOP_MODE_Msk = 0x400000
	// Bit LPUART4_IPG_STOP_MODE.
	IOMUXC_GPR_GPR8_LPUART4_IPG_STOP_MODE = 0x400000
	// the module is functional in Stop mode
	IOMUXC_GPR_GPR8_LPUART4_IPG_STOP_MODE_LPUART4_IPG_STOP_MODE_0 = 0x0
	// the module is NOT functional in Stop mode, when this bit is equal to 1 and ipg_stop is asserted
	IOMUXC_GPR_GPR8_LPUART4_IPG_STOP_MODE_LPUART4_IPG_STOP_MODE_1 = 0x1
	// Position of LPUART4_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPUART4_IPG_DOZE_Pos = 0x17
	// Bit mask of LPUART4_IPG_DOZE field.
	IOMUXC_GPR_GPR8_LPUART4_IPG_DOZE_Msk = 0x800000
	// Bit LPUART4_IPG_DOZE.
	IOMUXC_GPR_GPR8_LPUART4_IPG_DOZE = 0x800000
	// not in doze mode
	IOMUXC_GPR_GPR8_LPUART4_IPG_DOZE_LPUART4_IPG_DOZE_0 = 0x0
	// in doze mode
	IOMUXC_GPR_GPR8_LPUART4_IPG_DOZE_LPUART4_IPG_DOZE_1 = 0x1

	// GPR10: GPR10 General Purpose Register
	// Position of NIDEN field.
	IOMUXC_GPR_GPR10_NIDEN_Pos = 0x0
	// Bit mask of NIDEN field.
	IOMUXC_GPR_GPR10_NIDEN_Msk = 0x1
	// Bit NIDEN.
	IOMUXC_GPR_GPR10_NIDEN = 0x1
	// Debug turned off.
	IOMUXC_GPR_GPR10_NIDEN_NIDEN_0 = 0x0
	// Debug enabled (default).
	IOMUXC_GPR_GPR10_NIDEN_NIDEN_1 = 0x1
	// Position of DBG_EN field.
	IOMUXC_GPR_GPR10_DBG_EN_Pos = 0x1
	// Bit mask of DBG_EN field.
	IOMUXC_GPR_GPR10_DBG_EN_Msk = 0x2
	// Bit DBG_EN.
	IOMUXC_GPR_GPR10_DBG_EN = 0x2
	// Debug turned off.
	IOMUXC_GPR_GPR10_DBG_EN_DBG_EN_0 = 0x0
	// Debug enabled (default).
	IOMUXC_GPR_GPR10_DBG_EN_DBG_EN_1 = 0x1
	// Position of SEC_ERR_RESP field.
	IOMUXC_GPR_GPR10_SEC_ERR_RESP_Pos = 0x2
	// Bit mask of SEC_ERR_RESP field.
	IOMUXC_GPR_GPR10_SEC_ERR_RESP_Msk = 0x4
	// Bit SEC_ERR_RESP.
	IOMUXC_GPR_GPR10_SEC_ERR_RESP = 0x4
	// OKEY response
	IOMUXC_GPR_GPR10_SEC_ERR_RESP_SEC_ERR_RESP_0 = 0x0
	// SLVError (default)
	IOMUXC_GPR_GPR10_SEC_ERR_RESP_SEC_ERR_RESP_1 = 0x1
	// Position of DCPKEY_OCOTP_OR_KEYMUX field.
	IOMUXC_GPR_GPR10_DCPKEY_OCOTP_OR_KEYMUX_Pos = 0x4
	// Bit mask of DCPKEY_OCOTP_OR_KEYMUX field.
	IOMUXC_GPR_GPR10_DCPKEY_OCOTP_OR_KEYMUX_Msk = 0x10
	// Bit DCPKEY_OCOTP_OR_KEYMUX.
	IOMUXC_GPR_GPR10_DCPKEY_OCOTP_OR_KEYMUX = 0x10
	// Select key from SNVS Master Key.
	IOMUXC_GPR_GPR10_DCPKEY_OCOTP_OR_KEYMUX_DCPKEY_OCOTP_OR_KEYMUX_0 = 0x0
	// Select key from OCOTP (SW_GP2).
	IOMUXC_GPR_GPR10_DCPKEY_OCOTP_OR_KEYMUX_DCPKEY_OCOTP_OR_KEYMUX_1 = 0x1
	// Position of OCRAM_TZ_EN field.
	IOMUXC_GPR_GPR10_OCRAM_TZ_EN_Pos = 0x8
	// Bit mask of OCRAM_TZ_EN field.
	IOMUXC_GPR_GPR10_OCRAM_TZ_EN_Msk = 0x100
	// Bit OCRAM_TZ_EN.
	IOMUXC_GPR_GPR10_OCRAM_TZ_EN = 0x100
	// The TrustZone feature is disabled. Entire OCRAM space is available for all access types (secure/non-secure/user/supervisor).
	IOMUXC_GPR_GPR10_OCRAM_TZ_EN_OCRAM_TZ_EN_0 = 0x0
	// The TrustZone feature is enabled. Access to address in the range specified by [ENDADDR:STARTADDR] follows the execution mode access policy described in CSU chapter.
	IOMUXC_GPR_GPR10_OCRAM_TZ_EN_OCRAM_TZ_EN_1 = 0x1
	// Position of OCRAM_TZ_ADDR field.
	IOMUXC_GPR_GPR10_OCRAM_TZ_ADDR_Pos = 0x9
	// Bit mask of OCRAM_TZ_ADDR field.
	IOMUXC_GPR_GPR10_OCRAM_TZ_ADDR_Msk = 0x3e00
	// Position of LOCK_NIDEN field.
	IOMUXC_GPR_GPR10_LOCK_NIDEN_Pos = 0x10
	// Bit mask of LOCK_NIDEN field.
	IOMUXC_GPR_GPR10_LOCK_NIDEN_Msk = 0x10000
	// Bit LOCK_NIDEN.
	IOMUXC_GPR_GPR10_LOCK_NIDEN = 0x10000
	// Field is not locked
	IOMUXC_GPR_GPR10_LOCK_NIDEN_LOCK_NIDEN_0 = 0x0
	// Field is locked (read access only)
	IOMUXC_GPR_GPR10_LOCK_NIDEN_LOCK_NIDEN_1 = 0x1
	// Position of LOCK_DBG_EN field.
	IOMUXC_GPR_GPR10_LOCK_DBG_EN_Pos = 0x11
	// Bit mask of LOCK_DBG_EN field.
	IOMUXC_GPR_GPR10_LOCK_DBG_EN_Msk = 0x20000
	// Bit LOCK_DBG_EN.
	IOMUXC_GPR_GPR10_LOCK_DBG_EN = 0x20000
	// Field is not locked
	IOMUXC_GPR_GPR10_LOCK_DBG_EN_LOCK_DBG_EN_0 = 0x0
	// Field is locked (read access only)
	IOMUXC_GPR_GPR10_LOCK_DBG_EN_LOCK_DBG_EN_1 = 0x1
	// Position of LOCK_SEC_ERR_RESP field.
	IOMUXC_GPR_GPR10_LOCK_SEC_ERR_RESP_Pos = 0x12
	// Bit mask of LOCK_SEC_ERR_RESP field.
	IOMUXC_GPR_GPR10_LOCK_SEC_ERR_RESP_Msk = 0x40000
	// Bit LOCK_SEC_ERR_RESP.
	IOMUXC_GPR_GPR10_LOCK_SEC_ERR_RESP = 0x40000
	// Field is not locked
	IOMUXC_GPR_GPR10_LOCK_SEC_ERR_RESP_LOCK_SEC_ERR_RESP_0 = 0x0
	// Field is locked (read access only)
	IOMUXC_GPR_GPR10_LOCK_SEC_ERR_RESP_LOCK_SEC_ERR_RESP_1 = 0x1
	// Position of LOCK_DCPKEY_OCOTP_OR_KEYMUX field.
	IOMUXC_GPR_GPR10_LOCK_DCPKEY_OCOTP_OR_KEYMUX_Pos = 0x14
	// Bit mask of LOCK_DCPKEY_OCOTP_OR_KEYMUX field.
	IOMUXC_GPR_GPR10_LOCK_DCPKEY_OCOTP_OR_KEYMUX_Msk = 0x100000
	// Bit LOCK_DCPKEY_OCOTP_OR_KEYMUX.
	IOMUXC_GPR_GPR10_LOCK_DCPKEY_OCOTP_OR_KEYMUX = 0x100000
	// Field is not locked
	IOMUXC_GPR_GPR10_LOCK_DCPKEY_OCOTP_OR_KEYMUX_LOCK_DCPKEY_OCOTP_OR_KEYMUX_0 = 0x0
	// Field is locked (read access only)
	IOMUXC_GPR_GPR10_LOCK_DCPKEY_OCOTP_OR_KEYMUX_LOCK_DCPKEY_OCOTP_OR_KEYMUX_1 = 0x1
	// Position of LOCK_OCRAM_TZ_EN field.
	IOMUXC_GPR_GPR10_LOCK_OCRAM_TZ_EN_Pos = 0x18
	// Bit mask of LOCK_OCRAM_TZ_EN field.
	IOMUXC_GPR_GPR10_LOCK_OCRAM_TZ_EN_Msk = 0x1000000
	// Bit LOCK_OCRAM_TZ_EN.
	IOMUXC_GPR_GPR10_LOCK_OCRAM_TZ_EN = 0x1000000
	// Field is not locked
	IOMUXC_GPR_GPR10_LOCK_OCRAM_TZ_EN_LOCK_OCRAM_TZ_EN_0 = 0x0
	// Field is locked (read access only)
	IOMUXC_GPR_GPR10_LOCK_OCRAM_TZ_EN_LOCK_OCRAM_TZ_EN_1 = 0x1
	// Position of LOCK_OCRAM_TZ_ADDR field.
	IOMUXC_GPR_GPR10_LOCK_OCRAM_TZ_ADDR_Pos = 0x19
	// Bit mask of LOCK_OCRAM_TZ_ADDR field.
	IOMUXC_GPR_GPR10_LOCK_OCRAM_TZ_ADDR_Msk = 0x3e000000
	// Field is not locked
	IOMUXC_GPR_GPR10_LOCK_OCRAM_TZ_ADDR_LOCK_OCRAM_TZ_ADDR_0 = 0x0
	// Field is locked (read access only)
	IOMUXC_GPR_GPR10_LOCK_OCRAM_TZ_ADDR_LOCK_OCRAM_TZ_ADDR_1 = 0x1

	// GPR11: GPR11 General Purpose Register
	// Position of M7_APC_AC_R0_CTRL field.
	IOMUXC_GPR_GPR11_M7_APC_AC_R0_CTRL_Pos = 0x0
	// Bit mask of M7_APC_AC_R0_CTRL field.
	IOMUXC_GPR_GPR11_M7_APC_AC_R0_CTRL_Msk = 0x3
	// No access protection
	IOMUXC_GPR_GPR11_M7_APC_AC_R0_CTRL_M7_APC_AC_R0_CTRL_0 = 0x0
	// M7 debug protection enabled
	IOMUXC_GPR_GPR11_M7_APC_AC_R0_CTRL_M7_APC_AC_R0_CTRL_1 = 0x1
	// Position of M7_APC_AC_R1_CTRL field.
	IOMUXC_GPR_GPR11_M7_APC_AC_R1_CTRL_Pos = 0x2
	// Bit mask of M7_APC_AC_R1_CTRL field.
	IOMUXC_GPR_GPR11_M7_APC_AC_R1_CTRL_Msk = 0xc
	// No access protection
	IOMUXC_GPR_GPR11_M7_APC_AC_R1_CTRL_M7_APC_AC_R1_CTRL_0 = 0x0
	// M7 debug protection enabled
	IOMUXC_GPR_GPR11_M7_APC_AC_R1_CTRL_M7_APC_AC_R1_CTRL_1 = 0x1
	// Position of M7_APC_AC_R2_CTRL field.
	IOMUXC_GPR_GPR11_M7_APC_AC_R2_CTRL_Pos = 0x4
	// Bit mask of M7_APC_AC_R2_CTRL field.
	IOMUXC_GPR_GPR11_M7_APC_AC_R2_CTRL_Msk = 0x30
	// No access protection
	IOMUXC_GPR_GPR11_M7_APC_AC_R2_CTRL_M7_APC_AC_R2_CTRL_0 = 0x0
	// M7 debug protection enabled
	IOMUXC_GPR_GPR11_M7_APC_AC_R2_CTRL_M7_APC_AC_R2_CTRL_1 = 0x1
	// Position of M7_APC_AC_R3_CTRL field.
	IOMUXC_GPR_GPR11_M7_APC_AC_R3_CTRL_Pos = 0x6
	// Bit mask of M7_APC_AC_R3_CTRL field.
	IOMUXC_GPR_GPR11_M7_APC_AC_R3_CTRL_Msk = 0xc0
	// No access protection
	IOMUXC_GPR_GPR11_M7_APC_AC_R3_CTRL_M7_APC_AC_R3_CTRL_0 = 0x0
	// M7 debug protection enabled
	IOMUXC_GPR_GPR11_M7_APC_AC_R3_CTRL_M7_APC_AC_R3_CTRL_1 = 0x1
	// Position of LOCK_M7_APC_AC_R0_CTRL field.
	IOMUXC_GPR_GPR11_LOCK_M7_APC_AC_R0_CTRL_Pos = 0x10
	// Bit mask of LOCK_M7_APC_AC_R0_CTRL field.
	IOMUXC_GPR_GPR11_LOCK_M7_APC_AC_R0_CTRL_Msk = 0x30000
	// Position of LOCK_M7_APC_AC_R1_CTRL field.
	IOMUXC_GPR_GPR11_LOCK_M7_APC_AC_R1_CTRL_Pos = 0x12
	// Bit mask of LOCK_M7_APC_AC_R1_CTRL field.
	IOMUXC_GPR_GPR11_LOCK_M7_APC_AC_R1_CTRL_Msk = 0xc0000
	// Position of LOCK_M7_APC_AC_R2_CTRL field.
	IOMUXC_GPR_GPR11_LOCK_M7_APC_AC_R2_CTRL_Pos = 0x14
	// Bit mask of LOCK_M7_APC_AC_R2_CTRL field.
	IOMUXC_GPR_GPR11_LOCK_M7_APC_AC_R2_CTRL_Msk = 0x300000
	// Position of LOCK_M7_APC_AC_R3_CTRL field.
	IOMUXC_GPR_GPR11_LOCK_M7_APC_AC_R3_CTRL_Pos = 0x16
	// Bit mask of LOCK_M7_APC_AC_R3_CTRL field.
	IOMUXC_GPR_GPR11_LOCK_M7_APC_AC_R3_CTRL_Msk = 0xc00000

	// GPR12: GPR12 General Purpose Register
	// Position of FLEXIO1_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR12_FLEXIO1_IPG_STOP_MODE_Pos = 0x0
	// Bit mask of FLEXIO1_IPG_STOP_MODE field.
	IOMUXC_GPR_GPR12_FLEXIO1_IPG_STOP_MODE_Msk = 0x1
	// Bit FLEXIO1_IPG_STOP_MODE.
	IOMUXC_GPR_GPR12_FLEXIO1_IPG_STOP_MODE = 0x1
	// FlexIO1 is functional in Stop mode.
	IOMUXC_GPR_GPR12_FLEXIO1_IPG_STOP_MODE_FLEXIO1_IPG_STOP_MODE_0 = 0x0
	// When this bit is equal to 1'b1 and ipg_stop is asserted, FlexIO1 is not functional in Stop mode.
	IOMUXC_GPR_GPR12_FLEXIO1_IPG_STOP_MODE_FLEXIO1_IPG_STOP_MODE_1 = 0x1
	// Position of FLEXIO1_IPG_DOZE field.
	IOMUXC_GPR_GPR12_FLEXIO1_IPG_DOZE_Pos = 0x1
	// Bit mask of FLEXIO1_IPG_DOZE field.
	IOMUXC_GPR_GPR12_FLEXIO1_IPG_DOZE_Msk = 0x2
	// Bit FLEXIO1_IPG_DOZE.
	IOMUXC_GPR_GPR12_FLEXIO1_IPG_DOZE = 0x2
	// FLEXIO1 is not in doze mode
	IOMUXC_GPR_GPR12_FLEXIO1_IPG_DOZE_FLEXIO1_IPG_DOZE_0 = 0x0
	// FLEXIO1 is in doze mode
	IOMUXC_GPR_GPR12_FLEXIO1_IPG_DOZE_FLEXIO1_IPG_DOZE_1 = 0x1

	// GPR13: GPR13 General Purpose Register
	// Position of CACHE_USB field.
	IOMUXC_GPR_GPR13_CACHE_USB_Pos = 0xd
	// Bit mask of CACHE_USB field.
	IOMUXC_GPR_GPR13_CACHE_USB_Msk = 0x2000
	// Bit CACHE_USB.
	IOMUXC_GPR_GPR13_CACHE_USB = 0x2000
	// Cacheable attribute is off for read/write transactions.
	IOMUXC_GPR_GPR13_CACHE_USB_CACHE_USB_0 = 0x0
	// Cacheable attribute is on for read/write transactions.
	IOMUXC_GPR_GPR13_CACHE_USB_CACHE_USB_1 = 0x1

	// GPR14: GPR14 General Purpose Register
	// Position of CM7_CFGITCMSZ field.
	IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_Pos = 0x10
	// Bit mask of CM7_CFGITCMSZ field.
	IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_Msk = 0xf0000
	// 0 KB (No ITCM)
	IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_CM7_CFGITCMSZ_0 = 0x0
	// 4 KB
	IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_CM7_CFGITCMSZ_3 = 0x3
	// 8 KB
	IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_CM7_CFGITCMSZ_4 = 0x4
	// 16 KB
	IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_CM7_CFGITCMSZ_5 = 0x5
	// 32 KB
	IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_CM7_CFGITCMSZ_6 = 0x6
	// 64 KB
	IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_CM7_CFGITCMSZ_7 = 0x7
	// 128 KB
	IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_CM7_CFGITCMSZ_8 = 0x8
	// Position of CM7_CFGDTCMSZ field.
	IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_Pos = 0x14
	// Bit mask of CM7_CFGDTCMSZ field.
	IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_Msk = 0xf00000
	// 0 KB (No DTCM)
	IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_CM7_CFGDTCMSZ_0 = 0x0
	// 4 KB
	IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_CM7_CFGDTCMSZ_3 = 0x3
	// 8 KB
	IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_CM7_CFGDTCMSZ_4 = 0x4
	// 16 KB
	IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_CM7_CFGDTCMSZ_5 = 0x5
	// 32 KB
	IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_CM7_CFGDTCMSZ_6 = 0x6
	// 64 KB
	IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_CM7_CFGDTCMSZ_7 = 0x7
	// 128 KB
	IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_CM7_CFGDTCMSZ_8 = 0x8

	// GPR16: GPR16 General Purpose Register
	// Position of INIT_ITCM_EN field.
	IOMUXC_GPR_GPR16_INIT_ITCM_EN_Pos = 0x0
	// Bit mask of INIT_ITCM_EN field.
	IOMUXC_GPR_GPR16_INIT_ITCM_EN_Msk = 0x1
	// Bit INIT_ITCM_EN.
	IOMUXC_GPR_GPR16_INIT_ITCM_EN = 0x1
	// ITCM is disabled
	IOMUXC_GPR_GPR16_INIT_ITCM_EN_INIT_ITCM_EN_0 = 0x0
	// ITCM is enabled
	IOMUXC_GPR_GPR16_INIT_ITCM_EN_INIT_ITCM_EN_1 = 0x1
	// Position of INIT_DTCM_EN field.
	IOMUXC_GPR_GPR16_INIT_DTCM_EN_Pos = 0x1
	// Bit mask of INIT_DTCM_EN field.
	IOMUXC_GPR_GPR16_INIT_DTCM_EN_Msk = 0x2
	// Bit INIT_DTCM_EN.
	IOMUXC_GPR_GPR16_INIT_DTCM_EN = 0x2
	// DTCM is disabled
	IOMUXC_GPR_GPR16_INIT_DTCM_EN_INIT_DTCM_EN_0 = 0x0
	// DTCM is enabled
	IOMUXC_GPR_GPR16_INIT_DTCM_EN_INIT_DTCM_EN_1 = 0x1
	// Position of FLEXRAM_BANK_CFG_SEL field.
	IOMUXC_GPR_GPR16_FLEXRAM_BANK_CFG_SEL_Pos = 0x2
	// Bit mask of FLEXRAM_BANK_CFG_SEL field.
	IOMUXC_GPR_GPR16_FLEXRAM_BANK_CFG_SEL_Msk = 0x4
	// Bit FLEXRAM_BANK_CFG_SEL.
	IOMUXC_GPR_GPR16_FLEXRAM_BANK_CFG_SEL = 0x4
	// use fuse value to config
	IOMUXC_GPR_GPR16_FLEXRAM_BANK_CFG_SEL_FLEXRAM_BANK_CFG_SEL_0 = 0x0
	// use FLEXRAM_BANK_CFG to config
	IOMUXC_GPR_GPR16_FLEXRAM_BANK_CFG_SEL_FLEXRAM_BANK_CFG_SEL_1 = 0x1
	// Position of LOCK_VTOR field.
	IOMUXC_GPR_GPR16_LOCK_VTOR_Pos = 0x6
	// Bit mask of LOCK_VTOR field.
	IOMUXC_GPR_GPR16_LOCK_VTOR_Msk = 0x40
	// Bit LOCK_VTOR.
	IOMUXC_GPR_GPR16_LOCK_VTOR = 0x40
	// CM7_INIT_VTOR field is not locked.
	IOMUXC_GPR_GPR16_LOCK_VTOR_LOCK_VTOR_0 = 0x0
	// CM7_INIT_VTOR field is locked (read access only).
	IOMUXC_GPR_GPR16_LOCK_VTOR_LOCK_VTOR_1 = 0x1
	// Position of CM7_INIT_VTOR field.
	IOMUXC_GPR_GPR16_CM7_INIT_VTOR_Pos = 0x7
	// Bit mask of CM7_INIT_VTOR field.
	IOMUXC_GPR_GPR16_CM7_INIT_VTOR_Msk = 0xffffff80

	// GPR17: GPR17 General Purpose Register
	// Position of FLEXRAM_BANK_CFG field.
	IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_Pos = 0x0
	// Bit mask of FLEXRAM_BANK_CFG field.
	IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_Msk = 0xff

	// GPR18: GPR18 General Purpose Register
	// Position of LOCK_M7_APC_AC_R0_BOT field.
	IOMUXC_GPR_GPR18_LOCK_M7_APC_AC_R0_BOT_Pos = 0x0
	// Bit mask of LOCK_M7_APC_AC_R0_BOT field.
	IOMUXC_GPR_GPR18_LOCK_M7_APC_AC_R0_BOT_Msk = 0x1
	// Bit LOCK_M7_APC_AC_R0_BOT.
	IOMUXC_GPR_GPR18_LOCK_M7_APC_AC_R0_BOT = 0x1
	// Register field [31:1] is not locked
	IOMUXC_GPR_GPR18_LOCK_M7_APC_AC_R0_BOT_LOCK_M7_APC_AC_R0_BOT_0 = 0x0
	// Register field [31:1] is locked (read access only)
	IOMUXC_GPR_GPR18_LOCK_M7_APC_AC_R0_BOT_LOCK_M7_APC_AC_R0_BOT_1 = 0x1
	// Position of M7_APC_AC_R0_BOT field.
	IOMUXC_GPR_GPR18_M7_APC_AC_R0_BOT_Pos = 0x3
	// Bit mask of M7_APC_AC_R0_BOT field.
	IOMUXC_GPR_GPR18_M7_APC_AC_R0_BOT_Msk = 0xfffffff8

	// GPR19: GPR19 General Purpose Register
	// Position of LOCK_M7_APC_AC_R0_TOP field.
	IOMUXC_GPR_GPR19_LOCK_M7_APC_AC_R0_TOP_Pos = 0x0
	// Bit mask of LOCK_M7_APC_AC_R0_TOP field.
	IOMUXC_GPR_GPR19_LOCK_M7_APC_AC_R0_TOP_Msk = 0x1
	// Bit LOCK_M7_APC_AC_R0_TOP.
	IOMUXC_GPR_GPR19_LOCK_M7_APC_AC_R0_TOP = 0x1
	// Register field [31:1] is not locked
	IOMUXC_GPR_GPR19_LOCK_M7_APC_AC_R0_TOP_LOCK_M7_APC_AC_R0_TOP_0 = 0x0
	// Register field [31:1] is locked (read access only)
	IOMUXC_GPR_GPR19_LOCK_M7_APC_AC_R0_TOP_LOCK_M7_APC_AC_R0_TOP_1 = 0x1
	// Position of M7_APC_AC_R0_TOP field.
	IOMUXC_GPR_GPR19_M7_APC_AC_R0_TOP_Pos = 0x3
	// Bit mask of M7_APC_AC_R0_TOP field.
	IOMUXC_GPR_GPR19_M7_APC_AC_R0_TOP_Msk = 0xfffffff8

	// GPR20: GPR20 General Purpose Register
	// Position of LOCK_M7_APC_AC_R1_BOT field.
	IOMUXC_GPR_GPR20_LOCK_M7_APC_AC_R1_BOT_Pos = 0x0
	// Bit mask of LOCK_M7_APC_AC_R1_BOT field.
	IOMUXC_GPR_GPR20_LOCK_M7_APC_AC_R1_BOT_Msk = 0x1
	// Bit LOCK_M7_APC_AC_R1_BOT.
	IOMUXC_GPR_GPR20_LOCK_M7_APC_AC_R1_BOT = 0x1
	// Register field [31:1] is not locked
	IOMUXC_GPR_GPR20_LOCK_M7_APC_AC_R1_BOT_LOCK_M7_APC_AC_R1_BOT_0 = 0x0
	// Register field [31:1] is locked (read access only)
	IOMUXC_GPR_GPR20_LOCK_M7_APC_AC_R1_BOT_LOCK_M7_APC_AC_R1_BOT_1 = 0x1
	// Position of M7_APC_AC_R1_BOT field.
	IOMUXC_GPR_GPR20_M7_APC_AC_R1_BOT_Pos = 0x3
	// Bit mask of M7_APC_AC_R1_BOT field.
	IOMUXC_GPR_GPR20_M7_APC_AC_R1_BOT_Msk = 0xfffffff8

	// GPR21: GPR21 General Purpose Register
	// Position of LOCK_M7_APC_AC_R1_TOP field.
	IOMUXC_GPR_GPR21_LOCK_M7_APC_AC_R1_TOP_Pos = 0x0
	// Bit mask of LOCK_M7_APC_AC_R1_TOP field.
	IOMUXC_GPR_GPR21_LOCK_M7_APC_AC_R1_TOP_Msk = 0x1
	// Bit LOCK_M7_APC_AC_R1_TOP.
	IOMUXC_GPR_GPR21_LOCK_M7_APC_AC_R1_TOP = 0x1
	// Register field [31:1] is not locked
	IOMUXC_GPR_GPR21_LOCK_M7_APC_AC_R1_TOP_LOCK_M7_APC_AC_R1_TOP_0 = 0x0
	// Register field [31:1] is locked (read access only)
	IOMUXC_GPR_GPR21_LOCK_M7_APC_AC_R1_TOP_LOCK_M7_APC_AC_R1_TOP_1 = 0x1
	// Position of M7_APC_AC_R1_TOP field.
	IOMUXC_GPR_GPR21_M7_APC_AC_R1_TOP_Pos = 0x3
	// Bit mask of M7_APC_AC_R1_TOP field.
	IOMUXC_GPR_GPR21_M7_APC_AC_R1_TOP_Msk = 0xfffffff8

	// GPR22: GPR22 General Purpose Register
	// Position of LOCK_M7_APC_AC_R2_BOT field.
	IOMUXC_GPR_GPR22_LOCK_M7_APC_AC_R2_BOT_Pos = 0x0
	// Bit mask of LOCK_M7_APC_AC_R2_BOT field.
	IOMUXC_GPR_GPR22_LOCK_M7_APC_AC_R2_BOT_Msk = 0x1
	// Bit LOCK_M7_APC_AC_R2_BOT.
	IOMUXC_GPR_GPR22_LOCK_M7_APC_AC_R2_BOT = 0x1
	// Register field [31:1] is not locked
	IOMUXC_GPR_GPR22_LOCK_M7_APC_AC_R2_BOT_LOCK_M7_APC_AC_R2_BOT_0 = 0x0
	// Register field [31:1] is locked (read access only)
	IOMUXC_GPR_GPR22_LOCK_M7_APC_AC_R2_BOT_LOCK_M7_APC_AC_R2_BOT_1 = 0x1
	// Position of M7_APC_AC_R2_BOT field.
	IOMUXC_GPR_GPR22_M7_APC_AC_R2_BOT_Pos = 0x3
	// Bit mask of M7_APC_AC_R2_BOT field.
	IOMUXC_GPR_GPR22_M7_APC_AC_R2_BOT_Msk = 0xfffffff8

	// GPR23: GPR23 General Purpose Register
	// Position of LOCK_M7_APC_AC_R2_TOP field.
	IOMUXC_GPR_GPR23_LOCK_M7_APC_AC_R2_TOP_Pos = 0x0
	// Bit mask of LOCK_M7_APC_AC_R2_TOP field.
	IOMUXC_GPR_GPR23_LOCK_M7_APC_AC_R2_TOP_Msk = 0x1
	// Bit LOCK_M7_APC_AC_R2_TOP.
	IOMUXC_GPR_GPR23_LOCK_M7_APC_AC_R2_TOP = 0x1
	// Register field [31:1] is not locked
	IOMUXC_GPR_GPR23_LOCK_M7_APC_AC_R2_TOP_LOCK_M7_APC_AC_R2_TOP_0 = 0x0
	// Register field [31:1] is locked (read access only)
	IOMUXC_GPR_GPR23_LOCK_M7_APC_AC_R2_TOP_LOCK_M7_APC_AC_R2_TOP_1 = 0x1
	// Position of M7_APC_AC_R2_TOP field.
	IOMUXC_GPR_GPR23_M7_APC_AC_R2_TOP_Pos = 0x3
	// Bit mask of M7_APC_AC_R2_TOP field.
	IOMUXC_GPR_GPR23_M7_APC_AC_R2_TOP_Msk = 0xfffffff8

	// GPR24: GPR24 General Purpose Register
	// Position of LOCK_M7_APC_AC_R3_BOT field.
	IOMUXC_GPR_GPR24_LOCK_M7_APC_AC_R3_BOT_Pos = 0x0
	// Bit mask of LOCK_M7_APC_AC_R3_BOT field.
	IOMUXC_GPR_GPR24_LOCK_M7_APC_AC_R3_BOT_Msk = 0x1
	// Bit LOCK_M7_APC_AC_R3_BOT.
	IOMUXC_GPR_GPR24_LOCK_M7_APC_AC_R3_BOT = 0x1
	// Register field [31:1] is not locked
	IOMUXC_GPR_GPR24_LOCK_M7_APC_AC_R3_BOT_LOCK_M7_APC_AC_R3_BOT_0 = 0x0
	// Register field [31:1] is locked (read access only)
	IOMUXC_GPR_GPR24_LOCK_M7_APC_AC_R3_BOT_LOCK_M7_APC_AC_R3_BOT_1 = 0x1
	// Position of M7_APC_AC_R3_BOT field.
	IOMUXC_GPR_GPR24_M7_APC_AC_R3_BOT_Pos = 0x3
	// Bit mask of M7_APC_AC_R3_BOT field.
	IOMUXC_GPR_GPR24_M7_APC_AC_R3_BOT_Msk = 0xfffffff8

	// GPR25: GPR25 General Purpose Register
	// Position of LOCK_M7_APC_AC_R3_TOP field.
	IOMUXC_GPR_GPR25_LOCK_M7_APC_AC_R3_TOP_Pos = 0x0
	// Bit mask of LOCK_M7_APC_AC_R3_TOP field.
	IOMUXC_GPR_GPR25_LOCK_M7_APC_AC_R3_TOP_Msk = 0x1
	// Bit LOCK_M7_APC_AC_R3_TOP.
	IOMUXC_GPR_GPR25_LOCK_M7_APC_AC_R3_TOP = 0x1
	// Register field [31:1] is not locked
	IOMUXC_GPR_GPR25_LOCK_M7_APC_AC_R3_TOP_LOCK_M7_APC_AC_R3_TOP_0 = 0x0
	// Register field [31:1] is locked (read access only)
	IOMUXC_GPR_GPR25_LOCK_M7_APC_AC_R3_TOP_LOCK_M7_APC_AC_R3_TOP_1 = 0x1
	// Position of M7_APC_AC_R3_TOP field.
	IOMUXC_GPR_GPR25_M7_APC_AC_R3_TOP_Pos = 0x3
	// Bit mask of M7_APC_AC_R3_TOP field.
	IOMUXC_GPR_GPR25_M7_APC_AC_R3_TOP_Msk = 0xfffffff8

	// GPR26: GPR26 General Purpose Register
	// Position of GPIO_SEL field.
	IOMUXC_GPR_GPR26_GPIO_SEL_Pos = 0x0
	// Bit mask of GPIO_SEL field.
	IOMUXC_GPR_GPR26_GPIO_SEL_Msk = 0xffffffff

	// GPR27: GPR27 General Purpose Register
	// Position of FLEXSPI_REMAP_ADDR_START field.
	IOMUXC_GPR_GPR27_FLEXSPI_REMAP_ADDR_START_Pos = 0xc
	// Bit mask of FLEXSPI_REMAP_ADDR_START field.
	IOMUXC_GPR_GPR27_FLEXSPI_REMAP_ADDR_START_Msk = 0xfffff000

	// GPR28: GPR28 General Purpose Register
	// Position of FLEXSPI_REMAP_ADDR_END field.
	IOMUXC_GPR_GPR28_FLEXSPI_REMAP_ADDR_END_Pos = 0xc
	// Bit mask of FLEXSPI_REMAP_ADDR_END field.
	IOMUXC_GPR_GPR28_FLEXSPI_REMAP_ADDR_END_Msk = 0xfffff000

	// GPR29: GPR29 General Purpose Register
	// Position of FLEXSPI_REMAP_ADDR_OFFSET field.
	IOMUXC_GPR_GPR29_FLEXSPI_REMAP_ADDR_OFFSET_Pos = 0xc
	// Bit mask of FLEXSPI_REMAP_ADDR_OFFSET field.
	IOMUXC_GPR_GPR29_FLEXSPI_REMAP_ADDR_OFFSET_Msk = 0xfffff000
)

// Constants for FLEXRAM: FLEXRAM
const (
	// TCM_CTRL: TCM CRTL Register
	// Position of TCM_WWAIT_EN field.
	FLEXRAM_TCM_CTRL_TCM_WWAIT_EN_Pos = 0x0
	// Bit mask of TCM_WWAIT_EN field.
	FLEXRAM_TCM_CTRL_TCM_WWAIT_EN_Msk = 0x1
	// Bit TCM_WWAIT_EN.
	FLEXRAM_TCM_CTRL_TCM_WWAIT_EN = 0x1
	// TCM write fast mode: Write RAM accesses are expected to be finished in 1-cycle.
	FLEXRAM_TCM_CTRL_TCM_WWAIT_EN_TCM_WWAIT_EN_0 = 0x0
	// TCM write wait mode: Write RAM accesses are expected to be finished in 2-cycles.
	FLEXRAM_TCM_CTRL_TCM_WWAIT_EN_TCM_WWAIT_EN_1 = 0x1
	// Position of TCM_RWAIT_EN field.
	FLEXRAM_TCM_CTRL_TCM_RWAIT_EN_Pos = 0x1
	// Bit mask of TCM_RWAIT_EN field.
	FLEXRAM_TCM_CTRL_TCM_RWAIT_EN_Msk = 0x2
	// Bit TCM_RWAIT_EN.
	FLEXRAM_TCM_CTRL_TCM_RWAIT_EN = 0x2
	// TCM read fast mode: Read RAM accesses are expected to be finished in 1-cycle.
	FLEXRAM_TCM_CTRL_TCM_RWAIT_EN_TCM_RWAIT_EN_0 = 0x0
	// TCM read wait mode: Read RAM accesses are expected to be finished in 2-cycles.
	FLEXRAM_TCM_CTRL_TCM_RWAIT_EN_TCM_RWAIT_EN_1 = 0x1
	// Position of FORCE_CLK_ON field.
	FLEXRAM_TCM_CTRL_FORCE_CLK_ON_Pos = 0x2
	// Bit mask of FORCE_CLK_ON field.
	FLEXRAM_TCM_CTRL_FORCE_CLK_ON_Msk = 0x4
	// Bit FORCE_CLK_ON.
	FLEXRAM_TCM_CTRL_FORCE_CLK_ON = 0x4

	// OCRAM_MAGIC_ADDR: OCRAM Magic Address Register
	// Position of OCRAM_WR_RD_SEL field.
	FLEXRAM_OCRAM_MAGIC_ADDR_OCRAM_WR_RD_SEL_Pos = 0x0
	// Bit mask of OCRAM_WR_RD_SEL field.
	FLEXRAM_OCRAM_MAGIC_ADDR_OCRAM_WR_RD_SEL_Msk = 0x1
	// Bit OCRAM_WR_RD_SEL.
	FLEXRAM_OCRAM_MAGIC_ADDR_OCRAM_WR_RD_SEL = 0x1
	// When OCRAM read access hits magic address, it will generate interrupt.
	FLEXRAM_OCRAM_MAGIC_ADDR_OCRAM_WR_RD_SEL_OCRAM_WR_RD_SEL_0 = 0x0
	// When OCRAM write access hits magic address, it will generate interrupt.
	FLEXRAM_OCRAM_MAGIC_ADDR_OCRAM_WR_RD_SEL_OCRAM_WR_RD_SEL_1 = 0x1
	// Position of OCRAM_MAGIC_ADDR field.
	FLEXRAM_OCRAM_MAGIC_ADDR_OCRAM_MAGIC_ADDR_Pos = 0x1
	// Bit mask of OCRAM_MAGIC_ADDR field.
	FLEXRAM_OCRAM_MAGIC_ADDR_OCRAM_MAGIC_ADDR_Msk = 0x7ffe

	// DTCM_MAGIC_ADDR: DTCM Magic Address Register
	// Position of DTCM_WR_RD_SEL field.
	FLEXRAM_DTCM_MAGIC_ADDR_DTCM_WR_RD_SEL_Pos = 0x0
	// Bit mask of DTCM_WR_RD_SEL field.
	FLEXRAM_DTCM_MAGIC_ADDR_DTCM_WR_RD_SEL_Msk = 0x1
	// Bit DTCM_WR_RD_SEL.
	FLEXRAM_DTCM_MAGIC_ADDR_DTCM_WR_RD_SEL = 0x1
	// When DTCM read access hits magic address, it will generate interrupt.
	FLEXRAM_DTCM_MAGIC_ADDR_DTCM_WR_RD_SEL_DTCM_WR_RD_SEL_0 = 0x0
	// When DTCM write access hits magic address, it will generate interrupt.
	FLEXRAM_DTCM_MAGIC_ADDR_DTCM_WR_RD_SEL_DTCM_WR_RD_SEL_1 = 0x1
	// Position of DTCM_MAGIC_ADDR field.
	FLEXRAM_DTCM_MAGIC_ADDR_DTCM_MAGIC_ADDR_Pos = 0x1
	// Bit mask of DTCM_MAGIC_ADDR field.
	FLEXRAM_DTCM_MAGIC_ADDR_DTCM_MAGIC_ADDR_Msk = 0x7ffe

	// ITCM_MAGIC_ADDR: ITCM Magic Address Register
	// Position of ITCM_WR_RD_SEL field.
	FLEXRAM_ITCM_MAGIC_ADDR_ITCM_WR_RD_SEL_Pos = 0x0
	// Bit mask of ITCM_WR_RD_SEL field.
	FLEXRAM_ITCM_MAGIC_ADDR_ITCM_WR_RD_SEL_Msk = 0x1
	// Bit ITCM_WR_RD_SEL.
	FLEXRAM_ITCM_MAGIC_ADDR_ITCM_WR_RD_SEL = 0x1
	// When ITCM read access hits magic address, it will generate interrupt.
	FLEXRAM_ITCM_MAGIC_ADDR_ITCM_WR_RD_SEL_ITCM_WR_RD_SEL_0 = 0x0
	// When ITCM write access hits magic address, it will generate interrupt.
	FLEXRAM_ITCM_MAGIC_ADDR_ITCM_WR_RD_SEL_ITCM_WR_RD_SEL_1 = 0x1
	// Position of ITCM_MAGIC_ADDR field.
	FLEXRAM_ITCM_MAGIC_ADDR_ITCM_MAGIC_ADDR_Pos = 0x1
	// Bit mask of ITCM_MAGIC_ADDR field.
	FLEXRAM_ITCM_MAGIC_ADDR_ITCM_MAGIC_ADDR_Msk = 0x7ffe

	// INT_STATUS: Interrupt Status Register
	// Position of ITCM_MAM_STATUS field.
	FLEXRAM_INT_STATUS_ITCM_MAM_STATUS_Pos = 0x0
	// Bit mask of ITCM_MAM_STATUS field.
	FLEXRAM_INT_STATUS_ITCM_MAM_STATUS_Msk = 0x1
	// Bit ITCM_MAM_STATUS.
	FLEXRAM_INT_STATUS_ITCM_MAM_STATUS = 0x1
	// ITCM did not access magic address.
	FLEXRAM_INT_STATUS_ITCM_MAM_STATUS_ITCM_MAM_STATUS_0 = 0x0
	// ITCM accessed magic address.
	FLEXRAM_INT_STATUS_ITCM_MAM_STATUS_ITCM_MAM_STATUS_1 = 0x1
	// Position of DTCM_MAM_STATUS field.
	FLEXRAM_INT_STATUS_DTCM_MAM_STATUS_Pos = 0x1
	// Bit mask of DTCM_MAM_STATUS field.
	FLEXRAM_INT_STATUS_DTCM_MAM_STATUS_Msk = 0x2
	// Bit DTCM_MAM_STATUS.
	FLEXRAM_INT_STATUS_DTCM_MAM_STATUS = 0x2
	// DTCM did not access magic address.
	FLEXRAM_INT_STATUS_DTCM_MAM_STATUS_DTCM_MAM_STATUS_0 = 0x0
	// DTCM accessed magic address.
	FLEXRAM_INT_STATUS_DTCM_MAM_STATUS_DTCM_MAM_STATUS_1 = 0x1
	// Position of OCRAM_MAM_STATUS field.
	FLEXRAM_INT_STATUS_OCRAM_MAM_STATUS_Pos = 0x2
	// Bit mask of OCRAM_MAM_STATUS field.
	FLEXRAM_INT_STATUS_OCRAM_MAM_STATUS_Msk = 0x4
	// Bit OCRAM_MAM_STATUS.
	FLEXRAM_INT_STATUS_OCRAM_MAM_STATUS = 0x4
	// OCRAM did not access magic address.
	FLEXRAM_INT_STATUS_OCRAM_MAM_STATUS_OCRAM_MAM_STATUS_0 = 0x0
	// OCRAM accessed magic address.
	FLEXRAM_INT_STATUS_OCRAM_MAM_STATUS_OCRAM_MAM_STATUS_1 = 0x1
	// Position of ITCM_ERR_STATUS field.
	FLEXRAM_INT_STATUS_ITCM_ERR_STATUS_Pos = 0x3
	// Bit mask of ITCM_ERR_STATUS field.
	FLEXRAM_INT_STATUS_ITCM_ERR_STATUS_Msk = 0x8
	// Bit ITCM_ERR_STATUS.
	FLEXRAM_INT_STATUS_ITCM_ERR_STATUS = 0x8
	// ITCM access error does not happen
	FLEXRAM_INT_STATUS_ITCM_ERR_STATUS_ITCM_ERR_STATUS_0 = 0x0
	// ITCM access error happens.
	FLEXRAM_INT_STATUS_ITCM_ERR_STATUS_ITCM_ERR_STATUS_1 = 0x1
	// Position of DTCM_ERR_STATUS field.
	FLEXRAM_INT_STATUS_DTCM_ERR_STATUS_Pos = 0x4
	// Bit mask of DTCM_ERR_STATUS field.
	FLEXRAM_INT_STATUS_DTCM_ERR_STATUS_Msk = 0x10
	// Bit DTCM_ERR_STATUS.
	FLEXRAM_INT_STATUS_DTCM_ERR_STATUS = 0x10
	// DTCM access error does not happen
	FLEXRAM_INT_STATUS_DTCM_ERR_STATUS_DTCM_ERR_STATUS_0 = 0x0
	// DTCM access error happens.
	FLEXRAM_INT_STATUS_DTCM_ERR_STATUS_DTCM_ERR_STATUS_1 = 0x1
	// Position of OCRAM_ERR_STATUS field.
	FLEXRAM_INT_STATUS_OCRAM_ERR_STATUS_Pos = 0x5
	// Bit mask of OCRAM_ERR_STATUS field.
	FLEXRAM_INT_STATUS_OCRAM_ERR_STATUS_Msk = 0x20
	// Bit OCRAM_ERR_STATUS.
	FLEXRAM_INT_STATUS_OCRAM_ERR_STATUS = 0x20
	// OCRAM access error does not happen
	FLEXRAM_INT_STATUS_OCRAM_ERR_STATUS_OCRAM_ERR_STATUS_0 = 0x0
	// OCRAM access error happens.
	FLEXRAM_INT_STATUS_OCRAM_ERR_STATUS_OCRAM_ERR_STATUS_1 = 0x1

	// INT_STAT_EN: Interrupt Status Enable Register
	// Position of ITCM_MAM_STAT_EN field.
	FLEXRAM_INT_STAT_EN_ITCM_MAM_STAT_EN_Pos = 0x0
	// Bit mask of ITCM_MAM_STAT_EN field.
	FLEXRAM_INT_STAT_EN_ITCM_MAM_STAT_EN_Msk = 0x1
	// Bit ITCM_MAM_STAT_EN.
	FLEXRAM_INT_STAT_EN_ITCM_MAM_STAT_EN = 0x1
	// Masked
	FLEXRAM_INT_STAT_EN_ITCM_MAM_STAT_EN_ITCM_MAM_STAT_EN_0 = 0x0
	// Enabled
	FLEXRAM_INT_STAT_EN_ITCM_MAM_STAT_EN_ITCM_MAM_STAT_EN_1 = 0x1
	// Position of DTCM_MAM_STAT_EN field.
	FLEXRAM_INT_STAT_EN_DTCM_MAM_STAT_EN_Pos = 0x1
	// Bit mask of DTCM_MAM_STAT_EN field.
	FLEXRAM_INT_STAT_EN_DTCM_MAM_STAT_EN_Msk = 0x2
	// Bit DTCM_MAM_STAT_EN.
	FLEXRAM_INT_STAT_EN_DTCM_MAM_STAT_EN = 0x2
	// Masked
	FLEXRAM_INT_STAT_EN_DTCM_MAM_STAT_EN_DTCM_MAM_STAT_EN_0 = 0x0
	// Enabled
	FLEXRAM_INT_STAT_EN_DTCM_MAM_STAT_EN_DTCM_MAM_STAT_EN_1 = 0x1
	// Position of OCRAM_MAM_STAT_EN field.
	FLEXRAM_INT_STAT_EN_OCRAM_MAM_STAT_EN_Pos = 0x2
	// Bit mask of OCRAM_MAM_STAT_EN field.
	FLEXRAM_INT_STAT_EN_OCRAM_MAM_STAT_EN_Msk = 0x4
	// Bit OCRAM_MAM_STAT_EN.
	FLEXRAM_INT_STAT_EN_OCRAM_MAM_STAT_EN = 0x4
	// Masked
	FLEXRAM_INT_STAT_EN_OCRAM_MAM_STAT_EN_OCRAM_MAM_STAT_EN_0 = 0x0
	// Enabled
	FLEXRAM_INT_STAT_EN_OCRAM_MAM_STAT_EN_OCRAM_MAM_STAT_EN_1 = 0x1
	// Position of ITCM_ERR_STAT_EN field.
	FLEXRAM_INT_STAT_EN_ITCM_ERR_STAT_EN_Pos = 0x3
	// Bit mask of ITCM_ERR_STAT_EN field.
	FLEXRAM_INT_STAT_EN_ITCM_ERR_STAT_EN_Msk = 0x8
	// Bit ITCM_ERR_STAT_EN.
	FLEXRAM_INT_STAT_EN_ITCM_ERR_STAT_EN = 0x8
	// Masked
	FLEXRAM_INT_STAT_EN_ITCM_ERR_STAT_EN_ITCM_ERR_STAT_EN_0 = 0x0
	// Enabled
	FLEXRAM_INT_STAT_EN_ITCM_ERR_STAT_EN_ITCM_ERR_STAT_EN_1 = 0x1
	// Position of DTCM_ERR_STAT_EN field.
	FLEXRAM_INT_STAT_EN_DTCM_ERR_STAT_EN_Pos = 0x4
	// Bit mask of DTCM_ERR_STAT_EN field.
	FLEXRAM_INT_STAT_EN_DTCM_ERR_STAT_EN_Msk = 0x10
	// Bit DTCM_ERR_STAT_EN.
	FLEXRAM_INT_STAT_EN_DTCM_ERR_STAT_EN = 0x10
	// Masked
	FLEXRAM_INT_STAT_EN_DTCM_ERR_STAT_EN_DTCM_ERR_STAT_EN_0 = 0x0
	// Enabled
	FLEXRAM_INT_STAT_EN_DTCM_ERR_STAT_EN_DTCM_ERR_STAT_EN_1 = 0x1
	// Position of OCRAM_ERR_STAT_EN field.
	FLEXRAM_INT_STAT_EN_OCRAM_ERR_STAT_EN_Pos = 0x5
	// Bit mask of OCRAM_ERR_STAT_EN field.
	FLEXRAM_INT_STAT_EN_OCRAM_ERR_STAT_EN_Msk = 0x20
	// Bit OCRAM_ERR_STAT_EN.
	FLEXRAM_INT_STAT_EN_OCRAM_ERR_STAT_EN = 0x20
	// Masked
	FLEXRAM_INT_STAT_EN_OCRAM_ERR_STAT_EN_OCRAM_ERR_STAT_EN_0 = 0x0
	// Enabled
	FLEXRAM_INT_STAT_EN_OCRAM_ERR_STAT_EN_OCRAM_ERR_STAT_EN_1 = 0x1

	// INT_SIG_EN: Interrupt Enable Register
	// Position of ITCM_MAM_SIG_EN field.
	FLEXRAM_INT_SIG_EN_ITCM_MAM_SIG_EN_Pos = 0x0
	// Bit mask of ITCM_MAM_SIG_EN field.
	FLEXRAM_INT_SIG_EN_ITCM_MAM_SIG_EN_Msk = 0x1
	// Bit ITCM_MAM_SIG_EN.
	FLEXRAM_INT_SIG_EN_ITCM_MAM_SIG_EN = 0x1
	// Masked
	FLEXRAM_INT_SIG_EN_ITCM_MAM_SIG_EN_ITCM_MAM_SIG_EN_0 = 0x0
	// Enabled
	FLEXRAM_INT_SIG_EN_ITCM_MAM_SIG_EN_ITCM_MAM_SIG_EN_1 = 0x1
	// Position of DTCM_MAM_SIG_EN field.
	FLEXRAM_INT_SIG_EN_DTCM_MAM_SIG_EN_Pos = 0x1
	// Bit mask of DTCM_MAM_SIG_EN field.
	FLEXRAM_INT_SIG_EN_DTCM_MAM_SIG_EN_Msk = 0x2
	// Bit DTCM_MAM_SIG_EN.
	FLEXRAM_INT_SIG_EN_DTCM_MAM_SIG_EN = 0x2
	// Masked
	FLEXRAM_INT_SIG_EN_DTCM_MAM_SIG_EN_DTCM_MAM_SIG_EN_0 = 0x0
	// Enabled
	FLEXRAM_INT_SIG_EN_DTCM_MAM_SIG_EN_DTCM_MAM_SIG_EN_1 = 0x1
	// Position of OCRAM_MAM_SIG_EN field.
	FLEXRAM_INT_SIG_EN_OCRAM_MAM_SIG_EN_Pos = 0x2
	// Bit mask of OCRAM_MAM_SIG_EN field.
	FLEXRAM_INT_SIG_EN_OCRAM_MAM_SIG_EN_Msk = 0x4
	// Bit OCRAM_MAM_SIG_EN.
	FLEXRAM_INT_SIG_EN_OCRAM_MAM_SIG_EN = 0x4
	// Masked
	FLEXRAM_INT_SIG_EN_OCRAM_MAM_SIG_EN_OCRAM_MAM_SIG_EN_0 = 0x0
	// Enabled
	FLEXRAM_INT_SIG_EN_OCRAM_MAM_SIG_EN_OCRAM_MAM_SIG_EN_1 = 0x1
	// Position of ITCM_ERR_SIG_EN field.
	FLEXRAM_INT_SIG_EN_ITCM_ERR_SIG_EN_Pos = 0x3
	// Bit mask of ITCM_ERR_SIG_EN field.
	FLEXRAM_INT_SIG_EN_ITCM_ERR_SIG_EN_Msk = 0x8
	// Bit ITCM_ERR_SIG_EN.
	FLEXRAM_INT_SIG_EN_ITCM_ERR_SIG_EN = 0x8
	// Masked
	FLEXRAM_INT_SIG_EN_ITCM_ERR_SIG_EN_ITCM_ERR_SIG_EN_0 = 0x0
	// Enabled
	FLEXRAM_INT_SIG_EN_ITCM_ERR_SIG_EN_ITCM_ERR_SIG_EN_1 = 0x1
	// Position of DTCM_ERR_SIG_EN field.
	FLEXRAM_INT_SIG_EN_DTCM_ERR_SIG_EN_Pos = 0x4
	// Bit mask of DTCM_ERR_SIG_EN field.
	FLEXRAM_INT_SIG_EN_DTCM_ERR_SIG_EN_Msk = 0x10
	// Bit DTCM_ERR_SIG_EN.
	FLEXRAM_INT_SIG_EN_DTCM_ERR_SIG_EN = 0x10
	// Masked
	FLEXRAM_INT_SIG_EN_DTCM_ERR_SIG_EN_DTCM_ERR_SIG_EN_0 = 0x0
	// Enabled
	FLEXRAM_INT_SIG_EN_DTCM_ERR_SIG_EN_DTCM_ERR_SIG_EN_1 = 0x1
	// Position of OCRAM_ERR_SIG_EN field.
	FLEXRAM_INT_SIG_EN_OCRAM_ERR_SIG_EN_Pos = 0x5
	// Bit mask of OCRAM_ERR_SIG_EN field.
	FLEXRAM_INT_SIG_EN_OCRAM_ERR_SIG_EN_Msk = 0x20
	// Bit OCRAM_ERR_SIG_EN.
	FLEXRAM_INT_SIG_EN_OCRAM_ERR_SIG_EN = 0x20
	// Masked
	FLEXRAM_INT_SIG_EN_OCRAM_ERR_SIG_EN_OCRAM_ERR_SIG_EN_0 = 0x0
	// Enabled
	FLEXRAM_INT_SIG_EN_OCRAM_ERR_SIG_EN_OCRAM_ERR_SIG_EN_1 = 0x1
)

// Constants for EWM: EWM
const (
	// CTRL: Control Register
	// Position of EWMEN field.
	EWM_CTRL_EWMEN_Pos = 0x0
	// Bit mask of EWMEN field.
	EWM_CTRL_EWMEN_Msk = 0x1
	// Bit EWMEN.
	EWM_CTRL_EWMEN = 0x1
	// Position of ASSIN field.
	EWM_CTRL_ASSIN_Pos = 0x1
	// Bit mask of ASSIN field.
	EWM_CTRL_ASSIN_Msk = 0x2
	// Bit ASSIN.
	EWM_CTRL_ASSIN = 0x2
	// Position of INEN field.
	EWM_CTRL_INEN_Pos = 0x2
	// Bit mask of INEN field.
	EWM_CTRL_INEN_Msk = 0x4
	// Bit INEN.
	EWM_CTRL_INEN = 0x4
	// Position of INTEN field.
	EWM_CTRL_INTEN_Pos = 0x3
	// Bit mask of INTEN field.
	EWM_CTRL_INTEN_Msk = 0x8
	// Bit INTEN.
	EWM_CTRL_INTEN = 0x8

	// SERV: Service Register
	// Position of SERVICE field.
	EWM_SERV_SERVICE_Pos = 0x0
	// Bit mask of SERVICE field.
	EWM_SERV_SERVICE_Msk = 0xff

	// CMPL: Compare Low Register
	// Position of COMPAREL field.
	EWM_CMPL_COMPAREL_Pos = 0x0
	// Bit mask of COMPAREL field.
	EWM_CMPL_COMPAREL_Msk = 0xff

	// CMPH: Compare High Register
	// Position of COMPAREH field.
	EWM_CMPH_COMPAREH_Pos = 0x0
	// Bit mask of COMPAREH field.
	EWM_CMPH_COMPAREH_Msk = 0xff

	// CLKCTRL: Clock Control Register
	// Position of CLKSEL field.
	EWM_CLKCTRL_CLKSEL_Pos = 0x0
	// Bit mask of CLKSEL field.
	EWM_CLKCTRL_CLKSEL_Msk = 0x3

	// CLKPRESCALER: Clock Prescaler Register
	// Position of CLK_DIV field.
	EWM_CLKPRESCALER_CLK_DIV_Pos = 0x0
	// Bit mask of CLK_DIV field.
	EWM_CLKPRESCALER_CLK_DIV_Msk = 0xff
)

// Constants for WDOG1: WDOG
const (
	// WCR: Watchdog Control Register
	// Position of WDZST field.
	WDOG_WCR_WDZST_Pos = 0x0
	// Bit mask of WDZST field.
	WDOG_WCR_WDZST_Msk = 0x1
	// Bit WDZST.
	WDOG_WCR_WDZST = 0x1
	// Continue timer operation (Default).
	WDOG_WCR_WDZST_WDZST_0 = 0x0
	// Suspend the watchdog timer.
	WDOG_WCR_WDZST_WDZST_1 = 0x1
	// Position of WDBG field.
	WDOG_WCR_WDBG_Pos = 0x1
	// Bit mask of WDBG field.
	WDOG_WCR_WDBG_Msk = 0x2
	// Bit WDBG.
	WDOG_WCR_WDBG = 0x2
	// Continue WDOG timer operation (Default).
	WDOG_WCR_WDBG_WDBG_0 = 0x0
	// Suspend the watchdog timer.
	WDOG_WCR_WDBG_WDBG_1 = 0x1
	// Position of WDE field.
	WDOG_WCR_WDE_Pos = 0x2
	// Bit mask of WDE field.
	WDOG_WCR_WDE_Msk = 0x4
	// Bit WDE.
	WDOG_WCR_WDE = 0x4
	// Disable the Watchdog (Default).
	WDOG_WCR_WDE_WDE_0 = 0x0
	// Enable the Watchdog.
	WDOG_WCR_WDE_WDE_1 = 0x1
	// Position of WDT field.
	WDOG_WCR_WDT_Pos = 0x3
	// Bit mask of WDT field.
	WDOG_WCR_WDT_Msk = 0x8
	// Bit WDT.
	WDOG_WCR_WDT = 0x8
	// No effect on WDOG_B (Default).
	WDOG_WCR_WDT_WDT_0 = 0x0
	// Assert WDOG_B upon a Watchdog Time-out event.
	WDOG_WCR_WDT_WDT_1 = 0x1
	// Position of SRS field.
	WDOG_WCR_SRS_Pos = 0x4
	// Bit mask of SRS field.
	WDOG_WCR_SRS_Msk = 0x10
	// Bit SRS.
	WDOG_WCR_SRS = 0x10
	// Assert system reset signal.
	WDOG_WCR_SRS_SRS_0 = 0x0
	// No effect on the system (Default).
	WDOG_WCR_SRS_SRS_1 = 0x1
	// Position of WDA field.
	WDOG_WCR_WDA_Pos = 0x5
	// Bit mask of WDA field.
	WDOG_WCR_WDA_Msk = 0x20
	// Bit WDA.
	WDOG_WCR_WDA = 0x20
	// Assert WDOG_B output.
	WDOG_WCR_WDA_WDA_0 = 0x0
	// No effect on system (Default).
	WDOG_WCR_WDA_WDA_1 = 0x1
	// Position of SRE field.
	WDOG_WCR_SRE_Pos = 0x6
	// Bit mask of SRE field.
	WDOG_WCR_SRE_Msk = 0x40
	// Bit SRE.
	WDOG_WCR_SRE = 0x40
	// using original way to generate software reset (default)
	WDOG_WCR_SRE_SRE_0 = 0x0
	// using new way to generate software reset.
	WDOG_WCR_SRE_SRE_1 = 0x1
	// Position of WDW field.
	WDOG_WCR_WDW_Pos = 0x7
	// Bit mask of WDW field.
	WDOG_WCR_WDW_Msk = 0x80
	// Bit WDW.
	WDOG_WCR_WDW = 0x80
	// Continue WDOG timer operation (Default).
	WDOG_WCR_WDW_WDW_0 = 0x0
	// Suspend WDOG timer operation.
	WDOG_WCR_WDW_WDW_1 = 0x1
	// Position of WT field.
	WDOG_WCR_WT_Pos = 0x8
	// Bit mask of WT field.
	WDOG_WCR_WT_Msk = 0xff00
	// - 0.5 Seconds (Default).
	WDOG_WCR_WT_WT_0 = 0x0
	// - 1.0 Seconds.
	WDOG_WCR_WT_WT_1 = 0x1
	// - 1.5 Seconds.
	WDOG_WCR_WT_WT_2 = 0x2
	// - 2.0 Seconds.
	WDOG_WCR_WT_WT_3 = 0x3
	// - 128 Seconds.
	WDOG_WCR_WT_WT_255 = 0xff

	// WSR: Watchdog Service Register
	// Position of WSR field.
	WDOG_WSR_WSR_Pos = 0x0
	// Bit mask of WSR field.
	WDOG_WSR_WSR_Msk = 0xffff
	// Write to the Watchdog Service Register (WDOG_WSR).
	WDOG_WSR_WSR_WSR_21845 = 0x5555
	// Write to the Watchdog Service Register (WDOG_WSR).
	WDOG_WSR_WSR_WSR_43690 = 0xaaaa

	// WRSR: Watchdog Reset Status Register
	// Position of SFTW field.
	WDOG_WRSR_SFTW_Pos = 0x0
	// Bit mask of SFTW field.
	WDOG_WRSR_SFTW_Msk = 0x1
	// Bit SFTW.
	WDOG_WRSR_SFTW = 0x1
	// Reset is not the result of a software reset.
	WDOG_WRSR_SFTW_SFTW_0 = 0x0
	// Reset is the result of a software reset.
	WDOG_WRSR_SFTW_SFTW_1 = 0x1
	// Position of TOUT field.
	WDOG_WRSR_TOUT_Pos = 0x1
	// Bit mask of TOUT field.
	WDOG_WRSR_TOUT_Msk = 0x2
	// Bit TOUT.
	WDOG_WRSR_TOUT = 0x2
	// Reset is not the result of a WDOG timeout.
	WDOG_WRSR_TOUT_TOUT_0 = 0x0
	// Reset is the result of a WDOG timeout.
	WDOG_WRSR_TOUT_TOUT_1 = 0x1
	// Position of POR field.
	WDOG_WRSR_POR_Pos = 0x4
	// Bit mask of POR field.
	WDOG_WRSR_POR_Msk = 0x10
	// Bit POR.
	WDOG_WRSR_POR = 0x10
	// Reset is not the result of a power on reset.
	WDOG_WRSR_POR_POR_0 = 0x0
	// Reset is the result of a power on reset.
	WDOG_WRSR_POR_POR_1 = 0x1

	// WICR: Watchdog Interrupt Control Register
	// Position of WICT field.
	WDOG_WICR_WICT_Pos = 0x0
	// Bit mask of WICT field.
	WDOG_WICR_WICT_Msk = 0xff
	// WICT[7:0] = Time duration between interrupt and time-out is 0 seconds.
	WDOG_WICR_WICT_WICT_0 = 0x0
	// WICT[7:0] = Time duration between interrupt and time-out is 0.5 seconds.
	WDOG_WICR_WICT_WICT_1 = 0x1
	// WICT[7:0] = Time duration between interrupt and time-out is 2 seconds (Default).
	WDOG_WICR_WICT_WICT_4 = 0x4
	// WICT[7:0] = Time duration between interrupt and time-out is 127.5 seconds.
	WDOG_WICR_WICT_WICT_255 = 0xff
	// Position of WTIS field.
	WDOG_WICR_WTIS_Pos = 0xe
	// Bit mask of WTIS field.
	WDOG_WICR_WTIS_Msk = 0x4000
	// Bit WTIS.
	WDOG_WICR_WTIS = 0x4000
	// No interrupt has occurred (Default).
	WDOG_WICR_WTIS_WTIS_0 = 0x0
	// Interrupt has occurred
	WDOG_WICR_WTIS_WTIS_1 = 0x1
	// Position of WIE field.
	WDOG_WICR_WIE_Pos = 0xf
	// Bit mask of WIE field.
	WDOG_WICR_WIE_Msk = 0x8000
	// Bit WIE.
	WDOG_WICR_WIE = 0x8000
	// Disable Interrupt (Default).
	WDOG_WICR_WIE_WIE_0 = 0x0
	// Enable Interrupt.
	WDOG_WICR_WIE_WIE_1 = 0x1

	// WMCR: Watchdog Miscellaneous Control Register
	// Position of PDE field.
	WDOG_WMCR_PDE_Pos = 0x0
	// Bit mask of PDE field.
	WDOG_WMCR_PDE_Msk = 0x1
	// Bit PDE.
	WDOG_WMCR_PDE = 0x1
	// Power Down Counter of WDOG is disabled.
	WDOG_WMCR_PDE_PDE_0 = 0x0
	// Power Down Counter of WDOG is enabled (Default).
	WDOG_WMCR_PDE_PDE_1 = 0x1
)

// Constants for RTWDOG: WDOG
const (
	// CS: Watchdog Control and Status Register
	// Position of STOP field.
	RTWDOG_CS_STOP_Pos = 0x0
	// Bit mask of STOP field.
	RTWDOG_CS_STOP_Msk = 0x1
	// Bit STOP.
	RTWDOG_CS_STOP = 0x1
	// Watchdog disabled in chip stop mode.
	RTWDOG_CS_STOP_STOP_0 = 0x0
	// Watchdog enabled in chip stop mode.
	RTWDOG_CS_STOP_STOP_1 = 0x1
	// Position of WAIT field.
	RTWDOG_CS_WAIT_Pos = 0x1
	// Bit mask of WAIT field.
	RTWDOG_CS_WAIT_Msk = 0x2
	// Bit WAIT.
	RTWDOG_CS_WAIT = 0x2
	// Watchdog disabled in chip wait mode.
	RTWDOG_CS_WAIT_WAIT_0 = 0x0
	// Watchdog enabled in chip wait mode.
	RTWDOG_CS_WAIT_WAIT_1 = 0x1
	// Position of DBG field.
	RTWDOG_CS_DBG_Pos = 0x2
	// Bit mask of DBG field.
	RTWDOG_CS_DBG_Msk = 0x4
	// Bit DBG.
	RTWDOG_CS_DBG = 0x4
	// Watchdog disabled in chip debug mode.
	RTWDOG_CS_DBG_DBG_0 = 0x0
	// Watchdog enabled in chip debug mode.
	RTWDOG_CS_DBG_DBG_1 = 0x1
	// Position of TST field.
	RTWDOG_CS_TST_Pos = 0x3
	// Bit mask of TST field.
	RTWDOG_CS_TST_Msk = 0x18
	// Watchdog test mode disabled.
	RTWDOG_CS_TST_TST_0 = 0x0
	// Watchdog user mode enabled. (Watchdog test mode disabled.) After testing the watchdog, software should use this setting to indicate that the watchdog is functioning normally in user mode.
	RTWDOG_CS_TST_TST_1 = 0x1
	// Watchdog test mode enabled, only the low byte is used. CNT[CNTLOW] is compared with TOVAL[TOVALLOW].
	RTWDOG_CS_TST_TST_2 = 0x2
	// Watchdog test mode enabled, only the high byte is used. CNT[CNTHIGH] is compared with TOVAL[TOVALHIGH].
	RTWDOG_CS_TST_TST_3 = 0x3
	// Position of UPDATE field.
	RTWDOG_CS_UPDATE_Pos = 0x5
	// Bit mask of UPDATE field.
	RTWDOG_CS_UPDATE_Msk = 0x20
	// Bit UPDATE.
	RTWDOG_CS_UPDATE = 0x20
	// Updates not allowed. After the initial configuration, the watchdog cannot be later modified without forcing a reset.
	RTWDOG_CS_UPDATE_UPDATE_0 = 0x0
	// Updates allowed. Software can modify the watchdog configuration registers within 128 bus clocks after performing the unlock write sequence.
	RTWDOG_CS_UPDATE_UPDATE_1 = 0x1
	// Position of INT field.
	RTWDOG_CS_INT_Pos = 0x6
	// Bit mask of INT field.
	RTWDOG_CS_INT_Msk = 0x40
	// Bit INT.
	RTWDOG_CS_INT = 0x40
	// Watchdog interrupts are disabled. Watchdog resets are not delayed.
	RTWDOG_CS_INT_INT_0 = 0x0
	// Watchdog interrupts are enabled. Watchdog resets are delayed by 128 bus clocks from the interrupt vector fetch.
	RTWDOG_CS_INT_INT_1 = 0x1
	// Position of EN field.
	RTWDOG_CS_EN_Pos = 0x7
	// Bit mask of EN field.
	RTWDOG_CS_EN_Msk = 0x80
	// Bit EN.
	RTWDOG_CS_EN = 0x80
	// Watchdog disabled.
	RTWDOG_CS_EN_EN_0 = 0x0
	// Watchdog enabled.
	RTWDOG_CS_EN_EN_1 = 0x1
	// Position of CLK field.
	RTWDOG_CS_CLK_Pos = 0x8
	// Bit mask of CLK field.
	RTWDOG_CS_CLK_Msk = 0x300
	// Bus clock
	RTWDOG_CS_CLK_CLK_0 = 0x0
	// LPO clock
	RTWDOG_CS_CLK_CLK_1 = 0x1
	// INTCLK (internal clock)
	RTWDOG_CS_CLK_CLK_2 = 0x2
	// ERCLK (external reference clock)
	RTWDOG_CS_CLK_CLK_3 = 0x3
	// Position of RCS field.
	RTWDOG_CS_RCS_Pos = 0xa
	// Bit mask of RCS field.
	RTWDOG_CS_RCS_Msk = 0x400
	// Bit RCS.
	RTWDOG_CS_RCS = 0x400
	// Reconfiguring WDOG.
	RTWDOG_CS_RCS_RCS_0 = 0x0
	// Reconfiguration is successful.
	RTWDOG_CS_RCS_RCS_1 = 0x1
	// Position of ULK field.
	RTWDOG_CS_ULK_Pos = 0xb
	// Bit mask of ULK field.
	RTWDOG_CS_ULK_Msk = 0x800
	// Bit ULK.
	RTWDOG_CS_ULK = 0x800
	// WDOG is locked.
	RTWDOG_CS_ULK_ULK_0 = 0x0
	// WDOG is unlocked.
	RTWDOG_CS_ULK_ULK_1 = 0x1
	// Position of PRES field.
	RTWDOG_CS_PRES_Pos = 0xc
	// Bit mask of PRES field.
	RTWDOG_CS_PRES_Msk = 0x1000
	// Bit PRES.
	RTWDOG_CS_PRES = 0x1000
	// 256 prescaler disabled.
	RTWDOG_CS_PRES_PRES_0 = 0x0
	// 256 prescaler enabled.
	RTWDOG_CS_PRES_PRES_1 = 0x1
	// Position of CMD32EN field.
	RTWDOG_CS_CMD32EN_Pos = 0xd
	// Bit mask of CMD32EN field.
	RTWDOG_CS_CMD32EN_Msk = 0x2000
	// Bit CMD32EN.
	RTWDOG_CS_CMD32EN = 0x2000
	// Disables support for 32-bit refresh/unlock command write words. Only 16-bit or 8-bit is supported.
	RTWDOG_CS_CMD32EN_CMD32EN_0 = 0x0
	// Enables support for 32-bit refresh/unlock command write words. 16-bit or 8-bit is NOT supported.
	RTWDOG_CS_CMD32EN_CMD32EN_1 = 0x1
	// Position of FLG field.
	RTWDOG_CS_FLG_Pos = 0xe
	// Bit mask of FLG field.
	RTWDOG_CS_FLG_Msk = 0x4000
	// Bit FLG.
	RTWDOG_CS_FLG = 0x4000
	// No interrupt occurred.
	RTWDOG_CS_FLG_FLG_0 = 0x0
	// An interrupt occurred.
	RTWDOG_CS_FLG_FLG_1 = 0x1
	// Position of WIN field.
	RTWDOG_CS_WIN_Pos = 0xf
	// Bit mask of WIN field.
	RTWDOG_CS_WIN_Msk = 0x8000
	// Bit WIN.
	RTWDOG_CS_WIN = 0x8000
	// Window mode disabled.
	RTWDOG_CS_WIN_WIN_0 = 0x0
	// Window mode enabled.
	RTWDOG_CS_WIN_WIN_1 = 0x1

	// CNT: Watchdog Counter Register
	// Position of CNTLOW field.
	RTWDOG_CNT_CNTLOW_Pos = 0x0
	// Bit mask of CNTLOW field.
	RTWDOG_CNT_CNTLOW_Msk = 0xff
	// Position of CNTHIGH field.
	RTWDOG_CNT_CNTHIGH_Pos = 0x8
	// Bit mask of CNTHIGH field.
	RTWDOG_CNT_CNTHIGH_Msk = 0xff00

	// TOVAL: Watchdog Timeout Value Register
	// Position of TOVALLOW field.
	RTWDOG_TOVAL_TOVALLOW_Pos = 0x0
	// Bit mask of TOVALLOW field.
	RTWDOG_TOVAL_TOVALLOW_Msk = 0xff
	// Position of TOVALHIGH field.
	RTWDOG_TOVAL_TOVALHIGH_Pos = 0x8
	// Bit mask of TOVALHIGH field.
	RTWDOG_TOVAL_TOVALHIGH_Msk = 0xff00

	// WIN: Watchdog Window Register
	// Position of WINLOW field.
	RTWDOG_WIN_WINLOW_Pos = 0x0
	// Bit mask of WINLOW field.
	RTWDOG_WIN_WINLOW_Msk = 0xff
	// Position of WINHIGH field.
	RTWDOG_WIN_WINHIGH_Pos = 0x8
	// Bit mask of WINHIGH field.
	RTWDOG_WIN_WINHIGH_Msk = 0xff00
)

// Constants for ADC1: Analog-to-Digital Converter
const (
	// HC0: Control register for hardware triggers
	// Position of ADCH field.
	ADC_HC0_ADCH_Pos = 0x0
	// Bit mask of ADCH field.
	ADC_HC0_ADCH_Msk = 0x1f
	// External channel selection from ADC_ETC
	ADC_HC0_ADCH_ADCH_16 = 0x10
	// VREFSH = internal channel, for ADC self-test, hard connected to VRH internally
	ADC_HC0_ADCH_ADCH_25 = 0x19
	// Conversion Disabled. Hardware Triggers will not initiate any conversion.
	ADC_HC0_ADCH_ADCH_31 = 0x1f
	// Position of AIEN field.
	ADC_HC0_AIEN_Pos = 0x7
	// Bit mask of AIEN field.
	ADC_HC0_AIEN_Msk = 0x80
	// Bit AIEN.
	ADC_HC0_AIEN = 0x80
	// Conversion complete interrupt disabled
	ADC_HC0_AIEN_AIEN_0 = 0x0
	// Conversion complete interrupt enabled
	ADC_HC0_AIEN_AIEN_1 = 0x1

	// HC1: Control register for hardware triggers
	// Position of ADCH field.
	ADC_HC_ADCH_Pos = 0x0
	// Bit mask of ADCH field.
	ADC_HC_ADCH_Msk = 0x1f
	// External channel selection from ADC_ETC
	ADC_HC_ADCH_ADCH_16 = 0x10
	// VREFSH = internal channel, for ADC self-test, hard connected to VRH internally
	ADC_HC_ADCH_ADCH_25 = 0x19
	// Conversion Disabled. Hardware Triggers will not initiate any conversion.
	ADC_HC_ADCH_ADCH_31 = 0x1f
	// Position of AIEN field.
	ADC_HC_AIEN_Pos = 0x7
	// Bit mask of AIEN field.
	ADC_HC_AIEN_Msk = 0x80
	// Bit AIEN.
	ADC_HC_AIEN = 0x80
	// Conversion complete interrupt disabled
	ADC_HC_AIEN_AIEN_0 = 0x0
	// Conversion complete interrupt enabled
	ADC_HC_AIEN_AIEN_1 = 0x1

	// HS: Status register for HW triggers
	// Position of COCO0 field.
	ADC_HS_COCO0_Pos = 0x0
	// Bit mask of COCO0 field.
	ADC_HS_COCO0_Msk = 0x1
	// Bit COCO0.
	ADC_HS_COCO0 = 0x1

	// R0: Data result register for HW triggers
	// Position of CDATA field.
	ADC_R0_CDATA_Pos = 0x0
	// Bit mask of CDATA field.
	ADC_R0_CDATA_Msk = 0xfff

	// R1: Data result register for HW triggers
	// Position of CDATA field.
	ADC_R_CDATA_Pos = 0x0
	// Bit mask of CDATA field.
	ADC_R_CDATA_Msk = 0xfff

	// CFG: Configuration register
	// Position of ADICLK field.
	ADC_CFG_ADICLK_Pos = 0x0
	// Bit mask of ADICLK field.
	ADC_CFG_ADICLK_Msk = 0x3
	// IPG clock
	ADC_CFG_ADICLK_ADICLK_0 = 0x0
	// IPG clock divided by 2
	ADC_CFG_ADICLK_ADICLK_1 = 0x1
	// Alternate clock (ALTCLK)
	ADC_CFG_ADICLK_ADICLK_2 = 0x2
	// Asynchronous clock (ADACK)
	ADC_CFG_ADICLK_ADICLK_3 = 0x3
	// Position of MODE field.
	ADC_CFG_MODE_Pos = 0x2
	// Bit mask of MODE field.
	ADC_CFG_MODE_Msk = 0xc
	// 8-bit conversion
	ADC_CFG_MODE_MODE_0 = 0x0
	// 10-bit conversion
	ADC_CFG_MODE_MODE_1 = 0x1
	// 12-bit conversion
	ADC_CFG_MODE_MODE_2 = 0x2
	// Position of ADLSMP field.
	ADC_CFG_ADLSMP_Pos = 0x4
	// Bit mask of ADLSMP field.
	ADC_CFG_ADLSMP_Msk = 0x10
	// Bit ADLSMP.
	ADC_CFG_ADLSMP = 0x10
	// Short sample mode.
	ADC_CFG_ADLSMP_ADLSMP_0 = 0x0
	// Long sample mode.
	ADC_CFG_ADLSMP_ADLSMP_1 = 0x1
	// Position of ADIV field.
	ADC_CFG_ADIV_Pos = 0x5
	// Bit mask of ADIV field.
	ADC_CFG_ADIV_Msk = 0x60
	// Input clock
	ADC_CFG_ADIV_ADIV_0 = 0x0
	// Input clock / 2
	ADC_CFG_ADIV_ADIV_1 = 0x1
	// Input clock / 4
	ADC_CFG_ADIV_ADIV_2 = 0x2
	// Input clock / 8
	ADC_CFG_ADIV_ADIV_3 = 0x3
	// Position of ADLPC field.
	ADC_CFG_ADLPC_Pos = 0x7
	// Bit mask of ADLPC field.
	ADC_CFG_ADLPC_Msk = 0x80
	// Bit ADLPC.
	ADC_CFG_ADLPC = 0x80
	// ADC hard block not in low power mode.
	ADC_CFG_ADLPC_ADLPC_0 = 0x0
	// ADC hard block in low power mode.
	ADC_CFG_ADLPC_ADLPC_1 = 0x1
	// Position of ADSTS field.
	ADC_CFG_ADSTS_Pos = 0x8
	// Bit mask of ADSTS field.
	ADC_CFG_ADSTS_Msk = 0x300
	// Sample period (ADC clocks) = 2 if ADLSMP=0b Sample period (ADC clocks) = 12 if ADLSMP=1b
	ADC_CFG_ADSTS_ADSTS_0 = 0x0
	// Sample period (ADC clocks) = 4 if ADLSMP=0b Sample period (ADC clocks) = 16 if ADLSMP=1b
	ADC_CFG_ADSTS_ADSTS_1 = 0x1
	// Sample period (ADC clocks) = 6 if ADLSMP=0b Sample period (ADC clocks) = 20 if ADLSMP=1b
	ADC_CFG_ADSTS_ADSTS_2 = 0x2
	// Sample period (ADC clocks) = 8 if ADLSMP=0b Sample period (ADC clocks) = 24 if ADLSMP=1b
	ADC_CFG_ADSTS_ADSTS_3 = 0x3
	// Position of ADHSC field.
	ADC_CFG_ADHSC_Pos = 0xa
	// Bit mask of ADHSC field.
	ADC_CFG_ADHSC_Msk = 0x400
	// Bit ADHSC.
	ADC_CFG_ADHSC = 0x400
	// Normal conversion selected.
	ADC_CFG_ADHSC_ADHSC_0 = 0x0
	// High speed conversion selected.
	ADC_CFG_ADHSC_ADHSC_1 = 0x1
	// Position of REFSEL field.
	ADC_CFG_REFSEL_Pos = 0xb
	// Bit mask of REFSEL field.
	ADC_CFG_REFSEL_Msk = 0x1800
	// Selects VREFH/VREFL as reference voltage.
	ADC_CFG_REFSEL_REFSEL_0 = 0x0
	// Position of ADTRG field.
	ADC_CFG_ADTRG_Pos = 0xd
	// Bit mask of ADTRG field.
	ADC_CFG_ADTRG_Msk = 0x2000
	// Bit ADTRG.
	ADC_CFG_ADTRG = 0x2000
	// Software trigger selected
	ADC_CFG_ADTRG_ADTRG_0 = 0x0
	// Hardware trigger selected
	ADC_CFG_ADTRG_ADTRG_1 = 0x1
	// Position of AVGS field.
	ADC_CFG_AVGS_Pos = 0xe
	// Bit mask of AVGS field.
	ADC_CFG_AVGS_Msk = 0xc000
	// 4 samples averaged
	ADC_CFG_AVGS_AVGS_0 = 0x0
	// 8 samples averaged
	ADC_CFG_AVGS_AVGS_1 = 0x1
	// 16 samples averaged
	ADC_CFG_AVGS_AVGS_2 = 0x2
	// 32 samples averaged
	ADC_CFG_AVGS_AVGS_3 = 0x3
	// Position of OVWREN field.
	ADC_CFG_OVWREN_Pos = 0x10
	// Bit mask of OVWREN field.
	ADC_CFG_OVWREN_Msk = 0x10000
	// Bit OVWREN.
	ADC_CFG_OVWREN = 0x10000
	// Disable the overwriting. Existing Data in Data result register will not be overwritten by subsequent converted data.
	ADC_CFG_OVWREN_OVWREN_0 = 0x0
	// Enable the overwriting.
	ADC_CFG_OVWREN_OVWREN_1 = 0x1

	// GC: General control register
	// Position of ADACKEN field.
	ADC_GC_ADACKEN_Pos = 0x0
	// Bit mask of ADACKEN field.
	ADC_GC_ADACKEN_Msk = 0x1
	// Bit ADACKEN.
	ADC_GC_ADACKEN = 0x1
	// Asynchronous clock output disabled; Asynchronous clock only enabled if selected by ADICLK and a conversion is active.
	ADC_GC_ADACKEN_ADACKEN_0 = 0x0
	// Asynchronous clock and clock output enabled regardless of the state of the ADC
	ADC_GC_ADACKEN_ADACKEN_1 = 0x1
	// Position of DMAEN field.
	ADC_GC_DMAEN_Pos = 0x1
	// Bit mask of DMAEN field.
	ADC_GC_DMAEN_Msk = 0x2
	// Bit DMAEN.
	ADC_GC_DMAEN = 0x2
	// DMA disabled (default)
	ADC_GC_DMAEN_DMAEN_0 = 0x0
	// DMA enabled
	ADC_GC_DMAEN_DMAEN_1 = 0x1
	// Position of ACREN field.
	ADC_GC_ACREN_Pos = 0x2
	// Bit mask of ACREN field.
	ADC_GC_ACREN_Msk = 0x4
	// Bit ACREN.
	ADC_GC_ACREN = 0x4
	// Range function disabled. Only the compare value 1 of ADC_CV register (CV1) is compared.
	ADC_GC_ACREN_ACREN_0 = 0x0
	// Range function enabled. Both compare values of ADC_CV registers (CV1 and CV2) are compared.
	ADC_GC_ACREN_ACREN_1 = 0x1
	// Position of ACFGT field.
	ADC_GC_ACFGT_Pos = 0x3
	// Bit mask of ACFGT field.
	ADC_GC_ACFGT_Msk = 0x8
	// Bit ACFGT.
	ADC_GC_ACFGT = 0x8
	// Configures "Less Than Threshold, Outside Range Not Inclusive and Inside Range Not Inclusive" functionality based on the values placed in the ADC_CV register.
	ADC_GC_ACFGT_ACFGT_0 = 0x0
	// Configures "Greater Than Or Equal To Threshold, Outside Range Inclusive and Inside Range Inclusive" functionality based on the values placed in the ADC_CV registers.
	ADC_GC_ACFGT_ACFGT_1 = 0x1
	// Position of ACFE field.
	ADC_GC_ACFE_Pos = 0x4
	// Bit mask of ACFE field.
	ADC_GC_ACFE_Msk = 0x10
	// Bit ACFE.
	ADC_GC_ACFE = 0x10
	// Compare function disabled
	ADC_GC_ACFE_ACFE_0 = 0x0
	// Compare function enabled
	ADC_GC_ACFE_ACFE_1 = 0x1
	// Position of AVGE field.
	ADC_GC_AVGE_Pos = 0x5
	// Bit mask of AVGE field.
	ADC_GC_AVGE_Msk = 0x20
	// Bit AVGE.
	ADC_GC_AVGE = 0x20
	// Hardware average function disabled
	ADC_GC_AVGE_AVGE_0 = 0x0
	// Hardware average function enabled
	ADC_GC_AVGE_AVGE_1 = 0x1
	// Position of ADCO field.
	ADC_GC_ADCO_Pos = 0x6
	// Bit mask of ADCO field.
	ADC_GC_ADCO_Msk = 0x40
	// Bit ADCO.
	ADC_GC_ADCO = 0x40
	// One conversion or one set of conversions if the hardware average function is enabled (AVGE=1) after initiating a conversion.
	ADC_GC_ADCO_ADCO_0 = 0x0
	// Continuous conversions or sets of conversions if the hardware average function is enabled (AVGE=1) after initiating a conversion.
	ADC_GC_ADCO_ADCO_1 = 0x1
	// Position of CAL field.
	ADC_GC_CAL_Pos = 0x7
	// Bit mask of CAL field.
	ADC_GC_CAL_Msk = 0x80
	// Bit CAL.
	ADC_GC_CAL = 0x80

	// GS: General status register
	// Position of ADACT field.
	ADC_GS_ADACT_Pos = 0x0
	// Bit mask of ADACT field.
	ADC_GS_ADACT_Msk = 0x1
	// Bit ADACT.
	ADC_GS_ADACT = 0x1
	// Conversion not in progress.
	ADC_GS_ADACT_ADACT_0 = 0x0
	// Conversion in progress.
	ADC_GS_ADACT_ADACT_1 = 0x1
	// Position of CALF field.
	ADC_GS_CALF_Pos = 0x1
	// Bit mask of CALF field.
	ADC_GS_CALF_Msk = 0x2
	// Bit CALF.
	ADC_GS_CALF = 0x2
	// Calibration completed normally.
	ADC_GS_CALF_CALF_0 = 0x0
	// Calibration failed. ADC accuracy specifications are not guaranteed.
	ADC_GS_CALF_CALF_1 = 0x1
	// Position of AWKST field.
	ADC_GS_AWKST_Pos = 0x2
	// Bit mask of AWKST field.
	ADC_GS_AWKST_Msk = 0x4
	// Bit AWKST.
	ADC_GS_AWKST = 0x4
	// No asynchronous interrupt.
	ADC_GS_AWKST_AWKST_0 = 0x0
	// Asynchronous wake up interrupt occurred in stop mode.
	ADC_GS_AWKST_AWKST_1 = 0x1

	// CV: Compare value register
	// Position of CV1 field.
	ADC_CV_CV1_Pos = 0x0
	// Bit mask of CV1 field.
	ADC_CV_CV1_Msk = 0xfff
	// Position of CV2 field.
	ADC_CV_CV2_Pos = 0x10
	// Bit mask of CV2 field.
	ADC_CV_CV2_Msk = 0xfff0000

	// OFS: Offset correction value register
	// Position of OFS field.
	ADC_OFS_OFS_Pos = 0x0
	// Bit mask of OFS field.
	ADC_OFS_OFS_Msk = 0xfff
	// Position of SIGN field.
	ADC_OFS_SIGN_Pos = 0xc
	// Bit mask of SIGN field.
	ADC_OFS_SIGN_Msk = 0x1000
	// Bit SIGN.
	ADC_OFS_SIGN = 0x1000
	// The offset value is added with the raw result
	ADC_OFS_SIGN_SIGN_0 = 0x0
	// The offset value is subtracted from the raw converted value
	ADC_OFS_SIGN_SIGN_1 = 0x1

	// CAL: Calibration value register
	// Position of CAL_CODE field.
	ADC_CAL_CAL_CODE_Pos = 0x0
	// Bit mask of CAL_CODE field.
	ADC_CAL_CAL_CODE_Msk = 0xf
)

// Constants for TRNG: TRNG
const (
	// MCTL: Miscellaneous Control Register
	// Position of SAMP_MODE field.
	TRNG_MCTL_SAMP_MODE_Pos = 0x0
	// Bit mask of SAMP_MODE field.
	TRNG_MCTL_SAMP_MODE_Msk = 0x3
	// use Von Neumann data into both Entropy shifter and Statistical Checker
	TRNG_MCTL_SAMP_MODE_SAMP_MODE_0 = 0x0
	// use raw data into both Entropy shifter and Statistical Checker
	TRNG_MCTL_SAMP_MODE_SAMP_MODE_1 = 0x1
	// use Von Neumann data into Entropy shifter. Use raw data into Statistical Checker
	TRNG_MCTL_SAMP_MODE_SAMP_MODE_2 = 0x2
	// undefined/reserved.
	TRNG_MCTL_SAMP_MODE_SAMP_MODE_3 = 0x3
	// Position of OSC_DIV field.
	TRNG_MCTL_OSC_DIV_Pos = 0x2
	// Bit mask of OSC_DIV field.
	TRNG_MCTL_OSC_DIV_Msk = 0xc
	// use ring oscillator with no divide
	TRNG_MCTL_OSC_DIV_OSC_DIV_0 = 0x0
	// use ring oscillator divided-by-2
	TRNG_MCTL_OSC_DIV_OSC_DIV_1 = 0x1
	// use ring oscillator divided-by-4
	TRNG_MCTL_OSC_DIV_OSC_DIV_2 = 0x2
	// use ring oscillator divided-by-8
	TRNG_MCTL_OSC_DIV_OSC_DIV_3 = 0x3
	// Position of UNUSED4 field.
	TRNG_MCTL_UNUSED4_Pos = 0x4
	// Bit mask of UNUSED4 field.
	TRNG_MCTL_UNUSED4_Msk = 0x10
	// Bit UNUSED4.
	TRNG_MCTL_UNUSED4 = 0x10
	// Position of UNUSED5 field.
	TRNG_MCTL_UNUSED5_Pos = 0x5
	// Bit mask of UNUSED5 field.
	TRNG_MCTL_UNUSED5_Msk = 0x20
	// Bit UNUSED5.
	TRNG_MCTL_UNUSED5 = 0x20
	// Position of RST_DEF field.
	TRNG_MCTL_RST_DEF_Pos = 0x6
	// Bit mask of RST_DEF field.
	TRNG_MCTL_RST_DEF_Msk = 0x40
	// Bit RST_DEF.
	TRNG_MCTL_RST_DEF = 0x40
	// Position of FOR_SCLK field.
	TRNG_MCTL_FOR_SCLK_Pos = 0x7
	// Bit mask of FOR_SCLK field.
	TRNG_MCTL_FOR_SCLK_Msk = 0x80
	// Bit FOR_SCLK.
	TRNG_MCTL_FOR_SCLK = 0x80
	// Position of FCT_FAIL field.
	TRNG_MCTL_FCT_FAIL_Pos = 0x8
	// Bit mask of FCT_FAIL field.
	TRNG_MCTL_FCT_FAIL_Msk = 0x100
	// Bit FCT_FAIL.
	TRNG_MCTL_FCT_FAIL = 0x100
	// Position of FCT_VAL field.
	TRNG_MCTL_FCT_VAL_Pos = 0x9
	// Bit mask of FCT_VAL field.
	TRNG_MCTL_FCT_VAL_Msk = 0x200
	// Bit FCT_VAL.
	TRNG_MCTL_FCT_VAL = 0x200
	// Position of ENT_VAL field.
	TRNG_MCTL_ENT_VAL_Pos = 0xa
	// Bit mask of ENT_VAL field.
	TRNG_MCTL_ENT_VAL_Msk = 0x400
	// Bit ENT_VAL.
	TRNG_MCTL_ENT_VAL = 0x400
	// Position of TST_OUT field.
	TRNG_MCTL_TST_OUT_Pos = 0xb
	// Bit mask of TST_OUT field.
	TRNG_MCTL_TST_OUT_Msk = 0x800
	// Bit TST_OUT.
	TRNG_MCTL_TST_OUT = 0x800
	// Position of ERR field.
	TRNG_MCTL_ERR_Pos = 0xc
	// Bit mask of ERR field.
	TRNG_MCTL_ERR_Msk = 0x1000
	// Bit ERR.
	TRNG_MCTL_ERR = 0x1000
	// Position of TSTOP_OK field.
	TRNG_MCTL_TSTOP_OK_Pos = 0xd
	// Bit mask of TSTOP_OK field.
	TRNG_MCTL_TSTOP_OK_Msk = 0x2000
	// Bit TSTOP_OK.
	TRNG_MCTL_TSTOP_OK = 0x2000
	// Position of LRUN_CONT field.
	TRNG_MCTL_LRUN_CONT_Pos = 0xe
	// Bit mask of LRUN_CONT field.
	TRNG_MCTL_LRUN_CONT_Msk = 0x4000
	// Bit LRUN_CONT.
	TRNG_MCTL_LRUN_CONT = 0x4000
	// Position of PRGM field.
	TRNG_MCTL_PRGM_Pos = 0x10
	// Bit mask of PRGM field.
	TRNG_MCTL_PRGM_Msk = 0x10000
	// Bit PRGM.
	TRNG_MCTL_PRGM = 0x10000

	// SCMISC: Statistical Check Miscellaneous Register
	// Position of LRUN_MAX field.
	TRNG_SCMISC_LRUN_MAX_Pos = 0x0
	// Bit mask of LRUN_MAX field.
	TRNG_SCMISC_LRUN_MAX_Msk = 0xff
	// Position of RTY_CT field.
	TRNG_SCMISC_RTY_CT_Pos = 0x10
	// Bit mask of RTY_CT field.
	TRNG_SCMISC_RTY_CT_Msk = 0xf0000

	// PKRRNG: Poker Range Register
	// Position of PKR_RNG field.
	TRNG_PKRRNG_PKR_RNG_Pos = 0x0
	// Bit mask of PKR_RNG field.
	TRNG_PKRRNG_PKR_RNG_Msk = 0xffff

	// PKRMAX: Poker Maximum Limit Register
	// Position of PKR_MAX field.
	TRNG_PKRMAX_PKR_MAX_Pos = 0x0
	// Bit mask of PKR_MAX field.
	TRNG_PKRMAX_PKR_MAX_Msk = 0xffffff

	// PKRSQ: Poker Square Calculation Result Register
	// Position of PKR_SQ field.
	TRNG_PKRSQ_PKR_SQ_Pos = 0x0
	// Bit mask of PKR_SQ field.
	TRNG_PKRSQ_PKR_SQ_Msk = 0xffffff

	// SDCTL: Seed Control Register
	// Position of SAMP_SIZE field.
	TRNG_SDCTL_SAMP_SIZE_Pos = 0x0
	// Bit mask of SAMP_SIZE field.
	TRNG_SDCTL_SAMP_SIZE_Msk = 0xffff
	// Position of ENT_DLY field.
	TRNG_SDCTL_ENT_DLY_Pos = 0x10
	// Bit mask of ENT_DLY field.
	TRNG_SDCTL_ENT_DLY_Msk = 0xffff0000

	// SBLIM: Sparse Bit Limit Register
	// Position of SB_LIM field.
	TRNG_SBLIM_SB_LIM_Pos = 0x0
	// Bit mask of SB_LIM field.
	TRNG_SBLIM_SB_LIM_Msk = 0x3ff

	// TOTSAM: Total Samples Register
	// Position of TOT_SAM field.
	TRNG_TOTSAM_TOT_SAM_Pos = 0x0
	// Bit mask of TOT_SAM field.
	TRNG_TOTSAM_TOT_SAM_Msk = 0xfffff

	// FRQMIN: Frequency Count Minimum Limit Register
	// Position of FRQ_MIN field.
	TRNG_FRQMIN_FRQ_MIN_Pos = 0x0
	// Bit mask of FRQ_MIN field.
	TRNG_FRQMIN_FRQ_MIN_Msk = 0x3fffff

	// FRQCNT: Frequency Count Register
	// Position of FRQ_CT field.
	TRNG_FRQCNT_FRQ_CT_Pos = 0x0
	// Bit mask of FRQ_CT field.
	TRNG_FRQCNT_FRQ_CT_Msk = 0x3fffff

	// FRQMAX: Frequency Count Maximum Limit Register
	// Position of FRQ_MAX field.
	TRNG_FRQMAX_FRQ_MAX_Pos = 0x0
	// Bit mask of FRQ_MAX field.
	TRNG_FRQMAX_FRQ_MAX_Msk = 0x3fffff

	// SCMC: Statistical Check Monobit Count Register
	// Position of MONO_CT field.
	TRNG_SCMC_MONO_CT_Pos = 0x0
	// Bit mask of MONO_CT field.
	TRNG_SCMC_MONO_CT_Msk = 0xffff

	// SCML: Statistical Check Monobit Limit Register
	// Position of MONO_MAX field.
	TRNG_SCML_MONO_MAX_Pos = 0x0
	// Bit mask of MONO_MAX field.
	TRNG_SCML_MONO_MAX_Msk = 0xffff
	// Position of MONO_RNG field.
	TRNG_SCML_MONO_RNG_Pos = 0x10
	// Bit mask of MONO_RNG field.
	TRNG_SCML_MONO_RNG_Msk = 0xffff0000

	// SCR1C: Statistical Check Run Length 1 Count Register
	// Position of R1_0_CT field.
	TRNG_SCR1C_R1_0_CT_Pos = 0x0
	// Bit mask of R1_0_CT field.
	TRNG_SCR1C_R1_0_CT_Msk = 0x7fff
	// Position of R1_1_CT field.
	TRNG_SCR1C_R1_1_CT_Pos = 0x10
	// Bit mask of R1_1_CT field.
	TRNG_SCR1C_R1_1_CT_Msk = 0x7fff0000

	// SCR1L: Statistical Check Run Length 1 Limit Register
	// Position of RUN1_MAX field.
	TRNG_SCR1L_RUN1_MAX_Pos = 0x0
	// Bit mask of RUN1_MAX field.
	TRNG_SCR1L_RUN1_MAX_Msk = 0x7fff
	// Position of RUN1_RNG field.
	TRNG_SCR1L_RUN1_RNG_Pos = 0x10
	// Bit mask of RUN1_RNG field.
	TRNG_SCR1L_RUN1_RNG_Msk = 0x7fff0000

	// SCR2C: Statistical Check Run Length 2 Count Register
	// Position of R2_0_CT field.
	TRNG_SCR2C_R2_0_CT_Pos = 0x0
	// Bit mask of R2_0_CT field.
	TRNG_SCR2C_R2_0_CT_Msk = 0x3fff
	// Position of R2_1_CT field.
	TRNG_SCR2C_R2_1_CT_Pos = 0x10
	// Bit mask of R2_1_CT field.
	TRNG_SCR2C_R2_1_CT_Msk = 0x3fff0000

	// SCR2L: Statistical Check Run Length 2 Limit Register
	// Position of RUN2_MAX field.
	TRNG_SCR2L_RUN2_MAX_Pos = 0x0
	// Bit mask of RUN2_MAX field.
	TRNG_SCR2L_RUN2_MAX_Msk = 0x3fff
	// Position of RUN2_RNG field.
	TRNG_SCR2L_RUN2_RNG_Pos = 0x10
	// Bit mask of RUN2_RNG field.
	TRNG_SCR2L_RUN2_RNG_Msk = 0x3fff0000

	// SCR3C: Statistical Check Run Length 3 Count Register
	// Position of R3_0_CT field.
	TRNG_SCR3C_R3_0_CT_Pos = 0x0
	// Bit mask of R3_0_CT field.
	TRNG_SCR3C_R3_0_CT_Msk = 0x1fff
	// Position of R3_1_CT field.
	TRNG_SCR3C_R3_1_CT_Pos = 0x10
	// Bit mask of R3_1_CT field.
	TRNG_SCR3C_R3_1_CT_Msk = 0x1fff0000

	// SCR3L: Statistical Check Run Length 3 Limit Register
	// Position of RUN3_MAX field.
	TRNG_SCR3L_RUN3_MAX_Pos = 0x0
	// Bit mask of RUN3_MAX field.
	TRNG_SCR3L_RUN3_MAX_Msk = 0x1fff
	// Position of RUN3_RNG field.
	TRNG_SCR3L_RUN3_RNG_Pos = 0x10
	// Bit mask of RUN3_RNG field.
	TRNG_SCR3L_RUN3_RNG_Msk = 0x1fff0000

	// SCR4C: Statistical Check Run Length 4 Count Register
	// Position of R4_0_CT field.
	TRNG_SCR4C_R4_0_CT_Pos = 0x0
	// Bit mask of R4_0_CT field.
	TRNG_SCR4C_R4_0_CT_Msk = 0xfff
	// Position of R4_1_CT field.
	TRNG_SCR4C_R4_1_CT_Pos = 0x10
	// Bit mask of R4_1_CT field.
	TRNG_SCR4C_R4_1_CT_Msk = 0xfff0000

	// SCR4L: Statistical Check Run Length 4 Limit Register
	// Position of RUN4_MAX field.
	TRNG_SCR4L_RUN4_MAX_Pos = 0x0
	// Bit mask of RUN4_MAX field.
	TRNG_SCR4L_RUN4_MAX_Msk = 0xfff
	// Position of RUN4_RNG field.
	TRNG_SCR4L_RUN4_RNG_Pos = 0x10
	// Bit mask of RUN4_RNG field.
	TRNG_SCR4L_RUN4_RNG_Msk = 0xfff0000

	// SCR5C: Statistical Check Run Length 5 Count Register
	// Position of R5_0_CT field.
	TRNG_SCR5C_R5_0_CT_Pos = 0x0
	// Bit mask of R5_0_CT field.
	TRNG_SCR5C_R5_0_CT_Msk = 0x7ff
	// Position of R5_1_CT field.
	TRNG_SCR5C_R5_1_CT_Pos = 0x10
	// Bit mask of R5_1_CT field.
	TRNG_SCR5C_R5_1_CT_Msk = 0x7ff0000

	// SCR5L: Statistical Check Run Length 5 Limit Register
	// Position of RUN5_MAX field.
	TRNG_SCR5L_RUN5_MAX_Pos = 0x0
	// Bit mask of RUN5_MAX field.
	TRNG_SCR5L_RUN5_MAX_Msk = 0x7ff
	// Position of RUN5_RNG field.
	TRNG_SCR5L_RUN5_RNG_Pos = 0x10
	// Bit mask of RUN5_RNG field.
	TRNG_SCR5L_RUN5_RNG_Msk = 0x7ff0000

	// SCR6PC: Statistical Check Run Length 6+ Count Register
	// Position of R6P_0_CT field.
	TRNG_SCR6PC_R6P_0_CT_Pos = 0x0
	// Bit mask of R6P_0_CT field.
	TRNG_SCR6PC_R6P_0_CT_Msk = 0x7ff
	// Position of R6P_1_CT field.
	TRNG_SCR6PC_R6P_1_CT_Pos = 0x10
	// Bit mask of R6P_1_CT field.
	TRNG_SCR6PC_R6P_1_CT_Msk = 0x7ff0000

	// SCR6PL: Statistical Check Run Length 6+ Limit Register
	// Position of RUN6P_MAX field.
	TRNG_SCR6PL_RUN6P_MAX_Pos = 0x0
	// Bit mask of RUN6P_MAX field.
	TRNG_SCR6PL_RUN6P_MAX_Msk = 0x7ff
	// Position of RUN6P_RNG field.
	TRNG_SCR6PL_RUN6P_RNG_Pos = 0x10
	// Bit mask of RUN6P_RNG field.
	TRNG_SCR6PL_RUN6P_RNG_Msk = 0x7ff0000

	// STATUS: Status Register
	// Position of TF1BR0 field.
	TRNG_STATUS_TF1BR0_Pos = 0x0
	// Bit mask of TF1BR0 field.
	TRNG_STATUS_TF1BR0_Msk = 0x1
	// Bit TF1BR0.
	TRNG_STATUS_TF1BR0 = 0x1
	// Position of TF1BR1 field.
	TRNG_STATUS_TF1BR1_Pos = 0x1
	// Bit mask of TF1BR1 field.
	TRNG_STATUS_TF1BR1_Msk = 0x2
	// Bit TF1BR1.
	TRNG_STATUS_TF1BR1 = 0x2
	// Position of TF2BR0 field.
	TRNG_STATUS_TF2BR0_Pos = 0x2
	// Bit mask of TF2BR0 field.
	TRNG_STATUS_TF2BR0_Msk = 0x4
	// Bit TF2BR0.
	TRNG_STATUS_TF2BR0 = 0x4
	// Position of TF2BR1 field.
	TRNG_STATUS_TF2BR1_Pos = 0x3
	// Bit mask of TF2BR1 field.
	TRNG_STATUS_TF2BR1_Msk = 0x8
	// Bit TF2BR1.
	TRNG_STATUS_TF2BR1 = 0x8
	// Position of TF3BR0 field.
	TRNG_STATUS_TF3BR0_Pos = 0x4
	// Bit mask of TF3BR0 field.
	TRNG_STATUS_TF3BR0_Msk = 0x10
	// Bit TF3BR0.
	TRNG_STATUS_TF3BR0 = 0x10
	// Position of TF3BR1 field.
	TRNG_STATUS_TF3BR1_Pos = 0x5
	// Bit mask of TF3BR1 field.
	TRNG_STATUS_TF3BR1_Msk = 0x20
	// Bit TF3BR1.
	TRNG_STATUS_TF3BR1 = 0x20
	// Position of TF4BR0 field.
	TRNG_STATUS_TF4BR0_Pos = 0x6
	// Bit mask of TF4BR0 field.
	TRNG_STATUS_TF4BR0_Msk = 0x40
	// Bit TF4BR0.
	TRNG_STATUS_TF4BR0 = 0x40
	// Position of TF4BR1 field.
	TRNG_STATUS_TF4BR1_Pos = 0x7
	// Bit mask of TF4BR1 field.
	TRNG_STATUS_TF4BR1_Msk = 0x80
	// Bit TF4BR1.
	TRNG_STATUS_TF4BR1 = 0x80
	// Position of TF5BR0 field.
	TRNG_STATUS_TF5BR0_Pos = 0x8
	// Bit mask of TF5BR0 field.
	TRNG_STATUS_TF5BR0_Msk = 0x100
	// Bit TF5BR0.
	TRNG_STATUS_TF5BR0 = 0x100
	// Position of TF5BR1 field.
	TRNG_STATUS_TF5BR1_Pos = 0x9
	// Bit mask of TF5BR1 field.
	TRNG_STATUS_TF5BR1_Msk = 0x200
	// Bit TF5BR1.
	TRNG_STATUS_TF5BR1 = 0x200
	// Position of TF6PBR0 field.
	TRNG_STATUS_TF6PBR0_Pos = 0xa
	// Bit mask of TF6PBR0 field.
	TRNG_STATUS_TF6PBR0_Msk = 0x400
	// Bit TF6PBR0.
	TRNG_STATUS_TF6PBR0 = 0x400
	// Position of TF6PBR1 field.
	TRNG_STATUS_TF6PBR1_Pos = 0xb
	// Bit mask of TF6PBR1 field.
	TRNG_STATUS_TF6PBR1_Msk = 0x800
	// Bit TF6PBR1.
	TRNG_STATUS_TF6PBR1 = 0x800
	// Position of TFSB field.
	TRNG_STATUS_TFSB_Pos = 0xc
	// Bit mask of TFSB field.
	TRNG_STATUS_TFSB_Msk = 0x1000
	// Bit TFSB.
	TRNG_STATUS_TFSB = 0x1000
	// Position of TFLR field.
	TRNG_STATUS_TFLR_Pos = 0xd
	// Bit mask of TFLR field.
	TRNG_STATUS_TFLR_Msk = 0x2000
	// Bit TFLR.
	TRNG_STATUS_TFLR = 0x2000
	// Position of TFP field.
	TRNG_STATUS_TFP_Pos = 0xe
	// Bit mask of TFP field.
	TRNG_STATUS_TFP_Msk = 0x4000
	// Bit TFP.
	TRNG_STATUS_TFP = 0x4000
	// Position of TFMB field.
	TRNG_STATUS_TFMB_Pos = 0xf
	// Bit mask of TFMB field.
	TRNG_STATUS_TFMB_Msk = 0x8000
	// Bit TFMB.
	TRNG_STATUS_TFMB = 0x8000
	// Position of RETRY_CT field.
	TRNG_STATUS_RETRY_CT_Pos = 0x10
	// Bit mask of RETRY_CT field.
	TRNG_STATUS_RETRY_CT_Msk = 0xf0000

	// ENT: Entropy Read Register
	// Position of ENT field.
	TRNG_ENT_ENT_Pos = 0x0
	// Bit mask of ENT field.
	TRNG_ENT_ENT_Msk = 0xffffffff

	// PKRCNT10: Statistical Check Poker Count 1 and 0 Register
	// Position of PKR_0_CT field.
	TRNG_PKRCNT10_PKR_0_CT_Pos = 0x0
	// Bit mask of PKR_0_CT field.
	TRNG_PKRCNT10_PKR_0_CT_Msk = 0xffff
	// Position of PKR_1_CT field.
	TRNG_PKRCNT10_PKR_1_CT_Pos = 0x10
	// Bit mask of PKR_1_CT field.
	TRNG_PKRCNT10_PKR_1_CT_Msk = 0xffff0000

	// PKRCNT32: Statistical Check Poker Count 3 and 2 Register
	// Position of PKR_2_CT field.
	TRNG_PKRCNT32_PKR_2_CT_Pos = 0x0
	// Bit mask of PKR_2_CT field.
	TRNG_PKRCNT32_PKR_2_CT_Msk = 0xffff
	// Position of PKR_3_CT field.
	TRNG_PKRCNT32_PKR_3_CT_Pos = 0x10
	// Bit mask of PKR_3_CT field.
	TRNG_PKRCNT32_PKR_3_CT_Msk = 0xffff0000

	// PKRCNT54: Statistical Check Poker Count 5 and 4 Register
	// Position of PKR_4_CT field.
	TRNG_PKRCNT54_PKR_4_CT_Pos = 0x0
	// Bit mask of PKR_4_CT field.
	TRNG_PKRCNT54_PKR_4_CT_Msk = 0xffff
	// Position of PKR_5_CT field.
	TRNG_PKRCNT54_PKR_5_CT_Pos = 0x10
	// Bit mask of PKR_5_CT field.
	TRNG_PKRCNT54_PKR_5_CT_Msk = 0xffff0000

	// PKRCNT76: Statistical Check Poker Count 7 and 6 Register
	// Position of PKR_6_CT field.
	TRNG_PKRCNT76_PKR_6_CT_Pos = 0x0
	// Bit mask of PKR_6_CT field.
	TRNG_PKRCNT76_PKR_6_CT_Msk = 0xffff
	// Position of PKR_7_CT field.
	TRNG_PKRCNT76_PKR_7_CT_Pos = 0x10
	// Bit mask of PKR_7_CT field.
	TRNG_PKRCNT76_PKR_7_CT_Msk = 0xffff0000

	// PKRCNT98: Statistical Check Poker Count 9 and 8 Register
	// Position of PKR_8_CT field.
	TRNG_PKRCNT98_PKR_8_CT_Pos = 0x0
	// Bit mask of PKR_8_CT field.
	TRNG_PKRCNT98_PKR_8_CT_Msk = 0xffff
	// Position of PKR_9_CT field.
	TRNG_PKRCNT98_PKR_9_CT_Pos = 0x10
	// Bit mask of PKR_9_CT field.
	TRNG_PKRCNT98_PKR_9_CT_Msk = 0xffff0000

	// PKRCNTBA: Statistical Check Poker Count B and A Register
	// Position of PKR_A_CT field.
	TRNG_PKRCNTBA_PKR_A_CT_Pos = 0x0
	// Bit mask of PKR_A_CT field.
	TRNG_PKRCNTBA_PKR_A_CT_Msk = 0xffff
	// Position of PKR_B_CT field.
	TRNG_PKRCNTBA_PKR_B_CT_Pos = 0x10
	// Bit mask of PKR_B_CT field.
	TRNG_PKRCNTBA_PKR_B_CT_Msk = 0xffff0000

	// PKRCNTDC: Statistical Check Poker Count D and C Register
	// Position of PKR_C_CT field.
	TRNG_PKRCNTDC_PKR_C_CT_Pos = 0x0
	// Bit mask of PKR_C_CT field.
	TRNG_PKRCNTDC_PKR_C_CT_Msk = 0xffff
	// Position of PKR_D_CT field.
	TRNG_PKRCNTDC_PKR_D_CT_Pos = 0x10
	// Bit mask of PKR_D_CT field.
	TRNG_PKRCNTDC_PKR_D_CT_Msk = 0xffff0000

	// PKRCNTFE: Statistical Check Poker Count F and E Register
	// Position of PKR_E_CT field.
	TRNG_PKRCNTFE_PKR_E_CT_Pos = 0x0
	// Bit mask of PKR_E_CT field.
	TRNG_PKRCNTFE_PKR_E_CT_Msk = 0xffff
	// Position of PKR_F_CT field.
	TRNG_PKRCNTFE_PKR_F_CT_Pos = 0x10
	// Bit mask of PKR_F_CT field.
	TRNG_PKRCNTFE_PKR_F_CT_Msk = 0xffff0000

	// SEC_CFG: Security Configuration Register
	// Position of UNUSED0 field.
	TRNG_SEC_CFG_UNUSED0_Pos = 0x0
	// Bit mask of UNUSED0 field.
	TRNG_SEC_CFG_UNUSED0_Msk = 0x1
	// Bit UNUSED0.
	TRNG_SEC_CFG_UNUSED0 = 0x1
	// Position of NO_PRGM field.
	TRNG_SEC_CFG_NO_PRGM_Pos = 0x1
	// Bit mask of NO_PRGM field.
	TRNG_SEC_CFG_NO_PRGM_Msk = 0x2
	// Bit NO_PRGM.
	TRNG_SEC_CFG_NO_PRGM = 0x2
	// Programability of registers controlled only by the Miscellaneous Control Register's access mode bit.
	TRNG_SEC_CFG_NO_PRGM_NO_PRGM_0 = 0x0
	// Overides Miscellaneous Control Register access mode and prevents TRNG register programming.
	TRNG_SEC_CFG_NO_PRGM_NO_PRGM_1 = 0x1
	// Position of UNUSED2 field.
	TRNG_SEC_CFG_UNUSED2_Pos = 0x2
	// Bit mask of UNUSED2 field.
	TRNG_SEC_CFG_UNUSED2_Msk = 0x4
	// Bit UNUSED2.
	TRNG_SEC_CFG_UNUSED2 = 0x4

	// INT_CTRL: Interrupt Control Register
	// Position of HW_ERR field.
	TRNG_INT_CTRL_HW_ERR_Pos = 0x0
	// Bit mask of HW_ERR field.
	TRNG_INT_CTRL_HW_ERR_Msk = 0x1
	// Bit HW_ERR.
	TRNG_INT_CTRL_HW_ERR = 0x1
	// Corresponding bit of INT_STATUS register cleared.
	TRNG_INT_CTRL_HW_ERR_HW_ERR_0 = 0x0
	// Corresponding bit of INT_STATUS register active.
	TRNG_INT_CTRL_HW_ERR_HW_ERR_1 = 0x1
	// Position of ENT_VAL field.
	TRNG_INT_CTRL_ENT_VAL_Pos = 0x1
	// Bit mask of ENT_VAL field.
	TRNG_INT_CTRL_ENT_VAL_Msk = 0x2
	// Bit ENT_VAL.
	TRNG_INT_CTRL_ENT_VAL = 0x2
	// Same behavior as bit 0 of this register.
	TRNG_INT_CTRL_ENT_VAL_ENT_VAL_0 = 0x0
	// Same behavior as bit 0 of this register.
	TRNG_INT_CTRL_ENT_VAL_ENT_VAL_1 = 0x1
	// Position of FRQ_CT_FAIL field.
	TRNG_INT_CTRL_FRQ_CT_FAIL_Pos = 0x2
	// Bit mask of FRQ_CT_FAIL field.
	TRNG_INT_CTRL_FRQ_CT_FAIL_Msk = 0x4
	// Bit FRQ_CT_FAIL.
	TRNG_INT_CTRL_FRQ_CT_FAIL = 0x4
	// Same behavior as bit 0 of this register.
	TRNG_INT_CTRL_FRQ_CT_FAIL_FRQ_CT_FAIL_0 = 0x0
	// Same behavior as bit 0 of this register.
	TRNG_INT_CTRL_FRQ_CT_FAIL_FRQ_CT_FAIL_1 = 0x1

	// INT_MASK: Mask Register
	// Position of HW_ERR field.
	TRNG_INT_MASK_HW_ERR_Pos = 0x0
	// Bit mask of HW_ERR field.
	TRNG_INT_MASK_HW_ERR_Msk = 0x1
	// Bit HW_ERR.
	TRNG_INT_MASK_HW_ERR = 0x1
	// Corresponding interrupt of INT_STATUS is masked.
	TRNG_INT_MASK_HW_ERR_HW_ERR_0 = 0x0
	// Corresponding bit of INT_STATUS is active.
	TRNG_INT_MASK_HW_ERR_HW_ERR_1 = 0x1
	// Position of ENT_VAL field.
	TRNG_INT_MASK_ENT_VAL_Pos = 0x1
	// Bit mask of ENT_VAL field.
	TRNG_INT_MASK_ENT_VAL_Msk = 0x2
	// Bit ENT_VAL.
	TRNG_INT_MASK_ENT_VAL = 0x2
	// Same behavior as bit 0 of this register.
	TRNG_INT_MASK_ENT_VAL_ENT_VAL_0 = 0x0
	// Same behavior as bit 0 of this register.
	TRNG_INT_MASK_ENT_VAL_ENT_VAL_1 = 0x1
	// Position of FRQ_CT_FAIL field.
	TRNG_INT_MASK_FRQ_CT_FAIL_Pos = 0x2
	// Bit mask of FRQ_CT_FAIL field.
	TRNG_INT_MASK_FRQ_CT_FAIL_Msk = 0x4
	// Bit FRQ_CT_FAIL.
	TRNG_INT_MASK_FRQ_CT_FAIL = 0x4
	// Same behavior as bit 0 of this register.
	TRNG_INT_MASK_FRQ_CT_FAIL_FRQ_CT_FAIL_0 = 0x0
	// Same behavior as bit 0 of this register.
	TRNG_INT_MASK_FRQ_CT_FAIL_FRQ_CT_FAIL_1 = 0x1

	// INT_STATUS: Interrupt Status Register
	// Position of HW_ERR field.
	TRNG_INT_STATUS_HW_ERR_Pos = 0x0
	// Bit mask of HW_ERR field.
	TRNG_INT_STATUS_HW_ERR_Msk = 0x1
	// Bit HW_ERR.
	TRNG_INT_STATUS_HW_ERR = 0x1
	// no error
	TRNG_INT_STATUS_HW_ERR_HW_ERR_0 = 0x0
	// error detected.
	TRNG_INT_STATUS_HW_ERR_HW_ERR_1 = 0x1
	// Position of ENT_VAL field.
	TRNG_INT_STATUS_ENT_VAL_Pos = 0x1
	// Bit mask of ENT_VAL field.
	TRNG_INT_STATUS_ENT_VAL_Msk = 0x2
	// Bit ENT_VAL.
	TRNG_INT_STATUS_ENT_VAL = 0x2
	// Busy generation entropy. Any value read is invalid.
	TRNG_INT_STATUS_ENT_VAL_ENT_VAL_0 = 0x0
	// TRNG can be stopped and entropy is valid if read.
	TRNG_INT_STATUS_ENT_VAL_ENT_VAL_1 = 0x1
	// Position of FRQ_CT_FAIL field.
	TRNG_INT_STATUS_FRQ_CT_FAIL_Pos = 0x2
	// Bit mask of FRQ_CT_FAIL field.
	TRNG_INT_STATUS_FRQ_CT_FAIL_Msk = 0x4
	// Bit FRQ_CT_FAIL.
	TRNG_INT_STATUS_FRQ_CT_FAIL = 0x4
	// No hardware nor self test frequency errors.
	TRNG_INT_STATUS_FRQ_CT_FAIL_FRQ_CT_FAIL_0 = 0x0
	// The frequency counter has detected a failure.
	TRNG_INT_STATUS_FRQ_CT_FAIL_FRQ_CT_FAIL_1 = 0x1

	// VID1: Version ID Register (MS)
	// Position of MIN_REV field.
	TRNG_VID1_MIN_REV_Pos = 0x0
	// Bit mask of MIN_REV field.
	TRNG_VID1_MIN_REV_Msk = 0xff
	// Minor revision number for TRNG.
	TRNG_VID1_MIN_REV_MIN_REV_0 = 0x0
	// Position of MAJ_REV field.
	TRNG_VID1_MAJ_REV_Pos = 0x8
	// Bit mask of MAJ_REV field.
	TRNG_VID1_MAJ_REV_Msk = 0xff00
	// Major revision number for TRNG.
	TRNG_VID1_MAJ_REV_MAJ_REV_1 = 0x1
	// Position of IP_ID field.
	TRNG_VID1_IP_ID_Pos = 0x10
	// Bit mask of IP_ID field.
	TRNG_VID1_IP_ID_Msk = 0xffff0000
	// ID for TRNG.
	TRNG_VID1_IP_ID_IP_ID_48 = 0x30

	// VID2: Version ID Register (LS)
	// Position of CONFIG_OPT field.
	TRNG_VID2_CONFIG_OPT_Pos = 0x0
	// Bit mask of CONFIG_OPT field.
	TRNG_VID2_CONFIG_OPT_Msk = 0xff
	// TRNG_CONFIG_OPT for TRNG.
	TRNG_VID2_CONFIG_OPT_CONFIG_OPT_0 = 0x0
	// Position of ECO_REV field.
	TRNG_VID2_ECO_REV_Pos = 0x8
	// Bit mask of ECO_REV field.
	TRNG_VID2_ECO_REV_Msk = 0xff00
	// TRNG_ECO_REV for TRNG.
	TRNG_VID2_ECO_REV_ECO_REV_0 = 0x0
	// Position of INTG_OPT field.
	TRNG_VID2_INTG_OPT_Pos = 0x10
	// Bit mask of INTG_OPT field.
	TRNG_VID2_INTG_OPT_Msk = 0xff0000
	// INTG_OPT for TRNG.
	TRNG_VID2_INTG_OPT_INTG_OPT_0 = 0x0
	// Position of ERA field.
	TRNG_VID2_ERA_Pos = 0x18
	// Bit mask of ERA field.
	TRNG_VID2_ERA_Msk = 0xff000000
	// COMPILE_OPT for TRNG.
	TRNG_VID2_ERA_ERA_0 = 0x0
)

// Constants for SNVS: SNVS
const (
	// HPLR: SNVS_HP Lock Register
	// Position of ZMK_WSL field.
	SNVS_HPLR_ZMK_WSL_Pos = 0x0
	// Bit mask of ZMK_WSL field.
	SNVS_HPLR_ZMK_WSL_Msk = 0x1
	// Bit ZMK_WSL.
	SNVS_HPLR_ZMK_WSL = 0x1
	// Write access is allowed
	SNVS_HPLR_ZMK_WSL_ZMK_WSL_0 = 0x0
	// Write access is not allowed
	SNVS_HPLR_ZMK_WSL_ZMK_WSL_1 = 0x1
	// Position of ZMK_RSL field.
	SNVS_HPLR_ZMK_RSL_Pos = 0x1
	// Bit mask of ZMK_RSL field.
	SNVS_HPLR_ZMK_RSL_Msk = 0x2
	// Bit ZMK_RSL.
	SNVS_HPLR_ZMK_RSL = 0x2
	// Read access is allowed (only in software Programming mode)
	SNVS_HPLR_ZMK_RSL_ZMK_RSL_0 = 0x0
	// Read access is not allowed
	SNVS_HPLR_ZMK_RSL_ZMK_RSL_1 = 0x1
	// Position of SRTC_SL field.
	SNVS_HPLR_SRTC_SL_Pos = 0x2
	// Bit mask of SRTC_SL field.
	SNVS_HPLR_SRTC_SL_Msk = 0x4
	// Bit SRTC_SL.
	SNVS_HPLR_SRTC_SL = 0x4
	// Write access is allowed
	SNVS_HPLR_SRTC_SL_SRTC_SL_0 = 0x0
	// Write access is not allowed
	SNVS_HPLR_SRTC_SL_SRTC_SL_1 = 0x1
	// Position of LPCALB_SL field.
	SNVS_HPLR_LPCALB_SL_Pos = 0x3
	// Bit mask of LPCALB_SL field.
	SNVS_HPLR_LPCALB_SL_Msk = 0x8
	// Bit LPCALB_SL.
	SNVS_HPLR_LPCALB_SL = 0x8
	// Write access is allowed
	SNVS_HPLR_LPCALB_SL_LPCALB_SL_0 = 0x0
	// Write access is not allowed
	SNVS_HPLR_LPCALB_SL_LPCALB_SL_1 = 0x1
	// Position of MC_SL field.
	SNVS_HPLR_MC_SL_Pos = 0x4
	// Bit mask of MC_SL field.
	SNVS_HPLR_MC_SL_Msk = 0x10
	// Bit MC_SL.
	SNVS_HPLR_MC_SL = 0x10
	// Write access (increment) is allowed
	SNVS_HPLR_MC_SL_MC_SL_0 = 0x0
	// Write access (increment) is not allowed
	SNVS_HPLR_MC_SL_MC_SL_1 = 0x1
	// Position of GPR_SL field.
	SNVS_HPLR_GPR_SL_Pos = 0x5
	// Bit mask of GPR_SL field.
	SNVS_HPLR_GPR_SL_Msk = 0x20
	// Bit GPR_SL.
	SNVS_HPLR_GPR_SL = 0x20
	// Write access is allowed
	SNVS_HPLR_GPR_SL_GPR_SL_0 = 0x0
	// Write access is not allowed
	SNVS_HPLR_GPR_SL_GPR_SL_1 = 0x1
	// Position of LPSVCR_SL field.
	SNVS_HPLR_LPSVCR_SL_Pos = 0x6
	// Bit mask of LPSVCR_SL field.
	SNVS_HPLR_LPSVCR_SL_Msk = 0x40
	// Bit LPSVCR_SL.
	SNVS_HPLR_LPSVCR_SL = 0x40
	// Write access is allowed
	SNVS_HPLR_LPSVCR_SL_LPSVCR_SL_0 = 0x0
	// Write access is not allowed
	SNVS_HPLR_LPSVCR_SL_LPSVCR_SL_1 = 0x1
	// Position of LPTDCR_SL field.
	SNVS_HPLR_LPTDCR_SL_Pos = 0x8
	// Bit mask of LPTDCR_SL field.
	SNVS_HPLR_LPTDCR_SL_Msk = 0x100
	// Bit LPTDCR_SL.
	SNVS_HPLR_LPTDCR_SL = 0x100
	// Write access is allowed
	SNVS_HPLR_LPTDCR_SL_LPTDCR_SL_0 = 0x0
	// Write access is not allowed
	SNVS_HPLR_LPTDCR_SL_LPTDCR_SL_1 = 0x1
	// Position of MKS_SL field.
	SNVS_HPLR_MKS_SL_Pos = 0x9
	// Bit mask of MKS_SL field.
	SNVS_HPLR_MKS_SL_Msk = 0x200
	// Bit MKS_SL.
	SNVS_HPLR_MKS_SL = 0x200
	// Write access is allowed
	SNVS_HPLR_MKS_SL_MKS_SL_0 = 0x0
	// Write access is not allowed
	SNVS_HPLR_MKS_SL_MKS_SL_1 = 0x1
	// Position of HPSVCR_L field.
	SNVS_HPLR_HPSVCR_L_Pos = 0x10
	// Bit mask of HPSVCR_L field.
	SNVS_HPLR_HPSVCR_L_Msk = 0x10000
	// Bit HPSVCR_L.
	SNVS_HPLR_HPSVCR_L = 0x10000
	// Write access is allowed
	SNVS_HPLR_HPSVCR_L_HPSVCR_L_0 = 0x0
	// Write access is not allowed
	SNVS_HPLR_HPSVCR_L_HPSVCR_L_1 = 0x1
	// Position of HPSICR_L field.
	SNVS_HPLR_HPSICR_L_Pos = 0x11
	// Bit mask of HPSICR_L field.
	SNVS_HPLR_HPSICR_L_Msk = 0x20000
	// Bit HPSICR_L.
	SNVS_HPLR_HPSICR_L = 0x20000
	// Write access is allowed
	SNVS_HPLR_HPSICR_L_HPSICR_L_0 = 0x0
	// Write access is not allowed
	SNVS_HPLR_HPSICR_L_HPSICR_L_1 = 0x1
	// Position of HAC_L field.
	SNVS_HPLR_HAC_L_Pos = 0x12
	// Bit mask of HAC_L field.
	SNVS_HPLR_HAC_L_Msk = 0x40000
	// Bit HAC_L.
	SNVS_HPLR_HAC_L = 0x40000
	// Write access is allowed
	SNVS_HPLR_HAC_L_HAC_L_0 = 0x0
	// Write access is not allowed
	SNVS_HPLR_HAC_L_HAC_L_1 = 0x1

	// HPCOMR: SNVS_HP Command Register
	// Position of SSM_ST field.
	SNVS_HPCOMR_SSM_ST_Pos = 0x0
	// Bit mask of SSM_ST field.
	SNVS_HPCOMR_SSM_ST_Msk = 0x1
	// Bit SSM_ST.
	SNVS_HPCOMR_SSM_ST = 0x1
	// Position of SSM_ST_DIS field.
	SNVS_HPCOMR_SSM_ST_DIS_Pos = 0x1
	// Bit mask of SSM_ST_DIS field.
	SNVS_HPCOMR_SSM_ST_DIS_Msk = 0x2
	// Bit SSM_ST_DIS.
	SNVS_HPCOMR_SSM_ST_DIS = 0x2
	// Secure to Trusted State transition is enabled
	SNVS_HPCOMR_SSM_ST_DIS_SSM_ST_DIS_0 = 0x0
	// Secure to Trusted State transition is disabled
	SNVS_HPCOMR_SSM_ST_DIS_SSM_ST_DIS_1 = 0x1
	// Position of SSM_SFNS_DIS field.
	SNVS_HPCOMR_SSM_SFNS_DIS_Pos = 0x2
	// Bit mask of SSM_SFNS_DIS field.
	SNVS_HPCOMR_SSM_SFNS_DIS_Msk = 0x4
	// Bit SSM_SFNS_DIS.
	SNVS_HPCOMR_SSM_SFNS_DIS = 0x4
	// Soft Fail to Non-Secure State transition is enabled
	SNVS_HPCOMR_SSM_SFNS_DIS_SSM_SFNS_DIS_0 = 0x0
	// Soft Fail to Non-Secure State transition is disabled
	SNVS_HPCOMR_SSM_SFNS_DIS_SSM_SFNS_DIS_1 = 0x1
	// Position of LP_SWR field.
	SNVS_HPCOMR_LP_SWR_Pos = 0x4
	// Bit mask of LP_SWR field.
	SNVS_HPCOMR_LP_SWR_Msk = 0x10
	// Bit LP_SWR.
	SNVS_HPCOMR_LP_SWR = 0x10
	// No Action
	SNVS_HPCOMR_LP_SWR_LP_SWR_0 = 0x0
	// Reset LP section
	SNVS_HPCOMR_LP_SWR_LP_SWR_1 = 0x1
	// Position of LP_SWR_DIS field.
	SNVS_HPCOMR_LP_SWR_DIS_Pos = 0x5
	// Bit mask of LP_SWR_DIS field.
	SNVS_HPCOMR_LP_SWR_DIS_Msk = 0x20
	// Bit LP_SWR_DIS.
	SNVS_HPCOMR_LP_SWR_DIS = 0x20
	// LP software reset is enabled
	SNVS_HPCOMR_LP_SWR_DIS_LP_SWR_DIS_0 = 0x0
	// LP software reset is disabled
	SNVS_HPCOMR_LP_SWR_DIS_LP_SWR_DIS_1 = 0x1
	// Position of SW_SV field.
	SNVS_HPCOMR_SW_SV_Pos = 0x8
	// Bit mask of SW_SV field.
	SNVS_HPCOMR_SW_SV_Msk = 0x100
	// Bit SW_SV.
	SNVS_HPCOMR_SW_SV = 0x100
	// Position of SW_FSV field.
	SNVS_HPCOMR_SW_FSV_Pos = 0x9
	// Bit mask of SW_FSV field.
	SNVS_HPCOMR_SW_FSV_Msk = 0x200
	// Bit SW_FSV.
	SNVS_HPCOMR_SW_FSV = 0x200
	// Position of SW_LPSV field.
	SNVS_HPCOMR_SW_LPSV_Pos = 0xa
	// Bit mask of SW_LPSV field.
	SNVS_HPCOMR_SW_LPSV_Msk = 0x400
	// Bit SW_LPSV.
	SNVS_HPCOMR_SW_LPSV = 0x400
	// Position of PROG_ZMK field.
	SNVS_HPCOMR_PROG_ZMK_Pos = 0xc
	// Bit mask of PROG_ZMK field.
	SNVS_HPCOMR_PROG_ZMK_Msk = 0x1000
	// Bit PROG_ZMK.
	SNVS_HPCOMR_PROG_ZMK = 0x1000
	// No Action
	SNVS_HPCOMR_PROG_ZMK_PROG_ZMK_0 = 0x0
	// Activate hardware key programming mechanism
	SNVS_HPCOMR_PROG_ZMK_PROG_ZMK_1 = 0x1
	// Position of MKS_EN field.
	SNVS_HPCOMR_MKS_EN_Pos = 0xd
	// Bit mask of MKS_EN field.
	SNVS_HPCOMR_MKS_EN_Msk = 0x2000
	// Bit MKS_EN.
	SNVS_HPCOMR_MKS_EN = 0x2000
	// OTP master key is selected as an SNVS master key
	SNVS_HPCOMR_MKS_EN_MKS_EN_0 = 0x0
	// SNVS master key is selected according to the setting of the MASTER_KEY_SEL field of LPMKCR
	SNVS_HPCOMR_MKS_EN_MKS_EN_1 = 0x1
	// Position of HAC_EN field.
	SNVS_HPCOMR_HAC_EN_Pos = 0x10
	// Bit mask of HAC_EN field.
	SNVS_HPCOMR_HAC_EN_Msk = 0x10000
	// Bit HAC_EN.
	SNVS_HPCOMR_HAC_EN = 0x10000
	// High Assurance Counter is disabled
	SNVS_HPCOMR_HAC_EN_HAC_EN_0 = 0x0
	// High Assurance Counter is enabled
	SNVS_HPCOMR_HAC_EN_HAC_EN_1 = 0x1
	// Position of HAC_LOAD field.
	SNVS_HPCOMR_HAC_LOAD_Pos = 0x11
	// Bit mask of HAC_LOAD field.
	SNVS_HPCOMR_HAC_LOAD_Msk = 0x20000
	// Bit HAC_LOAD.
	SNVS_HPCOMR_HAC_LOAD = 0x20000
	// No Action
	SNVS_HPCOMR_HAC_LOAD_HAC_LOAD_0 = 0x0
	// Load the HAC
	SNVS_HPCOMR_HAC_LOAD_HAC_LOAD_1 = 0x1
	// Position of HAC_CLEAR field.
	SNVS_HPCOMR_HAC_CLEAR_Pos = 0x12
	// Bit mask of HAC_CLEAR field.
	SNVS_HPCOMR_HAC_CLEAR_Msk = 0x40000
	// Bit HAC_CLEAR.
	SNVS_HPCOMR_HAC_CLEAR = 0x40000
	// No Action
	SNVS_HPCOMR_HAC_CLEAR_HAC_CLEAR_0 = 0x0
	// Clear the HAC
	SNVS_HPCOMR_HAC_CLEAR_HAC_CLEAR_1 = 0x1
	// Position of HAC_STOP field.
	SNVS_HPCOMR_HAC_STOP_Pos = 0x13
	// Bit mask of HAC_STOP field.
	SNVS_HPCOMR_HAC_STOP_Msk = 0x80000
	// Bit HAC_STOP.
	SNVS_HPCOMR_HAC_STOP = 0x80000
	// Position of NPSWA_EN field.
	SNVS_HPCOMR_NPSWA_EN_Pos = 0x1f
	// Bit mask of NPSWA_EN field.
	SNVS_HPCOMR_NPSWA_EN_Msk = 0x80000000
	// Bit NPSWA_EN.
	SNVS_HPCOMR_NPSWA_EN = 0x80000000

	// HPCR: SNVS_HP Control Register
	// Position of RTC_EN field.
	SNVS_HPCR_RTC_EN_Pos = 0x0
	// Bit mask of RTC_EN field.
	SNVS_HPCR_RTC_EN_Msk = 0x1
	// Bit RTC_EN.
	SNVS_HPCR_RTC_EN = 0x1
	// RTC is disabled
	SNVS_HPCR_RTC_EN_RTC_EN_0 = 0x0
	// RTC is enabled
	SNVS_HPCR_RTC_EN_RTC_EN_1 = 0x1
	// Position of HPTA_EN field.
	SNVS_HPCR_HPTA_EN_Pos = 0x1
	// Bit mask of HPTA_EN field.
	SNVS_HPCR_HPTA_EN_Msk = 0x2
	// Bit HPTA_EN.
	SNVS_HPCR_HPTA_EN = 0x2
	// HP Time Alarm Interrupt is disabled
	SNVS_HPCR_HPTA_EN_HPTA_EN_0 = 0x0
	// HP Time Alarm Interrupt is enabled
	SNVS_HPCR_HPTA_EN_HPTA_EN_1 = 0x1
	// Position of DIS_PI field.
	SNVS_HPCR_DIS_PI_Pos = 0x2
	// Bit mask of DIS_PI field.
	SNVS_HPCR_DIS_PI_Msk = 0x4
	// Bit DIS_PI.
	SNVS_HPCR_DIS_PI = 0x4
	// Periodic interrupt will trigger a functional interrupt
	SNVS_HPCR_DIS_PI_DIS_PI_0 = 0x0
	// Disable periodic interrupt in the function interrupt
	SNVS_HPCR_DIS_PI_DIS_PI_1 = 0x1
	// Position of PI_EN field.
	SNVS_HPCR_PI_EN_Pos = 0x3
	// Bit mask of PI_EN field.
	SNVS_HPCR_PI_EN_Msk = 0x8
	// Bit PI_EN.
	SNVS_HPCR_PI_EN = 0x8
	// HP Periodic Interrupt is disabled
	SNVS_HPCR_PI_EN_PI_EN_0 = 0x0
	// HP Periodic Interrupt is enabled
	SNVS_HPCR_PI_EN_PI_EN_1 = 0x1
	// Position of PI_FREQ field.
	SNVS_HPCR_PI_FREQ_Pos = 0x4
	// Bit mask of PI_FREQ field.
	SNVS_HPCR_PI_FREQ_Msk = 0xf0
	// - bit 0 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_0 = 0x0
	// - bit 1 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_1 = 0x1
	// - bit 2 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_2 = 0x2
	// - bit 3 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_3 = 0x3
	// - bit 4 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_4 = 0x4
	// - bit 5 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_5 = 0x5
	// - bit 6 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_6 = 0x6
	// - bit 7 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_7 = 0x7
	// - bit 8 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_8 = 0x8
	// - bit 9 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_9 = 0x9
	// - bit 10 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_10 = 0xa
	// - bit 11 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_11 = 0xb
	// - bit 12 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_12 = 0xc
	// - bit 13 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_13 = 0xd
	// - bit 14 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_14 = 0xe
	// - bit 15 of the HPRTCLR is selected as a source of the periodic interrupt
	SNVS_HPCR_PI_FREQ_PI_FREQ_15 = 0xf
	// Position of HPCALB_EN field.
	SNVS_HPCR_HPCALB_EN_Pos = 0x8
	// Bit mask of HPCALB_EN field.
	SNVS_HPCR_HPCALB_EN_Msk = 0x100
	// Bit HPCALB_EN.
	SNVS_HPCR_HPCALB_EN = 0x100
	// HP Timer calibration disabled
	SNVS_HPCR_HPCALB_EN_HPCALB_EN_0 = 0x0
	// HP Timer calibration enabled
	SNVS_HPCR_HPCALB_EN_HPCALB_EN_1 = 0x1
	// Position of HPCALB_VAL field.
	SNVS_HPCR_HPCALB_VAL_Pos = 0xa
	// Bit mask of HPCALB_VAL field.
	SNVS_HPCR_HPCALB_VAL_Msk = 0x7c00
	// +0 counts per each 32768 ticks of the counter
	SNVS_HPCR_HPCALB_VAL_HPCALB_VAL_0 = 0x0
	// +1 counts per each 32768 ticks of the counter
	SNVS_HPCR_HPCALB_VAL_HPCALB_VAL_1 = 0x1
	// +2 counts per each 32768 ticks of the counter
	SNVS_HPCR_HPCALB_VAL_HPCALB_VAL_2 = 0x2
	// +15 counts per each 32768 ticks of the counter
	SNVS_HPCR_HPCALB_VAL_HPCALB_VAL_15 = 0xf
	// -16 counts per each 32768 ticks of the counter
	SNVS_HPCR_HPCALB_VAL_HPCALB_VAL_16 = 0x10
	// -15 counts per each 32768 ticks of the counter
	SNVS_HPCR_HPCALB_VAL_HPCALB_VAL_17 = 0x11
	// -2 counts per each 32768 ticks of the counter
	SNVS_HPCR_HPCALB_VAL_HPCALB_VAL_30 = 0x1e
	// -1 counts per each 32768 ticks of the counter
	SNVS_HPCR_HPCALB_VAL_HPCALB_VAL_31 = 0x1f
	// Position of HP_TS field.
	SNVS_HPCR_HP_TS_Pos = 0x10
	// Bit mask of HP_TS field.
	SNVS_HPCR_HP_TS_Msk = 0x10000
	// Bit HP_TS.
	SNVS_HPCR_HP_TS = 0x10000
	// No Action
	SNVS_HPCR_HP_TS_HP_TS_0 = 0x0
	// Synchronize the HP Time Counter to the LP Time Counter
	SNVS_HPCR_HP_TS_HP_TS_1 = 0x1
	// Position of BTN_CONFIG field.
	SNVS_HPCR_BTN_CONFIG_Pos = 0x18
	// Bit mask of BTN_CONFIG field.
	SNVS_HPCR_BTN_CONFIG_Msk = 0x7000000
	// Position of BTN_MASK field.
	SNVS_HPCR_BTN_MASK_Pos = 0x1b
	// Bit mask of BTN_MASK field.
	SNVS_HPCR_BTN_MASK_Msk = 0x8000000
	// Bit BTN_MASK.
	SNVS_HPCR_BTN_MASK = 0x8000000

	// HPSICR: SNVS_HP Security Interrupt Control Register
	// Position of SV0_EN field.
	SNVS_HPSICR_SV0_EN_Pos = 0x0
	// Bit mask of SV0_EN field.
	SNVS_HPSICR_SV0_EN_Msk = 0x1
	// Bit SV0_EN.
	SNVS_HPSICR_SV0_EN = 0x1
	// Security Violation 0 Interrupt is Disabled
	SNVS_HPSICR_SV0_EN_SV0_EN_0 = 0x0
	// Security Violation 0 Interrupt is Enabled
	SNVS_HPSICR_SV0_EN_SV0_EN_1 = 0x1
	// Position of SV1_EN field.
	SNVS_HPSICR_SV1_EN_Pos = 0x1
	// Bit mask of SV1_EN field.
	SNVS_HPSICR_SV1_EN_Msk = 0x2
	// Bit SV1_EN.
	SNVS_HPSICR_SV1_EN = 0x2
	// Security Violation 1 Interrupt is Disabled
	SNVS_HPSICR_SV1_EN_SV1_EN_0 = 0x0
	// Security Violation 1 Interrupt is Enabled
	SNVS_HPSICR_SV1_EN_SV1_EN_1 = 0x1
	// Position of SV2_EN field.
	SNVS_HPSICR_SV2_EN_Pos = 0x2
	// Bit mask of SV2_EN field.
	SNVS_HPSICR_SV2_EN_Msk = 0x4
	// Bit SV2_EN.
	SNVS_HPSICR_SV2_EN = 0x4
	// Security Violation 2 Interrupt is Disabled
	SNVS_HPSICR_SV2_EN_SV2_EN_0 = 0x0
	// Security Violation 2 Interrupt is Enabled
	SNVS_HPSICR_SV2_EN_SV2_EN_1 = 0x1
	// Position of SV3_EN field.
	SNVS_HPSICR_SV3_EN_Pos = 0x3
	// Bit mask of SV3_EN field.
	SNVS_HPSICR_SV3_EN_Msk = 0x8
	// Bit SV3_EN.
	SNVS_HPSICR_SV3_EN = 0x8
	// Security Violation 3 Interrupt is Disabled
	SNVS_HPSICR_SV3_EN_SV3_EN_0 = 0x0
	// Security Violation 3 Interrupt is Enabled
	SNVS_HPSICR_SV3_EN_SV3_EN_1 = 0x1
	// Position of SV4_EN field.
	SNVS_HPSICR_SV4_EN_Pos = 0x4
	// Bit mask of SV4_EN field.
	SNVS_HPSICR_SV4_EN_Msk = 0x10
	// Bit SV4_EN.
	SNVS_HPSICR_SV4_EN = 0x10
	// Security Violation 4 Interrupt is Disabled
	SNVS_HPSICR_SV4_EN_SV4_EN_0 = 0x0
	// Security Violation 4 Interrupt is Enabled
	SNVS_HPSICR_SV4_EN_SV4_EN_1 = 0x1
	// Position of SV5_EN field.
	SNVS_HPSICR_SV5_EN_Pos = 0x5
	// Bit mask of SV5_EN field.
	SNVS_HPSICR_SV5_EN_Msk = 0x20
	// Bit SV5_EN.
	SNVS_HPSICR_SV5_EN = 0x20
	// Security Violation 5 Interrupt is Disabled
	SNVS_HPSICR_SV5_EN_SV5_EN_0 = 0x0
	// Security Violation 5 Interrupt is Enabled
	SNVS_HPSICR_SV5_EN_SV5_EN_1 = 0x1
	// Position of LPSVI_EN field.
	SNVS_HPSICR_LPSVI_EN_Pos = 0x1f
	// Bit mask of LPSVI_EN field.
	SNVS_HPSICR_LPSVI_EN_Msk = 0x80000000
	// Bit LPSVI_EN.
	SNVS_HPSICR_LPSVI_EN = 0x80000000
	// LP Security Violation Interrupt is Disabled
	SNVS_HPSICR_LPSVI_EN_LPSVI_EN_0 = 0x0
	// LP Security Violation Interrupt is Enabled
	SNVS_HPSICR_LPSVI_EN_LPSVI_EN_1 = 0x1

	// HPSVCR: SNVS_HP Security Violation Control Register
	// Position of SV0_CFG field.
	SNVS_HPSVCR_SV0_CFG_Pos = 0x0
	// Bit mask of SV0_CFG field.
	SNVS_HPSVCR_SV0_CFG_Msk = 0x1
	// Bit SV0_CFG.
	SNVS_HPSVCR_SV0_CFG = 0x1
	// Security Violation 0 is a non-fatal violation
	SNVS_HPSVCR_SV0_CFG_SV0_CFG_0 = 0x0
	// Security Violation 0 is a fatal violation
	SNVS_HPSVCR_SV0_CFG_SV0_CFG_1 = 0x1
	// Position of SV1_CFG field.
	SNVS_HPSVCR_SV1_CFG_Pos = 0x1
	// Bit mask of SV1_CFG field.
	SNVS_HPSVCR_SV1_CFG_Msk = 0x2
	// Bit SV1_CFG.
	SNVS_HPSVCR_SV1_CFG = 0x2
	// Security Violation 1 is a non-fatal violation
	SNVS_HPSVCR_SV1_CFG_SV1_CFG_0 = 0x0
	// Security Violation 1 is a fatal violation
	SNVS_HPSVCR_SV1_CFG_SV1_CFG_1 = 0x1
	// Position of SV2_CFG field.
	SNVS_HPSVCR_SV2_CFG_Pos = 0x2
	// Bit mask of SV2_CFG field.
	SNVS_HPSVCR_SV2_CFG_Msk = 0x4
	// Bit SV2_CFG.
	SNVS_HPSVCR_SV2_CFG = 0x4
	// Security Violation 2 is a non-fatal violation
	SNVS_HPSVCR_SV2_CFG_SV2_CFG_0 = 0x0
	// Security Violation 2 is a fatal violation
	SNVS_HPSVCR_SV2_CFG_SV2_CFG_1 = 0x1
	// Position of SV3_CFG field.
	SNVS_HPSVCR_SV3_CFG_Pos = 0x3
	// Bit mask of SV3_CFG field.
	SNVS_HPSVCR_SV3_CFG_Msk = 0x8
	// Bit SV3_CFG.
	SNVS_HPSVCR_SV3_CFG = 0x8
	// Security Violation 3 is a non-fatal violation
	SNVS_HPSVCR_SV3_CFG_SV3_CFG_0 = 0x0
	// Security Violation 3 is a fatal violation
	SNVS_HPSVCR_SV3_CFG_SV3_CFG_1 = 0x1
	// Position of SV4_CFG field.
	SNVS_HPSVCR_SV4_CFG_Pos = 0x4
	// Bit mask of SV4_CFG field.
	SNVS_HPSVCR_SV4_CFG_Msk = 0x10
	// Bit SV4_CFG.
	SNVS_HPSVCR_SV4_CFG = 0x10
	// Security Violation 4 is a non-fatal violation
	SNVS_HPSVCR_SV4_CFG_SV4_CFG_0 = 0x0
	// Security Violation 4 is a fatal violation
	SNVS_HPSVCR_SV4_CFG_SV4_CFG_1 = 0x1
	// Position of SV5_CFG field.
	SNVS_HPSVCR_SV5_CFG_Pos = 0x5
	// Bit mask of SV5_CFG field.
	SNVS_HPSVCR_SV5_CFG_Msk = 0x60
	// Security Violation 5 is disabled
	SNVS_HPSVCR_SV5_CFG_SV5_CFG_0 = 0x0
	// Security Violation 5 is a non-fatal violation
	SNVS_HPSVCR_SV5_CFG_SV5_CFG_1 = 0x1
	// Security Violation 5 is a fatal violation
	SNVS_HPSVCR_SV5_CFG_SV5_CFG_2 = 0x2
	// Position of LPSV_CFG field.
	SNVS_HPSVCR_LPSV_CFG_Pos = 0x1e
	// Bit mask of LPSV_CFG field.
	SNVS_HPSVCR_LPSV_CFG_Msk = 0xc0000000
	// LP security violation is disabled
	SNVS_HPSVCR_LPSV_CFG_LPSV_CFG_0 = 0x0
	// LP security violation is a non-fatal violation
	SNVS_HPSVCR_LPSV_CFG_LPSV_CFG_1 = 0x1
	// LP security violation is a fatal violation
	SNVS_HPSVCR_LPSV_CFG_LPSV_CFG_2 = 0x2

	// HPSR: SNVS_HP Status Register
	// Position of HPTA field.
	SNVS_HPSR_HPTA_Pos = 0x0
	// Bit mask of HPTA field.
	SNVS_HPSR_HPTA_Msk = 0x1
	// Bit HPTA.
	SNVS_HPSR_HPTA = 0x1
	// No time alarm interrupt occurred.
	SNVS_HPSR_HPTA_HPTA_0 = 0x0
	// A time alarm interrupt occurred.
	SNVS_HPSR_HPTA_HPTA_1 = 0x1
	// Position of PI field.
	SNVS_HPSR_PI_Pos = 0x1
	// Bit mask of PI field.
	SNVS_HPSR_PI_Msk = 0x2
	// Bit PI.
	SNVS_HPSR_PI = 0x2
	// No periodic interrupt occurred.
	SNVS_HPSR_PI_PI_0 = 0x0
	// A periodic interrupt occurred.
	SNVS_HPSR_PI_PI_1 = 0x1
	// Position of LPDIS field.
	SNVS_HPSR_LPDIS_Pos = 0x4
	// Bit mask of LPDIS field.
	SNVS_HPSR_LPDIS_Msk = 0x10
	// Bit LPDIS.
	SNVS_HPSR_LPDIS = 0x10
	// Position of BTN field.
	SNVS_HPSR_BTN_Pos = 0x6
	// Bit mask of BTN field.
	SNVS_HPSR_BTN_Msk = 0x40
	// Bit BTN.
	SNVS_HPSR_BTN = 0x40
	// Position of BI field.
	SNVS_HPSR_BI_Pos = 0x7
	// Bit mask of BI field.
	SNVS_HPSR_BI_Msk = 0x80
	// Bit BI.
	SNVS_HPSR_BI = 0x80
	// Position of SSM_STATE field.
	SNVS_HPSR_SSM_STATE_Pos = 0x8
	// Bit mask of SSM_STATE field.
	SNVS_HPSR_SSM_STATE_Msk = 0xf00
	// Init
	SNVS_HPSR_SSM_STATE_SSM_STATE_0 = 0x0
	// Hard Fail
	SNVS_HPSR_SSM_STATE_SSM_STATE_1 = 0x1
	// Soft Fail
	SNVS_HPSR_SSM_STATE_SSM_STATE_3 = 0x3
	// Init Intermediate (transition state between Init and Check - SSM stays in this state only one clock cycle)
	SNVS_HPSR_SSM_STATE_SSM_STATE_8 = 0x8
	// Check
	SNVS_HPSR_SSM_STATE_SSM_STATE_9 = 0x9
	// Non-Secure
	SNVS_HPSR_SSM_STATE_SSM_STATE_11 = 0xb
	// Trusted
	SNVS_HPSR_SSM_STATE_SSM_STATE_13 = 0xd
	// Secure
	SNVS_HPSR_SSM_STATE_SSM_STATE_15 = 0xf
	// Position of SECURITY_CONFIG field.
	SNVS_HPSR_SECURITY_CONFIG_Pos = 0xc
	// Bit mask of SECURITY_CONFIG field.
	SNVS_HPSR_SECURITY_CONFIG_Msk = 0xf000
	// FIELD RETURN configuration
	SNVS_HPSR_SECURITY_CONFIG_FIELD_RETURN_CONFIG = 0x4
	// Position of OTPMK_SYNDROME field.
	SNVS_HPSR_OTPMK_SYNDROME_Pos = 0x10
	// Bit mask of OTPMK_SYNDROME field.
	SNVS_HPSR_OTPMK_SYNDROME_Msk = 0x1ff0000
	// Position of OTPMK_ZERO field.
	SNVS_HPSR_OTPMK_ZERO_Pos = 0x1b
	// Bit mask of OTPMK_ZERO field.
	SNVS_HPSR_OTPMK_ZERO_Msk = 0x8000000
	// Bit OTPMK_ZERO.
	SNVS_HPSR_OTPMK_ZERO = 0x8000000
	// The OTPMK is not zero.
	SNVS_HPSR_OTPMK_ZERO_OTPMK_ZERO_0 = 0x0
	// The OTPMK is zero.
	SNVS_HPSR_OTPMK_ZERO_OTPMK_ZERO_1 = 0x1
	// Position of ZMK_ZERO field.
	SNVS_HPSR_ZMK_ZERO_Pos = 0x1f
	// Bit mask of ZMK_ZERO field.
	SNVS_HPSR_ZMK_ZERO_Msk = 0x80000000
	// Bit ZMK_ZERO.
	SNVS_HPSR_ZMK_ZERO = 0x80000000
	// The ZMK is not zero.
	SNVS_HPSR_ZMK_ZERO_ZMK_ZERO_0 = 0x0
	// The ZMK is zero.
	SNVS_HPSR_ZMK_ZERO_ZMK_ZERO_1 = 0x1

	// HPSVSR: SNVS_HP Security Violation Status Register
	// Position of SV0 field.
	SNVS_HPSVSR_SV0_Pos = 0x0
	// Bit mask of SV0 field.
	SNVS_HPSVSR_SV0_Msk = 0x1
	// Bit SV0.
	SNVS_HPSVSR_SV0 = 0x1
	// No Security Violation 0 security violation was detected.
	SNVS_HPSVSR_SV0_SV0_0 = 0x0
	// Security Violation 0 security violation was detected.
	SNVS_HPSVSR_SV0_SV0_1 = 0x1
	// Position of SV1 field.
	SNVS_HPSVSR_SV1_Pos = 0x1
	// Bit mask of SV1 field.
	SNVS_HPSVSR_SV1_Msk = 0x2
	// Bit SV1.
	SNVS_HPSVSR_SV1 = 0x2
	// No Security Violation 1 security violation was detected.
	SNVS_HPSVSR_SV1_SV1_0 = 0x0
	// Security Violation 1 security violation was detected.
	SNVS_HPSVSR_SV1_SV1_1 = 0x1
	// Position of SV2 field.
	SNVS_HPSVSR_SV2_Pos = 0x2
	// Bit mask of SV2 field.
	SNVS_HPSVSR_SV2_Msk = 0x4
	// Bit SV2.
	SNVS_HPSVSR_SV2 = 0x4
	// No Security Violation 2 security violation was detected.
	SNVS_HPSVSR_SV2_SV2_0 = 0x0
	// Security Violation 2 security violation was detected.
	SNVS_HPSVSR_SV2_SV2_1 = 0x1
	// Position of SV3 field.
	SNVS_HPSVSR_SV3_Pos = 0x3
	// Bit mask of SV3 field.
	SNVS_HPSVSR_SV3_Msk = 0x8
	// Bit SV3.
	SNVS_HPSVSR_SV3 = 0x8
	// No Security Violation 3 security violation was detected.
	SNVS_HPSVSR_SV3_SV3_0 = 0x0
	// Security Violation 3 security violation was detected.
	SNVS_HPSVSR_SV3_SV3_1 = 0x1
	// Position of SV4 field.
	SNVS_HPSVSR_SV4_Pos = 0x4
	// Bit mask of SV4 field.
	SNVS_HPSVSR_SV4_Msk = 0x10
	// Bit SV4.
	SNVS_HPSVSR_SV4 = 0x10
	// No Security Violation 4 security violation was detected.
	SNVS_HPSVSR_SV4_SV4_0 = 0x0
	// Security Violation 4 security violation was detected.
	SNVS_HPSVSR_SV4_SV4_1 = 0x1
	// Position of SV5 field.
	SNVS_HPSVSR_SV5_Pos = 0x5
	// Bit mask of SV5 field.
	SNVS_HPSVSR_SV5_Msk = 0x20
	// Bit SV5.
	SNVS_HPSVSR_SV5 = 0x20
	// No Security Violation 5 security violation was detected.
	SNVS_HPSVSR_SV5_SV5_0 = 0x0
	// Security Violation 5 security violation was detected.
	SNVS_HPSVSR_SV5_SV5_1 = 0x1
	// Position of SW_SV field.
	SNVS_HPSVSR_SW_SV_Pos = 0xd
	// Bit mask of SW_SV field.
	SNVS_HPSVSR_SW_SV_Msk = 0x2000
	// Bit SW_SV.
	SNVS_HPSVSR_SW_SV = 0x2000
	// Position of SW_FSV field.
	SNVS_HPSVSR_SW_FSV_Pos = 0xe
	// Bit mask of SW_FSV field.
	SNVS_HPSVSR_SW_FSV_Msk = 0x4000
	// Bit SW_FSV.
	SNVS_HPSVSR_SW_FSV = 0x4000
	// Position of SW_LPSV field.
	SNVS_HPSVSR_SW_LPSV_Pos = 0xf
	// Bit mask of SW_LPSV field.
	SNVS_HPSVSR_SW_LPSV_Msk = 0x8000
	// Bit SW_LPSV.
	SNVS_HPSVSR_SW_LPSV = 0x8000
	// Position of ZMK_SYNDROME field.
	SNVS_HPSVSR_ZMK_SYNDROME_Pos = 0x10
	// Bit mask of ZMK_SYNDROME field.
	SNVS_HPSVSR_ZMK_SYNDROME_Msk = 0x1ff0000
	// Position of ZMK_ECC_FAIL field.
	SNVS_HPSVSR_ZMK_ECC_FAIL_Pos = 0x1b
	// Bit mask of ZMK_ECC_FAIL field.
	SNVS_HPSVSR_ZMK_ECC_FAIL_Msk = 0x8000000
	// Bit ZMK_ECC_FAIL.
	SNVS_HPSVSR_ZMK_ECC_FAIL = 0x8000000
	// ZMK ECC Failure was not detected.
	SNVS_HPSVSR_ZMK_ECC_FAIL_ZMK_ECC_FAIL_0 = 0x0
	// ZMK ECC Failure was detected.
	SNVS_HPSVSR_ZMK_ECC_FAIL_ZMK_ECC_FAIL_1 = 0x1
	// Position of LP_SEC_VIO field.
	SNVS_HPSVSR_LP_SEC_VIO_Pos = 0x1f
	// Bit mask of LP_SEC_VIO field.
	SNVS_HPSVSR_LP_SEC_VIO_Msk = 0x80000000
	// Bit LP_SEC_VIO.
	SNVS_HPSVSR_LP_SEC_VIO = 0x80000000

	// HPHACIVR: SNVS_HP High Assurance Counter IV Register
	// Position of HAC_COUNTER_IV field.
	SNVS_HPHACIVR_HAC_COUNTER_IV_Pos = 0x0
	// Bit mask of HAC_COUNTER_IV field.
	SNVS_HPHACIVR_HAC_COUNTER_IV_Msk = 0xffffffff

	// HPHACR: SNVS_HP High Assurance Counter Register
	// Position of HAC_COUNTER field.
	SNVS_HPHACR_HAC_COUNTER_Pos = 0x0
	// Bit mask of HAC_COUNTER field.
	SNVS_HPHACR_HAC_COUNTER_Msk = 0xffffffff

	// HPRTCMR: SNVS_HP Real Time Counter MSB Register
	// Position of RTC field.
	SNVS_HPRTCMR_RTC_Pos = 0x0
	// Bit mask of RTC field.
	SNVS_HPRTCMR_RTC_Msk = 0x7fff

	// HPRTCLR: SNVS_HP Real Time Counter LSB Register
	// Position of RTC field.
	SNVS_HPRTCLR_RTC_Pos = 0x0
	// Bit mask of RTC field.
	SNVS_HPRTCLR_RTC_Msk = 0xffffffff

	// HPTAMR: SNVS_HP Time Alarm MSB Register
	// Position of HPTA_MS field.
	SNVS_HPTAMR_HPTA_MS_Pos = 0x0
	// Bit mask of HPTA_MS field.
	SNVS_HPTAMR_HPTA_MS_Msk = 0x7fff

	// HPTALR: SNVS_HP Time Alarm LSB Register
	// Position of HPTA_LS field.
	SNVS_HPTALR_HPTA_LS_Pos = 0x0
	// Bit mask of HPTA_LS field.
	SNVS_HPTALR_HPTA_LS_Msk = 0xffffffff

	// LPLR: SNVS_LP Lock Register
	// Position of ZMK_WHL field.
	SNVS_LPLR_ZMK_WHL_Pos = 0x0
	// Bit mask of ZMK_WHL field.
	SNVS_LPLR_ZMK_WHL_Msk = 0x1
	// Bit ZMK_WHL.
	SNVS_LPLR_ZMK_WHL = 0x1
	// Write access is allowed.
	SNVS_LPLR_ZMK_WHL_ZMK_WHL_0 = 0x0
	// Write access is not allowed.
	SNVS_LPLR_ZMK_WHL_ZMK_WHL_1 = 0x1
	// Position of ZMK_RHL field.
	SNVS_LPLR_ZMK_RHL_Pos = 0x1
	// Bit mask of ZMK_RHL field.
	SNVS_LPLR_ZMK_RHL_Msk = 0x2
	// Bit ZMK_RHL.
	SNVS_LPLR_ZMK_RHL = 0x2
	// Read access is allowed (only in software programming mode).
	SNVS_LPLR_ZMK_RHL_ZMK_RHL_0 = 0x0
	// Read access is not allowed.
	SNVS_LPLR_ZMK_RHL_ZMK_RHL_1 = 0x1
	// Position of SRTC_HL field.
	SNVS_LPLR_SRTC_HL_Pos = 0x2
	// Bit mask of SRTC_HL field.
	SNVS_LPLR_SRTC_HL_Msk = 0x4
	// Bit SRTC_HL.
	SNVS_LPLR_SRTC_HL = 0x4
	// Write access is allowed.
	SNVS_LPLR_SRTC_HL_SRTC_HL_0 = 0x0
	// Write access is not allowed.
	SNVS_LPLR_SRTC_HL_SRTC_HL_1 = 0x1
	// Position of LPCALB_HL field.
	SNVS_LPLR_LPCALB_HL_Pos = 0x3
	// Bit mask of LPCALB_HL field.
	SNVS_LPLR_LPCALB_HL_Msk = 0x8
	// Bit LPCALB_HL.
	SNVS_LPLR_LPCALB_HL = 0x8
	// Write access is allowed.
	SNVS_LPLR_LPCALB_HL_LPCALB_HL_0 = 0x0
	// Write access is not allowed.
	SNVS_LPLR_LPCALB_HL_LPCALB_HL_1 = 0x1
	// Position of MC_HL field.
	SNVS_LPLR_MC_HL_Pos = 0x4
	// Bit mask of MC_HL field.
	SNVS_LPLR_MC_HL_Msk = 0x10
	// Bit MC_HL.
	SNVS_LPLR_MC_HL = 0x10
	// Write access (increment) is allowed.
	SNVS_LPLR_MC_HL_MC_HL_0 = 0x0
	// Write access (increment) is not allowed.
	SNVS_LPLR_MC_HL_MC_HL_1 = 0x1
	// Position of GPR_HL field.
	SNVS_LPLR_GPR_HL_Pos = 0x5
	// Bit mask of GPR_HL field.
	SNVS_LPLR_GPR_HL_Msk = 0x20
	// Bit GPR_HL.
	SNVS_LPLR_GPR_HL = 0x20
	// Write access is allowed.
	SNVS_LPLR_GPR_HL_GPR_HL_0 = 0x0
	// Write access is not allowed.
	SNVS_LPLR_GPR_HL_GPR_HL_1 = 0x1
	// Position of LPSVCR_HL field.
	SNVS_LPLR_LPSVCR_HL_Pos = 0x6
	// Bit mask of LPSVCR_HL field.
	SNVS_LPLR_LPSVCR_HL_Msk = 0x40
	// Bit LPSVCR_HL.
	SNVS_LPLR_LPSVCR_HL = 0x40
	// Write access is allowed.
	SNVS_LPLR_LPSVCR_HL_LPSVCR_HL_0 = 0x0
	// Write access is not allowed.
	SNVS_LPLR_LPSVCR_HL_LPSVCR_HL_1 = 0x1
	// Position of LPTDCR_HL field.
	SNVS_LPLR_LPTDCR_HL_Pos = 0x8
	// Bit mask of LPTDCR_HL field.
	SNVS_LPLR_LPTDCR_HL_Msk = 0x100
	// Bit LPTDCR_HL.
	SNVS_LPLR_LPTDCR_HL = 0x100
	// Write access is allowed.
	SNVS_LPLR_LPTDCR_HL_LPTDCR_HL_0 = 0x0
	// Write access is not allowed.
	SNVS_LPLR_LPTDCR_HL_LPTDCR_HL_1 = 0x1
	// Position of MKS_HL field.
	SNVS_LPLR_MKS_HL_Pos = 0x9
	// Bit mask of MKS_HL field.
	SNVS_LPLR_MKS_HL_Msk = 0x200
	// Bit MKS_HL.
	SNVS_LPLR_MKS_HL = 0x200
	// Write access is allowed.
	SNVS_LPLR_MKS_HL_MKS_HL_0 = 0x0
	// Write access is not allowed.
	SNVS_LPLR_MKS_HL_MKS_HL_1 = 0x1

	// LPCR: SNVS_LP Control Register
	// Position of SRTC_ENV field.
	SNVS_LPCR_SRTC_ENV_Pos = 0x0
	// Bit mask of SRTC_ENV field.
	SNVS_LPCR_SRTC_ENV_Msk = 0x1
	// Bit SRTC_ENV.
	SNVS_LPCR_SRTC_ENV = 0x1
	// SRTC is disabled or invalid.
	SNVS_LPCR_SRTC_ENV_SRTC_ENV_0 = 0x0
	// SRTC is enabled and valid.
	SNVS_LPCR_SRTC_ENV_SRTC_ENV_1 = 0x1
	// Position of LPTA_EN field.
	SNVS_LPCR_LPTA_EN_Pos = 0x1
	// Bit mask of LPTA_EN field.
	SNVS_LPCR_LPTA_EN_Msk = 0x2
	// Bit LPTA_EN.
	SNVS_LPCR_LPTA_EN = 0x2
	// LP time alarm interrupt is disabled.
	SNVS_LPCR_LPTA_EN_LPTA_EN_0 = 0x0
	// LP time alarm interrupt is enabled.
	SNVS_LPCR_LPTA_EN_LPTA_EN_1 = 0x1
	// Position of MC_ENV field.
	SNVS_LPCR_MC_ENV_Pos = 0x2
	// Bit mask of MC_ENV field.
	SNVS_LPCR_MC_ENV_Msk = 0x4
	// Bit MC_ENV.
	SNVS_LPCR_MC_ENV = 0x4
	// MC is disabled or invalid.
	SNVS_LPCR_MC_ENV_MC_ENV_0 = 0x0
	// MC is enabled and valid.
	SNVS_LPCR_MC_ENV_MC_ENV_1 = 0x1
	// Position of LPWUI_EN field.
	SNVS_LPCR_LPWUI_EN_Pos = 0x3
	// Bit mask of LPWUI_EN field.
	SNVS_LPCR_LPWUI_EN_Msk = 0x8
	// Bit LPWUI_EN.
	SNVS_LPCR_LPWUI_EN = 0x8
	// Position of SRTC_INV_EN field.
	SNVS_LPCR_SRTC_INV_EN_Pos = 0x4
	// Bit mask of SRTC_INV_EN field.
	SNVS_LPCR_SRTC_INV_EN_Msk = 0x10
	// Bit SRTC_INV_EN.
	SNVS_LPCR_SRTC_INV_EN = 0x10
	// SRTC stays valid in the case of security violation.
	SNVS_LPCR_SRTC_INV_EN_SRTC_INV_EN_0 = 0x0
	// SRTC is invalidated in the case of security violation.
	SNVS_LPCR_SRTC_INV_EN_SRTC_INV_EN_1 = 0x1
	// Position of DP_EN field.
	SNVS_LPCR_DP_EN_Pos = 0x5
	// Bit mask of DP_EN field.
	SNVS_LPCR_DP_EN_Msk = 0x20
	// Bit DP_EN.
	SNVS_LPCR_DP_EN = 0x20
	// Smart PMIC enabled.
	SNVS_LPCR_DP_EN_DP_EN_0 = 0x0
	// Dumb PMIC enabled.
	SNVS_LPCR_DP_EN_DP_EN_1 = 0x1
	// Position of TOP field.
	SNVS_LPCR_TOP_Pos = 0x6
	// Bit mask of TOP field.
	SNVS_LPCR_TOP_Msk = 0x40
	// Bit TOP.
	SNVS_LPCR_TOP = 0x40
	// Leave system power on.
	SNVS_LPCR_TOP_TOP_0 = 0x0
	// Turn off system power.
	SNVS_LPCR_TOP_TOP_1 = 0x1
	// Position of PWR_GLITCH_EN field.
	SNVS_LPCR_PWR_GLITCH_EN_Pos = 0x7
	// Bit mask of PWR_GLITCH_EN field.
	SNVS_LPCR_PWR_GLITCH_EN_Msk = 0x80
	// Bit PWR_GLITCH_EN.
	SNVS_LPCR_PWR_GLITCH_EN = 0x80
	// Position of LPCALB_EN field.
	SNVS_LPCR_LPCALB_EN_Pos = 0x8
	// Bit mask of LPCALB_EN field.
	SNVS_LPCR_LPCALB_EN_Msk = 0x100
	// Bit LPCALB_EN.
	SNVS_LPCR_LPCALB_EN = 0x100
	// SRTC Time calibration is disabled.
	SNVS_LPCR_LPCALB_EN_LPCALB_EN_0 = 0x0
	// SRTC Time calibration is enabled.
	SNVS_LPCR_LPCALB_EN_LPCALB_EN_1 = 0x1
	// Position of LPCALB_VAL field.
	SNVS_LPCR_LPCALB_VAL_Pos = 0xa
	// Bit mask of LPCALB_VAL field.
	SNVS_LPCR_LPCALB_VAL_Msk = 0x7c00
	// +0 counts per each 32768 ticks of the counter clock
	SNVS_LPCR_LPCALB_VAL_LPCALB_VAL_0 = 0x0
	// +1 counts per each 32768 ticks of the counter clock
	SNVS_LPCR_LPCALB_VAL_LPCALB_VAL_1 = 0x1
	// +2 counts per each 32768 ticks of the counter clock
	SNVS_LPCR_LPCALB_VAL_LPCALB_VAL_2 = 0x2
	// +15 counts per each 32768 ticks of the counter clock
	SNVS_LPCR_LPCALB_VAL_LPCALB_VAL_15 = 0xf
	// -16 counts per each 32768 ticks of the counter clock
	SNVS_LPCR_LPCALB_VAL_LPCALB_VAL_16 = 0x10
	// -15 counts per each 32768 ticks of the counter clock
	SNVS_LPCR_LPCALB_VAL_LPCALB_VAL_17 = 0x11
	// -2 counts per each 32768 ticks of the counter clock
	SNVS_LPCR_LPCALB_VAL_LPCALB_VAL_30 = 0x1e
	// -1 counts per each 32768 ticks of the counter clock
	SNVS_LPCR_LPCALB_VAL_LPCALB_VAL_31 = 0x1f
	// Position of BTN_PRESS_TIME field.
	SNVS_LPCR_BTN_PRESS_TIME_Pos = 0x10
	// Bit mask of BTN_PRESS_TIME field.
	SNVS_LPCR_BTN_PRESS_TIME_Msk = 0x30000
	// Position of DEBOUNCE field.
	SNVS_LPCR_DEBOUNCE_Pos = 0x12
	// Bit mask of DEBOUNCE field.
	SNVS_LPCR_DEBOUNCE_Msk = 0xc0000
	// Position of ON_TIME field.
	SNVS_LPCR_ON_TIME_Pos = 0x14
	// Bit mask of ON_TIME field.
	SNVS_LPCR_ON_TIME_Msk = 0x300000
	// Position of PK_EN field.
	SNVS_LPCR_PK_EN_Pos = 0x16
	// Bit mask of PK_EN field.
	SNVS_LPCR_PK_EN_Msk = 0x400000
	// Bit PK_EN.
	SNVS_LPCR_PK_EN = 0x400000
	// Position of PK_OVERRIDE field.
	SNVS_LPCR_PK_OVERRIDE_Pos = 0x17
	// Bit mask of PK_OVERRIDE field.
	SNVS_LPCR_PK_OVERRIDE_Msk = 0x800000
	// Bit PK_OVERRIDE.
	SNVS_LPCR_PK_OVERRIDE = 0x800000
	// Position of GPR_Z_DIS field.
	SNVS_LPCR_GPR_Z_DIS_Pos = 0x18
	// Bit mask of GPR_Z_DIS field.
	SNVS_LPCR_GPR_Z_DIS_Msk = 0x1000000
	// Bit GPR_Z_DIS.
	SNVS_LPCR_GPR_Z_DIS = 0x1000000

	// LPMKCR: SNVS_LP Master Key Control Register
	// Position of MASTER_KEY_SEL field.
	SNVS_LPMKCR_MASTER_KEY_SEL_Pos = 0x0
	// Bit mask of MASTER_KEY_SEL field.
	SNVS_LPMKCR_MASTER_KEY_SEL_Msk = 0x3
	// Select one time programmable master key.
	SNVS_LPMKCR_MASTER_KEY_SEL_MASTER_KEY_SEL_0 = 0x0
	// Select zeroizable master key when MKS_EN bit is set .
	SNVS_LPMKCR_MASTER_KEY_SEL_MASTER_KEY_SEL_2 = 0x2
	// Select combined master key when MKS_EN bit is set .
	SNVS_LPMKCR_MASTER_KEY_SEL_MASTER_KEY_SEL_3 = 0x3
	// Position of ZMK_HWP field.
	SNVS_LPMKCR_ZMK_HWP_Pos = 0x2
	// Bit mask of ZMK_HWP field.
	SNVS_LPMKCR_ZMK_HWP_Msk = 0x4
	// Bit ZMK_HWP.
	SNVS_LPMKCR_ZMK_HWP = 0x4
	// ZMK is in the software programming mode.
	SNVS_LPMKCR_ZMK_HWP_ZMK_HWP_0 = 0x0
	// ZMK is in the hardware programming mode.
	SNVS_LPMKCR_ZMK_HWP_ZMK_HWP_1 = 0x1
	// Position of ZMK_VAL field.
	SNVS_LPMKCR_ZMK_VAL_Pos = 0x3
	// Bit mask of ZMK_VAL field.
	SNVS_LPMKCR_ZMK_VAL_Msk = 0x8
	// Bit ZMK_VAL.
	SNVS_LPMKCR_ZMK_VAL = 0x8
	// ZMK is not valid.
	SNVS_LPMKCR_ZMK_VAL_ZMK_VAL_0 = 0x0
	// ZMK is valid.
	SNVS_LPMKCR_ZMK_VAL_ZMK_VAL_1 = 0x1
	// Position of ZMK_ECC_EN field.
	SNVS_LPMKCR_ZMK_ECC_EN_Pos = 0x4
	// Bit mask of ZMK_ECC_EN field.
	SNVS_LPMKCR_ZMK_ECC_EN_Msk = 0x10
	// Bit ZMK_ECC_EN.
	SNVS_LPMKCR_ZMK_ECC_EN = 0x10
	// ZMK ECC check is disabled.
	SNVS_LPMKCR_ZMK_ECC_EN_ZMK_ECC_EN_0 = 0x0
	// ZMK ECC check is enabled.
	SNVS_LPMKCR_ZMK_ECC_EN_ZMK_ECC_EN_1 = 0x1
	// Position of ZMK_ECC_VALUE field.
	SNVS_LPMKCR_ZMK_ECC_VALUE_Pos = 0x7
	// Bit mask of ZMK_ECC_VALUE field.
	SNVS_LPMKCR_ZMK_ECC_VALUE_Msk = 0xff80

	// LPSVCR: SNVS_LP Security Violation Control Register
	// Position of SV0_EN field.
	SNVS_LPSVCR_SV0_EN_Pos = 0x0
	// Bit mask of SV0_EN field.
	SNVS_LPSVCR_SV0_EN_Msk = 0x1
	// Bit SV0_EN.
	SNVS_LPSVCR_SV0_EN = 0x1
	// Security Violation 0 is disabled in the LP domain.
	SNVS_LPSVCR_SV0_EN_SV0_EN_0 = 0x0
	// Security Violation 0 is enabled in the LP domain.
	SNVS_LPSVCR_SV0_EN_SV0_EN_1 = 0x1
	// Position of SV1_EN field.
	SNVS_LPSVCR_SV1_EN_Pos = 0x1
	// Bit mask of SV1_EN field.
	SNVS_LPSVCR_SV1_EN_Msk = 0x2
	// Bit SV1_EN.
	SNVS_LPSVCR_SV1_EN = 0x2
	// Security Violation 1 is disabled in the LP domain.
	SNVS_LPSVCR_SV1_EN_SV1_EN_0 = 0x0
	// Security Violation 1 is enabled in the LP domain.
	SNVS_LPSVCR_SV1_EN_SV1_EN_1 = 0x1
	// Position of SV2_EN field.
	SNVS_LPSVCR_SV2_EN_Pos = 0x2
	// Bit mask of SV2_EN field.
	SNVS_LPSVCR_SV2_EN_Msk = 0x4
	// Bit SV2_EN.
	SNVS_LPSVCR_SV2_EN = 0x4
	// Security Violation 2 is disabled in the LP domain.
	SNVS_LPSVCR_SV2_EN_SV2_EN_0 = 0x0
	// Security Violation 2 is enabled in the LP domain.
	SNVS_LPSVCR_SV2_EN_SV2_EN_1 = 0x1
	// Position of SV3_EN field.
	SNVS_LPSVCR_SV3_EN_Pos = 0x3
	// Bit mask of SV3_EN field.
	SNVS_LPSVCR_SV3_EN_Msk = 0x8
	// Bit SV3_EN.
	SNVS_LPSVCR_SV3_EN = 0x8
	// Security Violation 3 is disabled in the LP domain.
	SNVS_LPSVCR_SV3_EN_SV3_EN_0 = 0x0
	// Security Violation 3 is enabled in the LP domain.
	SNVS_LPSVCR_SV3_EN_SV3_EN_1 = 0x1
	// Position of SV4_EN field.
	SNVS_LPSVCR_SV4_EN_Pos = 0x4
	// Bit mask of SV4_EN field.
	SNVS_LPSVCR_SV4_EN_Msk = 0x10
	// Bit SV4_EN.
	SNVS_LPSVCR_SV4_EN = 0x10
	// Security Violation 4 is disabled in the LP domain.
	SNVS_LPSVCR_SV4_EN_SV4_EN_0 = 0x0
	// Security Violation 4 is enabled in the LP domain.
	SNVS_LPSVCR_SV4_EN_SV4_EN_1 = 0x1
	// Position of SV5_EN field.
	SNVS_LPSVCR_SV5_EN_Pos = 0x5
	// Bit mask of SV5_EN field.
	SNVS_LPSVCR_SV5_EN_Msk = 0x20
	// Bit SV5_EN.
	SNVS_LPSVCR_SV5_EN = 0x20
	// Security Violation 5 is disabled in the LP domain.
	SNVS_LPSVCR_SV5_EN_SV5_EN_0 = 0x0
	// Security Violation 5 is enabled in the LP domain.
	SNVS_LPSVCR_SV5_EN_SV5_EN_1 = 0x1

	// LPTDCR: SNVS_LP Tamper Detectors Configuration Register
	// Position of SRTCR_EN field.
	SNVS_LPTDCR_SRTCR_EN_Pos = 0x1
	// Bit mask of SRTCR_EN field.
	SNVS_LPTDCR_SRTCR_EN_Msk = 0x2
	// Bit SRTCR_EN.
	SNVS_LPTDCR_SRTCR_EN = 0x2
	// SRTC rollover is disabled.
	SNVS_LPTDCR_SRTCR_EN_SRTCR_EN_0 = 0x0
	// SRTC rollover is enabled.
	SNVS_LPTDCR_SRTCR_EN_SRTCR_EN_1 = 0x1
	// Position of MCR_EN field.
	SNVS_LPTDCR_MCR_EN_Pos = 0x2
	// Bit mask of MCR_EN field.
	SNVS_LPTDCR_MCR_EN_Msk = 0x4
	// Bit MCR_EN.
	SNVS_LPTDCR_MCR_EN = 0x4
	// MC rollover is disabled.
	SNVS_LPTDCR_MCR_EN_MCR_EN_0 = 0x0
	// MC rollover is enabled.
	SNVS_LPTDCR_MCR_EN_MCR_EN_1 = 0x1
	// Position of ET1_EN field.
	SNVS_LPTDCR_ET1_EN_Pos = 0x9
	// Bit mask of ET1_EN field.
	SNVS_LPTDCR_ET1_EN_Msk = 0x200
	// Bit ET1_EN.
	SNVS_LPTDCR_ET1_EN = 0x200
	// External tamper 1 is disabled.
	SNVS_LPTDCR_ET1_EN_ET1_EN_0 = 0x0
	// External tamper 1 is enabled.
	SNVS_LPTDCR_ET1_EN_ET1_EN_1 = 0x1
	// Position of ET1P field.
	SNVS_LPTDCR_ET1P_Pos = 0xb
	// Bit mask of ET1P field.
	SNVS_LPTDCR_ET1P_Msk = 0x800
	// Bit ET1P.
	SNVS_LPTDCR_ET1P = 0x800
	// External tamper 1 is active low.
	SNVS_LPTDCR_ET1P_ET1P_0 = 0x0
	// External tamper 1 is active high.
	SNVS_LPTDCR_ET1P_ET1P_1 = 0x1
	// Position of PFD_OBSERV field.
	SNVS_LPTDCR_PFD_OBSERV_Pos = 0xe
	// Bit mask of PFD_OBSERV field.
	SNVS_LPTDCR_PFD_OBSERV_Msk = 0x4000
	// Bit PFD_OBSERV.
	SNVS_LPTDCR_PFD_OBSERV = 0x4000
	// Position of POR_OBSERV field.
	SNVS_LPTDCR_POR_OBSERV_Pos = 0xf
	// Bit mask of POR_OBSERV field.
	SNVS_LPTDCR_POR_OBSERV_Msk = 0x8000
	// Bit POR_OBSERV.
	SNVS_LPTDCR_POR_OBSERV = 0x8000
	// Position of OSCB field.
	SNVS_LPTDCR_OSCB_Pos = 0x1c
	// Bit mask of OSCB field.
	SNVS_LPTDCR_OSCB_Msk = 0x10000000
	// Bit OSCB.
	SNVS_LPTDCR_OSCB = 0x10000000
	// Normal SRTC clock oscillator not bypassed.
	SNVS_LPTDCR_OSCB_OSCB_0 = 0x0
	// Normal SRTC clock oscillator bypassed. Alternate clock can drive the SRTC clock source.
	SNVS_LPTDCR_OSCB_OSCB_1 = 0x1

	// LPSR: SNVS_LP Status Register
	// Position of LPTA field.
	SNVS_LPSR_LPTA_Pos = 0x0
	// Bit mask of LPTA field.
	SNVS_LPSR_LPTA_Msk = 0x1
	// Bit LPTA.
	SNVS_LPSR_LPTA = 0x1
	// No time alarm interrupt occurred.
	SNVS_LPSR_LPTA_LPTA_0 = 0x0
	// A time alarm interrupt occurred.
	SNVS_LPSR_LPTA_LPTA_1 = 0x1
	// Position of SRTCR field.
	SNVS_LPSR_SRTCR_Pos = 0x1
	// Bit mask of SRTCR field.
	SNVS_LPSR_SRTCR_Msk = 0x2
	// Bit SRTCR.
	SNVS_LPSR_SRTCR = 0x2
	// SRTC has not reached its maximum value.
	SNVS_LPSR_SRTCR_SRTCR_0 = 0x0
	// SRTC has reached its maximum value.
	SNVS_LPSR_SRTCR_SRTCR_1 = 0x1
	// Position of MCR field.
	SNVS_LPSR_MCR_Pos = 0x2
	// Bit mask of MCR field.
	SNVS_LPSR_MCR_Msk = 0x4
	// Bit MCR.
	SNVS_LPSR_MCR = 0x4
	// MC has not reached its maximum value.
	SNVS_LPSR_MCR_MCR_0 = 0x0
	// MC has reached its maximum value.
	SNVS_LPSR_MCR_MCR_1 = 0x1
	// Position of PGD field.
	SNVS_LPSR_PGD_Pos = 0x3
	// Bit mask of PGD field.
	SNVS_LPSR_PGD_Msk = 0x8
	// Bit PGD.
	SNVS_LPSR_PGD = 0x8
	// Position of ET1D field.
	SNVS_LPSR_ET1D_Pos = 0x9
	// Bit mask of ET1D field.
	SNVS_LPSR_ET1D_Msk = 0x200
	// Bit ET1D.
	SNVS_LPSR_ET1D = 0x200
	// External tampering 1 not detected.
	SNVS_LPSR_ET1D_ET1D_0 = 0x0
	// External tampering 1 detected.
	SNVS_LPSR_ET1D_ET1D_1 = 0x1
	// Position of ESVD field.
	SNVS_LPSR_ESVD_Pos = 0x10
	// Bit mask of ESVD field.
	SNVS_LPSR_ESVD_Msk = 0x10000
	// Bit ESVD.
	SNVS_LPSR_ESVD = 0x10000
	// No external security violation.
	SNVS_LPSR_ESVD_ESVD_0 = 0x0
	// External security violation is detected.
	SNVS_LPSR_ESVD_ESVD_1 = 0x1
	// Position of EO field.
	SNVS_LPSR_EO_Pos = 0x11
	// Bit mask of EO field.
	SNVS_LPSR_EO_Msk = 0x20000
	// Bit EO.
	SNVS_LPSR_EO = 0x20000
	// Emergency off was not detected.
	SNVS_LPSR_EO_EO_0 = 0x0
	// Emergency off was detected.
	SNVS_LPSR_EO_EO_1 = 0x1
	// Position of SPO field.
	SNVS_LPSR_SPO_Pos = 0x12
	// Bit mask of SPO field.
	SNVS_LPSR_SPO_Msk = 0x40000
	// Bit SPO.
	SNVS_LPSR_SPO = 0x40000
	// Set Power Off was not detected.
	SNVS_LPSR_SPO_SPO_0 = 0x0
	// Set Power Off was detected.
	SNVS_LPSR_SPO_SPO_1 = 0x1
	// Position of SED field.
	SNVS_LPSR_SED_Pos = 0x14
	// Bit mask of SED field.
	SNVS_LPSR_SED_Msk = 0x100000
	// Bit SED.
	SNVS_LPSR_SED = 0x100000
	// Scan exit was not detected.
	SNVS_LPSR_SED_SED_0 = 0x0
	// Scan exit was detected.
	SNVS_LPSR_SED_SED_1 = 0x1
	// Position of LPNS field.
	SNVS_LPSR_LPNS_Pos = 0x1e
	// Bit mask of LPNS field.
	SNVS_LPSR_LPNS_Msk = 0x40000000
	// Bit LPNS.
	SNVS_LPSR_LPNS = 0x40000000
	// LP section was not programmed in the non-secure state.
	SNVS_LPSR_LPNS_LPNS_0 = 0x0
	// LP section was programmed in the non-secure state.
	SNVS_LPSR_LPNS_LPNS_1 = 0x1
	// Position of LPS field.
	SNVS_LPSR_LPS_Pos = 0x1f
	// Bit mask of LPS field.
	SNVS_LPSR_LPS_Msk = 0x80000000
	// Bit LPS.
	SNVS_LPSR_LPS = 0x80000000
	// LP section was not programmed in secure or trusted state.
	SNVS_LPSR_LPS_LPS_0 = 0x0
	// LP section was programmed in secure or trusted state.
	SNVS_LPSR_LPS_LPS_1 = 0x1

	// LPSRTCMR: SNVS_LP Secure Real Time Counter MSB Register
	// Position of SRTC field.
	SNVS_LPSRTCMR_SRTC_Pos = 0x0
	// Bit mask of SRTC field.
	SNVS_LPSRTCMR_SRTC_Msk = 0x7fff

	// LPSRTCLR: SNVS_LP Secure Real Time Counter LSB Register
	// Position of SRTC field.
	SNVS_LPSRTCLR_SRTC_Pos = 0x0
	// Bit mask of SRTC field.
	SNVS_LPSRTCLR_SRTC_Msk = 0xffffffff

	// LPTAR: SNVS_LP Time Alarm Register
	// Position of LPTA field.
	SNVS_LPTAR_LPTA_Pos = 0x0
	// Bit mask of LPTA field.
	SNVS_LPTAR_LPTA_Msk = 0xffffffff

	// LPSMCMR: SNVS_LP Secure Monotonic Counter MSB Register
	// Position of MON_COUNTER field.
	SNVS_LPSMCMR_MON_COUNTER_Pos = 0x0
	// Bit mask of MON_COUNTER field.
	SNVS_LPSMCMR_MON_COUNTER_Msk = 0xffff
	// Position of MC_ERA_BITS field.
	SNVS_LPSMCMR_MC_ERA_BITS_Pos = 0x10
	// Bit mask of MC_ERA_BITS field.
	SNVS_LPSMCMR_MC_ERA_BITS_Msk = 0xffff0000

	// LPSMCLR: SNVS_LP Secure Monotonic Counter LSB Register
	// Position of MON_COUNTER field.
	SNVS_LPSMCLR_MON_COUNTER_Pos = 0x0
	// Bit mask of MON_COUNTER field.
	SNVS_LPSMCLR_MON_COUNTER_Msk = 0xffffffff

	// LPPGDR: SNVS_LP Power Glitch Detector Register
	// Position of PGD field.
	SNVS_LPPGDR_PGD_Pos = 0x0
	// Bit mask of PGD field.
	SNVS_LPPGDR_PGD_Msk = 0xffffffff

	// LPGPR0_legacy_alias: SNVS_LP General Purpose Register 0 (legacy alias)
	// Position of GPR field.
	SNVS_LPGPR0_legacy_alias_GPR_Pos = 0x0
	// Bit mask of GPR field.
	SNVS_LPGPR0_legacy_alias_GPR_Msk = 0xffffffff

	// LPZMKR: SNVS_LP Zeroizable Master Key Register
	// Position of ZMK field.
	SNVS_LPZMKR_ZMK_Pos = 0x0
	// Bit mask of ZMK field.
	SNVS_LPZMKR_ZMK_Msk = 0xffffffff

	// LPGPR_alias: SNVS_LP General Purpose Registers 0 .. 3
	// Position of GPR field.
	SNVS_LPGPR_alias_GPR_Pos = 0x0
	// Bit mask of GPR field.
	SNVS_LPGPR_alias_GPR_Msk = 0xffffffff

	// LPGPR: SNVS_LP General Purpose Registers 0 .. 3
	// Position of GPR field.
	SNVS_LPGPR_GPR_Pos = 0x0
	// Bit mask of GPR field.
	SNVS_LPGPR_GPR_Msk = 0xffffffff

	// HPVIDR1: SNVS_HP Version ID Register 1
	// Position of MINOR_REV field.
	SNVS_HPVIDR1_MINOR_REV_Pos = 0x0
	// Bit mask of MINOR_REV field.
	SNVS_HPVIDR1_MINOR_REV_Msk = 0xff
	// Position of MAJOR_REV field.
	SNVS_HPVIDR1_MAJOR_REV_Pos = 0x8
	// Bit mask of MAJOR_REV field.
	SNVS_HPVIDR1_MAJOR_REV_Msk = 0xff00
	// Position of IP_ID field.
	SNVS_HPVIDR1_IP_ID_Pos = 0x10
	// Bit mask of IP_ID field.
	SNVS_HPVIDR1_IP_ID_Msk = 0xffff0000

	// HPVIDR2: SNVS_HP Version ID Register 2
	// Position of CONFIG_OPT field.
	SNVS_HPVIDR2_CONFIG_OPT_Pos = 0x0
	// Bit mask of CONFIG_OPT field.
	SNVS_HPVIDR2_CONFIG_OPT_Msk = 0xff
	// Position of ECO_REV field.
	SNVS_HPVIDR2_ECO_REV_Pos = 0x8
	// Bit mask of ECO_REV field.
	SNVS_HPVIDR2_ECO_REV_Msk = 0xff00
	// Position of INTG_OPT field.
	SNVS_HPVIDR2_INTG_OPT_Pos = 0x10
	// Bit mask of INTG_OPT field.
	SNVS_HPVIDR2_INTG_OPT_Msk = 0xff0000
	// Position of IP_ERA field.
	SNVS_HPVIDR2_IP_ERA_Pos = 0x18
	// Bit mask of IP_ERA field.
	SNVS_HPVIDR2_IP_ERA_Msk = 0xff000000
)

// Constants for CCM_ANALOG: CCM_ANALOG
const (
	// PLL_USB1: Analog USB1 480MHz PLL Control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_USB1_DIV_SELECT_Pos = 0x1
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_USB1_DIV_SELECT_Msk = 0x2
	// Bit DIV_SELECT.
	CCM_ANALOG_PLL_USB1_DIV_SELECT = 0x2
	// Position of EN_USB_CLKS field.
	CCM_ANALOG_PLL_USB1_EN_USB_CLKS_Pos = 0x6
	// Bit mask of EN_USB_CLKS field.
	CCM_ANALOG_PLL_USB1_EN_USB_CLKS_Msk = 0x40
	// Bit EN_USB_CLKS.
	CCM_ANALOG_PLL_USB1_EN_USB_CLKS = 0x40
	// PLL outputs for USBPHYn off.
	CCM_ANALOG_PLL_USB1_EN_USB_CLKS_EN_USB_CLKS_0 = 0x0
	// PLL outputs for USBPHYn on.
	CCM_ANALOG_PLL_USB1_EN_USB_CLKS_EN_USB_CLKS_1 = 0x1
	// Position of POWER field.
	CCM_ANALOG_PLL_USB1_POWER_Pos = 0xc
	// Bit mask of POWER field.
	CCM_ANALOG_PLL_USB1_POWER_Msk = 0x1000
	// Bit POWER.
	CCM_ANALOG_PLL_USB1_POWER = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_USB1_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_USB1_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_USB1_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_USB1_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_USB1_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_USB1_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Position of BYPASS field.
	CCM_ANALOG_PLL_USB1_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_USB1_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_USB1_BYPASS = 0x10000
	// Position of LOCK field.
	CCM_ANALOG_PLL_USB1_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_USB1_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_USB1_LOCK = 0x80000000

	// PLL_USB1_SET: Analog USB1 480MHz PLL Control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_USB1_SET_DIV_SELECT_Pos = 0x1
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_USB1_SET_DIV_SELECT_Msk = 0x2
	// Bit DIV_SELECT.
	CCM_ANALOG_PLL_USB1_SET_DIV_SELECT = 0x2
	// Position of EN_USB_CLKS field.
	CCM_ANALOG_PLL_USB1_SET_EN_USB_CLKS_Pos = 0x6
	// Bit mask of EN_USB_CLKS field.
	CCM_ANALOG_PLL_USB1_SET_EN_USB_CLKS_Msk = 0x40
	// Bit EN_USB_CLKS.
	CCM_ANALOG_PLL_USB1_SET_EN_USB_CLKS = 0x40
	// PLL outputs for USBPHYn off.
	CCM_ANALOG_PLL_USB1_SET_EN_USB_CLKS_EN_USB_CLKS_0 = 0x0
	// PLL outputs for USBPHYn on.
	CCM_ANALOG_PLL_USB1_SET_EN_USB_CLKS_EN_USB_CLKS_1 = 0x1
	// Position of POWER field.
	CCM_ANALOG_PLL_USB1_SET_POWER_Pos = 0xc
	// Bit mask of POWER field.
	CCM_ANALOG_PLL_USB1_SET_POWER_Msk = 0x1000
	// Bit POWER.
	CCM_ANALOG_PLL_USB1_SET_POWER = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_USB1_SET_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_USB1_SET_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_USB1_SET_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_USB1_SET_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_USB1_SET_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_USB1_SET_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Position of BYPASS field.
	CCM_ANALOG_PLL_USB1_SET_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_USB1_SET_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_USB1_SET_BYPASS = 0x10000
	// Position of LOCK field.
	CCM_ANALOG_PLL_USB1_SET_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_USB1_SET_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_USB1_SET_LOCK = 0x80000000

	// PLL_USB1_CLR: Analog USB1 480MHz PLL Control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_USB1_CLR_DIV_SELECT_Pos = 0x1
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_USB1_CLR_DIV_SELECT_Msk = 0x2
	// Bit DIV_SELECT.
	CCM_ANALOG_PLL_USB1_CLR_DIV_SELECT = 0x2
	// Position of EN_USB_CLKS field.
	CCM_ANALOG_PLL_USB1_CLR_EN_USB_CLKS_Pos = 0x6
	// Bit mask of EN_USB_CLKS field.
	CCM_ANALOG_PLL_USB1_CLR_EN_USB_CLKS_Msk = 0x40
	// Bit EN_USB_CLKS.
	CCM_ANALOG_PLL_USB1_CLR_EN_USB_CLKS = 0x40
	// PLL outputs for USBPHYn off.
	CCM_ANALOG_PLL_USB1_CLR_EN_USB_CLKS_EN_USB_CLKS_0 = 0x0
	// PLL outputs for USBPHYn on.
	CCM_ANALOG_PLL_USB1_CLR_EN_USB_CLKS_EN_USB_CLKS_1 = 0x1
	// Position of POWER field.
	CCM_ANALOG_PLL_USB1_CLR_POWER_Pos = 0xc
	// Bit mask of POWER field.
	CCM_ANALOG_PLL_USB1_CLR_POWER_Msk = 0x1000
	// Bit POWER.
	CCM_ANALOG_PLL_USB1_CLR_POWER = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_USB1_CLR_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_USB1_CLR_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_USB1_CLR_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_USB1_CLR_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_USB1_CLR_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_USB1_CLR_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Position of BYPASS field.
	CCM_ANALOG_PLL_USB1_CLR_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_USB1_CLR_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_USB1_CLR_BYPASS = 0x10000
	// Position of LOCK field.
	CCM_ANALOG_PLL_USB1_CLR_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_USB1_CLR_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_USB1_CLR_LOCK = 0x80000000

	// PLL_USB1_TOG: Analog USB1 480MHz PLL Control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_USB1_TOG_DIV_SELECT_Pos = 0x1
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_USB1_TOG_DIV_SELECT_Msk = 0x2
	// Bit DIV_SELECT.
	CCM_ANALOG_PLL_USB1_TOG_DIV_SELECT = 0x2
	// Position of EN_USB_CLKS field.
	CCM_ANALOG_PLL_USB1_TOG_EN_USB_CLKS_Pos = 0x6
	// Bit mask of EN_USB_CLKS field.
	CCM_ANALOG_PLL_USB1_TOG_EN_USB_CLKS_Msk = 0x40
	// Bit EN_USB_CLKS.
	CCM_ANALOG_PLL_USB1_TOG_EN_USB_CLKS = 0x40
	// PLL outputs for USBPHYn off.
	CCM_ANALOG_PLL_USB1_TOG_EN_USB_CLKS_EN_USB_CLKS_0 = 0x0
	// PLL outputs for USBPHYn on.
	CCM_ANALOG_PLL_USB1_TOG_EN_USB_CLKS_EN_USB_CLKS_1 = 0x1
	// Position of POWER field.
	CCM_ANALOG_PLL_USB1_TOG_POWER_Pos = 0xc
	// Bit mask of POWER field.
	CCM_ANALOG_PLL_USB1_TOG_POWER_Msk = 0x1000
	// Bit POWER.
	CCM_ANALOG_PLL_USB1_TOG_POWER = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_USB1_TOG_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_USB1_TOG_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_USB1_TOG_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_USB1_TOG_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_USB1_TOG_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_USB1_TOG_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Position of BYPASS field.
	CCM_ANALOG_PLL_USB1_TOG_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_USB1_TOG_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_USB1_TOG_BYPASS = 0x10000
	// Position of LOCK field.
	CCM_ANALOG_PLL_USB1_TOG_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_USB1_TOG_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_USB1_TOG_LOCK = 0x80000000

	// PLL_SYS: Analog System PLL Control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_SYS_DIV_SELECT_Pos = 0x0
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_SYS_DIV_SELECT_Msk = 0x1
	// Bit DIV_SELECT.
	CCM_ANALOG_PLL_SYS_DIV_SELECT = 0x1
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_SYS_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_SYS_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_SYS_POWERDOWN = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_SYS_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_SYS_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_SYS_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_SYS_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_SYS_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_SYS_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Position of BYPASS field.
	CCM_ANALOG_PLL_SYS_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_SYS_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_SYS_BYPASS = 0x10000
	// Position of LOCK field.
	CCM_ANALOG_PLL_SYS_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_SYS_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_SYS_LOCK = 0x80000000

	// PLL_SYS_SET: Analog System PLL Control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_SYS_SET_DIV_SELECT_Pos = 0x0
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_SYS_SET_DIV_SELECT_Msk = 0x1
	// Bit DIV_SELECT.
	CCM_ANALOG_PLL_SYS_SET_DIV_SELECT = 0x1
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_SYS_SET_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_SYS_SET_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_SYS_SET_POWERDOWN = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_SYS_SET_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_SYS_SET_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_SYS_SET_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_SYS_SET_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_SYS_SET_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_SYS_SET_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Position of BYPASS field.
	CCM_ANALOG_PLL_SYS_SET_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_SYS_SET_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_SYS_SET_BYPASS = 0x10000
	// Position of LOCK field.
	CCM_ANALOG_PLL_SYS_SET_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_SYS_SET_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_SYS_SET_LOCK = 0x80000000

	// PLL_SYS_CLR: Analog System PLL Control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_SYS_CLR_DIV_SELECT_Pos = 0x0
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_SYS_CLR_DIV_SELECT_Msk = 0x1
	// Bit DIV_SELECT.
	CCM_ANALOG_PLL_SYS_CLR_DIV_SELECT = 0x1
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_SYS_CLR_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_SYS_CLR_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_SYS_CLR_POWERDOWN = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_SYS_CLR_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_SYS_CLR_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_SYS_CLR_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_SYS_CLR_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_SYS_CLR_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_SYS_CLR_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Position of BYPASS field.
	CCM_ANALOG_PLL_SYS_CLR_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_SYS_CLR_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_SYS_CLR_BYPASS = 0x10000
	// Position of LOCK field.
	CCM_ANALOG_PLL_SYS_CLR_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_SYS_CLR_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_SYS_CLR_LOCK = 0x80000000

	// PLL_SYS_TOG: Analog System PLL Control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_SYS_TOG_DIV_SELECT_Pos = 0x0
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_SYS_TOG_DIV_SELECT_Msk = 0x1
	// Bit DIV_SELECT.
	CCM_ANALOG_PLL_SYS_TOG_DIV_SELECT = 0x1
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_SYS_TOG_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_SYS_TOG_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_SYS_TOG_POWERDOWN = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_SYS_TOG_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_SYS_TOG_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_SYS_TOG_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_SYS_TOG_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_SYS_TOG_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_SYS_TOG_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Position of BYPASS field.
	CCM_ANALOG_PLL_SYS_TOG_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_SYS_TOG_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_SYS_TOG_BYPASS = 0x10000
	// Position of LOCK field.
	CCM_ANALOG_PLL_SYS_TOG_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_SYS_TOG_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_SYS_TOG_LOCK = 0x80000000

	// PLL_SYS_SS: 528MHz System PLL Spread Spectrum Register
	// Position of STEP field.
	CCM_ANALOG_PLL_SYS_SS_STEP_Pos = 0x0
	// Bit mask of STEP field.
	CCM_ANALOG_PLL_SYS_SS_STEP_Msk = 0x7fff
	// Position of ENABLE field.
	CCM_ANALOG_PLL_SYS_SS_ENABLE_Pos = 0xf
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_SYS_SS_ENABLE_Msk = 0x8000
	// Bit ENABLE.
	CCM_ANALOG_PLL_SYS_SS_ENABLE = 0x8000
	// Spread spectrum modulation disabled
	CCM_ANALOG_PLL_SYS_SS_ENABLE_ENABLE_0 = 0x0
	// Soread spectrum modulation enabled
	CCM_ANALOG_PLL_SYS_SS_ENABLE_ENABLE_1 = 0x1
	// Position of STOP field.
	CCM_ANALOG_PLL_SYS_SS_STOP_Pos = 0x10
	// Bit mask of STOP field.
	CCM_ANALOG_PLL_SYS_SS_STOP_Msk = 0xffff0000

	// PLL_SYS_NUM: Numerator of 528MHz System PLL Fractional Loop Divider Register
	// Position of A field.
	CCM_ANALOG_PLL_SYS_NUM_A_Pos = 0x0
	// Bit mask of A field.
	CCM_ANALOG_PLL_SYS_NUM_A_Msk = 0x3fffffff

	// PLL_SYS_DENOM: Denominator of 528MHz System PLL Fractional Loop Divider Register
	// Position of B field.
	CCM_ANALOG_PLL_SYS_DENOM_B_Pos = 0x0
	// Bit mask of B field.
	CCM_ANALOG_PLL_SYS_DENOM_B_Msk = 0x3fffffff

	// PLL_AUDIO: Analog Audio PLL control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_DIV_SELECT_Pos = 0x0
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_DIV_SELECT_Msk = 0x7f
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_AUDIO_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_AUDIO_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_AUDIO_POWERDOWN = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_AUDIO_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_AUDIO_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_AUDIO_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_AUDIO_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_AUDIO_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_AUDIO_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Position of BYPASS field.
	CCM_ANALOG_PLL_AUDIO_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_AUDIO_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_AUDIO_BYPASS = 0x10000
	// Position of POST_DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_POST_DIV_SELECT_Pos = 0x13
	// Bit mask of POST_DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_POST_DIV_SELECT_Msk = 0x180000
	// Divide by 4.
	CCM_ANALOG_PLL_AUDIO_POST_DIV_SELECT_POST_DIV_SELECT_0 = 0x0
	// Divide by 2.
	CCM_ANALOG_PLL_AUDIO_POST_DIV_SELECT_POST_DIV_SELECT_1 = 0x1
	// Divide by 1.
	CCM_ANALOG_PLL_AUDIO_POST_DIV_SELECT_POST_DIV_SELECT_2 = 0x2
	// Position of LOCK field.
	CCM_ANALOG_PLL_AUDIO_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_AUDIO_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_AUDIO_LOCK = 0x80000000

	// PLL_AUDIO_SET: Analog Audio PLL control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_SET_DIV_SELECT_Pos = 0x0
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_SET_DIV_SELECT_Msk = 0x7f
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_AUDIO_SET_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_AUDIO_SET_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_AUDIO_SET_POWERDOWN = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_AUDIO_SET_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_AUDIO_SET_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_AUDIO_SET_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_AUDIO_SET_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_AUDIO_SET_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_AUDIO_SET_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Position of BYPASS field.
	CCM_ANALOG_PLL_AUDIO_SET_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_AUDIO_SET_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_AUDIO_SET_BYPASS = 0x10000
	// Position of POST_DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_SET_POST_DIV_SELECT_Pos = 0x13
	// Bit mask of POST_DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_SET_POST_DIV_SELECT_Msk = 0x180000
	// Divide by 4.
	CCM_ANALOG_PLL_AUDIO_SET_POST_DIV_SELECT_POST_DIV_SELECT_0 = 0x0
	// Divide by 2.
	CCM_ANALOG_PLL_AUDIO_SET_POST_DIV_SELECT_POST_DIV_SELECT_1 = 0x1
	// Divide by 1.
	CCM_ANALOG_PLL_AUDIO_SET_POST_DIV_SELECT_POST_DIV_SELECT_2 = 0x2
	// Position of LOCK field.
	CCM_ANALOG_PLL_AUDIO_SET_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_AUDIO_SET_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_AUDIO_SET_LOCK = 0x80000000

	// PLL_AUDIO_CLR: Analog Audio PLL control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_CLR_DIV_SELECT_Pos = 0x0
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_CLR_DIV_SELECT_Msk = 0x7f
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_AUDIO_CLR_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_AUDIO_CLR_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_AUDIO_CLR_POWERDOWN = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_AUDIO_CLR_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_AUDIO_CLR_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_AUDIO_CLR_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_AUDIO_CLR_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_AUDIO_CLR_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_AUDIO_CLR_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Position of BYPASS field.
	CCM_ANALOG_PLL_AUDIO_CLR_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_AUDIO_CLR_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_AUDIO_CLR_BYPASS = 0x10000
	// Position of POST_DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_CLR_POST_DIV_SELECT_Pos = 0x13
	// Bit mask of POST_DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_CLR_POST_DIV_SELECT_Msk = 0x180000
	// Divide by 4.
	CCM_ANALOG_PLL_AUDIO_CLR_POST_DIV_SELECT_POST_DIV_SELECT_0 = 0x0
	// Divide by 2.
	CCM_ANALOG_PLL_AUDIO_CLR_POST_DIV_SELECT_POST_DIV_SELECT_1 = 0x1
	// Divide by 1.
	CCM_ANALOG_PLL_AUDIO_CLR_POST_DIV_SELECT_POST_DIV_SELECT_2 = 0x2
	// Position of LOCK field.
	CCM_ANALOG_PLL_AUDIO_CLR_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_AUDIO_CLR_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_AUDIO_CLR_LOCK = 0x80000000

	// PLL_AUDIO_TOG: Analog Audio PLL control Register
	// Position of DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_TOG_DIV_SELECT_Pos = 0x0
	// Bit mask of DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_TOG_DIV_SELECT_Msk = 0x7f
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_AUDIO_TOG_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_AUDIO_TOG_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_AUDIO_TOG_POWERDOWN = 0x1000
	// Position of ENABLE field.
	CCM_ANALOG_PLL_AUDIO_TOG_ENABLE_Pos = 0xd
	// Bit mask of ENABLE field.
	CCM_ANALOG_PLL_AUDIO_TOG_ENABLE_Msk = 0x2000
	// Bit ENABLE.
	CCM_ANALOG_PLL_AUDIO_TOG_ENABLE = 0x2000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_AUDIO_TOG_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_AUDIO_TOG_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_AUDIO_TOG_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Position of BYPASS field.
	CCM_ANALOG_PLL_AUDIO_TOG_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_AUDIO_TOG_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_AUDIO_TOG_BYPASS = 0x10000
	// Position of POST_DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_TOG_POST_DIV_SELECT_Pos = 0x13
	// Bit mask of POST_DIV_SELECT field.
	CCM_ANALOG_PLL_AUDIO_TOG_POST_DIV_SELECT_Msk = 0x180000
	// Divide by 4.
	CCM_ANALOG_PLL_AUDIO_TOG_POST_DIV_SELECT_POST_DIV_SELECT_0 = 0x0
	// Divide by 2.
	CCM_ANALOG_PLL_AUDIO_TOG_POST_DIV_SELECT_POST_DIV_SELECT_1 = 0x1
	// Divide by 1.
	CCM_ANALOG_PLL_AUDIO_TOG_POST_DIV_SELECT_POST_DIV_SELECT_2 = 0x2
	// Position of LOCK field.
	CCM_ANALOG_PLL_AUDIO_TOG_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_AUDIO_TOG_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_AUDIO_TOG_LOCK = 0x80000000

	// PLL_AUDIO_NUM: Numerator of Audio PLL Fractional Loop Divider Register
	// Position of A field.
	CCM_ANALOG_PLL_AUDIO_NUM_A_Pos = 0x0
	// Bit mask of A field.
	CCM_ANALOG_PLL_AUDIO_NUM_A_Msk = 0x3fffffff

	// PLL_AUDIO_DENOM: Denominator of Audio PLL Fractional Loop Divider Register
	// Position of B field.
	CCM_ANALOG_PLL_AUDIO_DENOM_B_Pos = 0x0
	// Bit mask of B field.
	CCM_ANALOG_PLL_AUDIO_DENOM_B_Msk = 0x3fffffff

	// PLL_ENET: Analog ENET PLL Control Register
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_ENET_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_ENET_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_ENET_POWERDOWN = 0x1000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_ENET_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_ENET_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_ENET_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Position of BYPASS field.
	CCM_ANALOG_PLL_ENET_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_ENET_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_ENET_BYPASS = 0x10000
	// Position of ENET_500M_REF_EN field.
	CCM_ANALOG_PLL_ENET_ENET_500M_REF_EN_Pos = 0x16
	// Bit mask of ENET_500M_REF_EN field.
	CCM_ANALOG_PLL_ENET_ENET_500M_REF_EN_Msk = 0x400000
	// Bit ENET_500M_REF_EN.
	CCM_ANALOG_PLL_ENET_ENET_500M_REF_EN = 0x400000
	// Position of LOCK field.
	CCM_ANALOG_PLL_ENET_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_ENET_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_ENET_LOCK = 0x80000000

	// PLL_ENET_SET: Analog ENET PLL Control Register
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_ENET_SET_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_ENET_SET_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_ENET_SET_POWERDOWN = 0x1000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_ENET_SET_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_ENET_SET_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_ENET_SET_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Position of BYPASS field.
	CCM_ANALOG_PLL_ENET_SET_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_ENET_SET_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_ENET_SET_BYPASS = 0x10000
	// Position of ENET_500M_REF_EN field.
	CCM_ANALOG_PLL_ENET_SET_ENET_500M_REF_EN_Pos = 0x16
	// Bit mask of ENET_500M_REF_EN field.
	CCM_ANALOG_PLL_ENET_SET_ENET_500M_REF_EN_Msk = 0x400000
	// Bit ENET_500M_REF_EN.
	CCM_ANALOG_PLL_ENET_SET_ENET_500M_REF_EN = 0x400000
	// Position of LOCK field.
	CCM_ANALOG_PLL_ENET_SET_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_ENET_SET_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_ENET_SET_LOCK = 0x80000000

	// PLL_ENET_CLR: Analog ENET PLL Control Register
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_ENET_CLR_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_ENET_CLR_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_ENET_CLR_POWERDOWN = 0x1000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_ENET_CLR_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_ENET_CLR_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_ENET_CLR_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Position of BYPASS field.
	CCM_ANALOG_PLL_ENET_CLR_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_ENET_CLR_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_ENET_CLR_BYPASS = 0x10000
	// Position of ENET_500M_REF_EN field.
	CCM_ANALOG_PLL_ENET_CLR_ENET_500M_REF_EN_Pos = 0x16
	// Bit mask of ENET_500M_REF_EN field.
	CCM_ANALOG_PLL_ENET_CLR_ENET_500M_REF_EN_Msk = 0x400000
	// Bit ENET_500M_REF_EN.
	CCM_ANALOG_PLL_ENET_CLR_ENET_500M_REF_EN = 0x400000
	// Position of LOCK field.
	CCM_ANALOG_PLL_ENET_CLR_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_ENET_CLR_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_ENET_CLR_LOCK = 0x80000000

	// PLL_ENET_TOG: Analog ENET PLL Control Register
	// Position of POWERDOWN field.
	CCM_ANALOG_PLL_ENET_TOG_POWERDOWN_Pos = 0xc
	// Bit mask of POWERDOWN field.
	CCM_ANALOG_PLL_ENET_TOG_POWERDOWN_Msk = 0x1000
	// Bit POWERDOWN.
	CCM_ANALOG_PLL_ENET_TOG_POWERDOWN = 0x1000
	// Position of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_ENET_TOG_BYPASS_CLK_SRC_Pos = 0xe
	// Bit mask of BYPASS_CLK_SRC field.
	CCM_ANALOG_PLL_ENET_TOG_BYPASS_CLK_SRC_Msk = 0xc000
	// Select the 24MHz oscillator as source.
	CCM_ANALOG_PLL_ENET_TOG_BYPASS_CLK_SRC_REF_CLK_24M = 0x0
	// Position of BYPASS field.
	CCM_ANALOG_PLL_ENET_TOG_BYPASS_Pos = 0x10
	// Bit mask of BYPASS field.
	CCM_ANALOG_PLL_ENET_TOG_BYPASS_Msk = 0x10000
	// Bit BYPASS.
	CCM_ANALOG_PLL_ENET_TOG_BYPASS = 0x10000
	// Position of ENET_500M_REF_EN field.
	CCM_ANALOG_PLL_ENET_TOG_ENET_500M_REF_EN_Pos = 0x16
	// Bit mask of ENET_500M_REF_EN field.
	CCM_ANALOG_PLL_ENET_TOG_ENET_500M_REF_EN_Msk = 0x400000
	// Bit ENET_500M_REF_EN.
	CCM_ANALOG_PLL_ENET_TOG_ENET_500M_REF_EN = 0x400000
	// Position of LOCK field.
	CCM_ANALOG_PLL_ENET_TOG_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	CCM_ANALOG_PLL_ENET_TOG_LOCK_Msk = 0x80000000
	// Bit LOCK.
	CCM_ANALOG_PLL_ENET_TOG_LOCK = 0x80000000

	// PFD_480: 480MHz Clock (PLL3) Phase Fractional Divider Control Register
	// Position of PFD0_FRAC field.
	CCM_ANALOG_PFD_480_PFD0_FRAC_Pos = 0x0
	// Bit mask of PFD0_FRAC field.
	CCM_ANALOG_PFD_480_PFD0_FRAC_Msk = 0x3f
	// Position of PFD0_STABLE field.
	CCM_ANALOG_PFD_480_PFD0_STABLE_Pos = 0x6
	// Bit mask of PFD0_STABLE field.
	CCM_ANALOG_PFD_480_PFD0_STABLE_Msk = 0x40
	// Bit PFD0_STABLE.
	CCM_ANALOG_PFD_480_PFD0_STABLE = 0x40
	// Position of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_480_PFD0_CLKGATE_Pos = 0x7
	// Bit mask of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_480_PFD0_CLKGATE_Msk = 0x80
	// Bit PFD0_CLKGATE.
	CCM_ANALOG_PFD_480_PFD0_CLKGATE = 0x80
	// Position of PFD1_FRAC field.
	CCM_ANALOG_PFD_480_PFD1_FRAC_Pos = 0x8
	// Bit mask of PFD1_FRAC field.
	CCM_ANALOG_PFD_480_PFD1_FRAC_Msk = 0x3f00
	// Position of PFD1_STABLE field.
	CCM_ANALOG_PFD_480_PFD1_STABLE_Pos = 0xe
	// Bit mask of PFD1_STABLE field.
	CCM_ANALOG_PFD_480_PFD1_STABLE_Msk = 0x4000
	// Bit PFD1_STABLE.
	CCM_ANALOG_PFD_480_PFD1_STABLE = 0x4000
	// Position of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_480_PFD1_CLKGATE_Pos = 0xf
	// Bit mask of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_480_PFD1_CLKGATE_Msk = 0x8000
	// Bit PFD1_CLKGATE.
	CCM_ANALOG_PFD_480_PFD1_CLKGATE = 0x8000
	// Position of PFD2_FRAC field.
	CCM_ANALOG_PFD_480_PFD2_FRAC_Pos = 0x10
	// Bit mask of PFD2_FRAC field.
	CCM_ANALOG_PFD_480_PFD2_FRAC_Msk = 0x3f0000
	// Position of PFD2_STABLE field.
	CCM_ANALOG_PFD_480_PFD2_STABLE_Pos = 0x16
	// Bit mask of PFD2_STABLE field.
	CCM_ANALOG_PFD_480_PFD2_STABLE_Msk = 0x400000
	// Bit PFD2_STABLE.
	CCM_ANALOG_PFD_480_PFD2_STABLE = 0x400000
	// Position of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_480_PFD2_CLKGATE_Pos = 0x17
	// Bit mask of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_480_PFD2_CLKGATE_Msk = 0x800000
	// Bit PFD2_CLKGATE.
	CCM_ANALOG_PFD_480_PFD2_CLKGATE = 0x800000
	// Position of PFD3_FRAC field.
	CCM_ANALOG_PFD_480_PFD3_FRAC_Pos = 0x18
	// Bit mask of PFD3_FRAC field.
	CCM_ANALOG_PFD_480_PFD3_FRAC_Msk = 0x3f000000
	// Position of PFD3_STABLE field.
	CCM_ANALOG_PFD_480_PFD3_STABLE_Pos = 0x1e
	// Bit mask of PFD3_STABLE field.
	CCM_ANALOG_PFD_480_PFD3_STABLE_Msk = 0x40000000
	// Bit PFD3_STABLE.
	CCM_ANALOG_PFD_480_PFD3_STABLE = 0x40000000
	// Position of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_480_PFD3_CLKGATE_Pos = 0x1f
	// Bit mask of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_480_PFD3_CLKGATE_Msk = 0x80000000
	// Bit PFD3_CLKGATE.
	CCM_ANALOG_PFD_480_PFD3_CLKGATE = 0x80000000

	// PFD_480_SET: 480MHz Clock (PLL3) Phase Fractional Divider Control Register
	// Position of PFD0_FRAC field.
	CCM_ANALOG_PFD_480_SET_PFD0_FRAC_Pos = 0x0
	// Bit mask of PFD0_FRAC field.
	CCM_ANALOG_PFD_480_SET_PFD0_FRAC_Msk = 0x3f
	// Position of PFD0_STABLE field.
	CCM_ANALOG_PFD_480_SET_PFD0_STABLE_Pos = 0x6
	// Bit mask of PFD0_STABLE field.
	CCM_ANALOG_PFD_480_SET_PFD0_STABLE_Msk = 0x40
	// Bit PFD0_STABLE.
	CCM_ANALOG_PFD_480_SET_PFD0_STABLE = 0x40
	// Position of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_480_SET_PFD0_CLKGATE_Pos = 0x7
	// Bit mask of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_480_SET_PFD0_CLKGATE_Msk = 0x80
	// Bit PFD0_CLKGATE.
	CCM_ANALOG_PFD_480_SET_PFD0_CLKGATE = 0x80
	// Position of PFD1_FRAC field.
	CCM_ANALOG_PFD_480_SET_PFD1_FRAC_Pos = 0x8
	// Bit mask of PFD1_FRAC field.
	CCM_ANALOG_PFD_480_SET_PFD1_FRAC_Msk = 0x3f00
	// Position of PFD1_STABLE field.
	CCM_ANALOG_PFD_480_SET_PFD1_STABLE_Pos = 0xe
	// Bit mask of PFD1_STABLE field.
	CCM_ANALOG_PFD_480_SET_PFD1_STABLE_Msk = 0x4000
	// Bit PFD1_STABLE.
	CCM_ANALOG_PFD_480_SET_PFD1_STABLE = 0x4000
	// Position of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_480_SET_PFD1_CLKGATE_Pos = 0xf
	// Bit mask of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_480_SET_PFD1_CLKGATE_Msk = 0x8000
	// Bit PFD1_CLKGATE.
	CCM_ANALOG_PFD_480_SET_PFD1_CLKGATE = 0x8000
	// Position of PFD2_FRAC field.
	CCM_ANALOG_PFD_480_SET_PFD2_FRAC_Pos = 0x10
	// Bit mask of PFD2_FRAC field.
	CCM_ANALOG_PFD_480_SET_PFD2_FRAC_Msk = 0x3f0000
	// Position of PFD2_STABLE field.
	CCM_ANALOG_PFD_480_SET_PFD2_STABLE_Pos = 0x16
	// Bit mask of PFD2_STABLE field.
	CCM_ANALOG_PFD_480_SET_PFD2_STABLE_Msk = 0x400000
	// Bit PFD2_STABLE.
	CCM_ANALOG_PFD_480_SET_PFD2_STABLE = 0x400000
	// Position of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_480_SET_PFD2_CLKGATE_Pos = 0x17
	// Bit mask of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_480_SET_PFD2_CLKGATE_Msk = 0x800000
	// Bit PFD2_CLKGATE.
	CCM_ANALOG_PFD_480_SET_PFD2_CLKGATE = 0x800000
	// Position of PFD3_FRAC field.
	CCM_ANALOG_PFD_480_SET_PFD3_FRAC_Pos = 0x18
	// Bit mask of PFD3_FRAC field.
	CCM_ANALOG_PFD_480_SET_PFD3_FRAC_Msk = 0x3f000000
	// Position of PFD3_STABLE field.
	CCM_ANALOG_PFD_480_SET_PFD3_STABLE_Pos = 0x1e
	// Bit mask of PFD3_STABLE field.
	CCM_ANALOG_PFD_480_SET_PFD3_STABLE_Msk = 0x40000000
	// Bit PFD3_STABLE.
	CCM_ANALOG_PFD_480_SET_PFD3_STABLE = 0x40000000
	// Position of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_480_SET_PFD3_CLKGATE_Pos = 0x1f
	// Bit mask of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_480_SET_PFD3_CLKGATE_Msk = 0x80000000
	// Bit PFD3_CLKGATE.
	CCM_ANALOG_PFD_480_SET_PFD3_CLKGATE = 0x80000000

	// PFD_480_CLR: 480MHz Clock (PLL3) Phase Fractional Divider Control Register
	// Position of PFD0_FRAC field.
	CCM_ANALOG_PFD_480_CLR_PFD0_FRAC_Pos = 0x0
	// Bit mask of PFD0_FRAC field.
	CCM_ANALOG_PFD_480_CLR_PFD0_FRAC_Msk = 0x3f
	// Position of PFD0_STABLE field.
	CCM_ANALOG_PFD_480_CLR_PFD0_STABLE_Pos = 0x6
	// Bit mask of PFD0_STABLE field.
	CCM_ANALOG_PFD_480_CLR_PFD0_STABLE_Msk = 0x40
	// Bit PFD0_STABLE.
	CCM_ANALOG_PFD_480_CLR_PFD0_STABLE = 0x40
	// Position of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_480_CLR_PFD0_CLKGATE_Pos = 0x7
	// Bit mask of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_480_CLR_PFD0_CLKGATE_Msk = 0x80
	// Bit PFD0_CLKGATE.
	CCM_ANALOG_PFD_480_CLR_PFD0_CLKGATE = 0x80
	// Position of PFD1_FRAC field.
	CCM_ANALOG_PFD_480_CLR_PFD1_FRAC_Pos = 0x8
	// Bit mask of PFD1_FRAC field.
	CCM_ANALOG_PFD_480_CLR_PFD1_FRAC_Msk = 0x3f00
	// Position of PFD1_STABLE field.
	CCM_ANALOG_PFD_480_CLR_PFD1_STABLE_Pos = 0xe
	// Bit mask of PFD1_STABLE field.
	CCM_ANALOG_PFD_480_CLR_PFD1_STABLE_Msk = 0x4000
	// Bit PFD1_STABLE.
	CCM_ANALOG_PFD_480_CLR_PFD1_STABLE = 0x4000
	// Position of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_480_CLR_PFD1_CLKGATE_Pos = 0xf
	// Bit mask of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_480_CLR_PFD1_CLKGATE_Msk = 0x8000
	// Bit PFD1_CLKGATE.
	CCM_ANALOG_PFD_480_CLR_PFD1_CLKGATE = 0x8000
	// Position of PFD2_FRAC field.
	CCM_ANALOG_PFD_480_CLR_PFD2_FRAC_Pos = 0x10
	// Bit mask of PFD2_FRAC field.
	CCM_ANALOG_PFD_480_CLR_PFD2_FRAC_Msk = 0x3f0000
	// Position of PFD2_STABLE field.
	CCM_ANALOG_PFD_480_CLR_PFD2_STABLE_Pos = 0x16
	// Bit mask of PFD2_STABLE field.
	CCM_ANALOG_PFD_480_CLR_PFD2_STABLE_Msk = 0x400000
	// Bit PFD2_STABLE.
	CCM_ANALOG_PFD_480_CLR_PFD2_STABLE = 0x400000
	// Position of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_480_CLR_PFD2_CLKGATE_Pos = 0x17
	// Bit mask of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_480_CLR_PFD2_CLKGATE_Msk = 0x800000
	// Bit PFD2_CLKGATE.
	CCM_ANALOG_PFD_480_CLR_PFD2_CLKGATE = 0x800000
	// Position of PFD3_FRAC field.
	CCM_ANALOG_PFD_480_CLR_PFD3_FRAC_Pos = 0x18
	// Bit mask of PFD3_FRAC field.
	CCM_ANALOG_PFD_480_CLR_PFD3_FRAC_Msk = 0x3f000000
	// Position of PFD3_STABLE field.
	CCM_ANALOG_PFD_480_CLR_PFD3_STABLE_Pos = 0x1e
	// Bit mask of PFD3_STABLE field.
	CCM_ANALOG_PFD_480_CLR_PFD3_STABLE_Msk = 0x40000000
	// Bit PFD3_STABLE.
	CCM_ANALOG_PFD_480_CLR_PFD3_STABLE = 0x40000000
	// Position of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_480_CLR_PFD3_CLKGATE_Pos = 0x1f
	// Bit mask of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_480_CLR_PFD3_CLKGATE_Msk = 0x80000000
	// Bit PFD3_CLKGATE.
	CCM_ANALOG_PFD_480_CLR_PFD3_CLKGATE = 0x80000000

	// PFD_480_TOG: 480MHz Clock (PLL3) Phase Fractional Divider Control Register
	// Position of PFD0_FRAC field.
	CCM_ANALOG_PFD_480_TOG_PFD0_FRAC_Pos = 0x0
	// Bit mask of PFD0_FRAC field.
	CCM_ANALOG_PFD_480_TOG_PFD0_FRAC_Msk = 0x3f
	// Position of PFD0_STABLE field.
	CCM_ANALOG_PFD_480_TOG_PFD0_STABLE_Pos = 0x6
	// Bit mask of PFD0_STABLE field.
	CCM_ANALOG_PFD_480_TOG_PFD0_STABLE_Msk = 0x40
	// Bit PFD0_STABLE.
	CCM_ANALOG_PFD_480_TOG_PFD0_STABLE = 0x40
	// Position of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_480_TOG_PFD0_CLKGATE_Pos = 0x7
	// Bit mask of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_480_TOG_PFD0_CLKGATE_Msk = 0x80
	// Bit PFD0_CLKGATE.
	CCM_ANALOG_PFD_480_TOG_PFD0_CLKGATE = 0x80
	// Position of PFD1_FRAC field.
	CCM_ANALOG_PFD_480_TOG_PFD1_FRAC_Pos = 0x8
	// Bit mask of PFD1_FRAC field.
	CCM_ANALOG_PFD_480_TOG_PFD1_FRAC_Msk = 0x3f00
	// Position of PFD1_STABLE field.
	CCM_ANALOG_PFD_480_TOG_PFD1_STABLE_Pos = 0xe
	// Bit mask of PFD1_STABLE field.
	CCM_ANALOG_PFD_480_TOG_PFD1_STABLE_Msk = 0x4000
	// Bit PFD1_STABLE.
	CCM_ANALOG_PFD_480_TOG_PFD1_STABLE = 0x4000
	// Position of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_480_TOG_PFD1_CLKGATE_Pos = 0xf
	// Bit mask of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_480_TOG_PFD1_CLKGATE_Msk = 0x8000
	// Bit PFD1_CLKGATE.
	CCM_ANALOG_PFD_480_TOG_PFD1_CLKGATE = 0x8000
	// Position of PFD2_FRAC field.
	CCM_ANALOG_PFD_480_TOG_PFD2_FRAC_Pos = 0x10
	// Bit mask of PFD2_FRAC field.
	CCM_ANALOG_PFD_480_TOG_PFD2_FRAC_Msk = 0x3f0000
	// Position of PFD2_STABLE field.
	CCM_ANALOG_PFD_480_TOG_PFD2_STABLE_Pos = 0x16
	// Bit mask of PFD2_STABLE field.
	CCM_ANALOG_PFD_480_TOG_PFD2_STABLE_Msk = 0x400000
	// Bit PFD2_STABLE.
	CCM_ANALOG_PFD_480_TOG_PFD2_STABLE = 0x400000
	// Position of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_480_TOG_PFD2_CLKGATE_Pos = 0x17
	// Bit mask of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_480_TOG_PFD2_CLKGATE_Msk = 0x800000
	// Bit PFD2_CLKGATE.
	CCM_ANALOG_PFD_480_TOG_PFD2_CLKGATE = 0x800000
	// Position of PFD3_FRAC field.
	CCM_ANALOG_PFD_480_TOG_PFD3_FRAC_Pos = 0x18
	// Bit mask of PFD3_FRAC field.
	CCM_ANALOG_PFD_480_TOG_PFD3_FRAC_Msk = 0x3f000000
	// Position of PFD3_STABLE field.
	CCM_ANALOG_PFD_480_TOG_PFD3_STABLE_Pos = 0x1e
	// Bit mask of PFD3_STABLE field.
	CCM_ANALOG_PFD_480_TOG_PFD3_STABLE_Msk = 0x40000000
	// Bit PFD3_STABLE.
	CCM_ANALOG_PFD_480_TOG_PFD3_STABLE = 0x40000000
	// Position of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_480_TOG_PFD3_CLKGATE_Pos = 0x1f
	// Bit mask of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_480_TOG_PFD3_CLKGATE_Msk = 0x80000000
	// Bit PFD3_CLKGATE.
	CCM_ANALOG_PFD_480_TOG_PFD3_CLKGATE = 0x80000000

	// PFD_528: 528MHz Clock (PLL2) Phase Fractional Divider Control Register
	// Position of PFD0_FRAC field.
	CCM_ANALOG_PFD_528_PFD0_FRAC_Pos = 0x0
	// Bit mask of PFD0_FRAC field.
	CCM_ANALOG_PFD_528_PFD0_FRAC_Msk = 0x3f
	// Position of PFD0_STABLE field.
	CCM_ANALOG_PFD_528_PFD0_STABLE_Pos = 0x6
	// Bit mask of PFD0_STABLE field.
	CCM_ANALOG_PFD_528_PFD0_STABLE_Msk = 0x40
	// Bit PFD0_STABLE.
	CCM_ANALOG_PFD_528_PFD0_STABLE = 0x40
	// Position of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_528_PFD0_CLKGATE_Pos = 0x7
	// Bit mask of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_528_PFD0_CLKGATE_Msk = 0x80
	// Bit PFD0_CLKGATE.
	CCM_ANALOG_PFD_528_PFD0_CLKGATE = 0x80
	// Position of PFD1_FRAC field.
	CCM_ANALOG_PFD_528_PFD1_FRAC_Pos = 0x8
	// Bit mask of PFD1_FRAC field.
	CCM_ANALOG_PFD_528_PFD1_FRAC_Msk = 0x3f00
	// Position of PFD1_STABLE field.
	CCM_ANALOG_PFD_528_PFD1_STABLE_Pos = 0xe
	// Bit mask of PFD1_STABLE field.
	CCM_ANALOG_PFD_528_PFD1_STABLE_Msk = 0x4000
	// Bit PFD1_STABLE.
	CCM_ANALOG_PFD_528_PFD1_STABLE = 0x4000
	// Position of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_528_PFD1_CLKGATE_Pos = 0xf
	// Bit mask of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_528_PFD1_CLKGATE_Msk = 0x8000
	// Bit PFD1_CLKGATE.
	CCM_ANALOG_PFD_528_PFD1_CLKGATE = 0x8000
	// Position of PFD2_FRAC field.
	CCM_ANALOG_PFD_528_PFD2_FRAC_Pos = 0x10
	// Bit mask of PFD2_FRAC field.
	CCM_ANALOG_PFD_528_PFD2_FRAC_Msk = 0x3f0000
	// Position of PFD2_STABLE field.
	CCM_ANALOG_PFD_528_PFD2_STABLE_Pos = 0x16
	// Bit mask of PFD2_STABLE field.
	CCM_ANALOG_PFD_528_PFD2_STABLE_Msk = 0x400000
	// Bit PFD2_STABLE.
	CCM_ANALOG_PFD_528_PFD2_STABLE = 0x400000
	// Position of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_528_PFD2_CLKGATE_Pos = 0x17
	// Bit mask of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_528_PFD2_CLKGATE_Msk = 0x800000
	// Bit PFD2_CLKGATE.
	CCM_ANALOG_PFD_528_PFD2_CLKGATE = 0x800000
	// Position of PFD3_FRAC field.
	CCM_ANALOG_PFD_528_PFD3_FRAC_Pos = 0x18
	// Bit mask of PFD3_FRAC field.
	CCM_ANALOG_PFD_528_PFD3_FRAC_Msk = 0x3f000000
	// Position of PFD3_STABLE field.
	CCM_ANALOG_PFD_528_PFD3_STABLE_Pos = 0x1e
	// Bit mask of PFD3_STABLE field.
	CCM_ANALOG_PFD_528_PFD3_STABLE_Msk = 0x40000000
	// Bit PFD3_STABLE.
	CCM_ANALOG_PFD_528_PFD3_STABLE = 0x40000000
	// Position of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_528_PFD3_CLKGATE_Pos = 0x1f
	// Bit mask of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_528_PFD3_CLKGATE_Msk = 0x80000000
	// Bit PFD3_CLKGATE.
	CCM_ANALOG_PFD_528_PFD3_CLKGATE = 0x80000000

	// PFD_528_SET: 528MHz Clock (PLL2) Phase Fractional Divider Control Register
	// Position of PFD0_FRAC field.
	CCM_ANALOG_PFD_528_SET_PFD0_FRAC_Pos = 0x0
	// Bit mask of PFD0_FRAC field.
	CCM_ANALOG_PFD_528_SET_PFD0_FRAC_Msk = 0x3f
	// Position of PFD0_STABLE field.
	CCM_ANALOG_PFD_528_SET_PFD0_STABLE_Pos = 0x6
	// Bit mask of PFD0_STABLE field.
	CCM_ANALOG_PFD_528_SET_PFD0_STABLE_Msk = 0x40
	// Bit PFD0_STABLE.
	CCM_ANALOG_PFD_528_SET_PFD0_STABLE = 0x40
	// Position of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_528_SET_PFD0_CLKGATE_Pos = 0x7
	// Bit mask of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_528_SET_PFD0_CLKGATE_Msk = 0x80
	// Bit PFD0_CLKGATE.
	CCM_ANALOG_PFD_528_SET_PFD0_CLKGATE = 0x80
	// Position of PFD1_FRAC field.
	CCM_ANALOG_PFD_528_SET_PFD1_FRAC_Pos = 0x8
	// Bit mask of PFD1_FRAC field.
	CCM_ANALOG_PFD_528_SET_PFD1_FRAC_Msk = 0x3f00
	// Position of PFD1_STABLE field.
	CCM_ANALOG_PFD_528_SET_PFD1_STABLE_Pos = 0xe
	// Bit mask of PFD1_STABLE field.
	CCM_ANALOG_PFD_528_SET_PFD1_STABLE_Msk = 0x4000
	// Bit PFD1_STABLE.
	CCM_ANALOG_PFD_528_SET_PFD1_STABLE = 0x4000
	// Position of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_528_SET_PFD1_CLKGATE_Pos = 0xf
	// Bit mask of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_528_SET_PFD1_CLKGATE_Msk = 0x8000
	// Bit PFD1_CLKGATE.
	CCM_ANALOG_PFD_528_SET_PFD1_CLKGATE = 0x8000
	// Position of PFD2_FRAC field.
	CCM_ANALOG_PFD_528_SET_PFD2_FRAC_Pos = 0x10
	// Bit mask of PFD2_FRAC field.
	CCM_ANALOG_PFD_528_SET_PFD2_FRAC_Msk = 0x3f0000
	// Position of PFD2_STABLE field.
	CCM_ANALOG_PFD_528_SET_PFD2_STABLE_Pos = 0x16
	// Bit mask of PFD2_STABLE field.
	CCM_ANALOG_PFD_528_SET_PFD2_STABLE_Msk = 0x400000
	// Bit PFD2_STABLE.
	CCM_ANALOG_PFD_528_SET_PFD2_STABLE = 0x400000
	// Position of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_528_SET_PFD2_CLKGATE_Pos = 0x17
	// Bit mask of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_528_SET_PFD2_CLKGATE_Msk = 0x800000
	// Bit PFD2_CLKGATE.
	CCM_ANALOG_PFD_528_SET_PFD2_CLKGATE = 0x800000
	// Position of PFD3_FRAC field.
	CCM_ANALOG_PFD_528_SET_PFD3_FRAC_Pos = 0x18
	// Bit mask of PFD3_FRAC field.
	CCM_ANALOG_PFD_528_SET_PFD3_FRAC_Msk = 0x3f000000
	// Position of PFD3_STABLE field.
	CCM_ANALOG_PFD_528_SET_PFD3_STABLE_Pos = 0x1e
	// Bit mask of PFD3_STABLE field.
	CCM_ANALOG_PFD_528_SET_PFD3_STABLE_Msk = 0x40000000
	// Bit PFD3_STABLE.
	CCM_ANALOG_PFD_528_SET_PFD3_STABLE = 0x40000000
	// Position of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_528_SET_PFD3_CLKGATE_Pos = 0x1f
	// Bit mask of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_528_SET_PFD3_CLKGATE_Msk = 0x80000000
	// Bit PFD3_CLKGATE.
	CCM_ANALOG_PFD_528_SET_PFD3_CLKGATE = 0x80000000

	// PFD_528_CLR: 528MHz Clock (PLL2) Phase Fractional Divider Control Register
	// Position of PFD0_FRAC field.
	CCM_ANALOG_PFD_528_CLR_PFD0_FRAC_Pos = 0x0
	// Bit mask of PFD0_FRAC field.
	CCM_ANALOG_PFD_528_CLR_PFD0_FRAC_Msk = 0x3f
	// Position of PFD0_STABLE field.
	CCM_ANALOG_PFD_528_CLR_PFD0_STABLE_Pos = 0x6
	// Bit mask of PFD0_STABLE field.
	CCM_ANALOG_PFD_528_CLR_PFD0_STABLE_Msk = 0x40
	// Bit PFD0_STABLE.
	CCM_ANALOG_PFD_528_CLR_PFD0_STABLE = 0x40
	// Position of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_528_CLR_PFD0_CLKGATE_Pos = 0x7
	// Bit mask of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_528_CLR_PFD0_CLKGATE_Msk = 0x80
	// Bit PFD0_CLKGATE.
	CCM_ANALOG_PFD_528_CLR_PFD0_CLKGATE = 0x80
	// Position of PFD1_FRAC field.
	CCM_ANALOG_PFD_528_CLR_PFD1_FRAC_Pos = 0x8
	// Bit mask of PFD1_FRAC field.
	CCM_ANALOG_PFD_528_CLR_PFD1_FRAC_Msk = 0x3f00
	// Position of PFD1_STABLE field.
	CCM_ANALOG_PFD_528_CLR_PFD1_STABLE_Pos = 0xe
	// Bit mask of PFD1_STABLE field.
	CCM_ANALOG_PFD_528_CLR_PFD1_STABLE_Msk = 0x4000
	// Bit PFD1_STABLE.
	CCM_ANALOG_PFD_528_CLR_PFD1_STABLE = 0x4000
	// Position of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_528_CLR_PFD1_CLKGATE_Pos = 0xf
	// Bit mask of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_528_CLR_PFD1_CLKGATE_Msk = 0x8000
	// Bit PFD1_CLKGATE.
	CCM_ANALOG_PFD_528_CLR_PFD1_CLKGATE = 0x8000
	// Position of PFD2_FRAC field.
	CCM_ANALOG_PFD_528_CLR_PFD2_FRAC_Pos = 0x10
	// Bit mask of PFD2_FRAC field.
	CCM_ANALOG_PFD_528_CLR_PFD2_FRAC_Msk = 0x3f0000
	// Position of PFD2_STABLE field.
	CCM_ANALOG_PFD_528_CLR_PFD2_STABLE_Pos = 0x16
	// Bit mask of PFD2_STABLE field.
	CCM_ANALOG_PFD_528_CLR_PFD2_STABLE_Msk = 0x400000
	// Bit PFD2_STABLE.
	CCM_ANALOG_PFD_528_CLR_PFD2_STABLE = 0x400000
	// Position of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_528_CLR_PFD2_CLKGATE_Pos = 0x17
	// Bit mask of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_528_CLR_PFD2_CLKGATE_Msk = 0x800000
	// Bit PFD2_CLKGATE.
	CCM_ANALOG_PFD_528_CLR_PFD2_CLKGATE = 0x800000
	// Position of PFD3_FRAC field.
	CCM_ANALOG_PFD_528_CLR_PFD3_FRAC_Pos = 0x18
	// Bit mask of PFD3_FRAC field.
	CCM_ANALOG_PFD_528_CLR_PFD3_FRAC_Msk = 0x3f000000
	// Position of PFD3_STABLE field.
	CCM_ANALOG_PFD_528_CLR_PFD3_STABLE_Pos = 0x1e
	// Bit mask of PFD3_STABLE field.
	CCM_ANALOG_PFD_528_CLR_PFD3_STABLE_Msk = 0x40000000
	// Bit PFD3_STABLE.
	CCM_ANALOG_PFD_528_CLR_PFD3_STABLE = 0x40000000
	// Position of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_528_CLR_PFD3_CLKGATE_Pos = 0x1f
	// Bit mask of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_528_CLR_PFD3_CLKGATE_Msk = 0x80000000
	// Bit PFD3_CLKGATE.
	CCM_ANALOG_PFD_528_CLR_PFD3_CLKGATE = 0x80000000

	// PFD_528_TOG: 528MHz Clock (PLL2) Phase Fractional Divider Control Register
	// Position of PFD0_FRAC field.
	CCM_ANALOG_PFD_528_TOG_PFD0_FRAC_Pos = 0x0
	// Bit mask of PFD0_FRAC field.
	CCM_ANALOG_PFD_528_TOG_PFD0_FRAC_Msk = 0x3f
	// Position of PFD0_STABLE field.
	CCM_ANALOG_PFD_528_TOG_PFD0_STABLE_Pos = 0x6
	// Bit mask of PFD0_STABLE field.
	CCM_ANALOG_PFD_528_TOG_PFD0_STABLE_Msk = 0x40
	// Bit PFD0_STABLE.
	CCM_ANALOG_PFD_528_TOG_PFD0_STABLE = 0x40
	// Position of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_528_TOG_PFD0_CLKGATE_Pos = 0x7
	// Bit mask of PFD0_CLKGATE field.
	CCM_ANALOG_PFD_528_TOG_PFD0_CLKGATE_Msk = 0x80
	// Bit PFD0_CLKGATE.
	CCM_ANALOG_PFD_528_TOG_PFD0_CLKGATE = 0x80
	// Position of PFD1_FRAC field.
	CCM_ANALOG_PFD_528_TOG_PFD1_FRAC_Pos = 0x8
	// Bit mask of PFD1_FRAC field.
	CCM_ANALOG_PFD_528_TOG_PFD1_FRAC_Msk = 0x3f00
	// Position of PFD1_STABLE field.
	CCM_ANALOG_PFD_528_TOG_PFD1_STABLE_Pos = 0xe
	// Bit mask of PFD1_STABLE field.
	CCM_ANALOG_PFD_528_TOG_PFD1_STABLE_Msk = 0x4000
	// Bit PFD1_STABLE.
	CCM_ANALOG_PFD_528_TOG_PFD1_STABLE = 0x4000
	// Position of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_528_TOG_PFD1_CLKGATE_Pos = 0xf
	// Bit mask of PFD1_CLKGATE field.
	CCM_ANALOG_PFD_528_TOG_PFD1_CLKGATE_Msk = 0x8000
	// Bit PFD1_CLKGATE.
	CCM_ANALOG_PFD_528_TOG_PFD1_CLKGATE = 0x8000
	// Position of PFD2_FRAC field.
	CCM_ANALOG_PFD_528_TOG_PFD2_FRAC_Pos = 0x10
	// Bit mask of PFD2_FRAC field.
	CCM_ANALOG_PFD_528_TOG_PFD2_FRAC_Msk = 0x3f0000
	// Position of PFD2_STABLE field.
	CCM_ANALOG_PFD_528_TOG_PFD2_STABLE_Pos = 0x16
	// Bit mask of PFD2_STABLE field.
	CCM_ANALOG_PFD_528_TOG_PFD2_STABLE_Msk = 0x400000
	// Bit PFD2_STABLE.
	CCM_ANALOG_PFD_528_TOG_PFD2_STABLE = 0x400000
	// Position of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_528_TOG_PFD2_CLKGATE_Pos = 0x17
	// Bit mask of PFD2_CLKGATE field.
	CCM_ANALOG_PFD_528_TOG_PFD2_CLKGATE_Msk = 0x800000
	// Bit PFD2_CLKGATE.
	CCM_ANALOG_PFD_528_TOG_PFD2_CLKGATE = 0x800000
	// Position of PFD3_FRAC field.
	CCM_ANALOG_PFD_528_TOG_PFD3_FRAC_Pos = 0x18
	// Bit mask of PFD3_FRAC field.
	CCM_ANALOG_PFD_528_TOG_PFD3_FRAC_Msk = 0x3f000000
	// Position of PFD3_STABLE field.
	CCM_ANALOG_PFD_528_TOG_PFD3_STABLE_Pos = 0x1e
	// Bit mask of PFD3_STABLE field.
	CCM_ANALOG_PFD_528_TOG_PFD3_STABLE_Msk = 0x40000000
	// Bit PFD3_STABLE.
	CCM_ANALOG_PFD_528_TOG_PFD3_STABLE = 0x40000000
	// Position of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_528_TOG_PFD3_CLKGATE_Pos = 0x1f
	// Bit mask of PFD3_CLKGATE field.
	CCM_ANALOG_PFD_528_TOG_PFD3_CLKGATE_Msk = 0x80000000
	// Bit PFD3_CLKGATE.
	CCM_ANALOG_PFD_528_TOG_PFD3_CLKGATE = 0x80000000

	// MISC0: Miscellaneous Register 0
	// Position of REFTOP_PWD field.
	CCM_ANALOG_MISC0_REFTOP_PWD_Pos = 0x0
	// Bit mask of REFTOP_PWD field.
	CCM_ANALOG_MISC0_REFTOP_PWD_Msk = 0x1
	// Bit REFTOP_PWD.
	CCM_ANALOG_MISC0_REFTOP_PWD = 0x1
	// Position of REFTOP_SELFBIASOFF field.
	CCM_ANALOG_MISC0_REFTOP_SELFBIASOFF_Pos = 0x3
	// Bit mask of REFTOP_SELFBIASOFF field.
	CCM_ANALOG_MISC0_REFTOP_SELFBIASOFF_Msk = 0x8
	// Bit REFTOP_SELFBIASOFF.
	CCM_ANALOG_MISC0_REFTOP_SELFBIASOFF = 0x8
	// Uses coarse bias currents for startup
	CCM_ANALOG_MISC0_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_0 = 0x0
	// Uses bandgap-based bias currents for best performance.
	CCM_ANALOG_MISC0_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_1 = 0x1
	// Position of REFTOP_VBGADJ field.
	CCM_ANALOG_MISC0_REFTOP_VBGADJ_Pos = 0x4
	// Bit mask of REFTOP_VBGADJ field.
	CCM_ANALOG_MISC0_REFTOP_VBGADJ_Msk = 0x70
	// Nominal VBG
	CCM_ANALOG_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_0 = 0x0
	// VBG+0.78%
	CCM_ANALOG_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_1 = 0x1
	// VBG+1.56%
	CCM_ANALOG_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_2 = 0x2
	// VBG+2.34%
	CCM_ANALOG_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_3 = 0x3
	// VBG-0.78%
	CCM_ANALOG_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_4 = 0x4
	// VBG-1.56%
	CCM_ANALOG_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_5 = 0x5
	// VBG-2.34%
	CCM_ANALOG_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_6 = 0x6
	// VBG-3.12%
	CCM_ANALOG_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_7 = 0x7
	// Position of REFTOP_VBGUP field.
	CCM_ANALOG_MISC0_REFTOP_VBGUP_Pos = 0x7
	// Bit mask of REFTOP_VBGUP field.
	CCM_ANALOG_MISC0_REFTOP_VBGUP_Msk = 0x80
	// Bit REFTOP_VBGUP.
	CCM_ANALOG_MISC0_REFTOP_VBGUP = 0x80
	// Position of STOP_MODE_CONFIG field.
	CCM_ANALOG_MISC0_STOP_MODE_CONFIG_Pos = 0xa
	// Bit mask of STOP_MODE_CONFIG field.
	CCM_ANALOG_MISC0_STOP_MODE_CONFIG_Msk = 0xc00
	// All analog except RTC powered down on stop mode assertion.
	CCM_ANALOG_MISC0_STOP_MODE_CONFIG_STOP_MODE_CONFIG_0 = 0x0
	// Beside RTC, analog bandgap, 1p1 and 2p5 regulators are also on.
	CCM_ANALOG_MISC0_STOP_MODE_CONFIG_STOP_MODE_CONFIG_1 = 0x1
	// Beside RTC, 1p1 and 2p5 regulators are also on, low-power bandgap is selected so that the normal analog bandgap together with the rest analog is powered down.
	CCM_ANALOG_MISC0_STOP_MODE_CONFIG_STOP_MODE_CONFIG_2 = 0x2
	// Beside RTC, low-power bandgap is selected and the rest analog is powered down.
	CCM_ANALOG_MISC0_STOP_MODE_CONFIG_STOP_MODE_CONFIG_3 = 0x3
	// Position of DISCON_HIGH_SNVS field.
	CCM_ANALOG_MISC0_DISCON_HIGH_SNVS_Pos = 0xc
	// Bit mask of DISCON_HIGH_SNVS field.
	CCM_ANALOG_MISC0_DISCON_HIGH_SNVS_Msk = 0x1000
	// Bit DISCON_HIGH_SNVS.
	CCM_ANALOG_MISC0_DISCON_HIGH_SNVS = 0x1000
	// Turn on the switch
	CCM_ANALOG_MISC0_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_0 = 0x0
	// Turn off the switch
	CCM_ANALOG_MISC0_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_1 = 0x1
	// Position of OSC_I field.
	CCM_ANALOG_MISC0_OSC_I_Pos = 0xd
	// Bit mask of OSC_I field.
	CCM_ANALOG_MISC0_OSC_I_Msk = 0x6000
	// Nominal
	CCM_ANALOG_MISC0_OSC_I_NOMINAL = 0x0
	// Decrease current by 12.5%
	CCM_ANALOG_MISC0_OSC_I_MINUS_12_5_PERCENT = 0x1
	// Decrease current by 25.0%
	CCM_ANALOG_MISC0_OSC_I_MINUS_25_PERCENT = 0x2
	// Decrease current by 37.5%
	CCM_ANALOG_MISC0_OSC_I_MINUS_37_5_PERCENT = 0x3
	// Position of OSC_XTALOK field.
	CCM_ANALOG_MISC0_OSC_XTALOK_Pos = 0xf
	// Bit mask of OSC_XTALOK field.
	CCM_ANALOG_MISC0_OSC_XTALOK_Msk = 0x8000
	// Bit OSC_XTALOK.
	CCM_ANALOG_MISC0_OSC_XTALOK = 0x8000
	// Position of OSC_XTALOK_EN field.
	CCM_ANALOG_MISC0_OSC_XTALOK_EN_Pos = 0x10
	// Bit mask of OSC_XTALOK_EN field.
	CCM_ANALOG_MISC0_OSC_XTALOK_EN_Msk = 0x10000
	// Bit OSC_XTALOK_EN.
	CCM_ANALOG_MISC0_OSC_XTALOK_EN = 0x10000
	// Position of CLKGATE_CTRL field.
	CCM_ANALOG_MISC0_CLKGATE_CTRL_Pos = 0x19
	// Bit mask of CLKGATE_CTRL field.
	CCM_ANALOG_MISC0_CLKGATE_CTRL_Msk = 0x2000000
	// Bit CLKGATE_CTRL.
	CCM_ANALOG_MISC0_CLKGATE_CTRL = 0x2000000
	// Allow the logic to automatically gate the clock when the XTAL is powered down.
	CCM_ANALOG_MISC0_CLKGATE_CTRL_ALLOW_AUTO_GATE = 0x0
	// Prevent the logic from ever gating off the clock.
	CCM_ANALOG_MISC0_CLKGATE_CTRL_NO_AUTO_GATE = 0x1
	// Position of CLKGATE_DELAY field.
	CCM_ANALOG_MISC0_CLKGATE_DELAY_Pos = 0x1a
	// Bit mask of CLKGATE_DELAY field.
	CCM_ANALOG_MISC0_CLKGATE_DELAY_Msk = 0x1c000000
	// 0.5ms
	CCM_ANALOG_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_0 = 0x0
	// 1.0ms
	CCM_ANALOG_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_1 = 0x1
	// 2.0ms
	CCM_ANALOG_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_2 = 0x2
	// 3.0ms
	CCM_ANALOG_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_3 = 0x3
	// 4.0ms
	CCM_ANALOG_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_4 = 0x4
	// 5.0ms
	CCM_ANALOG_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_5 = 0x5
	// 6.0ms
	CCM_ANALOG_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_6 = 0x6
	// 7.0ms
	CCM_ANALOG_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_7 = 0x7
	// Position of RTC_XTAL_SOURCE field.
	CCM_ANALOG_MISC0_RTC_XTAL_SOURCE_Pos = 0x1d
	// Bit mask of RTC_XTAL_SOURCE field.
	CCM_ANALOG_MISC0_RTC_XTAL_SOURCE_Msk = 0x20000000
	// Bit RTC_XTAL_SOURCE.
	CCM_ANALOG_MISC0_RTC_XTAL_SOURCE = 0x20000000
	// Internal ring oscillator
	CCM_ANALOG_MISC0_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_0 = 0x0
	// RTC_XTAL
	CCM_ANALOG_MISC0_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_1 = 0x1
	// Position of XTAL_24M_PWD field.
	CCM_ANALOG_MISC0_XTAL_24M_PWD_Pos = 0x1e
	// Bit mask of XTAL_24M_PWD field.
	CCM_ANALOG_MISC0_XTAL_24M_PWD_Msk = 0x40000000
	// Bit XTAL_24M_PWD.
	CCM_ANALOG_MISC0_XTAL_24M_PWD = 0x40000000

	// MISC0_SET: Miscellaneous Register 0
	// Position of REFTOP_PWD field.
	CCM_ANALOG_MISC0_SET_REFTOP_PWD_Pos = 0x0
	// Bit mask of REFTOP_PWD field.
	CCM_ANALOG_MISC0_SET_REFTOP_PWD_Msk = 0x1
	// Bit REFTOP_PWD.
	CCM_ANALOG_MISC0_SET_REFTOP_PWD = 0x1
	// Position of REFTOP_SELFBIASOFF field.
	CCM_ANALOG_MISC0_SET_REFTOP_SELFBIASOFF_Pos = 0x3
	// Bit mask of REFTOP_SELFBIASOFF field.
	CCM_ANALOG_MISC0_SET_REFTOP_SELFBIASOFF_Msk = 0x8
	// Bit REFTOP_SELFBIASOFF.
	CCM_ANALOG_MISC0_SET_REFTOP_SELFBIASOFF = 0x8
	// Uses coarse bias currents for startup
	CCM_ANALOG_MISC0_SET_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_0 = 0x0
	// Uses bandgap-based bias currents for best performance.
	CCM_ANALOG_MISC0_SET_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_1 = 0x1
	// Position of REFTOP_VBGADJ field.
	CCM_ANALOG_MISC0_SET_REFTOP_VBGADJ_Pos = 0x4
	// Bit mask of REFTOP_VBGADJ field.
	CCM_ANALOG_MISC0_SET_REFTOP_VBGADJ_Msk = 0x70
	// Nominal VBG
	CCM_ANALOG_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_0 = 0x0
	// VBG+0.78%
	CCM_ANALOG_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_1 = 0x1
	// VBG+1.56%
	CCM_ANALOG_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_2 = 0x2
	// VBG+2.34%
	CCM_ANALOG_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_3 = 0x3
	// VBG-0.78%
	CCM_ANALOG_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_4 = 0x4
	// VBG-1.56%
	CCM_ANALOG_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_5 = 0x5
	// VBG-2.34%
	CCM_ANALOG_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_6 = 0x6
	// VBG-3.12%
	CCM_ANALOG_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_7 = 0x7
	// Position of REFTOP_VBGUP field.
	CCM_ANALOG_MISC0_SET_REFTOP_VBGUP_Pos = 0x7
	// Bit mask of REFTOP_VBGUP field.
	CCM_ANALOG_MISC0_SET_REFTOP_VBGUP_Msk = 0x80
	// Bit REFTOP_VBGUP.
	CCM_ANALOG_MISC0_SET_REFTOP_VBGUP = 0x80
	// Position of STOP_MODE_CONFIG field.
	CCM_ANALOG_MISC0_SET_STOP_MODE_CONFIG_Pos = 0xa
	// Bit mask of STOP_MODE_CONFIG field.
	CCM_ANALOG_MISC0_SET_STOP_MODE_CONFIG_Msk = 0xc00
	// All analog except RTC powered down on stop mode assertion.
	CCM_ANALOG_MISC0_SET_STOP_MODE_CONFIG_STOP_MODE_CONFIG_0 = 0x0
	// Beside RTC, analog bandgap, 1p1 and 2p5 regulators are also on.
	CCM_ANALOG_MISC0_SET_STOP_MODE_CONFIG_STOP_MODE_CONFIG_1 = 0x1
	// Beside RTC, 1p1 and 2p5 regulators are also on, low-power bandgap is selected so that the normal analog bandgap together with the rest analog is powered down.
	CCM_ANALOG_MISC0_SET_STOP_MODE_CONFIG_STOP_MODE_CONFIG_2 = 0x2
	// Beside RTC, low-power bandgap is selected and the rest analog is powered down.
	CCM_ANALOG_MISC0_SET_STOP_MODE_CONFIG_STOP_MODE_CONFIG_3 = 0x3
	// Position of DISCON_HIGH_SNVS field.
	CCM_ANALOG_MISC0_SET_DISCON_HIGH_SNVS_Pos = 0xc
	// Bit mask of DISCON_HIGH_SNVS field.
	CCM_ANALOG_MISC0_SET_DISCON_HIGH_SNVS_Msk = 0x1000
	// Bit DISCON_HIGH_SNVS.
	CCM_ANALOG_MISC0_SET_DISCON_HIGH_SNVS = 0x1000
	// Turn on the switch
	CCM_ANALOG_MISC0_SET_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_0 = 0x0
	// Turn off the switch
	CCM_ANALOG_MISC0_SET_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_1 = 0x1
	// Position of OSC_I field.
	CCM_ANALOG_MISC0_SET_OSC_I_Pos = 0xd
	// Bit mask of OSC_I field.
	CCM_ANALOG_MISC0_SET_OSC_I_Msk = 0x6000
	// Nominal
	CCM_ANALOG_MISC0_SET_OSC_I_NOMINAL = 0x0
	// Decrease current by 12.5%
	CCM_ANALOG_MISC0_SET_OSC_I_MINUS_12_5_PERCENT = 0x1
	// Decrease current by 25.0%
	CCM_ANALOG_MISC0_SET_OSC_I_MINUS_25_PERCENT = 0x2
	// Decrease current by 37.5%
	CCM_ANALOG_MISC0_SET_OSC_I_MINUS_37_5_PERCENT = 0x3
	// Position of OSC_XTALOK field.
	CCM_ANALOG_MISC0_SET_OSC_XTALOK_Pos = 0xf
	// Bit mask of OSC_XTALOK field.
	CCM_ANALOG_MISC0_SET_OSC_XTALOK_Msk = 0x8000
	// Bit OSC_XTALOK.
	CCM_ANALOG_MISC0_SET_OSC_XTALOK = 0x8000
	// Position of OSC_XTALOK_EN field.
	CCM_ANALOG_MISC0_SET_OSC_XTALOK_EN_Pos = 0x10
	// Bit mask of OSC_XTALOK_EN field.
	CCM_ANALOG_MISC0_SET_OSC_XTALOK_EN_Msk = 0x10000
	// Bit OSC_XTALOK_EN.
	CCM_ANALOG_MISC0_SET_OSC_XTALOK_EN = 0x10000
	// Position of CLKGATE_CTRL field.
	CCM_ANALOG_MISC0_SET_CLKGATE_CTRL_Pos = 0x19
	// Bit mask of CLKGATE_CTRL field.
	CCM_ANALOG_MISC0_SET_CLKGATE_CTRL_Msk = 0x2000000
	// Bit CLKGATE_CTRL.
	CCM_ANALOG_MISC0_SET_CLKGATE_CTRL = 0x2000000
	// Allow the logic to automatically gate the clock when the XTAL is powered down.
	CCM_ANALOG_MISC0_SET_CLKGATE_CTRL_ALLOW_AUTO_GATE = 0x0
	// Prevent the logic from ever gating off the clock.
	CCM_ANALOG_MISC0_SET_CLKGATE_CTRL_NO_AUTO_GATE = 0x1
	// Position of CLKGATE_DELAY field.
	CCM_ANALOG_MISC0_SET_CLKGATE_DELAY_Pos = 0x1a
	// Bit mask of CLKGATE_DELAY field.
	CCM_ANALOG_MISC0_SET_CLKGATE_DELAY_Msk = 0x1c000000
	// 0.5ms
	CCM_ANALOG_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_0 = 0x0
	// 1.0ms
	CCM_ANALOG_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_1 = 0x1
	// 2.0ms
	CCM_ANALOG_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_2 = 0x2
	// 3.0ms
	CCM_ANALOG_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_3 = 0x3
	// 4.0ms
	CCM_ANALOG_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_4 = 0x4
	// 5.0ms
	CCM_ANALOG_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_5 = 0x5
	// 6.0ms
	CCM_ANALOG_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_6 = 0x6
	// 7.0ms
	CCM_ANALOG_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_7 = 0x7
	// Position of RTC_XTAL_SOURCE field.
	CCM_ANALOG_MISC0_SET_RTC_XTAL_SOURCE_Pos = 0x1d
	// Bit mask of RTC_XTAL_SOURCE field.
	CCM_ANALOG_MISC0_SET_RTC_XTAL_SOURCE_Msk = 0x20000000
	// Bit RTC_XTAL_SOURCE.
	CCM_ANALOG_MISC0_SET_RTC_XTAL_SOURCE = 0x20000000
	// Internal ring oscillator
	CCM_ANALOG_MISC0_SET_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_0 = 0x0
	// RTC_XTAL
	CCM_ANALOG_MISC0_SET_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_1 = 0x1
	// Position of XTAL_24M_PWD field.
	CCM_ANALOG_MISC0_SET_XTAL_24M_PWD_Pos = 0x1e
	// Bit mask of XTAL_24M_PWD field.
	CCM_ANALOG_MISC0_SET_XTAL_24M_PWD_Msk = 0x40000000
	// Bit XTAL_24M_PWD.
	CCM_ANALOG_MISC0_SET_XTAL_24M_PWD = 0x40000000

	// MISC0_CLR: Miscellaneous Register 0
	// Position of REFTOP_PWD field.
	CCM_ANALOG_MISC0_CLR_REFTOP_PWD_Pos = 0x0
	// Bit mask of REFTOP_PWD field.
	CCM_ANALOG_MISC0_CLR_REFTOP_PWD_Msk = 0x1
	// Bit REFTOP_PWD.
	CCM_ANALOG_MISC0_CLR_REFTOP_PWD = 0x1
	// Position of REFTOP_SELFBIASOFF field.
	CCM_ANALOG_MISC0_CLR_REFTOP_SELFBIASOFF_Pos = 0x3
	// Bit mask of REFTOP_SELFBIASOFF field.
	CCM_ANALOG_MISC0_CLR_REFTOP_SELFBIASOFF_Msk = 0x8
	// Bit REFTOP_SELFBIASOFF.
	CCM_ANALOG_MISC0_CLR_REFTOP_SELFBIASOFF = 0x8
	// Uses coarse bias currents for startup
	CCM_ANALOG_MISC0_CLR_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_0 = 0x0
	// Uses bandgap-based bias currents for best performance.
	CCM_ANALOG_MISC0_CLR_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_1 = 0x1
	// Position of REFTOP_VBGADJ field.
	CCM_ANALOG_MISC0_CLR_REFTOP_VBGADJ_Pos = 0x4
	// Bit mask of REFTOP_VBGADJ field.
	CCM_ANALOG_MISC0_CLR_REFTOP_VBGADJ_Msk = 0x70
	// Nominal VBG
	CCM_ANALOG_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_0 = 0x0
	// VBG+0.78%
	CCM_ANALOG_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_1 = 0x1
	// VBG+1.56%
	CCM_ANALOG_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_2 = 0x2
	// VBG+2.34%
	CCM_ANALOG_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_3 = 0x3
	// VBG-0.78%
	CCM_ANALOG_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_4 = 0x4
	// VBG-1.56%
	CCM_ANALOG_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_5 = 0x5
	// VBG-2.34%
	CCM_ANALOG_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_6 = 0x6
	// VBG-3.12%
	CCM_ANALOG_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_7 = 0x7
	// Position of REFTOP_VBGUP field.
	CCM_ANALOG_MISC0_CLR_REFTOP_VBGUP_Pos = 0x7
	// Bit mask of REFTOP_VBGUP field.
	CCM_ANALOG_MISC0_CLR_REFTOP_VBGUP_Msk = 0x80
	// Bit REFTOP_VBGUP.
	CCM_ANALOG_MISC0_CLR_REFTOP_VBGUP = 0x80
	// Position of STOP_MODE_CONFIG field.
	CCM_ANALOG_MISC0_CLR_STOP_MODE_CONFIG_Pos = 0xa
	// Bit mask of STOP_MODE_CONFIG field.
	CCM_ANALOG_MISC0_CLR_STOP_MODE_CONFIG_Msk = 0xc00
	// All analog except RTC powered down on stop mode assertion.
	CCM_ANALOG_MISC0_CLR_STOP_MODE_CONFIG_STOP_MODE_CONFIG_0 = 0x0
	// Beside RTC, analog bandgap, 1p1 and 2p5 regulators are also on.
	CCM_ANALOG_MISC0_CLR_STOP_MODE_CONFIG_STOP_MODE_CONFIG_1 = 0x1
	// Beside RTC, 1p1 and 2p5 regulators are also on, low-power bandgap is selected so that the normal analog bandgap together with the rest analog is powered down.
	CCM_ANALOG_MISC0_CLR_STOP_MODE_CONFIG_STOP_MODE_CONFIG_2 = 0x2
	// Beside RTC, low-power bandgap is selected and the rest analog is powered down.
	CCM_ANALOG_MISC0_CLR_STOP_MODE_CONFIG_STOP_MODE_CONFIG_3 = 0x3
	// Position of DISCON_HIGH_SNVS field.
	CCM_ANALOG_MISC0_CLR_DISCON_HIGH_SNVS_Pos = 0xc
	// Bit mask of DISCON_HIGH_SNVS field.
	CCM_ANALOG_MISC0_CLR_DISCON_HIGH_SNVS_Msk = 0x1000
	// Bit DISCON_HIGH_SNVS.
	CCM_ANALOG_MISC0_CLR_DISCON_HIGH_SNVS = 0x1000
	// Turn on the switch
	CCM_ANALOG_MISC0_CLR_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_0 = 0x0
	// Turn off the switch
	CCM_ANALOG_MISC0_CLR_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_1 = 0x1
	// Position of OSC_I field.
	CCM_ANALOG_MISC0_CLR_OSC_I_Pos = 0xd
	// Bit mask of OSC_I field.
	CCM_ANALOG_MISC0_CLR_OSC_I_Msk = 0x6000
	// Nominal
	CCM_ANALOG_MISC0_CLR_OSC_I_NOMINAL = 0x0
	// Decrease current by 12.5%
	CCM_ANALOG_MISC0_CLR_OSC_I_MINUS_12_5_PERCENT = 0x1
	// Decrease current by 25.0%
	CCM_ANALOG_MISC0_CLR_OSC_I_MINUS_25_PERCENT = 0x2
	// Decrease current by 37.5%
	CCM_ANALOG_MISC0_CLR_OSC_I_MINUS_37_5_PERCENT = 0x3
	// Position of OSC_XTALOK field.
	CCM_ANALOG_MISC0_CLR_OSC_XTALOK_Pos = 0xf
	// Bit mask of OSC_XTALOK field.
	CCM_ANALOG_MISC0_CLR_OSC_XTALOK_Msk = 0x8000
	// Bit OSC_XTALOK.
	CCM_ANALOG_MISC0_CLR_OSC_XTALOK = 0x8000
	// Position of OSC_XTALOK_EN field.
	CCM_ANALOG_MISC0_CLR_OSC_XTALOK_EN_Pos = 0x10
	// Bit mask of OSC_XTALOK_EN field.
	CCM_ANALOG_MISC0_CLR_OSC_XTALOK_EN_Msk = 0x10000
	// Bit OSC_XTALOK_EN.
	CCM_ANALOG_MISC0_CLR_OSC_XTALOK_EN = 0x10000
	// Position of CLKGATE_CTRL field.
	CCM_ANALOG_MISC0_CLR_CLKGATE_CTRL_Pos = 0x19
	// Bit mask of CLKGATE_CTRL field.
	CCM_ANALOG_MISC0_CLR_CLKGATE_CTRL_Msk = 0x2000000
	// Bit CLKGATE_CTRL.
	CCM_ANALOG_MISC0_CLR_CLKGATE_CTRL = 0x2000000
	// Allow the logic to automatically gate the clock when the XTAL is powered down.
	CCM_ANALOG_MISC0_CLR_CLKGATE_CTRL_ALLOW_AUTO_GATE = 0x0
	// Prevent the logic from ever gating off the clock.
	CCM_ANALOG_MISC0_CLR_CLKGATE_CTRL_NO_AUTO_GATE = 0x1
	// Position of CLKGATE_DELAY field.
	CCM_ANALOG_MISC0_CLR_CLKGATE_DELAY_Pos = 0x1a
	// Bit mask of CLKGATE_DELAY field.
	CCM_ANALOG_MISC0_CLR_CLKGATE_DELAY_Msk = 0x1c000000
	// 0.5ms
	CCM_ANALOG_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_0 = 0x0
	// 1.0ms
	CCM_ANALOG_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_1 = 0x1
	// 2.0ms
	CCM_ANALOG_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_2 = 0x2
	// 3.0ms
	CCM_ANALOG_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_3 = 0x3
	// 4.0ms
	CCM_ANALOG_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_4 = 0x4
	// 5.0ms
	CCM_ANALOG_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_5 = 0x5
	// 6.0ms
	CCM_ANALOG_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_6 = 0x6
	// 7.0ms
	CCM_ANALOG_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_7 = 0x7
	// Position of RTC_XTAL_SOURCE field.
	CCM_ANALOG_MISC0_CLR_RTC_XTAL_SOURCE_Pos = 0x1d
	// Bit mask of RTC_XTAL_SOURCE field.
	CCM_ANALOG_MISC0_CLR_RTC_XTAL_SOURCE_Msk = 0x20000000
	// Bit RTC_XTAL_SOURCE.
	CCM_ANALOG_MISC0_CLR_RTC_XTAL_SOURCE = 0x20000000
	// Internal ring oscillator
	CCM_ANALOG_MISC0_CLR_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_0 = 0x0
	// RTC_XTAL
	CCM_ANALOG_MISC0_CLR_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_1 = 0x1
	// Position of XTAL_24M_PWD field.
	CCM_ANALOG_MISC0_CLR_XTAL_24M_PWD_Pos = 0x1e
	// Bit mask of XTAL_24M_PWD field.
	CCM_ANALOG_MISC0_CLR_XTAL_24M_PWD_Msk = 0x40000000
	// Bit XTAL_24M_PWD.
	CCM_ANALOG_MISC0_CLR_XTAL_24M_PWD = 0x40000000

	// MISC0_TOG: Miscellaneous Register 0
	// Position of REFTOP_PWD field.
	CCM_ANALOG_MISC0_TOG_REFTOP_PWD_Pos = 0x0
	// Bit mask of REFTOP_PWD field.
	CCM_ANALOG_MISC0_TOG_REFTOP_PWD_Msk = 0x1
	// Bit REFTOP_PWD.
	CCM_ANALOG_MISC0_TOG_REFTOP_PWD = 0x1
	// Position of REFTOP_SELFBIASOFF field.
	CCM_ANALOG_MISC0_TOG_REFTOP_SELFBIASOFF_Pos = 0x3
	// Bit mask of REFTOP_SELFBIASOFF field.
	CCM_ANALOG_MISC0_TOG_REFTOP_SELFBIASOFF_Msk = 0x8
	// Bit REFTOP_SELFBIASOFF.
	CCM_ANALOG_MISC0_TOG_REFTOP_SELFBIASOFF = 0x8
	// Uses coarse bias currents for startup
	CCM_ANALOG_MISC0_TOG_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_0 = 0x0
	// Uses bandgap-based bias currents for best performance.
	CCM_ANALOG_MISC0_TOG_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_1 = 0x1
	// Position of REFTOP_VBGADJ field.
	CCM_ANALOG_MISC0_TOG_REFTOP_VBGADJ_Pos = 0x4
	// Bit mask of REFTOP_VBGADJ field.
	CCM_ANALOG_MISC0_TOG_REFTOP_VBGADJ_Msk = 0x70
	// Nominal VBG
	CCM_ANALOG_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_0 = 0x0
	// VBG+0.78%
	CCM_ANALOG_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_1 = 0x1
	// VBG+1.56%
	CCM_ANALOG_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_2 = 0x2
	// VBG+2.34%
	CCM_ANALOG_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_3 = 0x3
	// VBG-0.78%
	CCM_ANALOG_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_4 = 0x4
	// VBG-1.56%
	CCM_ANALOG_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_5 = 0x5
	// VBG-2.34%
	CCM_ANALOG_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_6 = 0x6
	// VBG-3.12%
	CCM_ANALOG_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_7 = 0x7
	// Position of REFTOP_VBGUP field.
	CCM_ANALOG_MISC0_TOG_REFTOP_VBGUP_Pos = 0x7
	// Bit mask of REFTOP_VBGUP field.
	CCM_ANALOG_MISC0_TOG_REFTOP_VBGUP_Msk = 0x80
	// Bit REFTOP_VBGUP.
	CCM_ANALOG_MISC0_TOG_REFTOP_VBGUP = 0x80
	// Position of STOP_MODE_CONFIG field.
	CCM_ANALOG_MISC0_TOG_STOP_MODE_CONFIG_Pos = 0xa
	// Bit mask of STOP_MODE_CONFIG field.
	CCM_ANALOG_MISC0_TOG_STOP_MODE_CONFIG_Msk = 0xc00
	// All analog except RTC powered down on stop mode assertion.
	CCM_ANALOG_MISC0_TOG_STOP_MODE_CONFIG_STOP_MODE_CONFIG_0 = 0x0
	// Beside RTC, analog bandgap, 1p1 and 2p5 regulators are also on.
	CCM_ANALOG_MISC0_TOG_STOP_MODE_CONFIG_STOP_MODE_CONFIG_1 = 0x1
	// Beside RTC, 1p1 and 2p5 regulators are also on, low-power bandgap is selected so that the normal analog bandgap together with the rest analog is powered down.
	CCM_ANALOG_MISC0_TOG_STOP_MODE_CONFIG_STOP_MODE_CONFIG_2 = 0x2
	// Beside RTC, low-power bandgap is selected and the rest analog is powered down.
	CCM_ANALOG_MISC0_TOG_STOP_MODE_CONFIG_STOP_MODE_CONFIG_3 = 0x3
	// Position of DISCON_HIGH_SNVS field.
	CCM_ANALOG_MISC0_TOG_DISCON_HIGH_SNVS_Pos = 0xc
	// Bit mask of DISCON_HIGH_SNVS field.
	CCM_ANALOG_MISC0_TOG_DISCON_HIGH_SNVS_Msk = 0x1000
	// Bit DISCON_HIGH_SNVS.
	CCM_ANALOG_MISC0_TOG_DISCON_HIGH_SNVS = 0x1000
	// Turn on the switch
	CCM_ANALOG_MISC0_TOG_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_0 = 0x0
	// Turn off the switch
	CCM_ANALOG_MISC0_TOG_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_1 = 0x1
	// Position of OSC_I field.
	CCM_ANALOG_MISC0_TOG_OSC_I_Pos = 0xd
	// Bit mask of OSC_I field.
	CCM_ANALOG_MISC0_TOG_OSC_I_Msk = 0x6000
	// Nominal
	CCM_ANALOG_MISC0_TOG_OSC_I_NOMINAL = 0x0
	// Decrease current by 12.5%
	CCM_ANALOG_MISC0_TOG_OSC_I_MINUS_12_5_PERCENT = 0x1
	// Decrease current by 25.0%
	CCM_ANALOG_MISC0_TOG_OSC_I_MINUS_25_PERCENT = 0x2
	// Decrease current by 37.5%
	CCM_ANALOG_MISC0_TOG_OSC_I_MINUS_37_5_PERCENT = 0x3
	// Position of OSC_XTALOK field.
	CCM_ANALOG_MISC0_TOG_OSC_XTALOK_Pos = 0xf
	// Bit mask of OSC_XTALOK field.
	CCM_ANALOG_MISC0_TOG_OSC_XTALOK_Msk = 0x8000
	// Bit OSC_XTALOK.
	CCM_ANALOG_MISC0_TOG_OSC_XTALOK = 0x8000
	// Position of OSC_XTALOK_EN field.
	CCM_ANALOG_MISC0_TOG_OSC_XTALOK_EN_Pos = 0x10
	// Bit mask of OSC_XTALOK_EN field.
	CCM_ANALOG_MISC0_TOG_OSC_XTALOK_EN_Msk = 0x10000
	// Bit OSC_XTALOK_EN.
	CCM_ANALOG_MISC0_TOG_OSC_XTALOK_EN = 0x10000
	// Position of CLKGATE_CTRL field.
	CCM_ANALOG_MISC0_TOG_CLKGATE_CTRL_Pos = 0x19
	// Bit mask of CLKGATE_CTRL field.
	CCM_ANALOG_MISC0_TOG_CLKGATE_CTRL_Msk = 0x2000000
	// Bit CLKGATE_CTRL.
	CCM_ANALOG_MISC0_TOG_CLKGATE_CTRL = 0x2000000
	// Allow the logic to automatically gate the clock when the XTAL is powered down.
	CCM_ANALOG_MISC0_TOG_CLKGATE_CTRL_ALLOW_AUTO_GATE = 0x0
	// Prevent the logic from ever gating off the clock.
	CCM_ANALOG_MISC0_TOG_CLKGATE_CTRL_NO_AUTO_GATE = 0x1
	// Position of CLKGATE_DELAY field.
	CCM_ANALOG_MISC0_TOG_CLKGATE_DELAY_Pos = 0x1a
	// Bit mask of CLKGATE_DELAY field.
	CCM_ANALOG_MISC0_TOG_CLKGATE_DELAY_Msk = 0x1c000000
	// 0.5ms
	CCM_ANALOG_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_0 = 0x0
	// 1.0ms
	CCM_ANALOG_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_1 = 0x1
	// 2.0ms
	CCM_ANALOG_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_2 = 0x2
	// 3.0ms
	CCM_ANALOG_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_3 = 0x3
	// 4.0ms
	CCM_ANALOG_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_4 = 0x4
	// 5.0ms
	CCM_ANALOG_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_5 = 0x5
	// 6.0ms
	CCM_ANALOG_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_6 = 0x6
	// 7.0ms
	CCM_ANALOG_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_7 = 0x7
	// Position of RTC_XTAL_SOURCE field.
	CCM_ANALOG_MISC0_TOG_RTC_XTAL_SOURCE_Pos = 0x1d
	// Bit mask of RTC_XTAL_SOURCE field.
	CCM_ANALOG_MISC0_TOG_RTC_XTAL_SOURCE_Msk = 0x20000000
	// Bit RTC_XTAL_SOURCE.
	CCM_ANALOG_MISC0_TOG_RTC_XTAL_SOURCE = 0x20000000
	// Internal ring oscillator
	CCM_ANALOG_MISC0_TOG_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_0 = 0x0
	// RTC_XTAL
	CCM_ANALOG_MISC0_TOG_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_1 = 0x1
	// Position of XTAL_24M_PWD field.
	CCM_ANALOG_MISC0_TOG_XTAL_24M_PWD_Pos = 0x1e
	// Bit mask of XTAL_24M_PWD field.
	CCM_ANALOG_MISC0_TOG_XTAL_24M_PWD_Msk = 0x40000000
	// Bit XTAL_24M_PWD.
	CCM_ANALOG_MISC0_TOG_XTAL_24M_PWD = 0x40000000

	// MISC1: Miscellaneous Register 1
	// Position of PFD_480_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_PFD_480_AUTOGATE_EN_Pos = 0x10
	// Bit mask of PFD_480_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_PFD_480_AUTOGATE_EN_Msk = 0x10000
	// Bit PFD_480_AUTOGATE_EN.
	CCM_ANALOG_MISC1_PFD_480_AUTOGATE_EN = 0x10000
	// Position of PFD_528_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_PFD_528_AUTOGATE_EN_Pos = 0x11
	// Bit mask of PFD_528_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_PFD_528_AUTOGATE_EN_Msk = 0x20000
	// Bit PFD_528_AUTOGATE_EN.
	CCM_ANALOG_MISC1_PFD_528_AUTOGATE_EN = 0x20000
	// Position of IRQ_TEMPPANIC field.
	CCM_ANALOG_MISC1_IRQ_TEMPPANIC_Pos = 0x1b
	// Bit mask of IRQ_TEMPPANIC field.
	CCM_ANALOG_MISC1_IRQ_TEMPPANIC_Msk = 0x8000000
	// Bit IRQ_TEMPPANIC.
	CCM_ANALOG_MISC1_IRQ_TEMPPANIC = 0x8000000
	// Position of IRQ_TEMPLOW field.
	CCM_ANALOG_MISC1_IRQ_TEMPLOW_Pos = 0x1c
	// Bit mask of IRQ_TEMPLOW field.
	CCM_ANALOG_MISC1_IRQ_TEMPLOW_Msk = 0x10000000
	// Bit IRQ_TEMPLOW.
	CCM_ANALOG_MISC1_IRQ_TEMPLOW = 0x10000000
	// Position of IRQ_TEMPHIGH field.
	CCM_ANALOG_MISC1_IRQ_TEMPHIGH_Pos = 0x1d
	// Bit mask of IRQ_TEMPHIGH field.
	CCM_ANALOG_MISC1_IRQ_TEMPHIGH_Msk = 0x20000000
	// Bit IRQ_TEMPHIGH.
	CCM_ANALOG_MISC1_IRQ_TEMPHIGH = 0x20000000
	// Position of IRQ_ANA_BO field.
	CCM_ANALOG_MISC1_IRQ_ANA_BO_Pos = 0x1e
	// Bit mask of IRQ_ANA_BO field.
	CCM_ANALOG_MISC1_IRQ_ANA_BO_Msk = 0x40000000
	// Bit IRQ_ANA_BO.
	CCM_ANALOG_MISC1_IRQ_ANA_BO = 0x40000000
	// Position of IRQ_DIG_BO field.
	CCM_ANALOG_MISC1_IRQ_DIG_BO_Pos = 0x1f
	// Bit mask of IRQ_DIG_BO field.
	CCM_ANALOG_MISC1_IRQ_DIG_BO_Msk = 0x80000000
	// Bit IRQ_DIG_BO.
	CCM_ANALOG_MISC1_IRQ_DIG_BO = 0x80000000

	// MISC1_SET: Miscellaneous Register 1
	// Position of PFD_480_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_SET_PFD_480_AUTOGATE_EN_Pos = 0x10
	// Bit mask of PFD_480_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_SET_PFD_480_AUTOGATE_EN_Msk = 0x10000
	// Bit PFD_480_AUTOGATE_EN.
	CCM_ANALOG_MISC1_SET_PFD_480_AUTOGATE_EN = 0x10000
	// Position of PFD_528_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_SET_PFD_528_AUTOGATE_EN_Pos = 0x11
	// Bit mask of PFD_528_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_SET_PFD_528_AUTOGATE_EN_Msk = 0x20000
	// Bit PFD_528_AUTOGATE_EN.
	CCM_ANALOG_MISC1_SET_PFD_528_AUTOGATE_EN = 0x20000
	// Position of IRQ_TEMPPANIC field.
	CCM_ANALOG_MISC1_SET_IRQ_TEMPPANIC_Pos = 0x1b
	// Bit mask of IRQ_TEMPPANIC field.
	CCM_ANALOG_MISC1_SET_IRQ_TEMPPANIC_Msk = 0x8000000
	// Bit IRQ_TEMPPANIC.
	CCM_ANALOG_MISC1_SET_IRQ_TEMPPANIC = 0x8000000
	// Position of IRQ_TEMPLOW field.
	CCM_ANALOG_MISC1_SET_IRQ_TEMPLOW_Pos = 0x1c
	// Bit mask of IRQ_TEMPLOW field.
	CCM_ANALOG_MISC1_SET_IRQ_TEMPLOW_Msk = 0x10000000
	// Bit IRQ_TEMPLOW.
	CCM_ANALOG_MISC1_SET_IRQ_TEMPLOW = 0x10000000
	// Position of IRQ_TEMPHIGH field.
	CCM_ANALOG_MISC1_SET_IRQ_TEMPHIGH_Pos = 0x1d
	// Bit mask of IRQ_TEMPHIGH field.
	CCM_ANALOG_MISC1_SET_IRQ_TEMPHIGH_Msk = 0x20000000
	// Bit IRQ_TEMPHIGH.
	CCM_ANALOG_MISC1_SET_IRQ_TEMPHIGH = 0x20000000
	// Position of IRQ_ANA_BO field.
	CCM_ANALOG_MISC1_SET_IRQ_ANA_BO_Pos = 0x1e
	// Bit mask of IRQ_ANA_BO field.
	CCM_ANALOG_MISC1_SET_IRQ_ANA_BO_Msk = 0x40000000
	// Bit IRQ_ANA_BO.
	CCM_ANALOG_MISC1_SET_IRQ_ANA_BO = 0x40000000
	// Position of IRQ_DIG_BO field.
	CCM_ANALOG_MISC1_SET_IRQ_DIG_BO_Pos = 0x1f
	// Bit mask of IRQ_DIG_BO field.
	CCM_ANALOG_MISC1_SET_IRQ_DIG_BO_Msk = 0x80000000
	// Bit IRQ_DIG_BO.
	CCM_ANALOG_MISC1_SET_IRQ_DIG_BO = 0x80000000

	// MISC1_CLR: Miscellaneous Register 1
	// Position of PFD_480_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_CLR_PFD_480_AUTOGATE_EN_Pos = 0x10
	// Bit mask of PFD_480_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_CLR_PFD_480_AUTOGATE_EN_Msk = 0x10000
	// Bit PFD_480_AUTOGATE_EN.
	CCM_ANALOG_MISC1_CLR_PFD_480_AUTOGATE_EN = 0x10000
	// Position of PFD_528_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_CLR_PFD_528_AUTOGATE_EN_Pos = 0x11
	// Bit mask of PFD_528_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_CLR_PFD_528_AUTOGATE_EN_Msk = 0x20000
	// Bit PFD_528_AUTOGATE_EN.
	CCM_ANALOG_MISC1_CLR_PFD_528_AUTOGATE_EN = 0x20000
	// Position of IRQ_TEMPPANIC field.
	CCM_ANALOG_MISC1_CLR_IRQ_TEMPPANIC_Pos = 0x1b
	// Bit mask of IRQ_TEMPPANIC field.
	CCM_ANALOG_MISC1_CLR_IRQ_TEMPPANIC_Msk = 0x8000000
	// Bit IRQ_TEMPPANIC.
	CCM_ANALOG_MISC1_CLR_IRQ_TEMPPANIC = 0x8000000
	// Position of IRQ_TEMPLOW field.
	CCM_ANALOG_MISC1_CLR_IRQ_TEMPLOW_Pos = 0x1c
	// Bit mask of IRQ_TEMPLOW field.
	CCM_ANALOG_MISC1_CLR_IRQ_TEMPLOW_Msk = 0x10000000
	// Bit IRQ_TEMPLOW.
	CCM_ANALOG_MISC1_CLR_IRQ_TEMPLOW = 0x10000000
	// Position of IRQ_TEMPHIGH field.
	CCM_ANALOG_MISC1_CLR_IRQ_TEMPHIGH_Pos = 0x1d
	// Bit mask of IRQ_TEMPHIGH field.
	CCM_ANALOG_MISC1_CLR_IRQ_TEMPHIGH_Msk = 0x20000000
	// Bit IRQ_TEMPHIGH.
	CCM_ANALOG_MISC1_CLR_IRQ_TEMPHIGH = 0x20000000
	// Position of IRQ_ANA_BO field.
	CCM_ANALOG_MISC1_CLR_IRQ_ANA_BO_Pos = 0x1e
	// Bit mask of IRQ_ANA_BO field.
	CCM_ANALOG_MISC1_CLR_IRQ_ANA_BO_Msk = 0x40000000
	// Bit IRQ_ANA_BO.
	CCM_ANALOG_MISC1_CLR_IRQ_ANA_BO = 0x40000000
	// Position of IRQ_DIG_BO field.
	CCM_ANALOG_MISC1_CLR_IRQ_DIG_BO_Pos = 0x1f
	// Bit mask of IRQ_DIG_BO field.
	CCM_ANALOG_MISC1_CLR_IRQ_DIG_BO_Msk = 0x80000000
	// Bit IRQ_DIG_BO.
	CCM_ANALOG_MISC1_CLR_IRQ_DIG_BO = 0x80000000

	// MISC1_TOG: Miscellaneous Register 1
	// Position of PFD_480_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_TOG_PFD_480_AUTOGATE_EN_Pos = 0x10
	// Bit mask of PFD_480_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_TOG_PFD_480_AUTOGATE_EN_Msk = 0x10000
	// Bit PFD_480_AUTOGATE_EN.
	CCM_ANALOG_MISC1_TOG_PFD_480_AUTOGATE_EN = 0x10000
	// Position of PFD_528_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_TOG_PFD_528_AUTOGATE_EN_Pos = 0x11
	// Bit mask of PFD_528_AUTOGATE_EN field.
	CCM_ANALOG_MISC1_TOG_PFD_528_AUTOGATE_EN_Msk = 0x20000
	// Bit PFD_528_AUTOGATE_EN.
	CCM_ANALOG_MISC1_TOG_PFD_528_AUTOGATE_EN = 0x20000
	// Position of IRQ_TEMPPANIC field.
	CCM_ANALOG_MISC1_TOG_IRQ_TEMPPANIC_Pos = 0x1b
	// Bit mask of IRQ_TEMPPANIC field.
	CCM_ANALOG_MISC1_TOG_IRQ_TEMPPANIC_Msk = 0x8000000
	// Bit IRQ_TEMPPANIC.
	CCM_ANALOG_MISC1_TOG_IRQ_TEMPPANIC = 0x8000000
	// Position of IRQ_TEMPLOW field.
	CCM_ANALOG_MISC1_TOG_IRQ_TEMPLOW_Pos = 0x1c
	// Bit mask of IRQ_TEMPLOW field.
	CCM_ANALOG_MISC1_TOG_IRQ_TEMPLOW_Msk = 0x10000000
	// Bit IRQ_TEMPLOW.
	CCM_ANALOG_MISC1_TOG_IRQ_TEMPLOW = 0x10000000
	// Position of IRQ_TEMPHIGH field.
	CCM_ANALOG_MISC1_TOG_IRQ_TEMPHIGH_Pos = 0x1d
	// Bit mask of IRQ_TEMPHIGH field.
	CCM_ANALOG_MISC1_TOG_IRQ_TEMPHIGH_Msk = 0x20000000
	// Bit IRQ_TEMPHIGH.
	CCM_ANALOG_MISC1_TOG_IRQ_TEMPHIGH = 0x20000000
	// Position of IRQ_ANA_BO field.
	CCM_ANALOG_MISC1_TOG_IRQ_ANA_BO_Pos = 0x1e
	// Bit mask of IRQ_ANA_BO field.
	CCM_ANALOG_MISC1_TOG_IRQ_ANA_BO_Msk = 0x40000000
	// Bit IRQ_ANA_BO.
	CCM_ANALOG_MISC1_TOG_IRQ_ANA_BO = 0x40000000
	// Position of IRQ_DIG_BO field.
	CCM_ANALOG_MISC1_TOG_IRQ_DIG_BO_Pos = 0x1f
	// Bit mask of IRQ_DIG_BO field.
	CCM_ANALOG_MISC1_TOG_IRQ_DIG_BO_Msk = 0x80000000
	// Bit IRQ_DIG_BO.
	CCM_ANALOG_MISC1_TOG_IRQ_DIG_BO = 0x80000000

	// MISC2: Miscellaneous Register 2
	// Position of REG0_BO_OFFSET field.
	CCM_ANALOG_MISC2_REG0_BO_OFFSET_Pos = 0x0
	// Bit mask of REG0_BO_OFFSET field.
	CCM_ANALOG_MISC2_REG0_BO_OFFSET_Msk = 0x7
	// Brownout offset = 0.100V
	CCM_ANALOG_MISC2_REG0_BO_OFFSET_REG0_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	CCM_ANALOG_MISC2_REG0_BO_OFFSET_REG0_BO_OFFSET_7 = 0x7
	// Position of REG0_BO_STATUS field.
	CCM_ANALOG_MISC2_REG0_BO_STATUS_Pos = 0x3
	// Bit mask of REG0_BO_STATUS field.
	CCM_ANALOG_MISC2_REG0_BO_STATUS_Msk = 0x8
	// Bit REG0_BO_STATUS.
	CCM_ANALOG_MISC2_REG0_BO_STATUS = 0x8
	// Brownout, supply is below target minus brownout offset.
	CCM_ANALOG_MISC2_REG0_BO_STATUS_REG0_BO_STATUS_1 = 0x1
	// Position of REG0_ENABLE_BO field.
	CCM_ANALOG_MISC2_REG0_ENABLE_BO_Pos = 0x5
	// Bit mask of REG0_ENABLE_BO field.
	CCM_ANALOG_MISC2_REG0_ENABLE_BO_Msk = 0x20
	// Bit REG0_ENABLE_BO.
	CCM_ANALOG_MISC2_REG0_ENABLE_BO = 0x20
	// Position of REG0_OK field.
	CCM_ANALOG_MISC2_REG0_OK_Pos = 0x6
	// Bit mask of REG0_OK field.
	CCM_ANALOG_MISC2_REG0_OK_Msk = 0x40
	// Bit REG0_OK.
	CCM_ANALOG_MISC2_REG0_OK = 0x40
	// Position of PLL3_DISABLE field.
	CCM_ANALOG_MISC2_PLL3_DISABLE_Pos = 0x7
	// Bit mask of PLL3_DISABLE field.
	CCM_ANALOG_MISC2_PLL3_DISABLE_Msk = 0x80
	// Bit PLL3_DISABLE.
	CCM_ANALOG_MISC2_PLL3_DISABLE = 0x80
	// PLL3 is being used by peripherals and is enabled when SoC is not in any low power mode
	CCM_ANALOG_MISC2_PLL3_DISABLE_PLL3_DISABLE_0 = 0x0
	// PLL3 can be disabled when the SoC is not in any low power mode
	CCM_ANALOG_MISC2_PLL3_DISABLE_PLL3_DISABLE_1 = 0x1
	// Position of REG1_BO_OFFSET field.
	CCM_ANALOG_MISC2_REG1_BO_OFFSET_Pos = 0x8
	// Bit mask of REG1_BO_OFFSET field.
	CCM_ANALOG_MISC2_REG1_BO_OFFSET_Msk = 0x700
	// Brownout offset = 0.100V
	CCM_ANALOG_MISC2_REG1_BO_OFFSET_REG1_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	CCM_ANALOG_MISC2_REG1_BO_OFFSET_REG1_BO_OFFSET_7 = 0x7
	// Position of REG1_BO_STATUS field.
	CCM_ANALOG_MISC2_REG1_BO_STATUS_Pos = 0xb
	// Bit mask of REG1_BO_STATUS field.
	CCM_ANALOG_MISC2_REG1_BO_STATUS_Msk = 0x800
	// Bit REG1_BO_STATUS.
	CCM_ANALOG_MISC2_REG1_BO_STATUS = 0x800
	// Brownout, supply is below target minus brownout offset.
	CCM_ANALOG_MISC2_REG1_BO_STATUS_REG1_BO_STATUS_1 = 0x1
	// Position of REG1_ENABLE_BO field.
	CCM_ANALOG_MISC2_REG1_ENABLE_BO_Pos = 0xd
	// Bit mask of REG1_ENABLE_BO field.
	CCM_ANALOG_MISC2_REG1_ENABLE_BO_Msk = 0x2000
	// Bit REG1_ENABLE_BO.
	CCM_ANALOG_MISC2_REG1_ENABLE_BO = 0x2000
	// Position of REG1_OK field.
	CCM_ANALOG_MISC2_REG1_OK_Pos = 0xe
	// Bit mask of REG1_OK field.
	CCM_ANALOG_MISC2_REG1_OK_Msk = 0x4000
	// Bit REG1_OK.
	CCM_ANALOG_MISC2_REG1_OK = 0x4000
	// Position of AUDIO_DIV_LSB field.
	CCM_ANALOG_MISC2_AUDIO_DIV_LSB_Pos = 0xf
	// Bit mask of AUDIO_DIV_LSB field.
	CCM_ANALOG_MISC2_AUDIO_DIV_LSB_Msk = 0x8000
	// Bit AUDIO_DIV_LSB.
	CCM_ANALOG_MISC2_AUDIO_DIV_LSB = 0x8000
	// divide by 1 (Default)
	CCM_ANALOG_MISC2_AUDIO_DIV_LSB_AUDIO_DIV_LSB_0 = 0x0
	// divide by 2
	CCM_ANALOG_MISC2_AUDIO_DIV_LSB_AUDIO_DIV_LSB_1 = 0x1
	// Position of REG2_BO_OFFSET field.
	CCM_ANALOG_MISC2_REG2_BO_OFFSET_Pos = 0x10
	// Bit mask of REG2_BO_OFFSET field.
	CCM_ANALOG_MISC2_REG2_BO_OFFSET_Msk = 0x70000
	// Brownout offset = 0.100V
	CCM_ANALOG_MISC2_REG2_BO_OFFSET_REG2_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	CCM_ANALOG_MISC2_REG2_BO_OFFSET_REG2_BO_OFFSET_7 = 0x7
	// Position of REG2_BO_STATUS field.
	CCM_ANALOG_MISC2_REG2_BO_STATUS_Pos = 0x13
	// Bit mask of REG2_BO_STATUS field.
	CCM_ANALOG_MISC2_REG2_BO_STATUS_Msk = 0x80000
	// Bit REG2_BO_STATUS.
	CCM_ANALOG_MISC2_REG2_BO_STATUS = 0x80000
	// Position of REG2_ENABLE_BO field.
	CCM_ANALOG_MISC2_REG2_ENABLE_BO_Pos = 0x15
	// Bit mask of REG2_ENABLE_BO field.
	CCM_ANALOG_MISC2_REG2_ENABLE_BO_Msk = 0x200000
	// Bit REG2_ENABLE_BO.
	CCM_ANALOG_MISC2_REG2_ENABLE_BO = 0x200000
	// Position of REG2_OK field.
	CCM_ANALOG_MISC2_REG2_OK_Pos = 0x16
	// Bit mask of REG2_OK field.
	CCM_ANALOG_MISC2_REG2_OK_Msk = 0x400000
	// Bit REG2_OK.
	CCM_ANALOG_MISC2_REG2_OK = 0x400000
	// Position of AUDIO_DIV_MSB field.
	CCM_ANALOG_MISC2_AUDIO_DIV_MSB_Pos = 0x17
	// Bit mask of AUDIO_DIV_MSB field.
	CCM_ANALOG_MISC2_AUDIO_DIV_MSB_Msk = 0x800000
	// Bit AUDIO_DIV_MSB.
	CCM_ANALOG_MISC2_AUDIO_DIV_MSB = 0x800000
	// divide by 1 (Default)
	CCM_ANALOG_MISC2_AUDIO_DIV_MSB_AUDIO_DIV_MSB_0 = 0x0
	// divide by 2
	CCM_ANALOG_MISC2_AUDIO_DIV_MSB_AUDIO_DIV_MSB_1 = 0x1
	// Position of REG0_STEP_TIME field.
	CCM_ANALOG_MISC2_REG0_STEP_TIME_Pos = 0x18
	// Bit mask of REG0_STEP_TIME field.
	CCM_ANALOG_MISC2_REG0_STEP_TIME_Msk = 0x3000000
	// 64
	CCM_ANALOG_MISC2_REG0_STEP_TIME_64_CLOCKS = 0x0
	// 128
	CCM_ANALOG_MISC2_REG0_STEP_TIME_128_CLOCKS = 0x1
	// 256
	CCM_ANALOG_MISC2_REG0_STEP_TIME_256_CLOCKS = 0x2
	// 512
	CCM_ANALOG_MISC2_REG0_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG1_STEP_TIME field.
	CCM_ANALOG_MISC2_REG1_STEP_TIME_Pos = 0x1a
	// Bit mask of REG1_STEP_TIME field.
	CCM_ANALOG_MISC2_REG1_STEP_TIME_Msk = 0xc000000
	// 64
	CCM_ANALOG_MISC2_REG1_STEP_TIME_64_CLOCKS = 0x0
	// 128
	CCM_ANALOG_MISC2_REG1_STEP_TIME_128_CLOCKS = 0x1
	// 256
	CCM_ANALOG_MISC2_REG1_STEP_TIME_256_CLOCKS = 0x2
	// 512
	CCM_ANALOG_MISC2_REG1_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG2_STEP_TIME field.
	CCM_ANALOG_MISC2_REG2_STEP_TIME_Pos = 0x1c
	// Bit mask of REG2_STEP_TIME field.
	CCM_ANALOG_MISC2_REG2_STEP_TIME_Msk = 0x30000000
	// 64
	CCM_ANALOG_MISC2_REG2_STEP_TIME_64_CLOCKS = 0x0
	// 128
	CCM_ANALOG_MISC2_REG2_STEP_TIME_128_CLOCKS = 0x1
	// 256
	CCM_ANALOG_MISC2_REG2_STEP_TIME_256_CLOCKS = 0x2
	// 512
	CCM_ANALOG_MISC2_REG2_STEP_TIME_512_CLOCKS = 0x3

	// MISC2_SET: Miscellaneous Register 2
	// Position of REG0_BO_OFFSET field.
	CCM_ANALOG_MISC2_SET_REG0_BO_OFFSET_Pos = 0x0
	// Bit mask of REG0_BO_OFFSET field.
	CCM_ANALOG_MISC2_SET_REG0_BO_OFFSET_Msk = 0x7
	// Brownout offset = 0.100V
	CCM_ANALOG_MISC2_SET_REG0_BO_OFFSET_REG0_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	CCM_ANALOG_MISC2_SET_REG0_BO_OFFSET_REG0_BO_OFFSET_7 = 0x7
	// Position of REG0_BO_STATUS field.
	CCM_ANALOG_MISC2_SET_REG0_BO_STATUS_Pos = 0x3
	// Bit mask of REG0_BO_STATUS field.
	CCM_ANALOG_MISC2_SET_REG0_BO_STATUS_Msk = 0x8
	// Bit REG0_BO_STATUS.
	CCM_ANALOG_MISC2_SET_REG0_BO_STATUS = 0x8
	// Brownout, supply is below target minus brownout offset.
	CCM_ANALOG_MISC2_SET_REG0_BO_STATUS_REG0_BO_STATUS_1 = 0x1
	// Position of REG0_ENABLE_BO field.
	CCM_ANALOG_MISC2_SET_REG0_ENABLE_BO_Pos = 0x5
	// Bit mask of REG0_ENABLE_BO field.
	CCM_ANALOG_MISC2_SET_REG0_ENABLE_BO_Msk = 0x20
	// Bit REG0_ENABLE_BO.
	CCM_ANALOG_MISC2_SET_REG0_ENABLE_BO = 0x20
	// Position of REG0_OK field.
	CCM_ANALOG_MISC2_SET_REG0_OK_Pos = 0x6
	// Bit mask of REG0_OK field.
	CCM_ANALOG_MISC2_SET_REG0_OK_Msk = 0x40
	// Bit REG0_OK.
	CCM_ANALOG_MISC2_SET_REG0_OK = 0x40
	// Position of PLL3_DISABLE field.
	CCM_ANALOG_MISC2_SET_PLL3_DISABLE_Pos = 0x7
	// Bit mask of PLL3_DISABLE field.
	CCM_ANALOG_MISC2_SET_PLL3_DISABLE_Msk = 0x80
	// Bit PLL3_DISABLE.
	CCM_ANALOG_MISC2_SET_PLL3_DISABLE = 0x80
	// PLL3 is being used by peripherals and is enabled when SoC is not in any low power mode
	CCM_ANALOG_MISC2_SET_PLL3_DISABLE_PLL3_DISABLE_0 = 0x0
	// PLL3 can be disabled when the SoC is not in any low power mode
	CCM_ANALOG_MISC2_SET_PLL3_DISABLE_PLL3_DISABLE_1 = 0x1
	// Position of REG1_BO_OFFSET field.
	CCM_ANALOG_MISC2_SET_REG1_BO_OFFSET_Pos = 0x8
	// Bit mask of REG1_BO_OFFSET field.
	CCM_ANALOG_MISC2_SET_REG1_BO_OFFSET_Msk = 0x700
	// Brownout offset = 0.100V
	CCM_ANALOG_MISC2_SET_REG1_BO_OFFSET_REG1_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	CCM_ANALOG_MISC2_SET_REG1_BO_OFFSET_REG1_BO_OFFSET_7 = 0x7
	// Position of REG1_BO_STATUS field.
	CCM_ANALOG_MISC2_SET_REG1_BO_STATUS_Pos = 0xb
	// Bit mask of REG1_BO_STATUS field.
	CCM_ANALOG_MISC2_SET_REG1_BO_STATUS_Msk = 0x800
	// Bit REG1_BO_STATUS.
	CCM_ANALOG_MISC2_SET_REG1_BO_STATUS = 0x800
	// Brownout, supply is below target minus brownout offset.
	CCM_ANALOG_MISC2_SET_REG1_BO_STATUS_REG1_BO_STATUS_1 = 0x1
	// Position of REG1_ENABLE_BO field.
	CCM_ANALOG_MISC2_SET_REG1_ENABLE_BO_Pos = 0xd
	// Bit mask of REG1_ENABLE_BO field.
	CCM_ANALOG_MISC2_SET_REG1_ENABLE_BO_Msk = 0x2000
	// Bit REG1_ENABLE_BO.
	CCM_ANALOG_MISC2_SET_REG1_ENABLE_BO = 0x2000
	// Position of REG1_OK field.
	CCM_ANALOG_MISC2_SET_REG1_OK_Pos = 0xe
	// Bit mask of REG1_OK field.
	CCM_ANALOG_MISC2_SET_REG1_OK_Msk = 0x4000
	// Bit REG1_OK.
	CCM_ANALOG_MISC2_SET_REG1_OK = 0x4000
	// Position of AUDIO_DIV_LSB field.
	CCM_ANALOG_MISC2_SET_AUDIO_DIV_LSB_Pos = 0xf
	// Bit mask of AUDIO_DIV_LSB field.
	CCM_ANALOG_MISC2_SET_AUDIO_DIV_LSB_Msk = 0x8000
	// Bit AUDIO_DIV_LSB.
	CCM_ANALOG_MISC2_SET_AUDIO_DIV_LSB = 0x8000
	// divide by 1 (Default)
	CCM_ANALOG_MISC2_SET_AUDIO_DIV_LSB_AUDIO_DIV_LSB_0 = 0x0
	// divide by 2
	CCM_ANALOG_MISC2_SET_AUDIO_DIV_LSB_AUDIO_DIV_LSB_1 = 0x1
	// Position of REG2_BO_OFFSET field.
	CCM_ANALOG_MISC2_SET_REG2_BO_OFFSET_Pos = 0x10
	// Bit mask of REG2_BO_OFFSET field.
	CCM_ANALOG_MISC2_SET_REG2_BO_OFFSET_Msk = 0x70000
	// Brownout offset = 0.100V
	CCM_ANALOG_MISC2_SET_REG2_BO_OFFSET_REG2_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	CCM_ANALOG_MISC2_SET_REG2_BO_OFFSET_REG2_BO_OFFSET_7 = 0x7
	// Position of REG2_BO_STATUS field.
	CCM_ANALOG_MISC2_SET_REG2_BO_STATUS_Pos = 0x13
	// Bit mask of REG2_BO_STATUS field.
	CCM_ANALOG_MISC2_SET_REG2_BO_STATUS_Msk = 0x80000
	// Bit REG2_BO_STATUS.
	CCM_ANALOG_MISC2_SET_REG2_BO_STATUS = 0x80000
	// Position of REG2_ENABLE_BO field.
	CCM_ANALOG_MISC2_SET_REG2_ENABLE_BO_Pos = 0x15
	// Bit mask of REG2_ENABLE_BO field.
	CCM_ANALOG_MISC2_SET_REG2_ENABLE_BO_Msk = 0x200000
	// Bit REG2_ENABLE_BO.
	CCM_ANALOG_MISC2_SET_REG2_ENABLE_BO = 0x200000
	// Position of REG2_OK field.
	CCM_ANALOG_MISC2_SET_REG2_OK_Pos = 0x16
	// Bit mask of REG2_OK field.
	CCM_ANALOG_MISC2_SET_REG2_OK_Msk = 0x400000
	// Bit REG2_OK.
	CCM_ANALOG_MISC2_SET_REG2_OK = 0x400000
	// Position of AUDIO_DIV_MSB field.
	CCM_ANALOG_MISC2_SET_AUDIO_DIV_MSB_Pos = 0x17
	// Bit mask of AUDIO_DIV_MSB field.
	CCM_ANALOG_MISC2_SET_AUDIO_DIV_MSB_Msk = 0x800000
	// Bit AUDIO_DIV_MSB.
	CCM_ANALOG_MISC2_SET_AUDIO_DIV_MSB = 0x800000
	// divide by 1 (Default)
	CCM_ANALOG_MISC2_SET_AUDIO_DIV_MSB_AUDIO_DIV_MSB_0 = 0x0
	// divide by 2
	CCM_ANALOG_MISC2_SET_AUDIO_DIV_MSB_AUDIO_DIV_MSB_1 = 0x1
	// Position of REG0_STEP_TIME field.
	CCM_ANALOG_MISC2_SET_REG0_STEP_TIME_Pos = 0x18
	// Bit mask of REG0_STEP_TIME field.
	CCM_ANALOG_MISC2_SET_REG0_STEP_TIME_Msk = 0x3000000
	// 64
	CCM_ANALOG_MISC2_SET_REG0_STEP_TIME_64_CLOCKS = 0x0
	// 128
	CCM_ANALOG_MISC2_SET_REG0_STEP_TIME_128_CLOCKS = 0x1
	// 256
	CCM_ANALOG_MISC2_SET_REG0_STEP_TIME_256_CLOCKS = 0x2
	// 512
	CCM_ANALOG_MISC2_SET_REG0_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG1_STEP_TIME field.
	CCM_ANALOG_MISC2_SET_REG1_STEP_TIME_Pos = 0x1a
	// Bit mask of REG1_STEP_TIME field.
	CCM_ANALOG_MISC2_SET_REG1_STEP_TIME_Msk = 0xc000000
	// 64
	CCM_ANALOG_MISC2_SET_REG1_STEP_TIME_64_CLOCKS = 0x0
	// 128
	CCM_ANALOG_MISC2_SET_REG1_STEP_TIME_128_CLOCKS = 0x1
	// 256
	CCM_ANALOG_MISC2_SET_REG1_STEP_TIME_256_CLOCKS = 0x2
	// 512
	CCM_ANALOG_MISC2_SET_REG1_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG2_STEP_TIME field.
	CCM_ANALOG_MISC2_SET_REG2_STEP_TIME_Pos = 0x1c
	// Bit mask of REG2_STEP_TIME field.
	CCM_ANALOG_MISC2_SET_REG2_STEP_TIME_Msk = 0x30000000
	// 64
	CCM_ANALOG_MISC2_SET_REG2_STEP_TIME_64_CLOCKS = 0x0
	// 128
	CCM_ANALOG_MISC2_SET_REG2_STEP_TIME_128_CLOCKS = 0x1
	// 256
	CCM_ANALOG_MISC2_SET_REG2_STEP_TIME_256_CLOCKS = 0x2
	// 512
	CCM_ANALOG_MISC2_SET_REG2_STEP_TIME_512_CLOCKS = 0x3

	// MISC2_CLR: Miscellaneous Register 2
	// Position of REG0_BO_OFFSET field.
	CCM_ANALOG_MISC2_CLR_REG0_BO_OFFSET_Pos = 0x0
	// Bit mask of REG0_BO_OFFSET field.
	CCM_ANALOG_MISC2_CLR_REG0_BO_OFFSET_Msk = 0x7
	// Brownout offset = 0.100V
	CCM_ANALOG_MISC2_CLR_REG0_BO_OFFSET_REG0_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	CCM_ANALOG_MISC2_CLR_REG0_BO_OFFSET_REG0_BO_OFFSET_7 = 0x7
	// Position of REG0_BO_STATUS field.
	CCM_ANALOG_MISC2_CLR_REG0_BO_STATUS_Pos = 0x3
	// Bit mask of REG0_BO_STATUS field.
	CCM_ANALOG_MISC2_CLR_REG0_BO_STATUS_Msk = 0x8
	// Bit REG0_BO_STATUS.
	CCM_ANALOG_MISC2_CLR_REG0_BO_STATUS = 0x8
	// Brownout, supply is below target minus brownout offset.
	CCM_ANALOG_MISC2_CLR_REG0_BO_STATUS_REG0_BO_STATUS_1 = 0x1
	// Position of REG0_ENABLE_BO field.
	CCM_ANALOG_MISC2_CLR_REG0_ENABLE_BO_Pos = 0x5
	// Bit mask of REG0_ENABLE_BO field.
	CCM_ANALOG_MISC2_CLR_REG0_ENABLE_BO_Msk = 0x20
	// Bit REG0_ENABLE_BO.
	CCM_ANALOG_MISC2_CLR_REG0_ENABLE_BO = 0x20
	// Position of REG0_OK field.
	CCM_ANALOG_MISC2_CLR_REG0_OK_Pos = 0x6
	// Bit mask of REG0_OK field.
	CCM_ANALOG_MISC2_CLR_REG0_OK_Msk = 0x40
	// Bit REG0_OK.
	CCM_ANALOG_MISC2_CLR_REG0_OK = 0x40
	// Position of PLL3_DISABLE field.
	CCM_ANALOG_MISC2_CLR_PLL3_DISABLE_Pos = 0x7
	// Bit mask of PLL3_DISABLE field.
	CCM_ANALOG_MISC2_CLR_PLL3_DISABLE_Msk = 0x80
	// Bit PLL3_DISABLE.
	CCM_ANALOG_MISC2_CLR_PLL3_DISABLE = 0x80
	// PLL3 is being used by peripherals and is enabled when SoC is not in any low power mode
	CCM_ANALOG_MISC2_CLR_PLL3_DISABLE_PLL3_DISABLE_0 = 0x0
	// PLL3 can be disabled when the SoC is not in any low power mode
	CCM_ANALOG_MISC2_CLR_PLL3_DISABLE_PLL3_DISABLE_1 = 0x1
	// Position of REG1_BO_OFFSET field.
	CCM_ANALOG_MISC2_CLR_REG1_BO_OFFSET_Pos = 0x8
	// Bit mask of REG1_BO_OFFSET field.
	CCM_ANALOG_MISC2_CLR_REG1_BO_OFFSET_Msk = 0x700
	// Brownout offset = 0.100V
	CCM_ANALOG_MISC2_CLR_REG1_BO_OFFSET_REG1_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	CCM_ANALOG_MISC2_CLR_REG1_BO_OFFSET_REG1_BO_OFFSET_7 = 0x7
	// Position of REG1_BO_STATUS field.
	CCM_ANALOG_MISC2_CLR_REG1_BO_STATUS_Pos = 0xb
	// Bit mask of REG1_BO_STATUS field.
	CCM_ANALOG_MISC2_CLR_REG1_BO_STATUS_Msk = 0x800
	// Bit REG1_BO_STATUS.
	CCM_ANALOG_MISC2_CLR_REG1_BO_STATUS = 0x800
	// Brownout, supply is below target minus brownout offset.
	CCM_ANALOG_MISC2_CLR_REG1_BO_STATUS_REG1_BO_STATUS_1 = 0x1
	// Position of REG1_ENABLE_BO field.
	CCM_ANALOG_MISC2_CLR_REG1_ENABLE_BO_Pos = 0xd
	// Bit mask of REG1_ENABLE_BO field.
	CCM_ANALOG_MISC2_CLR_REG1_ENABLE_BO_Msk = 0x2000
	// Bit REG1_ENABLE_BO.
	CCM_ANALOG_MISC2_CLR_REG1_ENABLE_BO = 0x2000
	// Position of REG1_OK field.
	CCM_ANALOG_MISC2_CLR_REG1_OK_Pos = 0xe
	// Bit mask of REG1_OK field.
	CCM_ANALOG_MISC2_CLR_REG1_OK_Msk = 0x4000
	// Bit REG1_OK.
	CCM_ANALOG_MISC2_CLR_REG1_OK = 0x4000
	// Position of AUDIO_DIV_LSB field.
	CCM_ANALOG_MISC2_CLR_AUDIO_DIV_LSB_Pos = 0xf
	// Bit mask of AUDIO_DIV_LSB field.
	CCM_ANALOG_MISC2_CLR_AUDIO_DIV_LSB_Msk = 0x8000
	// Bit AUDIO_DIV_LSB.
	CCM_ANALOG_MISC2_CLR_AUDIO_DIV_LSB = 0x8000
	// divide by 1 (Default)
	CCM_ANALOG_MISC2_CLR_AUDIO_DIV_LSB_AUDIO_DIV_LSB_0 = 0x0
	// divide by 2
	CCM_ANALOG_MISC2_CLR_AUDIO_DIV_LSB_AUDIO_DIV_LSB_1 = 0x1
	// Position of REG2_BO_OFFSET field.
	CCM_ANALOG_MISC2_CLR_REG2_BO_OFFSET_Pos = 0x10
	// Bit mask of REG2_BO_OFFSET field.
	CCM_ANALOG_MISC2_CLR_REG2_BO_OFFSET_Msk = 0x70000
	// Brownout offset = 0.100V
	CCM_ANALOG_MISC2_CLR_REG2_BO_OFFSET_REG2_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	CCM_ANALOG_MISC2_CLR_REG2_BO_OFFSET_REG2_BO_OFFSET_7 = 0x7
	// Position of REG2_BO_STATUS field.
	CCM_ANALOG_MISC2_CLR_REG2_BO_STATUS_Pos = 0x13
	// Bit mask of REG2_BO_STATUS field.
	CCM_ANALOG_MISC2_CLR_REG2_BO_STATUS_Msk = 0x80000
	// Bit REG2_BO_STATUS.
	CCM_ANALOG_MISC2_CLR_REG2_BO_STATUS = 0x80000
	// Position of REG2_ENABLE_BO field.
	CCM_ANALOG_MISC2_CLR_REG2_ENABLE_BO_Pos = 0x15
	// Bit mask of REG2_ENABLE_BO field.
	CCM_ANALOG_MISC2_CLR_REG2_ENABLE_BO_Msk = 0x200000
	// Bit REG2_ENABLE_BO.
	CCM_ANALOG_MISC2_CLR_REG2_ENABLE_BO = 0x200000
	// Position of REG2_OK field.
	CCM_ANALOG_MISC2_CLR_REG2_OK_Pos = 0x16
	// Bit mask of REG2_OK field.
	CCM_ANALOG_MISC2_CLR_REG2_OK_Msk = 0x400000
	// Bit REG2_OK.
	CCM_ANALOG_MISC2_CLR_REG2_OK = 0x400000
	// Position of AUDIO_DIV_MSB field.
	CCM_ANALOG_MISC2_CLR_AUDIO_DIV_MSB_Pos = 0x17
	// Bit mask of AUDIO_DIV_MSB field.
	CCM_ANALOG_MISC2_CLR_AUDIO_DIV_MSB_Msk = 0x800000
	// Bit AUDIO_DIV_MSB.
	CCM_ANALOG_MISC2_CLR_AUDIO_DIV_MSB = 0x800000
	// divide by 1 (Default)
	CCM_ANALOG_MISC2_CLR_AUDIO_DIV_MSB_AUDIO_DIV_MSB_0 = 0x0
	// divide by 2
	CCM_ANALOG_MISC2_CLR_AUDIO_DIV_MSB_AUDIO_DIV_MSB_1 = 0x1
	// Position of REG0_STEP_TIME field.
	CCM_ANALOG_MISC2_CLR_REG0_STEP_TIME_Pos = 0x18
	// Bit mask of REG0_STEP_TIME field.
	CCM_ANALOG_MISC2_CLR_REG0_STEP_TIME_Msk = 0x3000000
	// 64
	CCM_ANALOG_MISC2_CLR_REG0_STEP_TIME_64_CLOCKS = 0x0
	// 128
	CCM_ANALOG_MISC2_CLR_REG0_STEP_TIME_128_CLOCKS = 0x1
	// 256
	CCM_ANALOG_MISC2_CLR_REG0_STEP_TIME_256_CLOCKS = 0x2
	// 512
	CCM_ANALOG_MISC2_CLR_REG0_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG1_STEP_TIME field.
	CCM_ANALOG_MISC2_CLR_REG1_STEP_TIME_Pos = 0x1a
	// Bit mask of REG1_STEP_TIME field.
	CCM_ANALOG_MISC2_CLR_REG1_STEP_TIME_Msk = 0xc000000
	// 64
	CCM_ANALOG_MISC2_CLR_REG1_STEP_TIME_64_CLOCKS = 0x0
	// 128
	CCM_ANALOG_MISC2_CLR_REG1_STEP_TIME_128_CLOCKS = 0x1
	// 256
	CCM_ANALOG_MISC2_CLR_REG1_STEP_TIME_256_CLOCKS = 0x2
	// 512
	CCM_ANALOG_MISC2_CLR_REG1_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG2_STEP_TIME field.
	CCM_ANALOG_MISC2_CLR_REG2_STEP_TIME_Pos = 0x1c
	// Bit mask of REG2_STEP_TIME field.
	CCM_ANALOG_MISC2_CLR_REG2_STEP_TIME_Msk = 0x30000000
	// 64
	CCM_ANALOG_MISC2_CLR_REG2_STEP_TIME_64_CLOCKS = 0x0
	// 128
	CCM_ANALOG_MISC2_CLR_REG2_STEP_TIME_128_CLOCKS = 0x1
	// 256
	CCM_ANALOG_MISC2_CLR_REG2_STEP_TIME_256_CLOCKS = 0x2
	// 512
	CCM_ANALOG_MISC2_CLR_REG2_STEP_TIME_512_CLOCKS = 0x3

	// MISC2_TOG: Miscellaneous Register 2
	// Position of REG0_BO_OFFSET field.
	CCM_ANALOG_MISC2_TOG_REG0_BO_OFFSET_Pos = 0x0
	// Bit mask of REG0_BO_OFFSET field.
	CCM_ANALOG_MISC2_TOG_REG0_BO_OFFSET_Msk = 0x7
	// Brownout offset = 0.100V
	CCM_ANALOG_MISC2_TOG_REG0_BO_OFFSET_REG0_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	CCM_ANALOG_MISC2_TOG_REG0_BO_OFFSET_REG0_BO_OFFSET_7 = 0x7
	// Position of REG0_BO_STATUS field.
	CCM_ANALOG_MISC2_TOG_REG0_BO_STATUS_Pos = 0x3
	// Bit mask of REG0_BO_STATUS field.
	CCM_ANALOG_MISC2_TOG_REG0_BO_STATUS_Msk = 0x8
	// Bit REG0_BO_STATUS.
	CCM_ANALOG_MISC2_TOG_REG0_BO_STATUS = 0x8
	// Brownout, supply is below target minus brownout offset.
	CCM_ANALOG_MISC2_TOG_REG0_BO_STATUS_REG0_BO_STATUS_1 = 0x1
	// Position of REG0_ENABLE_BO field.
	CCM_ANALOG_MISC2_TOG_REG0_ENABLE_BO_Pos = 0x5
	// Bit mask of REG0_ENABLE_BO field.
	CCM_ANALOG_MISC2_TOG_REG0_ENABLE_BO_Msk = 0x20
	// Bit REG0_ENABLE_BO.
	CCM_ANALOG_MISC2_TOG_REG0_ENABLE_BO = 0x20
	// Position of REG0_OK field.
	CCM_ANALOG_MISC2_TOG_REG0_OK_Pos = 0x6
	// Bit mask of REG0_OK field.
	CCM_ANALOG_MISC2_TOG_REG0_OK_Msk = 0x40
	// Bit REG0_OK.
	CCM_ANALOG_MISC2_TOG_REG0_OK = 0x40
	// Position of PLL3_DISABLE field.
	CCM_ANALOG_MISC2_TOG_PLL3_DISABLE_Pos = 0x7
	// Bit mask of PLL3_DISABLE field.
	CCM_ANALOG_MISC2_TOG_PLL3_DISABLE_Msk = 0x80
	// Bit PLL3_DISABLE.
	CCM_ANALOG_MISC2_TOG_PLL3_DISABLE = 0x80
	// PLL3 is being used by peripherals and is enabled when SoC is not in any low power mode
	CCM_ANALOG_MISC2_TOG_PLL3_DISABLE_PLL3_DISABLE_0 = 0x0
	// PLL3 can be disabled when the SoC is not in any low power mode
	CCM_ANALOG_MISC2_TOG_PLL3_DISABLE_PLL3_DISABLE_1 = 0x1
	// Position of REG1_BO_OFFSET field.
	CCM_ANALOG_MISC2_TOG_REG1_BO_OFFSET_Pos = 0x8
	// Bit mask of REG1_BO_OFFSET field.
	CCM_ANALOG_MISC2_TOG_REG1_BO_OFFSET_Msk = 0x700
	// Brownout offset = 0.100V
	CCM_ANALOG_MISC2_TOG_REG1_BO_OFFSET_REG1_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	CCM_ANALOG_MISC2_TOG_REG1_BO_OFFSET_REG1_BO_OFFSET_7 = 0x7
	// Position of REG1_BO_STATUS field.
	CCM_ANALOG_MISC2_TOG_REG1_BO_STATUS_Pos = 0xb
	// Bit mask of REG1_BO_STATUS field.
	CCM_ANALOG_MISC2_TOG_REG1_BO_STATUS_Msk = 0x800
	// Bit REG1_BO_STATUS.
	CCM_ANALOG_MISC2_TOG_REG1_BO_STATUS = 0x800
	// Brownout, supply is below target minus brownout offset.
	CCM_ANALOG_MISC2_TOG_REG1_BO_STATUS_REG1_BO_STATUS_1 = 0x1
	// Position of REG1_ENABLE_BO field.
	CCM_ANALOG_MISC2_TOG_REG1_ENABLE_BO_Pos = 0xd
	// Bit mask of REG1_ENABLE_BO field.
	CCM_ANALOG_MISC2_TOG_REG1_ENABLE_BO_Msk = 0x2000
	// Bit REG1_ENABLE_BO.
	CCM_ANALOG_MISC2_TOG_REG1_ENABLE_BO = 0x2000
	// Position of REG1_OK field.
	CCM_ANALOG_MISC2_TOG_REG1_OK_Pos = 0xe
	// Bit mask of REG1_OK field.
	CCM_ANALOG_MISC2_TOG_REG1_OK_Msk = 0x4000
	// Bit REG1_OK.
	CCM_ANALOG_MISC2_TOG_REG1_OK = 0x4000
	// Position of AUDIO_DIV_LSB field.
	CCM_ANALOG_MISC2_TOG_AUDIO_DIV_LSB_Pos = 0xf
	// Bit mask of AUDIO_DIV_LSB field.
	CCM_ANALOG_MISC2_TOG_AUDIO_DIV_LSB_Msk = 0x8000
	// Bit AUDIO_DIV_LSB.
	CCM_ANALOG_MISC2_TOG_AUDIO_DIV_LSB = 0x8000
	// divide by 1 (Default)
	CCM_ANALOG_MISC2_TOG_AUDIO_DIV_LSB_AUDIO_DIV_LSB_0 = 0x0
	// divide by 2
	CCM_ANALOG_MISC2_TOG_AUDIO_DIV_LSB_AUDIO_DIV_LSB_1 = 0x1
	// Position of REG2_BO_OFFSET field.
	CCM_ANALOG_MISC2_TOG_REG2_BO_OFFSET_Pos = 0x10
	// Bit mask of REG2_BO_OFFSET field.
	CCM_ANALOG_MISC2_TOG_REG2_BO_OFFSET_Msk = 0x70000
	// Brownout offset = 0.100V
	CCM_ANALOG_MISC2_TOG_REG2_BO_OFFSET_REG2_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	CCM_ANALOG_MISC2_TOG_REG2_BO_OFFSET_REG2_BO_OFFSET_7 = 0x7
	// Position of REG2_BO_STATUS field.
	CCM_ANALOG_MISC2_TOG_REG2_BO_STATUS_Pos = 0x13
	// Bit mask of REG2_BO_STATUS field.
	CCM_ANALOG_MISC2_TOG_REG2_BO_STATUS_Msk = 0x80000
	// Bit REG2_BO_STATUS.
	CCM_ANALOG_MISC2_TOG_REG2_BO_STATUS = 0x80000
	// Position of REG2_ENABLE_BO field.
	CCM_ANALOG_MISC2_TOG_REG2_ENABLE_BO_Pos = 0x15
	// Bit mask of REG2_ENABLE_BO field.
	CCM_ANALOG_MISC2_TOG_REG2_ENABLE_BO_Msk = 0x200000
	// Bit REG2_ENABLE_BO.
	CCM_ANALOG_MISC2_TOG_REG2_ENABLE_BO = 0x200000
	// Position of REG2_OK field.
	CCM_ANALOG_MISC2_TOG_REG2_OK_Pos = 0x16
	// Bit mask of REG2_OK field.
	CCM_ANALOG_MISC2_TOG_REG2_OK_Msk = 0x400000
	// Bit REG2_OK.
	CCM_ANALOG_MISC2_TOG_REG2_OK = 0x400000
	// Position of AUDIO_DIV_MSB field.
	CCM_ANALOG_MISC2_TOG_AUDIO_DIV_MSB_Pos = 0x17
	// Bit mask of AUDIO_DIV_MSB field.
	CCM_ANALOG_MISC2_TOG_AUDIO_DIV_MSB_Msk = 0x800000
	// Bit AUDIO_DIV_MSB.
	CCM_ANALOG_MISC2_TOG_AUDIO_DIV_MSB = 0x800000
	// divide by 1 (Default)
	CCM_ANALOG_MISC2_TOG_AUDIO_DIV_MSB_AUDIO_DIV_MSB_0 = 0x0
	// divide by 2
	CCM_ANALOG_MISC2_TOG_AUDIO_DIV_MSB_AUDIO_DIV_MSB_1 = 0x1
	// Position of REG0_STEP_TIME field.
	CCM_ANALOG_MISC2_TOG_REG0_STEP_TIME_Pos = 0x18
	// Bit mask of REG0_STEP_TIME field.
	CCM_ANALOG_MISC2_TOG_REG0_STEP_TIME_Msk = 0x3000000
	// 64
	CCM_ANALOG_MISC2_TOG_REG0_STEP_TIME_64_CLOCKS = 0x0
	// 128
	CCM_ANALOG_MISC2_TOG_REG0_STEP_TIME_128_CLOCKS = 0x1
	// 256
	CCM_ANALOG_MISC2_TOG_REG0_STEP_TIME_256_CLOCKS = 0x2
	// 512
	CCM_ANALOG_MISC2_TOG_REG0_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG1_STEP_TIME field.
	CCM_ANALOG_MISC2_TOG_REG1_STEP_TIME_Pos = 0x1a
	// Bit mask of REG1_STEP_TIME field.
	CCM_ANALOG_MISC2_TOG_REG1_STEP_TIME_Msk = 0xc000000
	// 64
	CCM_ANALOG_MISC2_TOG_REG1_STEP_TIME_64_CLOCKS = 0x0
	// 128
	CCM_ANALOG_MISC2_TOG_REG1_STEP_TIME_128_CLOCKS = 0x1
	// 256
	CCM_ANALOG_MISC2_TOG_REG1_STEP_TIME_256_CLOCKS = 0x2
	// 512
	CCM_ANALOG_MISC2_TOG_REG1_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG2_STEP_TIME field.
	CCM_ANALOG_MISC2_TOG_REG2_STEP_TIME_Pos = 0x1c
	// Bit mask of REG2_STEP_TIME field.
	CCM_ANALOG_MISC2_TOG_REG2_STEP_TIME_Msk = 0x30000000
	// 64
	CCM_ANALOG_MISC2_TOG_REG2_STEP_TIME_64_CLOCKS = 0x0
	// 128
	CCM_ANALOG_MISC2_TOG_REG2_STEP_TIME_128_CLOCKS = 0x1
	// 256
	CCM_ANALOG_MISC2_TOG_REG2_STEP_TIME_256_CLOCKS = 0x2
	// 512
	CCM_ANALOG_MISC2_TOG_REG2_STEP_TIME_512_CLOCKS = 0x3
)

// Constants for PMU: PMU
const (
	// REG_1P1: Regulator 1P1 Register
	// Position of ENABLE_LINREG field.
	PMU_REG_1P1_ENABLE_LINREG_Pos = 0x0
	// Bit mask of ENABLE_LINREG field.
	PMU_REG_1P1_ENABLE_LINREG_Msk = 0x1
	// Bit ENABLE_LINREG.
	PMU_REG_1P1_ENABLE_LINREG = 0x1
	// Position of ENABLE_BO field.
	PMU_REG_1P1_ENABLE_BO_Pos = 0x1
	// Bit mask of ENABLE_BO field.
	PMU_REG_1P1_ENABLE_BO_Msk = 0x2
	// Bit ENABLE_BO.
	PMU_REG_1P1_ENABLE_BO = 0x2
	// Position of ENABLE_ILIMIT field.
	PMU_REG_1P1_ENABLE_ILIMIT_Pos = 0x2
	// Bit mask of ENABLE_ILIMIT field.
	PMU_REG_1P1_ENABLE_ILIMIT_Msk = 0x4
	// Bit ENABLE_ILIMIT.
	PMU_REG_1P1_ENABLE_ILIMIT = 0x4
	// Position of ENABLE_PULLDOWN field.
	PMU_REG_1P1_ENABLE_PULLDOWN_Pos = 0x3
	// Bit mask of ENABLE_PULLDOWN field.
	PMU_REG_1P1_ENABLE_PULLDOWN_Msk = 0x8
	// Bit ENABLE_PULLDOWN.
	PMU_REG_1P1_ENABLE_PULLDOWN = 0x8
	// Position of BO_OFFSET field.
	PMU_REG_1P1_BO_OFFSET_Pos = 0x4
	// Bit mask of BO_OFFSET field.
	PMU_REG_1P1_BO_OFFSET_Msk = 0x70
	// Position of OUTPUT_TRG field.
	PMU_REG_1P1_OUTPUT_TRG_Pos = 0x8
	// Bit mask of OUTPUT_TRG field.
	PMU_REG_1P1_OUTPUT_TRG_Msk = 0x1f00
	// 0.8V
	PMU_REG_1P1_OUTPUT_TRG_OUTPUT_TRG_4 = 0x4
	// 1.1V
	PMU_REG_1P1_OUTPUT_TRG_OUTPUT_TRG_16 = 0x10
	// Position of BO_VDD1P1 field.
	PMU_REG_1P1_BO_VDD1P1_Pos = 0x10
	// Bit mask of BO_VDD1P1 field.
	PMU_REG_1P1_BO_VDD1P1_Msk = 0x10000
	// Bit BO_VDD1P1.
	PMU_REG_1P1_BO_VDD1P1 = 0x10000
	// Position of OK_VDD1P1 field.
	PMU_REG_1P1_OK_VDD1P1_Pos = 0x11
	// Bit mask of OK_VDD1P1 field.
	PMU_REG_1P1_OK_VDD1P1_Msk = 0x20000
	// Bit OK_VDD1P1.
	PMU_REG_1P1_OK_VDD1P1 = 0x20000
	// Position of ENABLE_WEAK_LINREG field.
	PMU_REG_1P1_ENABLE_WEAK_LINREG_Pos = 0x12
	// Bit mask of ENABLE_WEAK_LINREG field.
	PMU_REG_1P1_ENABLE_WEAK_LINREG_Msk = 0x40000
	// Bit ENABLE_WEAK_LINREG.
	PMU_REG_1P1_ENABLE_WEAK_LINREG = 0x40000
	// Position of SELREF_WEAK_LINREG field.
	PMU_REG_1P1_SELREF_WEAK_LINREG_Pos = 0x13
	// Bit mask of SELREF_WEAK_LINREG field.
	PMU_REG_1P1_SELREF_WEAK_LINREG_Msk = 0x80000
	// Bit SELREF_WEAK_LINREG.
	PMU_REG_1P1_SELREF_WEAK_LINREG = 0x80000
	// Weak-linreg output tracks low-power-bandgap voltage
	PMU_REG_1P1_SELREF_WEAK_LINREG_SELREF_WEAK_LINREG_0 = 0x0
	// Weak-linreg output tracks VDD_SOC_IN voltage
	PMU_REG_1P1_SELREF_WEAK_LINREG_SELREF_WEAK_LINREG_1 = 0x1

	// REG_1P1_SET: Regulator 1P1 Register
	// Position of ENABLE_LINREG field.
	PMU_REG_1P1_SET_ENABLE_LINREG_Pos = 0x0
	// Bit mask of ENABLE_LINREG field.
	PMU_REG_1P1_SET_ENABLE_LINREG_Msk = 0x1
	// Bit ENABLE_LINREG.
	PMU_REG_1P1_SET_ENABLE_LINREG = 0x1
	// Position of ENABLE_BO field.
	PMU_REG_1P1_SET_ENABLE_BO_Pos = 0x1
	// Bit mask of ENABLE_BO field.
	PMU_REG_1P1_SET_ENABLE_BO_Msk = 0x2
	// Bit ENABLE_BO.
	PMU_REG_1P1_SET_ENABLE_BO = 0x2
	// Position of ENABLE_ILIMIT field.
	PMU_REG_1P1_SET_ENABLE_ILIMIT_Pos = 0x2
	// Bit mask of ENABLE_ILIMIT field.
	PMU_REG_1P1_SET_ENABLE_ILIMIT_Msk = 0x4
	// Bit ENABLE_ILIMIT.
	PMU_REG_1P1_SET_ENABLE_ILIMIT = 0x4
	// Position of ENABLE_PULLDOWN field.
	PMU_REG_1P1_SET_ENABLE_PULLDOWN_Pos = 0x3
	// Bit mask of ENABLE_PULLDOWN field.
	PMU_REG_1P1_SET_ENABLE_PULLDOWN_Msk = 0x8
	// Bit ENABLE_PULLDOWN.
	PMU_REG_1P1_SET_ENABLE_PULLDOWN = 0x8
	// Position of BO_OFFSET field.
	PMU_REG_1P1_SET_BO_OFFSET_Pos = 0x4
	// Bit mask of BO_OFFSET field.
	PMU_REG_1P1_SET_BO_OFFSET_Msk = 0x70
	// Position of OUTPUT_TRG field.
	PMU_REG_1P1_SET_OUTPUT_TRG_Pos = 0x8
	// Bit mask of OUTPUT_TRG field.
	PMU_REG_1P1_SET_OUTPUT_TRG_Msk = 0x1f00
	// 0.8V
	PMU_REG_1P1_SET_OUTPUT_TRG_OUTPUT_TRG_4 = 0x4
	// 1.1V
	PMU_REG_1P1_SET_OUTPUT_TRG_OUTPUT_TRG_16 = 0x10
	// Position of BO_VDD1P1 field.
	PMU_REG_1P1_SET_BO_VDD1P1_Pos = 0x10
	// Bit mask of BO_VDD1P1 field.
	PMU_REG_1P1_SET_BO_VDD1P1_Msk = 0x10000
	// Bit BO_VDD1P1.
	PMU_REG_1P1_SET_BO_VDD1P1 = 0x10000
	// Position of OK_VDD1P1 field.
	PMU_REG_1P1_SET_OK_VDD1P1_Pos = 0x11
	// Bit mask of OK_VDD1P1 field.
	PMU_REG_1P1_SET_OK_VDD1P1_Msk = 0x20000
	// Bit OK_VDD1P1.
	PMU_REG_1P1_SET_OK_VDD1P1 = 0x20000
	// Position of ENABLE_WEAK_LINREG field.
	PMU_REG_1P1_SET_ENABLE_WEAK_LINREG_Pos = 0x12
	// Bit mask of ENABLE_WEAK_LINREG field.
	PMU_REG_1P1_SET_ENABLE_WEAK_LINREG_Msk = 0x40000
	// Bit ENABLE_WEAK_LINREG.
	PMU_REG_1P1_SET_ENABLE_WEAK_LINREG = 0x40000
	// Position of SELREF_WEAK_LINREG field.
	PMU_REG_1P1_SET_SELREF_WEAK_LINREG_Pos = 0x13
	// Bit mask of SELREF_WEAK_LINREG field.
	PMU_REG_1P1_SET_SELREF_WEAK_LINREG_Msk = 0x80000
	// Bit SELREF_WEAK_LINREG.
	PMU_REG_1P1_SET_SELREF_WEAK_LINREG = 0x80000
	// Weak-linreg output tracks low-power-bandgap voltage
	PMU_REG_1P1_SET_SELREF_WEAK_LINREG_SELREF_WEAK_LINREG_0 = 0x0
	// Weak-linreg output tracks VDD_SOC_IN voltage
	PMU_REG_1P1_SET_SELREF_WEAK_LINREG_SELREF_WEAK_LINREG_1 = 0x1

	// REG_1P1_CLR: Regulator 1P1 Register
	// Position of ENABLE_LINREG field.
	PMU_REG_1P1_CLR_ENABLE_LINREG_Pos = 0x0
	// Bit mask of ENABLE_LINREG field.
	PMU_REG_1P1_CLR_ENABLE_LINREG_Msk = 0x1
	// Bit ENABLE_LINREG.
	PMU_REG_1P1_CLR_ENABLE_LINREG = 0x1
	// Position of ENABLE_BO field.
	PMU_REG_1P1_CLR_ENABLE_BO_Pos = 0x1
	// Bit mask of ENABLE_BO field.
	PMU_REG_1P1_CLR_ENABLE_BO_Msk = 0x2
	// Bit ENABLE_BO.
	PMU_REG_1P1_CLR_ENABLE_BO = 0x2
	// Position of ENABLE_ILIMIT field.
	PMU_REG_1P1_CLR_ENABLE_ILIMIT_Pos = 0x2
	// Bit mask of ENABLE_ILIMIT field.
	PMU_REG_1P1_CLR_ENABLE_ILIMIT_Msk = 0x4
	// Bit ENABLE_ILIMIT.
	PMU_REG_1P1_CLR_ENABLE_ILIMIT = 0x4
	// Position of ENABLE_PULLDOWN field.
	PMU_REG_1P1_CLR_ENABLE_PULLDOWN_Pos = 0x3
	// Bit mask of ENABLE_PULLDOWN field.
	PMU_REG_1P1_CLR_ENABLE_PULLDOWN_Msk = 0x8
	// Bit ENABLE_PULLDOWN.
	PMU_REG_1P1_CLR_ENABLE_PULLDOWN = 0x8
	// Position of BO_OFFSET field.
	PMU_REG_1P1_CLR_BO_OFFSET_Pos = 0x4
	// Bit mask of BO_OFFSET field.
	PMU_REG_1P1_CLR_BO_OFFSET_Msk = 0x70
	// Position of OUTPUT_TRG field.
	PMU_REG_1P1_CLR_OUTPUT_TRG_Pos = 0x8
	// Bit mask of OUTPUT_TRG field.
	PMU_REG_1P1_CLR_OUTPUT_TRG_Msk = 0x1f00
	// 0.8V
	PMU_REG_1P1_CLR_OUTPUT_TRG_OUTPUT_TRG_4 = 0x4
	// 1.1V
	PMU_REG_1P1_CLR_OUTPUT_TRG_OUTPUT_TRG_16 = 0x10
	// Position of BO_VDD1P1 field.
	PMU_REG_1P1_CLR_BO_VDD1P1_Pos = 0x10
	// Bit mask of BO_VDD1P1 field.
	PMU_REG_1P1_CLR_BO_VDD1P1_Msk = 0x10000
	// Bit BO_VDD1P1.
	PMU_REG_1P1_CLR_BO_VDD1P1 = 0x10000
	// Position of OK_VDD1P1 field.
	PMU_REG_1P1_CLR_OK_VDD1P1_Pos = 0x11
	// Bit mask of OK_VDD1P1 field.
	PMU_REG_1P1_CLR_OK_VDD1P1_Msk = 0x20000
	// Bit OK_VDD1P1.
	PMU_REG_1P1_CLR_OK_VDD1P1 = 0x20000
	// Position of ENABLE_WEAK_LINREG field.
	PMU_REG_1P1_CLR_ENABLE_WEAK_LINREG_Pos = 0x12
	// Bit mask of ENABLE_WEAK_LINREG field.
	PMU_REG_1P1_CLR_ENABLE_WEAK_LINREG_Msk = 0x40000
	// Bit ENABLE_WEAK_LINREG.
	PMU_REG_1P1_CLR_ENABLE_WEAK_LINREG = 0x40000
	// Position of SELREF_WEAK_LINREG field.
	PMU_REG_1P1_CLR_SELREF_WEAK_LINREG_Pos = 0x13
	// Bit mask of SELREF_WEAK_LINREG field.
	PMU_REG_1P1_CLR_SELREF_WEAK_LINREG_Msk = 0x80000
	// Bit SELREF_WEAK_LINREG.
	PMU_REG_1P1_CLR_SELREF_WEAK_LINREG = 0x80000
	// Weak-linreg output tracks low-power-bandgap voltage
	PMU_REG_1P1_CLR_SELREF_WEAK_LINREG_SELREF_WEAK_LINREG_0 = 0x0
	// Weak-linreg output tracks VDD_SOC_IN voltage
	PMU_REG_1P1_CLR_SELREF_WEAK_LINREG_SELREF_WEAK_LINREG_1 = 0x1

	// REG_1P1_TOG: Regulator 1P1 Register
	// Position of ENABLE_LINREG field.
	PMU_REG_1P1_TOG_ENABLE_LINREG_Pos = 0x0
	// Bit mask of ENABLE_LINREG field.
	PMU_REG_1P1_TOG_ENABLE_LINREG_Msk = 0x1
	// Bit ENABLE_LINREG.
	PMU_REG_1P1_TOG_ENABLE_LINREG = 0x1
	// Position of ENABLE_BO field.
	PMU_REG_1P1_TOG_ENABLE_BO_Pos = 0x1
	// Bit mask of ENABLE_BO field.
	PMU_REG_1P1_TOG_ENABLE_BO_Msk = 0x2
	// Bit ENABLE_BO.
	PMU_REG_1P1_TOG_ENABLE_BO = 0x2
	// Position of ENABLE_ILIMIT field.
	PMU_REG_1P1_TOG_ENABLE_ILIMIT_Pos = 0x2
	// Bit mask of ENABLE_ILIMIT field.
	PMU_REG_1P1_TOG_ENABLE_ILIMIT_Msk = 0x4
	// Bit ENABLE_ILIMIT.
	PMU_REG_1P1_TOG_ENABLE_ILIMIT = 0x4
	// Position of ENABLE_PULLDOWN field.
	PMU_REG_1P1_TOG_ENABLE_PULLDOWN_Pos = 0x3
	// Bit mask of ENABLE_PULLDOWN field.
	PMU_REG_1P1_TOG_ENABLE_PULLDOWN_Msk = 0x8
	// Bit ENABLE_PULLDOWN.
	PMU_REG_1P1_TOG_ENABLE_PULLDOWN = 0x8
	// Position of BO_OFFSET field.
	PMU_REG_1P1_TOG_BO_OFFSET_Pos = 0x4
	// Bit mask of BO_OFFSET field.
	PMU_REG_1P1_TOG_BO_OFFSET_Msk = 0x70
	// Position of OUTPUT_TRG field.
	PMU_REG_1P1_TOG_OUTPUT_TRG_Pos = 0x8
	// Bit mask of OUTPUT_TRG field.
	PMU_REG_1P1_TOG_OUTPUT_TRG_Msk = 0x1f00
	// 0.8V
	PMU_REG_1P1_TOG_OUTPUT_TRG_OUTPUT_TRG_4 = 0x4
	// 1.1V
	PMU_REG_1P1_TOG_OUTPUT_TRG_OUTPUT_TRG_16 = 0x10
	// Position of BO_VDD1P1 field.
	PMU_REG_1P1_TOG_BO_VDD1P1_Pos = 0x10
	// Bit mask of BO_VDD1P1 field.
	PMU_REG_1P1_TOG_BO_VDD1P1_Msk = 0x10000
	// Bit BO_VDD1P1.
	PMU_REG_1P1_TOG_BO_VDD1P1 = 0x10000
	// Position of OK_VDD1P1 field.
	PMU_REG_1P1_TOG_OK_VDD1P1_Pos = 0x11
	// Bit mask of OK_VDD1P1 field.
	PMU_REG_1P1_TOG_OK_VDD1P1_Msk = 0x20000
	// Bit OK_VDD1P1.
	PMU_REG_1P1_TOG_OK_VDD1P1 = 0x20000
	// Position of ENABLE_WEAK_LINREG field.
	PMU_REG_1P1_TOG_ENABLE_WEAK_LINREG_Pos = 0x12
	// Bit mask of ENABLE_WEAK_LINREG field.
	PMU_REG_1P1_TOG_ENABLE_WEAK_LINREG_Msk = 0x40000
	// Bit ENABLE_WEAK_LINREG.
	PMU_REG_1P1_TOG_ENABLE_WEAK_LINREG = 0x40000
	// Position of SELREF_WEAK_LINREG field.
	PMU_REG_1P1_TOG_SELREF_WEAK_LINREG_Pos = 0x13
	// Bit mask of SELREF_WEAK_LINREG field.
	PMU_REG_1P1_TOG_SELREF_WEAK_LINREG_Msk = 0x80000
	// Bit SELREF_WEAK_LINREG.
	PMU_REG_1P1_TOG_SELREF_WEAK_LINREG = 0x80000
	// Weak-linreg output tracks low-power-bandgap voltage
	PMU_REG_1P1_TOG_SELREF_WEAK_LINREG_SELREF_WEAK_LINREG_0 = 0x0
	// Weak-linreg output tracks VDD_SOC_IN voltage
	PMU_REG_1P1_TOG_SELREF_WEAK_LINREG_SELREF_WEAK_LINREG_1 = 0x1

	// REG_3P0: Regulator 3P0 Register
	// Position of ENABLE_LINREG field.
	PMU_REG_3P0_ENABLE_LINREG_Pos = 0x0
	// Bit mask of ENABLE_LINREG field.
	PMU_REG_3P0_ENABLE_LINREG_Msk = 0x1
	// Bit ENABLE_LINREG.
	PMU_REG_3P0_ENABLE_LINREG = 0x1
	// Position of ENABLE_BO field.
	PMU_REG_3P0_ENABLE_BO_Pos = 0x1
	// Bit mask of ENABLE_BO field.
	PMU_REG_3P0_ENABLE_BO_Msk = 0x2
	// Bit ENABLE_BO.
	PMU_REG_3P0_ENABLE_BO = 0x2
	// Position of ENABLE_ILIMIT field.
	PMU_REG_3P0_ENABLE_ILIMIT_Pos = 0x2
	// Bit mask of ENABLE_ILIMIT field.
	PMU_REG_3P0_ENABLE_ILIMIT_Msk = 0x4
	// Bit ENABLE_ILIMIT.
	PMU_REG_3P0_ENABLE_ILIMIT = 0x4
	// Position of BO_OFFSET field.
	PMU_REG_3P0_BO_OFFSET_Pos = 0x4
	// Bit mask of BO_OFFSET field.
	PMU_REG_3P0_BO_OFFSET_Msk = 0x70
	// Position of VBUS_SEL field.
	PMU_REG_3P0_VBUS_SEL_Pos = 0x7
	// Bit mask of VBUS_SEL field.
	PMU_REG_3P0_VBUS_SEL_Msk = 0x80
	// Bit VBUS_SEL.
	PMU_REG_3P0_VBUS_SEL = 0x80
	// Utilize VBUS OTG2 power
	PMU_REG_3P0_VBUS_SEL_USB_OTG2_VBUS = 0x0
	// Utilize VBUS OTG1 power
	PMU_REG_3P0_VBUS_SEL_USB_OTG1_VBUS = 0x1
	// Position of OUTPUT_TRG field.
	PMU_REG_3P0_OUTPUT_TRG_Pos = 0x8
	// Bit mask of OUTPUT_TRG field.
	PMU_REG_3P0_OUTPUT_TRG_Msk = 0x1f00
	// 2.625V
	PMU_REG_3P0_OUTPUT_TRG_OUTPUT_TRG_0 = 0x0
	// 3.000V
	PMU_REG_3P0_OUTPUT_TRG_OUTPUT_TRG_15 = 0xf
	// 3.400V
	PMU_REG_3P0_OUTPUT_TRG_OUTPUT_TRG_31 = 0x1f
	// Position of BO_VDD3P0 field.
	PMU_REG_3P0_BO_VDD3P0_Pos = 0x10
	// Bit mask of BO_VDD3P0 field.
	PMU_REG_3P0_BO_VDD3P0_Msk = 0x10000
	// Bit BO_VDD3P0.
	PMU_REG_3P0_BO_VDD3P0 = 0x10000
	// Position of OK_VDD3P0 field.
	PMU_REG_3P0_OK_VDD3P0_Pos = 0x11
	// Bit mask of OK_VDD3P0 field.
	PMU_REG_3P0_OK_VDD3P0_Msk = 0x20000
	// Bit OK_VDD3P0.
	PMU_REG_3P0_OK_VDD3P0 = 0x20000

	// REG_3P0_SET: Regulator 3P0 Register
	// Position of ENABLE_LINREG field.
	PMU_REG_3P0_SET_ENABLE_LINREG_Pos = 0x0
	// Bit mask of ENABLE_LINREG field.
	PMU_REG_3P0_SET_ENABLE_LINREG_Msk = 0x1
	// Bit ENABLE_LINREG.
	PMU_REG_3P0_SET_ENABLE_LINREG = 0x1
	// Position of ENABLE_BO field.
	PMU_REG_3P0_SET_ENABLE_BO_Pos = 0x1
	// Bit mask of ENABLE_BO field.
	PMU_REG_3P0_SET_ENABLE_BO_Msk = 0x2
	// Bit ENABLE_BO.
	PMU_REG_3P0_SET_ENABLE_BO = 0x2
	// Position of ENABLE_ILIMIT field.
	PMU_REG_3P0_SET_ENABLE_ILIMIT_Pos = 0x2
	// Bit mask of ENABLE_ILIMIT field.
	PMU_REG_3P0_SET_ENABLE_ILIMIT_Msk = 0x4
	// Bit ENABLE_ILIMIT.
	PMU_REG_3P0_SET_ENABLE_ILIMIT = 0x4
	// Position of BO_OFFSET field.
	PMU_REG_3P0_SET_BO_OFFSET_Pos = 0x4
	// Bit mask of BO_OFFSET field.
	PMU_REG_3P0_SET_BO_OFFSET_Msk = 0x70
	// Position of VBUS_SEL field.
	PMU_REG_3P0_SET_VBUS_SEL_Pos = 0x7
	// Bit mask of VBUS_SEL field.
	PMU_REG_3P0_SET_VBUS_SEL_Msk = 0x80
	// Bit VBUS_SEL.
	PMU_REG_3P0_SET_VBUS_SEL = 0x80
	// Utilize VBUS OTG2 power
	PMU_REG_3P0_SET_VBUS_SEL_USB_OTG2_VBUS = 0x0
	// Utilize VBUS OTG1 power
	PMU_REG_3P0_SET_VBUS_SEL_USB_OTG1_VBUS = 0x1
	// Position of OUTPUT_TRG field.
	PMU_REG_3P0_SET_OUTPUT_TRG_Pos = 0x8
	// Bit mask of OUTPUT_TRG field.
	PMU_REG_3P0_SET_OUTPUT_TRG_Msk = 0x1f00
	// 2.625V
	PMU_REG_3P0_SET_OUTPUT_TRG_OUTPUT_TRG_0 = 0x0
	// 3.000V
	PMU_REG_3P0_SET_OUTPUT_TRG_OUTPUT_TRG_15 = 0xf
	// 3.400V
	PMU_REG_3P0_SET_OUTPUT_TRG_OUTPUT_TRG_31 = 0x1f
	// Position of BO_VDD3P0 field.
	PMU_REG_3P0_SET_BO_VDD3P0_Pos = 0x10
	// Bit mask of BO_VDD3P0 field.
	PMU_REG_3P0_SET_BO_VDD3P0_Msk = 0x10000
	// Bit BO_VDD3P0.
	PMU_REG_3P0_SET_BO_VDD3P0 = 0x10000
	// Position of OK_VDD3P0 field.
	PMU_REG_3P0_SET_OK_VDD3P0_Pos = 0x11
	// Bit mask of OK_VDD3P0 field.
	PMU_REG_3P0_SET_OK_VDD3P0_Msk = 0x20000
	// Bit OK_VDD3P0.
	PMU_REG_3P0_SET_OK_VDD3P0 = 0x20000

	// REG_3P0_CLR: Regulator 3P0 Register
	// Position of ENABLE_LINREG field.
	PMU_REG_3P0_CLR_ENABLE_LINREG_Pos = 0x0
	// Bit mask of ENABLE_LINREG field.
	PMU_REG_3P0_CLR_ENABLE_LINREG_Msk = 0x1
	// Bit ENABLE_LINREG.
	PMU_REG_3P0_CLR_ENABLE_LINREG = 0x1
	// Position of ENABLE_BO field.
	PMU_REG_3P0_CLR_ENABLE_BO_Pos = 0x1
	// Bit mask of ENABLE_BO field.
	PMU_REG_3P0_CLR_ENABLE_BO_Msk = 0x2
	// Bit ENABLE_BO.
	PMU_REG_3P0_CLR_ENABLE_BO = 0x2
	// Position of ENABLE_ILIMIT field.
	PMU_REG_3P0_CLR_ENABLE_ILIMIT_Pos = 0x2
	// Bit mask of ENABLE_ILIMIT field.
	PMU_REG_3P0_CLR_ENABLE_ILIMIT_Msk = 0x4
	// Bit ENABLE_ILIMIT.
	PMU_REG_3P0_CLR_ENABLE_ILIMIT = 0x4
	// Position of BO_OFFSET field.
	PMU_REG_3P0_CLR_BO_OFFSET_Pos = 0x4
	// Bit mask of BO_OFFSET field.
	PMU_REG_3P0_CLR_BO_OFFSET_Msk = 0x70
	// Position of VBUS_SEL field.
	PMU_REG_3P0_CLR_VBUS_SEL_Pos = 0x7
	// Bit mask of VBUS_SEL field.
	PMU_REG_3P0_CLR_VBUS_SEL_Msk = 0x80
	// Bit VBUS_SEL.
	PMU_REG_3P0_CLR_VBUS_SEL = 0x80
	// Utilize VBUS OTG2 power
	PMU_REG_3P0_CLR_VBUS_SEL_USB_OTG2_VBUS = 0x0
	// Utilize VBUS OTG1 power
	PMU_REG_3P0_CLR_VBUS_SEL_USB_OTG1_VBUS = 0x1
	// Position of OUTPUT_TRG field.
	PMU_REG_3P0_CLR_OUTPUT_TRG_Pos = 0x8
	// Bit mask of OUTPUT_TRG field.
	PMU_REG_3P0_CLR_OUTPUT_TRG_Msk = 0x1f00
	// 2.625V
	PMU_REG_3P0_CLR_OUTPUT_TRG_OUTPUT_TRG_0 = 0x0
	// 3.000V
	PMU_REG_3P0_CLR_OUTPUT_TRG_OUTPUT_TRG_15 = 0xf
	// 3.400V
	PMU_REG_3P0_CLR_OUTPUT_TRG_OUTPUT_TRG_31 = 0x1f
	// Position of BO_VDD3P0 field.
	PMU_REG_3P0_CLR_BO_VDD3P0_Pos = 0x10
	// Bit mask of BO_VDD3P0 field.
	PMU_REG_3P0_CLR_BO_VDD3P0_Msk = 0x10000
	// Bit BO_VDD3P0.
	PMU_REG_3P0_CLR_BO_VDD3P0 = 0x10000
	// Position of OK_VDD3P0 field.
	PMU_REG_3P0_CLR_OK_VDD3P0_Pos = 0x11
	// Bit mask of OK_VDD3P0 field.
	PMU_REG_3P0_CLR_OK_VDD3P0_Msk = 0x20000
	// Bit OK_VDD3P0.
	PMU_REG_3P0_CLR_OK_VDD3P0 = 0x20000

	// REG_3P0_TOG: Regulator 3P0 Register
	// Position of ENABLE_LINREG field.
	PMU_REG_3P0_TOG_ENABLE_LINREG_Pos = 0x0
	// Bit mask of ENABLE_LINREG field.
	PMU_REG_3P0_TOG_ENABLE_LINREG_Msk = 0x1
	// Bit ENABLE_LINREG.
	PMU_REG_3P0_TOG_ENABLE_LINREG = 0x1
	// Position of ENABLE_BO field.
	PMU_REG_3P0_TOG_ENABLE_BO_Pos = 0x1
	// Bit mask of ENABLE_BO field.
	PMU_REG_3P0_TOG_ENABLE_BO_Msk = 0x2
	// Bit ENABLE_BO.
	PMU_REG_3P0_TOG_ENABLE_BO = 0x2
	// Position of ENABLE_ILIMIT field.
	PMU_REG_3P0_TOG_ENABLE_ILIMIT_Pos = 0x2
	// Bit mask of ENABLE_ILIMIT field.
	PMU_REG_3P0_TOG_ENABLE_ILIMIT_Msk = 0x4
	// Bit ENABLE_ILIMIT.
	PMU_REG_3P0_TOG_ENABLE_ILIMIT = 0x4
	// Position of BO_OFFSET field.
	PMU_REG_3P0_TOG_BO_OFFSET_Pos = 0x4
	// Bit mask of BO_OFFSET field.
	PMU_REG_3P0_TOG_BO_OFFSET_Msk = 0x70
	// Position of VBUS_SEL field.
	PMU_REG_3P0_TOG_VBUS_SEL_Pos = 0x7
	// Bit mask of VBUS_SEL field.
	PMU_REG_3P0_TOG_VBUS_SEL_Msk = 0x80
	// Bit VBUS_SEL.
	PMU_REG_3P0_TOG_VBUS_SEL = 0x80
	// Utilize VBUS OTG2 power
	PMU_REG_3P0_TOG_VBUS_SEL_USB_OTG2_VBUS = 0x0
	// Utilize VBUS OTG1 power
	PMU_REG_3P0_TOG_VBUS_SEL_USB_OTG1_VBUS = 0x1
	// Position of OUTPUT_TRG field.
	PMU_REG_3P0_TOG_OUTPUT_TRG_Pos = 0x8
	// Bit mask of OUTPUT_TRG field.
	PMU_REG_3P0_TOG_OUTPUT_TRG_Msk = 0x1f00
	// 2.625V
	PMU_REG_3P0_TOG_OUTPUT_TRG_OUTPUT_TRG_0 = 0x0
	// 3.000V
	PMU_REG_3P0_TOG_OUTPUT_TRG_OUTPUT_TRG_15 = 0xf
	// 3.400V
	PMU_REG_3P0_TOG_OUTPUT_TRG_OUTPUT_TRG_31 = 0x1f
	// Position of BO_VDD3P0 field.
	PMU_REG_3P0_TOG_BO_VDD3P0_Pos = 0x10
	// Bit mask of BO_VDD3P0 field.
	PMU_REG_3P0_TOG_BO_VDD3P0_Msk = 0x10000
	// Bit BO_VDD3P0.
	PMU_REG_3P0_TOG_BO_VDD3P0 = 0x10000
	// Position of OK_VDD3P0 field.
	PMU_REG_3P0_TOG_OK_VDD3P0_Pos = 0x11
	// Bit mask of OK_VDD3P0 field.
	PMU_REG_3P0_TOG_OK_VDD3P0_Msk = 0x20000
	// Bit OK_VDD3P0.
	PMU_REG_3P0_TOG_OK_VDD3P0 = 0x20000

	// REG_2P5: Regulator 2P5 Register
	// Position of ENABLE_LINREG field.
	PMU_REG_2P5_ENABLE_LINREG_Pos = 0x0
	// Bit mask of ENABLE_LINREG field.
	PMU_REG_2P5_ENABLE_LINREG_Msk = 0x1
	// Bit ENABLE_LINREG.
	PMU_REG_2P5_ENABLE_LINREG = 0x1
	// Position of ENABLE_BO field.
	PMU_REG_2P5_ENABLE_BO_Pos = 0x1
	// Bit mask of ENABLE_BO field.
	PMU_REG_2P5_ENABLE_BO_Msk = 0x2
	// Bit ENABLE_BO.
	PMU_REG_2P5_ENABLE_BO = 0x2
	// Position of ENABLE_ILIMIT field.
	PMU_REG_2P5_ENABLE_ILIMIT_Pos = 0x2
	// Bit mask of ENABLE_ILIMIT field.
	PMU_REG_2P5_ENABLE_ILIMIT_Msk = 0x4
	// Bit ENABLE_ILIMIT.
	PMU_REG_2P5_ENABLE_ILIMIT = 0x4
	// Position of ENABLE_PULLDOWN field.
	PMU_REG_2P5_ENABLE_PULLDOWN_Pos = 0x3
	// Bit mask of ENABLE_PULLDOWN field.
	PMU_REG_2P5_ENABLE_PULLDOWN_Msk = 0x8
	// Bit ENABLE_PULLDOWN.
	PMU_REG_2P5_ENABLE_PULLDOWN = 0x8
	// Position of BO_OFFSET field.
	PMU_REG_2P5_BO_OFFSET_Pos = 0x4
	// Bit mask of BO_OFFSET field.
	PMU_REG_2P5_BO_OFFSET_Msk = 0x70
	// Position of OUTPUT_TRG field.
	PMU_REG_2P5_OUTPUT_TRG_Pos = 0x8
	// Bit mask of OUTPUT_TRG field.
	PMU_REG_2P5_OUTPUT_TRG_Msk = 0x1f00
	// 2.10V
	PMU_REG_2P5_OUTPUT_TRG_OUTPUT_TRG_0 = 0x0
	// 2.50V
	PMU_REG_2P5_OUTPUT_TRG_OUTPUT_TRG_16 = 0x10
	// 2.875V
	PMU_REG_2P5_OUTPUT_TRG_OUTPUT_TRG_31 = 0x1f
	// Position of BO_VDD2P5 field.
	PMU_REG_2P5_BO_VDD2P5_Pos = 0x10
	// Bit mask of BO_VDD2P5 field.
	PMU_REG_2P5_BO_VDD2P5_Msk = 0x10000
	// Bit BO_VDD2P5.
	PMU_REG_2P5_BO_VDD2P5 = 0x10000
	// Position of OK_VDD2P5 field.
	PMU_REG_2P5_OK_VDD2P5_Pos = 0x11
	// Bit mask of OK_VDD2P5 field.
	PMU_REG_2P5_OK_VDD2P5_Msk = 0x20000
	// Bit OK_VDD2P5.
	PMU_REG_2P5_OK_VDD2P5 = 0x20000
	// Position of ENABLE_WEAK_LINREG field.
	PMU_REG_2P5_ENABLE_WEAK_LINREG_Pos = 0x12
	// Bit mask of ENABLE_WEAK_LINREG field.
	PMU_REG_2P5_ENABLE_WEAK_LINREG_Msk = 0x40000
	// Bit ENABLE_WEAK_LINREG.
	PMU_REG_2P5_ENABLE_WEAK_LINREG = 0x40000

	// REG_2P5_SET: Regulator 2P5 Register
	// Position of ENABLE_LINREG field.
	PMU_REG_2P5_SET_ENABLE_LINREG_Pos = 0x0
	// Bit mask of ENABLE_LINREG field.
	PMU_REG_2P5_SET_ENABLE_LINREG_Msk = 0x1
	// Bit ENABLE_LINREG.
	PMU_REG_2P5_SET_ENABLE_LINREG = 0x1
	// Position of ENABLE_BO field.
	PMU_REG_2P5_SET_ENABLE_BO_Pos = 0x1
	// Bit mask of ENABLE_BO field.
	PMU_REG_2P5_SET_ENABLE_BO_Msk = 0x2
	// Bit ENABLE_BO.
	PMU_REG_2P5_SET_ENABLE_BO = 0x2
	// Position of ENABLE_ILIMIT field.
	PMU_REG_2P5_SET_ENABLE_ILIMIT_Pos = 0x2
	// Bit mask of ENABLE_ILIMIT field.
	PMU_REG_2P5_SET_ENABLE_ILIMIT_Msk = 0x4
	// Bit ENABLE_ILIMIT.
	PMU_REG_2P5_SET_ENABLE_ILIMIT = 0x4
	// Position of ENABLE_PULLDOWN field.
	PMU_REG_2P5_SET_ENABLE_PULLDOWN_Pos = 0x3
	// Bit mask of ENABLE_PULLDOWN field.
	PMU_REG_2P5_SET_ENABLE_PULLDOWN_Msk = 0x8
	// Bit ENABLE_PULLDOWN.
	PMU_REG_2P5_SET_ENABLE_PULLDOWN = 0x8
	// Position of BO_OFFSET field.
	PMU_REG_2P5_SET_BO_OFFSET_Pos = 0x4
	// Bit mask of BO_OFFSET field.
	PMU_REG_2P5_SET_BO_OFFSET_Msk = 0x70
	// Position of OUTPUT_TRG field.
	PMU_REG_2P5_SET_OUTPUT_TRG_Pos = 0x8
	// Bit mask of OUTPUT_TRG field.
	PMU_REG_2P5_SET_OUTPUT_TRG_Msk = 0x1f00
	// 2.10V
	PMU_REG_2P5_SET_OUTPUT_TRG_OUTPUT_TRG_0 = 0x0
	// 2.50V
	PMU_REG_2P5_SET_OUTPUT_TRG_OUTPUT_TRG_16 = 0x10
	// 2.875V
	PMU_REG_2P5_SET_OUTPUT_TRG_OUTPUT_TRG_31 = 0x1f
	// Position of BO_VDD2P5 field.
	PMU_REG_2P5_SET_BO_VDD2P5_Pos = 0x10
	// Bit mask of BO_VDD2P5 field.
	PMU_REG_2P5_SET_BO_VDD2P5_Msk = 0x10000
	// Bit BO_VDD2P5.
	PMU_REG_2P5_SET_BO_VDD2P5 = 0x10000
	// Position of OK_VDD2P5 field.
	PMU_REG_2P5_SET_OK_VDD2P5_Pos = 0x11
	// Bit mask of OK_VDD2P5 field.
	PMU_REG_2P5_SET_OK_VDD2P5_Msk = 0x20000
	// Bit OK_VDD2P5.
	PMU_REG_2P5_SET_OK_VDD2P5 = 0x20000
	// Position of ENABLE_WEAK_LINREG field.
	PMU_REG_2P5_SET_ENABLE_WEAK_LINREG_Pos = 0x12
	// Bit mask of ENABLE_WEAK_LINREG field.
	PMU_REG_2P5_SET_ENABLE_WEAK_LINREG_Msk = 0x40000
	// Bit ENABLE_WEAK_LINREG.
	PMU_REG_2P5_SET_ENABLE_WEAK_LINREG = 0x40000

	// REG_2P5_CLR: Regulator 2P5 Register
	// Position of ENABLE_LINREG field.
	PMU_REG_2P5_CLR_ENABLE_LINREG_Pos = 0x0
	// Bit mask of ENABLE_LINREG field.
	PMU_REG_2P5_CLR_ENABLE_LINREG_Msk = 0x1
	// Bit ENABLE_LINREG.
	PMU_REG_2P5_CLR_ENABLE_LINREG = 0x1
	// Position of ENABLE_BO field.
	PMU_REG_2P5_CLR_ENABLE_BO_Pos = 0x1
	// Bit mask of ENABLE_BO field.
	PMU_REG_2P5_CLR_ENABLE_BO_Msk = 0x2
	// Bit ENABLE_BO.
	PMU_REG_2P5_CLR_ENABLE_BO = 0x2
	// Position of ENABLE_ILIMIT field.
	PMU_REG_2P5_CLR_ENABLE_ILIMIT_Pos = 0x2
	// Bit mask of ENABLE_ILIMIT field.
	PMU_REG_2P5_CLR_ENABLE_ILIMIT_Msk = 0x4
	// Bit ENABLE_ILIMIT.
	PMU_REG_2P5_CLR_ENABLE_ILIMIT = 0x4
	// Position of ENABLE_PULLDOWN field.
	PMU_REG_2P5_CLR_ENABLE_PULLDOWN_Pos = 0x3
	// Bit mask of ENABLE_PULLDOWN field.
	PMU_REG_2P5_CLR_ENABLE_PULLDOWN_Msk = 0x8
	// Bit ENABLE_PULLDOWN.
	PMU_REG_2P5_CLR_ENABLE_PULLDOWN = 0x8
	// Position of BO_OFFSET field.
	PMU_REG_2P5_CLR_BO_OFFSET_Pos = 0x4
	// Bit mask of BO_OFFSET field.
	PMU_REG_2P5_CLR_BO_OFFSET_Msk = 0x70
	// Position of OUTPUT_TRG field.
	PMU_REG_2P5_CLR_OUTPUT_TRG_Pos = 0x8
	// Bit mask of OUTPUT_TRG field.
	PMU_REG_2P5_CLR_OUTPUT_TRG_Msk = 0x1f00
	// 2.10V
	PMU_REG_2P5_CLR_OUTPUT_TRG_OUTPUT_TRG_0 = 0x0
	// 2.50V
	PMU_REG_2P5_CLR_OUTPUT_TRG_OUTPUT_TRG_16 = 0x10
	// 2.875V
	PMU_REG_2P5_CLR_OUTPUT_TRG_OUTPUT_TRG_31 = 0x1f
	// Position of BO_VDD2P5 field.
	PMU_REG_2P5_CLR_BO_VDD2P5_Pos = 0x10
	// Bit mask of BO_VDD2P5 field.
	PMU_REG_2P5_CLR_BO_VDD2P5_Msk = 0x10000
	// Bit BO_VDD2P5.
	PMU_REG_2P5_CLR_BO_VDD2P5 = 0x10000
	// Position of OK_VDD2P5 field.
	PMU_REG_2P5_CLR_OK_VDD2P5_Pos = 0x11
	// Bit mask of OK_VDD2P5 field.
	PMU_REG_2P5_CLR_OK_VDD2P5_Msk = 0x20000
	// Bit OK_VDD2P5.
	PMU_REG_2P5_CLR_OK_VDD2P5 = 0x20000
	// Position of ENABLE_WEAK_LINREG field.
	PMU_REG_2P5_CLR_ENABLE_WEAK_LINREG_Pos = 0x12
	// Bit mask of ENABLE_WEAK_LINREG field.
	PMU_REG_2P5_CLR_ENABLE_WEAK_LINREG_Msk = 0x40000
	// Bit ENABLE_WEAK_LINREG.
	PMU_REG_2P5_CLR_ENABLE_WEAK_LINREG = 0x40000

	// REG_2P5_TOG: Regulator 2P5 Register
	// Position of ENABLE_LINREG field.
	PMU_REG_2P5_TOG_ENABLE_LINREG_Pos = 0x0
	// Bit mask of ENABLE_LINREG field.
	PMU_REG_2P5_TOG_ENABLE_LINREG_Msk = 0x1
	// Bit ENABLE_LINREG.
	PMU_REG_2P5_TOG_ENABLE_LINREG = 0x1
	// Position of ENABLE_BO field.
	PMU_REG_2P5_TOG_ENABLE_BO_Pos = 0x1
	// Bit mask of ENABLE_BO field.
	PMU_REG_2P5_TOG_ENABLE_BO_Msk = 0x2
	// Bit ENABLE_BO.
	PMU_REG_2P5_TOG_ENABLE_BO = 0x2
	// Position of ENABLE_ILIMIT field.
	PMU_REG_2P5_TOG_ENABLE_ILIMIT_Pos = 0x2
	// Bit mask of ENABLE_ILIMIT field.
	PMU_REG_2P5_TOG_ENABLE_ILIMIT_Msk = 0x4
	// Bit ENABLE_ILIMIT.
	PMU_REG_2P5_TOG_ENABLE_ILIMIT = 0x4
	// Position of ENABLE_PULLDOWN field.
	PMU_REG_2P5_TOG_ENABLE_PULLDOWN_Pos = 0x3
	// Bit mask of ENABLE_PULLDOWN field.
	PMU_REG_2P5_TOG_ENABLE_PULLDOWN_Msk = 0x8
	// Bit ENABLE_PULLDOWN.
	PMU_REG_2P5_TOG_ENABLE_PULLDOWN = 0x8
	// Position of BO_OFFSET field.
	PMU_REG_2P5_TOG_BO_OFFSET_Pos = 0x4
	// Bit mask of BO_OFFSET field.
	PMU_REG_2P5_TOG_BO_OFFSET_Msk = 0x70
	// Position of OUTPUT_TRG field.
	PMU_REG_2P5_TOG_OUTPUT_TRG_Pos = 0x8
	// Bit mask of OUTPUT_TRG field.
	PMU_REG_2P5_TOG_OUTPUT_TRG_Msk = 0x1f00
	// 2.10V
	PMU_REG_2P5_TOG_OUTPUT_TRG_OUTPUT_TRG_0 = 0x0
	// 2.50V
	PMU_REG_2P5_TOG_OUTPUT_TRG_OUTPUT_TRG_16 = 0x10
	// 2.875V
	PMU_REG_2P5_TOG_OUTPUT_TRG_OUTPUT_TRG_31 = 0x1f
	// Position of BO_VDD2P5 field.
	PMU_REG_2P5_TOG_BO_VDD2P5_Pos = 0x10
	// Bit mask of BO_VDD2P5 field.
	PMU_REG_2P5_TOG_BO_VDD2P5_Msk = 0x10000
	// Bit BO_VDD2P5.
	PMU_REG_2P5_TOG_BO_VDD2P5 = 0x10000
	// Position of OK_VDD2P5 field.
	PMU_REG_2P5_TOG_OK_VDD2P5_Pos = 0x11
	// Bit mask of OK_VDD2P5 field.
	PMU_REG_2P5_TOG_OK_VDD2P5_Msk = 0x20000
	// Bit OK_VDD2P5.
	PMU_REG_2P5_TOG_OK_VDD2P5 = 0x20000
	// Position of ENABLE_WEAK_LINREG field.
	PMU_REG_2P5_TOG_ENABLE_WEAK_LINREG_Pos = 0x12
	// Bit mask of ENABLE_WEAK_LINREG field.
	PMU_REG_2P5_TOG_ENABLE_WEAK_LINREG_Msk = 0x40000
	// Bit ENABLE_WEAK_LINREG.
	PMU_REG_2P5_TOG_ENABLE_WEAK_LINREG = 0x40000

	// REG_CORE: Digital Regulator Core Register
	// Position of REG0_TARG field.
	PMU_REG_CORE_REG0_TARG_Pos = 0x0
	// Bit mask of REG0_TARG field.
	PMU_REG_CORE_REG0_TARG_Msk = 0x1f
	// Power gated off
	PMU_REG_CORE_REG0_TARG_REG0_TARG_0 = 0x0
	// Target core voltage = 0.725V
	PMU_REG_CORE_REG0_TARG_REG0_TARG_1 = 0x1
	// Target core voltage = 0.750V
	PMU_REG_CORE_REG0_TARG_REG0_TARG_2 = 0x2
	// Target core voltage = 0.775V
	PMU_REG_CORE_REG0_TARG_REG0_TARG_3 = 0x3
	// Target core voltage = 1.100V
	PMU_REG_CORE_REG0_TARG_REG0_TARG_16 = 0x10
	// Target core voltage = 1.450V
	PMU_REG_CORE_REG0_TARG_REG0_TARG_30 = 0x1e
	// Power FET switched full on. No regulation.
	PMU_REG_CORE_REG0_TARG_REG0_TARG_31 = 0x1f
	// Position of REG0_ADJ field.
	PMU_REG_CORE_REG0_ADJ_Pos = 0x5
	// Bit mask of REG0_ADJ field.
	PMU_REG_CORE_REG0_ADJ_Msk = 0x1e0
	// No adjustment
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_0 = 0x0
	// + 0.25%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_1 = 0x1
	// + 0.50%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_2 = 0x2
	// + 0.75%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_3 = 0x3
	// + 1.00%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_4 = 0x4
	// + 1.25%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_5 = 0x5
	// + 1.50%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_6 = 0x6
	// + 1.75%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_7 = 0x7
	// - 0.25%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_8 = 0x8
	// - 0.50%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_9 = 0x9
	// - 0.75%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_10 = 0xa
	// - 1.00%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_11 = 0xb
	// - 1.25%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_12 = 0xc
	// - 1.50%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_13 = 0xd
	// - 1.75%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_14 = 0xe
	// - 2.00%
	PMU_REG_CORE_REG0_ADJ_REG0_ADJ_15 = 0xf
	// Position of REG1_TARG field.
	PMU_REG_CORE_REG1_TARG_Pos = 0x9
	// Bit mask of REG1_TARG field.
	PMU_REG_CORE_REG1_TARG_Msk = 0x3e00
	// Power gated off
	PMU_REG_CORE_REG1_TARG_REG1_TARG_0 = 0x0
	// Target core voltage = 0.725V
	PMU_REG_CORE_REG1_TARG_REG1_TARG_1 = 0x1
	// Target core voltage = 0.750V
	PMU_REG_CORE_REG1_TARG_REG1_TARG_2 = 0x2
	// Target core voltage = 0.775V
	PMU_REG_CORE_REG1_TARG_REG1_TARG_3 = 0x3
	// Target core voltage = 1.100V
	PMU_REG_CORE_REG1_TARG_REG1_TARG_16 = 0x10
	// Target core voltage = 1.450V
	PMU_REG_CORE_REG1_TARG_REG1_TARG_30 = 0x1e
	// Power FET switched full on. No regulation.
	PMU_REG_CORE_REG1_TARG_REG1_TARG_31 = 0x1f
	// Position of REG1_ADJ field.
	PMU_REG_CORE_REG1_ADJ_Pos = 0xe
	// Bit mask of REG1_ADJ field.
	PMU_REG_CORE_REG1_ADJ_Msk = 0x3c000
	// No adjustment
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_0 = 0x0
	// + 0.25%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_1 = 0x1
	// + 0.50%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_2 = 0x2
	// + 0.75%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_3 = 0x3
	// + 1.00%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_4 = 0x4
	// + 1.25%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_5 = 0x5
	// + 1.50%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_6 = 0x6
	// + 1.75%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_7 = 0x7
	// - 0.25%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_8 = 0x8
	// - 0.50%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_9 = 0x9
	// - 0.75%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_10 = 0xa
	// - 1.00%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_11 = 0xb
	// - 1.25%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_12 = 0xc
	// - 1.50%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_13 = 0xd
	// - 1.75%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_14 = 0xe
	// - 2.00%
	PMU_REG_CORE_REG1_ADJ_REG1_ADJ_15 = 0xf
	// Position of REG2_TARG field.
	PMU_REG_CORE_REG2_TARG_Pos = 0x12
	// Bit mask of REG2_TARG field.
	PMU_REG_CORE_REG2_TARG_Msk = 0x7c0000
	// Power gated off
	PMU_REG_CORE_REG2_TARG_REG2_TARG_0 = 0x0
	// Target core voltage = 0.725V
	PMU_REG_CORE_REG2_TARG_REG2_TARG_1 = 0x1
	// Target core voltage = 0.750V
	PMU_REG_CORE_REG2_TARG_REG2_TARG_2 = 0x2
	// Target core voltage = 0.775V
	PMU_REG_CORE_REG2_TARG_REG2_TARG_3 = 0x3
	// Target core voltage = 1.100V
	PMU_REG_CORE_REG2_TARG_REG2_TARG_16 = 0x10
	// Target core voltage = 1.450V
	PMU_REG_CORE_REG2_TARG_REG2_TARG_30 = 0x1e
	// Power FET switched full on. No regulation.
	PMU_REG_CORE_REG2_TARG_REG2_TARG_31 = 0x1f
	// Position of REG2_ADJ field.
	PMU_REG_CORE_REG2_ADJ_Pos = 0x17
	// Bit mask of REG2_ADJ field.
	PMU_REG_CORE_REG2_ADJ_Msk = 0x7800000
	// No adjustment
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_0 = 0x0
	// + 0.25%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_1 = 0x1
	// + 0.50%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_2 = 0x2
	// + 0.75%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_3 = 0x3
	// + 1.00%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_4 = 0x4
	// + 1.25%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_5 = 0x5
	// + 1.50%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_6 = 0x6
	// + 1.75%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_7 = 0x7
	// - 0.25%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_8 = 0x8
	// - 0.50%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_9 = 0x9
	// - 0.75%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_10 = 0xa
	// - 1.00%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_11 = 0xb
	// - 1.25%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_12 = 0xc
	// - 1.50%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_13 = 0xd
	// - 1.75%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_14 = 0xe
	// - 2.00%
	PMU_REG_CORE_REG2_ADJ_REG2_ADJ_15 = 0xf
	// Position of RAMP_RATE field.
	PMU_REG_CORE_RAMP_RATE_Pos = 0x1b
	// Bit mask of RAMP_RATE field.
	PMU_REG_CORE_RAMP_RATE_Msk = 0x18000000
	// Fast
	PMU_REG_CORE_RAMP_RATE_RAMP_RATE_0 = 0x0
	// Medium Fast
	PMU_REG_CORE_RAMP_RATE_RAMP_RATE_1 = 0x1
	// Medium Slow
	PMU_REG_CORE_RAMP_RATE_RAMP_RATE_2 = 0x2
	// Slow
	PMU_REG_CORE_RAMP_RATE_RAMP_RATE_3 = 0x3
	// Position of FET_ODRIVE field.
	PMU_REG_CORE_FET_ODRIVE_Pos = 0x1d
	// Bit mask of FET_ODRIVE field.
	PMU_REG_CORE_FET_ODRIVE_Msk = 0x20000000
	// Bit FET_ODRIVE.
	PMU_REG_CORE_FET_ODRIVE = 0x20000000

	// REG_CORE_SET: Digital Regulator Core Register
	// Position of REG0_TARG field.
	PMU_REG_CORE_SET_REG0_TARG_Pos = 0x0
	// Bit mask of REG0_TARG field.
	PMU_REG_CORE_SET_REG0_TARG_Msk = 0x1f
	// Power gated off
	PMU_REG_CORE_SET_REG0_TARG_REG0_TARG_0 = 0x0
	// Target core voltage = 0.725V
	PMU_REG_CORE_SET_REG0_TARG_REG0_TARG_1 = 0x1
	// Target core voltage = 0.750V
	PMU_REG_CORE_SET_REG0_TARG_REG0_TARG_2 = 0x2
	// Target core voltage = 0.775V
	PMU_REG_CORE_SET_REG0_TARG_REG0_TARG_3 = 0x3
	// Target core voltage = 1.100V
	PMU_REG_CORE_SET_REG0_TARG_REG0_TARG_16 = 0x10
	// Target core voltage = 1.450V
	PMU_REG_CORE_SET_REG0_TARG_REG0_TARG_30 = 0x1e
	// Power FET switched full on. No regulation.
	PMU_REG_CORE_SET_REG0_TARG_REG0_TARG_31 = 0x1f
	// Position of REG0_ADJ field.
	PMU_REG_CORE_SET_REG0_ADJ_Pos = 0x5
	// Bit mask of REG0_ADJ field.
	PMU_REG_CORE_SET_REG0_ADJ_Msk = 0x1e0
	// No adjustment
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_0 = 0x0
	// + 0.25%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_1 = 0x1
	// + 0.50%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_2 = 0x2
	// + 0.75%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_3 = 0x3
	// + 1.00%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_4 = 0x4
	// + 1.25%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_5 = 0x5
	// + 1.50%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_6 = 0x6
	// + 1.75%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_7 = 0x7
	// - 0.25%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_8 = 0x8
	// - 0.50%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_9 = 0x9
	// - 0.75%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_10 = 0xa
	// - 1.00%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_11 = 0xb
	// - 1.25%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_12 = 0xc
	// - 1.50%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_13 = 0xd
	// - 1.75%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_14 = 0xe
	// - 2.00%
	PMU_REG_CORE_SET_REG0_ADJ_REG0_ADJ_15 = 0xf
	// Position of REG1_TARG field.
	PMU_REG_CORE_SET_REG1_TARG_Pos = 0x9
	// Bit mask of REG1_TARG field.
	PMU_REG_CORE_SET_REG1_TARG_Msk = 0x3e00
	// Power gated off
	PMU_REG_CORE_SET_REG1_TARG_REG1_TARG_0 = 0x0
	// Target core voltage = 0.725V
	PMU_REG_CORE_SET_REG1_TARG_REG1_TARG_1 = 0x1
	// Target core voltage = 0.750V
	PMU_REG_CORE_SET_REG1_TARG_REG1_TARG_2 = 0x2
	// Target core voltage = 0.775V
	PMU_REG_CORE_SET_REG1_TARG_REG1_TARG_3 = 0x3
	// Target core voltage = 1.100V
	PMU_REG_CORE_SET_REG1_TARG_REG1_TARG_16 = 0x10
	// Target core voltage = 1.450V
	PMU_REG_CORE_SET_REG1_TARG_REG1_TARG_30 = 0x1e
	// Power FET switched full on. No regulation.
	PMU_REG_CORE_SET_REG1_TARG_REG1_TARG_31 = 0x1f
	// Position of REG1_ADJ field.
	PMU_REG_CORE_SET_REG1_ADJ_Pos = 0xe
	// Bit mask of REG1_ADJ field.
	PMU_REG_CORE_SET_REG1_ADJ_Msk = 0x3c000
	// No adjustment
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_0 = 0x0
	// + 0.25%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_1 = 0x1
	// + 0.50%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_2 = 0x2
	// + 0.75%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_3 = 0x3
	// + 1.00%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_4 = 0x4
	// + 1.25%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_5 = 0x5
	// + 1.50%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_6 = 0x6
	// + 1.75%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_7 = 0x7
	// - 0.25%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_8 = 0x8
	// - 0.50%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_9 = 0x9
	// - 0.75%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_10 = 0xa
	// - 1.00%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_11 = 0xb
	// - 1.25%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_12 = 0xc
	// - 1.50%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_13 = 0xd
	// - 1.75%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_14 = 0xe
	// - 2.00%
	PMU_REG_CORE_SET_REG1_ADJ_REG1_ADJ_15 = 0xf
	// Position of REG2_TARG field.
	PMU_REG_CORE_SET_REG2_TARG_Pos = 0x12
	// Bit mask of REG2_TARG field.
	PMU_REG_CORE_SET_REG2_TARG_Msk = 0x7c0000
	// Power gated off
	PMU_REG_CORE_SET_REG2_TARG_REG2_TARG_0 = 0x0
	// Target core voltage = 0.725V
	PMU_REG_CORE_SET_REG2_TARG_REG2_TARG_1 = 0x1
	// Target core voltage = 0.750V
	PMU_REG_CORE_SET_REG2_TARG_REG2_TARG_2 = 0x2
	// Target core voltage = 0.775V
	PMU_REG_CORE_SET_REG2_TARG_REG2_TARG_3 = 0x3
	// Target core voltage = 1.100V
	PMU_REG_CORE_SET_REG2_TARG_REG2_TARG_16 = 0x10
	// Target core voltage = 1.450V
	PMU_REG_CORE_SET_REG2_TARG_REG2_TARG_30 = 0x1e
	// Power FET switched full on. No regulation.
	PMU_REG_CORE_SET_REG2_TARG_REG2_TARG_31 = 0x1f
	// Position of REG2_ADJ field.
	PMU_REG_CORE_SET_REG2_ADJ_Pos = 0x17
	// Bit mask of REG2_ADJ field.
	PMU_REG_CORE_SET_REG2_ADJ_Msk = 0x7800000
	// No adjustment
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_0 = 0x0
	// + 0.25%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_1 = 0x1
	// + 0.50%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_2 = 0x2
	// + 0.75%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_3 = 0x3
	// + 1.00%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_4 = 0x4
	// + 1.25%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_5 = 0x5
	// + 1.50%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_6 = 0x6
	// + 1.75%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_7 = 0x7
	// - 0.25%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_8 = 0x8
	// - 0.50%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_9 = 0x9
	// - 0.75%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_10 = 0xa
	// - 1.00%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_11 = 0xb
	// - 1.25%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_12 = 0xc
	// - 1.50%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_13 = 0xd
	// - 1.75%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_14 = 0xe
	// - 2.00%
	PMU_REG_CORE_SET_REG2_ADJ_REG2_ADJ_15 = 0xf
	// Position of RAMP_RATE field.
	PMU_REG_CORE_SET_RAMP_RATE_Pos = 0x1b
	// Bit mask of RAMP_RATE field.
	PMU_REG_CORE_SET_RAMP_RATE_Msk = 0x18000000
	// Fast
	PMU_REG_CORE_SET_RAMP_RATE_RAMP_RATE_0 = 0x0
	// Medium Fast
	PMU_REG_CORE_SET_RAMP_RATE_RAMP_RATE_1 = 0x1
	// Medium Slow
	PMU_REG_CORE_SET_RAMP_RATE_RAMP_RATE_2 = 0x2
	// Slow
	PMU_REG_CORE_SET_RAMP_RATE_RAMP_RATE_3 = 0x3
	// Position of FET_ODRIVE field.
	PMU_REG_CORE_SET_FET_ODRIVE_Pos = 0x1d
	// Bit mask of FET_ODRIVE field.
	PMU_REG_CORE_SET_FET_ODRIVE_Msk = 0x20000000
	// Bit FET_ODRIVE.
	PMU_REG_CORE_SET_FET_ODRIVE = 0x20000000

	// REG_CORE_CLR: Digital Regulator Core Register
	// Position of REG0_TARG field.
	PMU_REG_CORE_CLR_REG0_TARG_Pos = 0x0
	// Bit mask of REG0_TARG field.
	PMU_REG_CORE_CLR_REG0_TARG_Msk = 0x1f
	// Power gated off
	PMU_REG_CORE_CLR_REG0_TARG_REG0_TARG_0 = 0x0
	// Target core voltage = 0.725V
	PMU_REG_CORE_CLR_REG0_TARG_REG0_TARG_1 = 0x1
	// Target core voltage = 0.750V
	PMU_REG_CORE_CLR_REG0_TARG_REG0_TARG_2 = 0x2
	// Target core voltage = 0.775V
	PMU_REG_CORE_CLR_REG0_TARG_REG0_TARG_3 = 0x3
	// Target core voltage = 1.100V
	PMU_REG_CORE_CLR_REG0_TARG_REG0_TARG_16 = 0x10
	// Target core voltage = 1.450V
	PMU_REG_CORE_CLR_REG0_TARG_REG0_TARG_30 = 0x1e
	// Power FET switched full on. No regulation.
	PMU_REG_CORE_CLR_REG0_TARG_REG0_TARG_31 = 0x1f
	// Position of REG0_ADJ field.
	PMU_REG_CORE_CLR_REG0_ADJ_Pos = 0x5
	// Bit mask of REG0_ADJ field.
	PMU_REG_CORE_CLR_REG0_ADJ_Msk = 0x1e0
	// No adjustment
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_0 = 0x0
	// + 0.25%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_1 = 0x1
	// + 0.50%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_2 = 0x2
	// + 0.75%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_3 = 0x3
	// + 1.00%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_4 = 0x4
	// + 1.25%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_5 = 0x5
	// + 1.50%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_6 = 0x6
	// + 1.75%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_7 = 0x7
	// - 0.25%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_8 = 0x8
	// - 0.50%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_9 = 0x9
	// - 0.75%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_10 = 0xa
	// - 1.00%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_11 = 0xb
	// - 1.25%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_12 = 0xc
	// - 1.50%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_13 = 0xd
	// - 1.75%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_14 = 0xe
	// - 2.00%
	PMU_REG_CORE_CLR_REG0_ADJ_REG0_ADJ_15 = 0xf
	// Position of REG1_TARG field.
	PMU_REG_CORE_CLR_REG1_TARG_Pos = 0x9
	// Bit mask of REG1_TARG field.
	PMU_REG_CORE_CLR_REG1_TARG_Msk = 0x3e00
	// Power gated off
	PMU_REG_CORE_CLR_REG1_TARG_REG1_TARG_0 = 0x0
	// Target core voltage = 0.725V
	PMU_REG_CORE_CLR_REG1_TARG_REG1_TARG_1 = 0x1
	// Target core voltage = 0.750V
	PMU_REG_CORE_CLR_REG1_TARG_REG1_TARG_2 = 0x2
	// Target core voltage = 0.775V
	PMU_REG_CORE_CLR_REG1_TARG_REG1_TARG_3 = 0x3
	// Target core voltage = 1.100V
	PMU_REG_CORE_CLR_REG1_TARG_REG1_TARG_16 = 0x10
	// Target core voltage = 1.450V
	PMU_REG_CORE_CLR_REG1_TARG_REG1_TARG_30 = 0x1e
	// Power FET switched full on. No regulation.
	PMU_REG_CORE_CLR_REG1_TARG_REG1_TARG_31 = 0x1f
	// Position of REG1_ADJ field.
	PMU_REG_CORE_CLR_REG1_ADJ_Pos = 0xe
	// Bit mask of REG1_ADJ field.
	PMU_REG_CORE_CLR_REG1_ADJ_Msk = 0x3c000
	// No adjustment
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_0 = 0x0
	// + 0.25%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_1 = 0x1
	// + 0.50%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_2 = 0x2
	// + 0.75%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_3 = 0x3
	// + 1.00%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_4 = 0x4
	// + 1.25%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_5 = 0x5
	// + 1.50%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_6 = 0x6
	// + 1.75%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_7 = 0x7
	// - 0.25%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_8 = 0x8
	// - 0.50%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_9 = 0x9
	// - 0.75%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_10 = 0xa
	// - 1.00%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_11 = 0xb
	// - 1.25%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_12 = 0xc
	// - 1.50%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_13 = 0xd
	// - 1.75%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_14 = 0xe
	// - 2.00%
	PMU_REG_CORE_CLR_REG1_ADJ_REG1_ADJ_15 = 0xf
	// Position of REG2_TARG field.
	PMU_REG_CORE_CLR_REG2_TARG_Pos = 0x12
	// Bit mask of REG2_TARG field.
	PMU_REG_CORE_CLR_REG2_TARG_Msk = 0x7c0000
	// Power gated off
	PMU_REG_CORE_CLR_REG2_TARG_REG2_TARG_0 = 0x0
	// Target core voltage = 0.725V
	PMU_REG_CORE_CLR_REG2_TARG_REG2_TARG_1 = 0x1
	// Target core voltage = 0.750V
	PMU_REG_CORE_CLR_REG2_TARG_REG2_TARG_2 = 0x2
	// Target core voltage = 0.775V
	PMU_REG_CORE_CLR_REG2_TARG_REG2_TARG_3 = 0x3
	// Target core voltage = 1.100V
	PMU_REG_CORE_CLR_REG2_TARG_REG2_TARG_16 = 0x10
	// Target core voltage = 1.450V
	PMU_REG_CORE_CLR_REG2_TARG_REG2_TARG_30 = 0x1e
	// Power FET switched full on. No regulation.
	PMU_REG_CORE_CLR_REG2_TARG_REG2_TARG_31 = 0x1f
	// Position of REG2_ADJ field.
	PMU_REG_CORE_CLR_REG2_ADJ_Pos = 0x17
	// Bit mask of REG2_ADJ field.
	PMU_REG_CORE_CLR_REG2_ADJ_Msk = 0x7800000
	// No adjustment
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_0 = 0x0
	// + 0.25%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_1 = 0x1
	// + 0.50%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_2 = 0x2
	// + 0.75%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_3 = 0x3
	// + 1.00%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_4 = 0x4
	// + 1.25%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_5 = 0x5
	// + 1.50%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_6 = 0x6
	// + 1.75%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_7 = 0x7
	// - 0.25%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_8 = 0x8
	// - 0.50%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_9 = 0x9
	// - 0.75%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_10 = 0xa
	// - 1.00%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_11 = 0xb
	// - 1.25%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_12 = 0xc
	// - 1.50%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_13 = 0xd
	// - 1.75%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_14 = 0xe
	// - 2.00%
	PMU_REG_CORE_CLR_REG2_ADJ_REG2_ADJ_15 = 0xf
	// Position of RAMP_RATE field.
	PMU_REG_CORE_CLR_RAMP_RATE_Pos = 0x1b
	// Bit mask of RAMP_RATE field.
	PMU_REG_CORE_CLR_RAMP_RATE_Msk = 0x18000000
	// Fast
	PMU_REG_CORE_CLR_RAMP_RATE_RAMP_RATE_0 = 0x0
	// Medium Fast
	PMU_REG_CORE_CLR_RAMP_RATE_RAMP_RATE_1 = 0x1
	// Medium Slow
	PMU_REG_CORE_CLR_RAMP_RATE_RAMP_RATE_2 = 0x2
	// Slow
	PMU_REG_CORE_CLR_RAMP_RATE_RAMP_RATE_3 = 0x3
	// Position of FET_ODRIVE field.
	PMU_REG_CORE_CLR_FET_ODRIVE_Pos = 0x1d
	// Bit mask of FET_ODRIVE field.
	PMU_REG_CORE_CLR_FET_ODRIVE_Msk = 0x20000000
	// Bit FET_ODRIVE.
	PMU_REG_CORE_CLR_FET_ODRIVE = 0x20000000

	// REG_CORE_TOG: Digital Regulator Core Register
	// Position of REG0_TARG field.
	PMU_REG_CORE_TOG_REG0_TARG_Pos = 0x0
	// Bit mask of REG0_TARG field.
	PMU_REG_CORE_TOG_REG0_TARG_Msk = 0x1f
	// Power gated off
	PMU_REG_CORE_TOG_REG0_TARG_REG0_TARG_0 = 0x0
	// Target core voltage = 0.725V
	PMU_REG_CORE_TOG_REG0_TARG_REG0_TARG_1 = 0x1
	// Target core voltage = 0.750V
	PMU_REG_CORE_TOG_REG0_TARG_REG0_TARG_2 = 0x2
	// Target core voltage = 0.775V
	PMU_REG_CORE_TOG_REG0_TARG_REG0_TARG_3 = 0x3
	// Target core voltage = 1.100V
	PMU_REG_CORE_TOG_REG0_TARG_REG0_TARG_16 = 0x10
	// Target core voltage = 1.450V
	PMU_REG_CORE_TOG_REG0_TARG_REG0_TARG_30 = 0x1e
	// Power FET switched full on. No regulation.
	PMU_REG_CORE_TOG_REG0_TARG_REG0_TARG_31 = 0x1f
	// Position of REG0_ADJ field.
	PMU_REG_CORE_TOG_REG0_ADJ_Pos = 0x5
	// Bit mask of REG0_ADJ field.
	PMU_REG_CORE_TOG_REG0_ADJ_Msk = 0x1e0
	// No adjustment
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_0 = 0x0
	// + 0.25%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_1 = 0x1
	// + 0.50%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_2 = 0x2
	// + 0.75%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_3 = 0x3
	// + 1.00%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_4 = 0x4
	// + 1.25%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_5 = 0x5
	// + 1.50%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_6 = 0x6
	// + 1.75%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_7 = 0x7
	// - 0.25%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_8 = 0x8
	// - 0.50%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_9 = 0x9
	// - 0.75%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_10 = 0xa
	// - 1.00%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_11 = 0xb
	// - 1.25%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_12 = 0xc
	// - 1.50%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_13 = 0xd
	// - 1.75%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_14 = 0xe
	// - 2.00%
	PMU_REG_CORE_TOG_REG0_ADJ_REG0_ADJ_15 = 0xf
	// Position of REG1_TARG field.
	PMU_REG_CORE_TOG_REG1_TARG_Pos = 0x9
	// Bit mask of REG1_TARG field.
	PMU_REG_CORE_TOG_REG1_TARG_Msk = 0x3e00
	// Power gated off
	PMU_REG_CORE_TOG_REG1_TARG_REG1_TARG_0 = 0x0
	// Target core voltage = 0.725V
	PMU_REG_CORE_TOG_REG1_TARG_REG1_TARG_1 = 0x1
	// Target core voltage = 0.750V
	PMU_REG_CORE_TOG_REG1_TARG_REG1_TARG_2 = 0x2
	// Target core voltage = 0.775V
	PMU_REG_CORE_TOG_REG1_TARG_REG1_TARG_3 = 0x3
	// Target core voltage = 1.100V
	PMU_REG_CORE_TOG_REG1_TARG_REG1_TARG_16 = 0x10
	// Target core voltage = 1.450V
	PMU_REG_CORE_TOG_REG1_TARG_REG1_TARG_30 = 0x1e
	// Power FET switched full on. No regulation.
	PMU_REG_CORE_TOG_REG1_TARG_REG1_TARG_31 = 0x1f
	// Position of REG1_ADJ field.
	PMU_REG_CORE_TOG_REG1_ADJ_Pos = 0xe
	// Bit mask of REG1_ADJ field.
	PMU_REG_CORE_TOG_REG1_ADJ_Msk = 0x3c000
	// No adjustment
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_0 = 0x0
	// + 0.25%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_1 = 0x1
	// + 0.50%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_2 = 0x2
	// + 0.75%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_3 = 0x3
	// + 1.00%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_4 = 0x4
	// + 1.25%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_5 = 0x5
	// + 1.50%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_6 = 0x6
	// + 1.75%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_7 = 0x7
	// - 0.25%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_8 = 0x8
	// - 0.50%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_9 = 0x9
	// - 0.75%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_10 = 0xa
	// - 1.00%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_11 = 0xb
	// - 1.25%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_12 = 0xc
	// - 1.50%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_13 = 0xd
	// - 1.75%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_14 = 0xe
	// - 2.00%
	PMU_REG_CORE_TOG_REG1_ADJ_REG1_ADJ_15 = 0xf
	// Position of REG2_TARG field.
	PMU_REG_CORE_TOG_REG2_TARG_Pos = 0x12
	// Bit mask of REG2_TARG field.
	PMU_REG_CORE_TOG_REG2_TARG_Msk = 0x7c0000
	// Power gated off
	PMU_REG_CORE_TOG_REG2_TARG_REG2_TARG_0 = 0x0
	// Target core voltage = 0.725V
	PMU_REG_CORE_TOG_REG2_TARG_REG2_TARG_1 = 0x1
	// Target core voltage = 0.750V
	PMU_REG_CORE_TOG_REG2_TARG_REG2_TARG_2 = 0x2
	// Target core voltage = 0.775V
	PMU_REG_CORE_TOG_REG2_TARG_REG2_TARG_3 = 0x3
	// Target core voltage = 1.100V
	PMU_REG_CORE_TOG_REG2_TARG_REG2_TARG_16 = 0x10
	// Target core voltage = 1.450V
	PMU_REG_CORE_TOG_REG2_TARG_REG2_TARG_30 = 0x1e
	// Power FET switched full on. No regulation.
	PMU_REG_CORE_TOG_REG2_TARG_REG2_TARG_31 = 0x1f
	// Position of REG2_ADJ field.
	PMU_REG_CORE_TOG_REG2_ADJ_Pos = 0x17
	// Bit mask of REG2_ADJ field.
	PMU_REG_CORE_TOG_REG2_ADJ_Msk = 0x7800000
	// No adjustment
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_0 = 0x0
	// + 0.25%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_1 = 0x1
	// + 0.50%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_2 = 0x2
	// + 0.75%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_3 = 0x3
	// + 1.00%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_4 = 0x4
	// + 1.25%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_5 = 0x5
	// + 1.50%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_6 = 0x6
	// + 1.75%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_7 = 0x7
	// - 0.25%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_8 = 0x8
	// - 0.50%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_9 = 0x9
	// - 0.75%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_10 = 0xa
	// - 1.00%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_11 = 0xb
	// - 1.25%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_12 = 0xc
	// - 1.50%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_13 = 0xd
	// - 1.75%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_14 = 0xe
	// - 2.00%
	PMU_REG_CORE_TOG_REG2_ADJ_REG2_ADJ_15 = 0xf
	// Position of RAMP_RATE field.
	PMU_REG_CORE_TOG_RAMP_RATE_Pos = 0x1b
	// Bit mask of RAMP_RATE field.
	PMU_REG_CORE_TOG_RAMP_RATE_Msk = 0x18000000
	// Fast
	PMU_REG_CORE_TOG_RAMP_RATE_RAMP_RATE_0 = 0x0
	// Medium Fast
	PMU_REG_CORE_TOG_RAMP_RATE_RAMP_RATE_1 = 0x1
	// Medium Slow
	PMU_REG_CORE_TOG_RAMP_RATE_RAMP_RATE_2 = 0x2
	// Slow
	PMU_REG_CORE_TOG_RAMP_RATE_RAMP_RATE_3 = 0x3
	// Position of FET_ODRIVE field.
	PMU_REG_CORE_TOG_FET_ODRIVE_Pos = 0x1d
	// Bit mask of FET_ODRIVE field.
	PMU_REG_CORE_TOG_FET_ODRIVE_Msk = 0x20000000
	// Bit FET_ODRIVE.
	PMU_REG_CORE_TOG_FET_ODRIVE = 0x20000000

	// MISC0: Miscellaneous Register 0
	// Position of REFTOP_PWD field.
	PMU_MISC0_REFTOP_PWD_Pos = 0x0
	// Bit mask of REFTOP_PWD field.
	PMU_MISC0_REFTOP_PWD_Msk = 0x1
	// Bit REFTOP_PWD.
	PMU_MISC0_REFTOP_PWD = 0x1
	// Position of REFTOP_PWDVBGUP field.
	PMU_MISC0_REFTOP_PWDVBGUP_Pos = 0x1
	// Bit mask of REFTOP_PWDVBGUP field.
	PMU_MISC0_REFTOP_PWDVBGUP_Msk = 0x2
	// Bit REFTOP_PWDVBGUP.
	PMU_MISC0_REFTOP_PWDVBGUP = 0x2
	// Position of REFTOP_LOWPOWER field.
	PMU_MISC0_REFTOP_LOWPOWER_Pos = 0x2
	// Bit mask of REFTOP_LOWPOWER field.
	PMU_MISC0_REFTOP_LOWPOWER_Msk = 0x4
	// Bit REFTOP_LOWPOWER.
	PMU_MISC0_REFTOP_LOWPOWER = 0x4
	// Position of REFTOP_SELFBIASOFF field.
	PMU_MISC0_REFTOP_SELFBIASOFF_Pos = 0x3
	// Bit mask of REFTOP_SELFBIASOFF field.
	PMU_MISC0_REFTOP_SELFBIASOFF_Msk = 0x8
	// Bit REFTOP_SELFBIASOFF.
	PMU_MISC0_REFTOP_SELFBIASOFF = 0x8
	// Uses coarse bias currents for startup
	PMU_MISC0_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_0 = 0x0
	// Uses bandgap-based bias currents for best performance.
	PMU_MISC0_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_1 = 0x1
	// Position of REFTOP_VBGADJ field.
	PMU_MISC0_REFTOP_VBGADJ_Pos = 0x4
	// Bit mask of REFTOP_VBGADJ field.
	PMU_MISC0_REFTOP_VBGADJ_Msk = 0x70
	// Nominal VBG
	PMU_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_0 = 0x0
	// VBG+0.78%
	PMU_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_1 = 0x1
	// VBG+1.56%
	PMU_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_2 = 0x2
	// VBG+2.34%
	PMU_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_3 = 0x3
	// VBG-0.78%
	PMU_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_4 = 0x4
	// VBG-1.56%
	PMU_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_5 = 0x5
	// VBG-2.34%
	PMU_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_6 = 0x6
	// VBG-3.12%
	PMU_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_7 = 0x7
	// Position of REFTOP_VBGUP field.
	PMU_MISC0_REFTOP_VBGUP_Pos = 0x7
	// Bit mask of REFTOP_VBGUP field.
	PMU_MISC0_REFTOP_VBGUP_Msk = 0x80
	// Bit REFTOP_VBGUP.
	PMU_MISC0_REFTOP_VBGUP = 0x80
	// Position of STOP_MODE_CONFIG field.
	PMU_MISC0_STOP_MODE_CONFIG_Pos = 0xa
	// Bit mask of STOP_MODE_CONFIG field.
	PMU_MISC0_STOP_MODE_CONFIG_Msk = 0xc00
	// SUSPEND (DSM)
	PMU_MISC0_STOP_MODE_CONFIG_STOP_MODE_CONFIG_0 = 0x0
	// Analog regulators are ON.
	PMU_MISC0_STOP_MODE_CONFIG_STANDBY = 0x1
	// STOP (lower power)
	PMU_MISC0_STOP_MODE_CONFIG_STOP_MODE_CONFIG_2 = 0x2
	// STOP (very lower power)
	PMU_MISC0_STOP_MODE_CONFIG_STOP_MODE_CONFIG_3 = 0x3
	// Position of DISCON_HIGH_SNVS field.
	PMU_MISC0_DISCON_HIGH_SNVS_Pos = 0xc
	// Bit mask of DISCON_HIGH_SNVS field.
	PMU_MISC0_DISCON_HIGH_SNVS_Msk = 0x1000
	// Bit DISCON_HIGH_SNVS.
	PMU_MISC0_DISCON_HIGH_SNVS = 0x1000
	// Turn on the switch
	PMU_MISC0_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_0 = 0x0
	// Turn off the switch
	PMU_MISC0_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_1 = 0x1
	// Position of OSC_I field.
	PMU_MISC0_OSC_I_Pos = 0xd
	// Bit mask of OSC_I field.
	PMU_MISC0_OSC_I_Msk = 0x6000
	// Nominal
	PMU_MISC0_OSC_I_NOMINAL = 0x0
	// Decrease current by 12.5%
	PMU_MISC0_OSC_I_MINUS_12_5_PERCENT = 0x1
	// Decrease current by 25.0%
	PMU_MISC0_OSC_I_MINUS_25_PERCENT = 0x2
	// Decrease current by 37.5%
	PMU_MISC0_OSC_I_MINUS_37_5_PERCENT = 0x3
	// Position of OSC_XTALOK field.
	PMU_MISC0_OSC_XTALOK_Pos = 0xf
	// Bit mask of OSC_XTALOK field.
	PMU_MISC0_OSC_XTALOK_Msk = 0x8000
	// Bit OSC_XTALOK.
	PMU_MISC0_OSC_XTALOK = 0x8000
	// Position of OSC_XTALOK_EN field.
	PMU_MISC0_OSC_XTALOK_EN_Pos = 0x10
	// Bit mask of OSC_XTALOK_EN field.
	PMU_MISC0_OSC_XTALOK_EN_Msk = 0x10000
	// Bit OSC_XTALOK_EN.
	PMU_MISC0_OSC_XTALOK_EN = 0x10000
	// Position of CLKGATE_CTRL field.
	PMU_MISC0_CLKGATE_CTRL_Pos = 0x19
	// Bit mask of CLKGATE_CTRL field.
	PMU_MISC0_CLKGATE_CTRL_Msk = 0x2000000
	// Bit CLKGATE_CTRL.
	PMU_MISC0_CLKGATE_CTRL = 0x2000000
	// Allow the logic to automatically gate the clock when the XTAL is powered down.
	PMU_MISC0_CLKGATE_CTRL_ALLOW_AUTO_GATE = 0x0
	// Prevent the logic from ever gating off the clock.
	PMU_MISC0_CLKGATE_CTRL_NO_AUTO_GATE = 0x1
	// Position of CLKGATE_DELAY field.
	PMU_MISC0_CLKGATE_DELAY_Pos = 0x1a
	// Bit mask of CLKGATE_DELAY field.
	PMU_MISC0_CLKGATE_DELAY_Msk = 0x1c000000
	// 0.5ms
	PMU_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_0 = 0x0
	// 1.0ms
	PMU_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_1 = 0x1
	// 2.0ms
	PMU_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_2 = 0x2
	// 3.0ms
	PMU_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_3 = 0x3
	// 4.0ms
	PMU_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_4 = 0x4
	// 5.0ms
	PMU_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_5 = 0x5
	// 6.0ms
	PMU_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_6 = 0x6
	// 7.0ms
	PMU_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_7 = 0x7
	// Position of RTC_XTAL_SOURCE field.
	PMU_MISC0_RTC_XTAL_SOURCE_Pos = 0x1d
	// Bit mask of RTC_XTAL_SOURCE field.
	PMU_MISC0_RTC_XTAL_SOURCE_Msk = 0x20000000
	// Bit RTC_XTAL_SOURCE.
	PMU_MISC0_RTC_XTAL_SOURCE = 0x20000000
	// Internal ring oscillator
	PMU_MISC0_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_0 = 0x0
	// RTC_XTAL
	PMU_MISC0_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_1 = 0x1
	// Position of XTAL_24M_PWD field.
	PMU_MISC0_XTAL_24M_PWD_Pos = 0x1e
	// Bit mask of XTAL_24M_PWD field.
	PMU_MISC0_XTAL_24M_PWD_Msk = 0x40000000
	// Bit XTAL_24M_PWD.
	PMU_MISC0_XTAL_24M_PWD = 0x40000000

	// MISC0_SET: Miscellaneous Register 0
	// Position of REFTOP_PWD field.
	PMU_MISC0_SET_REFTOP_PWD_Pos = 0x0
	// Bit mask of REFTOP_PWD field.
	PMU_MISC0_SET_REFTOP_PWD_Msk = 0x1
	// Bit REFTOP_PWD.
	PMU_MISC0_SET_REFTOP_PWD = 0x1
	// Position of REFTOP_PWDVBGUP field.
	PMU_MISC0_SET_REFTOP_PWDVBGUP_Pos = 0x1
	// Bit mask of REFTOP_PWDVBGUP field.
	PMU_MISC0_SET_REFTOP_PWDVBGUP_Msk = 0x2
	// Bit REFTOP_PWDVBGUP.
	PMU_MISC0_SET_REFTOP_PWDVBGUP = 0x2
	// Position of REFTOP_LOWPOWER field.
	PMU_MISC0_SET_REFTOP_LOWPOWER_Pos = 0x2
	// Bit mask of REFTOP_LOWPOWER field.
	PMU_MISC0_SET_REFTOP_LOWPOWER_Msk = 0x4
	// Bit REFTOP_LOWPOWER.
	PMU_MISC0_SET_REFTOP_LOWPOWER = 0x4
	// Position of REFTOP_SELFBIASOFF field.
	PMU_MISC0_SET_REFTOP_SELFBIASOFF_Pos = 0x3
	// Bit mask of REFTOP_SELFBIASOFF field.
	PMU_MISC0_SET_REFTOP_SELFBIASOFF_Msk = 0x8
	// Bit REFTOP_SELFBIASOFF.
	PMU_MISC0_SET_REFTOP_SELFBIASOFF = 0x8
	// Uses coarse bias currents for startup
	PMU_MISC0_SET_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_0 = 0x0
	// Uses bandgap-based bias currents for best performance.
	PMU_MISC0_SET_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_1 = 0x1
	// Position of REFTOP_VBGADJ field.
	PMU_MISC0_SET_REFTOP_VBGADJ_Pos = 0x4
	// Bit mask of REFTOP_VBGADJ field.
	PMU_MISC0_SET_REFTOP_VBGADJ_Msk = 0x70
	// Nominal VBG
	PMU_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_0 = 0x0
	// VBG+0.78%
	PMU_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_1 = 0x1
	// VBG+1.56%
	PMU_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_2 = 0x2
	// VBG+2.34%
	PMU_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_3 = 0x3
	// VBG-0.78%
	PMU_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_4 = 0x4
	// VBG-1.56%
	PMU_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_5 = 0x5
	// VBG-2.34%
	PMU_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_6 = 0x6
	// VBG-3.12%
	PMU_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_7 = 0x7
	// Position of REFTOP_VBGUP field.
	PMU_MISC0_SET_REFTOP_VBGUP_Pos = 0x7
	// Bit mask of REFTOP_VBGUP field.
	PMU_MISC0_SET_REFTOP_VBGUP_Msk = 0x80
	// Bit REFTOP_VBGUP.
	PMU_MISC0_SET_REFTOP_VBGUP = 0x80
	// Position of STOP_MODE_CONFIG field.
	PMU_MISC0_SET_STOP_MODE_CONFIG_Pos = 0xa
	// Bit mask of STOP_MODE_CONFIG field.
	PMU_MISC0_SET_STOP_MODE_CONFIG_Msk = 0xc00
	// SUSPEND (DSM)
	PMU_MISC0_SET_STOP_MODE_CONFIG_STOP_MODE_CONFIG_0 = 0x0
	// Analog regulators are ON.
	PMU_MISC0_SET_STOP_MODE_CONFIG_STANDBY = 0x1
	// STOP (lower power)
	PMU_MISC0_SET_STOP_MODE_CONFIG_STOP_MODE_CONFIG_2 = 0x2
	// STOP (very lower power)
	PMU_MISC0_SET_STOP_MODE_CONFIG_STOP_MODE_CONFIG_3 = 0x3
	// Position of DISCON_HIGH_SNVS field.
	PMU_MISC0_SET_DISCON_HIGH_SNVS_Pos = 0xc
	// Bit mask of DISCON_HIGH_SNVS field.
	PMU_MISC0_SET_DISCON_HIGH_SNVS_Msk = 0x1000
	// Bit DISCON_HIGH_SNVS.
	PMU_MISC0_SET_DISCON_HIGH_SNVS = 0x1000
	// Turn on the switch
	PMU_MISC0_SET_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_0 = 0x0
	// Turn off the switch
	PMU_MISC0_SET_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_1 = 0x1
	// Position of OSC_I field.
	PMU_MISC0_SET_OSC_I_Pos = 0xd
	// Bit mask of OSC_I field.
	PMU_MISC0_SET_OSC_I_Msk = 0x6000
	// Nominal
	PMU_MISC0_SET_OSC_I_NOMINAL = 0x0
	// Decrease current by 12.5%
	PMU_MISC0_SET_OSC_I_MINUS_12_5_PERCENT = 0x1
	// Decrease current by 25.0%
	PMU_MISC0_SET_OSC_I_MINUS_25_PERCENT = 0x2
	// Decrease current by 37.5%
	PMU_MISC0_SET_OSC_I_MINUS_37_5_PERCENT = 0x3
	// Position of OSC_XTALOK field.
	PMU_MISC0_SET_OSC_XTALOK_Pos = 0xf
	// Bit mask of OSC_XTALOK field.
	PMU_MISC0_SET_OSC_XTALOK_Msk = 0x8000
	// Bit OSC_XTALOK.
	PMU_MISC0_SET_OSC_XTALOK = 0x8000
	// Position of OSC_XTALOK_EN field.
	PMU_MISC0_SET_OSC_XTALOK_EN_Pos = 0x10
	// Bit mask of OSC_XTALOK_EN field.
	PMU_MISC0_SET_OSC_XTALOK_EN_Msk = 0x10000
	// Bit OSC_XTALOK_EN.
	PMU_MISC0_SET_OSC_XTALOK_EN = 0x10000
	// Position of CLKGATE_CTRL field.
	PMU_MISC0_SET_CLKGATE_CTRL_Pos = 0x19
	// Bit mask of CLKGATE_CTRL field.
	PMU_MISC0_SET_CLKGATE_CTRL_Msk = 0x2000000
	// Bit CLKGATE_CTRL.
	PMU_MISC0_SET_CLKGATE_CTRL = 0x2000000
	// Allow the logic to automatically gate the clock when the XTAL is powered down.
	PMU_MISC0_SET_CLKGATE_CTRL_ALLOW_AUTO_GATE = 0x0
	// Prevent the logic from ever gating off the clock.
	PMU_MISC0_SET_CLKGATE_CTRL_NO_AUTO_GATE = 0x1
	// Position of CLKGATE_DELAY field.
	PMU_MISC0_SET_CLKGATE_DELAY_Pos = 0x1a
	// Bit mask of CLKGATE_DELAY field.
	PMU_MISC0_SET_CLKGATE_DELAY_Msk = 0x1c000000
	// 0.5ms
	PMU_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_0 = 0x0
	// 1.0ms
	PMU_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_1 = 0x1
	// 2.0ms
	PMU_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_2 = 0x2
	// 3.0ms
	PMU_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_3 = 0x3
	// 4.0ms
	PMU_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_4 = 0x4
	// 5.0ms
	PMU_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_5 = 0x5
	// 6.0ms
	PMU_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_6 = 0x6
	// 7.0ms
	PMU_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_7 = 0x7
	// Position of RTC_XTAL_SOURCE field.
	PMU_MISC0_SET_RTC_XTAL_SOURCE_Pos = 0x1d
	// Bit mask of RTC_XTAL_SOURCE field.
	PMU_MISC0_SET_RTC_XTAL_SOURCE_Msk = 0x20000000
	// Bit RTC_XTAL_SOURCE.
	PMU_MISC0_SET_RTC_XTAL_SOURCE = 0x20000000
	// Internal ring oscillator
	PMU_MISC0_SET_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_0 = 0x0
	// RTC_XTAL
	PMU_MISC0_SET_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_1 = 0x1
	// Position of XTAL_24M_PWD field.
	PMU_MISC0_SET_XTAL_24M_PWD_Pos = 0x1e
	// Bit mask of XTAL_24M_PWD field.
	PMU_MISC0_SET_XTAL_24M_PWD_Msk = 0x40000000
	// Bit XTAL_24M_PWD.
	PMU_MISC0_SET_XTAL_24M_PWD = 0x40000000

	// MISC0_CLR: Miscellaneous Register 0
	// Position of REFTOP_PWD field.
	PMU_MISC0_CLR_REFTOP_PWD_Pos = 0x0
	// Bit mask of REFTOP_PWD field.
	PMU_MISC0_CLR_REFTOP_PWD_Msk = 0x1
	// Bit REFTOP_PWD.
	PMU_MISC0_CLR_REFTOP_PWD = 0x1
	// Position of REFTOP_PWDVBGUP field.
	PMU_MISC0_CLR_REFTOP_PWDVBGUP_Pos = 0x1
	// Bit mask of REFTOP_PWDVBGUP field.
	PMU_MISC0_CLR_REFTOP_PWDVBGUP_Msk = 0x2
	// Bit REFTOP_PWDVBGUP.
	PMU_MISC0_CLR_REFTOP_PWDVBGUP = 0x2
	// Position of REFTOP_LOWPOWER field.
	PMU_MISC0_CLR_REFTOP_LOWPOWER_Pos = 0x2
	// Bit mask of REFTOP_LOWPOWER field.
	PMU_MISC0_CLR_REFTOP_LOWPOWER_Msk = 0x4
	// Bit REFTOP_LOWPOWER.
	PMU_MISC0_CLR_REFTOP_LOWPOWER = 0x4
	// Position of REFTOP_SELFBIASOFF field.
	PMU_MISC0_CLR_REFTOP_SELFBIASOFF_Pos = 0x3
	// Bit mask of REFTOP_SELFBIASOFF field.
	PMU_MISC0_CLR_REFTOP_SELFBIASOFF_Msk = 0x8
	// Bit REFTOP_SELFBIASOFF.
	PMU_MISC0_CLR_REFTOP_SELFBIASOFF = 0x8
	// Uses coarse bias currents for startup
	PMU_MISC0_CLR_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_0 = 0x0
	// Uses bandgap-based bias currents for best performance.
	PMU_MISC0_CLR_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_1 = 0x1
	// Position of REFTOP_VBGADJ field.
	PMU_MISC0_CLR_REFTOP_VBGADJ_Pos = 0x4
	// Bit mask of REFTOP_VBGADJ field.
	PMU_MISC0_CLR_REFTOP_VBGADJ_Msk = 0x70
	// Nominal VBG
	PMU_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_0 = 0x0
	// VBG+0.78%
	PMU_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_1 = 0x1
	// VBG+1.56%
	PMU_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_2 = 0x2
	// VBG+2.34%
	PMU_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_3 = 0x3
	// VBG-0.78%
	PMU_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_4 = 0x4
	// VBG-1.56%
	PMU_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_5 = 0x5
	// VBG-2.34%
	PMU_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_6 = 0x6
	// VBG-3.12%
	PMU_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_7 = 0x7
	// Position of REFTOP_VBGUP field.
	PMU_MISC0_CLR_REFTOP_VBGUP_Pos = 0x7
	// Bit mask of REFTOP_VBGUP field.
	PMU_MISC0_CLR_REFTOP_VBGUP_Msk = 0x80
	// Bit REFTOP_VBGUP.
	PMU_MISC0_CLR_REFTOP_VBGUP = 0x80
	// Position of STOP_MODE_CONFIG field.
	PMU_MISC0_CLR_STOP_MODE_CONFIG_Pos = 0xa
	// Bit mask of STOP_MODE_CONFIG field.
	PMU_MISC0_CLR_STOP_MODE_CONFIG_Msk = 0xc00
	// SUSPEND (DSM)
	PMU_MISC0_CLR_STOP_MODE_CONFIG_STOP_MODE_CONFIG_0 = 0x0
	// Analog regulators are ON.
	PMU_MISC0_CLR_STOP_MODE_CONFIG_STANDBY = 0x1
	// STOP (lower power)
	PMU_MISC0_CLR_STOP_MODE_CONFIG_STOP_MODE_CONFIG_2 = 0x2
	// STOP (very lower power)
	PMU_MISC0_CLR_STOP_MODE_CONFIG_STOP_MODE_CONFIG_3 = 0x3
	// Position of DISCON_HIGH_SNVS field.
	PMU_MISC0_CLR_DISCON_HIGH_SNVS_Pos = 0xc
	// Bit mask of DISCON_HIGH_SNVS field.
	PMU_MISC0_CLR_DISCON_HIGH_SNVS_Msk = 0x1000
	// Bit DISCON_HIGH_SNVS.
	PMU_MISC0_CLR_DISCON_HIGH_SNVS = 0x1000
	// Turn on the switch
	PMU_MISC0_CLR_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_0 = 0x0
	// Turn off the switch
	PMU_MISC0_CLR_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_1 = 0x1
	// Position of OSC_I field.
	PMU_MISC0_CLR_OSC_I_Pos = 0xd
	// Bit mask of OSC_I field.
	PMU_MISC0_CLR_OSC_I_Msk = 0x6000
	// Nominal
	PMU_MISC0_CLR_OSC_I_NOMINAL = 0x0
	// Decrease current by 12.5%
	PMU_MISC0_CLR_OSC_I_MINUS_12_5_PERCENT = 0x1
	// Decrease current by 25.0%
	PMU_MISC0_CLR_OSC_I_MINUS_25_PERCENT = 0x2
	// Decrease current by 37.5%
	PMU_MISC0_CLR_OSC_I_MINUS_37_5_PERCENT = 0x3
	// Position of OSC_XTALOK field.
	PMU_MISC0_CLR_OSC_XTALOK_Pos = 0xf
	// Bit mask of OSC_XTALOK field.
	PMU_MISC0_CLR_OSC_XTALOK_Msk = 0x8000
	// Bit OSC_XTALOK.
	PMU_MISC0_CLR_OSC_XTALOK = 0x8000
	// Position of OSC_XTALOK_EN field.
	PMU_MISC0_CLR_OSC_XTALOK_EN_Pos = 0x10
	// Bit mask of OSC_XTALOK_EN field.
	PMU_MISC0_CLR_OSC_XTALOK_EN_Msk = 0x10000
	// Bit OSC_XTALOK_EN.
	PMU_MISC0_CLR_OSC_XTALOK_EN = 0x10000
	// Position of CLKGATE_CTRL field.
	PMU_MISC0_CLR_CLKGATE_CTRL_Pos = 0x19
	// Bit mask of CLKGATE_CTRL field.
	PMU_MISC0_CLR_CLKGATE_CTRL_Msk = 0x2000000
	// Bit CLKGATE_CTRL.
	PMU_MISC0_CLR_CLKGATE_CTRL = 0x2000000
	// Allow the logic to automatically gate the clock when the XTAL is powered down.
	PMU_MISC0_CLR_CLKGATE_CTRL_ALLOW_AUTO_GATE = 0x0
	// Prevent the logic from ever gating off the clock.
	PMU_MISC0_CLR_CLKGATE_CTRL_NO_AUTO_GATE = 0x1
	// Position of CLKGATE_DELAY field.
	PMU_MISC0_CLR_CLKGATE_DELAY_Pos = 0x1a
	// Bit mask of CLKGATE_DELAY field.
	PMU_MISC0_CLR_CLKGATE_DELAY_Msk = 0x1c000000
	// 0.5ms
	PMU_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_0 = 0x0
	// 1.0ms
	PMU_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_1 = 0x1
	// 2.0ms
	PMU_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_2 = 0x2
	// 3.0ms
	PMU_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_3 = 0x3
	// 4.0ms
	PMU_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_4 = 0x4
	// 5.0ms
	PMU_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_5 = 0x5
	// 6.0ms
	PMU_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_6 = 0x6
	// 7.0ms
	PMU_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_7 = 0x7
	// Position of RTC_XTAL_SOURCE field.
	PMU_MISC0_CLR_RTC_XTAL_SOURCE_Pos = 0x1d
	// Bit mask of RTC_XTAL_SOURCE field.
	PMU_MISC0_CLR_RTC_XTAL_SOURCE_Msk = 0x20000000
	// Bit RTC_XTAL_SOURCE.
	PMU_MISC0_CLR_RTC_XTAL_SOURCE = 0x20000000
	// Internal ring oscillator
	PMU_MISC0_CLR_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_0 = 0x0
	// RTC_XTAL
	PMU_MISC0_CLR_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_1 = 0x1
	// Position of XTAL_24M_PWD field.
	PMU_MISC0_CLR_XTAL_24M_PWD_Pos = 0x1e
	// Bit mask of XTAL_24M_PWD field.
	PMU_MISC0_CLR_XTAL_24M_PWD_Msk = 0x40000000
	// Bit XTAL_24M_PWD.
	PMU_MISC0_CLR_XTAL_24M_PWD = 0x40000000

	// MISC0_TOG: Miscellaneous Register 0
	// Position of REFTOP_PWD field.
	PMU_MISC0_TOG_REFTOP_PWD_Pos = 0x0
	// Bit mask of REFTOP_PWD field.
	PMU_MISC0_TOG_REFTOP_PWD_Msk = 0x1
	// Bit REFTOP_PWD.
	PMU_MISC0_TOG_REFTOP_PWD = 0x1
	// Position of REFTOP_PWDVBGUP field.
	PMU_MISC0_TOG_REFTOP_PWDVBGUP_Pos = 0x1
	// Bit mask of REFTOP_PWDVBGUP field.
	PMU_MISC0_TOG_REFTOP_PWDVBGUP_Msk = 0x2
	// Bit REFTOP_PWDVBGUP.
	PMU_MISC0_TOG_REFTOP_PWDVBGUP = 0x2
	// Position of REFTOP_LOWPOWER field.
	PMU_MISC0_TOG_REFTOP_LOWPOWER_Pos = 0x2
	// Bit mask of REFTOP_LOWPOWER field.
	PMU_MISC0_TOG_REFTOP_LOWPOWER_Msk = 0x4
	// Bit REFTOP_LOWPOWER.
	PMU_MISC0_TOG_REFTOP_LOWPOWER = 0x4
	// Position of REFTOP_SELFBIASOFF field.
	PMU_MISC0_TOG_REFTOP_SELFBIASOFF_Pos = 0x3
	// Bit mask of REFTOP_SELFBIASOFF field.
	PMU_MISC0_TOG_REFTOP_SELFBIASOFF_Msk = 0x8
	// Bit REFTOP_SELFBIASOFF.
	PMU_MISC0_TOG_REFTOP_SELFBIASOFF = 0x8
	// Uses coarse bias currents for startup
	PMU_MISC0_TOG_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_0 = 0x0
	// Uses bandgap-based bias currents for best performance.
	PMU_MISC0_TOG_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_1 = 0x1
	// Position of REFTOP_VBGADJ field.
	PMU_MISC0_TOG_REFTOP_VBGADJ_Pos = 0x4
	// Bit mask of REFTOP_VBGADJ field.
	PMU_MISC0_TOG_REFTOP_VBGADJ_Msk = 0x70
	// Nominal VBG
	PMU_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_0 = 0x0
	// VBG+0.78%
	PMU_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_1 = 0x1
	// VBG+1.56%
	PMU_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_2 = 0x2
	// VBG+2.34%
	PMU_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_3 = 0x3
	// VBG-0.78%
	PMU_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_4 = 0x4
	// VBG-1.56%
	PMU_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_5 = 0x5
	// VBG-2.34%
	PMU_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_6 = 0x6
	// VBG-3.12%
	PMU_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_7 = 0x7
	// Position of REFTOP_VBGUP field.
	PMU_MISC0_TOG_REFTOP_VBGUP_Pos = 0x7
	// Bit mask of REFTOP_VBGUP field.
	PMU_MISC0_TOG_REFTOP_VBGUP_Msk = 0x80
	// Bit REFTOP_VBGUP.
	PMU_MISC0_TOG_REFTOP_VBGUP = 0x80
	// Position of STOP_MODE_CONFIG field.
	PMU_MISC0_TOG_STOP_MODE_CONFIG_Pos = 0xa
	// Bit mask of STOP_MODE_CONFIG field.
	PMU_MISC0_TOG_STOP_MODE_CONFIG_Msk = 0xc00
	// SUSPEND (DSM)
	PMU_MISC0_TOG_STOP_MODE_CONFIG_STOP_MODE_CONFIG_0 = 0x0
	// Analog regulators are ON.
	PMU_MISC0_TOG_STOP_MODE_CONFIG_STANDBY = 0x1
	// STOP (lower power)
	PMU_MISC0_TOG_STOP_MODE_CONFIG_STOP_MODE_CONFIG_2 = 0x2
	// STOP (very lower power)
	PMU_MISC0_TOG_STOP_MODE_CONFIG_STOP_MODE_CONFIG_3 = 0x3
	// Position of DISCON_HIGH_SNVS field.
	PMU_MISC0_TOG_DISCON_HIGH_SNVS_Pos = 0xc
	// Bit mask of DISCON_HIGH_SNVS field.
	PMU_MISC0_TOG_DISCON_HIGH_SNVS_Msk = 0x1000
	// Bit DISCON_HIGH_SNVS.
	PMU_MISC0_TOG_DISCON_HIGH_SNVS = 0x1000
	// Turn on the switch
	PMU_MISC0_TOG_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_0 = 0x0
	// Turn off the switch
	PMU_MISC0_TOG_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_1 = 0x1
	// Position of OSC_I field.
	PMU_MISC0_TOG_OSC_I_Pos = 0xd
	// Bit mask of OSC_I field.
	PMU_MISC0_TOG_OSC_I_Msk = 0x6000
	// Nominal
	PMU_MISC0_TOG_OSC_I_NOMINAL = 0x0
	// Decrease current by 12.5%
	PMU_MISC0_TOG_OSC_I_MINUS_12_5_PERCENT = 0x1
	// Decrease current by 25.0%
	PMU_MISC0_TOG_OSC_I_MINUS_25_PERCENT = 0x2
	// Decrease current by 37.5%
	PMU_MISC0_TOG_OSC_I_MINUS_37_5_PERCENT = 0x3
	// Position of OSC_XTALOK field.
	PMU_MISC0_TOG_OSC_XTALOK_Pos = 0xf
	// Bit mask of OSC_XTALOK field.
	PMU_MISC0_TOG_OSC_XTALOK_Msk = 0x8000
	// Bit OSC_XTALOK.
	PMU_MISC0_TOG_OSC_XTALOK = 0x8000
	// Position of OSC_XTALOK_EN field.
	PMU_MISC0_TOG_OSC_XTALOK_EN_Pos = 0x10
	// Bit mask of OSC_XTALOK_EN field.
	PMU_MISC0_TOG_OSC_XTALOK_EN_Msk = 0x10000
	// Bit OSC_XTALOK_EN.
	PMU_MISC0_TOG_OSC_XTALOK_EN = 0x10000
	// Position of CLKGATE_CTRL field.
	PMU_MISC0_TOG_CLKGATE_CTRL_Pos = 0x19
	// Bit mask of CLKGATE_CTRL field.
	PMU_MISC0_TOG_CLKGATE_CTRL_Msk = 0x2000000
	// Bit CLKGATE_CTRL.
	PMU_MISC0_TOG_CLKGATE_CTRL = 0x2000000
	// Allow the logic to automatically gate the clock when the XTAL is powered down.
	PMU_MISC0_TOG_CLKGATE_CTRL_ALLOW_AUTO_GATE = 0x0
	// Prevent the logic from ever gating off the clock.
	PMU_MISC0_TOG_CLKGATE_CTRL_NO_AUTO_GATE = 0x1
	// Position of CLKGATE_DELAY field.
	PMU_MISC0_TOG_CLKGATE_DELAY_Pos = 0x1a
	// Bit mask of CLKGATE_DELAY field.
	PMU_MISC0_TOG_CLKGATE_DELAY_Msk = 0x1c000000
	// 0.5ms
	PMU_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_0 = 0x0
	// 1.0ms
	PMU_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_1 = 0x1
	// 2.0ms
	PMU_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_2 = 0x2
	// 3.0ms
	PMU_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_3 = 0x3
	// 4.0ms
	PMU_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_4 = 0x4
	// 5.0ms
	PMU_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_5 = 0x5
	// 6.0ms
	PMU_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_6 = 0x6
	// 7.0ms
	PMU_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_7 = 0x7
	// Position of RTC_XTAL_SOURCE field.
	PMU_MISC0_TOG_RTC_XTAL_SOURCE_Pos = 0x1d
	// Bit mask of RTC_XTAL_SOURCE field.
	PMU_MISC0_TOG_RTC_XTAL_SOURCE_Msk = 0x20000000
	// Bit RTC_XTAL_SOURCE.
	PMU_MISC0_TOG_RTC_XTAL_SOURCE = 0x20000000
	// Internal ring oscillator
	PMU_MISC0_TOG_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_0 = 0x0
	// RTC_XTAL
	PMU_MISC0_TOG_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_1 = 0x1
	// Position of XTAL_24M_PWD field.
	PMU_MISC0_TOG_XTAL_24M_PWD_Pos = 0x1e
	// Bit mask of XTAL_24M_PWD field.
	PMU_MISC0_TOG_XTAL_24M_PWD_Msk = 0x40000000
	// Bit XTAL_24M_PWD.
	PMU_MISC0_TOG_XTAL_24M_PWD = 0x40000000

	// MISC1: Miscellaneous Register 1
	// Position of PFD_480_AUTOGATE_EN field.
	PMU_MISC1_PFD_480_AUTOGATE_EN_Pos = 0x10
	// Bit mask of PFD_480_AUTOGATE_EN field.
	PMU_MISC1_PFD_480_AUTOGATE_EN_Msk = 0x10000
	// Bit PFD_480_AUTOGATE_EN.
	PMU_MISC1_PFD_480_AUTOGATE_EN = 0x10000
	// Position of PFD_528_AUTOGATE_EN field.
	PMU_MISC1_PFD_528_AUTOGATE_EN_Pos = 0x11
	// Bit mask of PFD_528_AUTOGATE_EN field.
	PMU_MISC1_PFD_528_AUTOGATE_EN_Msk = 0x20000
	// Bit PFD_528_AUTOGATE_EN.
	PMU_MISC1_PFD_528_AUTOGATE_EN = 0x20000
	// Position of IRQ_TEMPPANIC field.
	PMU_MISC1_IRQ_TEMPPANIC_Pos = 0x1b
	// Bit mask of IRQ_TEMPPANIC field.
	PMU_MISC1_IRQ_TEMPPANIC_Msk = 0x8000000
	// Bit IRQ_TEMPPANIC.
	PMU_MISC1_IRQ_TEMPPANIC = 0x8000000
	// Position of IRQ_TEMPLOW field.
	PMU_MISC1_IRQ_TEMPLOW_Pos = 0x1c
	// Bit mask of IRQ_TEMPLOW field.
	PMU_MISC1_IRQ_TEMPLOW_Msk = 0x10000000
	// Bit IRQ_TEMPLOW.
	PMU_MISC1_IRQ_TEMPLOW = 0x10000000
	// Position of IRQ_TEMPHIGH field.
	PMU_MISC1_IRQ_TEMPHIGH_Pos = 0x1d
	// Bit mask of IRQ_TEMPHIGH field.
	PMU_MISC1_IRQ_TEMPHIGH_Msk = 0x20000000
	// Bit IRQ_TEMPHIGH.
	PMU_MISC1_IRQ_TEMPHIGH = 0x20000000
	// Position of IRQ_ANA_BO field.
	PMU_MISC1_IRQ_ANA_BO_Pos = 0x1e
	// Bit mask of IRQ_ANA_BO field.
	PMU_MISC1_IRQ_ANA_BO_Msk = 0x40000000
	// Bit IRQ_ANA_BO.
	PMU_MISC1_IRQ_ANA_BO = 0x40000000
	// Position of IRQ_DIG_BO field.
	PMU_MISC1_IRQ_DIG_BO_Pos = 0x1f
	// Bit mask of IRQ_DIG_BO field.
	PMU_MISC1_IRQ_DIG_BO_Msk = 0x80000000
	// Bit IRQ_DIG_BO.
	PMU_MISC1_IRQ_DIG_BO = 0x80000000

	// MISC1_SET: Miscellaneous Register 1
	// Position of PFD_480_AUTOGATE_EN field.
	PMU_MISC1_SET_PFD_480_AUTOGATE_EN_Pos = 0x10
	// Bit mask of PFD_480_AUTOGATE_EN field.
	PMU_MISC1_SET_PFD_480_AUTOGATE_EN_Msk = 0x10000
	// Bit PFD_480_AUTOGATE_EN.
	PMU_MISC1_SET_PFD_480_AUTOGATE_EN = 0x10000
	// Position of PFD_528_AUTOGATE_EN field.
	PMU_MISC1_SET_PFD_528_AUTOGATE_EN_Pos = 0x11
	// Bit mask of PFD_528_AUTOGATE_EN field.
	PMU_MISC1_SET_PFD_528_AUTOGATE_EN_Msk = 0x20000
	// Bit PFD_528_AUTOGATE_EN.
	PMU_MISC1_SET_PFD_528_AUTOGATE_EN = 0x20000
	// Position of IRQ_TEMPPANIC field.
	PMU_MISC1_SET_IRQ_TEMPPANIC_Pos = 0x1b
	// Bit mask of IRQ_TEMPPANIC field.
	PMU_MISC1_SET_IRQ_TEMPPANIC_Msk = 0x8000000
	// Bit IRQ_TEMPPANIC.
	PMU_MISC1_SET_IRQ_TEMPPANIC = 0x8000000
	// Position of IRQ_TEMPLOW field.
	PMU_MISC1_SET_IRQ_TEMPLOW_Pos = 0x1c
	// Bit mask of IRQ_TEMPLOW field.
	PMU_MISC1_SET_IRQ_TEMPLOW_Msk = 0x10000000
	// Bit IRQ_TEMPLOW.
	PMU_MISC1_SET_IRQ_TEMPLOW = 0x10000000
	// Position of IRQ_TEMPHIGH field.
	PMU_MISC1_SET_IRQ_TEMPHIGH_Pos = 0x1d
	// Bit mask of IRQ_TEMPHIGH field.
	PMU_MISC1_SET_IRQ_TEMPHIGH_Msk = 0x20000000
	// Bit IRQ_TEMPHIGH.
	PMU_MISC1_SET_IRQ_TEMPHIGH = 0x20000000
	// Position of IRQ_ANA_BO field.
	PMU_MISC1_SET_IRQ_ANA_BO_Pos = 0x1e
	// Bit mask of IRQ_ANA_BO field.
	PMU_MISC1_SET_IRQ_ANA_BO_Msk = 0x40000000
	// Bit IRQ_ANA_BO.
	PMU_MISC1_SET_IRQ_ANA_BO = 0x40000000
	// Position of IRQ_DIG_BO field.
	PMU_MISC1_SET_IRQ_DIG_BO_Pos = 0x1f
	// Bit mask of IRQ_DIG_BO field.
	PMU_MISC1_SET_IRQ_DIG_BO_Msk = 0x80000000
	// Bit IRQ_DIG_BO.
	PMU_MISC1_SET_IRQ_DIG_BO = 0x80000000

	// MISC1_CLR: Miscellaneous Register 1
	// Position of PFD_480_AUTOGATE_EN field.
	PMU_MISC1_CLR_PFD_480_AUTOGATE_EN_Pos = 0x10
	// Bit mask of PFD_480_AUTOGATE_EN field.
	PMU_MISC1_CLR_PFD_480_AUTOGATE_EN_Msk = 0x10000
	// Bit PFD_480_AUTOGATE_EN.
	PMU_MISC1_CLR_PFD_480_AUTOGATE_EN = 0x10000
	// Position of PFD_528_AUTOGATE_EN field.
	PMU_MISC1_CLR_PFD_528_AUTOGATE_EN_Pos = 0x11
	// Bit mask of PFD_528_AUTOGATE_EN field.
	PMU_MISC1_CLR_PFD_528_AUTOGATE_EN_Msk = 0x20000
	// Bit PFD_528_AUTOGATE_EN.
	PMU_MISC1_CLR_PFD_528_AUTOGATE_EN = 0x20000
	// Position of IRQ_TEMPPANIC field.
	PMU_MISC1_CLR_IRQ_TEMPPANIC_Pos = 0x1b
	// Bit mask of IRQ_TEMPPANIC field.
	PMU_MISC1_CLR_IRQ_TEMPPANIC_Msk = 0x8000000
	// Bit IRQ_TEMPPANIC.
	PMU_MISC1_CLR_IRQ_TEMPPANIC = 0x8000000
	// Position of IRQ_TEMPLOW field.
	PMU_MISC1_CLR_IRQ_TEMPLOW_Pos = 0x1c
	// Bit mask of IRQ_TEMPLOW field.
	PMU_MISC1_CLR_IRQ_TEMPLOW_Msk = 0x10000000
	// Bit IRQ_TEMPLOW.
	PMU_MISC1_CLR_IRQ_TEMPLOW = 0x10000000
	// Position of IRQ_TEMPHIGH field.
	PMU_MISC1_CLR_IRQ_TEMPHIGH_Pos = 0x1d
	// Bit mask of IRQ_TEMPHIGH field.
	PMU_MISC1_CLR_IRQ_TEMPHIGH_Msk = 0x20000000
	// Bit IRQ_TEMPHIGH.
	PMU_MISC1_CLR_IRQ_TEMPHIGH = 0x20000000
	// Position of IRQ_ANA_BO field.
	PMU_MISC1_CLR_IRQ_ANA_BO_Pos = 0x1e
	// Bit mask of IRQ_ANA_BO field.
	PMU_MISC1_CLR_IRQ_ANA_BO_Msk = 0x40000000
	// Bit IRQ_ANA_BO.
	PMU_MISC1_CLR_IRQ_ANA_BO = 0x40000000
	// Position of IRQ_DIG_BO field.
	PMU_MISC1_CLR_IRQ_DIG_BO_Pos = 0x1f
	// Bit mask of IRQ_DIG_BO field.
	PMU_MISC1_CLR_IRQ_DIG_BO_Msk = 0x80000000
	// Bit IRQ_DIG_BO.
	PMU_MISC1_CLR_IRQ_DIG_BO = 0x80000000

	// MISC1_TOG: Miscellaneous Register 1
	// Position of PFD_480_AUTOGATE_EN field.
	PMU_MISC1_TOG_PFD_480_AUTOGATE_EN_Pos = 0x10
	// Bit mask of PFD_480_AUTOGATE_EN field.
	PMU_MISC1_TOG_PFD_480_AUTOGATE_EN_Msk = 0x10000
	// Bit PFD_480_AUTOGATE_EN.
	PMU_MISC1_TOG_PFD_480_AUTOGATE_EN = 0x10000
	// Position of PFD_528_AUTOGATE_EN field.
	PMU_MISC1_TOG_PFD_528_AUTOGATE_EN_Pos = 0x11
	// Bit mask of PFD_528_AUTOGATE_EN field.
	PMU_MISC1_TOG_PFD_528_AUTOGATE_EN_Msk = 0x20000
	// Bit PFD_528_AUTOGATE_EN.
	PMU_MISC1_TOG_PFD_528_AUTOGATE_EN = 0x20000
	// Position of IRQ_TEMPPANIC field.
	PMU_MISC1_TOG_IRQ_TEMPPANIC_Pos = 0x1b
	// Bit mask of IRQ_TEMPPANIC field.
	PMU_MISC1_TOG_IRQ_TEMPPANIC_Msk = 0x8000000
	// Bit IRQ_TEMPPANIC.
	PMU_MISC1_TOG_IRQ_TEMPPANIC = 0x8000000
	// Position of IRQ_TEMPLOW field.
	PMU_MISC1_TOG_IRQ_TEMPLOW_Pos = 0x1c
	// Bit mask of IRQ_TEMPLOW field.
	PMU_MISC1_TOG_IRQ_TEMPLOW_Msk = 0x10000000
	// Bit IRQ_TEMPLOW.
	PMU_MISC1_TOG_IRQ_TEMPLOW = 0x10000000
	// Position of IRQ_TEMPHIGH field.
	PMU_MISC1_TOG_IRQ_TEMPHIGH_Pos = 0x1d
	// Bit mask of IRQ_TEMPHIGH field.
	PMU_MISC1_TOG_IRQ_TEMPHIGH_Msk = 0x20000000
	// Bit IRQ_TEMPHIGH.
	PMU_MISC1_TOG_IRQ_TEMPHIGH = 0x20000000
	// Position of IRQ_ANA_BO field.
	PMU_MISC1_TOG_IRQ_ANA_BO_Pos = 0x1e
	// Bit mask of IRQ_ANA_BO field.
	PMU_MISC1_TOG_IRQ_ANA_BO_Msk = 0x40000000
	// Bit IRQ_ANA_BO.
	PMU_MISC1_TOG_IRQ_ANA_BO = 0x40000000
	// Position of IRQ_DIG_BO field.
	PMU_MISC1_TOG_IRQ_DIG_BO_Pos = 0x1f
	// Bit mask of IRQ_DIG_BO field.
	PMU_MISC1_TOG_IRQ_DIG_BO_Msk = 0x80000000
	// Bit IRQ_DIG_BO.
	PMU_MISC1_TOG_IRQ_DIG_BO = 0x80000000

	// MISC2: Miscellaneous Control Register
	// Position of REG0_BO_OFFSET field.
	PMU_MISC2_REG0_BO_OFFSET_Pos = 0x0
	// Bit mask of REG0_BO_OFFSET field.
	PMU_MISC2_REG0_BO_OFFSET_Msk = 0x7
	// Brownout offset = 0.100V
	PMU_MISC2_REG0_BO_OFFSET_REG0_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	PMU_MISC2_REG0_BO_OFFSET_REG0_BO_OFFSET_7 = 0x7
	// Position of REG0_BO_STATUS field.
	PMU_MISC2_REG0_BO_STATUS_Pos = 0x3
	// Bit mask of REG0_BO_STATUS field.
	PMU_MISC2_REG0_BO_STATUS_Msk = 0x8
	// Bit REG0_BO_STATUS.
	PMU_MISC2_REG0_BO_STATUS = 0x8
	// Brownout, supply is below target minus brownout offset.
	PMU_MISC2_REG0_BO_STATUS_REG0_BO_STATUS_1 = 0x1
	// Position of REG0_ENABLE_BO field.
	PMU_MISC2_REG0_ENABLE_BO_Pos = 0x5
	// Bit mask of REG0_ENABLE_BO field.
	PMU_MISC2_REG0_ENABLE_BO_Msk = 0x20
	// Bit REG0_ENABLE_BO.
	PMU_MISC2_REG0_ENABLE_BO = 0x20
	// Position of PLL3_disable field.
	PMU_MISC2_PLL3_disable_Pos = 0x7
	// Bit mask of PLL3_disable field.
	PMU_MISC2_PLL3_disable_Msk = 0x80
	// Bit PLL3_disable.
	PMU_MISC2_PLL3_disable = 0x80
	// Position of REG1_BO_OFFSET field.
	PMU_MISC2_REG1_BO_OFFSET_Pos = 0x8
	// Bit mask of REG1_BO_OFFSET field.
	PMU_MISC2_REG1_BO_OFFSET_Msk = 0x700
	// Brownout offset = 0.100V
	PMU_MISC2_REG1_BO_OFFSET_REG1_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	PMU_MISC2_REG1_BO_OFFSET_REG1_BO_OFFSET_7 = 0x7
	// Position of REG1_BO_STATUS field.
	PMU_MISC2_REG1_BO_STATUS_Pos = 0xb
	// Bit mask of REG1_BO_STATUS field.
	PMU_MISC2_REG1_BO_STATUS_Msk = 0x800
	// Bit REG1_BO_STATUS.
	PMU_MISC2_REG1_BO_STATUS = 0x800
	// Brownout, supply is below target minus brownout offset.
	PMU_MISC2_REG1_BO_STATUS_REG1_BO_STATUS_1 = 0x1
	// Position of REG1_ENABLE_BO field.
	PMU_MISC2_REG1_ENABLE_BO_Pos = 0xd
	// Bit mask of REG1_ENABLE_BO field.
	PMU_MISC2_REG1_ENABLE_BO_Msk = 0x2000
	// Bit REG1_ENABLE_BO.
	PMU_MISC2_REG1_ENABLE_BO = 0x2000
	// Position of AUDIO_DIV_LSB field.
	PMU_MISC2_AUDIO_DIV_LSB_Pos = 0xf
	// Bit mask of AUDIO_DIV_LSB field.
	PMU_MISC2_AUDIO_DIV_LSB_Msk = 0x8000
	// Bit AUDIO_DIV_LSB.
	PMU_MISC2_AUDIO_DIV_LSB = 0x8000
	// divide by 1 (Default)
	PMU_MISC2_AUDIO_DIV_LSB_AUDIO_DIV_LSB_0 = 0x0
	// divide by 2
	PMU_MISC2_AUDIO_DIV_LSB_AUDIO_DIV_LSB_1 = 0x1
	// Position of REG2_BO_OFFSET field.
	PMU_MISC2_REG2_BO_OFFSET_Pos = 0x10
	// Bit mask of REG2_BO_OFFSET field.
	PMU_MISC2_REG2_BO_OFFSET_Msk = 0x70000
	// Brownout offset = 0.100V
	PMU_MISC2_REG2_BO_OFFSET_REG2_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	PMU_MISC2_REG2_BO_OFFSET_REG2_BO_OFFSET_7 = 0x7
	// Position of REG2_BO_STATUS field.
	PMU_MISC2_REG2_BO_STATUS_Pos = 0x13
	// Bit mask of REG2_BO_STATUS field.
	PMU_MISC2_REG2_BO_STATUS_Msk = 0x80000
	// Bit REG2_BO_STATUS.
	PMU_MISC2_REG2_BO_STATUS = 0x80000
	// Position of REG2_ENABLE_BO field.
	PMU_MISC2_REG2_ENABLE_BO_Pos = 0x15
	// Bit mask of REG2_ENABLE_BO field.
	PMU_MISC2_REG2_ENABLE_BO_Msk = 0x200000
	// Bit REG2_ENABLE_BO.
	PMU_MISC2_REG2_ENABLE_BO = 0x200000
	// Position of REG2_OK field.
	PMU_MISC2_REG2_OK_Pos = 0x16
	// Bit mask of REG2_OK field.
	PMU_MISC2_REG2_OK_Msk = 0x400000
	// Bit REG2_OK.
	PMU_MISC2_REG2_OK = 0x400000
	// Position of AUDIO_DIV_MSB field.
	PMU_MISC2_AUDIO_DIV_MSB_Pos = 0x17
	// Bit mask of AUDIO_DIV_MSB field.
	PMU_MISC2_AUDIO_DIV_MSB_Msk = 0x800000
	// Bit AUDIO_DIV_MSB.
	PMU_MISC2_AUDIO_DIV_MSB = 0x800000
	// divide by 1 (Default)
	PMU_MISC2_AUDIO_DIV_MSB_AUDIO_DIV_MSB_0 = 0x0
	// divide by 2
	PMU_MISC2_AUDIO_DIV_MSB_AUDIO_DIV_MSB_1 = 0x1
	// Position of REG0_STEP_TIME field.
	PMU_MISC2_REG0_STEP_TIME_Pos = 0x18
	// Bit mask of REG0_STEP_TIME field.
	PMU_MISC2_REG0_STEP_TIME_Msk = 0x3000000
	// 64
	PMU_MISC2_REG0_STEP_TIME_64_CLOCKS = 0x0
	// 128
	PMU_MISC2_REG0_STEP_TIME_128_CLOCKS = 0x1
	// 256
	PMU_MISC2_REG0_STEP_TIME_256_CLOCKS = 0x2
	// 512
	PMU_MISC2_REG0_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG1_STEP_TIME field.
	PMU_MISC2_REG1_STEP_TIME_Pos = 0x1a
	// Bit mask of REG1_STEP_TIME field.
	PMU_MISC2_REG1_STEP_TIME_Msk = 0xc000000
	// 64
	PMU_MISC2_REG1_STEP_TIME_64_CLOCKS = 0x0
	// 128
	PMU_MISC2_REG1_STEP_TIME_128_CLOCKS = 0x1
	// 256
	PMU_MISC2_REG1_STEP_TIME_256_CLOCKS = 0x2
	// 512
	PMU_MISC2_REG1_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG2_STEP_TIME field.
	PMU_MISC2_REG2_STEP_TIME_Pos = 0x1c
	// Bit mask of REG2_STEP_TIME field.
	PMU_MISC2_REG2_STEP_TIME_Msk = 0x30000000
	// 64
	PMU_MISC2_REG2_STEP_TIME_64_CLOCKS = 0x0
	// 128
	PMU_MISC2_REG2_STEP_TIME_128_CLOCKS = 0x1
	// 256
	PMU_MISC2_REG2_STEP_TIME_256_CLOCKS = 0x2
	// 512
	PMU_MISC2_REG2_STEP_TIME_512_CLOCKS = 0x3

	// MISC2_SET: Miscellaneous Control Register
	// Position of REG0_BO_OFFSET field.
	PMU_MISC2_SET_REG0_BO_OFFSET_Pos = 0x0
	// Bit mask of REG0_BO_OFFSET field.
	PMU_MISC2_SET_REG0_BO_OFFSET_Msk = 0x7
	// Brownout offset = 0.100V
	PMU_MISC2_SET_REG0_BO_OFFSET_REG0_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	PMU_MISC2_SET_REG0_BO_OFFSET_REG0_BO_OFFSET_7 = 0x7
	// Position of REG0_BO_STATUS field.
	PMU_MISC2_SET_REG0_BO_STATUS_Pos = 0x3
	// Bit mask of REG0_BO_STATUS field.
	PMU_MISC2_SET_REG0_BO_STATUS_Msk = 0x8
	// Bit REG0_BO_STATUS.
	PMU_MISC2_SET_REG0_BO_STATUS = 0x8
	// Brownout, supply is below target minus brownout offset.
	PMU_MISC2_SET_REG0_BO_STATUS_REG0_BO_STATUS_1 = 0x1
	// Position of REG0_ENABLE_BO field.
	PMU_MISC2_SET_REG0_ENABLE_BO_Pos = 0x5
	// Bit mask of REG0_ENABLE_BO field.
	PMU_MISC2_SET_REG0_ENABLE_BO_Msk = 0x20
	// Bit REG0_ENABLE_BO.
	PMU_MISC2_SET_REG0_ENABLE_BO = 0x20
	// Position of PLL3_disable field.
	PMU_MISC2_SET_PLL3_disable_Pos = 0x7
	// Bit mask of PLL3_disable field.
	PMU_MISC2_SET_PLL3_disable_Msk = 0x80
	// Bit PLL3_disable.
	PMU_MISC2_SET_PLL3_disable = 0x80
	// Position of REG1_BO_OFFSET field.
	PMU_MISC2_SET_REG1_BO_OFFSET_Pos = 0x8
	// Bit mask of REG1_BO_OFFSET field.
	PMU_MISC2_SET_REG1_BO_OFFSET_Msk = 0x700
	// Brownout offset = 0.100V
	PMU_MISC2_SET_REG1_BO_OFFSET_REG1_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	PMU_MISC2_SET_REG1_BO_OFFSET_REG1_BO_OFFSET_7 = 0x7
	// Position of REG1_BO_STATUS field.
	PMU_MISC2_SET_REG1_BO_STATUS_Pos = 0xb
	// Bit mask of REG1_BO_STATUS field.
	PMU_MISC2_SET_REG1_BO_STATUS_Msk = 0x800
	// Bit REG1_BO_STATUS.
	PMU_MISC2_SET_REG1_BO_STATUS = 0x800
	// Brownout, supply is below target minus brownout offset.
	PMU_MISC2_SET_REG1_BO_STATUS_REG1_BO_STATUS_1 = 0x1
	// Position of REG1_ENABLE_BO field.
	PMU_MISC2_SET_REG1_ENABLE_BO_Pos = 0xd
	// Bit mask of REG1_ENABLE_BO field.
	PMU_MISC2_SET_REG1_ENABLE_BO_Msk = 0x2000
	// Bit REG1_ENABLE_BO.
	PMU_MISC2_SET_REG1_ENABLE_BO = 0x2000
	// Position of AUDIO_DIV_LSB field.
	PMU_MISC2_SET_AUDIO_DIV_LSB_Pos = 0xf
	// Bit mask of AUDIO_DIV_LSB field.
	PMU_MISC2_SET_AUDIO_DIV_LSB_Msk = 0x8000
	// Bit AUDIO_DIV_LSB.
	PMU_MISC2_SET_AUDIO_DIV_LSB = 0x8000
	// divide by 1 (Default)
	PMU_MISC2_SET_AUDIO_DIV_LSB_AUDIO_DIV_LSB_0 = 0x0
	// divide by 2
	PMU_MISC2_SET_AUDIO_DIV_LSB_AUDIO_DIV_LSB_1 = 0x1
	// Position of REG2_BO_OFFSET field.
	PMU_MISC2_SET_REG2_BO_OFFSET_Pos = 0x10
	// Bit mask of REG2_BO_OFFSET field.
	PMU_MISC2_SET_REG2_BO_OFFSET_Msk = 0x70000
	// Brownout offset = 0.100V
	PMU_MISC2_SET_REG2_BO_OFFSET_REG2_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	PMU_MISC2_SET_REG2_BO_OFFSET_REG2_BO_OFFSET_7 = 0x7
	// Position of REG2_BO_STATUS field.
	PMU_MISC2_SET_REG2_BO_STATUS_Pos = 0x13
	// Bit mask of REG2_BO_STATUS field.
	PMU_MISC2_SET_REG2_BO_STATUS_Msk = 0x80000
	// Bit REG2_BO_STATUS.
	PMU_MISC2_SET_REG2_BO_STATUS = 0x80000
	// Position of REG2_ENABLE_BO field.
	PMU_MISC2_SET_REG2_ENABLE_BO_Pos = 0x15
	// Bit mask of REG2_ENABLE_BO field.
	PMU_MISC2_SET_REG2_ENABLE_BO_Msk = 0x200000
	// Bit REG2_ENABLE_BO.
	PMU_MISC2_SET_REG2_ENABLE_BO = 0x200000
	// Position of REG2_OK field.
	PMU_MISC2_SET_REG2_OK_Pos = 0x16
	// Bit mask of REG2_OK field.
	PMU_MISC2_SET_REG2_OK_Msk = 0x400000
	// Bit REG2_OK.
	PMU_MISC2_SET_REG2_OK = 0x400000
	// Position of AUDIO_DIV_MSB field.
	PMU_MISC2_SET_AUDIO_DIV_MSB_Pos = 0x17
	// Bit mask of AUDIO_DIV_MSB field.
	PMU_MISC2_SET_AUDIO_DIV_MSB_Msk = 0x800000
	// Bit AUDIO_DIV_MSB.
	PMU_MISC2_SET_AUDIO_DIV_MSB = 0x800000
	// divide by 1 (Default)
	PMU_MISC2_SET_AUDIO_DIV_MSB_AUDIO_DIV_MSB_0 = 0x0
	// divide by 2
	PMU_MISC2_SET_AUDIO_DIV_MSB_AUDIO_DIV_MSB_1 = 0x1
	// Position of REG0_STEP_TIME field.
	PMU_MISC2_SET_REG0_STEP_TIME_Pos = 0x18
	// Bit mask of REG0_STEP_TIME field.
	PMU_MISC2_SET_REG0_STEP_TIME_Msk = 0x3000000
	// 64
	PMU_MISC2_SET_REG0_STEP_TIME_64_CLOCKS = 0x0
	// 128
	PMU_MISC2_SET_REG0_STEP_TIME_128_CLOCKS = 0x1
	// 256
	PMU_MISC2_SET_REG0_STEP_TIME_256_CLOCKS = 0x2
	// 512
	PMU_MISC2_SET_REG0_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG1_STEP_TIME field.
	PMU_MISC2_SET_REG1_STEP_TIME_Pos = 0x1a
	// Bit mask of REG1_STEP_TIME field.
	PMU_MISC2_SET_REG1_STEP_TIME_Msk = 0xc000000
	// 64
	PMU_MISC2_SET_REG1_STEP_TIME_64_CLOCKS = 0x0
	// 128
	PMU_MISC2_SET_REG1_STEP_TIME_128_CLOCKS = 0x1
	// 256
	PMU_MISC2_SET_REG1_STEP_TIME_256_CLOCKS = 0x2
	// 512
	PMU_MISC2_SET_REG1_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG2_STEP_TIME field.
	PMU_MISC2_SET_REG2_STEP_TIME_Pos = 0x1c
	// Bit mask of REG2_STEP_TIME field.
	PMU_MISC2_SET_REG2_STEP_TIME_Msk = 0x30000000
	// 64
	PMU_MISC2_SET_REG2_STEP_TIME_64_CLOCKS = 0x0
	// 128
	PMU_MISC2_SET_REG2_STEP_TIME_128_CLOCKS = 0x1
	// 256
	PMU_MISC2_SET_REG2_STEP_TIME_256_CLOCKS = 0x2
	// 512
	PMU_MISC2_SET_REG2_STEP_TIME_512_CLOCKS = 0x3

	// MISC2_CLR: Miscellaneous Control Register
	// Position of REG0_BO_OFFSET field.
	PMU_MISC2_CLR_REG0_BO_OFFSET_Pos = 0x0
	// Bit mask of REG0_BO_OFFSET field.
	PMU_MISC2_CLR_REG0_BO_OFFSET_Msk = 0x7
	// Brownout offset = 0.100V
	PMU_MISC2_CLR_REG0_BO_OFFSET_REG0_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	PMU_MISC2_CLR_REG0_BO_OFFSET_REG0_BO_OFFSET_7 = 0x7
	// Position of REG0_BO_STATUS field.
	PMU_MISC2_CLR_REG0_BO_STATUS_Pos = 0x3
	// Bit mask of REG0_BO_STATUS field.
	PMU_MISC2_CLR_REG0_BO_STATUS_Msk = 0x8
	// Bit REG0_BO_STATUS.
	PMU_MISC2_CLR_REG0_BO_STATUS = 0x8
	// Brownout, supply is below target minus brownout offset.
	PMU_MISC2_CLR_REG0_BO_STATUS_REG0_BO_STATUS_1 = 0x1
	// Position of REG0_ENABLE_BO field.
	PMU_MISC2_CLR_REG0_ENABLE_BO_Pos = 0x5
	// Bit mask of REG0_ENABLE_BO field.
	PMU_MISC2_CLR_REG0_ENABLE_BO_Msk = 0x20
	// Bit REG0_ENABLE_BO.
	PMU_MISC2_CLR_REG0_ENABLE_BO = 0x20
	// Position of PLL3_disable field.
	PMU_MISC2_CLR_PLL3_disable_Pos = 0x7
	// Bit mask of PLL3_disable field.
	PMU_MISC2_CLR_PLL3_disable_Msk = 0x80
	// Bit PLL3_disable.
	PMU_MISC2_CLR_PLL3_disable = 0x80
	// Position of REG1_BO_OFFSET field.
	PMU_MISC2_CLR_REG1_BO_OFFSET_Pos = 0x8
	// Bit mask of REG1_BO_OFFSET field.
	PMU_MISC2_CLR_REG1_BO_OFFSET_Msk = 0x700
	// Brownout offset = 0.100V
	PMU_MISC2_CLR_REG1_BO_OFFSET_REG1_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	PMU_MISC2_CLR_REG1_BO_OFFSET_REG1_BO_OFFSET_7 = 0x7
	// Position of REG1_BO_STATUS field.
	PMU_MISC2_CLR_REG1_BO_STATUS_Pos = 0xb
	// Bit mask of REG1_BO_STATUS field.
	PMU_MISC2_CLR_REG1_BO_STATUS_Msk = 0x800
	// Bit REG1_BO_STATUS.
	PMU_MISC2_CLR_REG1_BO_STATUS = 0x800
	// Brownout, supply is below target minus brownout offset.
	PMU_MISC2_CLR_REG1_BO_STATUS_REG1_BO_STATUS_1 = 0x1
	// Position of REG1_ENABLE_BO field.
	PMU_MISC2_CLR_REG1_ENABLE_BO_Pos = 0xd
	// Bit mask of REG1_ENABLE_BO field.
	PMU_MISC2_CLR_REG1_ENABLE_BO_Msk = 0x2000
	// Bit REG1_ENABLE_BO.
	PMU_MISC2_CLR_REG1_ENABLE_BO = 0x2000
	// Position of AUDIO_DIV_LSB field.
	PMU_MISC2_CLR_AUDIO_DIV_LSB_Pos = 0xf
	// Bit mask of AUDIO_DIV_LSB field.
	PMU_MISC2_CLR_AUDIO_DIV_LSB_Msk = 0x8000
	// Bit AUDIO_DIV_LSB.
	PMU_MISC2_CLR_AUDIO_DIV_LSB = 0x8000
	// divide by 1 (Default)
	PMU_MISC2_CLR_AUDIO_DIV_LSB_AUDIO_DIV_LSB_0 = 0x0
	// divide by 2
	PMU_MISC2_CLR_AUDIO_DIV_LSB_AUDIO_DIV_LSB_1 = 0x1
	// Position of REG2_BO_OFFSET field.
	PMU_MISC2_CLR_REG2_BO_OFFSET_Pos = 0x10
	// Bit mask of REG2_BO_OFFSET field.
	PMU_MISC2_CLR_REG2_BO_OFFSET_Msk = 0x70000
	// Brownout offset = 0.100V
	PMU_MISC2_CLR_REG2_BO_OFFSET_REG2_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	PMU_MISC2_CLR_REG2_BO_OFFSET_REG2_BO_OFFSET_7 = 0x7
	// Position of REG2_BO_STATUS field.
	PMU_MISC2_CLR_REG2_BO_STATUS_Pos = 0x13
	// Bit mask of REG2_BO_STATUS field.
	PMU_MISC2_CLR_REG2_BO_STATUS_Msk = 0x80000
	// Bit REG2_BO_STATUS.
	PMU_MISC2_CLR_REG2_BO_STATUS = 0x80000
	// Position of REG2_ENABLE_BO field.
	PMU_MISC2_CLR_REG2_ENABLE_BO_Pos = 0x15
	// Bit mask of REG2_ENABLE_BO field.
	PMU_MISC2_CLR_REG2_ENABLE_BO_Msk = 0x200000
	// Bit REG2_ENABLE_BO.
	PMU_MISC2_CLR_REG2_ENABLE_BO = 0x200000
	// Position of REG2_OK field.
	PMU_MISC2_CLR_REG2_OK_Pos = 0x16
	// Bit mask of REG2_OK field.
	PMU_MISC2_CLR_REG2_OK_Msk = 0x400000
	// Bit REG2_OK.
	PMU_MISC2_CLR_REG2_OK = 0x400000
	// Position of AUDIO_DIV_MSB field.
	PMU_MISC2_CLR_AUDIO_DIV_MSB_Pos = 0x17
	// Bit mask of AUDIO_DIV_MSB field.
	PMU_MISC2_CLR_AUDIO_DIV_MSB_Msk = 0x800000
	// Bit AUDIO_DIV_MSB.
	PMU_MISC2_CLR_AUDIO_DIV_MSB = 0x800000
	// divide by 1 (Default)
	PMU_MISC2_CLR_AUDIO_DIV_MSB_AUDIO_DIV_MSB_0 = 0x0
	// divide by 2
	PMU_MISC2_CLR_AUDIO_DIV_MSB_AUDIO_DIV_MSB_1 = 0x1
	// Position of REG0_STEP_TIME field.
	PMU_MISC2_CLR_REG0_STEP_TIME_Pos = 0x18
	// Bit mask of REG0_STEP_TIME field.
	PMU_MISC2_CLR_REG0_STEP_TIME_Msk = 0x3000000
	// 64
	PMU_MISC2_CLR_REG0_STEP_TIME_64_CLOCKS = 0x0
	// 128
	PMU_MISC2_CLR_REG0_STEP_TIME_128_CLOCKS = 0x1
	// 256
	PMU_MISC2_CLR_REG0_STEP_TIME_256_CLOCKS = 0x2
	// 512
	PMU_MISC2_CLR_REG0_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG1_STEP_TIME field.
	PMU_MISC2_CLR_REG1_STEP_TIME_Pos = 0x1a
	// Bit mask of REG1_STEP_TIME field.
	PMU_MISC2_CLR_REG1_STEP_TIME_Msk = 0xc000000
	// 64
	PMU_MISC2_CLR_REG1_STEP_TIME_64_CLOCKS = 0x0
	// 128
	PMU_MISC2_CLR_REG1_STEP_TIME_128_CLOCKS = 0x1
	// 256
	PMU_MISC2_CLR_REG1_STEP_TIME_256_CLOCKS = 0x2
	// 512
	PMU_MISC2_CLR_REG1_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG2_STEP_TIME field.
	PMU_MISC2_CLR_REG2_STEP_TIME_Pos = 0x1c
	// Bit mask of REG2_STEP_TIME field.
	PMU_MISC2_CLR_REG2_STEP_TIME_Msk = 0x30000000
	// 64
	PMU_MISC2_CLR_REG2_STEP_TIME_64_CLOCKS = 0x0
	// 128
	PMU_MISC2_CLR_REG2_STEP_TIME_128_CLOCKS = 0x1
	// 256
	PMU_MISC2_CLR_REG2_STEP_TIME_256_CLOCKS = 0x2
	// 512
	PMU_MISC2_CLR_REG2_STEP_TIME_512_CLOCKS = 0x3

	// MISC2_TOG: Miscellaneous Control Register
	// Position of REG0_BO_OFFSET field.
	PMU_MISC2_TOG_REG0_BO_OFFSET_Pos = 0x0
	// Bit mask of REG0_BO_OFFSET field.
	PMU_MISC2_TOG_REG0_BO_OFFSET_Msk = 0x7
	// Brownout offset = 0.100V
	PMU_MISC2_TOG_REG0_BO_OFFSET_REG0_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	PMU_MISC2_TOG_REG0_BO_OFFSET_REG0_BO_OFFSET_7 = 0x7
	// Position of REG0_BO_STATUS field.
	PMU_MISC2_TOG_REG0_BO_STATUS_Pos = 0x3
	// Bit mask of REG0_BO_STATUS field.
	PMU_MISC2_TOG_REG0_BO_STATUS_Msk = 0x8
	// Bit REG0_BO_STATUS.
	PMU_MISC2_TOG_REG0_BO_STATUS = 0x8
	// Brownout, supply is below target minus brownout offset.
	PMU_MISC2_TOG_REG0_BO_STATUS_REG0_BO_STATUS_1 = 0x1
	// Position of REG0_ENABLE_BO field.
	PMU_MISC2_TOG_REG0_ENABLE_BO_Pos = 0x5
	// Bit mask of REG0_ENABLE_BO field.
	PMU_MISC2_TOG_REG0_ENABLE_BO_Msk = 0x20
	// Bit REG0_ENABLE_BO.
	PMU_MISC2_TOG_REG0_ENABLE_BO = 0x20
	// Position of PLL3_disable field.
	PMU_MISC2_TOG_PLL3_disable_Pos = 0x7
	// Bit mask of PLL3_disable field.
	PMU_MISC2_TOG_PLL3_disable_Msk = 0x80
	// Bit PLL3_disable.
	PMU_MISC2_TOG_PLL3_disable = 0x80
	// Position of REG1_BO_OFFSET field.
	PMU_MISC2_TOG_REG1_BO_OFFSET_Pos = 0x8
	// Bit mask of REG1_BO_OFFSET field.
	PMU_MISC2_TOG_REG1_BO_OFFSET_Msk = 0x700
	// Brownout offset = 0.100V
	PMU_MISC2_TOG_REG1_BO_OFFSET_REG1_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	PMU_MISC2_TOG_REG1_BO_OFFSET_REG1_BO_OFFSET_7 = 0x7
	// Position of REG1_BO_STATUS field.
	PMU_MISC2_TOG_REG1_BO_STATUS_Pos = 0xb
	// Bit mask of REG1_BO_STATUS field.
	PMU_MISC2_TOG_REG1_BO_STATUS_Msk = 0x800
	// Bit REG1_BO_STATUS.
	PMU_MISC2_TOG_REG1_BO_STATUS = 0x800
	// Brownout, supply is below target minus brownout offset.
	PMU_MISC2_TOG_REG1_BO_STATUS_REG1_BO_STATUS_1 = 0x1
	// Position of REG1_ENABLE_BO field.
	PMU_MISC2_TOG_REG1_ENABLE_BO_Pos = 0xd
	// Bit mask of REG1_ENABLE_BO field.
	PMU_MISC2_TOG_REG1_ENABLE_BO_Msk = 0x2000
	// Bit REG1_ENABLE_BO.
	PMU_MISC2_TOG_REG1_ENABLE_BO = 0x2000
	// Position of AUDIO_DIV_LSB field.
	PMU_MISC2_TOG_AUDIO_DIV_LSB_Pos = 0xf
	// Bit mask of AUDIO_DIV_LSB field.
	PMU_MISC2_TOG_AUDIO_DIV_LSB_Msk = 0x8000
	// Bit AUDIO_DIV_LSB.
	PMU_MISC2_TOG_AUDIO_DIV_LSB = 0x8000
	// divide by 1 (Default)
	PMU_MISC2_TOG_AUDIO_DIV_LSB_AUDIO_DIV_LSB_0 = 0x0
	// divide by 2
	PMU_MISC2_TOG_AUDIO_DIV_LSB_AUDIO_DIV_LSB_1 = 0x1
	// Position of REG2_BO_OFFSET field.
	PMU_MISC2_TOG_REG2_BO_OFFSET_Pos = 0x10
	// Bit mask of REG2_BO_OFFSET field.
	PMU_MISC2_TOG_REG2_BO_OFFSET_Msk = 0x70000
	// Brownout offset = 0.100V
	PMU_MISC2_TOG_REG2_BO_OFFSET_REG2_BO_OFFSET_4 = 0x4
	// Brownout offset = 0.175V
	PMU_MISC2_TOG_REG2_BO_OFFSET_REG2_BO_OFFSET_7 = 0x7
	// Position of REG2_BO_STATUS field.
	PMU_MISC2_TOG_REG2_BO_STATUS_Pos = 0x13
	// Bit mask of REG2_BO_STATUS field.
	PMU_MISC2_TOG_REG2_BO_STATUS_Msk = 0x80000
	// Bit REG2_BO_STATUS.
	PMU_MISC2_TOG_REG2_BO_STATUS = 0x80000
	// Position of REG2_ENABLE_BO field.
	PMU_MISC2_TOG_REG2_ENABLE_BO_Pos = 0x15
	// Bit mask of REG2_ENABLE_BO field.
	PMU_MISC2_TOG_REG2_ENABLE_BO_Msk = 0x200000
	// Bit REG2_ENABLE_BO.
	PMU_MISC2_TOG_REG2_ENABLE_BO = 0x200000
	// Position of REG2_OK field.
	PMU_MISC2_TOG_REG2_OK_Pos = 0x16
	// Bit mask of REG2_OK field.
	PMU_MISC2_TOG_REG2_OK_Msk = 0x400000
	// Bit REG2_OK.
	PMU_MISC2_TOG_REG2_OK = 0x400000
	// Position of AUDIO_DIV_MSB field.
	PMU_MISC2_TOG_AUDIO_DIV_MSB_Pos = 0x17
	// Bit mask of AUDIO_DIV_MSB field.
	PMU_MISC2_TOG_AUDIO_DIV_MSB_Msk = 0x800000
	// Bit AUDIO_DIV_MSB.
	PMU_MISC2_TOG_AUDIO_DIV_MSB = 0x800000
	// divide by 1 (Default)
	PMU_MISC2_TOG_AUDIO_DIV_MSB_AUDIO_DIV_MSB_0 = 0x0
	// divide by 2
	PMU_MISC2_TOG_AUDIO_DIV_MSB_AUDIO_DIV_MSB_1 = 0x1
	// Position of REG0_STEP_TIME field.
	PMU_MISC2_TOG_REG0_STEP_TIME_Pos = 0x18
	// Bit mask of REG0_STEP_TIME field.
	PMU_MISC2_TOG_REG0_STEP_TIME_Msk = 0x3000000
	// 64
	PMU_MISC2_TOG_REG0_STEP_TIME_64_CLOCKS = 0x0
	// 128
	PMU_MISC2_TOG_REG0_STEP_TIME_128_CLOCKS = 0x1
	// 256
	PMU_MISC2_TOG_REG0_STEP_TIME_256_CLOCKS = 0x2
	// 512
	PMU_MISC2_TOG_REG0_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG1_STEP_TIME field.
	PMU_MISC2_TOG_REG1_STEP_TIME_Pos = 0x1a
	// Bit mask of REG1_STEP_TIME field.
	PMU_MISC2_TOG_REG1_STEP_TIME_Msk = 0xc000000
	// 64
	PMU_MISC2_TOG_REG1_STEP_TIME_64_CLOCKS = 0x0
	// 128
	PMU_MISC2_TOG_REG1_STEP_TIME_128_CLOCKS = 0x1
	// 256
	PMU_MISC2_TOG_REG1_STEP_TIME_256_CLOCKS = 0x2
	// 512
	PMU_MISC2_TOG_REG1_STEP_TIME_512_CLOCKS = 0x3
	// Position of REG2_STEP_TIME field.
	PMU_MISC2_TOG_REG2_STEP_TIME_Pos = 0x1c
	// Bit mask of REG2_STEP_TIME field.
	PMU_MISC2_TOG_REG2_STEP_TIME_Msk = 0x30000000
	// 64
	PMU_MISC2_TOG_REG2_STEP_TIME_64_CLOCKS = 0x0
	// 128
	PMU_MISC2_TOG_REG2_STEP_TIME_128_CLOCKS = 0x1
	// 256
	PMU_MISC2_TOG_REG2_STEP_TIME_256_CLOCKS = 0x2
	// 512
	PMU_MISC2_TOG_REG2_STEP_TIME_512_CLOCKS = 0x3
)

// Constants for TEMPMON: Temperature Monitor
const (
	// TEMPSENSE0: Tempsensor Control Register 0
	// Position of POWER_DOWN field.
	TEMPMON_TEMPSENSE0_POWER_DOWN_Pos = 0x0
	// Bit mask of POWER_DOWN field.
	TEMPMON_TEMPSENSE0_POWER_DOWN_Msk = 0x1
	// Bit POWER_DOWN.
	TEMPMON_TEMPSENSE0_POWER_DOWN = 0x1
	// Enable power to the temperature sensor.
	TEMPMON_TEMPSENSE0_POWER_DOWN_POWER_UP = 0x0
	// Power down the temperature sensor.
	TEMPMON_TEMPSENSE0_POWER_DOWN_POWER_DOWN = 0x1
	// Position of MEASURE_TEMP field.
	TEMPMON_TEMPSENSE0_MEASURE_TEMP_Pos = 0x1
	// Bit mask of MEASURE_TEMP field.
	TEMPMON_TEMPSENSE0_MEASURE_TEMP_Msk = 0x2
	// Bit MEASURE_TEMP.
	TEMPMON_TEMPSENSE0_MEASURE_TEMP = 0x2
	// Do not start the measurement process.
	TEMPMON_TEMPSENSE0_MEASURE_TEMP_STOP = 0x0
	// Start the measurement process.
	TEMPMON_TEMPSENSE0_MEASURE_TEMP_START = 0x1
	// Position of FINISHED field.
	TEMPMON_TEMPSENSE0_FINISHED_Pos = 0x2
	// Bit mask of FINISHED field.
	TEMPMON_TEMPSENSE0_FINISHED_Msk = 0x4
	// Bit FINISHED.
	TEMPMON_TEMPSENSE0_FINISHED = 0x4
	// Last measurement is not ready yet.
	TEMPMON_TEMPSENSE0_FINISHED_INVALID = 0x0
	// Last measurement is valid.
	TEMPMON_TEMPSENSE0_FINISHED_VALID = 0x1
	// Position of TEMP_CNT field.
	TEMPMON_TEMPSENSE0_TEMP_CNT_Pos = 0x8
	// Bit mask of TEMP_CNT field.
	TEMPMON_TEMPSENSE0_TEMP_CNT_Msk = 0xfff00
	// Position of ALARM_VALUE field.
	TEMPMON_TEMPSENSE0_ALARM_VALUE_Pos = 0x14
	// Bit mask of ALARM_VALUE field.
	TEMPMON_TEMPSENSE0_ALARM_VALUE_Msk = 0xfff00000

	// TEMPSENSE0_SET: Tempsensor Control Register 0
	// Position of POWER_DOWN field.
	TEMPMON_TEMPSENSE0_SET_POWER_DOWN_Pos = 0x0
	// Bit mask of POWER_DOWN field.
	TEMPMON_TEMPSENSE0_SET_POWER_DOWN_Msk = 0x1
	// Bit POWER_DOWN.
	TEMPMON_TEMPSENSE0_SET_POWER_DOWN = 0x1
	// Enable power to the temperature sensor.
	TEMPMON_TEMPSENSE0_SET_POWER_DOWN_POWER_UP = 0x0
	// Power down the temperature sensor.
	TEMPMON_TEMPSENSE0_SET_POWER_DOWN_POWER_DOWN = 0x1
	// Position of MEASURE_TEMP field.
	TEMPMON_TEMPSENSE0_SET_MEASURE_TEMP_Pos = 0x1
	// Bit mask of MEASURE_TEMP field.
	TEMPMON_TEMPSENSE0_SET_MEASURE_TEMP_Msk = 0x2
	// Bit MEASURE_TEMP.
	TEMPMON_TEMPSENSE0_SET_MEASURE_TEMP = 0x2
	// Do not start the measurement process.
	TEMPMON_TEMPSENSE0_SET_MEASURE_TEMP_STOP = 0x0
	// Start the measurement process.
	TEMPMON_TEMPSENSE0_SET_MEASURE_TEMP_START = 0x1
	// Position of FINISHED field.
	TEMPMON_TEMPSENSE0_SET_FINISHED_Pos = 0x2
	// Bit mask of FINISHED field.
	TEMPMON_TEMPSENSE0_SET_FINISHED_Msk = 0x4
	// Bit FINISHED.
	TEMPMON_TEMPSENSE0_SET_FINISHED = 0x4
	// Last measurement is not ready yet.
	TEMPMON_TEMPSENSE0_SET_FINISHED_INVALID = 0x0
	// Last measurement is valid.
	TEMPMON_TEMPSENSE0_SET_FINISHED_VALID = 0x1
	// Position of TEMP_CNT field.
	TEMPMON_TEMPSENSE0_SET_TEMP_CNT_Pos = 0x8
	// Bit mask of TEMP_CNT field.
	TEMPMON_TEMPSENSE0_SET_TEMP_CNT_Msk = 0xfff00
	// Position of ALARM_VALUE field.
	TEMPMON_TEMPSENSE0_SET_ALARM_VALUE_Pos = 0x14
	// Bit mask of ALARM_VALUE field.
	TEMPMON_TEMPSENSE0_SET_ALARM_VALUE_Msk = 0xfff00000

	// TEMPSENSE0_CLR: Tempsensor Control Register 0
	// Position of POWER_DOWN field.
	TEMPMON_TEMPSENSE0_CLR_POWER_DOWN_Pos = 0x0
	// Bit mask of POWER_DOWN field.
	TEMPMON_TEMPSENSE0_CLR_POWER_DOWN_Msk = 0x1
	// Bit POWER_DOWN.
	TEMPMON_TEMPSENSE0_CLR_POWER_DOWN = 0x1
	// Enable power to the temperature sensor.
	TEMPMON_TEMPSENSE0_CLR_POWER_DOWN_POWER_UP = 0x0
	// Power down the temperature sensor.
	TEMPMON_TEMPSENSE0_CLR_POWER_DOWN_POWER_DOWN = 0x1
	// Position of MEASURE_TEMP field.
	TEMPMON_TEMPSENSE0_CLR_MEASURE_TEMP_Pos = 0x1
	// Bit mask of MEASURE_TEMP field.
	TEMPMON_TEMPSENSE0_CLR_MEASURE_TEMP_Msk = 0x2
	// Bit MEASURE_TEMP.
	TEMPMON_TEMPSENSE0_CLR_MEASURE_TEMP = 0x2
	// Do not start the measurement process.
	TEMPMON_TEMPSENSE0_CLR_MEASURE_TEMP_STOP = 0x0
	// Start the measurement process.
	TEMPMON_TEMPSENSE0_CLR_MEASURE_TEMP_START = 0x1
	// Position of FINISHED field.
	TEMPMON_TEMPSENSE0_CLR_FINISHED_Pos = 0x2
	// Bit mask of FINISHED field.
	TEMPMON_TEMPSENSE0_CLR_FINISHED_Msk = 0x4
	// Bit FINISHED.
	TEMPMON_TEMPSENSE0_CLR_FINISHED = 0x4
	// Last measurement is not ready yet.
	TEMPMON_TEMPSENSE0_CLR_FINISHED_INVALID = 0x0
	// Last measurement is valid.
	TEMPMON_TEMPSENSE0_CLR_FINISHED_VALID = 0x1
	// Position of TEMP_CNT field.
	TEMPMON_TEMPSENSE0_CLR_TEMP_CNT_Pos = 0x8
	// Bit mask of TEMP_CNT field.
	TEMPMON_TEMPSENSE0_CLR_TEMP_CNT_Msk = 0xfff00
	// Position of ALARM_VALUE field.
	TEMPMON_TEMPSENSE0_CLR_ALARM_VALUE_Pos = 0x14
	// Bit mask of ALARM_VALUE field.
	TEMPMON_TEMPSENSE0_CLR_ALARM_VALUE_Msk = 0xfff00000

	// TEMPSENSE0_TOG: Tempsensor Control Register 0
	// Position of POWER_DOWN field.
	TEMPMON_TEMPSENSE0_TOG_POWER_DOWN_Pos = 0x0
	// Bit mask of POWER_DOWN field.
	TEMPMON_TEMPSENSE0_TOG_POWER_DOWN_Msk = 0x1
	// Bit POWER_DOWN.
	TEMPMON_TEMPSENSE0_TOG_POWER_DOWN = 0x1
	// Enable power to the temperature sensor.
	TEMPMON_TEMPSENSE0_TOG_POWER_DOWN_POWER_UP = 0x0
	// Power down the temperature sensor.
	TEMPMON_TEMPSENSE0_TOG_POWER_DOWN_POWER_DOWN = 0x1
	// Position of MEASURE_TEMP field.
	TEMPMON_TEMPSENSE0_TOG_MEASURE_TEMP_Pos = 0x1
	// Bit mask of MEASURE_TEMP field.
	TEMPMON_TEMPSENSE0_TOG_MEASURE_TEMP_Msk = 0x2
	// Bit MEASURE_TEMP.
	TEMPMON_TEMPSENSE0_TOG_MEASURE_TEMP = 0x2
	// Do not start the measurement process.
	TEMPMON_TEMPSENSE0_TOG_MEASURE_TEMP_STOP = 0x0
	// Start the measurement process.
	TEMPMON_TEMPSENSE0_TOG_MEASURE_TEMP_START = 0x1
	// Position of FINISHED field.
	TEMPMON_TEMPSENSE0_TOG_FINISHED_Pos = 0x2
	// Bit mask of FINISHED field.
	TEMPMON_TEMPSENSE0_TOG_FINISHED_Msk = 0x4
	// Bit FINISHED.
	TEMPMON_TEMPSENSE0_TOG_FINISHED = 0x4
	// Last measurement is not ready yet.
	TEMPMON_TEMPSENSE0_TOG_FINISHED_INVALID = 0x0
	// Last measurement is valid.
	TEMPMON_TEMPSENSE0_TOG_FINISHED_VALID = 0x1
	// Position of TEMP_CNT field.
	TEMPMON_TEMPSENSE0_TOG_TEMP_CNT_Pos = 0x8
	// Bit mask of TEMP_CNT field.
	TEMPMON_TEMPSENSE0_TOG_TEMP_CNT_Msk = 0xfff00
	// Position of ALARM_VALUE field.
	TEMPMON_TEMPSENSE0_TOG_ALARM_VALUE_Pos = 0x14
	// Bit mask of ALARM_VALUE field.
	TEMPMON_TEMPSENSE0_TOG_ALARM_VALUE_Msk = 0xfff00000

	// TEMPSENSE1: Tempsensor Control Register 1
	// Position of MEASURE_FREQ field.
	TEMPMON_TEMPSENSE1_MEASURE_FREQ_Pos = 0x0
	// Bit mask of MEASURE_FREQ field.
	TEMPMON_TEMPSENSE1_MEASURE_FREQ_Msk = 0xffff

	// TEMPSENSE1_SET: Tempsensor Control Register 1
	// Position of MEASURE_FREQ field.
	TEMPMON_TEMPSENSE1_SET_MEASURE_FREQ_Pos = 0x0
	// Bit mask of MEASURE_FREQ field.
	TEMPMON_TEMPSENSE1_SET_MEASURE_FREQ_Msk = 0xffff

	// TEMPSENSE1_CLR: Tempsensor Control Register 1
	// Position of MEASURE_FREQ field.
	TEMPMON_TEMPSENSE1_CLR_MEASURE_FREQ_Pos = 0x0
	// Bit mask of MEASURE_FREQ field.
	TEMPMON_TEMPSENSE1_CLR_MEASURE_FREQ_Msk = 0xffff

	// TEMPSENSE1_TOG: Tempsensor Control Register 1
	// Position of MEASURE_FREQ field.
	TEMPMON_TEMPSENSE1_TOG_MEASURE_FREQ_Pos = 0x0
	// Bit mask of MEASURE_FREQ field.
	TEMPMON_TEMPSENSE1_TOG_MEASURE_FREQ_Msk = 0xffff

	// TEMPSENSE2: Tempsensor Control Register 2
	// Position of LOW_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_LOW_ALARM_VALUE_Pos = 0x0
	// Bit mask of LOW_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_LOW_ALARM_VALUE_Msk = 0xfff
	// Position of PANIC_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_PANIC_ALARM_VALUE_Pos = 0x10
	// Bit mask of PANIC_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_PANIC_ALARM_VALUE_Msk = 0xfff0000

	// TEMPSENSE2_SET: Tempsensor Control Register 2
	// Position of LOW_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_SET_LOW_ALARM_VALUE_Pos = 0x0
	// Bit mask of LOW_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_SET_LOW_ALARM_VALUE_Msk = 0xfff
	// Position of PANIC_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_SET_PANIC_ALARM_VALUE_Pos = 0x10
	// Bit mask of PANIC_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_SET_PANIC_ALARM_VALUE_Msk = 0xfff0000

	// TEMPSENSE2_CLR: Tempsensor Control Register 2
	// Position of LOW_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_CLR_LOW_ALARM_VALUE_Pos = 0x0
	// Bit mask of LOW_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_CLR_LOW_ALARM_VALUE_Msk = 0xfff
	// Position of PANIC_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_CLR_PANIC_ALARM_VALUE_Pos = 0x10
	// Bit mask of PANIC_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_CLR_PANIC_ALARM_VALUE_Msk = 0xfff0000

	// TEMPSENSE2_TOG: Tempsensor Control Register 2
	// Position of LOW_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_TOG_LOW_ALARM_VALUE_Pos = 0x0
	// Bit mask of LOW_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_TOG_LOW_ALARM_VALUE_Msk = 0xfff
	// Position of PANIC_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_TOG_PANIC_ALARM_VALUE_Pos = 0x10
	// Bit mask of PANIC_ALARM_VALUE field.
	TEMPMON_TEMPSENSE2_TOG_PANIC_ALARM_VALUE_Msk = 0xfff0000
)

// Constants for USB_ANALOG: USB Analog
const (
	// USB1_VBUS_DETECT: USB VBUS Detect Register
	// Position of VBUSVALID_THRESH field.
	USB_ANALOG_USB1_VBUS_DETECT_VBUSVALID_THRESH_Pos = 0x0
	// Bit mask of VBUSVALID_THRESH field.
	USB_ANALOG_USB1_VBUS_DETECT_VBUSVALID_THRESH_Msk = 0x7
	// 4.0V
	USB_ANALOG_USB1_VBUS_DETECT_VBUSVALID_THRESH_4V0 = 0x0
	// 4.1V
	USB_ANALOG_USB1_VBUS_DETECT_VBUSVALID_THRESH_4V1 = 0x1
	// 4.2V
	USB_ANALOG_USB1_VBUS_DETECT_VBUSVALID_THRESH_4V2 = 0x2
	// 4.3V
	USB_ANALOG_USB1_VBUS_DETECT_VBUSVALID_THRESH_4V3 = 0x3
	// 4.4V (default)
	USB_ANALOG_USB1_VBUS_DETECT_VBUSVALID_THRESH_4V4 = 0x4
	// 4.5V
	USB_ANALOG_USB1_VBUS_DETECT_VBUSVALID_THRESH_4V5 = 0x5
	// 4.6V
	USB_ANALOG_USB1_VBUS_DETECT_VBUSVALID_THRESH_4V6 = 0x6
	// 4.7V
	USB_ANALOG_USB1_VBUS_DETECT_VBUSVALID_THRESH_4V7 = 0x7
	// Position of VBUSVALID_PWRUP_CMPS field.
	USB_ANALOG_USB1_VBUS_DETECT_VBUSVALID_PWRUP_CMPS_Pos = 0x14
	// Bit mask of VBUSVALID_PWRUP_CMPS field.
	USB_ANALOG_USB1_VBUS_DETECT_VBUSVALID_PWRUP_CMPS_Msk = 0x100000
	// Bit VBUSVALID_PWRUP_CMPS.
	USB_ANALOG_USB1_VBUS_DETECT_VBUSVALID_PWRUP_CMPS = 0x100000
	// Position of DISCHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_DISCHARGE_VBUS_Pos = 0x1a
	// Bit mask of DISCHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_DISCHARGE_VBUS_Msk = 0x4000000
	// Bit DISCHARGE_VBUS.
	USB_ANALOG_USB1_VBUS_DETECT_DISCHARGE_VBUS = 0x4000000
	// Position of CHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_CHARGE_VBUS_Pos = 0x1b
	// Bit mask of CHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_CHARGE_VBUS_Msk = 0x8000000
	// Bit CHARGE_VBUS.
	USB_ANALOG_USB1_VBUS_DETECT_CHARGE_VBUS = 0x8000000

	// USB1_VBUS_DETECT_SET: USB VBUS Detect Register
	// Position of VBUSVALID_THRESH field.
	USB_ANALOG_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_Pos = 0x0
	// Bit mask of VBUSVALID_THRESH field.
	USB_ANALOG_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_Msk = 0x7
	// 4.0V
	USB_ANALOG_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_4V0 = 0x0
	// 4.1V
	USB_ANALOG_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_4V1 = 0x1
	// 4.2V
	USB_ANALOG_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_4V2 = 0x2
	// 4.3V
	USB_ANALOG_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_4V3 = 0x3
	// 4.4V (default)
	USB_ANALOG_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_4V4 = 0x4
	// 4.5V
	USB_ANALOG_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_4V5 = 0x5
	// 4.6V
	USB_ANALOG_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_4V6 = 0x6
	// 4.7V
	USB_ANALOG_USB1_VBUS_DETECT_SET_VBUSVALID_THRESH_4V7 = 0x7
	// Position of VBUSVALID_PWRUP_CMPS field.
	USB_ANALOG_USB1_VBUS_DETECT_SET_VBUSVALID_PWRUP_CMPS_Pos = 0x14
	// Bit mask of VBUSVALID_PWRUP_CMPS field.
	USB_ANALOG_USB1_VBUS_DETECT_SET_VBUSVALID_PWRUP_CMPS_Msk = 0x100000
	// Bit VBUSVALID_PWRUP_CMPS.
	USB_ANALOG_USB1_VBUS_DETECT_SET_VBUSVALID_PWRUP_CMPS = 0x100000
	// Position of DISCHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_SET_DISCHARGE_VBUS_Pos = 0x1a
	// Bit mask of DISCHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_SET_DISCHARGE_VBUS_Msk = 0x4000000
	// Bit DISCHARGE_VBUS.
	USB_ANALOG_USB1_VBUS_DETECT_SET_DISCHARGE_VBUS = 0x4000000
	// Position of CHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_SET_CHARGE_VBUS_Pos = 0x1b
	// Bit mask of CHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_SET_CHARGE_VBUS_Msk = 0x8000000
	// Bit CHARGE_VBUS.
	USB_ANALOG_USB1_VBUS_DETECT_SET_CHARGE_VBUS = 0x8000000

	// USB1_VBUS_DETECT_CLR: USB VBUS Detect Register
	// Position of VBUSVALID_THRESH field.
	USB_ANALOG_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_Pos = 0x0
	// Bit mask of VBUSVALID_THRESH field.
	USB_ANALOG_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_Msk = 0x7
	// 4.0V
	USB_ANALOG_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_4V0 = 0x0
	// 4.1V
	USB_ANALOG_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_4V1 = 0x1
	// 4.2V
	USB_ANALOG_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_4V2 = 0x2
	// 4.3V
	USB_ANALOG_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_4V3 = 0x3
	// 4.4V (default)
	USB_ANALOG_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_4V4 = 0x4
	// 4.5V
	USB_ANALOG_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_4V5 = 0x5
	// 4.6V
	USB_ANALOG_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_4V6 = 0x6
	// 4.7V
	USB_ANALOG_USB1_VBUS_DETECT_CLR_VBUSVALID_THRESH_4V7 = 0x7
	// Position of VBUSVALID_PWRUP_CMPS field.
	USB_ANALOG_USB1_VBUS_DETECT_CLR_VBUSVALID_PWRUP_CMPS_Pos = 0x14
	// Bit mask of VBUSVALID_PWRUP_CMPS field.
	USB_ANALOG_USB1_VBUS_DETECT_CLR_VBUSVALID_PWRUP_CMPS_Msk = 0x100000
	// Bit VBUSVALID_PWRUP_CMPS.
	USB_ANALOG_USB1_VBUS_DETECT_CLR_VBUSVALID_PWRUP_CMPS = 0x100000
	// Position of DISCHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_CLR_DISCHARGE_VBUS_Pos = 0x1a
	// Bit mask of DISCHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_CLR_DISCHARGE_VBUS_Msk = 0x4000000
	// Bit DISCHARGE_VBUS.
	USB_ANALOG_USB1_VBUS_DETECT_CLR_DISCHARGE_VBUS = 0x4000000
	// Position of CHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_CLR_CHARGE_VBUS_Pos = 0x1b
	// Bit mask of CHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_CLR_CHARGE_VBUS_Msk = 0x8000000
	// Bit CHARGE_VBUS.
	USB_ANALOG_USB1_VBUS_DETECT_CLR_CHARGE_VBUS = 0x8000000

	// USB1_VBUS_DETECT_TOG: USB VBUS Detect Register
	// Position of VBUSVALID_THRESH field.
	USB_ANALOG_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_Pos = 0x0
	// Bit mask of VBUSVALID_THRESH field.
	USB_ANALOG_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_Msk = 0x7
	// 4.0V
	USB_ANALOG_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_4V0 = 0x0
	// 4.1V
	USB_ANALOG_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_4V1 = 0x1
	// 4.2V
	USB_ANALOG_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_4V2 = 0x2
	// 4.3V
	USB_ANALOG_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_4V3 = 0x3
	// 4.4V (default)
	USB_ANALOG_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_4V4 = 0x4
	// 4.5V
	USB_ANALOG_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_4V5 = 0x5
	// 4.6V
	USB_ANALOG_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_4V6 = 0x6
	// 4.7V
	USB_ANALOG_USB1_VBUS_DETECT_TOG_VBUSVALID_THRESH_4V7 = 0x7
	// Position of VBUSVALID_PWRUP_CMPS field.
	USB_ANALOG_USB1_VBUS_DETECT_TOG_VBUSVALID_PWRUP_CMPS_Pos = 0x14
	// Bit mask of VBUSVALID_PWRUP_CMPS field.
	USB_ANALOG_USB1_VBUS_DETECT_TOG_VBUSVALID_PWRUP_CMPS_Msk = 0x100000
	// Bit VBUSVALID_PWRUP_CMPS.
	USB_ANALOG_USB1_VBUS_DETECT_TOG_VBUSVALID_PWRUP_CMPS = 0x100000
	// Position of DISCHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_TOG_DISCHARGE_VBUS_Pos = 0x1a
	// Bit mask of DISCHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_TOG_DISCHARGE_VBUS_Msk = 0x4000000
	// Bit DISCHARGE_VBUS.
	USB_ANALOG_USB1_VBUS_DETECT_TOG_DISCHARGE_VBUS = 0x4000000
	// Position of CHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_TOG_CHARGE_VBUS_Pos = 0x1b
	// Bit mask of CHARGE_VBUS field.
	USB_ANALOG_USB1_VBUS_DETECT_TOG_CHARGE_VBUS_Msk = 0x8000000
	// Bit CHARGE_VBUS.
	USB_ANALOG_USB1_VBUS_DETECT_TOG_CHARGE_VBUS = 0x8000000

	// USB1_CHRG_DETECT: USB Charger Detect Register
	// Position of CHK_CONTACT field.
	USB_ANALOG_USB1_CHRG_DETECT_CHK_CONTACT_Pos = 0x12
	// Bit mask of CHK_CONTACT field.
	USB_ANALOG_USB1_CHRG_DETECT_CHK_CONTACT_Msk = 0x40000
	// Bit CHK_CONTACT.
	USB_ANALOG_USB1_CHRG_DETECT_CHK_CONTACT = 0x40000
	// Do not check the contact of USB plug.
	USB_ANALOG_USB1_CHRG_DETECT_CHK_CONTACT_NO_CHECK = 0x0
	// Check whether the USB plug has been in contact with each other
	USB_ANALOG_USB1_CHRG_DETECT_CHK_CONTACT_CHECK = 0x1
	// Position of CHK_CHRG_B field.
	USB_ANALOG_USB1_CHRG_DETECT_CHK_CHRG_B_Pos = 0x13
	// Bit mask of CHK_CHRG_B field.
	USB_ANALOG_USB1_CHRG_DETECT_CHK_CHRG_B_Msk = 0x80000
	// Bit CHK_CHRG_B.
	USB_ANALOG_USB1_CHRG_DETECT_CHK_CHRG_B = 0x80000
	// Check whether a charger (either a dedicated charger or a host charger) is connected to USB port.
	USB_ANALOG_USB1_CHRG_DETECT_CHK_CHRG_B_CHECK = 0x0
	// Do not check whether a charger is connected to the USB port.
	USB_ANALOG_USB1_CHRG_DETECT_CHK_CHRG_B_NO_CHECK = 0x1
	// Position of EN_B field.
	USB_ANALOG_USB1_CHRG_DETECT_EN_B_Pos = 0x14
	// Bit mask of EN_B field.
	USB_ANALOG_USB1_CHRG_DETECT_EN_B_Msk = 0x100000
	// Bit EN_B.
	USB_ANALOG_USB1_CHRG_DETECT_EN_B = 0x100000
	// Enable the charger detector.
	USB_ANALOG_USB1_CHRG_DETECT_EN_B_ENABLE = 0x0
	// Disable the charger detector.
	USB_ANALOG_USB1_CHRG_DETECT_EN_B_DISABLE = 0x1

	// USB1_CHRG_DETECT_SET: USB Charger Detect Register
	// Position of CHK_CONTACT field.
	USB_ANALOG_USB1_CHRG_DETECT_SET_CHK_CONTACT_Pos = 0x12
	// Bit mask of CHK_CONTACT field.
	USB_ANALOG_USB1_CHRG_DETECT_SET_CHK_CONTACT_Msk = 0x40000
	// Bit CHK_CONTACT.
	USB_ANALOG_USB1_CHRG_DETECT_SET_CHK_CONTACT = 0x40000
	// Do not check the contact of USB plug.
	USB_ANALOG_USB1_CHRG_DETECT_SET_CHK_CONTACT_NO_CHECK = 0x0
	// Check whether the USB plug has been in contact with each other
	USB_ANALOG_USB1_CHRG_DETECT_SET_CHK_CONTACT_CHECK = 0x1
	// Position of CHK_CHRG_B field.
	USB_ANALOG_USB1_CHRG_DETECT_SET_CHK_CHRG_B_Pos = 0x13
	// Bit mask of CHK_CHRG_B field.
	USB_ANALOG_USB1_CHRG_DETECT_SET_CHK_CHRG_B_Msk = 0x80000
	// Bit CHK_CHRG_B.
	USB_ANALOG_USB1_CHRG_DETECT_SET_CHK_CHRG_B = 0x80000
	// Check whether a charger (either a dedicated charger or a host charger) is connected to USB port.
	USB_ANALOG_USB1_CHRG_DETECT_SET_CHK_CHRG_B_CHECK = 0x0
	// Do not check whether a charger is connected to the USB port.
	USB_ANALOG_USB1_CHRG_DETECT_SET_CHK_CHRG_B_NO_CHECK = 0x1
	// Position of EN_B field.
	USB_ANALOG_USB1_CHRG_DETECT_SET_EN_B_Pos = 0x14
	// Bit mask of EN_B field.
	USB_ANALOG_USB1_CHRG_DETECT_SET_EN_B_Msk = 0x100000
	// Bit EN_B.
	USB_ANALOG_USB1_CHRG_DETECT_SET_EN_B = 0x100000
	// Enable the charger detector.
	USB_ANALOG_USB1_CHRG_DETECT_SET_EN_B_ENABLE = 0x0
	// Disable the charger detector.
	USB_ANALOG_USB1_CHRG_DETECT_SET_EN_B_DISABLE = 0x1

	// USB1_CHRG_DETECT_CLR: USB Charger Detect Register
	// Position of CHK_CONTACT field.
	USB_ANALOG_USB1_CHRG_DETECT_CLR_CHK_CONTACT_Pos = 0x12
	// Bit mask of CHK_CONTACT field.
	USB_ANALOG_USB1_CHRG_DETECT_CLR_CHK_CONTACT_Msk = 0x40000
	// Bit CHK_CONTACT.
	USB_ANALOG_USB1_CHRG_DETECT_CLR_CHK_CONTACT = 0x40000
	// Do not check the contact of USB plug.
	USB_ANALOG_USB1_CHRG_DETECT_CLR_CHK_CONTACT_NO_CHECK = 0x0
	// Check whether the USB plug has been in contact with each other
	USB_ANALOG_USB1_CHRG_DETECT_CLR_CHK_CONTACT_CHECK = 0x1
	// Position of CHK_CHRG_B field.
	USB_ANALOG_USB1_CHRG_DETECT_CLR_CHK_CHRG_B_Pos = 0x13
	// Bit mask of CHK_CHRG_B field.
	USB_ANALOG_USB1_CHRG_DETECT_CLR_CHK_CHRG_B_Msk = 0x80000
	// Bit CHK_CHRG_B.
	USB_ANALOG_USB1_CHRG_DETECT_CLR_CHK_CHRG_B = 0x80000
	// Check whether a charger (either a dedicated charger or a host charger) is connected to USB port.
	USB_ANALOG_USB1_CHRG_DETECT_CLR_CHK_CHRG_B_CHECK = 0x0
	// Do not check whether a charger is connected to the USB port.
	USB_ANALOG_USB1_CHRG_DETECT_CLR_CHK_CHRG_B_NO_CHECK = 0x1
	// Position of EN_B field.
	USB_ANALOG_USB1_CHRG_DETECT_CLR_EN_B_Pos = 0x14
	// Bit mask of EN_B field.
	USB_ANALOG_USB1_CHRG_DETECT_CLR_EN_B_Msk = 0x100000
	// Bit EN_B.
	USB_ANALOG_USB1_CHRG_DETECT_CLR_EN_B = 0x100000
	// Enable the charger detector.
	USB_ANALOG_USB1_CHRG_DETECT_CLR_EN_B_ENABLE = 0x0
	// Disable the charger detector.
	USB_ANALOG_USB1_CHRG_DETECT_CLR_EN_B_DISABLE = 0x1

	// USB1_CHRG_DETECT_TOG: USB Charger Detect Register
	// Position of CHK_CONTACT field.
	USB_ANALOG_USB1_CHRG_DETECT_TOG_CHK_CONTACT_Pos = 0x12
	// Bit mask of CHK_CONTACT field.
	USB_ANALOG_USB1_CHRG_DETECT_TOG_CHK_CONTACT_Msk = 0x40000
	// Bit CHK_CONTACT.
	USB_ANALOG_USB1_CHRG_DETECT_TOG_CHK_CONTACT = 0x40000
	// Do not check the contact of USB plug.
	USB_ANALOG_USB1_CHRG_DETECT_TOG_CHK_CONTACT_NO_CHECK = 0x0
	// Check whether the USB plug has been in contact with each other
	USB_ANALOG_USB1_CHRG_DETECT_TOG_CHK_CONTACT_CHECK = 0x1
	// Position of CHK_CHRG_B field.
	USB_ANALOG_USB1_CHRG_DETECT_TOG_CHK_CHRG_B_Pos = 0x13
	// Bit mask of CHK_CHRG_B field.
	USB_ANALOG_USB1_CHRG_DETECT_TOG_CHK_CHRG_B_Msk = 0x80000
	// Bit CHK_CHRG_B.
	USB_ANALOG_USB1_CHRG_DETECT_TOG_CHK_CHRG_B = 0x80000
	// Check whether a charger (either a dedicated charger or a host charger) is connected to USB port.
	USB_ANALOG_USB1_CHRG_DETECT_TOG_CHK_CHRG_B_CHECK = 0x0
	// Do not check whether a charger is connected to the USB port.
	USB_ANALOG_USB1_CHRG_DETECT_TOG_CHK_CHRG_B_NO_CHECK = 0x1
	// Position of EN_B field.
	USB_ANALOG_USB1_CHRG_DETECT_TOG_EN_B_Pos = 0x14
	// Bit mask of EN_B field.
	USB_ANALOG_USB1_CHRG_DETECT_TOG_EN_B_Msk = 0x100000
	// Bit EN_B.
	USB_ANALOG_USB1_CHRG_DETECT_TOG_EN_B = 0x100000
	// Enable the charger detector.
	USB_ANALOG_USB1_CHRG_DETECT_TOG_EN_B_ENABLE = 0x0
	// Disable the charger detector.
	USB_ANALOG_USB1_CHRG_DETECT_TOG_EN_B_DISABLE = 0x1

	// USB1_VBUS_DETECT_STAT: USB VBUS Detect Status Register
	// Position of SESSEND field.
	USB_ANALOG_USB1_VBUS_DETECT_STAT_SESSEND_Pos = 0x0
	// Bit mask of SESSEND field.
	USB_ANALOG_USB1_VBUS_DETECT_STAT_SESSEND_Msk = 0x1
	// Bit SESSEND.
	USB_ANALOG_USB1_VBUS_DETECT_STAT_SESSEND = 0x1
	// Position of BVALID field.
	USB_ANALOG_USB1_VBUS_DETECT_STAT_BVALID_Pos = 0x1
	// Bit mask of BVALID field.
	USB_ANALOG_USB1_VBUS_DETECT_STAT_BVALID_Msk = 0x2
	// Bit BVALID.
	USB_ANALOG_USB1_VBUS_DETECT_STAT_BVALID = 0x2
	// Position of AVALID field.
	USB_ANALOG_USB1_VBUS_DETECT_STAT_AVALID_Pos = 0x2
	// Bit mask of AVALID field.
	USB_ANALOG_USB1_VBUS_DETECT_STAT_AVALID_Msk = 0x4
	// Bit AVALID.
	USB_ANALOG_USB1_VBUS_DETECT_STAT_AVALID = 0x4
	// Position of VBUS_VALID field.
	USB_ANALOG_USB1_VBUS_DETECT_STAT_VBUS_VALID_Pos = 0x3
	// Bit mask of VBUS_VALID field.
	USB_ANALOG_USB1_VBUS_DETECT_STAT_VBUS_VALID_Msk = 0x8
	// Bit VBUS_VALID.
	USB_ANALOG_USB1_VBUS_DETECT_STAT_VBUS_VALID = 0x8

	// USB1_CHRG_DETECT_STAT: USB Charger Detect Status Register
	// Position of PLUG_CONTACT field.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_PLUG_CONTACT_Pos = 0x0
	// Bit mask of PLUG_CONTACT field.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_PLUG_CONTACT_Msk = 0x1
	// Bit PLUG_CONTACT.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_PLUG_CONTACT = 0x1
	// The USB plug has not made contact.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_PLUG_CONTACT_NO_CONTACT = 0x0
	// The USB plug has made good contact.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_PLUG_CONTACT_GOOD_CONTACT = 0x1
	// Position of CHRG_DETECTED field.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_CHRG_DETECTED_Pos = 0x1
	// Bit mask of CHRG_DETECTED field.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_CHRG_DETECTED_Msk = 0x2
	// Bit CHRG_DETECTED.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_CHRG_DETECTED = 0x2
	// The USB port is not connected to a charger.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_CHRG_DETECTED_CHARGER_NOT_PRESENT = 0x0
	// A charger (either a dedicated charger or a host charger) is connected to the USB port.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_CHRG_DETECTED_CHARGER_PRESENT = 0x1
	// Position of DM_STATE field.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_DM_STATE_Pos = 0x2
	// Bit mask of DM_STATE field.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_DM_STATE_Msk = 0x4
	// Bit DM_STATE.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_DM_STATE = 0x4
	// Position of DP_STATE field.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_DP_STATE_Pos = 0x3
	// Bit mask of DP_STATE field.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_DP_STATE_Msk = 0x8
	// Bit DP_STATE.
	USB_ANALOG_USB1_CHRG_DETECT_STAT_DP_STATE = 0x8

	// USB1_LOOPBACK: USB Loopback Test Register
	// Position of UTMI_TESTSTART field.
	USB_ANALOG_USB1_LOOPBACK_UTMI_TESTSTART_Pos = 0x0
	// Bit mask of UTMI_TESTSTART field.
	USB_ANALOG_USB1_LOOPBACK_UTMI_TESTSTART_Msk = 0x1
	// Bit UTMI_TESTSTART.
	USB_ANALOG_USB1_LOOPBACK_UTMI_TESTSTART = 0x1

	// USB1_LOOPBACK_SET: USB Loopback Test Register
	// Position of UTMI_TESTSTART field.
	USB_ANALOG_USB1_LOOPBACK_SET_UTMI_TESTSTART_Pos = 0x0
	// Bit mask of UTMI_TESTSTART field.
	USB_ANALOG_USB1_LOOPBACK_SET_UTMI_TESTSTART_Msk = 0x1
	// Bit UTMI_TESTSTART.
	USB_ANALOG_USB1_LOOPBACK_SET_UTMI_TESTSTART = 0x1

	// USB1_LOOPBACK_CLR: USB Loopback Test Register
	// Position of UTMI_TESTSTART field.
	USB_ANALOG_USB1_LOOPBACK_CLR_UTMI_TESTSTART_Pos = 0x0
	// Bit mask of UTMI_TESTSTART field.
	USB_ANALOG_USB1_LOOPBACK_CLR_UTMI_TESTSTART_Msk = 0x1
	// Bit UTMI_TESTSTART.
	USB_ANALOG_USB1_LOOPBACK_CLR_UTMI_TESTSTART = 0x1

	// USB1_LOOPBACK_TOG: USB Loopback Test Register
	// Position of UTMI_TESTSTART field.
	USB_ANALOG_USB1_LOOPBACK_TOG_UTMI_TESTSTART_Pos = 0x0
	// Bit mask of UTMI_TESTSTART field.
	USB_ANALOG_USB1_LOOPBACK_TOG_UTMI_TESTSTART_Msk = 0x1
	// Bit UTMI_TESTSTART.
	USB_ANALOG_USB1_LOOPBACK_TOG_UTMI_TESTSTART = 0x1

	// USB1_MISC: USB Misc Register
	// Position of HS_USE_EXTERNAL_R field.
	USB_ANALOG_USB1_MISC_HS_USE_EXTERNAL_R_Pos = 0x0
	// Bit mask of HS_USE_EXTERNAL_R field.
	USB_ANALOG_USB1_MISC_HS_USE_EXTERNAL_R_Msk = 0x1
	// Bit HS_USE_EXTERNAL_R.
	USB_ANALOG_USB1_MISC_HS_USE_EXTERNAL_R = 0x1
	// Position of EN_DEGLITCH field.
	USB_ANALOG_USB1_MISC_EN_DEGLITCH_Pos = 0x1
	// Bit mask of EN_DEGLITCH field.
	USB_ANALOG_USB1_MISC_EN_DEGLITCH_Msk = 0x2
	// Bit EN_DEGLITCH.
	USB_ANALOG_USB1_MISC_EN_DEGLITCH = 0x2
	// Position of EN_CLK_UTMI field.
	USB_ANALOG_USB1_MISC_EN_CLK_UTMI_Pos = 0x1e
	// Bit mask of EN_CLK_UTMI field.
	USB_ANALOG_USB1_MISC_EN_CLK_UTMI_Msk = 0x40000000
	// Bit EN_CLK_UTMI.
	USB_ANALOG_USB1_MISC_EN_CLK_UTMI = 0x40000000

	// USB1_MISC_SET: USB Misc Register
	// Position of HS_USE_EXTERNAL_R field.
	USB_ANALOG_USB1_MISC_SET_HS_USE_EXTERNAL_R_Pos = 0x0
	// Bit mask of HS_USE_EXTERNAL_R field.
	USB_ANALOG_USB1_MISC_SET_HS_USE_EXTERNAL_R_Msk = 0x1
	// Bit HS_USE_EXTERNAL_R.
	USB_ANALOG_USB1_MISC_SET_HS_USE_EXTERNAL_R = 0x1
	// Position of EN_DEGLITCH field.
	USB_ANALOG_USB1_MISC_SET_EN_DEGLITCH_Pos = 0x1
	// Bit mask of EN_DEGLITCH field.
	USB_ANALOG_USB1_MISC_SET_EN_DEGLITCH_Msk = 0x2
	// Bit EN_DEGLITCH.
	USB_ANALOG_USB1_MISC_SET_EN_DEGLITCH = 0x2
	// Position of EN_CLK_UTMI field.
	USB_ANALOG_USB1_MISC_SET_EN_CLK_UTMI_Pos = 0x1e
	// Bit mask of EN_CLK_UTMI field.
	USB_ANALOG_USB1_MISC_SET_EN_CLK_UTMI_Msk = 0x40000000
	// Bit EN_CLK_UTMI.
	USB_ANALOG_USB1_MISC_SET_EN_CLK_UTMI = 0x40000000

	// USB1_MISC_CLR: USB Misc Register
	// Position of HS_USE_EXTERNAL_R field.
	USB_ANALOG_USB1_MISC_CLR_HS_USE_EXTERNAL_R_Pos = 0x0
	// Bit mask of HS_USE_EXTERNAL_R field.
	USB_ANALOG_USB1_MISC_CLR_HS_USE_EXTERNAL_R_Msk = 0x1
	// Bit HS_USE_EXTERNAL_R.
	USB_ANALOG_USB1_MISC_CLR_HS_USE_EXTERNAL_R = 0x1
	// Position of EN_DEGLITCH field.
	USB_ANALOG_USB1_MISC_CLR_EN_DEGLITCH_Pos = 0x1
	// Bit mask of EN_DEGLITCH field.
	USB_ANALOG_USB1_MISC_CLR_EN_DEGLITCH_Msk = 0x2
	// Bit EN_DEGLITCH.
	USB_ANALOG_USB1_MISC_CLR_EN_DEGLITCH = 0x2
	// Position of EN_CLK_UTMI field.
	USB_ANALOG_USB1_MISC_CLR_EN_CLK_UTMI_Pos = 0x1e
	// Bit mask of EN_CLK_UTMI field.
	USB_ANALOG_USB1_MISC_CLR_EN_CLK_UTMI_Msk = 0x40000000
	// Bit EN_CLK_UTMI.
	USB_ANALOG_USB1_MISC_CLR_EN_CLK_UTMI = 0x40000000

	// USB1_MISC_TOG: USB Misc Register
	// Position of HS_USE_EXTERNAL_R field.
	USB_ANALOG_USB1_MISC_TOG_HS_USE_EXTERNAL_R_Pos = 0x0
	// Bit mask of HS_USE_EXTERNAL_R field.
	USB_ANALOG_USB1_MISC_TOG_HS_USE_EXTERNAL_R_Msk = 0x1
	// Bit HS_USE_EXTERNAL_R.
	USB_ANALOG_USB1_MISC_TOG_HS_USE_EXTERNAL_R = 0x1
	// Position of EN_DEGLITCH field.
	USB_ANALOG_USB1_MISC_TOG_EN_DEGLITCH_Pos = 0x1
	// Bit mask of EN_DEGLITCH field.
	USB_ANALOG_USB1_MISC_TOG_EN_DEGLITCH_Msk = 0x2
	// Bit EN_DEGLITCH.
	USB_ANALOG_USB1_MISC_TOG_EN_DEGLITCH = 0x2
	// Position of EN_CLK_UTMI field.
	USB_ANALOG_USB1_MISC_TOG_EN_CLK_UTMI_Pos = 0x1e
	// Bit mask of EN_CLK_UTMI field.
	USB_ANALOG_USB1_MISC_TOG_EN_CLK_UTMI_Msk = 0x40000000
	// Bit EN_CLK_UTMI.
	USB_ANALOG_USB1_MISC_TOG_EN_CLK_UTMI = 0x40000000

	// DIGPROG: Chip Silicon Version
	// Position of SILICON_REVISION field.
	USB_ANALOG_DIGPROG_SILICON_REVISION_Pos = 0x0
	// Bit mask of SILICON_REVISION field.
	USB_ANALOG_DIGPROG_SILICON_REVISION_Msk = 0xffffffff
	// Silicon revision 1.0
	USB_ANALOG_DIGPROG_SILICON_REVISION_SILICON_REVISION_7143424 = 0x6d0000
)

// Constants for XTALOSC24M: XTALOSC24M
const (
	// MISC0: Miscellaneous Register 0
	// Position of REFTOP_PWD field.
	XTALOSC24M_MISC0_REFTOP_PWD_Pos = 0x0
	// Bit mask of REFTOP_PWD field.
	XTALOSC24M_MISC0_REFTOP_PWD_Msk = 0x1
	// Bit REFTOP_PWD.
	XTALOSC24M_MISC0_REFTOP_PWD = 0x1
	// Position of REFTOP_SELFBIASOFF field.
	XTALOSC24M_MISC0_REFTOP_SELFBIASOFF_Pos = 0x3
	// Bit mask of REFTOP_SELFBIASOFF field.
	XTALOSC24M_MISC0_REFTOP_SELFBIASOFF_Msk = 0x8
	// Bit REFTOP_SELFBIASOFF.
	XTALOSC24M_MISC0_REFTOP_SELFBIASOFF = 0x8
	// Uses coarse bias currents for startup
	XTALOSC24M_MISC0_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_0 = 0x0
	// Uses bandgap-based bias currents for best performance.
	XTALOSC24M_MISC0_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_1 = 0x1
	// Position of REFTOP_VBGADJ field.
	XTALOSC24M_MISC0_REFTOP_VBGADJ_Pos = 0x4
	// Bit mask of REFTOP_VBGADJ field.
	XTALOSC24M_MISC0_REFTOP_VBGADJ_Msk = 0x70
	// Nominal VBG
	XTALOSC24M_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_0 = 0x0
	// VBG+0.78%
	XTALOSC24M_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_1 = 0x1
	// VBG+1.56%
	XTALOSC24M_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_2 = 0x2
	// VBG+2.34%
	XTALOSC24M_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_3 = 0x3
	// VBG-0.78%
	XTALOSC24M_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_4 = 0x4
	// VBG-1.56%
	XTALOSC24M_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_5 = 0x5
	// VBG-2.34%
	XTALOSC24M_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_6 = 0x6
	// VBG-3.12%
	XTALOSC24M_MISC0_REFTOP_VBGADJ_REFTOP_VBGADJ_7 = 0x7
	// Position of REFTOP_VBGUP field.
	XTALOSC24M_MISC0_REFTOP_VBGUP_Pos = 0x7
	// Bit mask of REFTOP_VBGUP field.
	XTALOSC24M_MISC0_REFTOP_VBGUP_Msk = 0x80
	// Bit REFTOP_VBGUP.
	XTALOSC24M_MISC0_REFTOP_VBGUP = 0x80
	// Position of STOP_MODE_CONFIG field.
	XTALOSC24M_MISC0_STOP_MODE_CONFIG_Pos = 0xa
	// Bit mask of STOP_MODE_CONFIG field.
	XTALOSC24M_MISC0_STOP_MODE_CONFIG_Msk = 0xc00
	// All analog except rtc powered down on stop mode assertion. XtalOsc=on, RCOsc=off;
	XTALOSC24M_MISC0_STOP_MODE_CONFIG_STOP_MODE_CONFIG_0 = 0x0
	// Certain analog functions such as certain regulators left up. XtalOsc=on, RCOsc=off;
	XTALOSC24M_MISC0_STOP_MODE_CONFIG_STOP_MODE_CONFIG_1 = 0x1
	// XtalOsc=off, RCOsc=on, Old BG=on, New BG=off.
	XTALOSC24M_MISC0_STOP_MODE_CONFIG_STOP_MODE_CONFIG_2 = 0x2
	// XtalOsc=off, RCOsc=on, Old BG=off, New BG=on.
	XTALOSC24M_MISC0_STOP_MODE_CONFIG_STOP_MODE_CONFIG_3 = 0x3
	// Position of DISCON_HIGH_SNVS field.
	XTALOSC24M_MISC0_DISCON_HIGH_SNVS_Pos = 0xc
	// Bit mask of DISCON_HIGH_SNVS field.
	XTALOSC24M_MISC0_DISCON_HIGH_SNVS_Msk = 0x1000
	// Bit DISCON_HIGH_SNVS.
	XTALOSC24M_MISC0_DISCON_HIGH_SNVS = 0x1000
	// Turn on the switch
	XTALOSC24M_MISC0_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_0 = 0x0
	// Turn off the switch
	XTALOSC24M_MISC0_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_1 = 0x1
	// Position of OSC_I field.
	XTALOSC24M_MISC0_OSC_I_Pos = 0xd
	// Bit mask of OSC_I field.
	XTALOSC24M_MISC0_OSC_I_Msk = 0x6000
	// Nominal
	XTALOSC24M_MISC0_OSC_I_NOMINAL = 0x0
	// Decrease current by 12.5%
	XTALOSC24M_MISC0_OSC_I_MINUS_12_5_PERCENT = 0x1
	// Decrease current by 25.0%
	XTALOSC24M_MISC0_OSC_I_MINUS_25_PERCENT = 0x2
	// Decrease current by 37.5%
	XTALOSC24M_MISC0_OSC_I_MINUS_37_5_PERCENT = 0x3
	// Position of OSC_XTALOK field.
	XTALOSC24M_MISC0_OSC_XTALOK_Pos = 0xf
	// Bit mask of OSC_XTALOK field.
	XTALOSC24M_MISC0_OSC_XTALOK_Msk = 0x8000
	// Bit OSC_XTALOK.
	XTALOSC24M_MISC0_OSC_XTALOK = 0x8000
	// Position of OSC_XTALOK_EN field.
	XTALOSC24M_MISC0_OSC_XTALOK_EN_Pos = 0x10
	// Bit mask of OSC_XTALOK_EN field.
	XTALOSC24M_MISC0_OSC_XTALOK_EN_Msk = 0x10000
	// Bit OSC_XTALOK_EN.
	XTALOSC24M_MISC0_OSC_XTALOK_EN = 0x10000
	// Position of CLKGATE_CTRL field.
	XTALOSC24M_MISC0_CLKGATE_CTRL_Pos = 0x19
	// Bit mask of CLKGATE_CTRL field.
	XTALOSC24M_MISC0_CLKGATE_CTRL_Msk = 0x2000000
	// Bit CLKGATE_CTRL.
	XTALOSC24M_MISC0_CLKGATE_CTRL = 0x2000000
	// Allow the logic to automatically gate the clock when the XTAL is powered down.
	XTALOSC24M_MISC0_CLKGATE_CTRL_ALLOW_AUTO_GATE = 0x0
	// Prevent the logic from ever gating off the clock.
	XTALOSC24M_MISC0_CLKGATE_CTRL_NO_AUTO_GATE = 0x1
	// Position of CLKGATE_DELAY field.
	XTALOSC24M_MISC0_CLKGATE_DELAY_Pos = 0x1a
	// Bit mask of CLKGATE_DELAY field.
	XTALOSC24M_MISC0_CLKGATE_DELAY_Msk = 0x1c000000
	// 0.5ms
	XTALOSC24M_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_0 = 0x0
	// 1.0ms
	XTALOSC24M_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_1 = 0x1
	// 2.0ms
	XTALOSC24M_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_2 = 0x2
	// 3.0ms
	XTALOSC24M_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_3 = 0x3
	// 4.0ms
	XTALOSC24M_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_4 = 0x4
	// 5.0ms
	XTALOSC24M_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_5 = 0x5
	// 6.0ms
	XTALOSC24M_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_6 = 0x6
	// 7.0ms
	XTALOSC24M_MISC0_CLKGATE_DELAY_CLKGATE_DELAY_7 = 0x7
	// Position of RTC_XTAL_SOURCE field.
	XTALOSC24M_MISC0_RTC_XTAL_SOURCE_Pos = 0x1d
	// Bit mask of RTC_XTAL_SOURCE field.
	XTALOSC24M_MISC0_RTC_XTAL_SOURCE_Msk = 0x20000000
	// Bit RTC_XTAL_SOURCE.
	XTALOSC24M_MISC0_RTC_XTAL_SOURCE = 0x20000000
	// Internal ring oscillator
	XTALOSC24M_MISC0_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_0 = 0x0
	// RTC_XTAL
	XTALOSC24M_MISC0_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_1 = 0x1
	// Position of XTAL_24M_PWD field.
	XTALOSC24M_MISC0_XTAL_24M_PWD_Pos = 0x1e
	// Bit mask of XTAL_24M_PWD field.
	XTALOSC24M_MISC0_XTAL_24M_PWD_Msk = 0x40000000
	// Bit XTAL_24M_PWD.
	XTALOSC24M_MISC0_XTAL_24M_PWD = 0x40000000
	// Position of VID_PLL_PREDIV field.
	XTALOSC24M_MISC0_VID_PLL_PREDIV_Pos = 0x1f
	// Bit mask of VID_PLL_PREDIV field.
	XTALOSC24M_MISC0_VID_PLL_PREDIV_Msk = 0x80000000
	// Bit VID_PLL_PREDIV.
	XTALOSC24M_MISC0_VID_PLL_PREDIV = 0x80000000
	// Divide by 1
	XTALOSC24M_MISC0_VID_PLL_PREDIV_VID_PLL_PREDIV_0 = 0x0
	// Divide by 2
	XTALOSC24M_MISC0_VID_PLL_PREDIV_VID_PLL_PREDIV_1 = 0x1

	// MISC0_SET: Miscellaneous Register 0
	// Position of REFTOP_PWD field.
	XTALOSC24M_MISC0_SET_REFTOP_PWD_Pos = 0x0
	// Bit mask of REFTOP_PWD field.
	XTALOSC24M_MISC0_SET_REFTOP_PWD_Msk = 0x1
	// Bit REFTOP_PWD.
	XTALOSC24M_MISC0_SET_REFTOP_PWD = 0x1
	// Position of REFTOP_SELFBIASOFF field.
	XTALOSC24M_MISC0_SET_REFTOP_SELFBIASOFF_Pos = 0x3
	// Bit mask of REFTOP_SELFBIASOFF field.
	XTALOSC24M_MISC0_SET_REFTOP_SELFBIASOFF_Msk = 0x8
	// Bit REFTOP_SELFBIASOFF.
	XTALOSC24M_MISC0_SET_REFTOP_SELFBIASOFF = 0x8
	// Uses coarse bias currents for startup
	XTALOSC24M_MISC0_SET_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_0 = 0x0
	// Uses bandgap-based bias currents for best performance.
	XTALOSC24M_MISC0_SET_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_1 = 0x1
	// Position of REFTOP_VBGADJ field.
	XTALOSC24M_MISC0_SET_REFTOP_VBGADJ_Pos = 0x4
	// Bit mask of REFTOP_VBGADJ field.
	XTALOSC24M_MISC0_SET_REFTOP_VBGADJ_Msk = 0x70
	// Nominal VBG
	XTALOSC24M_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_0 = 0x0
	// VBG+0.78%
	XTALOSC24M_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_1 = 0x1
	// VBG+1.56%
	XTALOSC24M_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_2 = 0x2
	// VBG+2.34%
	XTALOSC24M_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_3 = 0x3
	// VBG-0.78%
	XTALOSC24M_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_4 = 0x4
	// VBG-1.56%
	XTALOSC24M_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_5 = 0x5
	// VBG-2.34%
	XTALOSC24M_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_6 = 0x6
	// VBG-3.12%
	XTALOSC24M_MISC0_SET_REFTOP_VBGADJ_REFTOP_VBGADJ_7 = 0x7
	// Position of REFTOP_VBGUP field.
	XTALOSC24M_MISC0_SET_REFTOP_VBGUP_Pos = 0x7
	// Bit mask of REFTOP_VBGUP field.
	XTALOSC24M_MISC0_SET_REFTOP_VBGUP_Msk = 0x80
	// Bit REFTOP_VBGUP.
	XTALOSC24M_MISC0_SET_REFTOP_VBGUP = 0x80
	// Position of STOP_MODE_CONFIG field.
	XTALOSC24M_MISC0_SET_STOP_MODE_CONFIG_Pos = 0xa
	// Bit mask of STOP_MODE_CONFIG field.
	XTALOSC24M_MISC0_SET_STOP_MODE_CONFIG_Msk = 0xc00
	// All analog except rtc powered down on stop mode assertion. XtalOsc=on, RCOsc=off;
	XTALOSC24M_MISC0_SET_STOP_MODE_CONFIG_STOP_MODE_CONFIG_0 = 0x0
	// Certain analog functions such as certain regulators left up. XtalOsc=on, RCOsc=off;
	XTALOSC24M_MISC0_SET_STOP_MODE_CONFIG_STOP_MODE_CONFIG_1 = 0x1
	// XtalOsc=off, RCOsc=on, Old BG=on, New BG=off.
	XTALOSC24M_MISC0_SET_STOP_MODE_CONFIG_STOP_MODE_CONFIG_2 = 0x2
	// XtalOsc=off, RCOsc=on, Old BG=off, New BG=on.
	XTALOSC24M_MISC0_SET_STOP_MODE_CONFIG_STOP_MODE_CONFIG_3 = 0x3
	// Position of DISCON_HIGH_SNVS field.
	XTALOSC24M_MISC0_SET_DISCON_HIGH_SNVS_Pos = 0xc
	// Bit mask of DISCON_HIGH_SNVS field.
	XTALOSC24M_MISC0_SET_DISCON_HIGH_SNVS_Msk = 0x1000
	// Bit DISCON_HIGH_SNVS.
	XTALOSC24M_MISC0_SET_DISCON_HIGH_SNVS = 0x1000
	// Turn on the switch
	XTALOSC24M_MISC0_SET_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_0 = 0x0
	// Turn off the switch
	XTALOSC24M_MISC0_SET_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_1 = 0x1
	// Position of OSC_I field.
	XTALOSC24M_MISC0_SET_OSC_I_Pos = 0xd
	// Bit mask of OSC_I field.
	XTALOSC24M_MISC0_SET_OSC_I_Msk = 0x6000
	// Nominal
	XTALOSC24M_MISC0_SET_OSC_I_NOMINAL = 0x0
	// Decrease current by 12.5%
	XTALOSC24M_MISC0_SET_OSC_I_MINUS_12_5_PERCENT = 0x1
	// Decrease current by 25.0%
	XTALOSC24M_MISC0_SET_OSC_I_MINUS_25_PERCENT = 0x2
	// Decrease current by 37.5%
	XTALOSC24M_MISC0_SET_OSC_I_MINUS_37_5_PERCENT = 0x3
	// Position of OSC_XTALOK field.
	XTALOSC24M_MISC0_SET_OSC_XTALOK_Pos = 0xf
	// Bit mask of OSC_XTALOK field.
	XTALOSC24M_MISC0_SET_OSC_XTALOK_Msk = 0x8000
	// Bit OSC_XTALOK.
	XTALOSC24M_MISC0_SET_OSC_XTALOK = 0x8000
	// Position of OSC_XTALOK_EN field.
	XTALOSC24M_MISC0_SET_OSC_XTALOK_EN_Pos = 0x10
	// Bit mask of OSC_XTALOK_EN field.
	XTALOSC24M_MISC0_SET_OSC_XTALOK_EN_Msk = 0x10000
	// Bit OSC_XTALOK_EN.
	XTALOSC24M_MISC0_SET_OSC_XTALOK_EN = 0x10000
	// Position of CLKGATE_CTRL field.
	XTALOSC24M_MISC0_SET_CLKGATE_CTRL_Pos = 0x19
	// Bit mask of CLKGATE_CTRL field.
	XTALOSC24M_MISC0_SET_CLKGATE_CTRL_Msk = 0x2000000
	// Bit CLKGATE_CTRL.
	XTALOSC24M_MISC0_SET_CLKGATE_CTRL = 0x2000000
	// Allow the logic to automatically gate the clock when the XTAL is powered down.
	XTALOSC24M_MISC0_SET_CLKGATE_CTRL_ALLOW_AUTO_GATE = 0x0
	// Prevent the logic from ever gating off the clock.
	XTALOSC24M_MISC0_SET_CLKGATE_CTRL_NO_AUTO_GATE = 0x1
	// Position of CLKGATE_DELAY field.
	XTALOSC24M_MISC0_SET_CLKGATE_DELAY_Pos = 0x1a
	// Bit mask of CLKGATE_DELAY field.
	XTALOSC24M_MISC0_SET_CLKGATE_DELAY_Msk = 0x1c000000
	// 0.5ms
	XTALOSC24M_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_0 = 0x0
	// 1.0ms
	XTALOSC24M_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_1 = 0x1
	// 2.0ms
	XTALOSC24M_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_2 = 0x2
	// 3.0ms
	XTALOSC24M_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_3 = 0x3
	// 4.0ms
	XTALOSC24M_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_4 = 0x4
	// 5.0ms
	XTALOSC24M_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_5 = 0x5
	// 6.0ms
	XTALOSC24M_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_6 = 0x6
	// 7.0ms
	XTALOSC24M_MISC0_SET_CLKGATE_DELAY_CLKGATE_DELAY_7 = 0x7
	// Position of RTC_XTAL_SOURCE field.
	XTALOSC24M_MISC0_SET_RTC_XTAL_SOURCE_Pos = 0x1d
	// Bit mask of RTC_XTAL_SOURCE field.
	XTALOSC24M_MISC0_SET_RTC_XTAL_SOURCE_Msk = 0x20000000
	// Bit RTC_XTAL_SOURCE.
	XTALOSC24M_MISC0_SET_RTC_XTAL_SOURCE = 0x20000000
	// Internal ring oscillator
	XTALOSC24M_MISC0_SET_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_0 = 0x0
	// RTC_XTAL
	XTALOSC24M_MISC0_SET_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_1 = 0x1
	// Position of XTAL_24M_PWD field.
	XTALOSC24M_MISC0_SET_XTAL_24M_PWD_Pos = 0x1e
	// Bit mask of XTAL_24M_PWD field.
	XTALOSC24M_MISC0_SET_XTAL_24M_PWD_Msk = 0x40000000
	// Bit XTAL_24M_PWD.
	XTALOSC24M_MISC0_SET_XTAL_24M_PWD = 0x40000000
	// Position of VID_PLL_PREDIV field.
	XTALOSC24M_MISC0_SET_VID_PLL_PREDIV_Pos = 0x1f
	// Bit mask of VID_PLL_PREDIV field.
	XTALOSC24M_MISC0_SET_VID_PLL_PREDIV_Msk = 0x80000000
	// Bit VID_PLL_PREDIV.
	XTALOSC24M_MISC0_SET_VID_PLL_PREDIV = 0x80000000
	// Divide by 1
	XTALOSC24M_MISC0_SET_VID_PLL_PREDIV_VID_PLL_PREDIV_0 = 0x0
	// Divide by 2
	XTALOSC24M_MISC0_SET_VID_PLL_PREDIV_VID_PLL_PREDIV_1 = 0x1

	// MISC0_CLR: Miscellaneous Register 0
	// Position of REFTOP_PWD field.
	XTALOSC24M_MISC0_CLR_REFTOP_PWD_Pos = 0x0
	// Bit mask of REFTOP_PWD field.
	XTALOSC24M_MISC0_CLR_REFTOP_PWD_Msk = 0x1
	// Bit REFTOP_PWD.
	XTALOSC24M_MISC0_CLR_REFTOP_PWD = 0x1
	// Position of REFTOP_SELFBIASOFF field.
	XTALOSC24M_MISC0_CLR_REFTOP_SELFBIASOFF_Pos = 0x3
	// Bit mask of REFTOP_SELFBIASOFF field.
	XTALOSC24M_MISC0_CLR_REFTOP_SELFBIASOFF_Msk = 0x8
	// Bit REFTOP_SELFBIASOFF.
	XTALOSC24M_MISC0_CLR_REFTOP_SELFBIASOFF = 0x8
	// Uses coarse bias currents for startup
	XTALOSC24M_MISC0_CLR_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_0 = 0x0
	// Uses bandgap-based bias currents for best performance.
	XTALOSC24M_MISC0_CLR_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_1 = 0x1
	// Position of REFTOP_VBGADJ field.
	XTALOSC24M_MISC0_CLR_REFTOP_VBGADJ_Pos = 0x4
	// Bit mask of REFTOP_VBGADJ field.
	XTALOSC24M_MISC0_CLR_REFTOP_VBGADJ_Msk = 0x70
	// Nominal VBG
	XTALOSC24M_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_0 = 0x0
	// VBG+0.78%
	XTALOSC24M_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_1 = 0x1
	// VBG+1.56%
	XTALOSC24M_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_2 = 0x2
	// VBG+2.34%
	XTALOSC24M_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_3 = 0x3
	// VBG-0.78%
	XTALOSC24M_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_4 = 0x4
	// VBG-1.56%
	XTALOSC24M_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_5 = 0x5
	// VBG-2.34%
	XTALOSC24M_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_6 = 0x6
	// VBG-3.12%
	XTALOSC24M_MISC0_CLR_REFTOP_VBGADJ_REFTOP_VBGADJ_7 = 0x7
	// Position of REFTOP_VBGUP field.
	XTALOSC24M_MISC0_CLR_REFTOP_VBGUP_Pos = 0x7
	// Bit mask of REFTOP_VBGUP field.
	XTALOSC24M_MISC0_CLR_REFTOP_VBGUP_Msk = 0x80
	// Bit REFTOP_VBGUP.
	XTALOSC24M_MISC0_CLR_REFTOP_VBGUP = 0x80
	// Position of STOP_MODE_CONFIG field.
	XTALOSC24M_MISC0_CLR_STOP_MODE_CONFIG_Pos = 0xa
	// Bit mask of STOP_MODE_CONFIG field.
	XTALOSC24M_MISC0_CLR_STOP_MODE_CONFIG_Msk = 0xc00
	// All analog except rtc powered down on stop mode assertion. XtalOsc=on, RCOsc=off;
	XTALOSC24M_MISC0_CLR_STOP_MODE_CONFIG_STOP_MODE_CONFIG_0 = 0x0
	// Certain analog functions such as certain regulators left up. XtalOsc=on, RCOsc=off;
	XTALOSC24M_MISC0_CLR_STOP_MODE_CONFIG_STOP_MODE_CONFIG_1 = 0x1
	// XtalOsc=off, RCOsc=on, Old BG=on, New BG=off.
	XTALOSC24M_MISC0_CLR_STOP_MODE_CONFIG_STOP_MODE_CONFIG_2 = 0x2
	// XtalOsc=off, RCOsc=on, Old BG=off, New BG=on.
	XTALOSC24M_MISC0_CLR_STOP_MODE_CONFIG_STOP_MODE_CONFIG_3 = 0x3
	// Position of DISCON_HIGH_SNVS field.
	XTALOSC24M_MISC0_CLR_DISCON_HIGH_SNVS_Pos = 0xc
	// Bit mask of DISCON_HIGH_SNVS field.
	XTALOSC24M_MISC0_CLR_DISCON_HIGH_SNVS_Msk = 0x1000
	// Bit DISCON_HIGH_SNVS.
	XTALOSC24M_MISC0_CLR_DISCON_HIGH_SNVS = 0x1000
	// Turn on the switch
	XTALOSC24M_MISC0_CLR_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_0 = 0x0
	// Turn off the switch
	XTALOSC24M_MISC0_CLR_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_1 = 0x1
	// Position of OSC_I field.
	XTALOSC24M_MISC0_CLR_OSC_I_Pos = 0xd
	// Bit mask of OSC_I field.
	XTALOSC24M_MISC0_CLR_OSC_I_Msk = 0x6000
	// Nominal
	XTALOSC24M_MISC0_CLR_OSC_I_NOMINAL = 0x0
	// Decrease current by 12.5%
	XTALOSC24M_MISC0_CLR_OSC_I_MINUS_12_5_PERCENT = 0x1
	// Decrease current by 25.0%
	XTALOSC24M_MISC0_CLR_OSC_I_MINUS_25_PERCENT = 0x2
	// Decrease current by 37.5%
	XTALOSC24M_MISC0_CLR_OSC_I_MINUS_37_5_PERCENT = 0x3
	// Position of OSC_XTALOK field.
	XTALOSC24M_MISC0_CLR_OSC_XTALOK_Pos = 0xf
	// Bit mask of OSC_XTALOK field.
	XTALOSC24M_MISC0_CLR_OSC_XTALOK_Msk = 0x8000
	// Bit OSC_XTALOK.
	XTALOSC24M_MISC0_CLR_OSC_XTALOK = 0x8000
	// Position of OSC_XTALOK_EN field.
	XTALOSC24M_MISC0_CLR_OSC_XTALOK_EN_Pos = 0x10
	// Bit mask of OSC_XTALOK_EN field.
	XTALOSC24M_MISC0_CLR_OSC_XTALOK_EN_Msk = 0x10000
	// Bit OSC_XTALOK_EN.
	XTALOSC24M_MISC0_CLR_OSC_XTALOK_EN = 0x10000
	// Position of CLKGATE_CTRL field.
	XTALOSC24M_MISC0_CLR_CLKGATE_CTRL_Pos = 0x19
	// Bit mask of CLKGATE_CTRL field.
	XTALOSC24M_MISC0_CLR_CLKGATE_CTRL_Msk = 0x2000000
	// Bit CLKGATE_CTRL.
	XTALOSC24M_MISC0_CLR_CLKGATE_CTRL = 0x2000000
	// Allow the logic to automatically gate the clock when the XTAL is powered down.
	XTALOSC24M_MISC0_CLR_CLKGATE_CTRL_ALLOW_AUTO_GATE = 0x0
	// Prevent the logic from ever gating off the clock.
	XTALOSC24M_MISC0_CLR_CLKGATE_CTRL_NO_AUTO_GATE = 0x1
	// Position of CLKGATE_DELAY field.
	XTALOSC24M_MISC0_CLR_CLKGATE_DELAY_Pos = 0x1a
	// Bit mask of CLKGATE_DELAY field.
	XTALOSC24M_MISC0_CLR_CLKGATE_DELAY_Msk = 0x1c000000
	// 0.5ms
	XTALOSC24M_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_0 = 0x0
	// 1.0ms
	XTALOSC24M_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_1 = 0x1
	// 2.0ms
	XTALOSC24M_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_2 = 0x2
	// 3.0ms
	XTALOSC24M_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_3 = 0x3
	// 4.0ms
	XTALOSC24M_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_4 = 0x4
	// 5.0ms
	XTALOSC24M_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_5 = 0x5
	// 6.0ms
	XTALOSC24M_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_6 = 0x6
	// 7.0ms
	XTALOSC24M_MISC0_CLR_CLKGATE_DELAY_CLKGATE_DELAY_7 = 0x7
	// Position of RTC_XTAL_SOURCE field.
	XTALOSC24M_MISC0_CLR_RTC_XTAL_SOURCE_Pos = 0x1d
	// Bit mask of RTC_XTAL_SOURCE field.
	XTALOSC24M_MISC0_CLR_RTC_XTAL_SOURCE_Msk = 0x20000000
	// Bit RTC_XTAL_SOURCE.
	XTALOSC24M_MISC0_CLR_RTC_XTAL_SOURCE = 0x20000000
	// Internal ring oscillator
	XTALOSC24M_MISC0_CLR_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_0 = 0x0
	// RTC_XTAL
	XTALOSC24M_MISC0_CLR_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_1 = 0x1
	// Position of XTAL_24M_PWD field.
	XTALOSC24M_MISC0_CLR_XTAL_24M_PWD_Pos = 0x1e
	// Bit mask of XTAL_24M_PWD field.
	XTALOSC24M_MISC0_CLR_XTAL_24M_PWD_Msk = 0x40000000
	// Bit XTAL_24M_PWD.
	XTALOSC24M_MISC0_CLR_XTAL_24M_PWD = 0x40000000
	// Position of VID_PLL_PREDIV field.
	XTALOSC24M_MISC0_CLR_VID_PLL_PREDIV_Pos = 0x1f
	// Bit mask of VID_PLL_PREDIV field.
	XTALOSC24M_MISC0_CLR_VID_PLL_PREDIV_Msk = 0x80000000
	// Bit VID_PLL_PREDIV.
	XTALOSC24M_MISC0_CLR_VID_PLL_PREDIV = 0x80000000
	// Divide by 1
	XTALOSC24M_MISC0_CLR_VID_PLL_PREDIV_VID_PLL_PREDIV_0 = 0x0
	// Divide by 2
	XTALOSC24M_MISC0_CLR_VID_PLL_PREDIV_VID_PLL_PREDIV_1 = 0x1

	// MISC0_TOG: Miscellaneous Register 0
	// Position of REFTOP_PWD field.
	XTALOSC24M_MISC0_TOG_REFTOP_PWD_Pos = 0x0
	// Bit mask of REFTOP_PWD field.
	XTALOSC24M_MISC0_TOG_REFTOP_PWD_Msk = 0x1
	// Bit REFTOP_PWD.
	XTALOSC24M_MISC0_TOG_REFTOP_PWD = 0x1
	// Position of REFTOP_SELFBIASOFF field.
	XTALOSC24M_MISC0_TOG_REFTOP_SELFBIASOFF_Pos = 0x3
	// Bit mask of REFTOP_SELFBIASOFF field.
	XTALOSC24M_MISC0_TOG_REFTOP_SELFBIASOFF_Msk = 0x8
	// Bit REFTOP_SELFBIASOFF.
	XTALOSC24M_MISC0_TOG_REFTOP_SELFBIASOFF = 0x8
	// Uses coarse bias currents for startup
	XTALOSC24M_MISC0_TOG_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_0 = 0x0
	// Uses bandgap-based bias currents for best performance.
	XTALOSC24M_MISC0_TOG_REFTOP_SELFBIASOFF_REFTOP_SELFBIASOFF_1 = 0x1
	// Position of REFTOP_VBGADJ field.
	XTALOSC24M_MISC0_TOG_REFTOP_VBGADJ_Pos = 0x4
	// Bit mask of REFTOP_VBGADJ field.
	XTALOSC24M_MISC0_TOG_REFTOP_VBGADJ_Msk = 0x70
	// Nominal VBG
	XTALOSC24M_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_0 = 0x0
	// VBG+0.78%
	XTALOSC24M_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_1 = 0x1
	// VBG+1.56%
	XTALOSC24M_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_2 = 0x2
	// VBG+2.34%
	XTALOSC24M_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_3 = 0x3
	// VBG-0.78%
	XTALOSC24M_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_4 = 0x4
	// VBG-1.56%
	XTALOSC24M_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_5 = 0x5
	// VBG-2.34%
	XTALOSC24M_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_6 = 0x6
	// VBG-3.12%
	XTALOSC24M_MISC0_TOG_REFTOP_VBGADJ_REFTOP_VBGADJ_7 = 0x7
	// Position of REFTOP_VBGUP field.
	XTALOSC24M_MISC0_TOG_REFTOP_VBGUP_Pos = 0x7
	// Bit mask of REFTOP_VBGUP field.
	XTALOSC24M_MISC0_TOG_REFTOP_VBGUP_Msk = 0x80
	// Bit REFTOP_VBGUP.
	XTALOSC24M_MISC0_TOG_REFTOP_VBGUP = 0x80
	// Position of STOP_MODE_CONFIG field.
	XTALOSC24M_MISC0_TOG_STOP_MODE_CONFIG_Pos = 0xa
	// Bit mask of STOP_MODE_CONFIG field.
	XTALOSC24M_MISC0_TOG_STOP_MODE_CONFIG_Msk = 0xc00
	// All analog except rtc powered down on stop mode assertion. XtalOsc=on, RCOsc=off;
	XTALOSC24M_MISC0_TOG_STOP_MODE_CONFIG_STOP_MODE_CONFIG_0 = 0x0
	// Certain analog functions such as certain regulators left up. XtalOsc=on, RCOsc=off;
	XTALOSC24M_MISC0_TOG_STOP_MODE_CONFIG_STOP_MODE_CONFIG_1 = 0x1
	// XtalOsc=off, RCOsc=on, Old BG=on, New BG=off.
	XTALOSC24M_MISC0_TOG_STOP_MODE_CONFIG_STOP_MODE_CONFIG_2 = 0x2
	// XtalOsc=off, RCOsc=on, Old BG=off, New BG=on.
	XTALOSC24M_MISC0_TOG_STOP_MODE_CONFIG_STOP_MODE_CONFIG_3 = 0x3
	// Position of DISCON_HIGH_SNVS field.
	XTALOSC24M_MISC0_TOG_DISCON_HIGH_SNVS_Pos = 0xc
	// Bit mask of DISCON_HIGH_SNVS field.
	XTALOSC24M_MISC0_TOG_DISCON_HIGH_SNVS_Msk = 0x1000
	// Bit DISCON_HIGH_SNVS.
	XTALOSC24M_MISC0_TOG_DISCON_HIGH_SNVS = 0x1000
	// Turn on the switch
	XTALOSC24M_MISC0_TOG_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_0 = 0x0
	// Turn off the switch
	XTALOSC24M_MISC0_TOG_DISCON_HIGH_SNVS_DISCON_HIGH_SNVS_1 = 0x1
	// Position of OSC_I field.
	XTALOSC24M_MISC0_TOG_OSC_I_Pos = 0xd
	// Bit mask of OSC_I field.
	XTALOSC24M_MISC0_TOG_OSC_I_Msk = 0x6000
	// Nominal
	XTALOSC24M_MISC0_TOG_OSC_I_NOMINAL = 0x0
	// Decrease current by 12.5%
	XTALOSC24M_MISC0_TOG_OSC_I_MINUS_12_5_PERCENT = 0x1
	// Decrease current by 25.0%
	XTALOSC24M_MISC0_TOG_OSC_I_MINUS_25_PERCENT = 0x2
	// Decrease current by 37.5%
	XTALOSC24M_MISC0_TOG_OSC_I_MINUS_37_5_PERCENT = 0x3
	// Position of OSC_XTALOK field.
	XTALOSC24M_MISC0_TOG_OSC_XTALOK_Pos = 0xf
	// Bit mask of OSC_XTALOK field.
	XTALOSC24M_MISC0_TOG_OSC_XTALOK_Msk = 0x8000
	// Bit OSC_XTALOK.
	XTALOSC24M_MISC0_TOG_OSC_XTALOK = 0x8000
	// Position of OSC_XTALOK_EN field.
	XTALOSC24M_MISC0_TOG_OSC_XTALOK_EN_Pos = 0x10
	// Bit mask of OSC_XTALOK_EN field.
	XTALOSC24M_MISC0_TOG_OSC_XTALOK_EN_Msk = 0x10000
	// Bit OSC_XTALOK_EN.
	XTALOSC24M_MISC0_TOG_OSC_XTALOK_EN = 0x10000
	// Position of CLKGATE_CTRL field.
	XTALOSC24M_MISC0_TOG_CLKGATE_CTRL_Pos = 0x19
	// Bit mask of CLKGATE_CTRL field.
	XTALOSC24M_MISC0_TOG_CLKGATE_CTRL_Msk = 0x2000000
	// Bit CLKGATE_CTRL.
	XTALOSC24M_MISC0_TOG_CLKGATE_CTRL = 0x2000000
	// Allow the logic to automatically gate the clock when the XTAL is powered down.
	XTALOSC24M_MISC0_TOG_CLKGATE_CTRL_ALLOW_AUTO_GATE = 0x0
	// Prevent the logic from ever gating off the clock.
	XTALOSC24M_MISC0_TOG_CLKGATE_CTRL_NO_AUTO_GATE = 0x1
	// Position of CLKGATE_DELAY field.
	XTALOSC24M_MISC0_TOG_CLKGATE_DELAY_Pos = 0x1a
	// Bit mask of CLKGATE_DELAY field.
	XTALOSC24M_MISC0_TOG_CLKGATE_DELAY_Msk = 0x1c000000
	// 0.5ms
	XTALOSC24M_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_0 = 0x0
	// 1.0ms
	XTALOSC24M_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_1 = 0x1
	// 2.0ms
	XTALOSC24M_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_2 = 0x2
	// 3.0ms
	XTALOSC24M_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_3 = 0x3
	// 4.0ms
	XTALOSC24M_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_4 = 0x4
	// 5.0ms
	XTALOSC24M_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_5 = 0x5
	// 6.0ms
	XTALOSC24M_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_6 = 0x6
	// 7.0ms
	XTALOSC24M_MISC0_TOG_CLKGATE_DELAY_CLKGATE_DELAY_7 = 0x7
	// Position of RTC_XTAL_SOURCE field.
	XTALOSC24M_MISC0_TOG_RTC_XTAL_SOURCE_Pos = 0x1d
	// Bit mask of RTC_XTAL_SOURCE field.
	XTALOSC24M_MISC0_TOG_RTC_XTAL_SOURCE_Msk = 0x20000000
	// Bit RTC_XTAL_SOURCE.
	XTALOSC24M_MISC0_TOG_RTC_XTAL_SOURCE = 0x20000000
	// Internal ring oscillator
	XTALOSC24M_MISC0_TOG_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_0 = 0x0
	// RTC_XTAL
	XTALOSC24M_MISC0_TOG_RTC_XTAL_SOURCE_RTC_XTAL_SOURCE_1 = 0x1
	// Position of XTAL_24M_PWD field.
	XTALOSC24M_MISC0_TOG_XTAL_24M_PWD_Pos = 0x1e
	// Bit mask of XTAL_24M_PWD field.
	XTALOSC24M_MISC0_TOG_XTAL_24M_PWD_Msk = 0x40000000
	// Bit XTAL_24M_PWD.
	XTALOSC24M_MISC0_TOG_XTAL_24M_PWD = 0x40000000
	// Position of VID_PLL_PREDIV field.
	XTALOSC24M_MISC0_TOG_VID_PLL_PREDIV_Pos = 0x1f
	// Bit mask of VID_PLL_PREDIV field.
	XTALOSC24M_MISC0_TOG_VID_PLL_PREDIV_Msk = 0x80000000
	// Bit VID_PLL_PREDIV.
	XTALOSC24M_MISC0_TOG_VID_PLL_PREDIV = 0x80000000
	// Divide by 1
	XTALOSC24M_MISC0_TOG_VID_PLL_PREDIV_VID_PLL_PREDIV_0 = 0x0
	// Divide by 2
	XTALOSC24M_MISC0_TOG_VID_PLL_PREDIV_VID_PLL_PREDIV_1 = 0x1

	// LOWPWR_CTRL: XTAL OSC (LP) Control Register
	// Position of RC_OSC_EN field.
	XTALOSC24M_LOWPWR_CTRL_RC_OSC_EN_Pos = 0x0
	// Bit mask of RC_OSC_EN field.
	XTALOSC24M_LOWPWR_CTRL_RC_OSC_EN_Msk = 0x1
	// Bit RC_OSC_EN.
	XTALOSC24M_LOWPWR_CTRL_RC_OSC_EN = 0x1
	// Use XTAL OSC to source the 24MHz clock
	XTALOSC24M_LOWPWR_CTRL_RC_OSC_EN_RC_OSC_EN_0 = 0x0
	// Use RC OSC
	XTALOSC24M_LOWPWR_CTRL_RC_OSC_EN_RC_OSC_EN_1 = 0x1
	// Position of OSC_SEL field.
	XTALOSC24M_LOWPWR_CTRL_OSC_SEL_Pos = 0x4
	// Bit mask of OSC_SEL field.
	XTALOSC24M_LOWPWR_CTRL_OSC_SEL_Msk = 0x10
	// Bit OSC_SEL.
	XTALOSC24M_LOWPWR_CTRL_OSC_SEL = 0x10
	// XTAL OSC
	XTALOSC24M_LOWPWR_CTRL_OSC_SEL_OSC_SEL_0 = 0x0
	// RC OSC
	XTALOSC24M_LOWPWR_CTRL_OSC_SEL_OSC_SEL_1 = 0x1
	// Position of LPBG_SEL field.
	XTALOSC24M_LOWPWR_CTRL_LPBG_SEL_Pos = 0x5
	// Bit mask of LPBG_SEL field.
	XTALOSC24M_LOWPWR_CTRL_LPBG_SEL_Msk = 0x20
	// Bit LPBG_SEL.
	XTALOSC24M_LOWPWR_CTRL_LPBG_SEL = 0x20
	// Normal power bandgap
	XTALOSC24M_LOWPWR_CTRL_LPBG_SEL_LPBG_SEL_0 = 0x0
	// Low power bandgap
	XTALOSC24M_LOWPWR_CTRL_LPBG_SEL_LPBG_SEL_1 = 0x1
	// Position of LPBG_TEST field.
	XTALOSC24M_LOWPWR_CTRL_LPBG_TEST_Pos = 0x6
	// Bit mask of LPBG_TEST field.
	XTALOSC24M_LOWPWR_CTRL_LPBG_TEST_Msk = 0x40
	// Bit LPBG_TEST.
	XTALOSC24M_LOWPWR_CTRL_LPBG_TEST = 0x40
	// Position of REFTOP_IBIAS_OFF field.
	XTALOSC24M_LOWPWR_CTRL_REFTOP_IBIAS_OFF_Pos = 0x7
	// Bit mask of REFTOP_IBIAS_OFF field.
	XTALOSC24M_LOWPWR_CTRL_REFTOP_IBIAS_OFF_Msk = 0x80
	// Bit REFTOP_IBIAS_OFF.
	XTALOSC24M_LOWPWR_CTRL_REFTOP_IBIAS_OFF = 0x80
	// Position of L1_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_L1_PWRGATE_Pos = 0x8
	// Bit mask of L1_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_L1_PWRGATE_Msk = 0x100
	// Bit L1_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_L1_PWRGATE = 0x100
	// Position of L2_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_L2_PWRGATE_Pos = 0x9
	// Bit mask of L2_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_L2_PWRGATE_Msk = 0x200
	// Bit L2_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_L2_PWRGATE = 0x200
	// Position of CPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_CPU_PWRGATE_Pos = 0xa
	// Bit mask of CPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_CPU_PWRGATE_Msk = 0x400
	// Bit CPU_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_CPU_PWRGATE = 0x400
	// Position of DISPLAY_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_DISPLAY_PWRGATE_Pos = 0xb
	// Bit mask of DISPLAY_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_DISPLAY_PWRGATE_Msk = 0x800
	// Bit DISPLAY_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_DISPLAY_PWRGATE = 0x800
	// Position of RCOSC_CG_OVERRIDE field.
	XTALOSC24M_LOWPWR_CTRL_RCOSC_CG_OVERRIDE_Pos = 0xd
	// Bit mask of RCOSC_CG_OVERRIDE field.
	XTALOSC24M_LOWPWR_CTRL_RCOSC_CG_OVERRIDE_Msk = 0x2000
	// Bit RCOSC_CG_OVERRIDE.
	XTALOSC24M_LOWPWR_CTRL_RCOSC_CG_OVERRIDE = 0x2000
	// Position of XTALOSC_PWRUP_DELAY field.
	XTALOSC24M_LOWPWR_CTRL_XTALOSC_PWRUP_DELAY_Pos = 0xe
	// Bit mask of XTALOSC_PWRUP_DELAY field.
	XTALOSC24M_LOWPWR_CTRL_XTALOSC_PWRUP_DELAY_Msk = 0xc000
	// 0.25ms
	XTALOSC24M_LOWPWR_CTRL_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_0 = 0x0
	// 0.5ms
	XTALOSC24M_LOWPWR_CTRL_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_1 = 0x1
	// 1ms
	XTALOSC24M_LOWPWR_CTRL_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_2 = 0x2
	// 2ms
	XTALOSC24M_LOWPWR_CTRL_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_3 = 0x3
	// Position of XTALOSC_PWRUP_STAT field.
	XTALOSC24M_LOWPWR_CTRL_XTALOSC_PWRUP_STAT_Pos = 0x10
	// Bit mask of XTALOSC_PWRUP_STAT field.
	XTALOSC24M_LOWPWR_CTRL_XTALOSC_PWRUP_STAT_Msk = 0x10000
	// Bit XTALOSC_PWRUP_STAT.
	XTALOSC24M_LOWPWR_CTRL_XTALOSC_PWRUP_STAT = 0x10000
	// Not stable
	XTALOSC24M_LOWPWR_CTRL_XTALOSC_PWRUP_STAT_XTALOSC_PWRUP_STAT_0 = 0x0
	// Stable and ready to use
	XTALOSC24M_LOWPWR_CTRL_XTALOSC_PWRUP_STAT_XTALOSC_PWRUP_STAT_1 = 0x1
	// Position of MIX_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_MIX_PWRGATE_Pos = 0x11
	// Bit mask of MIX_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_MIX_PWRGATE_Msk = 0x20000
	// Bit MIX_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_MIX_PWRGATE = 0x20000
	// Position of GPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_GPU_PWRGATE_Pos = 0x12
	// Bit mask of GPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_GPU_PWRGATE_Msk = 0x40000
	// Bit GPU_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_GPU_PWRGATE = 0x40000

	// LOWPWR_CTRL_SET: XTAL OSC (LP) Control Register
	// Position of RC_OSC_EN field.
	XTALOSC24M_LOWPWR_CTRL_SET_RC_OSC_EN_Pos = 0x0
	// Bit mask of RC_OSC_EN field.
	XTALOSC24M_LOWPWR_CTRL_SET_RC_OSC_EN_Msk = 0x1
	// Bit RC_OSC_EN.
	XTALOSC24M_LOWPWR_CTRL_SET_RC_OSC_EN = 0x1
	// Use XTAL OSC to source the 24MHz clock
	XTALOSC24M_LOWPWR_CTRL_SET_RC_OSC_EN_RC_OSC_EN_0 = 0x0
	// Use RC OSC
	XTALOSC24M_LOWPWR_CTRL_SET_RC_OSC_EN_RC_OSC_EN_1 = 0x1
	// Position of OSC_SEL field.
	XTALOSC24M_LOWPWR_CTRL_SET_OSC_SEL_Pos = 0x4
	// Bit mask of OSC_SEL field.
	XTALOSC24M_LOWPWR_CTRL_SET_OSC_SEL_Msk = 0x10
	// Bit OSC_SEL.
	XTALOSC24M_LOWPWR_CTRL_SET_OSC_SEL = 0x10
	// XTAL OSC
	XTALOSC24M_LOWPWR_CTRL_SET_OSC_SEL_OSC_SEL_0 = 0x0
	// RC OSC
	XTALOSC24M_LOWPWR_CTRL_SET_OSC_SEL_OSC_SEL_1 = 0x1
	// Position of LPBG_SEL field.
	XTALOSC24M_LOWPWR_CTRL_SET_LPBG_SEL_Pos = 0x5
	// Bit mask of LPBG_SEL field.
	XTALOSC24M_LOWPWR_CTRL_SET_LPBG_SEL_Msk = 0x20
	// Bit LPBG_SEL.
	XTALOSC24M_LOWPWR_CTRL_SET_LPBG_SEL = 0x20
	// Normal power bandgap
	XTALOSC24M_LOWPWR_CTRL_SET_LPBG_SEL_LPBG_SEL_0 = 0x0
	// Low power bandgap
	XTALOSC24M_LOWPWR_CTRL_SET_LPBG_SEL_LPBG_SEL_1 = 0x1
	// Position of LPBG_TEST field.
	XTALOSC24M_LOWPWR_CTRL_SET_LPBG_TEST_Pos = 0x6
	// Bit mask of LPBG_TEST field.
	XTALOSC24M_LOWPWR_CTRL_SET_LPBG_TEST_Msk = 0x40
	// Bit LPBG_TEST.
	XTALOSC24M_LOWPWR_CTRL_SET_LPBG_TEST = 0x40
	// Position of REFTOP_IBIAS_OFF field.
	XTALOSC24M_LOWPWR_CTRL_SET_REFTOP_IBIAS_OFF_Pos = 0x7
	// Bit mask of REFTOP_IBIAS_OFF field.
	XTALOSC24M_LOWPWR_CTRL_SET_REFTOP_IBIAS_OFF_Msk = 0x80
	// Bit REFTOP_IBIAS_OFF.
	XTALOSC24M_LOWPWR_CTRL_SET_REFTOP_IBIAS_OFF = 0x80
	// Position of L1_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_SET_L1_PWRGATE_Pos = 0x8
	// Bit mask of L1_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_SET_L1_PWRGATE_Msk = 0x100
	// Bit L1_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_SET_L1_PWRGATE = 0x100
	// Position of L2_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_SET_L2_PWRGATE_Pos = 0x9
	// Bit mask of L2_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_SET_L2_PWRGATE_Msk = 0x200
	// Bit L2_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_SET_L2_PWRGATE = 0x200
	// Position of CPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_SET_CPU_PWRGATE_Pos = 0xa
	// Bit mask of CPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_SET_CPU_PWRGATE_Msk = 0x400
	// Bit CPU_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_SET_CPU_PWRGATE = 0x400
	// Position of DISPLAY_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_SET_DISPLAY_PWRGATE_Pos = 0xb
	// Bit mask of DISPLAY_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_SET_DISPLAY_PWRGATE_Msk = 0x800
	// Bit DISPLAY_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_SET_DISPLAY_PWRGATE = 0x800
	// Position of RCOSC_CG_OVERRIDE field.
	XTALOSC24M_LOWPWR_CTRL_SET_RCOSC_CG_OVERRIDE_Pos = 0xd
	// Bit mask of RCOSC_CG_OVERRIDE field.
	XTALOSC24M_LOWPWR_CTRL_SET_RCOSC_CG_OVERRIDE_Msk = 0x2000
	// Bit RCOSC_CG_OVERRIDE.
	XTALOSC24M_LOWPWR_CTRL_SET_RCOSC_CG_OVERRIDE = 0x2000
	// Position of XTALOSC_PWRUP_DELAY field.
	XTALOSC24M_LOWPWR_CTRL_SET_XTALOSC_PWRUP_DELAY_Pos = 0xe
	// Bit mask of XTALOSC_PWRUP_DELAY field.
	XTALOSC24M_LOWPWR_CTRL_SET_XTALOSC_PWRUP_DELAY_Msk = 0xc000
	// 0.25ms
	XTALOSC24M_LOWPWR_CTRL_SET_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_0 = 0x0
	// 0.5ms
	XTALOSC24M_LOWPWR_CTRL_SET_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_1 = 0x1
	// 1ms
	XTALOSC24M_LOWPWR_CTRL_SET_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_2 = 0x2
	// 2ms
	XTALOSC24M_LOWPWR_CTRL_SET_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_3 = 0x3
	// Position of XTALOSC_PWRUP_STAT field.
	XTALOSC24M_LOWPWR_CTRL_SET_XTALOSC_PWRUP_STAT_Pos = 0x10
	// Bit mask of XTALOSC_PWRUP_STAT field.
	XTALOSC24M_LOWPWR_CTRL_SET_XTALOSC_PWRUP_STAT_Msk = 0x10000
	// Bit XTALOSC_PWRUP_STAT.
	XTALOSC24M_LOWPWR_CTRL_SET_XTALOSC_PWRUP_STAT = 0x10000
	// Not stable
	XTALOSC24M_LOWPWR_CTRL_SET_XTALOSC_PWRUP_STAT_XTALOSC_PWRUP_STAT_0 = 0x0
	// Stable and ready to use
	XTALOSC24M_LOWPWR_CTRL_SET_XTALOSC_PWRUP_STAT_XTALOSC_PWRUP_STAT_1 = 0x1
	// Position of MIX_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_SET_MIX_PWRGATE_Pos = 0x11
	// Bit mask of MIX_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_SET_MIX_PWRGATE_Msk = 0x20000
	// Bit MIX_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_SET_MIX_PWRGATE = 0x20000
	// Position of GPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_SET_GPU_PWRGATE_Pos = 0x12
	// Bit mask of GPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_SET_GPU_PWRGATE_Msk = 0x40000
	// Bit GPU_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_SET_GPU_PWRGATE = 0x40000

	// LOWPWR_CTRL_CLR: XTAL OSC (LP) Control Register
	// Position of RC_OSC_EN field.
	XTALOSC24M_LOWPWR_CTRL_CLR_RC_OSC_EN_Pos = 0x0
	// Bit mask of RC_OSC_EN field.
	XTALOSC24M_LOWPWR_CTRL_CLR_RC_OSC_EN_Msk = 0x1
	// Bit RC_OSC_EN.
	XTALOSC24M_LOWPWR_CTRL_CLR_RC_OSC_EN = 0x1
	// Use XTAL OSC to source the 24MHz clock
	XTALOSC24M_LOWPWR_CTRL_CLR_RC_OSC_EN_RC_OSC_EN_0 = 0x0
	// Use RC OSC
	XTALOSC24M_LOWPWR_CTRL_CLR_RC_OSC_EN_RC_OSC_EN_1 = 0x1
	// Position of OSC_SEL field.
	XTALOSC24M_LOWPWR_CTRL_CLR_OSC_SEL_Pos = 0x4
	// Bit mask of OSC_SEL field.
	XTALOSC24M_LOWPWR_CTRL_CLR_OSC_SEL_Msk = 0x10
	// Bit OSC_SEL.
	XTALOSC24M_LOWPWR_CTRL_CLR_OSC_SEL = 0x10
	// XTAL OSC
	XTALOSC24M_LOWPWR_CTRL_CLR_OSC_SEL_OSC_SEL_0 = 0x0
	// RC OSC
	XTALOSC24M_LOWPWR_CTRL_CLR_OSC_SEL_OSC_SEL_1 = 0x1
	// Position of LPBG_SEL field.
	XTALOSC24M_LOWPWR_CTRL_CLR_LPBG_SEL_Pos = 0x5
	// Bit mask of LPBG_SEL field.
	XTALOSC24M_LOWPWR_CTRL_CLR_LPBG_SEL_Msk = 0x20
	// Bit LPBG_SEL.
	XTALOSC24M_LOWPWR_CTRL_CLR_LPBG_SEL = 0x20
	// Normal power bandgap
	XTALOSC24M_LOWPWR_CTRL_CLR_LPBG_SEL_LPBG_SEL_0 = 0x0
	// Low power bandgap
	XTALOSC24M_LOWPWR_CTRL_CLR_LPBG_SEL_LPBG_SEL_1 = 0x1
	// Position of LPBG_TEST field.
	XTALOSC24M_LOWPWR_CTRL_CLR_LPBG_TEST_Pos = 0x6
	// Bit mask of LPBG_TEST field.
	XTALOSC24M_LOWPWR_CTRL_CLR_LPBG_TEST_Msk = 0x40
	// Bit LPBG_TEST.
	XTALOSC24M_LOWPWR_CTRL_CLR_LPBG_TEST = 0x40
	// Position of REFTOP_IBIAS_OFF field.
	XTALOSC24M_LOWPWR_CTRL_CLR_REFTOP_IBIAS_OFF_Pos = 0x7
	// Bit mask of REFTOP_IBIAS_OFF field.
	XTALOSC24M_LOWPWR_CTRL_CLR_REFTOP_IBIAS_OFF_Msk = 0x80
	// Bit REFTOP_IBIAS_OFF.
	XTALOSC24M_LOWPWR_CTRL_CLR_REFTOP_IBIAS_OFF = 0x80
	// Position of L1_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_CLR_L1_PWRGATE_Pos = 0x8
	// Bit mask of L1_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_CLR_L1_PWRGATE_Msk = 0x100
	// Bit L1_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_CLR_L1_PWRGATE = 0x100
	// Position of L2_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_CLR_L2_PWRGATE_Pos = 0x9
	// Bit mask of L2_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_CLR_L2_PWRGATE_Msk = 0x200
	// Bit L2_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_CLR_L2_PWRGATE = 0x200
	// Position of CPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_CLR_CPU_PWRGATE_Pos = 0xa
	// Bit mask of CPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_CLR_CPU_PWRGATE_Msk = 0x400
	// Bit CPU_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_CLR_CPU_PWRGATE = 0x400
	// Position of DISPLAY_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_CLR_DISPLAY_PWRGATE_Pos = 0xb
	// Bit mask of DISPLAY_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_CLR_DISPLAY_PWRGATE_Msk = 0x800
	// Bit DISPLAY_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_CLR_DISPLAY_PWRGATE = 0x800
	// Position of RCOSC_CG_OVERRIDE field.
	XTALOSC24M_LOWPWR_CTRL_CLR_RCOSC_CG_OVERRIDE_Pos = 0xd
	// Bit mask of RCOSC_CG_OVERRIDE field.
	XTALOSC24M_LOWPWR_CTRL_CLR_RCOSC_CG_OVERRIDE_Msk = 0x2000
	// Bit RCOSC_CG_OVERRIDE.
	XTALOSC24M_LOWPWR_CTRL_CLR_RCOSC_CG_OVERRIDE = 0x2000
	// Position of XTALOSC_PWRUP_DELAY field.
	XTALOSC24M_LOWPWR_CTRL_CLR_XTALOSC_PWRUP_DELAY_Pos = 0xe
	// Bit mask of XTALOSC_PWRUP_DELAY field.
	XTALOSC24M_LOWPWR_CTRL_CLR_XTALOSC_PWRUP_DELAY_Msk = 0xc000
	// 0.25ms
	XTALOSC24M_LOWPWR_CTRL_CLR_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_0 = 0x0
	// 0.5ms
	XTALOSC24M_LOWPWR_CTRL_CLR_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_1 = 0x1
	// 1ms
	XTALOSC24M_LOWPWR_CTRL_CLR_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_2 = 0x2
	// 2ms
	XTALOSC24M_LOWPWR_CTRL_CLR_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_3 = 0x3
	// Position of XTALOSC_PWRUP_STAT field.
	XTALOSC24M_LOWPWR_CTRL_CLR_XTALOSC_PWRUP_STAT_Pos = 0x10
	// Bit mask of XTALOSC_PWRUP_STAT field.
	XTALOSC24M_LOWPWR_CTRL_CLR_XTALOSC_PWRUP_STAT_Msk = 0x10000
	// Bit XTALOSC_PWRUP_STAT.
	XTALOSC24M_LOWPWR_CTRL_CLR_XTALOSC_PWRUP_STAT = 0x10000
	// Not stable
	XTALOSC24M_LOWPWR_CTRL_CLR_XTALOSC_PWRUP_STAT_XTALOSC_PWRUP_STAT_0 = 0x0
	// Stable and ready to use
	XTALOSC24M_LOWPWR_CTRL_CLR_XTALOSC_PWRUP_STAT_XTALOSC_PWRUP_STAT_1 = 0x1
	// Position of MIX_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_CLR_MIX_PWRGATE_Pos = 0x11
	// Bit mask of MIX_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_CLR_MIX_PWRGATE_Msk = 0x20000
	// Bit MIX_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_CLR_MIX_PWRGATE = 0x20000
	// Position of GPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_CLR_GPU_PWRGATE_Pos = 0x12
	// Bit mask of GPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_CLR_GPU_PWRGATE_Msk = 0x40000
	// Bit GPU_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_CLR_GPU_PWRGATE = 0x40000

	// LOWPWR_CTRL_TOG: XTAL OSC (LP) Control Register
	// Position of RC_OSC_EN field.
	XTALOSC24M_LOWPWR_CTRL_TOG_RC_OSC_EN_Pos = 0x0
	// Bit mask of RC_OSC_EN field.
	XTALOSC24M_LOWPWR_CTRL_TOG_RC_OSC_EN_Msk = 0x1
	// Bit RC_OSC_EN.
	XTALOSC24M_LOWPWR_CTRL_TOG_RC_OSC_EN = 0x1
	// Use XTAL OSC to source the 24MHz clock
	XTALOSC24M_LOWPWR_CTRL_TOG_RC_OSC_EN_RC_OSC_EN_0 = 0x0
	// Use RC OSC
	XTALOSC24M_LOWPWR_CTRL_TOG_RC_OSC_EN_RC_OSC_EN_1 = 0x1
	// Position of OSC_SEL field.
	XTALOSC24M_LOWPWR_CTRL_TOG_OSC_SEL_Pos = 0x4
	// Bit mask of OSC_SEL field.
	XTALOSC24M_LOWPWR_CTRL_TOG_OSC_SEL_Msk = 0x10
	// Bit OSC_SEL.
	XTALOSC24M_LOWPWR_CTRL_TOG_OSC_SEL = 0x10
	// XTAL OSC
	XTALOSC24M_LOWPWR_CTRL_TOG_OSC_SEL_OSC_SEL_0 = 0x0
	// RC OSC
	XTALOSC24M_LOWPWR_CTRL_TOG_OSC_SEL_OSC_SEL_1 = 0x1
	// Position of LPBG_SEL field.
	XTALOSC24M_LOWPWR_CTRL_TOG_LPBG_SEL_Pos = 0x5
	// Bit mask of LPBG_SEL field.
	XTALOSC24M_LOWPWR_CTRL_TOG_LPBG_SEL_Msk = 0x20
	// Bit LPBG_SEL.
	XTALOSC24M_LOWPWR_CTRL_TOG_LPBG_SEL = 0x20
	// Normal power bandgap
	XTALOSC24M_LOWPWR_CTRL_TOG_LPBG_SEL_LPBG_SEL_0 = 0x0
	// Low power bandgap
	XTALOSC24M_LOWPWR_CTRL_TOG_LPBG_SEL_LPBG_SEL_1 = 0x1
	// Position of LPBG_TEST field.
	XTALOSC24M_LOWPWR_CTRL_TOG_LPBG_TEST_Pos = 0x6
	// Bit mask of LPBG_TEST field.
	XTALOSC24M_LOWPWR_CTRL_TOG_LPBG_TEST_Msk = 0x40
	// Bit LPBG_TEST.
	XTALOSC24M_LOWPWR_CTRL_TOG_LPBG_TEST = 0x40
	// Position of REFTOP_IBIAS_OFF field.
	XTALOSC24M_LOWPWR_CTRL_TOG_REFTOP_IBIAS_OFF_Pos = 0x7
	// Bit mask of REFTOP_IBIAS_OFF field.
	XTALOSC24M_LOWPWR_CTRL_TOG_REFTOP_IBIAS_OFF_Msk = 0x80
	// Bit REFTOP_IBIAS_OFF.
	XTALOSC24M_LOWPWR_CTRL_TOG_REFTOP_IBIAS_OFF = 0x80
	// Position of L1_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_TOG_L1_PWRGATE_Pos = 0x8
	// Bit mask of L1_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_TOG_L1_PWRGATE_Msk = 0x100
	// Bit L1_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_TOG_L1_PWRGATE = 0x100
	// Position of L2_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_TOG_L2_PWRGATE_Pos = 0x9
	// Bit mask of L2_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_TOG_L2_PWRGATE_Msk = 0x200
	// Bit L2_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_TOG_L2_PWRGATE = 0x200
	// Position of CPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_TOG_CPU_PWRGATE_Pos = 0xa
	// Bit mask of CPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_TOG_CPU_PWRGATE_Msk = 0x400
	// Bit CPU_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_TOG_CPU_PWRGATE = 0x400
	// Position of DISPLAY_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_TOG_DISPLAY_PWRGATE_Pos = 0xb
	// Bit mask of DISPLAY_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_TOG_DISPLAY_PWRGATE_Msk = 0x800
	// Bit DISPLAY_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_TOG_DISPLAY_PWRGATE = 0x800
	// Position of RCOSC_CG_OVERRIDE field.
	XTALOSC24M_LOWPWR_CTRL_TOG_RCOSC_CG_OVERRIDE_Pos = 0xd
	// Bit mask of RCOSC_CG_OVERRIDE field.
	XTALOSC24M_LOWPWR_CTRL_TOG_RCOSC_CG_OVERRIDE_Msk = 0x2000
	// Bit RCOSC_CG_OVERRIDE.
	XTALOSC24M_LOWPWR_CTRL_TOG_RCOSC_CG_OVERRIDE = 0x2000
	// Position of XTALOSC_PWRUP_DELAY field.
	XTALOSC24M_LOWPWR_CTRL_TOG_XTALOSC_PWRUP_DELAY_Pos = 0xe
	// Bit mask of XTALOSC_PWRUP_DELAY field.
	XTALOSC24M_LOWPWR_CTRL_TOG_XTALOSC_PWRUP_DELAY_Msk = 0xc000
	// 0.25ms
	XTALOSC24M_LOWPWR_CTRL_TOG_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_0 = 0x0
	// 0.5ms
	XTALOSC24M_LOWPWR_CTRL_TOG_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_1 = 0x1
	// 1ms
	XTALOSC24M_LOWPWR_CTRL_TOG_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_2 = 0x2
	// 2ms
	XTALOSC24M_LOWPWR_CTRL_TOG_XTALOSC_PWRUP_DELAY_XTALOSC_PWRUP_DELAY_3 = 0x3
	// Position of XTALOSC_PWRUP_STAT field.
	XTALOSC24M_LOWPWR_CTRL_TOG_XTALOSC_PWRUP_STAT_Pos = 0x10
	// Bit mask of XTALOSC_PWRUP_STAT field.
	XTALOSC24M_LOWPWR_CTRL_TOG_XTALOSC_PWRUP_STAT_Msk = 0x10000
	// Bit XTALOSC_PWRUP_STAT.
	XTALOSC24M_LOWPWR_CTRL_TOG_XTALOSC_PWRUP_STAT = 0x10000
	// Not stable
	XTALOSC24M_LOWPWR_CTRL_TOG_XTALOSC_PWRUP_STAT_XTALOSC_PWRUP_STAT_0 = 0x0
	// Stable and ready to use
	XTALOSC24M_LOWPWR_CTRL_TOG_XTALOSC_PWRUP_STAT_XTALOSC_PWRUP_STAT_1 = 0x1
	// Position of MIX_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_TOG_MIX_PWRGATE_Pos = 0x11
	// Bit mask of MIX_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_TOG_MIX_PWRGATE_Msk = 0x20000
	// Bit MIX_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_TOG_MIX_PWRGATE = 0x20000
	// Position of GPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_TOG_GPU_PWRGATE_Pos = 0x12
	// Bit mask of GPU_PWRGATE field.
	XTALOSC24M_LOWPWR_CTRL_TOG_GPU_PWRGATE_Msk = 0x40000
	// Bit GPU_PWRGATE.
	XTALOSC24M_LOWPWR_CTRL_TOG_GPU_PWRGATE = 0x40000

	// OSC_CONFIG0: XTAL OSC Configuration 0 Register
	// Position of START field.
	XTALOSC24M_OSC_CONFIG0_START_Pos = 0x0
	// Bit mask of START field.
	XTALOSC24M_OSC_CONFIG0_START_Msk = 0x1
	// Bit START.
	XTALOSC24M_OSC_CONFIG0_START = 0x1
	// Position of ENABLE field.
	XTALOSC24M_OSC_CONFIG0_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	XTALOSC24M_OSC_CONFIG0_ENABLE_Msk = 0x2
	// Bit ENABLE.
	XTALOSC24M_OSC_CONFIG0_ENABLE = 0x2
	// Position of BYPASS field.
	XTALOSC24M_OSC_CONFIG0_BYPASS_Pos = 0x2
	// Bit mask of BYPASS field.
	XTALOSC24M_OSC_CONFIG0_BYPASS_Msk = 0x4
	// Bit BYPASS.
	XTALOSC24M_OSC_CONFIG0_BYPASS = 0x4
	// Position of INVERT field.
	XTALOSC24M_OSC_CONFIG0_INVERT_Pos = 0x3
	// Bit mask of INVERT field.
	XTALOSC24M_OSC_CONFIG0_INVERT_Msk = 0x8
	// Bit INVERT.
	XTALOSC24M_OSC_CONFIG0_INVERT = 0x8
	// Position of RC_OSC_PROG field.
	XTALOSC24M_OSC_CONFIG0_RC_OSC_PROG_Pos = 0x4
	// Bit mask of RC_OSC_PROG field.
	XTALOSC24M_OSC_CONFIG0_RC_OSC_PROG_Msk = 0xff0
	// Position of HYST_PLUS field.
	XTALOSC24M_OSC_CONFIG0_HYST_PLUS_Pos = 0xc
	// Bit mask of HYST_PLUS field.
	XTALOSC24M_OSC_CONFIG0_HYST_PLUS_Msk = 0xf000
	// Position of HYST_MINUS field.
	XTALOSC24M_OSC_CONFIG0_HYST_MINUS_Pos = 0x10
	// Bit mask of HYST_MINUS field.
	XTALOSC24M_OSC_CONFIG0_HYST_MINUS_Msk = 0xf0000
	// Position of RC_OSC_PROG_CUR field.
	XTALOSC24M_OSC_CONFIG0_RC_OSC_PROG_CUR_Pos = 0x18
	// Bit mask of RC_OSC_PROG_CUR field.
	XTALOSC24M_OSC_CONFIG0_RC_OSC_PROG_CUR_Msk = 0xff000000

	// OSC_CONFIG0_SET: XTAL OSC Configuration 0 Register
	// Position of START field.
	XTALOSC24M_OSC_CONFIG0_SET_START_Pos = 0x0
	// Bit mask of START field.
	XTALOSC24M_OSC_CONFIG0_SET_START_Msk = 0x1
	// Bit START.
	XTALOSC24M_OSC_CONFIG0_SET_START = 0x1
	// Position of ENABLE field.
	XTALOSC24M_OSC_CONFIG0_SET_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	XTALOSC24M_OSC_CONFIG0_SET_ENABLE_Msk = 0x2
	// Bit ENABLE.
	XTALOSC24M_OSC_CONFIG0_SET_ENABLE = 0x2
	// Position of BYPASS field.
	XTALOSC24M_OSC_CONFIG0_SET_BYPASS_Pos = 0x2
	// Bit mask of BYPASS field.
	XTALOSC24M_OSC_CONFIG0_SET_BYPASS_Msk = 0x4
	// Bit BYPASS.
	XTALOSC24M_OSC_CONFIG0_SET_BYPASS = 0x4
	// Position of INVERT field.
	XTALOSC24M_OSC_CONFIG0_SET_INVERT_Pos = 0x3
	// Bit mask of INVERT field.
	XTALOSC24M_OSC_CONFIG0_SET_INVERT_Msk = 0x8
	// Bit INVERT.
	XTALOSC24M_OSC_CONFIG0_SET_INVERT = 0x8
	// Position of RC_OSC_PROG field.
	XTALOSC24M_OSC_CONFIG0_SET_RC_OSC_PROG_Pos = 0x4
	// Bit mask of RC_OSC_PROG field.
	XTALOSC24M_OSC_CONFIG0_SET_RC_OSC_PROG_Msk = 0xff0
	// Position of HYST_PLUS field.
	XTALOSC24M_OSC_CONFIG0_SET_HYST_PLUS_Pos = 0xc
	// Bit mask of HYST_PLUS field.
	XTALOSC24M_OSC_CONFIG0_SET_HYST_PLUS_Msk = 0xf000
	// Position of HYST_MINUS field.
	XTALOSC24M_OSC_CONFIG0_SET_HYST_MINUS_Pos = 0x10
	// Bit mask of HYST_MINUS field.
	XTALOSC24M_OSC_CONFIG0_SET_HYST_MINUS_Msk = 0xf0000
	// Position of RC_OSC_PROG_CUR field.
	XTALOSC24M_OSC_CONFIG0_SET_RC_OSC_PROG_CUR_Pos = 0x18
	// Bit mask of RC_OSC_PROG_CUR field.
	XTALOSC24M_OSC_CONFIG0_SET_RC_OSC_PROG_CUR_Msk = 0xff000000

	// OSC_CONFIG0_CLR: XTAL OSC Configuration 0 Register
	// Position of START field.
	XTALOSC24M_OSC_CONFIG0_CLR_START_Pos = 0x0
	// Bit mask of START field.
	XTALOSC24M_OSC_CONFIG0_CLR_START_Msk = 0x1
	// Bit START.
	XTALOSC24M_OSC_CONFIG0_CLR_START = 0x1
	// Position of ENABLE field.
	XTALOSC24M_OSC_CONFIG0_CLR_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	XTALOSC24M_OSC_CONFIG0_CLR_ENABLE_Msk = 0x2
	// Bit ENABLE.
	XTALOSC24M_OSC_CONFIG0_CLR_ENABLE = 0x2
	// Position of BYPASS field.
	XTALOSC24M_OSC_CONFIG0_CLR_BYPASS_Pos = 0x2
	// Bit mask of BYPASS field.
	XTALOSC24M_OSC_CONFIG0_CLR_BYPASS_Msk = 0x4
	// Bit BYPASS.
	XTALOSC24M_OSC_CONFIG0_CLR_BYPASS = 0x4
	// Position of INVERT field.
	XTALOSC24M_OSC_CONFIG0_CLR_INVERT_Pos = 0x3
	// Bit mask of INVERT field.
	XTALOSC24M_OSC_CONFIG0_CLR_INVERT_Msk = 0x8
	// Bit INVERT.
	XTALOSC24M_OSC_CONFIG0_CLR_INVERT = 0x8
	// Position of RC_OSC_PROG field.
	XTALOSC24M_OSC_CONFIG0_CLR_RC_OSC_PROG_Pos = 0x4
	// Bit mask of RC_OSC_PROG field.
	XTALOSC24M_OSC_CONFIG0_CLR_RC_OSC_PROG_Msk = 0xff0
	// Position of HYST_PLUS field.
	XTALOSC24M_OSC_CONFIG0_CLR_HYST_PLUS_Pos = 0xc
	// Bit mask of HYST_PLUS field.
	XTALOSC24M_OSC_CONFIG0_CLR_HYST_PLUS_Msk = 0xf000
	// Position of HYST_MINUS field.
	XTALOSC24M_OSC_CONFIG0_CLR_HYST_MINUS_Pos = 0x10
	// Bit mask of HYST_MINUS field.
	XTALOSC24M_OSC_CONFIG0_CLR_HYST_MINUS_Msk = 0xf0000
	// Position of RC_OSC_PROG_CUR field.
	XTALOSC24M_OSC_CONFIG0_CLR_RC_OSC_PROG_CUR_Pos = 0x18
	// Bit mask of RC_OSC_PROG_CUR field.
	XTALOSC24M_OSC_CONFIG0_CLR_RC_OSC_PROG_CUR_Msk = 0xff000000

	// OSC_CONFIG0_TOG: XTAL OSC Configuration 0 Register
	// Position of START field.
	XTALOSC24M_OSC_CONFIG0_TOG_START_Pos = 0x0
	// Bit mask of START field.
	XTALOSC24M_OSC_CONFIG0_TOG_START_Msk = 0x1
	// Bit START.
	XTALOSC24M_OSC_CONFIG0_TOG_START = 0x1
	// Position of ENABLE field.
	XTALOSC24M_OSC_CONFIG0_TOG_ENABLE_Pos = 0x1
	// Bit mask of ENABLE field.
	XTALOSC24M_OSC_CONFIG0_TOG_ENABLE_Msk = 0x2
	// Bit ENABLE.
	XTALOSC24M_OSC_CONFIG0_TOG_ENABLE = 0x2
	// Position of BYPASS field.
	XTALOSC24M_OSC_CONFIG0_TOG_BYPASS_Pos = 0x2
	// Bit mask of BYPASS field.
	XTALOSC24M_OSC_CONFIG0_TOG_BYPASS_Msk = 0x4
	// Bit BYPASS.
	XTALOSC24M_OSC_CONFIG0_TOG_BYPASS = 0x4
	// Position of INVERT field.
	XTALOSC24M_OSC_CONFIG0_TOG_INVERT_Pos = 0x3
	// Bit mask of INVERT field.
	XTALOSC24M_OSC_CONFIG0_TOG_INVERT_Msk = 0x8
	// Bit INVERT.
	XTALOSC24M_OSC_CONFIG0_TOG_INVERT = 0x8
	// Position of RC_OSC_PROG field.
	XTALOSC24M_OSC_CONFIG0_TOG_RC_OSC_PROG_Pos = 0x4
	// Bit mask of RC_OSC_PROG field.
	XTALOSC24M_OSC_CONFIG0_TOG_RC_OSC_PROG_Msk = 0xff0
	// Position of HYST_PLUS field.
	XTALOSC24M_OSC_CONFIG0_TOG_HYST_PLUS_Pos = 0xc
	// Bit mask of HYST_PLUS field.
	XTALOSC24M_OSC_CONFIG0_TOG_HYST_PLUS_Msk = 0xf000
	// Position of HYST_MINUS field.
	XTALOSC24M_OSC_CONFIG0_TOG_HYST_MINUS_Pos = 0x10
	// Bit mask of HYST_MINUS field.
	XTALOSC24M_OSC_CONFIG0_TOG_HYST_MINUS_Msk = 0xf0000
	// Position of RC_OSC_PROG_CUR field.
	XTALOSC24M_OSC_CONFIG0_TOG_RC_OSC_PROG_CUR_Pos = 0x18
	// Bit mask of RC_OSC_PROG_CUR field.
	XTALOSC24M_OSC_CONFIG0_TOG_RC_OSC_PROG_CUR_Msk = 0xff000000

	// OSC_CONFIG1: XTAL OSC Configuration 1 Register
	// Position of COUNT_RC_TRG field.
	XTALOSC24M_OSC_CONFIG1_COUNT_RC_TRG_Pos = 0x0
	// Bit mask of COUNT_RC_TRG field.
	XTALOSC24M_OSC_CONFIG1_COUNT_RC_TRG_Msk = 0xfff
	// Position of COUNT_RC_CUR field.
	XTALOSC24M_OSC_CONFIG1_COUNT_RC_CUR_Pos = 0x14
	// Bit mask of COUNT_RC_CUR field.
	XTALOSC24M_OSC_CONFIG1_COUNT_RC_CUR_Msk = 0xfff00000

	// OSC_CONFIG1_SET: XTAL OSC Configuration 1 Register
	// Position of COUNT_RC_TRG field.
	XTALOSC24M_OSC_CONFIG1_SET_COUNT_RC_TRG_Pos = 0x0
	// Bit mask of COUNT_RC_TRG field.
	XTALOSC24M_OSC_CONFIG1_SET_COUNT_RC_TRG_Msk = 0xfff
	// Position of COUNT_RC_CUR field.
	XTALOSC24M_OSC_CONFIG1_SET_COUNT_RC_CUR_Pos = 0x14
	// Bit mask of COUNT_RC_CUR field.
	XTALOSC24M_OSC_CONFIG1_SET_COUNT_RC_CUR_Msk = 0xfff00000

	// OSC_CONFIG1_CLR: XTAL OSC Configuration 1 Register
	// Position of COUNT_RC_TRG field.
	XTALOSC24M_OSC_CONFIG1_CLR_COUNT_RC_TRG_Pos = 0x0
	// Bit mask of COUNT_RC_TRG field.
	XTALOSC24M_OSC_CONFIG1_CLR_COUNT_RC_TRG_Msk = 0xfff
	// Position of COUNT_RC_CUR field.
	XTALOSC24M_OSC_CONFIG1_CLR_COUNT_RC_CUR_Pos = 0x14
	// Bit mask of COUNT_RC_CUR field.
	XTALOSC24M_OSC_CONFIG1_CLR_COUNT_RC_CUR_Msk = 0xfff00000

	// OSC_CONFIG1_TOG: XTAL OSC Configuration 1 Register
	// Position of COUNT_RC_TRG field.
	XTALOSC24M_OSC_CONFIG1_TOG_COUNT_RC_TRG_Pos = 0x0
	// Bit mask of COUNT_RC_TRG field.
	XTALOSC24M_OSC_CONFIG1_TOG_COUNT_RC_TRG_Msk = 0xfff
	// Position of COUNT_RC_CUR field.
	XTALOSC24M_OSC_CONFIG1_TOG_COUNT_RC_CUR_Pos = 0x14
	// Bit mask of COUNT_RC_CUR field.
	XTALOSC24M_OSC_CONFIG1_TOG_COUNT_RC_CUR_Msk = 0xfff00000

	// OSC_CONFIG2: XTAL OSC Configuration 2 Register
	// Position of COUNT_1M_TRG field.
	XTALOSC24M_OSC_CONFIG2_COUNT_1M_TRG_Pos = 0x0
	// Bit mask of COUNT_1M_TRG field.
	XTALOSC24M_OSC_CONFIG2_COUNT_1M_TRG_Msk = 0xfff
	// Position of ENABLE_1M field.
	XTALOSC24M_OSC_CONFIG2_ENABLE_1M_Pos = 0x10
	// Bit mask of ENABLE_1M field.
	XTALOSC24M_OSC_CONFIG2_ENABLE_1M_Msk = 0x10000
	// Bit ENABLE_1M.
	XTALOSC24M_OSC_CONFIG2_ENABLE_1M = 0x10000
	// Position of MUX_1M field.
	XTALOSC24M_OSC_CONFIG2_MUX_1M_Pos = 0x11
	// Bit mask of MUX_1M field.
	XTALOSC24M_OSC_CONFIG2_MUX_1M_Msk = 0x20000
	// Bit MUX_1M.
	XTALOSC24M_OSC_CONFIG2_MUX_1M = 0x20000
	// Position of CLK_1M_ERR_FL field.
	XTALOSC24M_OSC_CONFIG2_CLK_1M_ERR_FL_Pos = 0x1f
	// Bit mask of CLK_1M_ERR_FL field.
	XTALOSC24M_OSC_CONFIG2_CLK_1M_ERR_FL_Msk = 0x80000000
	// Bit CLK_1M_ERR_FL.
	XTALOSC24M_OSC_CONFIG2_CLK_1M_ERR_FL = 0x80000000

	// OSC_CONFIG2_SET: XTAL OSC Configuration 2 Register
	// Position of COUNT_1M_TRG field.
	XTALOSC24M_OSC_CONFIG2_SET_COUNT_1M_TRG_Pos = 0x0
	// Bit mask of COUNT_1M_TRG field.
	XTALOSC24M_OSC_CONFIG2_SET_COUNT_1M_TRG_Msk = 0xfff
	// Position of ENABLE_1M field.
	XTALOSC24M_OSC_CONFIG2_SET_ENABLE_1M_Pos = 0x10
	// Bit mask of ENABLE_1M field.
	XTALOSC24M_OSC_CONFIG2_SET_ENABLE_1M_Msk = 0x10000
	// Bit ENABLE_1M.
	XTALOSC24M_OSC_CONFIG2_SET_ENABLE_1M = 0x10000
	// Position of MUX_1M field.
	XTALOSC24M_OSC_CONFIG2_SET_MUX_1M_Pos = 0x11
	// Bit mask of MUX_1M field.
	XTALOSC24M_OSC_CONFIG2_SET_MUX_1M_Msk = 0x20000
	// Bit MUX_1M.
	XTALOSC24M_OSC_CONFIG2_SET_MUX_1M = 0x20000
	// Position of CLK_1M_ERR_FL field.
	XTALOSC24M_OSC_CONFIG2_SET_CLK_1M_ERR_FL_Pos = 0x1f
	// Bit mask of CLK_1M_ERR_FL field.
	XTALOSC24M_OSC_CONFIG2_SET_CLK_1M_ERR_FL_Msk = 0x80000000
	// Bit CLK_1M_ERR_FL.
	XTALOSC24M_OSC_CONFIG2_SET_CLK_1M_ERR_FL = 0x80000000

	// OSC_CONFIG2_CLR: XTAL OSC Configuration 2 Register
	// Position of COUNT_1M_TRG field.
	XTALOSC24M_OSC_CONFIG2_CLR_COUNT_1M_TRG_Pos = 0x0
	// Bit mask of COUNT_1M_TRG field.
	XTALOSC24M_OSC_CONFIG2_CLR_COUNT_1M_TRG_Msk = 0xfff
	// Position of ENABLE_1M field.
	XTALOSC24M_OSC_CONFIG2_CLR_ENABLE_1M_Pos = 0x10
	// Bit mask of ENABLE_1M field.
	XTALOSC24M_OSC_CONFIG2_CLR_ENABLE_1M_Msk = 0x10000
	// Bit ENABLE_1M.
	XTALOSC24M_OSC_CONFIG2_CLR_ENABLE_1M = 0x10000
	// Position of MUX_1M field.
	XTALOSC24M_OSC_CONFIG2_CLR_MUX_1M_Pos = 0x11
	// Bit mask of MUX_1M field.
	XTALOSC24M_OSC_CONFIG2_CLR_MUX_1M_Msk = 0x20000
	// Bit MUX_1M.
	XTALOSC24M_OSC_CONFIG2_CLR_MUX_1M = 0x20000
	// Position of CLK_1M_ERR_FL field.
	XTALOSC24M_OSC_CONFIG2_CLR_CLK_1M_ERR_FL_Pos = 0x1f
	// Bit mask of CLK_1M_ERR_FL field.
	XTALOSC24M_OSC_CONFIG2_CLR_CLK_1M_ERR_FL_Msk = 0x80000000
	// Bit CLK_1M_ERR_FL.
	XTALOSC24M_OSC_CONFIG2_CLR_CLK_1M_ERR_FL = 0x80000000

	// OSC_CONFIG2_TOG: XTAL OSC Configuration 2 Register
	// Position of COUNT_1M_TRG field.
	XTALOSC24M_OSC_CONFIG2_TOG_COUNT_1M_TRG_Pos = 0x0
	// Bit mask of COUNT_1M_TRG field.
	XTALOSC24M_OSC_CONFIG2_TOG_COUNT_1M_TRG_Msk = 0xfff
	// Position of ENABLE_1M field.
	XTALOSC24M_OSC_CONFIG2_TOG_ENABLE_1M_Pos = 0x10
	// Bit mask of ENABLE_1M field.
	XTALOSC24M_OSC_CONFIG2_TOG_ENABLE_1M_Msk = 0x10000
	// Bit ENABLE_1M.
	XTALOSC24M_OSC_CONFIG2_TOG_ENABLE_1M = 0x10000
	// Position of MUX_1M field.
	XTALOSC24M_OSC_CONFIG2_TOG_MUX_1M_Pos = 0x11
	// Bit mask of MUX_1M field.
	XTALOSC24M_OSC_CONFIG2_TOG_MUX_1M_Msk = 0x20000
	// Bit MUX_1M.
	XTALOSC24M_OSC_CONFIG2_TOG_MUX_1M = 0x20000
	// Position of CLK_1M_ERR_FL field.
	XTALOSC24M_OSC_CONFIG2_TOG_CLK_1M_ERR_FL_Pos = 0x1f
	// Bit mask of CLK_1M_ERR_FL field.
	XTALOSC24M_OSC_CONFIG2_TOG_CLK_1M_ERR_FL_Msk = 0x80000000
	// Bit CLK_1M_ERR_FL.
	XTALOSC24M_OSC_CONFIG2_TOG_CLK_1M_ERR_FL = 0x80000000
)

// Constants for USBPHY: USBPHY Register Reference Index
const (
	// PWD: USB PHY Power-Down Register
	// Position of RSVD0 field.
	USBPHY_PWD_RSVD0_Pos = 0x0
	// Bit mask of RSVD0 field.
	USBPHY_PWD_RSVD0_Msk = 0x3ff
	// Position of TXPWDFS field.
	USBPHY_PWD_TXPWDFS_Pos = 0xa
	// Bit mask of TXPWDFS field.
	USBPHY_PWD_TXPWDFS_Msk = 0x400
	// Bit TXPWDFS.
	USBPHY_PWD_TXPWDFS = 0x400
	// Position of TXPWDIBIAS field.
	USBPHY_PWD_TXPWDIBIAS_Pos = 0xb
	// Bit mask of TXPWDIBIAS field.
	USBPHY_PWD_TXPWDIBIAS_Msk = 0x800
	// Bit TXPWDIBIAS.
	USBPHY_PWD_TXPWDIBIAS = 0x800
	// Position of TXPWDV2I field.
	USBPHY_PWD_TXPWDV2I_Pos = 0xc
	// Bit mask of TXPWDV2I field.
	USBPHY_PWD_TXPWDV2I_Msk = 0x1000
	// Bit TXPWDV2I.
	USBPHY_PWD_TXPWDV2I = 0x1000
	// Position of RSVD1 field.
	USBPHY_PWD_RSVD1_Pos = 0xd
	// Bit mask of RSVD1 field.
	USBPHY_PWD_RSVD1_Msk = 0x1e000
	// Position of RXPWDENV field.
	USBPHY_PWD_RXPWDENV_Pos = 0x11
	// Bit mask of RXPWDENV field.
	USBPHY_PWD_RXPWDENV_Msk = 0x20000
	// Bit RXPWDENV.
	USBPHY_PWD_RXPWDENV = 0x20000
	// Position of RXPWD1PT1 field.
	USBPHY_PWD_RXPWD1PT1_Pos = 0x12
	// Bit mask of RXPWD1PT1 field.
	USBPHY_PWD_RXPWD1PT1_Msk = 0x40000
	// Bit RXPWD1PT1.
	USBPHY_PWD_RXPWD1PT1 = 0x40000
	// Position of RXPWDDIFF field.
	USBPHY_PWD_RXPWDDIFF_Pos = 0x13
	// Bit mask of RXPWDDIFF field.
	USBPHY_PWD_RXPWDDIFF_Msk = 0x80000
	// Bit RXPWDDIFF.
	USBPHY_PWD_RXPWDDIFF = 0x80000
	// Position of RXPWDRX field.
	USBPHY_PWD_RXPWDRX_Pos = 0x14
	// Bit mask of RXPWDRX field.
	USBPHY_PWD_RXPWDRX_Msk = 0x100000
	// Bit RXPWDRX.
	USBPHY_PWD_RXPWDRX = 0x100000
	// Position of RSVD2 field.
	USBPHY_PWD_RSVD2_Pos = 0x15
	// Bit mask of RSVD2 field.
	USBPHY_PWD_RSVD2_Msk = 0xffe00000

	// PWD_SET: USB PHY Power-Down Register
	// Position of RSVD0 field.
	USBPHY_PWD_SET_RSVD0_Pos = 0x0
	// Bit mask of RSVD0 field.
	USBPHY_PWD_SET_RSVD0_Msk = 0x3ff
	// Position of TXPWDFS field.
	USBPHY_PWD_SET_TXPWDFS_Pos = 0xa
	// Bit mask of TXPWDFS field.
	USBPHY_PWD_SET_TXPWDFS_Msk = 0x400
	// Bit TXPWDFS.
	USBPHY_PWD_SET_TXPWDFS = 0x400
	// Position of TXPWDIBIAS field.
	USBPHY_PWD_SET_TXPWDIBIAS_Pos = 0xb
	// Bit mask of TXPWDIBIAS field.
	USBPHY_PWD_SET_TXPWDIBIAS_Msk = 0x800
	// Bit TXPWDIBIAS.
	USBPHY_PWD_SET_TXPWDIBIAS = 0x800
	// Position of TXPWDV2I field.
	USBPHY_PWD_SET_TXPWDV2I_Pos = 0xc
	// Bit mask of TXPWDV2I field.
	USBPHY_PWD_SET_TXPWDV2I_Msk = 0x1000
	// Bit TXPWDV2I.
	USBPHY_PWD_SET_TXPWDV2I = 0x1000
	// Position of RSVD1 field.
	USBPHY_PWD_SET_RSVD1_Pos = 0xd
	// Bit mask of RSVD1 field.
	USBPHY_PWD_SET_RSVD1_Msk = 0x1e000
	// Position of RXPWDENV field.
	USBPHY_PWD_SET_RXPWDENV_Pos = 0x11
	// Bit mask of RXPWDENV field.
	USBPHY_PWD_SET_RXPWDENV_Msk = 0x20000
	// Bit RXPWDENV.
	USBPHY_PWD_SET_RXPWDENV = 0x20000
	// Position of RXPWD1PT1 field.
	USBPHY_PWD_SET_RXPWD1PT1_Pos = 0x12
	// Bit mask of RXPWD1PT1 field.
	USBPHY_PWD_SET_RXPWD1PT1_Msk = 0x40000
	// Bit RXPWD1PT1.
	USBPHY_PWD_SET_RXPWD1PT1 = 0x40000
	// Position of RXPWDDIFF field.
	USBPHY_PWD_SET_RXPWDDIFF_Pos = 0x13
	// Bit mask of RXPWDDIFF field.
	USBPHY_PWD_SET_RXPWDDIFF_Msk = 0x80000
	// Bit RXPWDDIFF.
	USBPHY_PWD_SET_RXPWDDIFF = 0x80000
	// Position of RXPWDRX field.
	USBPHY_PWD_SET_RXPWDRX_Pos = 0x14
	// Bit mask of RXPWDRX field.
	USBPHY_PWD_SET_RXPWDRX_Msk = 0x100000
	// Bit RXPWDRX.
	USBPHY_PWD_SET_RXPWDRX = 0x100000
	// Position of RSVD2 field.
	USBPHY_PWD_SET_RSVD2_Pos = 0x15
	// Bit mask of RSVD2 field.
	USBPHY_PWD_SET_RSVD2_Msk = 0xffe00000

	// PWD_CLR: USB PHY Power-Down Register
	// Position of RSVD0 field.
	USBPHY_PWD_CLR_RSVD0_Pos = 0x0
	// Bit mask of RSVD0 field.
	USBPHY_PWD_CLR_RSVD0_Msk = 0x3ff
	// Position of TXPWDFS field.
	USBPHY_PWD_CLR_TXPWDFS_Pos = 0xa
	// Bit mask of TXPWDFS field.
	USBPHY_PWD_CLR_TXPWDFS_Msk = 0x400
	// Bit TXPWDFS.
	USBPHY_PWD_CLR_TXPWDFS = 0x400
	// Position of TXPWDIBIAS field.
	USBPHY_PWD_CLR_TXPWDIBIAS_Pos = 0xb
	// Bit mask of TXPWDIBIAS field.
	USBPHY_PWD_CLR_TXPWDIBIAS_Msk = 0x800
	// Bit TXPWDIBIAS.
	USBPHY_PWD_CLR_TXPWDIBIAS = 0x800
	// Position of TXPWDV2I field.
	USBPHY_PWD_CLR_TXPWDV2I_Pos = 0xc
	// Bit mask of TXPWDV2I field.
	USBPHY_PWD_CLR_TXPWDV2I_Msk = 0x1000
	// Bit TXPWDV2I.
	USBPHY_PWD_CLR_TXPWDV2I = 0x1000
	// Position of RSVD1 field.
	USBPHY_PWD_CLR_RSVD1_Pos = 0xd
	// Bit mask of RSVD1 field.
	USBPHY_PWD_CLR_RSVD1_Msk = 0x1e000
	// Position of RXPWDENV field.
	USBPHY_PWD_CLR_RXPWDENV_Pos = 0x11
	// Bit mask of RXPWDENV field.
	USBPHY_PWD_CLR_RXPWDENV_Msk = 0x20000
	// Bit RXPWDENV.
	USBPHY_PWD_CLR_RXPWDENV = 0x20000
	// Position of RXPWD1PT1 field.
	USBPHY_PWD_CLR_RXPWD1PT1_Pos = 0x12
	// Bit mask of RXPWD1PT1 field.
	USBPHY_PWD_CLR_RXPWD1PT1_Msk = 0x40000
	// Bit RXPWD1PT1.
	USBPHY_PWD_CLR_RXPWD1PT1 = 0x40000
	// Position of RXPWDDIFF field.
	USBPHY_PWD_CLR_RXPWDDIFF_Pos = 0x13
	// Bit mask of RXPWDDIFF field.
	USBPHY_PWD_CLR_RXPWDDIFF_Msk = 0x80000
	// Bit RXPWDDIFF.
	USBPHY_PWD_CLR_RXPWDDIFF = 0x80000
	// Position of RXPWDRX field.
	USBPHY_PWD_CLR_RXPWDRX_Pos = 0x14
	// Bit mask of RXPWDRX field.
	USBPHY_PWD_CLR_RXPWDRX_Msk = 0x100000
	// Bit RXPWDRX.
	USBPHY_PWD_CLR_RXPWDRX = 0x100000
	// Position of RSVD2 field.
	USBPHY_PWD_CLR_RSVD2_Pos = 0x15
	// Bit mask of RSVD2 field.
	USBPHY_PWD_CLR_RSVD2_Msk = 0xffe00000

	// PWD_TOG: USB PHY Power-Down Register
	// Position of RSVD0 field.
	USBPHY_PWD_TOG_RSVD0_Pos = 0x0
	// Bit mask of RSVD0 field.
	USBPHY_PWD_TOG_RSVD0_Msk = 0x3ff
	// Position of TXPWDFS field.
	USBPHY_PWD_TOG_TXPWDFS_Pos = 0xa
	// Bit mask of TXPWDFS field.
	USBPHY_PWD_TOG_TXPWDFS_Msk = 0x400
	// Bit TXPWDFS.
	USBPHY_PWD_TOG_TXPWDFS = 0x400
	// Position of TXPWDIBIAS field.
	USBPHY_PWD_TOG_TXPWDIBIAS_Pos = 0xb
	// Bit mask of TXPWDIBIAS field.
	USBPHY_PWD_TOG_TXPWDIBIAS_Msk = 0x800
	// Bit TXPWDIBIAS.
	USBPHY_PWD_TOG_TXPWDIBIAS = 0x800
	// Position of TXPWDV2I field.
	USBPHY_PWD_TOG_TXPWDV2I_Pos = 0xc
	// Bit mask of TXPWDV2I field.
	USBPHY_PWD_TOG_TXPWDV2I_Msk = 0x1000
	// Bit TXPWDV2I.
	USBPHY_PWD_TOG_TXPWDV2I = 0x1000
	// Position of RSVD1 field.
	USBPHY_PWD_TOG_RSVD1_Pos = 0xd
	// Bit mask of RSVD1 field.
	USBPHY_PWD_TOG_RSVD1_Msk = 0x1e000
	// Position of RXPWDENV field.
	USBPHY_PWD_TOG_RXPWDENV_Pos = 0x11
	// Bit mask of RXPWDENV field.
	USBPHY_PWD_TOG_RXPWDENV_Msk = 0x20000
	// Bit RXPWDENV.
	USBPHY_PWD_TOG_RXPWDENV = 0x20000
	// Position of RXPWD1PT1 field.
	USBPHY_PWD_TOG_RXPWD1PT1_Pos = 0x12
	// Bit mask of RXPWD1PT1 field.
	USBPHY_PWD_TOG_RXPWD1PT1_Msk = 0x40000
	// Bit RXPWD1PT1.
	USBPHY_PWD_TOG_RXPWD1PT1 = 0x40000
	// Position of RXPWDDIFF field.
	USBPHY_PWD_TOG_RXPWDDIFF_Pos = 0x13
	// Bit mask of RXPWDDIFF field.
	USBPHY_PWD_TOG_RXPWDDIFF_Msk = 0x80000
	// Bit RXPWDDIFF.
	USBPHY_PWD_TOG_RXPWDDIFF = 0x80000
	// Position of RXPWDRX field.
	USBPHY_PWD_TOG_RXPWDRX_Pos = 0x14
	// Bit mask of RXPWDRX field.
	USBPHY_PWD_TOG_RXPWDRX_Msk = 0x100000
	// Bit RXPWDRX.
	USBPHY_PWD_TOG_RXPWDRX = 0x100000
	// Position of RSVD2 field.
	USBPHY_PWD_TOG_RSVD2_Pos = 0x15
	// Bit mask of RSVD2 field.
	USBPHY_PWD_TOG_RSVD2_Msk = 0xffe00000

	// TX: USB PHY Transmitter Control Register
	// Position of D_CAL field.
	USBPHY_TX_D_CAL_Pos = 0x0
	// Bit mask of D_CAL field.
	USBPHY_TX_D_CAL_Msk = 0xf
	// Position of RSVD0 field.
	USBPHY_TX_RSVD0_Pos = 0x4
	// Bit mask of RSVD0 field.
	USBPHY_TX_RSVD0_Msk = 0xf0
	// Position of TXCAL45DN field.
	USBPHY_TX_TXCAL45DN_Pos = 0x8
	// Bit mask of TXCAL45DN field.
	USBPHY_TX_TXCAL45DN_Msk = 0xf00
	// Position of RSVD1 field.
	USBPHY_TX_RSVD1_Pos = 0xc
	// Bit mask of RSVD1 field.
	USBPHY_TX_RSVD1_Msk = 0xf000
	// Position of TXCAL45DP field.
	USBPHY_TX_TXCAL45DP_Pos = 0x10
	// Bit mask of TXCAL45DP field.
	USBPHY_TX_TXCAL45DP_Msk = 0xf0000
	// Position of RSVD2 field.
	USBPHY_TX_RSVD2_Pos = 0x14
	// Bit mask of RSVD2 field.
	USBPHY_TX_RSVD2_Msk = 0x3f00000
	// Position of USBPHY_TX_EDGECTRL field.
	USBPHY_TX_USBPHY_TX_EDGECTRL_Pos = 0x1a
	// Bit mask of USBPHY_TX_EDGECTRL field.
	USBPHY_TX_USBPHY_TX_EDGECTRL_Msk = 0x1c000000
	// Position of RSVD5 field.
	USBPHY_TX_RSVD5_Pos = 0x1d
	// Bit mask of RSVD5 field.
	USBPHY_TX_RSVD5_Msk = 0xe0000000

	// TX_SET: USB PHY Transmitter Control Register
	// Position of D_CAL field.
	USBPHY_TX_SET_D_CAL_Pos = 0x0
	// Bit mask of D_CAL field.
	USBPHY_TX_SET_D_CAL_Msk = 0xf
	// Position of RSVD0 field.
	USBPHY_TX_SET_RSVD0_Pos = 0x4
	// Bit mask of RSVD0 field.
	USBPHY_TX_SET_RSVD0_Msk = 0xf0
	// Position of TXCAL45DN field.
	USBPHY_TX_SET_TXCAL45DN_Pos = 0x8
	// Bit mask of TXCAL45DN field.
	USBPHY_TX_SET_TXCAL45DN_Msk = 0xf00
	// Position of RSVD1 field.
	USBPHY_TX_SET_RSVD1_Pos = 0xc
	// Bit mask of RSVD1 field.
	USBPHY_TX_SET_RSVD1_Msk = 0xf000
	// Position of TXCAL45DP field.
	USBPHY_TX_SET_TXCAL45DP_Pos = 0x10
	// Bit mask of TXCAL45DP field.
	USBPHY_TX_SET_TXCAL45DP_Msk = 0xf0000
	// Position of RSVD2 field.
	USBPHY_TX_SET_RSVD2_Pos = 0x14
	// Bit mask of RSVD2 field.
	USBPHY_TX_SET_RSVD2_Msk = 0x3f00000
	// Position of USBPHY_TX_EDGECTRL field.
	USBPHY_TX_SET_USBPHY_TX_EDGECTRL_Pos = 0x1a
	// Bit mask of USBPHY_TX_EDGECTRL field.
	USBPHY_TX_SET_USBPHY_TX_EDGECTRL_Msk = 0x1c000000
	// Position of RSVD5 field.
	USBPHY_TX_SET_RSVD5_Pos = 0x1d
	// Bit mask of RSVD5 field.
	USBPHY_TX_SET_RSVD5_Msk = 0xe0000000

	// TX_CLR: USB PHY Transmitter Control Register
	// Position of D_CAL field.
	USBPHY_TX_CLR_D_CAL_Pos = 0x0
	// Bit mask of D_CAL field.
	USBPHY_TX_CLR_D_CAL_Msk = 0xf
	// Position of RSVD0 field.
	USBPHY_TX_CLR_RSVD0_Pos = 0x4
	// Bit mask of RSVD0 field.
	USBPHY_TX_CLR_RSVD0_Msk = 0xf0
	// Position of TXCAL45DN field.
	USBPHY_TX_CLR_TXCAL45DN_Pos = 0x8
	// Bit mask of TXCAL45DN field.
	USBPHY_TX_CLR_TXCAL45DN_Msk = 0xf00
	// Position of RSVD1 field.
	USBPHY_TX_CLR_RSVD1_Pos = 0xc
	// Bit mask of RSVD1 field.
	USBPHY_TX_CLR_RSVD1_Msk = 0xf000
	// Position of TXCAL45DP field.
	USBPHY_TX_CLR_TXCAL45DP_Pos = 0x10
	// Bit mask of TXCAL45DP field.
	USBPHY_TX_CLR_TXCAL45DP_Msk = 0xf0000
	// Position of RSVD2 field.
	USBPHY_TX_CLR_RSVD2_Pos = 0x14
	// Bit mask of RSVD2 field.
	USBPHY_TX_CLR_RSVD2_Msk = 0x3f00000
	// Position of USBPHY_TX_EDGECTRL field.
	USBPHY_TX_CLR_USBPHY_TX_EDGECTRL_Pos = 0x1a
	// Bit mask of USBPHY_TX_EDGECTRL field.
	USBPHY_TX_CLR_USBPHY_TX_EDGECTRL_Msk = 0x1c000000
	// Position of RSVD5 field.
	USBPHY_TX_CLR_RSVD5_Pos = 0x1d
	// Bit mask of RSVD5 field.
	USBPHY_TX_CLR_RSVD5_Msk = 0xe0000000

	// TX_TOG: USB PHY Transmitter Control Register
	// Position of D_CAL field.
	USBPHY_TX_TOG_D_CAL_Pos = 0x0
	// Bit mask of D_CAL field.
	USBPHY_TX_TOG_D_CAL_Msk = 0xf
	// Position of RSVD0 field.
	USBPHY_TX_TOG_RSVD0_Pos = 0x4
	// Bit mask of RSVD0 field.
	USBPHY_TX_TOG_RSVD0_Msk = 0xf0
	// Position of TXCAL45DN field.
	USBPHY_TX_TOG_TXCAL45DN_Pos = 0x8
	// Bit mask of TXCAL45DN field.
	USBPHY_TX_TOG_TXCAL45DN_Msk = 0xf00
	// Position of RSVD1 field.
	USBPHY_TX_TOG_RSVD1_Pos = 0xc
	// Bit mask of RSVD1 field.
	USBPHY_TX_TOG_RSVD1_Msk = 0xf000
	// Position of TXCAL45DP field.
	USBPHY_TX_TOG_TXCAL45DP_Pos = 0x10
	// Bit mask of TXCAL45DP field.
	USBPHY_TX_TOG_TXCAL45DP_Msk = 0xf0000
	// Position of RSVD2 field.
	USBPHY_TX_TOG_RSVD2_Pos = 0x14
	// Bit mask of RSVD2 field.
	USBPHY_TX_TOG_RSVD2_Msk = 0x3f00000
	// Position of USBPHY_TX_EDGECTRL field.
	USBPHY_TX_TOG_USBPHY_TX_EDGECTRL_Pos = 0x1a
	// Bit mask of USBPHY_TX_EDGECTRL field.
	USBPHY_TX_TOG_USBPHY_TX_EDGECTRL_Msk = 0x1c000000
	// Position of RSVD5 field.
	USBPHY_TX_TOG_RSVD5_Pos = 0x1d
	// Bit mask of RSVD5 field.
	USBPHY_TX_TOG_RSVD5_Msk = 0xe0000000

	// RX: USB PHY Receiver Control Register
	// Position of ENVADJ field.
	USBPHY_RX_ENVADJ_Pos = 0x0
	// Bit mask of ENVADJ field.
	USBPHY_RX_ENVADJ_Msk = 0x7
	// Position of RSVD0 field.
	USBPHY_RX_RSVD0_Pos = 0x3
	// Bit mask of RSVD0 field.
	USBPHY_RX_RSVD0_Msk = 0x8
	// Bit RSVD0.
	USBPHY_RX_RSVD0 = 0x8
	// Position of DISCONADJ field.
	USBPHY_RX_DISCONADJ_Pos = 0x4
	// Bit mask of DISCONADJ field.
	USBPHY_RX_DISCONADJ_Msk = 0x70
	// Position of RSVD1 field.
	USBPHY_RX_RSVD1_Pos = 0x7
	// Bit mask of RSVD1 field.
	USBPHY_RX_RSVD1_Msk = 0x3fff80
	// Position of RXDBYPASS field.
	USBPHY_RX_RXDBYPASS_Pos = 0x16
	// Bit mask of RXDBYPASS field.
	USBPHY_RX_RXDBYPASS_Msk = 0x400000
	// Bit RXDBYPASS.
	USBPHY_RX_RXDBYPASS = 0x400000
	// Position of RSVD2 field.
	USBPHY_RX_RSVD2_Pos = 0x17
	// Bit mask of RSVD2 field.
	USBPHY_RX_RSVD2_Msk = 0xff800000

	// RX_SET: USB PHY Receiver Control Register
	// Position of ENVADJ field.
	USBPHY_RX_SET_ENVADJ_Pos = 0x0
	// Bit mask of ENVADJ field.
	USBPHY_RX_SET_ENVADJ_Msk = 0x7
	// Position of RSVD0 field.
	USBPHY_RX_SET_RSVD0_Pos = 0x3
	// Bit mask of RSVD0 field.
	USBPHY_RX_SET_RSVD0_Msk = 0x8
	// Bit RSVD0.
	USBPHY_RX_SET_RSVD0 = 0x8
	// Position of DISCONADJ field.
	USBPHY_RX_SET_DISCONADJ_Pos = 0x4
	// Bit mask of DISCONADJ field.
	USBPHY_RX_SET_DISCONADJ_Msk = 0x70
	// Position of RSVD1 field.
	USBPHY_RX_SET_RSVD1_Pos = 0x7
	// Bit mask of RSVD1 field.
	USBPHY_RX_SET_RSVD1_Msk = 0x3fff80
	// Position of RXDBYPASS field.
	USBPHY_RX_SET_RXDBYPASS_Pos = 0x16
	// Bit mask of RXDBYPASS field.
	USBPHY_RX_SET_RXDBYPASS_Msk = 0x400000
	// Bit RXDBYPASS.
	USBPHY_RX_SET_RXDBYPASS = 0x400000
	// Position of RSVD2 field.
	USBPHY_RX_SET_RSVD2_Pos = 0x17
	// Bit mask of RSVD2 field.
	USBPHY_RX_SET_RSVD2_Msk = 0xff800000

	// RX_CLR: USB PHY Receiver Control Register
	// Position of ENVADJ field.
	USBPHY_RX_CLR_ENVADJ_Pos = 0x0
	// Bit mask of ENVADJ field.
	USBPHY_RX_CLR_ENVADJ_Msk = 0x7
	// Position of RSVD0 field.
	USBPHY_RX_CLR_RSVD0_Pos = 0x3
	// Bit mask of RSVD0 field.
	USBPHY_RX_CLR_RSVD0_Msk = 0x8
	// Bit RSVD0.
	USBPHY_RX_CLR_RSVD0 = 0x8
	// Position of DISCONADJ field.
	USBPHY_RX_CLR_DISCONADJ_Pos = 0x4
	// Bit mask of DISCONADJ field.
	USBPHY_RX_CLR_DISCONADJ_Msk = 0x70
	// Position of RSVD1 field.
	USBPHY_RX_CLR_RSVD1_Pos = 0x7
	// Bit mask of RSVD1 field.
	USBPHY_RX_CLR_RSVD1_Msk = 0x3fff80
	// Position of RXDBYPASS field.
	USBPHY_RX_CLR_RXDBYPASS_Pos = 0x16
	// Bit mask of RXDBYPASS field.
	USBPHY_RX_CLR_RXDBYPASS_Msk = 0x400000
	// Bit RXDBYPASS.
	USBPHY_RX_CLR_RXDBYPASS = 0x400000
	// Position of RSVD2 field.
	USBPHY_RX_CLR_RSVD2_Pos = 0x17
	// Bit mask of RSVD2 field.
	USBPHY_RX_CLR_RSVD2_Msk = 0xff800000

	// RX_TOG: USB PHY Receiver Control Register
	// Position of ENVADJ field.
	USBPHY_RX_TOG_ENVADJ_Pos = 0x0
	// Bit mask of ENVADJ field.
	USBPHY_RX_TOG_ENVADJ_Msk = 0x7
	// Position of RSVD0 field.
	USBPHY_RX_TOG_RSVD0_Pos = 0x3
	// Bit mask of RSVD0 field.
	USBPHY_RX_TOG_RSVD0_Msk = 0x8
	// Bit RSVD0.
	USBPHY_RX_TOG_RSVD0 = 0x8
	// Position of DISCONADJ field.
	USBPHY_RX_TOG_DISCONADJ_Pos = 0x4
	// Bit mask of DISCONADJ field.
	USBPHY_RX_TOG_DISCONADJ_Msk = 0x70
	// Position of RSVD1 field.
	USBPHY_RX_TOG_RSVD1_Pos = 0x7
	// Bit mask of RSVD1 field.
	USBPHY_RX_TOG_RSVD1_Msk = 0x3fff80
	// Position of RXDBYPASS field.
	USBPHY_RX_TOG_RXDBYPASS_Pos = 0x16
	// Bit mask of RXDBYPASS field.
	USBPHY_RX_TOG_RXDBYPASS_Msk = 0x400000
	// Bit RXDBYPASS.
	USBPHY_RX_TOG_RXDBYPASS = 0x400000
	// Position of RSVD2 field.
	USBPHY_RX_TOG_RSVD2_Pos = 0x17
	// Bit mask of RSVD2 field.
	USBPHY_RX_TOG_RSVD2_Msk = 0xff800000

	// CTRL: USB PHY General Control Register
	// Position of ENOTG_ID_CHG_IRQ field.
	USBPHY_CTRL_ENOTG_ID_CHG_IRQ_Pos = 0x0
	// Bit mask of ENOTG_ID_CHG_IRQ field.
	USBPHY_CTRL_ENOTG_ID_CHG_IRQ_Msk = 0x1
	// Bit ENOTG_ID_CHG_IRQ.
	USBPHY_CTRL_ENOTG_ID_CHG_IRQ = 0x1
	// Position of ENHOSTDISCONDETECT field.
	USBPHY_CTRL_ENHOSTDISCONDETECT_Pos = 0x1
	// Bit mask of ENHOSTDISCONDETECT field.
	USBPHY_CTRL_ENHOSTDISCONDETECT_Msk = 0x2
	// Bit ENHOSTDISCONDETECT.
	USBPHY_CTRL_ENHOSTDISCONDETECT = 0x2
	// Position of ENIRQHOSTDISCON field.
	USBPHY_CTRL_ENIRQHOSTDISCON_Pos = 0x2
	// Bit mask of ENIRQHOSTDISCON field.
	USBPHY_CTRL_ENIRQHOSTDISCON_Msk = 0x4
	// Bit ENIRQHOSTDISCON.
	USBPHY_CTRL_ENIRQHOSTDISCON = 0x4
	// Position of HOSTDISCONDETECT_IRQ field.
	USBPHY_CTRL_HOSTDISCONDETECT_IRQ_Pos = 0x3
	// Bit mask of HOSTDISCONDETECT_IRQ field.
	USBPHY_CTRL_HOSTDISCONDETECT_IRQ_Msk = 0x8
	// Bit HOSTDISCONDETECT_IRQ.
	USBPHY_CTRL_HOSTDISCONDETECT_IRQ = 0x8
	// Position of ENDEVPLUGINDETECT field.
	USBPHY_CTRL_ENDEVPLUGINDETECT_Pos = 0x4
	// Bit mask of ENDEVPLUGINDETECT field.
	USBPHY_CTRL_ENDEVPLUGINDETECT_Msk = 0x10
	// Bit ENDEVPLUGINDETECT.
	USBPHY_CTRL_ENDEVPLUGINDETECT = 0x10
	// Position of DEVPLUGIN_POLARITY field.
	USBPHY_CTRL_DEVPLUGIN_POLARITY_Pos = 0x5
	// Bit mask of DEVPLUGIN_POLARITY field.
	USBPHY_CTRL_DEVPLUGIN_POLARITY_Msk = 0x20
	// Bit DEVPLUGIN_POLARITY.
	USBPHY_CTRL_DEVPLUGIN_POLARITY = 0x20
	// Position of OTG_ID_CHG_IRQ field.
	USBPHY_CTRL_OTG_ID_CHG_IRQ_Pos = 0x6
	// Bit mask of OTG_ID_CHG_IRQ field.
	USBPHY_CTRL_OTG_ID_CHG_IRQ_Msk = 0x40
	// Bit OTG_ID_CHG_IRQ.
	USBPHY_CTRL_OTG_ID_CHG_IRQ = 0x40
	// Position of ENOTGIDDETECT field.
	USBPHY_CTRL_ENOTGIDDETECT_Pos = 0x7
	// Bit mask of ENOTGIDDETECT field.
	USBPHY_CTRL_ENOTGIDDETECT_Msk = 0x80
	// Bit ENOTGIDDETECT.
	USBPHY_CTRL_ENOTGIDDETECT = 0x80
	// Position of RESUMEIRQSTICKY field.
	USBPHY_CTRL_RESUMEIRQSTICKY_Pos = 0x8
	// Bit mask of RESUMEIRQSTICKY field.
	USBPHY_CTRL_RESUMEIRQSTICKY_Msk = 0x100
	// Bit RESUMEIRQSTICKY.
	USBPHY_CTRL_RESUMEIRQSTICKY = 0x100
	// Position of ENIRQRESUMEDETECT field.
	USBPHY_CTRL_ENIRQRESUMEDETECT_Pos = 0x9
	// Bit mask of ENIRQRESUMEDETECT field.
	USBPHY_CTRL_ENIRQRESUMEDETECT_Msk = 0x200
	// Bit ENIRQRESUMEDETECT.
	USBPHY_CTRL_ENIRQRESUMEDETECT = 0x200
	// Position of RESUME_IRQ field.
	USBPHY_CTRL_RESUME_IRQ_Pos = 0xa
	// Bit mask of RESUME_IRQ field.
	USBPHY_CTRL_RESUME_IRQ_Msk = 0x400
	// Bit RESUME_IRQ.
	USBPHY_CTRL_RESUME_IRQ = 0x400
	// Position of ENIRQDEVPLUGIN field.
	USBPHY_CTRL_ENIRQDEVPLUGIN_Pos = 0xb
	// Bit mask of ENIRQDEVPLUGIN field.
	USBPHY_CTRL_ENIRQDEVPLUGIN_Msk = 0x800
	// Bit ENIRQDEVPLUGIN.
	USBPHY_CTRL_ENIRQDEVPLUGIN = 0x800
	// Position of DEVPLUGIN_IRQ field.
	USBPHY_CTRL_DEVPLUGIN_IRQ_Pos = 0xc
	// Bit mask of DEVPLUGIN_IRQ field.
	USBPHY_CTRL_DEVPLUGIN_IRQ_Msk = 0x1000
	// Bit DEVPLUGIN_IRQ.
	USBPHY_CTRL_DEVPLUGIN_IRQ = 0x1000
	// Position of DATA_ON_LRADC field.
	USBPHY_CTRL_DATA_ON_LRADC_Pos = 0xd
	// Bit mask of DATA_ON_LRADC field.
	USBPHY_CTRL_DATA_ON_LRADC_Msk = 0x2000
	// Bit DATA_ON_LRADC.
	USBPHY_CTRL_DATA_ON_LRADC = 0x2000
	// Position of ENUTMILEVEL2 field.
	USBPHY_CTRL_ENUTMILEVEL2_Pos = 0xe
	// Bit mask of ENUTMILEVEL2 field.
	USBPHY_CTRL_ENUTMILEVEL2_Msk = 0x4000
	// Bit ENUTMILEVEL2.
	USBPHY_CTRL_ENUTMILEVEL2 = 0x4000
	// Position of ENUTMILEVEL3 field.
	USBPHY_CTRL_ENUTMILEVEL3_Pos = 0xf
	// Bit mask of ENUTMILEVEL3 field.
	USBPHY_CTRL_ENUTMILEVEL3_Msk = 0x8000
	// Bit ENUTMILEVEL3.
	USBPHY_CTRL_ENUTMILEVEL3 = 0x8000
	// Position of ENIRQWAKEUP field.
	USBPHY_CTRL_ENIRQWAKEUP_Pos = 0x10
	// Bit mask of ENIRQWAKEUP field.
	USBPHY_CTRL_ENIRQWAKEUP_Msk = 0x10000
	// Bit ENIRQWAKEUP.
	USBPHY_CTRL_ENIRQWAKEUP = 0x10000
	// Position of WAKEUP_IRQ field.
	USBPHY_CTRL_WAKEUP_IRQ_Pos = 0x11
	// Bit mask of WAKEUP_IRQ field.
	USBPHY_CTRL_WAKEUP_IRQ_Msk = 0x20000
	// Bit WAKEUP_IRQ.
	USBPHY_CTRL_WAKEUP_IRQ = 0x20000
	// Position of ENAUTO_PWRON_PLL field.
	USBPHY_CTRL_ENAUTO_PWRON_PLL_Pos = 0x12
	// Bit mask of ENAUTO_PWRON_PLL field.
	USBPHY_CTRL_ENAUTO_PWRON_PLL_Msk = 0x40000
	// Bit ENAUTO_PWRON_PLL.
	USBPHY_CTRL_ENAUTO_PWRON_PLL = 0x40000
	// Position of ENAUTOCLR_CLKGATE field.
	USBPHY_CTRL_ENAUTOCLR_CLKGATE_Pos = 0x13
	// Bit mask of ENAUTOCLR_CLKGATE field.
	USBPHY_CTRL_ENAUTOCLR_CLKGATE_Msk = 0x80000
	// Bit ENAUTOCLR_CLKGATE.
	USBPHY_CTRL_ENAUTOCLR_CLKGATE = 0x80000
	// Position of ENAUTOCLR_PHY_PWD field.
	USBPHY_CTRL_ENAUTOCLR_PHY_PWD_Pos = 0x14
	// Bit mask of ENAUTOCLR_PHY_PWD field.
	USBPHY_CTRL_ENAUTOCLR_PHY_PWD_Msk = 0x100000
	// Bit ENAUTOCLR_PHY_PWD.
	USBPHY_CTRL_ENAUTOCLR_PHY_PWD = 0x100000
	// Position of ENDPDMCHG_WKUP field.
	USBPHY_CTRL_ENDPDMCHG_WKUP_Pos = 0x15
	// Bit mask of ENDPDMCHG_WKUP field.
	USBPHY_CTRL_ENDPDMCHG_WKUP_Msk = 0x200000
	// Bit ENDPDMCHG_WKUP.
	USBPHY_CTRL_ENDPDMCHG_WKUP = 0x200000
	// Position of ENIDCHG_WKUP field.
	USBPHY_CTRL_ENIDCHG_WKUP_Pos = 0x16
	// Bit mask of ENIDCHG_WKUP field.
	USBPHY_CTRL_ENIDCHG_WKUP_Msk = 0x400000
	// Bit ENIDCHG_WKUP.
	USBPHY_CTRL_ENIDCHG_WKUP = 0x400000
	// Position of ENVBUSCHG_WKUP field.
	USBPHY_CTRL_ENVBUSCHG_WKUP_Pos = 0x17
	// Bit mask of ENVBUSCHG_WKUP field.
	USBPHY_CTRL_ENVBUSCHG_WKUP_Msk = 0x800000
	// Bit ENVBUSCHG_WKUP.
	USBPHY_CTRL_ENVBUSCHG_WKUP = 0x800000
	// Position of FSDLL_RST_EN field.
	USBPHY_CTRL_FSDLL_RST_EN_Pos = 0x18
	// Bit mask of FSDLL_RST_EN field.
	USBPHY_CTRL_FSDLL_RST_EN_Msk = 0x1000000
	// Bit FSDLL_RST_EN.
	USBPHY_CTRL_FSDLL_RST_EN = 0x1000000
	// Position of RSVD1 field.
	USBPHY_CTRL_RSVD1_Pos = 0x19
	// Bit mask of RSVD1 field.
	USBPHY_CTRL_RSVD1_Msk = 0x6000000
	// Position of OTG_ID_VALUE field.
	USBPHY_CTRL_OTG_ID_VALUE_Pos = 0x1b
	// Bit mask of OTG_ID_VALUE field.
	USBPHY_CTRL_OTG_ID_VALUE_Msk = 0x8000000
	// Bit OTG_ID_VALUE.
	USBPHY_CTRL_OTG_ID_VALUE = 0x8000000
	// Position of HOST_FORCE_LS_SE0 field.
	USBPHY_CTRL_HOST_FORCE_LS_SE0_Pos = 0x1c
	// Bit mask of HOST_FORCE_LS_SE0 field.
	USBPHY_CTRL_HOST_FORCE_LS_SE0_Msk = 0x10000000
	// Bit HOST_FORCE_LS_SE0.
	USBPHY_CTRL_HOST_FORCE_LS_SE0 = 0x10000000
	// Position of UTMI_SUSPENDM field.
	USBPHY_CTRL_UTMI_SUSPENDM_Pos = 0x1d
	// Bit mask of UTMI_SUSPENDM field.
	USBPHY_CTRL_UTMI_SUSPENDM_Msk = 0x20000000
	// Bit UTMI_SUSPENDM.
	USBPHY_CTRL_UTMI_SUSPENDM = 0x20000000
	// Position of CLKGATE field.
	USBPHY_CTRL_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	USBPHY_CTRL_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	USBPHY_CTRL_CLKGATE = 0x40000000
	// Position of SFTRST field.
	USBPHY_CTRL_SFTRST_Pos = 0x1f
	// Bit mask of SFTRST field.
	USBPHY_CTRL_SFTRST_Msk = 0x80000000
	// Bit SFTRST.
	USBPHY_CTRL_SFTRST = 0x80000000

	// CTRL_SET: USB PHY General Control Register
	// Position of ENOTG_ID_CHG_IRQ field.
	USBPHY_CTRL_SET_ENOTG_ID_CHG_IRQ_Pos = 0x0
	// Bit mask of ENOTG_ID_CHG_IRQ field.
	USBPHY_CTRL_SET_ENOTG_ID_CHG_IRQ_Msk = 0x1
	// Bit ENOTG_ID_CHG_IRQ.
	USBPHY_CTRL_SET_ENOTG_ID_CHG_IRQ = 0x1
	// Position of ENHOSTDISCONDETECT field.
	USBPHY_CTRL_SET_ENHOSTDISCONDETECT_Pos = 0x1
	// Bit mask of ENHOSTDISCONDETECT field.
	USBPHY_CTRL_SET_ENHOSTDISCONDETECT_Msk = 0x2
	// Bit ENHOSTDISCONDETECT.
	USBPHY_CTRL_SET_ENHOSTDISCONDETECT = 0x2
	// Position of ENIRQHOSTDISCON field.
	USBPHY_CTRL_SET_ENIRQHOSTDISCON_Pos = 0x2
	// Bit mask of ENIRQHOSTDISCON field.
	USBPHY_CTRL_SET_ENIRQHOSTDISCON_Msk = 0x4
	// Bit ENIRQHOSTDISCON.
	USBPHY_CTRL_SET_ENIRQHOSTDISCON = 0x4
	// Position of HOSTDISCONDETECT_IRQ field.
	USBPHY_CTRL_SET_HOSTDISCONDETECT_IRQ_Pos = 0x3
	// Bit mask of HOSTDISCONDETECT_IRQ field.
	USBPHY_CTRL_SET_HOSTDISCONDETECT_IRQ_Msk = 0x8
	// Bit HOSTDISCONDETECT_IRQ.
	USBPHY_CTRL_SET_HOSTDISCONDETECT_IRQ = 0x8
	// Position of ENDEVPLUGINDETECT field.
	USBPHY_CTRL_SET_ENDEVPLUGINDETECT_Pos = 0x4
	// Bit mask of ENDEVPLUGINDETECT field.
	USBPHY_CTRL_SET_ENDEVPLUGINDETECT_Msk = 0x10
	// Bit ENDEVPLUGINDETECT.
	USBPHY_CTRL_SET_ENDEVPLUGINDETECT = 0x10
	// Position of DEVPLUGIN_POLARITY field.
	USBPHY_CTRL_SET_DEVPLUGIN_POLARITY_Pos = 0x5
	// Bit mask of DEVPLUGIN_POLARITY field.
	USBPHY_CTRL_SET_DEVPLUGIN_POLARITY_Msk = 0x20
	// Bit DEVPLUGIN_POLARITY.
	USBPHY_CTRL_SET_DEVPLUGIN_POLARITY = 0x20
	// Position of OTG_ID_CHG_IRQ field.
	USBPHY_CTRL_SET_OTG_ID_CHG_IRQ_Pos = 0x6
	// Bit mask of OTG_ID_CHG_IRQ field.
	USBPHY_CTRL_SET_OTG_ID_CHG_IRQ_Msk = 0x40
	// Bit OTG_ID_CHG_IRQ.
	USBPHY_CTRL_SET_OTG_ID_CHG_IRQ = 0x40
	// Position of ENOTGIDDETECT field.
	USBPHY_CTRL_SET_ENOTGIDDETECT_Pos = 0x7
	// Bit mask of ENOTGIDDETECT field.
	USBPHY_CTRL_SET_ENOTGIDDETECT_Msk = 0x80
	// Bit ENOTGIDDETECT.
	USBPHY_CTRL_SET_ENOTGIDDETECT = 0x80
	// Position of RESUMEIRQSTICKY field.
	USBPHY_CTRL_SET_RESUMEIRQSTICKY_Pos = 0x8
	// Bit mask of RESUMEIRQSTICKY field.
	USBPHY_CTRL_SET_RESUMEIRQSTICKY_Msk = 0x100
	// Bit RESUMEIRQSTICKY.
	USBPHY_CTRL_SET_RESUMEIRQSTICKY = 0x100
	// Position of ENIRQRESUMEDETECT field.
	USBPHY_CTRL_SET_ENIRQRESUMEDETECT_Pos = 0x9
	// Bit mask of ENIRQRESUMEDETECT field.
	USBPHY_CTRL_SET_ENIRQRESUMEDETECT_Msk = 0x200
	// Bit ENIRQRESUMEDETECT.
	USBPHY_CTRL_SET_ENIRQRESUMEDETECT = 0x200
	// Position of RESUME_IRQ field.
	USBPHY_CTRL_SET_RESUME_IRQ_Pos = 0xa
	// Bit mask of RESUME_IRQ field.
	USBPHY_CTRL_SET_RESUME_IRQ_Msk = 0x400
	// Bit RESUME_IRQ.
	USBPHY_CTRL_SET_RESUME_IRQ = 0x400
	// Position of ENIRQDEVPLUGIN field.
	USBPHY_CTRL_SET_ENIRQDEVPLUGIN_Pos = 0xb
	// Bit mask of ENIRQDEVPLUGIN field.
	USBPHY_CTRL_SET_ENIRQDEVPLUGIN_Msk = 0x800
	// Bit ENIRQDEVPLUGIN.
	USBPHY_CTRL_SET_ENIRQDEVPLUGIN = 0x800
	// Position of DEVPLUGIN_IRQ field.
	USBPHY_CTRL_SET_DEVPLUGIN_IRQ_Pos = 0xc
	// Bit mask of DEVPLUGIN_IRQ field.
	USBPHY_CTRL_SET_DEVPLUGIN_IRQ_Msk = 0x1000
	// Bit DEVPLUGIN_IRQ.
	USBPHY_CTRL_SET_DEVPLUGIN_IRQ = 0x1000
	// Position of DATA_ON_LRADC field.
	USBPHY_CTRL_SET_DATA_ON_LRADC_Pos = 0xd
	// Bit mask of DATA_ON_LRADC field.
	USBPHY_CTRL_SET_DATA_ON_LRADC_Msk = 0x2000
	// Bit DATA_ON_LRADC.
	USBPHY_CTRL_SET_DATA_ON_LRADC = 0x2000
	// Position of ENUTMILEVEL2 field.
	USBPHY_CTRL_SET_ENUTMILEVEL2_Pos = 0xe
	// Bit mask of ENUTMILEVEL2 field.
	USBPHY_CTRL_SET_ENUTMILEVEL2_Msk = 0x4000
	// Bit ENUTMILEVEL2.
	USBPHY_CTRL_SET_ENUTMILEVEL2 = 0x4000
	// Position of ENUTMILEVEL3 field.
	USBPHY_CTRL_SET_ENUTMILEVEL3_Pos = 0xf
	// Bit mask of ENUTMILEVEL3 field.
	USBPHY_CTRL_SET_ENUTMILEVEL3_Msk = 0x8000
	// Bit ENUTMILEVEL3.
	USBPHY_CTRL_SET_ENUTMILEVEL3 = 0x8000
	// Position of ENIRQWAKEUP field.
	USBPHY_CTRL_SET_ENIRQWAKEUP_Pos = 0x10
	// Bit mask of ENIRQWAKEUP field.
	USBPHY_CTRL_SET_ENIRQWAKEUP_Msk = 0x10000
	// Bit ENIRQWAKEUP.
	USBPHY_CTRL_SET_ENIRQWAKEUP = 0x10000
	// Position of WAKEUP_IRQ field.
	USBPHY_CTRL_SET_WAKEUP_IRQ_Pos = 0x11
	// Bit mask of WAKEUP_IRQ field.
	USBPHY_CTRL_SET_WAKEUP_IRQ_Msk = 0x20000
	// Bit WAKEUP_IRQ.
	USBPHY_CTRL_SET_WAKEUP_IRQ = 0x20000
	// Position of ENAUTO_PWRON_PLL field.
	USBPHY_CTRL_SET_ENAUTO_PWRON_PLL_Pos = 0x12
	// Bit mask of ENAUTO_PWRON_PLL field.
	USBPHY_CTRL_SET_ENAUTO_PWRON_PLL_Msk = 0x40000
	// Bit ENAUTO_PWRON_PLL.
	USBPHY_CTRL_SET_ENAUTO_PWRON_PLL = 0x40000
	// Position of ENAUTOCLR_CLKGATE field.
	USBPHY_CTRL_SET_ENAUTOCLR_CLKGATE_Pos = 0x13
	// Bit mask of ENAUTOCLR_CLKGATE field.
	USBPHY_CTRL_SET_ENAUTOCLR_CLKGATE_Msk = 0x80000
	// Bit ENAUTOCLR_CLKGATE.
	USBPHY_CTRL_SET_ENAUTOCLR_CLKGATE = 0x80000
	// Position of ENAUTOCLR_PHY_PWD field.
	USBPHY_CTRL_SET_ENAUTOCLR_PHY_PWD_Pos = 0x14
	// Bit mask of ENAUTOCLR_PHY_PWD field.
	USBPHY_CTRL_SET_ENAUTOCLR_PHY_PWD_Msk = 0x100000
	// Bit ENAUTOCLR_PHY_PWD.
	USBPHY_CTRL_SET_ENAUTOCLR_PHY_PWD = 0x100000
	// Position of ENDPDMCHG_WKUP field.
	USBPHY_CTRL_SET_ENDPDMCHG_WKUP_Pos = 0x15
	// Bit mask of ENDPDMCHG_WKUP field.
	USBPHY_CTRL_SET_ENDPDMCHG_WKUP_Msk = 0x200000
	// Bit ENDPDMCHG_WKUP.
	USBPHY_CTRL_SET_ENDPDMCHG_WKUP = 0x200000
	// Position of ENIDCHG_WKUP field.
	USBPHY_CTRL_SET_ENIDCHG_WKUP_Pos = 0x16
	// Bit mask of ENIDCHG_WKUP field.
	USBPHY_CTRL_SET_ENIDCHG_WKUP_Msk = 0x400000
	// Bit ENIDCHG_WKUP.
	USBPHY_CTRL_SET_ENIDCHG_WKUP = 0x400000
	// Position of ENVBUSCHG_WKUP field.
	USBPHY_CTRL_SET_ENVBUSCHG_WKUP_Pos = 0x17
	// Bit mask of ENVBUSCHG_WKUP field.
	USBPHY_CTRL_SET_ENVBUSCHG_WKUP_Msk = 0x800000
	// Bit ENVBUSCHG_WKUP.
	USBPHY_CTRL_SET_ENVBUSCHG_WKUP = 0x800000
	// Position of FSDLL_RST_EN field.
	USBPHY_CTRL_SET_FSDLL_RST_EN_Pos = 0x18
	// Bit mask of FSDLL_RST_EN field.
	USBPHY_CTRL_SET_FSDLL_RST_EN_Msk = 0x1000000
	// Bit FSDLL_RST_EN.
	USBPHY_CTRL_SET_FSDLL_RST_EN = 0x1000000
	// Position of RSVD1 field.
	USBPHY_CTRL_SET_RSVD1_Pos = 0x19
	// Bit mask of RSVD1 field.
	USBPHY_CTRL_SET_RSVD1_Msk = 0x6000000
	// Position of OTG_ID_VALUE field.
	USBPHY_CTRL_SET_OTG_ID_VALUE_Pos = 0x1b
	// Bit mask of OTG_ID_VALUE field.
	USBPHY_CTRL_SET_OTG_ID_VALUE_Msk = 0x8000000
	// Bit OTG_ID_VALUE.
	USBPHY_CTRL_SET_OTG_ID_VALUE = 0x8000000
	// Position of HOST_FORCE_LS_SE0 field.
	USBPHY_CTRL_SET_HOST_FORCE_LS_SE0_Pos = 0x1c
	// Bit mask of HOST_FORCE_LS_SE0 field.
	USBPHY_CTRL_SET_HOST_FORCE_LS_SE0_Msk = 0x10000000
	// Bit HOST_FORCE_LS_SE0.
	USBPHY_CTRL_SET_HOST_FORCE_LS_SE0 = 0x10000000
	// Position of UTMI_SUSPENDM field.
	USBPHY_CTRL_SET_UTMI_SUSPENDM_Pos = 0x1d
	// Bit mask of UTMI_SUSPENDM field.
	USBPHY_CTRL_SET_UTMI_SUSPENDM_Msk = 0x20000000
	// Bit UTMI_SUSPENDM.
	USBPHY_CTRL_SET_UTMI_SUSPENDM = 0x20000000
	// Position of CLKGATE field.
	USBPHY_CTRL_SET_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	USBPHY_CTRL_SET_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	USBPHY_CTRL_SET_CLKGATE = 0x40000000
	// Position of SFTRST field.
	USBPHY_CTRL_SET_SFTRST_Pos = 0x1f
	// Bit mask of SFTRST field.
	USBPHY_CTRL_SET_SFTRST_Msk = 0x80000000
	// Bit SFTRST.
	USBPHY_CTRL_SET_SFTRST = 0x80000000

	// CTRL_CLR: USB PHY General Control Register
	// Position of ENOTG_ID_CHG_IRQ field.
	USBPHY_CTRL_CLR_ENOTG_ID_CHG_IRQ_Pos = 0x0
	// Bit mask of ENOTG_ID_CHG_IRQ field.
	USBPHY_CTRL_CLR_ENOTG_ID_CHG_IRQ_Msk = 0x1
	// Bit ENOTG_ID_CHG_IRQ.
	USBPHY_CTRL_CLR_ENOTG_ID_CHG_IRQ = 0x1
	// Position of ENHOSTDISCONDETECT field.
	USBPHY_CTRL_CLR_ENHOSTDISCONDETECT_Pos = 0x1
	// Bit mask of ENHOSTDISCONDETECT field.
	USBPHY_CTRL_CLR_ENHOSTDISCONDETECT_Msk = 0x2
	// Bit ENHOSTDISCONDETECT.
	USBPHY_CTRL_CLR_ENHOSTDISCONDETECT = 0x2
	// Position of ENIRQHOSTDISCON field.
	USBPHY_CTRL_CLR_ENIRQHOSTDISCON_Pos = 0x2
	// Bit mask of ENIRQHOSTDISCON field.
	USBPHY_CTRL_CLR_ENIRQHOSTDISCON_Msk = 0x4
	// Bit ENIRQHOSTDISCON.
	USBPHY_CTRL_CLR_ENIRQHOSTDISCON = 0x4
	// Position of HOSTDISCONDETECT_IRQ field.
	USBPHY_CTRL_CLR_HOSTDISCONDETECT_IRQ_Pos = 0x3
	// Bit mask of HOSTDISCONDETECT_IRQ field.
	USBPHY_CTRL_CLR_HOSTDISCONDETECT_IRQ_Msk = 0x8
	// Bit HOSTDISCONDETECT_IRQ.
	USBPHY_CTRL_CLR_HOSTDISCONDETECT_IRQ = 0x8
	// Position of ENDEVPLUGINDETECT field.
	USBPHY_CTRL_CLR_ENDEVPLUGINDETECT_Pos = 0x4
	// Bit mask of ENDEVPLUGINDETECT field.
	USBPHY_CTRL_CLR_ENDEVPLUGINDETECT_Msk = 0x10
	// Bit ENDEVPLUGINDETECT.
	USBPHY_CTRL_CLR_ENDEVPLUGINDETECT = 0x10
	// Position of DEVPLUGIN_POLARITY field.
	USBPHY_CTRL_CLR_DEVPLUGIN_POLARITY_Pos = 0x5
	// Bit mask of DEVPLUGIN_POLARITY field.
	USBPHY_CTRL_CLR_DEVPLUGIN_POLARITY_Msk = 0x20
	// Bit DEVPLUGIN_POLARITY.
	USBPHY_CTRL_CLR_DEVPLUGIN_POLARITY = 0x20
	// Position of OTG_ID_CHG_IRQ field.
	USBPHY_CTRL_CLR_OTG_ID_CHG_IRQ_Pos = 0x6
	// Bit mask of OTG_ID_CHG_IRQ field.
	USBPHY_CTRL_CLR_OTG_ID_CHG_IRQ_Msk = 0x40
	// Bit OTG_ID_CHG_IRQ.
	USBPHY_CTRL_CLR_OTG_ID_CHG_IRQ = 0x40
	// Position of ENOTGIDDETECT field.
	USBPHY_CTRL_CLR_ENOTGIDDETECT_Pos = 0x7
	// Bit mask of ENOTGIDDETECT field.
	USBPHY_CTRL_CLR_ENOTGIDDETECT_Msk = 0x80
	// Bit ENOTGIDDETECT.
	USBPHY_CTRL_CLR_ENOTGIDDETECT = 0x80
	// Position of RESUMEIRQSTICKY field.
	USBPHY_CTRL_CLR_RESUMEIRQSTICKY_Pos = 0x8
	// Bit mask of RESUMEIRQSTICKY field.
	USBPHY_CTRL_CLR_RESUMEIRQSTICKY_Msk = 0x100
	// Bit RESUMEIRQSTICKY.
	USBPHY_CTRL_CLR_RESUMEIRQSTICKY = 0x100
	// Position of ENIRQRESUMEDETECT field.
	USBPHY_CTRL_CLR_ENIRQRESUMEDETECT_Pos = 0x9
	// Bit mask of ENIRQRESUMEDETECT field.
	USBPHY_CTRL_CLR_ENIRQRESUMEDETECT_Msk = 0x200
	// Bit ENIRQRESUMEDETECT.
	USBPHY_CTRL_CLR_ENIRQRESUMEDETECT = 0x200
	// Position of RESUME_IRQ field.
	USBPHY_CTRL_CLR_RESUME_IRQ_Pos = 0xa
	// Bit mask of RESUME_IRQ field.
	USBPHY_CTRL_CLR_RESUME_IRQ_Msk = 0x400
	// Bit RESUME_IRQ.
	USBPHY_CTRL_CLR_RESUME_IRQ = 0x400
	// Position of ENIRQDEVPLUGIN field.
	USBPHY_CTRL_CLR_ENIRQDEVPLUGIN_Pos = 0xb
	// Bit mask of ENIRQDEVPLUGIN field.
	USBPHY_CTRL_CLR_ENIRQDEVPLUGIN_Msk = 0x800
	// Bit ENIRQDEVPLUGIN.
	USBPHY_CTRL_CLR_ENIRQDEVPLUGIN = 0x800
	// Position of DEVPLUGIN_IRQ field.
	USBPHY_CTRL_CLR_DEVPLUGIN_IRQ_Pos = 0xc
	// Bit mask of DEVPLUGIN_IRQ field.
	USBPHY_CTRL_CLR_DEVPLUGIN_IRQ_Msk = 0x1000
	// Bit DEVPLUGIN_IRQ.
	USBPHY_CTRL_CLR_DEVPLUGIN_IRQ = 0x1000
	// Position of DATA_ON_LRADC field.
	USBPHY_CTRL_CLR_DATA_ON_LRADC_Pos = 0xd
	// Bit mask of DATA_ON_LRADC field.
	USBPHY_CTRL_CLR_DATA_ON_LRADC_Msk = 0x2000
	// Bit DATA_ON_LRADC.
	USBPHY_CTRL_CLR_DATA_ON_LRADC = 0x2000
	// Position of ENUTMILEVEL2 field.
	USBPHY_CTRL_CLR_ENUTMILEVEL2_Pos = 0xe
	// Bit mask of ENUTMILEVEL2 field.
	USBPHY_CTRL_CLR_ENUTMILEVEL2_Msk = 0x4000
	// Bit ENUTMILEVEL2.
	USBPHY_CTRL_CLR_ENUTMILEVEL2 = 0x4000
	// Position of ENUTMILEVEL3 field.
	USBPHY_CTRL_CLR_ENUTMILEVEL3_Pos = 0xf
	// Bit mask of ENUTMILEVEL3 field.
	USBPHY_CTRL_CLR_ENUTMILEVEL3_Msk = 0x8000
	// Bit ENUTMILEVEL3.
	USBPHY_CTRL_CLR_ENUTMILEVEL3 = 0x8000
	// Position of ENIRQWAKEUP field.
	USBPHY_CTRL_CLR_ENIRQWAKEUP_Pos = 0x10
	// Bit mask of ENIRQWAKEUP field.
	USBPHY_CTRL_CLR_ENIRQWAKEUP_Msk = 0x10000
	// Bit ENIRQWAKEUP.
	USBPHY_CTRL_CLR_ENIRQWAKEUP = 0x10000
	// Position of WAKEUP_IRQ field.
	USBPHY_CTRL_CLR_WAKEUP_IRQ_Pos = 0x11
	// Bit mask of WAKEUP_IRQ field.
	USBPHY_CTRL_CLR_WAKEUP_IRQ_Msk = 0x20000
	// Bit WAKEUP_IRQ.
	USBPHY_CTRL_CLR_WAKEUP_IRQ = 0x20000
	// Position of ENAUTO_PWRON_PLL field.
	USBPHY_CTRL_CLR_ENAUTO_PWRON_PLL_Pos = 0x12
	// Bit mask of ENAUTO_PWRON_PLL field.
	USBPHY_CTRL_CLR_ENAUTO_PWRON_PLL_Msk = 0x40000
	// Bit ENAUTO_PWRON_PLL.
	USBPHY_CTRL_CLR_ENAUTO_PWRON_PLL = 0x40000
	// Position of ENAUTOCLR_CLKGATE field.
	USBPHY_CTRL_CLR_ENAUTOCLR_CLKGATE_Pos = 0x13
	// Bit mask of ENAUTOCLR_CLKGATE field.
	USBPHY_CTRL_CLR_ENAUTOCLR_CLKGATE_Msk = 0x80000
	// Bit ENAUTOCLR_CLKGATE.
	USBPHY_CTRL_CLR_ENAUTOCLR_CLKGATE = 0x80000
	// Position of ENAUTOCLR_PHY_PWD field.
	USBPHY_CTRL_CLR_ENAUTOCLR_PHY_PWD_Pos = 0x14
	// Bit mask of ENAUTOCLR_PHY_PWD field.
	USBPHY_CTRL_CLR_ENAUTOCLR_PHY_PWD_Msk = 0x100000
	// Bit ENAUTOCLR_PHY_PWD.
	USBPHY_CTRL_CLR_ENAUTOCLR_PHY_PWD = 0x100000
	// Position of ENDPDMCHG_WKUP field.
	USBPHY_CTRL_CLR_ENDPDMCHG_WKUP_Pos = 0x15
	// Bit mask of ENDPDMCHG_WKUP field.
	USBPHY_CTRL_CLR_ENDPDMCHG_WKUP_Msk = 0x200000
	// Bit ENDPDMCHG_WKUP.
	USBPHY_CTRL_CLR_ENDPDMCHG_WKUP = 0x200000
	// Position of ENIDCHG_WKUP field.
	USBPHY_CTRL_CLR_ENIDCHG_WKUP_Pos = 0x16
	// Bit mask of ENIDCHG_WKUP field.
	USBPHY_CTRL_CLR_ENIDCHG_WKUP_Msk = 0x400000
	// Bit ENIDCHG_WKUP.
	USBPHY_CTRL_CLR_ENIDCHG_WKUP = 0x400000
	// Position of ENVBUSCHG_WKUP field.
	USBPHY_CTRL_CLR_ENVBUSCHG_WKUP_Pos = 0x17
	// Bit mask of ENVBUSCHG_WKUP field.
	USBPHY_CTRL_CLR_ENVBUSCHG_WKUP_Msk = 0x800000
	// Bit ENVBUSCHG_WKUP.
	USBPHY_CTRL_CLR_ENVBUSCHG_WKUP = 0x800000
	// Position of FSDLL_RST_EN field.
	USBPHY_CTRL_CLR_FSDLL_RST_EN_Pos = 0x18
	// Bit mask of FSDLL_RST_EN field.
	USBPHY_CTRL_CLR_FSDLL_RST_EN_Msk = 0x1000000
	// Bit FSDLL_RST_EN.
	USBPHY_CTRL_CLR_FSDLL_RST_EN = 0x1000000
	// Position of RSVD1 field.
	USBPHY_CTRL_CLR_RSVD1_Pos = 0x19
	// Bit mask of RSVD1 field.
	USBPHY_CTRL_CLR_RSVD1_Msk = 0x6000000
	// Position of OTG_ID_VALUE field.
	USBPHY_CTRL_CLR_OTG_ID_VALUE_Pos = 0x1b
	// Bit mask of OTG_ID_VALUE field.
	USBPHY_CTRL_CLR_OTG_ID_VALUE_Msk = 0x8000000
	// Bit OTG_ID_VALUE.
	USBPHY_CTRL_CLR_OTG_ID_VALUE = 0x8000000
	// Position of HOST_FORCE_LS_SE0 field.
	USBPHY_CTRL_CLR_HOST_FORCE_LS_SE0_Pos = 0x1c
	// Bit mask of HOST_FORCE_LS_SE0 field.
	USBPHY_CTRL_CLR_HOST_FORCE_LS_SE0_Msk = 0x10000000
	// Bit HOST_FORCE_LS_SE0.
	USBPHY_CTRL_CLR_HOST_FORCE_LS_SE0 = 0x10000000
	// Position of UTMI_SUSPENDM field.
	USBPHY_CTRL_CLR_UTMI_SUSPENDM_Pos = 0x1d
	// Bit mask of UTMI_SUSPENDM field.
	USBPHY_CTRL_CLR_UTMI_SUSPENDM_Msk = 0x20000000
	// Bit UTMI_SUSPENDM.
	USBPHY_CTRL_CLR_UTMI_SUSPENDM = 0x20000000
	// Position of CLKGATE field.
	USBPHY_CTRL_CLR_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	USBPHY_CTRL_CLR_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	USBPHY_CTRL_CLR_CLKGATE = 0x40000000
	// Position of SFTRST field.
	USBPHY_CTRL_CLR_SFTRST_Pos = 0x1f
	// Bit mask of SFTRST field.
	USBPHY_CTRL_CLR_SFTRST_Msk = 0x80000000
	// Bit SFTRST.
	USBPHY_CTRL_CLR_SFTRST = 0x80000000

	// CTRL_TOG: USB PHY General Control Register
	// Position of ENOTG_ID_CHG_IRQ field.
	USBPHY_CTRL_TOG_ENOTG_ID_CHG_IRQ_Pos = 0x0
	// Bit mask of ENOTG_ID_CHG_IRQ field.
	USBPHY_CTRL_TOG_ENOTG_ID_CHG_IRQ_Msk = 0x1
	// Bit ENOTG_ID_CHG_IRQ.
	USBPHY_CTRL_TOG_ENOTG_ID_CHG_IRQ = 0x1
	// Position of ENHOSTDISCONDETECT field.
	USBPHY_CTRL_TOG_ENHOSTDISCONDETECT_Pos = 0x1
	// Bit mask of ENHOSTDISCONDETECT field.
	USBPHY_CTRL_TOG_ENHOSTDISCONDETECT_Msk = 0x2
	// Bit ENHOSTDISCONDETECT.
	USBPHY_CTRL_TOG_ENHOSTDISCONDETECT = 0x2
	// Position of ENIRQHOSTDISCON field.
	USBPHY_CTRL_TOG_ENIRQHOSTDISCON_Pos = 0x2
	// Bit mask of ENIRQHOSTDISCON field.
	USBPHY_CTRL_TOG_ENIRQHOSTDISCON_Msk = 0x4
	// Bit ENIRQHOSTDISCON.
	USBPHY_CTRL_TOG_ENIRQHOSTDISCON = 0x4
	// Position of HOSTDISCONDETECT_IRQ field.
	USBPHY_CTRL_TOG_HOSTDISCONDETECT_IRQ_Pos = 0x3
	// Bit mask of HOSTDISCONDETECT_IRQ field.
	USBPHY_CTRL_TOG_HOSTDISCONDETECT_IRQ_Msk = 0x8
	// Bit HOSTDISCONDETECT_IRQ.
	USBPHY_CTRL_TOG_HOSTDISCONDETECT_IRQ = 0x8
	// Position of ENDEVPLUGINDETECT field.
	USBPHY_CTRL_TOG_ENDEVPLUGINDETECT_Pos = 0x4
	// Bit mask of ENDEVPLUGINDETECT field.
	USBPHY_CTRL_TOG_ENDEVPLUGINDETECT_Msk = 0x10
	// Bit ENDEVPLUGINDETECT.
	USBPHY_CTRL_TOG_ENDEVPLUGINDETECT = 0x10
	// Position of DEVPLUGIN_POLARITY field.
	USBPHY_CTRL_TOG_DEVPLUGIN_POLARITY_Pos = 0x5
	// Bit mask of DEVPLUGIN_POLARITY field.
	USBPHY_CTRL_TOG_DEVPLUGIN_POLARITY_Msk = 0x20
	// Bit DEVPLUGIN_POLARITY.
	USBPHY_CTRL_TOG_DEVPLUGIN_POLARITY = 0x20
	// Position of OTG_ID_CHG_IRQ field.
	USBPHY_CTRL_TOG_OTG_ID_CHG_IRQ_Pos = 0x6
	// Bit mask of OTG_ID_CHG_IRQ field.
	USBPHY_CTRL_TOG_OTG_ID_CHG_IRQ_Msk = 0x40
	// Bit OTG_ID_CHG_IRQ.
	USBPHY_CTRL_TOG_OTG_ID_CHG_IRQ = 0x40
	// Position of ENOTGIDDETECT field.
	USBPHY_CTRL_TOG_ENOTGIDDETECT_Pos = 0x7
	// Bit mask of ENOTGIDDETECT field.
	USBPHY_CTRL_TOG_ENOTGIDDETECT_Msk = 0x80
	// Bit ENOTGIDDETECT.
	USBPHY_CTRL_TOG_ENOTGIDDETECT = 0x80
	// Position of RESUMEIRQSTICKY field.
	USBPHY_CTRL_TOG_RESUMEIRQSTICKY_Pos = 0x8
	// Bit mask of RESUMEIRQSTICKY field.
	USBPHY_CTRL_TOG_RESUMEIRQSTICKY_Msk = 0x100
	// Bit RESUMEIRQSTICKY.
	USBPHY_CTRL_TOG_RESUMEIRQSTICKY = 0x100
	// Position of ENIRQRESUMEDETECT field.
	USBPHY_CTRL_TOG_ENIRQRESUMEDETECT_Pos = 0x9
	// Bit mask of ENIRQRESUMEDETECT field.
	USBPHY_CTRL_TOG_ENIRQRESUMEDETECT_Msk = 0x200
	// Bit ENIRQRESUMEDETECT.
	USBPHY_CTRL_TOG_ENIRQRESUMEDETECT = 0x200
	// Position of RESUME_IRQ field.
	USBPHY_CTRL_TOG_RESUME_IRQ_Pos = 0xa
	// Bit mask of RESUME_IRQ field.
	USBPHY_CTRL_TOG_RESUME_IRQ_Msk = 0x400
	// Bit RESUME_IRQ.
	USBPHY_CTRL_TOG_RESUME_IRQ = 0x400
	// Position of ENIRQDEVPLUGIN field.
	USBPHY_CTRL_TOG_ENIRQDEVPLUGIN_Pos = 0xb
	// Bit mask of ENIRQDEVPLUGIN field.
	USBPHY_CTRL_TOG_ENIRQDEVPLUGIN_Msk = 0x800
	// Bit ENIRQDEVPLUGIN.
	USBPHY_CTRL_TOG_ENIRQDEVPLUGIN = 0x800
	// Position of DEVPLUGIN_IRQ field.
	USBPHY_CTRL_TOG_DEVPLUGIN_IRQ_Pos = 0xc
	// Bit mask of DEVPLUGIN_IRQ field.
	USBPHY_CTRL_TOG_DEVPLUGIN_IRQ_Msk = 0x1000
	// Bit DEVPLUGIN_IRQ.
	USBPHY_CTRL_TOG_DEVPLUGIN_IRQ = 0x1000
	// Position of DATA_ON_LRADC field.
	USBPHY_CTRL_TOG_DATA_ON_LRADC_Pos = 0xd
	// Bit mask of DATA_ON_LRADC field.
	USBPHY_CTRL_TOG_DATA_ON_LRADC_Msk = 0x2000
	// Bit DATA_ON_LRADC.
	USBPHY_CTRL_TOG_DATA_ON_LRADC = 0x2000
	// Position of ENUTMILEVEL2 field.
	USBPHY_CTRL_TOG_ENUTMILEVEL2_Pos = 0xe
	// Bit mask of ENUTMILEVEL2 field.
	USBPHY_CTRL_TOG_ENUTMILEVEL2_Msk = 0x4000
	// Bit ENUTMILEVEL2.
	USBPHY_CTRL_TOG_ENUTMILEVEL2 = 0x4000
	// Position of ENUTMILEVEL3 field.
	USBPHY_CTRL_TOG_ENUTMILEVEL3_Pos = 0xf
	// Bit mask of ENUTMILEVEL3 field.
	USBPHY_CTRL_TOG_ENUTMILEVEL3_Msk = 0x8000
	// Bit ENUTMILEVEL3.
	USBPHY_CTRL_TOG_ENUTMILEVEL3 = 0x8000
	// Position of ENIRQWAKEUP field.
	USBPHY_CTRL_TOG_ENIRQWAKEUP_Pos = 0x10
	// Bit mask of ENIRQWAKEUP field.
	USBPHY_CTRL_TOG_ENIRQWAKEUP_Msk = 0x10000
	// Bit ENIRQWAKEUP.
	USBPHY_CTRL_TOG_ENIRQWAKEUP = 0x10000
	// Position of WAKEUP_IRQ field.
	USBPHY_CTRL_TOG_WAKEUP_IRQ_Pos = 0x11
	// Bit mask of WAKEUP_IRQ field.
	USBPHY_CTRL_TOG_WAKEUP_IRQ_Msk = 0x20000
	// Bit WAKEUP_IRQ.
	USBPHY_CTRL_TOG_WAKEUP_IRQ = 0x20000
	// Position of ENAUTO_PWRON_PLL field.
	USBPHY_CTRL_TOG_ENAUTO_PWRON_PLL_Pos = 0x12
	// Bit mask of ENAUTO_PWRON_PLL field.
	USBPHY_CTRL_TOG_ENAUTO_PWRON_PLL_Msk = 0x40000
	// Bit ENAUTO_PWRON_PLL.
	USBPHY_CTRL_TOG_ENAUTO_PWRON_PLL = 0x40000
	// Position of ENAUTOCLR_CLKGATE field.
	USBPHY_CTRL_TOG_ENAUTOCLR_CLKGATE_Pos = 0x13
	// Bit mask of ENAUTOCLR_CLKGATE field.
	USBPHY_CTRL_TOG_ENAUTOCLR_CLKGATE_Msk = 0x80000
	// Bit ENAUTOCLR_CLKGATE.
	USBPHY_CTRL_TOG_ENAUTOCLR_CLKGATE = 0x80000
	// Position of ENAUTOCLR_PHY_PWD field.
	USBPHY_CTRL_TOG_ENAUTOCLR_PHY_PWD_Pos = 0x14
	// Bit mask of ENAUTOCLR_PHY_PWD field.
	USBPHY_CTRL_TOG_ENAUTOCLR_PHY_PWD_Msk = 0x100000
	// Bit ENAUTOCLR_PHY_PWD.
	USBPHY_CTRL_TOG_ENAUTOCLR_PHY_PWD = 0x100000
	// Position of ENDPDMCHG_WKUP field.
	USBPHY_CTRL_TOG_ENDPDMCHG_WKUP_Pos = 0x15
	// Bit mask of ENDPDMCHG_WKUP field.
	USBPHY_CTRL_TOG_ENDPDMCHG_WKUP_Msk = 0x200000
	// Bit ENDPDMCHG_WKUP.
	USBPHY_CTRL_TOG_ENDPDMCHG_WKUP = 0x200000
	// Position of ENIDCHG_WKUP field.
	USBPHY_CTRL_TOG_ENIDCHG_WKUP_Pos = 0x16
	// Bit mask of ENIDCHG_WKUP field.
	USBPHY_CTRL_TOG_ENIDCHG_WKUP_Msk = 0x400000
	// Bit ENIDCHG_WKUP.
	USBPHY_CTRL_TOG_ENIDCHG_WKUP = 0x400000
	// Position of ENVBUSCHG_WKUP field.
	USBPHY_CTRL_TOG_ENVBUSCHG_WKUP_Pos = 0x17
	// Bit mask of ENVBUSCHG_WKUP field.
	USBPHY_CTRL_TOG_ENVBUSCHG_WKUP_Msk = 0x800000
	// Bit ENVBUSCHG_WKUP.
	USBPHY_CTRL_TOG_ENVBUSCHG_WKUP = 0x800000
	// Position of FSDLL_RST_EN field.
	USBPHY_CTRL_TOG_FSDLL_RST_EN_Pos = 0x18
	// Bit mask of FSDLL_RST_EN field.
	USBPHY_CTRL_TOG_FSDLL_RST_EN_Msk = 0x1000000
	// Bit FSDLL_RST_EN.
	USBPHY_CTRL_TOG_FSDLL_RST_EN = 0x1000000
	// Position of RSVD1 field.
	USBPHY_CTRL_TOG_RSVD1_Pos = 0x19
	// Bit mask of RSVD1 field.
	USBPHY_CTRL_TOG_RSVD1_Msk = 0x6000000
	// Position of OTG_ID_VALUE field.
	USBPHY_CTRL_TOG_OTG_ID_VALUE_Pos = 0x1b
	// Bit mask of OTG_ID_VALUE field.
	USBPHY_CTRL_TOG_OTG_ID_VALUE_Msk = 0x8000000
	// Bit OTG_ID_VALUE.
	USBPHY_CTRL_TOG_OTG_ID_VALUE = 0x8000000
	// Position of HOST_FORCE_LS_SE0 field.
	USBPHY_CTRL_TOG_HOST_FORCE_LS_SE0_Pos = 0x1c
	// Bit mask of HOST_FORCE_LS_SE0 field.
	USBPHY_CTRL_TOG_HOST_FORCE_LS_SE0_Msk = 0x10000000
	// Bit HOST_FORCE_LS_SE0.
	USBPHY_CTRL_TOG_HOST_FORCE_LS_SE0 = 0x10000000
	// Position of UTMI_SUSPENDM field.
	USBPHY_CTRL_TOG_UTMI_SUSPENDM_Pos = 0x1d
	// Bit mask of UTMI_SUSPENDM field.
	USBPHY_CTRL_TOG_UTMI_SUSPENDM_Msk = 0x20000000
	// Bit UTMI_SUSPENDM.
	USBPHY_CTRL_TOG_UTMI_SUSPENDM = 0x20000000
	// Position of CLKGATE field.
	USBPHY_CTRL_TOG_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	USBPHY_CTRL_TOG_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	USBPHY_CTRL_TOG_CLKGATE = 0x40000000
	// Position of SFTRST field.
	USBPHY_CTRL_TOG_SFTRST_Pos = 0x1f
	// Bit mask of SFTRST field.
	USBPHY_CTRL_TOG_SFTRST_Msk = 0x80000000
	// Bit SFTRST.
	USBPHY_CTRL_TOG_SFTRST = 0x80000000

	// STATUS: USB PHY Status Register
	// Position of RSVD0 field.
	USBPHY_STATUS_RSVD0_Pos = 0x0
	// Bit mask of RSVD0 field.
	USBPHY_STATUS_RSVD0_Msk = 0x7
	// Position of HOSTDISCONDETECT_STATUS field.
	USBPHY_STATUS_HOSTDISCONDETECT_STATUS_Pos = 0x3
	// Bit mask of HOSTDISCONDETECT_STATUS field.
	USBPHY_STATUS_HOSTDISCONDETECT_STATUS_Msk = 0x8
	// Bit HOSTDISCONDETECT_STATUS.
	USBPHY_STATUS_HOSTDISCONDETECT_STATUS = 0x8
	// Position of RSVD1 field.
	USBPHY_STATUS_RSVD1_Pos = 0x4
	// Bit mask of RSVD1 field.
	USBPHY_STATUS_RSVD1_Msk = 0x30
	// Position of DEVPLUGIN_STATUS field.
	USBPHY_STATUS_DEVPLUGIN_STATUS_Pos = 0x6
	// Bit mask of DEVPLUGIN_STATUS field.
	USBPHY_STATUS_DEVPLUGIN_STATUS_Msk = 0x40
	// Bit DEVPLUGIN_STATUS.
	USBPHY_STATUS_DEVPLUGIN_STATUS = 0x40
	// Position of RSVD2 field.
	USBPHY_STATUS_RSVD2_Pos = 0x7
	// Bit mask of RSVD2 field.
	USBPHY_STATUS_RSVD2_Msk = 0x80
	// Bit RSVD2.
	USBPHY_STATUS_RSVD2 = 0x80
	// Position of OTGID_STATUS field.
	USBPHY_STATUS_OTGID_STATUS_Pos = 0x8
	// Bit mask of OTGID_STATUS field.
	USBPHY_STATUS_OTGID_STATUS_Msk = 0x100
	// Bit OTGID_STATUS.
	USBPHY_STATUS_OTGID_STATUS = 0x100
	// Position of RSVD3 field.
	USBPHY_STATUS_RSVD3_Pos = 0x9
	// Bit mask of RSVD3 field.
	USBPHY_STATUS_RSVD3_Msk = 0x200
	// Bit RSVD3.
	USBPHY_STATUS_RSVD3 = 0x200
	// Position of RESUME_STATUS field.
	USBPHY_STATUS_RESUME_STATUS_Pos = 0xa
	// Bit mask of RESUME_STATUS field.
	USBPHY_STATUS_RESUME_STATUS_Msk = 0x400
	// Bit RESUME_STATUS.
	USBPHY_STATUS_RESUME_STATUS = 0x400
	// Position of RSVD4 field.
	USBPHY_STATUS_RSVD4_Pos = 0xb
	// Bit mask of RSVD4 field.
	USBPHY_STATUS_RSVD4_Msk = 0xfffff800

	// DEBUG: USB PHY Debug Register
	// Position of OTGIDPIOLOCK field.
	USBPHY_DEBUG_OTGIDPIOLOCK_Pos = 0x0
	// Bit mask of OTGIDPIOLOCK field.
	USBPHY_DEBUG_OTGIDPIOLOCK_Msk = 0x1
	// Bit OTGIDPIOLOCK.
	USBPHY_DEBUG_OTGIDPIOLOCK = 0x1
	// Position of DEBUG_INTERFACE_HOLD field.
	USBPHY_DEBUG_DEBUG_INTERFACE_HOLD_Pos = 0x1
	// Bit mask of DEBUG_INTERFACE_HOLD field.
	USBPHY_DEBUG_DEBUG_INTERFACE_HOLD_Msk = 0x2
	// Bit DEBUG_INTERFACE_HOLD.
	USBPHY_DEBUG_DEBUG_INTERFACE_HOLD = 0x2
	// Position of HSTPULLDOWN field.
	USBPHY_DEBUG_HSTPULLDOWN_Pos = 0x2
	// Bit mask of HSTPULLDOWN field.
	USBPHY_DEBUG_HSTPULLDOWN_Msk = 0xc
	// Position of ENHSTPULLDOWN field.
	USBPHY_DEBUG_ENHSTPULLDOWN_Pos = 0x4
	// Bit mask of ENHSTPULLDOWN field.
	USBPHY_DEBUG_ENHSTPULLDOWN_Msk = 0x30
	// Position of RSVD0 field.
	USBPHY_DEBUG_RSVD0_Pos = 0x6
	// Bit mask of RSVD0 field.
	USBPHY_DEBUG_RSVD0_Msk = 0xc0
	// Position of TX2RXCOUNT field.
	USBPHY_DEBUG_TX2RXCOUNT_Pos = 0x8
	// Bit mask of TX2RXCOUNT field.
	USBPHY_DEBUG_TX2RXCOUNT_Msk = 0xf00
	// Position of ENTX2RXCOUNT field.
	USBPHY_DEBUG_ENTX2RXCOUNT_Pos = 0xc
	// Bit mask of ENTX2RXCOUNT field.
	USBPHY_DEBUG_ENTX2RXCOUNT_Msk = 0x1000
	// Bit ENTX2RXCOUNT.
	USBPHY_DEBUG_ENTX2RXCOUNT = 0x1000
	// Position of RSVD1 field.
	USBPHY_DEBUG_RSVD1_Pos = 0xd
	// Bit mask of RSVD1 field.
	USBPHY_DEBUG_RSVD1_Msk = 0xe000
	// Position of SQUELCHRESETCOUNT field.
	USBPHY_DEBUG_SQUELCHRESETCOUNT_Pos = 0x10
	// Bit mask of SQUELCHRESETCOUNT field.
	USBPHY_DEBUG_SQUELCHRESETCOUNT_Msk = 0x1f0000
	// Position of RSVD2 field.
	USBPHY_DEBUG_RSVD2_Pos = 0x15
	// Bit mask of RSVD2 field.
	USBPHY_DEBUG_RSVD2_Msk = 0xe00000
	// Position of ENSQUELCHRESET field.
	USBPHY_DEBUG_ENSQUELCHRESET_Pos = 0x18
	// Bit mask of ENSQUELCHRESET field.
	USBPHY_DEBUG_ENSQUELCHRESET_Msk = 0x1000000
	// Bit ENSQUELCHRESET.
	USBPHY_DEBUG_ENSQUELCHRESET = 0x1000000
	// Position of SQUELCHRESETLENGTH field.
	USBPHY_DEBUG_SQUELCHRESETLENGTH_Pos = 0x19
	// Bit mask of SQUELCHRESETLENGTH field.
	USBPHY_DEBUG_SQUELCHRESETLENGTH_Msk = 0x1e000000
	// Position of HOST_RESUME_DEBUG field.
	USBPHY_DEBUG_HOST_RESUME_DEBUG_Pos = 0x1d
	// Bit mask of HOST_RESUME_DEBUG field.
	USBPHY_DEBUG_HOST_RESUME_DEBUG_Msk = 0x20000000
	// Bit HOST_RESUME_DEBUG.
	USBPHY_DEBUG_HOST_RESUME_DEBUG = 0x20000000
	// Position of CLKGATE field.
	USBPHY_DEBUG_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	USBPHY_DEBUG_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	USBPHY_DEBUG_CLKGATE = 0x40000000
	// Position of RSVD3 field.
	USBPHY_DEBUG_RSVD3_Pos = 0x1f
	// Bit mask of RSVD3 field.
	USBPHY_DEBUG_RSVD3_Msk = 0x80000000
	// Bit RSVD3.
	USBPHY_DEBUG_RSVD3 = 0x80000000

	// DEBUG_SET: USB PHY Debug Register
	// Position of OTGIDPIOLOCK field.
	USBPHY_DEBUG_SET_OTGIDPIOLOCK_Pos = 0x0
	// Bit mask of OTGIDPIOLOCK field.
	USBPHY_DEBUG_SET_OTGIDPIOLOCK_Msk = 0x1
	// Bit OTGIDPIOLOCK.
	USBPHY_DEBUG_SET_OTGIDPIOLOCK = 0x1
	// Position of DEBUG_INTERFACE_HOLD field.
	USBPHY_DEBUG_SET_DEBUG_INTERFACE_HOLD_Pos = 0x1
	// Bit mask of DEBUG_INTERFACE_HOLD field.
	USBPHY_DEBUG_SET_DEBUG_INTERFACE_HOLD_Msk = 0x2
	// Bit DEBUG_INTERFACE_HOLD.
	USBPHY_DEBUG_SET_DEBUG_INTERFACE_HOLD = 0x2
	// Position of HSTPULLDOWN field.
	USBPHY_DEBUG_SET_HSTPULLDOWN_Pos = 0x2
	// Bit mask of HSTPULLDOWN field.
	USBPHY_DEBUG_SET_HSTPULLDOWN_Msk = 0xc
	// Position of ENHSTPULLDOWN field.
	USBPHY_DEBUG_SET_ENHSTPULLDOWN_Pos = 0x4
	// Bit mask of ENHSTPULLDOWN field.
	USBPHY_DEBUG_SET_ENHSTPULLDOWN_Msk = 0x30
	// Position of RSVD0 field.
	USBPHY_DEBUG_SET_RSVD0_Pos = 0x6
	// Bit mask of RSVD0 field.
	USBPHY_DEBUG_SET_RSVD0_Msk = 0xc0
	// Position of TX2RXCOUNT field.
	USBPHY_DEBUG_SET_TX2RXCOUNT_Pos = 0x8
	// Bit mask of TX2RXCOUNT field.
	USBPHY_DEBUG_SET_TX2RXCOUNT_Msk = 0xf00
	// Position of ENTX2RXCOUNT field.
	USBPHY_DEBUG_SET_ENTX2RXCOUNT_Pos = 0xc
	// Bit mask of ENTX2RXCOUNT field.
	USBPHY_DEBUG_SET_ENTX2RXCOUNT_Msk = 0x1000
	// Bit ENTX2RXCOUNT.
	USBPHY_DEBUG_SET_ENTX2RXCOUNT = 0x1000
	// Position of RSVD1 field.
	USBPHY_DEBUG_SET_RSVD1_Pos = 0xd
	// Bit mask of RSVD1 field.
	USBPHY_DEBUG_SET_RSVD1_Msk = 0xe000
	// Position of SQUELCHRESETCOUNT field.
	USBPHY_DEBUG_SET_SQUELCHRESETCOUNT_Pos = 0x10
	// Bit mask of SQUELCHRESETCOUNT field.
	USBPHY_DEBUG_SET_SQUELCHRESETCOUNT_Msk = 0x1f0000
	// Position of RSVD2 field.
	USBPHY_DEBUG_SET_RSVD2_Pos = 0x15
	// Bit mask of RSVD2 field.
	USBPHY_DEBUG_SET_RSVD2_Msk = 0xe00000
	// Position of ENSQUELCHRESET field.
	USBPHY_DEBUG_SET_ENSQUELCHRESET_Pos = 0x18
	// Bit mask of ENSQUELCHRESET field.
	USBPHY_DEBUG_SET_ENSQUELCHRESET_Msk = 0x1000000
	// Bit ENSQUELCHRESET.
	USBPHY_DEBUG_SET_ENSQUELCHRESET = 0x1000000
	// Position of SQUELCHRESETLENGTH field.
	USBPHY_DEBUG_SET_SQUELCHRESETLENGTH_Pos = 0x19
	// Bit mask of SQUELCHRESETLENGTH field.
	USBPHY_DEBUG_SET_SQUELCHRESETLENGTH_Msk = 0x1e000000
	// Position of HOST_RESUME_DEBUG field.
	USBPHY_DEBUG_SET_HOST_RESUME_DEBUG_Pos = 0x1d
	// Bit mask of HOST_RESUME_DEBUG field.
	USBPHY_DEBUG_SET_HOST_RESUME_DEBUG_Msk = 0x20000000
	// Bit HOST_RESUME_DEBUG.
	USBPHY_DEBUG_SET_HOST_RESUME_DEBUG = 0x20000000
	// Position of CLKGATE field.
	USBPHY_DEBUG_SET_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	USBPHY_DEBUG_SET_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	USBPHY_DEBUG_SET_CLKGATE = 0x40000000
	// Position of RSVD3 field.
	USBPHY_DEBUG_SET_RSVD3_Pos = 0x1f
	// Bit mask of RSVD3 field.
	USBPHY_DEBUG_SET_RSVD3_Msk = 0x80000000
	// Bit RSVD3.
	USBPHY_DEBUG_SET_RSVD3 = 0x80000000

	// DEBUG_CLR: USB PHY Debug Register
	// Position of OTGIDPIOLOCK field.
	USBPHY_DEBUG_CLR_OTGIDPIOLOCK_Pos = 0x0
	// Bit mask of OTGIDPIOLOCK field.
	USBPHY_DEBUG_CLR_OTGIDPIOLOCK_Msk = 0x1
	// Bit OTGIDPIOLOCK.
	USBPHY_DEBUG_CLR_OTGIDPIOLOCK = 0x1
	// Position of DEBUG_INTERFACE_HOLD field.
	USBPHY_DEBUG_CLR_DEBUG_INTERFACE_HOLD_Pos = 0x1
	// Bit mask of DEBUG_INTERFACE_HOLD field.
	USBPHY_DEBUG_CLR_DEBUG_INTERFACE_HOLD_Msk = 0x2
	// Bit DEBUG_INTERFACE_HOLD.
	USBPHY_DEBUG_CLR_DEBUG_INTERFACE_HOLD = 0x2
	// Position of HSTPULLDOWN field.
	USBPHY_DEBUG_CLR_HSTPULLDOWN_Pos = 0x2
	// Bit mask of HSTPULLDOWN field.
	USBPHY_DEBUG_CLR_HSTPULLDOWN_Msk = 0xc
	// Position of ENHSTPULLDOWN field.
	USBPHY_DEBUG_CLR_ENHSTPULLDOWN_Pos = 0x4
	// Bit mask of ENHSTPULLDOWN field.
	USBPHY_DEBUG_CLR_ENHSTPULLDOWN_Msk = 0x30
	// Position of RSVD0 field.
	USBPHY_DEBUG_CLR_RSVD0_Pos = 0x6
	// Bit mask of RSVD0 field.
	USBPHY_DEBUG_CLR_RSVD0_Msk = 0xc0
	// Position of TX2RXCOUNT field.
	USBPHY_DEBUG_CLR_TX2RXCOUNT_Pos = 0x8
	// Bit mask of TX2RXCOUNT field.
	USBPHY_DEBUG_CLR_TX2RXCOUNT_Msk = 0xf00
	// Position of ENTX2RXCOUNT field.
	USBPHY_DEBUG_CLR_ENTX2RXCOUNT_Pos = 0xc
	// Bit mask of ENTX2RXCOUNT field.
	USBPHY_DEBUG_CLR_ENTX2RXCOUNT_Msk = 0x1000
	// Bit ENTX2RXCOUNT.
	USBPHY_DEBUG_CLR_ENTX2RXCOUNT = 0x1000
	// Position of RSVD1 field.
	USBPHY_DEBUG_CLR_RSVD1_Pos = 0xd
	// Bit mask of RSVD1 field.
	USBPHY_DEBUG_CLR_RSVD1_Msk = 0xe000
	// Position of SQUELCHRESETCOUNT field.
	USBPHY_DEBUG_CLR_SQUELCHRESETCOUNT_Pos = 0x10
	// Bit mask of SQUELCHRESETCOUNT field.
	USBPHY_DEBUG_CLR_SQUELCHRESETCOUNT_Msk = 0x1f0000
	// Position of RSVD2 field.
	USBPHY_DEBUG_CLR_RSVD2_Pos = 0x15
	// Bit mask of RSVD2 field.
	USBPHY_DEBUG_CLR_RSVD2_Msk = 0xe00000
	// Position of ENSQUELCHRESET field.
	USBPHY_DEBUG_CLR_ENSQUELCHRESET_Pos = 0x18
	// Bit mask of ENSQUELCHRESET field.
	USBPHY_DEBUG_CLR_ENSQUELCHRESET_Msk = 0x1000000
	// Bit ENSQUELCHRESET.
	USBPHY_DEBUG_CLR_ENSQUELCHRESET = 0x1000000
	// Position of SQUELCHRESETLENGTH field.
	USBPHY_DEBUG_CLR_SQUELCHRESETLENGTH_Pos = 0x19
	// Bit mask of SQUELCHRESETLENGTH field.
	USBPHY_DEBUG_CLR_SQUELCHRESETLENGTH_Msk = 0x1e000000
	// Position of HOST_RESUME_DEBUG field.
	USBPHY_DEBUG_CLR_HOST_RESUME_DEBUG_Pos = 0x1d
	// Bit mask of HOST_RESUME_DEBUG field.
	USBPHY_DEBUG_CLR_HOST_RESUME_DEBUG_Msk = 0x20000000
	// Bit HOST_RESUME_DEBUG.
	USBPHY_DEBUG_CLR_HOST_RESUME_DEBUG = 0x20000000
	// Position of CLKGATE field.
	USBPHY_DEBUG_CLR_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	USBPHY_DEBUG_CLR_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	USBPHY_DEBUG_CLR_CLKGATE = 0x40000000
	// Position of RSVD3 field.
	USBPHY_DEBUG_CLR_RSVD3_Pos = 0x1f
	// Bit mask of RSVD3 field.
	USBPHY_DEBUG_CLR_RSVD3_Msk = 0x80000000
	// Bit RSVD3.
	USBPHY_DEBUG_CLR_RSVD3 = 0x80000000

	// DEBUG_TOG: USB PHY Debug Register
	// Position of OTGIDPIOLOCK field.
	USBPHY_DEBUG_TOG_OTGIDPIOLOCK_Pos = 0x0
	// Bit mask of OTGIDPIOLOCK field.
	USBPHY_DEBUG_TOG_OTGIDPIOLOCK_Msk = 0x1
	// Bit OTGIDPIOLOCK.
	USBPHY_DEBUG_TOG_OTGIDPIOLOCK = 0x1
	// Position of DEBUG_INTERFACE_HOLD field.
	USBPHY_DEBUG_TOG_DEBUG_INTERFACE_HOLD_Pos = 0x1
	// Bit mask of DEBUG_INTERFACE_HOLD field.
	USBPHY_DEBUG_TOG_DEBUG_INTERFACE_HOLD_Msk = 0x2
	// Bit DEBUG_INTERFACE_HOLD.
	USBPHY_DEBUG_TOG_DEBUG_INTERFACE_HOLD = 0x2
	// Position of HSTPULLDOWN field.
	USBPHY_DEBUG_TOG_HSTPULLDOWN_Pos = 0x2
	// Bit mask of HSTPULLDOWN field.
	USBPHY_DEBUG_TOG_HSTPULLDOWN_Msk = 0xc
	// Position of ENHSTPULLDOWN field.
	USBPHY_DEBUG_TOG_ENHSTPULLDOWN_Pos = 0x4
	// Bit mask of ENHSTPULLDOWN field.
	USBPHY_DEBUG_TOG_ENHSTPULLDOWN_Msk = 0x30
	// Position of RSVD0 field.
	USBPHY_DEBUG_TOG_RSVD0_Pos = 0x6
	// Bit mask of RSVD0 field.
	USBPHY_DEBUG_TOG_RSVD0_Msk = 0xc0
	// Position of TX2RXCOUNT field.
	USBPHY_DEBUG_TOG_TX2RXCOUNT_Pos = 0x8
	// Bit mask of TX2RXCOUNT field.
	USBPHY_DEBUG_TOG_TX2RXCOUNT_Msk = 0xf00
	// Position of ENTX2RXCOUNT field.
	USBPHY_DEBUG_TOG_ENTX2RXCOUNT_Pos = 0xc
	// Bit mask of ENTX2RXCOUNT field.
	USBPHY_DEBUG_TOG_ENTX2RXCOUNT_Msk = 0x1000
	// Bit ENTX2RXCOUNT.
	USBPHY_DEBUG_TOG_ENTX2RXCOUNT = 0x1000
	// Position of RSVD1 field.
	USBPHY_DEBUG_TOG_RSVD1_Pos = 0xd
	// Bit mask of RSVD1 field.
	USBPHY_DEBUG_TOG_RSVD1_Msk = 0xe000
	// Position of SQUELCHRESETCOUNT field.
	USBPHY_DEBUG_TOG_SQUELCHRESETCOUNT_Pos = 0x10
	// Bit mask of SQUELCHRESETCOUNT field.
	USBPHY_DEBUG_TOG_SQUELCHRESETCOUNT_Msk = 0x1f0000
	// Position of RSVD2 field.
	USBPHY_DEBUG_TOG_RSVD2_Pos = 0x15
	// Bit mask of RSVD2 field.
	USBPHY_DEBUG_TOG_RSVD2_Msk = 0xe00000
	// Position of ENSQUELCHRESET field.
	USBPHY_DEBUG_TOG_ENSQUELCHRESET_Pos = 0x18
	// Bit mask of ENSQUELCHRESET field.
	USBPHY_DEBUG_TOG_ENSQUELCHRESET_Msk = 0x1000000
	// Bit ENSQUELCHRESET.
	USBPHY_DEBUG_TOG_ENSQUELCHRESET = 0x1000000
	// Position of SQUELCHRESETLENGTH field.
	USBPHY_DEBUG_TOG_SQUELCHRESETLENGTH_Pos = 0x19
	// Bit mask of SQUELCHRESETLENGTH field.
	USBPHY_DEBUG_TOG_SQUELCHRESETLENGTH_Msk = 0x1e000000
	// Position of HOST_RESUME_DEBUG field.
	USBPHY_DEBUG_TOG_HOST_RESUME_DEBUG_Pos = 0x1d
	// Bit mask of HOST_RESUME_DEBUG field.
	USBPHY_DEBUG_TOG_HOST_RESUME_DEBUG_Msk = 0x20000000
	// Bit HOST_RESUME_DEBUG.
	USBPHY_DEBUG_TOG_HOST_RESUME_DEBUG = 0x20000000
	// Position of CLKGATE field.
	USBPHY_DEBUG_TOG_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	USBPHY_DEBUG_TOG_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	USBPHY_DEBUG_TOG_CLKGATE = 0x40000000
	// Position of RSVD3 field.
	USBPHY_DEBUG_TOG_RSVD3_Pos = 0x1f
	// Bit mask of RSVD3 field.
	USBPHY_DEBUG_TOG_RSVD3_Msk = 0x80000000
	// Bit RSVD3.
	USBPHY_DEBUG_TOG_RSVD3 = 0x80000000

	// DEBUG0_STATUS: UTMI Debug Status Register 0
	// Position of LOOP_BACK_FAIL_COUNT field.
	USBPHY_DEBUG0_STATUS_LOOP_BACK_FAIL_COUNT_Pos = 0x0
	// Bit mask of LOOP_BACK_FAIL_COUNT field.
	USBPHY_DEBUG0_STATUS_LOOP_BACK_FAIL_COUNT_Msk = 0xffff
	// Position of UTMI_RXERROR_FAIL_COUNT field.
	USBPHY_DEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT_Pos = 0x10
	// Bit mask of UTMI_RXERROR_FAIL_COUNT field.
	USBPHY_DEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT_Msk = 0x3ff0000
	// Position of SQUELCH_COUNT field.
	USBPHY_DEBUG0_STATUS_SQUELCH_COUNT_Pos = 0x1a
	// Bit mask of SQUELCH_COUNT field.
	USBPHY_DEBUG0_STATUS_SQUELCH_COUNT_Msk = 0xfc000000

	// DEBUG1: UTMI Debug Status Register 1
	// Position of RSVD0 field.
	USBPHY_DEBUG1_RSVD0_Pos = 0x0
	// Bit mask of RSVD0 field.
	USBPHY_DEBUG1_RSVD0_Msk = 0x1fff
	// Position of ENTAILADJVD field.
	USBPHY_DEBUG1_ENTAILADJVD_Pos = 0xd
	// Bit mask of ENTAILADJVD field.
	USBPHY_DEBUG1_ENTAILADJVD_Msk = 0x6000
	// Position of RSVD1 field.
	USBPHY_DEBUG1_RSVD1_Pos = 0xf
	// Bit mask of RSVD1 field.
	USBPHY_DEBUG1_RSVD1_Msk = 0xffff8000

	// DEBUG1_SET: UTMI Debug Status Register 1
	// Position of RSVD0 field.
	USBPHY_DEBUG1_SET_RSVD0_Pos = 0x0
	// Bit mask of RSVD0 field.
	USBPHY_DEBUG1_SET_RSVD0_Msk = 0x1fff
	// Position of ENTAILADJVD field.
	USBPHY_DEBUG1_SET_ENTAILADJVD_Pos = 0xd
	// Bit mask of ENTAILADJVD field.
	USBPHY_DEBUG1_SET_ENTAILADJVD_Msk = 0x6000
	// Position of RSVD1 field.
	USBPHY_DEBUG1_SET_RSVD1_Pos = 0xf
	// Bit mask of RSVD1 field.
	USBPHY_DEBUG1_SET_RSVD1_Msk = 0xffff8000

	// DEBUG1_CLR: UTMI Debug Status Register 1
	// Position of RSVD0 field.
	USBPHY_DEBUG1_CLR_RSVD0_Pos = 0x0
	// Bit mask of RSVD0 field.
	USBPHY_DEBUG1_CLR_RSVD0_Msk = 0x1fff
	// Position of ENTAILADJVD field.
	USBPHY_DEBUG1_CLR_ENTAILADJVD_Pos = 0xd
	// Bit mask of ENTAILADJVD field.
	USBPHY_DEBUG1_CLR_ENTAILADJVD_Msk = 0x6000
	// Position of RSVD1 field.
	USBPHY_DEBUG1_CLR_RSVD1_Pos = 0xf
	// Bit mask of RSVD1 field.
	USBPHY_DEBUG1_CLR_RSVD1_Msk = 0xffff8000

	// DEBUG1_TOG: UTMI Debug Status Register 1
	// Position of RSVD0 field.
	USBPHY_DEBUG1_TOG_RSVD0_Pos = 0x0
	// Bit mask of RSVD0 field.
	USBPHY_DEBUG1_TOG_RSVD0_Msk = 0x1fff
	// Position of ENTAILADJVD field.
	USBPHY_DEBUG1_TOG_ENTAILADJVD_Pos = 0xd
	// Bit mask of ENTAILADJVD field.
	USBPHY_DEBUG1_TOG_ENTAILADJVD_Msk = 0x6000
	// Position of RSVD1 field.
	USBPHY_DEBUG1_TOG_RSVD1_Pos = 0xf
	// Bit mask of RSVD1 field.
	USBPHY_DEBUG1_TOG_RSVD1_Msk = 0xffff8000

	// VERSION: UTMI RTL Version
	// Position of STEP field.
	USBPHY_VERSION_STEP_Pos = 0x0
	// Bit mask of STEP field.
	USBPHY_VERSION_STEP_Msk = 0xffff
	// Position of MINOR field.
	USBPHY_VERSION_MINOR_Pos = 0x10
	// Bit mask of MINOR field.
	USBPHY_VERSION_MINOR_Msk = 0xff0000
	// Position of MAJOR field.
	USBPHY_VERSION_MAJOR_Pos = 0x18
	// Bit mask of MAJOR field.
	USBPHY_VERSION_MAJOR_Msk = 0xff000000
)

// Constants for CSU: CSU registers
const (
	// CSL0: Config security level register
	// Position of SUR_S2 field.
	CSU_CSL_SUR_S2_Pos = 0x0
	// Bit mask of SUR_S2 field.
	CSU_CSL_SUR_S2_Msk = 0x1
	// Bit SUR_S2.
	CSU_CSL_SUR_S2 = 0x1
	// The secure user read access is disabled for the second slave.
	CSU_CSL_SUR_S2_SUR_S2_0 = 0x0
	// The secure user read access is enabled for the second slave.
	CSU_CSL_SUR_S2_SUR_S2_1 = 0x1
	// Position of SSR_S2 field.
	CSU_CSL_SSR_S2_Pos = 0x1
	// Bit mask of SSR_S2 field.
	CSU_CSL_SSR_S2_Msk = 0x2
	// Bit SSR_S2.
	CSU_CSL_SSR_S2 = 0x2
	// The secure supervisor read access is disabled for the second slave.
	CSU_CSL_SSR_S2_SSR_S2_0 = 0x0
	// The secure supervisor read access is enabled for the second slave.
	CSU_CSL_SSR_S2_SSR_S2_1 = 0x1
	// Position of NUR_S2 field.
	CSU_CSL_NUR_S2_Pos = 0x2
	// Bit mask of NUR_S2 field.
	CSU_CSL_NUR_S2_Msk = 0x4
	// Bit NUR_S2.
	CSU_CSL_NUR_S2 = 0x4
	// The non-secure user read access is disabled for the second slave.
	CSU_CSL_NUR_S2_NUR_S2_0 = 0x0
	// The non-secure user read access is enabled for the second slave.
	CSU_CSL_NUR_S2_NUR_S2_1 = 0x1
	// Position of NSR_S2 field.
	CSU_CSL_NSR_S2_Pos = 0x3
	// Bit mask of NSR_S2 field.
	CSU_CSL_NSR_S2_Msk = 0x8
	// Bit NSR_S2.
	CSU_CSL_NSR_S2 = 0x8
	// The non-secure supervisor read access is disabled for the second slave.
	CSU_CSL_NSR_S2_NSR_S2_0 = 0x0
	// The non-secure supervisor read access is enabled for the second slave.
	CSU_CSL_NSR_S2_NSR_S2_1 = 0x1
	// Position of SUW_S2 field.
	CSU_CSL_SUW_S2_Pos = 0x4
	// Bit mask of SUW_S2 field.
	CSU_CSL_SUW_S2_Msk = 0x10
	// Bit SUW_S2.
	CSU_CSL_SUW_S2 = 0x10
	// The secure user write access is disabled for the second slave.
	CSU_CSL_SUW_S2_SUW_S2_0 = 0x0
	// The secure user write access is enabled for the second slave.
	CSU_CSL_SUW_S2_SUW_S2_1 = 0x1
	// Position of SSW_S2 field.
	CSU_CSL_SSW_S2_Pos = 0x5
	// Bit mask of SSW_S2 field.
	CSU_CSL_SSW_S2_Msk = 0x20
	// Bit SSW_S2.
	CSU_CSL_SSW_S2 = 0x20
	// The secure supervisor write access is disabled for the second slave.
	CSU_CSL_SSW_S2_SSW_S2_0 = 0x0
	// The secure supervisor write access is enabled for the second slave.
	CSU_CSL_SSW_S2_SSW_S2_1 = 0x1
	// Position of NUW_S2 field.
	CSU_CSL_NUW_S2_Pos = 0x6
	// Bit mask of NUW_S2 field.
	CSU_CSL_NUW_S2_Msk = 0x40
	// Bit NUW_S2.
	CSU_CSL_NUW_S2 = 0x40
	// The non-secure user write access is disabled for the second slave.
	CSU_CSL_NUW_S2_NUW_S2_0 = 0x0
	// The non-secure user write access is enabled for the second slave.
	CSU_CSL_NUW_S2_NUW_S2_1 = 0x1
	// Position of NSW_S2 field.
	CSU_CSL_NSW_S2_Pos = 0x7
	// Bit mask of NSW_S2 field.
	CSU_CSL_NSW_S2_Msk = 0x80
	// Bit NSW_S2.
	CSU_CSL_NSW_S2 = 0x80
	// The non-secure supervisor write access is disabled for the second slave.
	CSU_CSL_NSW_S2_NSW_S2_0 = 0x0
	// The non-secure supervisor write access is enabled for the second slave.
	CSU_CSL_NSW_S2_NSW_S2_1 = 0x1
	// Position of LOCK_S2 field.
	CSU_CSL_LOCK_S2_Pos = 0x8
	// Bit mask of LOCK_S2 field.
	CSU_CSL_LOCK_S2_Msk = 0x100
	// Bit LOCK_S2.
	CSU_CSL_LOCK_S2 = 0x100
	// Not locked. Bits 7-0 can be written by the software.
	CSU_CSL_LOCK_S2_LOCK_S2_0 = 0x0
	// Bits 7-0 are locked and cannot be written by the software
	CSU_CSL_LOCK_S2_LOCK_S2_1 = 0x1
	// Position of SUR_S1 field.
	CSU_CSL_SUR_S1_Pos = 0x10
	// Bit mask of SUR_S1 field.
	CSU_CSL_SUR_S1_Msk = 0x10000
	// Bit SUR_S1.
	CSU_CSL_SUR_S1 = 0x10000
	// The secure user read access is disabled for the first slave.
	CSU_CSL_SUR_S1_SUR_S1_0 = 0x0
	// The secure user read access is enabled for the first slave.
	CSU_CSL_SUR_S1_SUR_S1_1 = 0x1
	// Position of SSR_S1 field.
	CSU_CSL_SSR_S1_Pos = 0x11
	// Bit mask of SSR_S1 field.
	CSU_CSL_SSR_S1_Msk = 0x20000
	// Bit SSR_S1.
	CSU_CSL_SSR_S1 = 0x20000
	// The secure supervisor read access is disabled for the first slave.
	CSU_CSL_SSR_S1_SSR_S1_0 = 0x0
	// The secure supervisor read access is enabled for the first slave.
	CSU_CSL_SSR_S1_SSR_S1_1 = 0x1
	// Position of NUR_S1 field.
	CSU_CSL_NUR_S1_Pos = 0x12
	// Bit mask of NUR_S1 field.
	CSU_CSL_NUR_S1_Msk = 0x40000
	// Bit NUR_S1.
	CSU_CSL_NUR_S1 = 0x40000
	// The non-secure user read access is disabled for the first slave.
	CSU_CSL_NUR_S1_NUR_S1_0 = 0x0
	// The non-secure user read access is enabled for the first slave.
	CSU_CSL_NUR_S1_NUR_S1_1 = 0x1
	// Position of NSR_S1 field.
	CSU_CSL_NSR_S1_Pos = 0x13
	// Bit mask of NSR_S1 field.
	CSU_CSL_NSR_S1_Msk = 0x80000
	// Bit NSR_S1.
	CSU_CSL_NSR_S1 = 0x80000
	// The non-secure supervisor read access is disabled for the first slave.
	CSU_CSL_NSR_S1_NSR_S1_0 = 0x0
	// The non-secure supervisor read access is enabled for the first slave.
	CSU_CSL_NSR_S1_NSR_S1_1 = 0x1
	// Position of SUW_S1 field.
	CSU_CSL_SUW_S1_Pos = 0x14
	// Bit mask of SUW_S1 field.
	CSU_CSL_SUW_S1_Msk = 0x100000
	// Bit SUW_S1.
	CSU_CSL_SUW_S1 = 0x100000
	// The secure user write access is disabled for the first slave.
	CSU_CSL_SUW_S1_SUW_S1_0 = 0x0
	// The secure user write access is enabled for the first slave.
	CSU_CSL_SUW_S1_SUW_S1_1 = 0x1
	// Position of SSW_S1 field.
	CSU_CSL_SSW_S1_Pos = 0x15
	// Bit mask of SSW_S1 field.
	CSU_CSL_SSW_S1_Msk = 0x200000
	// Bit SSW_S1.
	CSU_CSL_SSW_S1 = 0x200000
	// The secure supervisor write access is disabled for the first slave.
	CSU_CSL_SSW_S1_SSW_S1_0 = 0x0
	// The secure supervisor write access is enabled for the first slave.
	CSU_CSL_SSW_S1_SSW_S1_1 = 0x1
	// Position of NUW_S1 field.
	CSU_CSL_NUW_S1_Pos = 0x16
	// Bit mask of NUW_S1 field.
	CSU_CSL_NUW_S1_Msk = 0x400000
	// Bit NUW_S1.
	CSU_CSL_NUW_S1 = 0x400000
	// The non-secure user write access is disabled for the first slave.
	CSU_CSL_NUW_S1_NUW_S1_0 = 0x0
	// The non-secure user write access is enabled for the first slave.
	CSU_CSL_NUW_S1_NUW_S1_1 = 0x1
	// Position of NSW_S1 field.
	CSU_CSL_NSW_S1_Pos = 0x17
	// Bit mask of NSW_S1 field.
	CSU_CSL_NSW_S1_Msk = 0x800000
	// Bit NSW_S1.
	CSU_CSL_NSW_S1 = 0x800000
	// The non-secure supervisor write access is disabled for the first slave.
	CSU_CSL_NSW_S1_NSW_S1_0 = 0x0
	// The non-secure supervisor write access is enabled for the first slave
	CSU_CSL_NSW_S1_NSW_S1_1 = 0x1
	// Position of LOCK_S1 field.
	CSU_CSL_LOCK_S1_Pos = 0x18
	// Bit mask of LOCK_S1 field.
	CSU_CSL_LOCK_S1_Msk = 0x1000000
	// Bit LOCK_S1.
	CSU_CSL_LOCK_S1 = 0x1000000
	// Not locked. The bits 16-23 can be written by the software.
	CSU_CSL_LOCK_S1_LOCK_S1_0 = 0x0
	// The bits 16-23 are locked and can't be written by the software.
	CSU_CSL_LOCK_S1_LOCK_S1_1 = 0x1

	// HP0: HP0 register
	// Position of HP_DMA field.
	CSU_HP0_HP_DMA_Pos = 0x2
	// Bit mask of HP_DMA field.
	CSU_HP0_HP_DMA_Msk = 0x4
	// Bit HP_DMA.
	CSU_HP0_HP_DMA = 0x4
	// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_DMA_HP_DMA_0 = 0x0
	// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_DMA_HP_DMA_1 = 0x1
	// Position of L_DMA field.
	CSU_HP0_L_DMA_Pos = 0x3
	// Bit mask of L_DMA field.
	CSU_HP0_L_DMA_Msk = 0x8
	// Bit L_DMA.
	CSU_HP0_L_DMA = 0x8
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HP0_L_DMA_L_DMA_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HP0_L_DMA_L_DMA_1 = 0x1
	// Position of HP_LCDIF field.
	CSU_HP0_HP_LCDIF_Pos = 0x4
	// Bit mask of HP_LCDIF field.
	CSU_HP0_HP_LCDIF_Msk = 0x10
	// Bit HP_LCDIF.
	CSU_HP0_HP_LCDIF = 0x10
	// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_LCDIF_HP_LCDIF_0 = 0x0
	// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_LCDIF_HP_LCDIF_1 = 0x1
	// Position of L_LCDIF field.
	CSU_HP0_L_LCDIF_Pos = 0x5
	// Bit mask of L_LCDIF field.
	CSU_HP0_L_LCDIF_Msk = 0x20
	// Bit L_LCDIF.
	CSU_HP0_L_LCDIF = 0x20
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HP0_L_LCDIF_L_LCDIF_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HP0_L_LCDIF_L_LCDIF_1 = 0x1
	// Position of HP_CSI field.
	CSU_HP0_HP_CSI_Pos = 0x6
	// Bit mask of HP_CSI field.
	CSU_HP0_HP_CSI_Msk = 0x40
	// Bit HP_CSI.
	CSU_HP0_HP_CSI = 0x40
	// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_CSI_HP_CSI_0 = 0x0
	// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_CSI_HP_CSI_1 = 0x1
	// Position of L_CSI field.
	CSU_HP0_L_CSI_Pos = 0x7
	// Bit mask of L_CSI field.
	CSU_HP0_L_CSI_Msk = 0x80
	// Bit L_CSI.
	CSU_HP0_L_CSI = 0x80
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HP0_L_CSI_L_CSI_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HP0_L_CSI_L_CSI_1 = 0x1
	// Position of HP_PXP field.
	CSU_HP0_HP_PXP_Pos = 0x8
	// Bit mask of HP_PXP field.
	CSU_HP0_HP_PXP_Msk = 0x100
	// Bit HP_PXP.
	CSU_HP0_HP_PXP = 0x100
	// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_PXP_HP_PXP_0 = 0x0
	// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_PXP_HP_PXP_1 = 0x1
	// Position of L_PXP field.
	CSU_HP0_L_PXP_Pos = 0x9
	// Bit mask of L_PXP field.
	CSU_HP0_L_PXP_Msk = 0x200
	// Bit L_PXP.
	CSU_HP0_L_PXP = 0x200
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HP0_L_PXP_L_PXP_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HP0_L_PXP_L_PXP_1 = 0x1
	// Position of HP_DCP field.
	CSU_HP0_HP_DCP_Pos = 0xa
	// Bit mask of HP_DCP field.
	CSU_HP0_HP_DCP_Msk = 0x400
	// Bit HP_DCP.
	CSU_HP0_HP_DCP = 0x400
	// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_DCP_HP_DCP_0 = 0x0
	// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_DCP_HP_DCP_1 = 0x1
	// Position of L_DCP field.
	CSU_HP0_L_DCP_Pos = 0xb
	// Bit mask of L_DCP field.
	CSU_HP0_L_DCP_Msk = 0x800
	// Bit L_DCP.
	CSU_HP0_L_DCP = 0x800
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HP0_L_DCP_L_DCP_0 = 0x0
	// Lock-the adjacent (next lower) bit cannot be written by the software.
	CSU_HP0_L_DCP_L_DCP_1 = 0x1
	// Position of HP_ENET field.
	CSU_HP0_HP_ENET_Pos = 0xe
	// Bit mask of HP_ENET field.
	CSU_HP0_HP_ENET_Msk = 0x4000
	// Bit HP_ENET.
	CSU_HP0_HP_ENET = 0x4000
	// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_ENET_HP_ENET_0 = 0x0
	// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_ENET_HP_ENET_1 = 0x1
	// Position of L_ENET field.
	CSU_HP0_L_ENET_Pos = 0xf
	// Bit mask of L_ENET field.
	CSU_HP0_L_ENET_Msk = 0x8000
	// Bit L_ENET.
	CSU_HP0_L_ENET = 0x8000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HP0_L_ENET_L_ENET_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HP0_L_ENET_L_ENET_1 = 0x1
	// Position of HP_USDHC1 field.
	CSU_HP0_HP_USDHC1_Pos = 0x10
	// Bit mask of HP_USDHC1 field.
	CSU_HP0_HP_USDHC1_Msk = 0x10000
	// Bit HP_USDHC1.
	CSU_HP0_HP_USDHC1 = 0x10000
	// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_USDHC1_HP_USDHC1_0 = 0x0
	// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_USDHC1_HP_USDHC1_1 = 0x1
	// Position of L_USDHC1 field.
	CSU_HP0_L_USDHC1_Pos = 0x11
	// Bit mask of L_USDHC1 field.
	CSU_HP0_L_USDHC1_Msk = 0x20000
	// Bit L_USDHC1.
	CSU_HP0_L_USDHC1 = 0x20000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HP0_L_USDHC1_L_USDHC1_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HP0_L_USDHC1_L_USDHC1_1 = 0x1
	// Position of HP_USDHC2 field.
	CSU_HP0_HP_USDHC2_Pos = 0x12
	// Bit mask of HP_USDHC2 field.
	CSU_HP0_HP_USDHC2_Msk = 0x40000
	// Bit HP_USDHC2.
	CSU_HP0_HP_USDHC2 = 0x40000
	// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_USDHC2_HP_USDHC2_0 = 0x0
	// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_USDHC2_HP_USDHC2_1 = 0x1
	// Position of L_USDHC2 field.
	CSU_HP0_L_USDHC2_Pos = 0x13
	// Bit mask of L_USDHC2 field.
	CSU_HP0_L_USDHC2_Msk = 0x80000
	// Bit L_USDHC2.
	CSU_HP0_L_USDHC2 = 0x80000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HP0_L_USDHC2_L_USDHC2_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HP0_L_USDHC2_L_USDHC2_1 = 0x1
	// Position of HP_TPSMP field.
	CSU_HP0_HP_TPSMP_Pos = 0x14
	// Bit mask of HP_TPSMP field.
	CSU_HP0_HP_TPSMP_Msk = 0x100000
	// Bit HP_TPSMP.
	CSU_HP0_HP_TPSMP = 0x100000
	// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_TPSMP_HP_TPSMP_0 = 0x0
	// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_TPSMP_HP_TPSMP_1 = 0x1
	// Position of L_TPSMP field.
	CSU_HP0_L_TPSMP_Pos = 0x15
	// Bit mask of L_TPSMP field.
	CSU_HP0_L_TPSMP_Msk = 0x200000
	// Bit L_TPSMP.
	CSU_HP0_L_TPSMP = 0x200000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HP0_L_TPSMP_L_TPSMP_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HP0_L_TPSMP_L_TPSMP_1 = 0x1
	// Position of HP_USB field.
	CSU_HP0_HP_USB_Pos = 0x16
	// Bit mask of HP_USB field.
	CSU_HP0_HP_USB_Msk = 0x400000
	// Bit HP_USB.
	CSU_HP0_HP_USB = 0x400000
	// The hprot1 input signal value is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_USB_HP_USB_0 = 0x0
	// The HP register bit is routed to the csu_hprot1 output for the corresponding master.
	CSU_HP0_HP_USB_HP_USB_1 = 0x1
	// Position of L_USB field.
	CSU_HP0_L_USB_Pos = 0x17
	// Bit mask of L_USB field.
	CSU_HP0_L_USB_Msk = 0x800000
	// Bit L_USB.
	CSU_HP0_L_USB = 0x800000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HP0_L_USB_L_USB_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HP0_L_USB_L_USB_1 = 0x1

	// SA: Secure access register
	// Position of NSA_DMA field.
	CSU_SA_NSA_DMA_Pos = 0x2
	// Bit mask of NSA_DMA field.
	CSU_SA_NSA_DMA_Msk = 0x4
	// Bit NSA_DMA.
	CSU_SA_NSA_DMA = 0x4
	// Secure access for the corresponding type-1 master
	CSU_SA_NSA_DMA_NSA_DMA_0 = 0x0
	// Non-secure access for the corresponding type-1 master
	CSU_SA_NSA_DMA_NSA_DMA_1 = 0x1
	// Position of L_DMA field.
	CSU_SA_L_DMA_Pos = 0x3
	// Bit mask of L_DMA field.
	CSU_SA_L_DMA_Msk = 0x8
	// Bit L_DMA.
	CSU_SA_L_DMA = 0x8
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_SA_L_DMA_L_DMA_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_SA_L_DMA_L_DMA_1 = 0x1
	// Position of NSA_LCDIF field.
	CSU_SA_NSA_LCDIF_Pos = 0x4
	// Bit mask of NSA_LCDIF field.
	CSU_SA_NSA_LCDIF_Msk = 0x10
	// Bit NSA_LCDIF.
	CSU_SA_NSA_LCDIF = 0x10
	// Secure access for the corresponding type-1 master
	CSU_SA_NSA_LCDIF_NSA_LCDIF_0 = 0x0
	// Non-secure access for the corresponding type-1 master
	CSU_SA_NSA_LCDIF_NSA_LCDIF_1 = 0x1
	// Position of L_LCDIF field.
	CSU_SA_L_LCDIF_Pos = 0x5
	// Bit mask of L_LCDIF field.
	CSU_SA_L_LCDIF_Msk = 0x20
	// Bit L_LCDIF.
	CSU_SA_L_LCDIF = 0x20
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_SA_L_LCDIF_L_LCDIF_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_SA_L_LCDIF_L_LCDIF_1 = 0x1
	// Position of NSA_CSI field.
	CSU_SA_NSA_CSI_Pos = 0x6
	// Bit mask of NSA_CSI field.
	CSU_SA_NSA_CSI_Msk = 0x40
	// Bit NSA_CSI.
	CSU_SA_NSA_CSI = 0x40
	// Secure access for the corresponding type-1 master
	CSU_SA_NSA_CSI_NSA_CSI_0 = 0x0
	// Non-secure access for the corresponding type-1 master
	CSU_SA_NSA_CSI_NSA_CSI_1 = 0x1
	// Position of L_CSI field.
	CSU_SA_L_CSI_Pos = 0x7
	// Bit mask of L_CSI field.
	CSU_SA_L_CSI_Msk = 0x80
	// Bit L_CSI.
	CSU_SA_L_CSI = 0x80
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_SA_L_CSI_L_CSI_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_SA_L_CSI_L_CSI_1 = 0x1
	// Position of NSA_PXP field.
	CSU_SA_NSA_PXP_Pos = 0x8
	// Bit mask of NSA_PXP field.
	CSU_SA_NSA_PXP_Msk = 0x100
	// Bit NSA_PXP.
	CSU_SA_NSA_PXP = 0x100
	// Secure access for the corresponding type-1 master
	CSU_SA_NSA_PXP_NSA_PXP_0 = 0x0
	// Non-secure access for the corresponding type-1 master
	CSU_SA_NSA_PXP_NSA_PXP_1 = 0x1
	// Position of L_PXP field.
	CSU_SA_L_PXP_Pos = 0x9
	// Bit mask of L_PXP field.
	CSU_SA_L_PXP_Msk = 0x200
	// Bit L_PXP.
	CSU_SA_L_PXP = 0x200
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_SA_L_PXP_L_PXP_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_SA_L_PXP_L_PXP_1 = 0x1
	// Position of NSA_DCP field.
	CSU_SA_NSA_DCP_Pos = 0xa
	// Bit mask of NSA_DCP field.
	CSU_SA_NSA_DCP_Msk = 0x400
	// Bit NSA_DCP.
	CSU_SA_NSA_DCP = 0x400
	// Secure access for the corresponding type-1 master
	CSU_SA_NSA_DCP_NSA_DCP_0 = 0x0
	// Non-secure access for the corresponding type-1 master
	CSU_SA_NSA_DCP_NSA_DCP_1 = 0x1
	// Position of L_DCP field.
	CSU_SA_L_DCP_Pos = 0xb
	// Bit mask of L_DCP field.
	CSU_SA_L_DCP_Msk = 0x800
	// Bit L_DCP.
	CSU_SA_L_DCP = 0x800
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_SA_L_DCP_L_DCP_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_SA_L_DCP_L_DCP_1 = 0x1
	// Position of NSA_ENET field.
	CSU_SA_NSA_ENET_Pos = 0xe
	// Bit mask of NSA_ENET field.
	CSU_SA_NSA_ENET_Msk = 0x4000
	// Bit NSA_ENET.
	CSU_SA_NSA_ENET = 0x4000
	// Secure access for the corresponding type-1 master
	CSU_SA_NSA_ENET_NSA_ENET_0 = 0x0
	// Non-secure access for the corresponding type-1 master
	CSU_SA_NSA_ENET_NSA_ENET_1 = 0x1
	// Position of L_ENET field.
	CSU_SA_L_ENET_Pos = 0xf
	// Bit mask of L_ENET field.
	CSU_SA_L_ENET_Msk = 0x8000
	// Bit L_ENET.
	CSU_SA_L_ENET = 0x8000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_SA_L_ENET_L_ENET_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_SA_L_ENET_L_ENET_1 = 0x1
	// Position of NSA_USDHC1 field.
	CSU_SA_NSA_USDHC1_Pos = 0x10
	// Bit mask of NSA_USDHC1 field.
	CSU_SA_NSA_USDHC1_Msk = 0x10000
	// Bit NSA_USDHC1.
	CSU_SA_NSA_USDHC1 = 0x10000
	// Secure access for the corresponding type-1 master
	CSU_SA_NSA_USDHC1_NSA_USDHC1_0 = 0x0
	// Non-secure access for the corresponding type-1 master
	CSU_SA_NSA_USDHC1_NSA_USDHC1_1 = 0x1
	// Position of L_USDHC1 field.
	CSU_SA_L_USDHC1_Pos = 0x11
	// Bit mask of L_USDHC1 field.
	CSU_SA_L_USDHC1_Msk = 0x20000
	// Bit L_USDHC1.
	CSU_SA_L_USDHC1 = 0x20000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_SA_L_USDHC1_L_USDHC1_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_SA_L_USDHC1_L_USDHC1_1 = 0x1
	// Position of NSA_USDHC2 field.
	CSU_SA_NSA_USDHC2_Pos = 0x12
	// Bit mask of NSA_USDHC2 field.
	CSU_SA_NSA_USDHC2_Msk = 0x40000
	// Bit NSA_USDHC2.
	CSU_SA_NSA_USDHC2 = 0x40000
	// Secure access for the corresponding type-1 master
	CSU_SA_NSA_USDHC2_NSA_USDHC2_0 = 0x0
	// Non-secure access for the corresponding type-1 master
	CSU_SA_NSA_USDHC2_NSA_USDHC2_1 = 0x1
	// Position of L_USDHC2 field.
	CSU_SA_L_USDHC2_Pos = 0x13
	// Bit mask of L_USDHC2 field.
	CSU_SA_L_USDHC2_Msk = 0x80000
	// Bit L_USDHC2.
	CSU_SA_L_USDHC2 = 0x80000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_SA_L_USDHC2_L_USDHC2_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_SA_L_USDHC2_L_USDHC2_1 = 0x1
	// Position of NSA_TPSMP field.
	CSU_SA_NSA_TPSMP_Pos = 0x14
	// Bit mask of NSA_TPSMP field.
	CSU_SA_NSA_TPSMP_Msk = 0x100000
	// Bit NSA_TPSMP.
	CSU_SA_NSA_TPSMP = 0x100000
	// Secure access for the corresponding type-1 master
	CSU_SA_NSA_TPSMP_NSA_TPSMP_0 = 0x0
	// Non-secure access for the corresponding type-1 master
	CSU_SA_NSA_TPSMP_NSA_TPSMP_1 = 0x1
	// Position of L_TPSMP field.
	CSU_SA_L_TPSMP_Pos = 0x15
	// Bit mask of L_TPSMP field.
	CSU_SA_L_TPSMP_Msk = 0x200000
	// Bit L_TPSMP.
	CSU_SA_L_TPSMP = 0x200000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_SA_L_TPSMP_L_TPSMP_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_SA_L_TPSMP_L_TPSMP_1 = 0x1
	// Position of NSA_USB field.
	CSU_SA_NSA_USB_Pos = 0x16
	// Bit mask of NSA_USB field.
	CSU_SA_NSA_USB_Msk = 0x400000
	// Bit NSA_USB.
	CSU_SA_NSA_USB = 0x400000
	// Secure access for the corresponding type-1 master
	CSU_SA_NSA_USB_NSA_USB_0 = 0x0
	// Non-secure access for the corresponding type-1 master
	CSU_SA_NSA_USB_NSA_USB_1 = 0x1
	// Position of L_USB field.
	CSU_SA_L_USB_Pos = 0x17
	// Bit mask of L_USB field.
	CSU_SA_L_USB_Msk = 0x800000
	// Bit L_USB.
	CSU_SA_L_USB = 0x800000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_SA_L_USB_L_USB_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_SA_L_USB_L_USB_1 = 0x1

	// HPCONTROL0: HPCONTROL0 register
	// Position of HPC_DMA field.
	CSU_HPCONTROL0_HPC_DMA_Pos = 0x2
	// Bit mask of HPC_DMA field.
	CSU_HPCONTROL0_HPC_DMA_Msk = 0x4
	// Bit HPC_DMA.
	CSU_HPCONTROL0_HPC_DMA = 0x4
	// User mode for the corresponding master
	CSU_HPCONTROL0_HPC_DMA_HPC_DMA_0 = 0x0
	// Supervisor mode for the corresponding master
	CSU_HPCONTROL0_HPC_DMA_HPC_DMA_1 = 0x1
	// Position of L_DMA field.
	CSU_HPCONTROL0_L_DMA_Pos = 0x3
	// Bit mask of L_DMA field.
	CSU_HPCONTROL0_L_DMA_Msk = 0x8
	// Bit L_DMA.
	CSU_HPCONTROL0_L_DMA = 0x8
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HPCONTROL0_L_DMA_L_DMA_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HPCONTROL0_L_DMA_L_DMA_1 = 0x1
	// Position of HPC_LCDIF field.
	CSU_HPCONTROL0_HPC_LCDIF_Pos = 0x4
	// Bit mask of HPC_LCDIF field.
	CSU_HPCONTROL0_HPC_LCDIF_Msk = 0x10
	// Bit HPC_LCDIF.
	CSU_HPCONTROL0_HPC_LCDIF = 0x10
	// User mode for the corresponding master
	CSU_HPCONTROL0_HPC_LCDIF_HPC_LCDIF_0 = 0x0
	// Supervisor mode for the corresponding master
	CSU_HPCONTROL0_HPC_LCDIF_HPC_LCDIF_1 = 0x1
	// Position of L_LCDIF field.
	CSU_HPCONTROL0_L_LCDIF_Pos = 0x5
	// Bit mask of L_LCDIF field.
	CSU_HPCONTROL0_L_LCDIF_Msk = 0x20
	// Bit L_LCDIF.
	CSU_HPCONTROL0_L_LCDIF = 0x20
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HPCONTROL0_L_LCDIF_L_LCDIF_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HPCONTROL0_L_LCDIF_L_LCDIF_1 = 0x1
	// Position of HPC_CSI field.
	CSU_HPCONTROL0_HPC_CSI_Pos = 0x6
	// Bit mask of HPC_CSI field.
	CSU_HPCONTROL0_HPC_CSI_Msk = 0x40
	// Bit HPC_CSI.
	CSU_HPCONTROL0_HPC_CSI = 0x40
	// User mode for the corresponding master
	CSU_HPCONTROL0_HPC_CSI_HPC_CSI_0 = 0x0
	// Supervisor mode for the corresponding master
	CSU_HPCONTROL0_HPC_CSI_HPC_CSI_1 = 0x1
	// Position of L_CSI field.
	CSU_HPCONTROL0_L_CSI_Pos = 0x7
	// Bit mask of L_CSI field.
	CSU_HPCONTROL0_L_CSI_Msk = 0x80
	// Bit L_CSI.
	CSU_HPCONTROL0_L_CSI = 0x80
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HPCONTROL0_L_CSI_L_CSI_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HPCONTROL0_L_CSI_L_CSI_1 = 0x1
	// Position of HPC_PXP field.
	CSU_HPCONTROL0_HPC_PXP_Pos = 0x8
	// Bit mask of HPC_PXP field.
	CSU_HPCONTROL0_HPC_PXP_Msk = 0x100
	// Bit HPC_PXP.
	CSU_HPCONTROL0_HPC_PXP = 0x100
	// User mode for the corresponding master
	CSU_HPCONTROL0_HPC_PXP_HPC_PXP_0 = 0x0
	// Supervisor mode for the corresponding master
	CSU_HPCONTROL0_HPC_PXP_HPC_PXP_1 = 0x1
	// Position of L_PXP field.
	CSU_HPCONTROL0_L_PXP_Pos = 0x9
	// Bit mask of L_PXP field.
	CSU_HPCONTROL0_L_PXP_Msk = 0x200
	// Bit L_PXP.
	CSU_HPCONTROL0_L_PXP = 0x200
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HPCONTROL0_L_PXP_L_PXP_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HPCONTROL0_L_PXP_L_PXP_1 = 0x1
	// Position of HPC_DCP field.
	CSU_HPCONTROL0_HPC_DCP_Pos = 0xa
	// Bit mask of HPC_DCP field.
	CSU_HPCONTROL0_HPC_DCP_Msk = 0x400
	// Bit HPC_DCP.
	CSU_HPCONTROL0_HPC_DCP = 0x400
	// User mode for the corresponding master
	CSU_HPCONTROL0_HPC_DCP_HPC_DCP_0 = 0x0
	// Supervisor mode for the corresponding master
	CSU_HPCONTROL0_HPC_DCP_HPC_DCP_1 = 0x1
	// Position of L_DCP field.
	CSU_HPCONTROL0_L_DCP_Pos = 0xb
	// Bit mask of L_DCP field.
	CSU_HPCONTROL0_L_DCP_Msk = 0x800
	// Bit L_DCP.
	CSU_HPCONTROL0_L_DCP = 0x800
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HPCONTROL0_L_DCP_L_DCP_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HPCONTROL0_L_DCP_L_DCP_1 = 0x1
	// Position of HPC_ENET field.
	CSU_HPCONTROL0_HPC_ENET_Pos = 0xe
	// Bit mask of HPC_ENET field.
	CSU_HPCONTROL0_HPC_ENET_Msk = 0x4000
	// Bit HPC_ENET.
	CSU_HPCONTROL0_HPC_ENET = 0x4000
	// User mode for the corresponding master
	CSU_HPCONTROL0_HPC_ENET_HPC_ENET_0 = 0x0
	// Supervisor mode for the corresponding master
	CSU_HPCONTROL0_HPC_ENET_HPC_ENET_1 = 0x1
	// Position of L_ENET field.
	CSU_HPCONTROL0_L_ENET_Pos = 0xf
	// Bit mask of L_ENET field.
	CSU_HPCONTROL0_L_ENET_Msk = 0x8000
	// Bit L_ENET.
	CSU_HPCONTROL0_L_ENET = 0x8000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HPCONTROL0_L_ENET_L_ENET_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HPCONTROL0_L_ENET_L_ENET_1 = 0x1
	// Position of HPC_USDHC1 field.
	CSU_HPCONTROL0_HPC_USDHC1_Pos = 0x10
	// Bit mask of HPC_USDHC1 field.
	CSU_HPCONTROL0_HPC_USDHC1_Msk = 0x10000
	// Bit HPC_USDHC1.
	CSU_HPCONTROL0_HPC_USDHC1 = 0x10000
	// User mode for the corresponding master
	CSU_HPCONTROL0_HPC_USDHC1_HPC_USDHC1_0 = 0x0
	// Supervisor mode for the corresponding master
	CSU_HPCONTROL0_HPC_USDHC1_HPC_USDHC1_1 = 0x1
	// Position of L_USDHC1 field.
	CSU_HPCONTROL0_L_USDHC1_Pos = 0x11
	// Bit mask of L_USDHC1 field.
	CSU_HPCONTROL0_L_USDHC1_Msk = 0x20000
	// Bit L_USDHC1.
	CSU_HPCONTROL0_L_USDHC1 = 0x20000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HPCONTROL0_L_USDHC1_L_USDHC1_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HPCONTROL0_L_USDHC1_L_USDHC1_1 = 0x1
	// Position of HPC_USDHC2 field.
	CSU_HPCONTROL0_HPC_USDHC2_Pos = 0x12
	// Bit mask of HPC_USDHC2 field.
	CSU_HPCONTROL0_HPC_USDHC2_Msk = 0x40000
	// Bit HPC_USDHC2.
	CSU_HPCONTROL0_HPC_USDHC2 = 0x40000
	// User mode for the corresponding master
	CSU_HPCONTROL0_HPC_USDHC2_HPC_USDHC2_0 = 0x0
	// Supervisor mode for the corresponding master
	CSU_HPCONTROL0_HPC_USDHC2_HPC_USDHC2_1 = 0x1
	// Position of L_USDHC2 field.
	CSU_HPCONTROL0_L_USDHC2_Pos = 0x13
	// Bit mask of L_USDHC2 field.
	CSU_HPCONTROL0_L_USDHC2_Msk = 0x80000
	// Bit L_USDHC2.
	CSU_HPCONTROL0_L_USDHC2 = 0x80000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HPCONTROL0_L_USDHC2_L_USDHC2_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HPCONTROL0_L_USDHC2_L_USDHC2_1 = 0x1
	// Position of HPC_TPSMP field.
	CSU_HPCONTROL0_HPC_TPSMP_Pos = 0x14
	// Bit mask of HPC_TPSMP field.
	CSU_HPCONTROL0_HPC_TPSMP_Msk = 0x100000
	// Bit HPC_TPSMP.
	CSU_HPCONTROL0_HPC_TPSMP = 0x100000
	// User mode for the corresponding master
	CSU_HPCONTROL0_HPC_TPSMP_HPC_TPSMP_0 = 0x0
	// Supervisor mode for the corresponding master
	CSU_HPCONTROL0_HPC_TPSMP_HPC_TPSMP_1 = 0x1
	// Position of L_TPSMP field.
	CSU_HPCONTROL0_L_TPSMP_Pos = 0x15
	// Bit mask of L_TPSMP field.
	CSU_HPCONTROL0_L_TPSMP_Msk = 0x200000
	// Bit L_TPSMP.
	CSU_HPCONTROL0_L_TPSMP = 0x200000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HPCONTROL0_L_TPSMP_L_TPSMP_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HPCONTROL0_L_TPSMP_L_TPSMP_1 = 0x1
	// Position of HPC_USB field.
	CSU_HPCONTROL0_HPC_USB_Pos = 0x16
	// Bit mask of HPC_USB field.
	CSU_HPCONTROL0_HPC_USB_Msk = 0x400000
	// Bit HPC_USB.
	CSU_HPCONTROL0_HPC_USB = 0x400000
	// User mode for the corresponding master
	CSU_HPCONTROL0_HPC_USB_HPC_USB_0 = 0x0
	// Supervisor mode for the corresponding master
	CSU_HPCONTROL0_HPC_USB_HPC_USB_1 = 0x1
	// Position of L_USB field.
	CSU_HPCONTROL0_L_USB_Pos = 0x17
	// Bit mask of L_USB field.
	CSU_HPCONTROL0_L_USB_Msk = 0x800000
	// Bit L_USB.
	CSU_HPCONTROL0_L_USB = 0x800000
	// No lock-the adjacent (next lower) bit can be written by the software.
	CSU_HPCONTROL0_L_USB_L_USB_0 = 0x0
	// Lock-the adjacent (next lower) bit can't be written by the software.
	CSU_HPCONTROL0_L_USB_L_USB_1 = 0x1
)

// Constants for USB: USB
const (
	// ID: Identification register
	// Position of ID field.
	USB_ID_ID_Pos = 0x0
	// Bit mask of ID field.
	USB_ID_ID_Msk = 0x3f
	// Position of NID field.
	USB_ID_NID_Pos = 0x8
	// Bit mask of NID field.
	USB_ID_NID_Msk = 0x3f00
	// Position of REVISION field.
	USB_ID_REVISION_Pos = 0x10
	// Bit mask of REVISION field.
	USB_ID_REVISION_Msk = 0xff0000

	// HWGENERAL: Hardware General
	// Position of PHYW field.
	USB_HWGENERAL_PHYW_Pos = 0x4
	// Bit mask of PHYW field.
	USB_HWGENERAL_PHYW_Msk = 0x30
	// 8 bit wide data bus Software non-programmable
	USB_HWGENERAL_PHYW_PHYW_0 = 0x0
	// 16 bit wide data bus Software non-programmable
	USB_HWGENERAL_PHYW_PHYW_1 = 0x1
	// Reset to 8 bit wide data bus Software programmable
	USB_HWGENERAL_PHYW_PHYW_2 = 0x2
	// Reset to 16 bit wide data bus Software programmable
	USB_HWGENERAL_PHYW_PHYW_3 = 0x3
	// Position of PHYM field.
	USB_HWGENERAL_PHYM_Pos = 0x6
	// Bit mask of PHYM field.
	USB_HWGENERAL_PHYM_Msk = 0x1c0
	// UTMI/UMTI+
	USB_HWGENERAL_PHYM_PHYM_0 = 0x0
	// ULPI DDR
	USB_HWGENERAL_PHYM_PHYM_1 = 0x1
	// ULPI
	USB_HWGENERAL_PHYM_PHYM_2 = 0x2
	// Serial Only
	USB_HWGENERAL_PHYM_PHYM_3 = 0x3
	// Software programmable - reset to UTMI/UTMI+
	USB_HWGENERAL_PHYM_PHYM_4 = 0x4
	// Software programmable - reset to ULPI DDR
	USB_HWGENERAL_PHYM_PHYM_5 = 0x5
	// Software programmable - reset to ULPI
	USB_HWGENERAL_PHYM_PHYM_6 = 0x6
	// Software programmable - reset to Serial
	USB_HWGENERAL_PHYM_PHYM_7 = 0x7
	// Position of SM field.
	USB_HWGENERAL_SM_Pos = 0x9
	// Bit mask of SM field.
	USB_HWGENERAL_SM_Msk = 0x600
	// No Serial Engine, always use parallel signalling.
	USB_HWGENERAL_SM_SM_0 = 0x0
	// Serial Engine present, always use serial signalling for FS/LS.
	USB_HWGENERAL_SM_SM_1 = 0x1
	// Software programmable - Reset to use parallel signalling for FS/LS
	USB_HWGENERAL_SM_SM_2 = 0x2
	// Software programmable - Reset to use serial signalling for FS/LS
	USB_HWGENERAL_SM_SM_3 = 0x3

	// HWHOST: Host Hardware Parameters
	// Position of HC field.
	USB_HWHOST_HC_Pos = 0x0
	// Bit mask of HC field.
	USB_HWHOST_HC_Msk = 0x1
	// Bit HC.
	USB_HWHOST_HC = 0x1
	// Not supported
	USB_HWHOST_HC_HC_0 = 0x0
	// Supported
	USB_HWHOST_HC_HC_1 = 0x1
	// Position of NPORT field.
	USB_HWHOST_NPORT_Pos = 0x1
	// Bit mask of NPORT field.
	USB_HWHOST_NPORT_Msk = 0xe

	// HWDEVICE: Device Hardware Parameters
	// Position of DC field.
	USB_HWDEVICE_DC_Pos = 0x0
	// Bit mask of DC field.
	USB_HWDEVICE_DC_Msk = 0x1
	// Bit DC.
	USB_HWDEVICE_DC = 0x1
	// Not supported
	USB_HWDEVICE_DC_DC_0 = 0x0
	// Supported
	USB_HWDEVICE_DC_DC_1 = 0x1
	// Position of DEVEP field.
	USB_HWDEVICE_DEVEP_Pos = 0x1
	// Bit mask of DEVEP field.
	USB_HWDEVICE_DEVEP_Msk = 0x3e

	// HWTXBUF: TX Buffer Hardware Parameters
	// Position of TXBURST field.
	USB_HWTXBUF_TXBURST_Pos = 0x0
	// Bit mask of TXBURST field.
	USB_HWTXBUF_TXBURST_Msk = 0xff
	// Position of TXCHANADD field.
	USB_HWTXBUF_TXCHANADD_Pos = 0x10
	// Bit mask of TXCHANADD field.
	USB_HWTXBUF_TXCHANADD_Msk = 0xff0000

	// HWRXBUF: RX Buffer Hardware Parameters
	// Position of RXBURST field.
	USB_HWRXBUF_RXBURST_Pos = 0x0
	// Bit mask of RXBURST field.
	USB_HWRXBUF_RXBURST_Msk = 0xff
	// Position of RXADD field.
	USB_HWRXBUF_RXADD_Pos = 0x8
	// Bit mask of RXADD field.
	USB_HWRXBUF_RXADD_Msk = 0xff00

	// GPTIMER0LD: General Purpose Timer #0 Load
	// Position of GPTLD field.
	USB_GPTIMER0LD_GPTLD_Pos = 0x0
	// Bit mask of GPTLD field.
	USB_GPTIMER0LD_GPTLD_Msk = 0xffffff

	// GPTIMER0CTRL: General Purpose Timer #0 Controller
	// Position of GPTCNT field.
	USB_GPTIMER0CTRL_GPTCNT_Pos = 0x0
	// Bit mask of GPTCNT field.
	USB_GPTIMER0CTRL_GPTCNT_Msk = 0xffffff
	// Position of GPTMODE field.
	USB_GPTIMER0CTRL_GPTMODE_Pos = 0x18
	// Bit mask of GPTMODE field.
	USB_GPTIMER0CTRL_GPTMODE_Msk = 0x1000000
	// Bit GPTMODE.
	USB_GPTIMER0CTRL_GPTMODE = 0x1000000
	// One Shot Mode
	USB_GPTIMER0CTRL_GPTMODE_GPTMODE_0 = 0x0
	// Repeat Mode
	USB_GPTIMER0CTRL_GPTMODE_GPTMODE_1 = 0x1
	// Position of GPTRST field.
	USB_GPTIMER0CTRL_GPTRST_Pos = 0x1e
	// Bit mask of GPTRST field.
	USB_GPTIMER0CTRL_GPTRST_Msk = 0x40000000
	// Bit GPTRST.
	USB_GPTIMER0CTRL_GPTRST = 0x40000000
	// No action
	USB_GPTIMER0CTRL_GPTRST_GPTRST_0 = 0x0
	// Load counter value from GPTLD bits in n_GPTIMER0LD
	USB_GPTIMER0CTRL_GPTRST_GPTRST_1 = 0x1
	// Position of GPTRUN field.
	USB_GPTIMER0CTRL_GPTRUN_Pos = 0x1f
	// Bit mask of GPTRUN field.
	USB_GPTIMER0CTRL_GPTRUN_Msk = 0x80000000
	// Bit GPTRUN.
	USB_GPTIMER0CTRL_GPTRUN = 0x80000000
	// Stop counting
	USB_GPTIMER0CTRL_GPTRUN_GPTRUN_0 = 0x0
	// Run
	USB_GPTIMER0CTRL_GPTRUN_GPTRUN_1 = 0x1

	// GPTIMER1LD: General Purpose Timer #1 Load
	// Position of GPTLD field.
	USB_GPTIMER1LD_GPTLD_Pos = 0x0
	// Bit mask of GPTLD field.
	USB_GPTIMER1LD_GPTLD_Msk = 0xffffff

	// GPTIMER1CTRL: General Purpose Timer #1 Controller
	// Position of GPTCNT field.
	USB_GPTIMER1CTRL_GPTCNT_Pos = 0x0
	// Bit mask of GPTCNT field.
	USB_GPTIMER1CTRL_GPTCNT_Msk = 0xffffff
	// Position of GPTMODE field.
	USB_GPTIMER1CTRL_GPTMODE_Pos = 0x18
	// Bit mask of GPTMODE field.
	USB_GPTIMER1CTRL_GPTMODE_Msk = 0x1000000
	// Bit GPTMODE.
	USB_GPTIMER1CTRL_GPTMODE = 0x1000000
	// One Shot Mode
	USB_GPTIMER1CTRL_GPTMODE_GPTMODE_0 = 0x0
	// Repeat Mode
	USB_GPTIMER1CTRL_GPTMODE_GPTMODE_1 = 0x1
	// Position of GPTRST field.
	USB_GPTIMER1CTRL_GPTRST_Pos = 0x1e
	// Bit mask of GPTRST field.
	USB_GPTIMER1CTRL_GPTRST_Msk = 0x40000000
	// Bit GPTRST.
	USB_GPTIMER1CTRL_GPTRST = 0x40000000
	// No action
	USB_GPTIMER1CTRL_GPTRST_GPTRST_0 = 0x0
	// Load counter value from GPTLD bits in USB_n_GPTIMER0LD
	USB_GPTIMER1CTRL_GPTRST_GPTRST_1 = 0x1
	// Position of GPTRUN field.
	USB_GPTIMER1CTRL_GPTRUN_Pos = 0x1f
	// Bit mask of GPTRUN field.
	USB_GPTIMER1CTRL_GPTRUN_Msk = 0x80000000
	// Bit GPTRUN.
	USB_GPTIMER1CTRL_GPTRUN = 0x80000000
	// Stop counting
	USB_GPTIMER1CTRL_GPTRUN_GPTRUN_0 = 0x0
	// Run
	USB_GPTIMER1CTRL_GPTRUN_GPTRUN_1 = 0x1

	// SBUSCFG: System Bus Config
	// Position of AHBBRST field.
	USB_SBUSCFG_AHBBRST_Pos = 0x0
	// Bit mask of AHBBRST field.
	USB_SBUSCFG_AHBBRST_Msk = 0x7
	// Incremental burst of unspecified length only
	USB_SBUSCFG_AHBBRST_AHBBRST_0 = 0x0
	// INCR4 burst, then single transfer
	USB_SBUSCFG_AHBBRST_AHBBRST_1 = 0x1
	// INCR8 burst, INCR4 burst, then single transfer
	USB_SBUSCFG_AHBBRST_AHBBRST_2 = 0x2
	// INCR16 burst, INCR8 burst, INCR4 burst, then single transfer
	USB_SBUSCFG_AHBBRST_AHBBRST_3 = 0x3
	// INCR4 burst, then incremental burst of unspecified length
	USB_SBUSCFG_AHBBRST_AHBBRST_5 = 0x5
	// INCR8 burst, INCR4 burst, then incremental burst of unspecified length
	USB_SBUSCFG_AHBBRST_AHBBRST_6 = 0x6
	// INCR16 burst, INCR8 burst, INCR4 burst, then incremental burst of unspecified length
	USB_SBUSCFG_AHBBRST_AHBBRST_7 = 0x7

	// CAPLENGTH: Capability Registers Length
	// Position of CAPLENGTH field.
	USB_CAPLENGTH_CAPLENGTH_Pos = 0x0
	// Bit mask of CAPLENGTH field.
	USB_CAPLENGTH_CAPLENGTH_Msk = 0xff

	// HCIVERSION: Host Controller Interface Version
	// Position of HCIVERSION field.
	USB_HCIVERSION_HCIVERSION_Pos = 0x0
	// Bit mask of HCIVERSION field.
	USB_HCIVERSION_HCIVERSION_Msk = 0xffff

	// HCSPARAMS: Host Controller Structural Parameters
	// Position of N_PORTS field.
	USB_HCSPARAMS_N_PORTS_Pos = 0x0
	// Bit mask of N_PORTS field.
	USB_HCSPARAMS_N_PORTS_Msk = 0xf
	// Position of PPC field.
	USB_HCSPARAMS_PPC_Pos = 0x4
	// Bit mask of PPC field.
	USB_HCSPARAMS_PPC_Msk = 0x10
	// Bit PPC.
	USB_HCSPARAMS_PPC = 0x10
	// Position of N_PCC field.
	USB_HCSPARAMS_N_PCC_Pos = 0x8
	// Bit mask of N_PCC field.
	USB_HCSPARAMS_N_PCC_Msk = 0xf00
	// Position of N_CC field.
	USB_HCSPARAMS_N_CC_Pos = 0xc
	// Bit mask of N_CC field.
	USB_HCSPARAMS_N_CC_Msk = 0xf000
	// There is no internal Companion Controller and port-ownership hand-off is not supported.
	USB_HCSPARAMS_N_CC_N_CC_0 = 0x0
	// There are internal companion controller(s) and port-ownership hand-offs is supported.
	USB_HCSPARAMS_N_CC_N_CC_1 = 0x1
	// Position of PI field.
	USB_HCSPARAMS_PI_Pos = 0x10
	// Bit mask of PI field.
	USB_HCSPARAMS_PI_Msk = 0x10000
	// Bit PI.
	USB_HCSPARAMS_PI = 0x10000
	// Position of N_PTT field.
	USB_HCSPARAMS_N_PTT_Pos = 0x14
	// Bit mask of N_PTT field.
	USB_HCSPARAMS_N_PTT_Msk = 0xf00000
	// Position of N_TT field.
	USB_HCSPARAMS_N_TT_Pos = 0x18
	// Bit mask of N_TT field.
	USB_HCSPARAMS_N_TT_Msk = 0xf000000

	// HCCPARAMS: Host Controller Capability Parameters
	// Position of ADC field.
	USB_HCCPARAMS_ADC_Pos = 0x0
	// Bit mask of ADC field.
	USB_HCCPARAMS_ADC_Msk = 0x1
	// Bit ADC.
	USB_HCCPARAMS_ADC = 0x1
	// Position of PFL field.
	USB_HCCPARAMS_PFL_Pos = 0x1
	// Bit mask of PFL field.
	USB_HCCPARAMS_PFL_Msk = 0x2
	// Bit PFL.
	USB_HCCPARAMS_PFL = 0x2
	// Position of ASP field.
	USB_HCCPARAMS_ASP_Pos = 0x2
	// Bit mask of ASP field.
	USB_HCCPARAMS_ASP_Msk = 0x4
	// Bit ASP.
	USB_HCCPARAMS_ASP = 0x4
	// Position of IST field.
	USB_HCCPARAMS_IST_Pos = 0x4
	// Bit mask of IST field.
	USB_HCCPARAMS_IST_Msk = 0xf0
	// Position of EECP field.
	USB_HCCPARAMS_EECP_Pos = 0x8
	// Bit mask of EECP field.
	USB_HCCPARAMS_EECP_Msk = 0xff00

	// DCIVERSION: Device Controller Interface Version
	// Position of DCIVERSION field.
	USB_DCIVERSION_DCIVERSION_Pos = 0x0
	// Bit mask of DCIVERSION field.
	USB_DCIVERSION_DCIVERSION_Msk = 0xffff

	// DCCPARAMS: Device Controller Capability Parameters
	// Position of DEN field.
	USB_DCCPARAMS_DEN_Pos = 0x0
	// Bit mask of DEN field.
	USB_DCCPARAMS_DEN_Msk = 0x1f
	// Position of DC field.
	USB_DCCPARAMS_DC_Pos = 0x7
	// Bit mask of DC field.
	USB_DCCPARAMS_DC_Msk = 0x80
	// Bit DC.
	USB_DCCPARAMS_DC = 0x80
	// Position of HC field.
	USB_DCCPARAMS_HC_Pos = 0x8
	// Bit mask of HC field.
	USB_DCCPARAMS_HC_Msk = 0x100
	// Bit HC.
	USB_DCCPARAMS_HC = 0x100

	// USBCMD: USB Command Register
	// Position of RS field.
	USB_USBCMD_RS_Pos = 0x0
	// Bit mask of RS field.
	USB_USBCMD_RS_Msk = 0x1
	// Bit RS.
	USB_USBCMD_RS = 0x1
	// Position of RST field.
	USB_USBCMD_RST_Pos = 0x1
	// Bit mask of RST field.
	USB_USBCMD_RST_Msk = 0x2
	// Bit RST.
	USB_USBCMD_RST = 0x2
	// Position of FS_1 field.
	USB_USBCMD_FS_1_Pos = 0x2
	// Bit mask of FS_1 field.
	USB_USBCMD_FS_1_Msk = 0xc
	// Position of PSE field.
	USB_USBCMD_PSE_Pos = 0x4
	// Bit mask of PSE field.
	USB_USBCMD_PSE_Msk = 0x10
	// Bit PSE.
	USB_USBCMD_PSE = 0x10
	// Do not process the Periodic Schedule
	USB_USBCMD_PSE_PSE_0 = 0x0
	// Use the PERIODICLISTBASE register to access the Periodic Schedule.
	USB_USBCMD_PSE_PSE_1 = 0x1
	// Position of ASE field.
	USB_USBCMD_ASE_Pos = 0x5
	// Bit mask of ASE field.
	USB_USBCMD_ASE_Msk = 0x20
	// Bit ASE.
	USB_USBCMD_ASE = 0x20
	// Do not process the Asynchronous Schedule.
	USB_USBCMD_ASE_ASE_0 = 0x0
	// Use the ASYNCLISTADDR register to access the Asynchronous Schedule.
	USB_USBCMD_ASE_ASE_1 = 0x1
	// Position of IAA field.
	USB_USBCMD_IAA_Pos = 0x6
	// Bit mask of IAA field.
	USB_USBCMD_IAA_Msk = 0x40
	// Bit IAA.
	USB_USBCMD_IAA = 0x40
	// Position of ASP field.
	USB_USBCMD_ASP_Pos = 0x8
	// Bit mask of ASP field.
	USB_USBCMD_ASP_Msk = 0x300
	// Position of ASPE field.
	USB_USBCMD_ASPE_Pos = 0xb
	// Bit mask of ASPE field.
	USB_USBCMD_ASPE_Msk = 0x800
	// Bit ASPE.
	USB_USBCMD_ASPE = 0x800
	// Position of SUTW field.
	USB_USBCMD_SUTW_Pos = 0xd
	// Bit mask of SUTW field.
	USB_USBCMD_SUTW_Msk = 0x2000
	// Bit SUTW.
	USB_USBCMD_SUTW = 0x2000
	// Position of ATDTW field.
	USB_USBCMD_ATDTW_Pos = 0xe
	// Bit mask of ATDTW field.
	USB_USBCMD_ATDTW_Msk = 0x4000
	// Bit ATDTW.
	USB_USBCMD_ATDTW = 0x4000
	// Position of FS_2 field.
	USB_USBCMD_FS_2_Pos = 0xf
	// Bit mask of FS_2 field.
	USB_USBCMD_FS_2_Msk = 0x8000
	// Bit FS_2.
	USB_USBCMD_FS_2 = 0x8000
	// 1024 elements (4096 bytes) Default value
	USB_USBCMD_FS_2_FS_2_0 = 0x0
	// 512 elements (2048 bytes)
	USB_USBCMD_FS_2_FS_2_1 = 0x1
	// Position of ITC field.
	USB_USBCMD_ITC_Pos = 0x10
	// Bit mask of ITC field.
	USB_USBCMD_ITC_Msk = 0xff0000
	// Immediate (no threshold)
	USB_USBCMD_ITC_ITC_0 = 0x0
	// 1 micro-frame
	USB_USBCMD_ITC_ITC_1 = 0x1
	// 2 micro-frames
	USB_USBCMD_ITC_ITC_2 = 0x2
	// 4 micro-frames
	USB_USBCMD_ITC_ITC_4 = 0x4
	// 8 micro-frames
	USB_USBCMD_ITC_ITC_8 = 0x8
	// 16 micro-frames
	USB_USBCMD_ITC_ITC_16 = 0x10
	// 32 micro-frames
	USB_USBCMD_ITC_ITC_32 = 0x20
	// 64 micro-frames
	USB_USBCMD_ITC_ITC_64 = 0x40

	// USBSTS: USB Status Register
	// Position of UI field.
	USB_USBSTS_UI_Pos = 0x0
	// Bit mask of UI field.
	USB_USBSTS_UI_Msk = 0x1
	// Bit UI.
	USB_USBSTS_UI = 0x1
	// Position of UEI field.
	USB_USBSTS_UEI_Pos = 0x1
	// Bit mask of UEI field.
	USB_USBSTS_UEI_Msk = 0x2
	// Bit UEI.
	USB_USBSTS_UEI = 0x2
	// Position of PCI field.
	USB_USBSTS_PCI_Pos = 0x2
	// Bit mask of PCI field.
	USB_USBSTS_PCI_Msk = 0x4
	// Bit PCI.
	USB_USBSTS_PCI = 0x4
	// Position of FRI field.
	USB_USBSTS_FRI_Pos = 0x3
	// Bit mask of FRI field.
	USB_USBSTS_FRI_Msk = 0x8
	// Bit FRI.
	USB_USBSTS_FRI = 0x8
	// Position of SEI field.
	USB_USBSTS_SEI_Pos = 0x4
	// Bit mask of SEI field.
	USB_USBSTS_SEI_Msk = 0x10
	// Bit SEI.
	USB_USBSTS_SEI = 0x10
	// Position of AAI field.
	USB_USBSTS_AAI_Pos = 0x5
	// Bit mask of AAI field.
	USB_USBSTS_AAI_Msk = 0x20
	// Bit AAI.
	USB_USBSTS_AAI = 0x20
	// Position of URI field.
	USB_USBSTS_URI_Pos = 0x6
	// Bit mask of URI field.
	USB_USBSTS_URI_Msk = 0x40
	// Bit URI.
	USB_USBSTS_URI = 0x40
	// Position of SRI field.
	USB_USBSTS_SRI_Pos = 0x7
	// Bit mask of SRI field.
	USB_USBSTS_SRI_Msk = 0x80
	// Bit SRI.
	USB_USBSTS_SRI = 0x80
	// Position of SLI field.
	USB_USBSTS_SLI_Pos = 0x8
	// Bit mask of SLI field.
	USB_USBSTS_SLI_Msk = 0x100
	// Bit SLI.
	USB_USBSTS_SLI = 0x100
	// Position of ULPII field.
	USB_USBSTS_ULPII_Pos = 0xa
	// Bit mask of ULPII field.
	USB_USBSTS_ULPII_Msk = 0x400
	// Bit ULPII.
	USB_USBSTS_ULPII = 0x400
	// Position of HCH field.
	USB_USBSTS_HCH_Pos = 0xc
	// Bit mask of HCH field.
	USB_USBSTS_HCH_Msk = 0x1000
	// Bit HCH.
	USB_USBSTS_HCH = 0x1000
	// Position of RCL field.
	USB_USBSTS_RCL_Pos = 0xd
	// Bit mask of RCL field.
	USB_USBSTS_RCL_Msk = 0x2000
	// Bit RCL.
	USB_USBSTS_RCL = 0x2000
	// Position of PS field.
	USB_USBSTS_PS_Pos = 0xe
	// Bit mask of PS field.
	USB_USBSTS_PS_Msk = 0x4000
	// Bit PS.
	USB_USBSTS_PS = 0x4000
	// Position of AS field.
	USB_USBSTS_AS_Pos = 0xf
	// Bit mask of AS field.
	USB_USBSTS_AS_Msk = 0x8000
	// Bit AS.
	USB_USBSTS_AS = 0x8000
	// Position of NAKI field.
	USB_USBSTS_NAKI_Pos = 0x10
	// Bit mask of NAKI field.
	USB_USBSTS_NAKI_Msk = 0x10000
	// Bit NAKI.
	USB_USBSTS_NAKI = 0x10000
	// Position of TI0 field.
	USB_USBSTS_TI0_Pos = 0x18
	// Bit mask of TI0 field.
	USB_USBSTS_TI0_Msk = 0x1000000
	// Bit TI0.
	USB_USBSTS_TI0 = 0x1000000
	// Position of TI1 field.
	USB_USBSTS_TI1_Pos = 0x19
	// Bit mask of TI1 field.
	USB_USBSTS_TI1_Msk = 0x2000000
	// Bit TI1.
	USB_USBSTS_TI1 = 0x2000000

	// USBINTR: Interrupt Enable Register
	// Position of UE field.
	USB_USBINTR_UE_Pos = 0x0
	// Bit mask of UE field.
	USB_USBINTR_UE_Msk = 0x1
	// Bit UE.
	USB_USBINTR_UE = 0x1
	// Position of UEE field.
	USB_USBINTR_UEE_Pos = 0x1
	// Bit mask of UEE field.
	USB_USBINTR_UEE_Msk = 0x2
	// Bit UEE.
	USB_USBINTR_UEE = 0x2
	// Position of PCE field.
	USB_USBINTR_PCE_Pos = 0x2
	// Bit mask of PCE field.
	USB_USBINTR_PCE_Msk = 0x4
	// Bit PCE.
	USB_USBINTR_PCE = 0x4
	// Position of FRE field.
	USB_USBINTR_FRE_Pos = 0x3
	// Bit mask of FRE field.
	USB_USBINTR_FRE_Msk = 0x8
	// Bit FRE.
	USB_USBINTR_FRE = 0x8
	// Position of SEE field.
	USB_USBINTR_SEE_Pos = 0x4
	// Bit mask of SEE field.
	USB_USBINTR_SEE_Msk = 0x10
	// Bit SEE.
	USB_USBINTR_SEE = 0x10
	// Position of AAE field.
	USB_USBINTR_AAE_Pos = 0x5
	// Bit mask of AAE field.
	USB_USBINTR_AAE_Msk = 0x20
	// Bit AAE.
	USB_USBINTR_AAE = 0x20
	// Position of URE field.
	USB_USBINTR_URE_Pos = 0x6
	// Bit mask of URE field.
	USB_USBINTR_URE_Msk = 0x40
	// Bit URE.
	USB_USBINTR_URE = 0x40
	// Position of SRE field.
	USB_USBINTR_SRE_Pos = 0x7
	// Bit mask of SRE field.
	USB_USBINTR_SRE_Msk = 0x80
	// Bit SRE.
	USB_USBINTR_SRE = 0x80
	// Position of SLE field.
	USB_USBINTR_SLE_Pos = 0x8
	// Bit mask of SLE field.
	USB_USBINTR_SLE_Msk = 0x100
	// Bit SLE.
	USB_USBINTR_SLE = 0x100
	// Position of ULPIE field.
	USB_USBINTR_ULPIE_Pos = 0xa
	// Bit mask of ULPIE field.
	USB_USBINTR_ULPIE_Msk = 0x400
	// Bit ULPIE.
	USB_USBINTR_ULPIE = 0x400
	// Position of NAKE field.
	USB_USBINTR_NAKE_Pos = 0x10
	// Bit mask of NAKE field.
	USB_USBINTR_NAKE_Msk = 0x10000
	// Bit NAKE.
	USB_USBINTR_NAKE = 0x10000
	// Position of UAIE field.
	USB_USBINTR_UAIE_Pos = 0x12
	// Bit mask of UAIE field.
	USB_USBINTR_UAIE_Msk = 0x40000
	// Bit UAIE.
	USB_USBINTR_UAIE = 0x40000
	// Position of UPIE field.
	USB_USBINTR_UPIE_Pos = 0x13
	// Bit mask of UPIE field.
	USB_USBINTR_UPIE_Msk = 0x80000
	// Bit UPIE.
	USB_USBINTR_UPIE = 0x80000
	// Position of TIE0 field.
	USB_USBINTR_TIE0_Pos = 0x18
	// Bit mask of TIE0 field.
	USB_USBINTR_TIE0_Msk = 0x1000000
	// Bit TIE0.
	USB_USBINTR_TIE0 = 0x1000000
	// Position of TIE1 field.
	USB_USBINTR_TIE1_Pos = 0x19
	// Bit mask of TIE1 field.
	USB_USBINTR_TIE1_Msk = 0x2000000
	// Bit TIE1.
	USB_USBINTR_TIE1 = 0x2000000

	// FRINDEX: USB Frame Index
	// Position of FRINDEX field.
	USB_FRINDEX_FRINDEX_Pos = 0x0
	// Bit mask of FRINDEX field.
	USB_FRINDEX_FRINDEX_Msk = 0x3fff
	// (1024) 12
	USB_FRINDEX_FRINDEX_FRINDEX_0 = 0x0
	// (512) 11
	USB_FRINDEX_FRINDEX_FRINDEX_1 = 0x1
	// (256) 10
	USB_FRINDEX_FRINDEX_FRINDEX_2 = 0x2
	// (128) 9
	USB_FRINDEX_FRINDEX_FRINDEX_3 = 0x3
	// (64) 8
	USB_FRINDEX_FRINDEX_FRINDEX_4 = 0x4
	// (32) 7
	USB_FRINDEX_FRINDEX_FRINDEX_5 = 0x5
	// (16) 6
	USB_FRINDEX_FRINDEX_FRINDEX_6 = 0x6
	// (8) 5
	USB_FRINDEX_FRINDEX_FRINDEX_7 = 0x7

	// DEVICEADDR: Device Address
	// Position of USBADRA field.
	USB_DEVICEADDR_USBADRA_Pos = 0x18
	// Bit mask of USBADRA field.
	USB_DEVICEADDR_USBADRA_Msk = 0x1000000
	// Bit USBADRA.
	USB_DEVICEADDR_USBADRA = 0x1000000
	// Position of USBADR field.
	USB_DEVICEADDR_USBADR_Pos = 0x19
	// Bit mask of USBADR field.
	USB_DEVICEADDR_USBADR_Msk = 0xfe000000

	// PERIODICLISTBASE: Frame List Base Address
	// Position of BASEADR field.
	USB_PERIODICLISTBASE_BASEADR_Pos = 0xc
	// Bit mask of BASEADR field.
	USB_PERIODICLISTBASE_BASEADR_Msk = 0xfffff000

	// ASYNCLISTADDR: Next Asynch. Address
	// Position of ASYBASE field.
	USB_ASYNCLISTADDR_ASYBASE_Pos = 0x5
	// Bit mask of ASYBASE field.
	USB_ASYNCLISTADDR_ASYBASE_Msk = 0xffffffe0

	// ENDPTLISTADDR: Endpoint List Address
	// Position of EPBASE field.
	USB_ENDPTLISTADDR_EPBASE_Pos = 0xb
	// Bit mask of EPBASE field.
	USB_ENDPTLISTADDR_EPBASE_Msk = 0xfffff800

	// BURSTSIZE: Programmable Burst Size
	// Position of RXPBURST field.
	USB_BURSTSIZE_RXPBURST_Pos = 0x0
	// Bit mask of RXPBURST field.
	USB_BURSTSIZE_RXPBURST_Msk = 0xff
	// Position of TXPBURST field.
	USB_BURSTSIZE_TXPBURST_Pos = 0x8
	// Bit mask of TXPBURST field.
	USB_BURSTSIZE_TXPBURST_Msk = 0x1ff00

	// TXFILLTUNING: TX FIFO Fill Tuning
	// Position of TXSCHOH field.
	USB_TXFILLTUNING_TXSCHOH_Pos = 0x0
	// Bit mask of TXSCHOH field.
	USB_TXFILLTUNING_TXSCHOH_Msk = 0xff
	// Position of TXSCHHEALTH field.
	USB_TXFILLTUNING_TXSCHHEALTH_Pos = 0x8
	// Bit mask of TXSCHHEALTH field.
	USB_TXFILLTUNING_TXSCHHEALTH_Msk = 0x1f00
	// Position of TXFIFOTHRES field.
	USB_TXFILLTUNING_TXFIFOTHRES_Pos = 0x10
	// Bit mask of TXFIFOTHRES field.
	USB_TXFILLTUNING_TXFIFOTHRES_Msk = 0x3f0000

	// ENDPTNAK: Endpoint NAK
	// Position of EPRN field.
	USB_ENDPTNAK_EPRN_Pos = 0x0
	// Bit mask of EPRN field.
	USB_ENDPTNAK_EPRN_Msk = 0xff
	// Position of EPTN field.
	USB_ENDPTNAK_EPTN_Pos = 0x10
	// Bit mask of EPTN field.
	USB_ENDPTNAK_EPTN_Msk = 0xff0000

	// ENDPTNAKEN: Endpoint NAK Enable
	// Position of EPRNE field.
	USB_ENDPTNAKEN_EPRNE_Pos = 0x0
	// Bit mask of EPRNE field.
	USB_ENDPTNAKEN_EPRNE_Msk = 0xff
	// Position of EPTNE field.
	USB_ENDPTNAKEN_EPTNE_Pos = 0x10
	// Bit mask of EPTNE field.
	USB_ENDPTNAKEN_EPTNE_Msk = 0xff0000

	// CONFIGFLAG: Configure Flag Register
	// Position of CF field.
	USB_CONFIGFLAG_CF_Pos = 0x0
	// Bit mask of CF field.
	USB_CONFIGFLAG_CF_Msk = 0x1
	// Bit CF.
	USB_CONFIGFLAG_CF = 0x1
	// Port routing control logic default-routes each port to an implementation dependent classic host controller.
	USB_CONFIGFLAG_CF_CF_0 = 0x0
	// Port routing control logic default-routes all ports to this host controller.
	USB_CONFIGFLAG_CF_CF_1 = 0x1

	// PORTSC1: Port Status & Control
	// Position of CCS field.
	USB_PORTSC1_CCS_Pos = 0x0
	// Bit mask of CCS field.
	USB_PORTSC1_CCS_Msk = 0x1
	// Bit CCS.
	USB_PORTSC1_CCS = 0x1
	// Position of CSC field.
	USB_PORTSC1_CSC_Pos = 0x1
	// Bit mask of CSC field.
	USB_PORTSC1_CSC_Msk = 0x2
	// Bit CSC.
	USB_PORTSC1_CSC = 0x2
	// Position of PE field.
	USB_PORTSC1_PE_Pos = 0x2
	// Bit mask of PE field.
	USB_PORTSC1_PE_Msk = 0x4
	// Bit PE.
	USB_PORTSC1_PE = 0x4
	// Position of PEC field.
	USB_PORTSC1_PEC_Pos = 0x3
	// Bit mask of PEC field.
	USB_PORTSC1_PEC_Msk = 0x8
	// Bit PEC.
	USB_PORTSC1_PEC = 0x8
	// Position of OCA field.
	USB_PORTSC1_OCA_Pos = 0x4
	// Bit mask of OCA field.
	USB_PORTSC1_OCA_Msk = 0x10
	// Bit OCA.
	USB_PORTSC1_OCA = 0x10
	// This port does not have an over-current condition.
	USB_PORTSC1_OCA_OCA_0 = 0x0
	// This port currently has an over-current condition
	USB_PORTSC1_OCA_OCA_1 = 0x1
	// Position of OCC field.
	USB_PORTSC1_OCC_Pos = 0x5
	// Bit mask of OCC field.
	USB_PORTSC1_OCC_Msk = 0x20
	// Bit OCC.
	USB_PORTSC1_OCC = 0x20
	// Position of FPR field.
	USB_PORTSC1_FPR_Pos = 0x6
	// Bit mask of FPR field.
	USB_PORTSC1_FPR_Msk = 0x40
	// Bit FPR.
	USB_PORTSC1_FPR = 0x40
	// Position of SUSP field.
	USB_PORTSC1_SUSP_Pos = 0x7
	// Bit mask of SUSP field.
	USB_PORTSC1_SUSP_Msk = 0x80
	// Bit SUSP.
	USB_PORTSC1_SUSP = 0x80
	// Position of PR field.
	USB_PORTSC1_PR_Pos = 0x8
	// Bit mask of PR field.
	USB_PORTSC1_PR_Msk = 0x100
	// Bit PR.
	USB_PORTSC1_PR = 0x100
	// Position of HSP field.
	USB_PORTSC1_HSP_Pos = 0x9
	// Bit mask of HSP field.
	USB_PORTSC1_HSP_Msk = 0x200
	// Bit HSP.
	USB_PORTSC1_HSP = 0x200
	// Position of LS field.
	USB_PORTSC1_LS_Pos = 0xa
	// Bit mask of LS field.
	USB_PORTSC1_LS_Msk = 0xc00
	// SE0
	USB_PORTSC1_LS_LS_0 = 0x0
	// K-state
	USB_PORTSC1_LS_LS_1 = 0x1
	// J-state
	USB_PORTSC1_LS_LS_2 = 0x2
	// Undefined
	USB_PORTSC1_LS_LS_3 = 0x3
	// Position of PP field.
	USB_PORTSC1_PP_Pos = 0xc
	// Bit mask of PP field.
	USB_PORTSC1_PP_Msk = 0x1000
	// Bit PP.
	USB_PORTSC1_PP = 0x1000
	// Position of PO field.
	USB_PORTSC1_PO_Pos = 0xd
	// Bit mask of PO field.
	USB_PORTSC1_PO_Msk = 0x2000
	// Bit PO.
	USB_PORTSC1_PO = 0x2000
	// Position of PIC field.
	USB_PORTSC1_PIC_Pos = 0xe
	// Bit mask of PIC field.
	USB_PORTSC1_PIC_Msk = 0xc000
	// Port indicators are off
	USB_PORTSC1_PIC_PIC_0 = 0x0
	// Amber
	USB_PORTSC1_PIC_PIC_1 = 0x1
	// Green
	USB_PORTSC1_PIC_PIC_2 = 0x2
	// Undefined
	USB_PORTSC1_PIC_PIC_3 = 0x3
	// Position of PTC field.
	USB_PORTSC1_PTC_Pos = 0x10
	// Bit mask of PTC field.
	USB_PORTSC1_PTC_Msk = 0xf0000
	// TEST_MODE_DISABLE
	USB_PORTSC1_PTC_PTC_0 = 0x0
	// J_STATE
	USB_PORTSC1_PTC_PTC_1 = 0x1
	// K_STATE
	USB_PORTSC1_PTC_PTC_2 = 0x2
	// SE0 (host) / NAK (device)
	USB_PORTSC1_PTC_PTC_3 = 0x3
	// Packet
	USB_PORTSC1_PTC_PTC_4 = 0x4
	// FORCE_ENABLE_HS
	USB_PORTSC1_PTC_PTC_5 = 0x5
	// FORCE_ENABLE_FS
	USB_PORTSC1_PTC_PTC_6 = 0x6
	// FORCE_ENABLE_LS
	USB_PORTSC1_PTC_PTC_7 = 0x7
	// Position of WKCN field.
	USB_PORTSC1_WKCN_Pos = 0x14
	// Bit mask of WKCN field.
	USB_PORTSC1_WKCN_Msk = 0x100000
	// Bit WKCN.
	USB_PORTSC1_WKCN = 0x100000
	// Position of WKDC field.
	USB_PORTSC1_WKDC_Pos = 0x15
	// Bit mask of WKDC field.
	USB_PORTSC1_WKDC_Msk = 0x200000
	// Bit WKDC.
	USB_PORTSC1_WKDC = 0x200000
	// Position of WKOC field.
	USB_PORTSC1_WKOC_Pos = 0x16
	// Bit mask of WKOC field.
	USB_PORTSC1_WKOC_Msk = 0x400000
	// Bit WKOC.
	USB_PORTSC1_WKOC = 0x400000
	// Position of PHCD field.
	USB_PORTSC1_PHCD_Pos = 0x17
	// Bit mask of PHCD field.
	USB_PORTSC1_PHCD_Msk = 0x800000
	// Bit PHCD.
	USB_PORTSC1_PHCD = 0x800000
	// Enable PHY clock
	USB_PORTSC1_PHCD_PHCD_0 = 0x0
	// Disable PHY clock
	USB_PORTSC1_PHCD_PHCD_1 = 0x1
	// Position of PFSC field.
	USB_PORTSC1_PFSC_Pos = 0x18
	// Bit mask of PFSC field.
	USB_PORTSC1_PFSC_Msk = 0x1000000
	// Bit PFSC.
	USB_PORTSC1_PFSC = 0x1000000
	// Normal operation
	USB_PORTSC1_PFSC_PFSC_0 = 0x0
	// Forced to full speed
	USB_PORTSC1_PFSC_PFSC_1 = 0x1
	// Position of PTS_2 field.
	USB_PORTSC1_PTS_2_Pos = 0x19
	// Bit mask of PTS_2 field.
	USB_PORTSC1_PTS_2_Msk = 0x2000000
	// Bit PTS_2.
	USB_PORTSC1_PTS_2 = 0x2000000
	// Position of PSPD field.
	USB_PORTSC1_PSPD_Pos = 0x1a
	// Bit mask of PSPD field.
	USB_PORTSC1_PSPD_Msk = 0xc000000
	// Full Speed
	USB_PORTSC1_PSPD_PSPD_0 = 0x0
	// Low Speed
	USB_PORTSC1_PSPD_PSPD_1 = 0x1
	// High Speed
	USB_PORTSC1_PSPD_PSPD_2 = 0x2
	// Undefined
	USB_PORTSC1_PSPD_PSPD_3 = 0x3
	// Position of PTW field.
	USB_PORTSC1_PTW_Pos = 0x1c
	// Bit mask of PTW field.
	USB_PORTSC1_PTW_Msk = 0x10000000
	// Bit PTW.
	USB_PORTSC1_PTW = 0x10000000
	// Select the 8-bit UTMI interface [60MHz]
	USB_PORTSC1_PTW_PTW_0 = 0x0
	// Select the 16-bit UTMI interface [30MHz]
	USB_PORTSC1_PTW_PTW_1 = 0x1
	// Position of STS field.
	USB_PORTSC1_STS_Pos = 0x1d
	// Bit mask of STS field.
	USB_PORTSC1_STS_Msk = 0x20000000
	// Bit STS.
	USB_PORTSC1_STS = 0x20000000
	// Position of PTS_1 field.
	USB_PORTSC1_PTS_1_Pos = 0x1e
	// Bit mask of PTS_1 field.
	USB_PORTSC1_PTS_1_Msk = 0xc0000000

	// OTGSC: On-The-Go Status & control
	// Position of VD field.
	USB_OTGSC_VD_Pos = 0x0
	// Bit mask of VD field.
	USB_OTGSC_VD_Msk = 0x1
	// Bit VD.
	USB_OTGSC_VD = 0x1
	// Position of VC field.
	USB_OTGSC_VC_Pos = 0x1
	// Bit mask of VC field.
	USB_OTGSC_VC_Msk = 0x2
	// Bit VC.
	USB_OTGSC_VC = 0x2
	// Position of OT field.
	USB_OTGSC_OT_Pos = 0x3
	// Bit mask of OT field.
	USB_OTGSC_OT_Msk = 0x8
	// Bit OT.
	USB_OTGSC_OT = 0x8
	// Position of DP field.
	USB_OTGSC_DP_Pos = 0x4
	// Bit mask of DP field.
	USB_OTGSC_DP_Msk = 0x10
	// Bit DP.
	USB_OTGSC_DP = 0x10
	// Position of IDPU field.
	USB_OTGSC_IDPU_Pos = 0x5
	// Bit mask of IDPU field.
	USB_OTGSC_IDPU_Msk = 0x20
	// Bit IDPU.
	USB_OTGSC_IDPU = 0x20
	// Position of ID field.
	USB_OTGSC_ID_Pos = 0x8
	// Bit mask of ID field.
	USB_OTGSC_ID_Msk = 0x100
	// Bit ID.
	USB_OTGSC_ID = 0x100
	// Position of AVV field.
	USB_OTGSC_AVV_Pos = 0x9
	// Bit mask of AVV field.
	USB_OTGSC_AVV_Msk = 0x200
	// Bit AVV.
	USB_OTGSC_AVV = 0x200
	// Position of ASV field.
	USB_OTGSC_ASV_Pos = 0xa
	// Bit mask of ASV field.
	USB_OTGSC_ASV_Msk = 0x400
	// Bit ASV.
	USB_OTGSC_ASV = 0x400
	// Position of BSV field.
	USB_OTGSC_BSV_Pos = 0xb
	// Bit mask of BSV field.
	USB_OTGSC_BSV_Msk = 0x800
	// Bit BSV.
	USB_OTGSC_BSV = 0x800
	// Position of BSE field.
	USB_OTGSC_BSE_Pos = 0xc
	// Bit mask of BSE field.
	USB_OTGSC_BSE_Msk = 0x1000
	// Bit BSE.
	USB_OTGSC_BSE = 0x1000
	// Position of TOG_1MS field.
	USB_OTGSC_TOG_1MS_Pos = 0xd
	// Bit mask of TOG_1MS field.
	USB_OTGSC_TOG_1MS_Msk = 0x2000
	// Bit TOG_1MS.
	USB_OTGSC_TOG_1MS = 0x2000
	// Position of DPS field.
	USB_OTGSC_DPS_Pos = 0xe
	// Bit mask of DPS field.
	USB_OTGSC_DPS_Msk = 0x4000
	// Bit DPS.
	USB_OTGSC_DPS = 0x4000
	// Position of IDIS field.
	USB_OTGSC_IDIS_Pos = 0x10
	// Bit mask of IDIS field.
	USB_OTGSC_IDIS_Msk = 0x10000
	// Bit IDIS.
	USB_OTGSC_IDIS = 0x10000
	// Position of AVVIS field.
	USB_OTGSC_AVVIS_Pos = 0x11
	// Bit mask of AVVIS field.
	USB_OTGSC_AVVIS_Msk = 0x20000
	// Bit AVVIS.
	USB_OTGSC_AVVIS = 0x20000
	// Position of ASVIS field.
	USB_OTGSC_ASVIS_Pos = 0x12
	// Bit mask of ASVIS field.
	USB_OTGSC_ASVIS_Msk = 0x40000
	// Bit ASVIS.
	USB_OTGSC_ASVIS = 0x40000
	// Position of BSVIS field.
	USB_OTGSC_BSVIS_Pos = 0x13
	// Bit mask of BSVIS field.
	USB_OTGSC_BSVIS_Msk = 0x80000
	// Bit BSVIS.
	USB_OTGSC_BSVIS = 0x80000
	// Position of BSEIS field.
	USB_OTGSC_BSEIS_Pos = 0x14
	// Bit mask of BSEIS field.
	USB_OTGSC_BSEIS_Msk = 0x100000
	// Bit BSEIS.
	USB_OTGSC_BSEIS = 0x100000
	// Position of STATUS_1MS field.
	USB_OTGSC_STATUS_1MS_Pos = 0x15
	// Bit mask of STATUS_1MS field.
	USB_OTGSC_STATUS_1MS_Msk = 0x200000
	// Bit STATUS_1MS.
	USB_OTGSC_STATUS_1MS = 0x200000
	// Position of DPIS field.
	USB_OTGSC_DPIS_Pos = 0x16
	// Bit mask of DPIS field.
	USB_OTGSC_DPIS_Msk = 0x400000
	// Bit DPIS.
	USB_OTGSC_DPIS = 0x400000
	// Position of IDIE field.
	USB_OTGSC_IDIE_Pos = 0x18
	// Bit mask of IDIE field.
	USB_OTGSC_IDIE_Msk = 0x1000000
	// Bit IDIE.
	USB_OTGSC_IDIE = 0x1000000
	// Position of AVVIE field.
	USB_OTGSC_AVVIE_Pos = 0x19
	// Bit mask of AVVIE field.
	USB_OTGSC_AVVIE_Msk = 0x2000000
	// Bit AVVIE.
	USB_OTGSC_AVVIE = 0x2000000
	// Position of ASVIE field.
	USB_OTGSC_ASVIE_Pos = 0x1a
	// Bit mask of ASVIE field.
	USB_OTGSC_ASVIE_Msk = 0x4000000
	// Bit ASVIE.
	USB_OTGSC_ASVIE = 0x4000000
	// Position of BSVIE field.
	USB_OTGSC_BSVIE_Pos = 0x1b
	// Bit mask of BSVIE field.
	USB_OTGSC_BSVIE_Msk = 0x8000000
	// Bit BSVIE.
	USB_OTGSC_BSVIE = 0x8000000
	// Position of BSEIE field.
	USB_OTGSC_BSEIE_Pos = 0x1c
	// Bit mask of BSEIE field.
	USB_OTGSC_BSEIE_Msk = 0x10000000
	// Bit BSEIE.
	USB_OTGSC_BSEIE = 0x10000000
	// Position of EN_1MS field.
	USB_OTGSC_EN_1MS_Pos = 0x1d
	// Bit mask of EN_1MS field.
	USB_OTGSC_EN_1MS_Msk = 0x20000000
	// Bit EN_1MS.
	USB_OTGSC_EN_1MS = 0x20000000
	// Position of DPIE field.
	USB_OTGSC_DPIE_Pos = 0x1e
	// Bit mask of DPIE field.
	USB_OTGSC_DPIE_Msk = 0x40000000
	// Bit DPIE.
	USB_OTGSC_DPIE = 0x40000000

	// USBMODE: USB Device Mode
	// Position of CM field.
	USB_USBMODE_CM_Pos = 0x0
	// Bit mask of CM field.
	USB_USBMODE_CM_Msk = 0x3
	// Idle [Default for combination host/device]
	USB_USBMODE_CM_CM_0 = 0x0
	// Device Controller [Default for device only controller]
	USB_USBMODE_CM_CM_2 = 0x2
	// Host Controller [Default for host only controller]
	USB_USBMODE_CM_CM_3 = 0x3
	// Position of ES field.
	USB_USBMODE_ES_Pos = 0x2
	// Bit mask of ES field.
	USB_USBMODE_ES_Msk = 0x4
	// Bit ES.
	USB_USBMODE_ES = 0x4
	// Little Endian [Default]
	USB_USBMODE_ES_ES_0 = 0x0
	// Big Endian
	USB_USBMODE_ES_ES_1 = 0x1
	// Position of SLOM field.
	USB_USBMODE_SLOM_Pos = 0x3
	// Bit mask of SLOM field.
	USB_USBMODE_SLOM_Msk = 0x8
	// Bit SLOM.
	USB_USBMODE_SLOM = 0x8
	// Setup Lockouts On (default);
	USB_USBMODE_SLOM_SLOM_0 = 0x0
	// Setup Lockouts Off (DCD requires use of Setup Data Buffer Tripwire in USBCMDUSB Command Register .
	USB_USBMODE_SLOM_SLOM_1 = 0x1
	// Position of SDIS field.
	USB_USBMODE_SDIS_Pos = 0x4
	// Bit mask of SDIS field.
	USB_USBMODE_SDIS_Msk = 0x10
	// Bit SDIS.
	USB_USBMODE_SDIS = 0x10

	// ENDPTSETUPSTAT: Endpoint Setup Status
	// Position of ENDPTSETUPSTAT field.
	USB_ENDPTSETUPSTAT_ENDPTSETUPSTAT_Pos = 0x0
	// Bit mask of ENDPTSETUPSTAT field.
	USB_ENDPTSETUPSTAT_ENDPTSETUPSTAT_Msk = 0xffff

	// ENDPTPRIME: Endpoint Prime
	// Position of PERB field.
	USB_ENDPTPRIME_PERB_Pos = 0x0
	// Bit mask of PERB field.
	USB_ENDPTPRIME_PERB_Msk = 0xff
	// Position of PETB field.
	USB_ENDPTPRIME_PETB_Pos = 0x10
	// Bit mask of PETB field.
	USB_ENDPTPRIME_PETB_Msk = 0xff0000

	// ENDPTFLUSH: Endpoint Flush
	// Position of FERB field.
	USB_ENDPTFLUSH_FERB_Pos = 0x0
	// Bit mask of FERB field.
	USB_ENDPTFLUSH_FERB_Msk = 0xff
	// Position of FETB field.
	USB_ENDPTFLUSH_FETB_Pos = 0x10
	// Bit mask of FETB field.
	USB_ENDPTFLUSH_FETB_Msk = 0xff0000

	// ENDPTSTAT: Endpoint Status
	// Position of ERBR field.
	USB_ENDPTSTAT_ERBR_Pos = 0x0
	// Bit mask of ERBR field.
	USB_ENDPTSTAT_ERBR_Msk = 0xff
	// Position of ETBR field.
	USB_ENDPTSTAT_ETBR_Pos = 0x10
	// Bit mask of ETBR field.
	USB_ENDPTSTAT_ETBR_Msk = 0xff0000

	// ENDPTCOMPLETE: Endpoint Complete
	// Position of ERCE field.
	USB_ENDPTCOMPLETE_ERCE_Pos = 0x0
	// Bit mask of ERCE field.
	USB_ENDPTCOMPLETE_ERCE_Msk = 0xff
	// Position of ETCE field.
	USB_ENDPTCOMPLETE_ETCE_Pos = 0x10
	// Bit mask of ETCE field.
	USB_ENDPTCOMPLETE_ETCE_Msk = 0xff0000

	// ENDPTCTRL0: Endpoint Control0
	// Position of RXS field.
	USB_ENDPTCTRL0_RXS_Pos = 0x0
	// Bit mask of RXS field.
	USB_ENDPTCTRL0_RXS_Msk = 0x1
	// Bit RXS.
	USB_ENDPTCTRL0_RXS = 0x1
	// Position of RXT field.
	USB_ENDPTCTRL0_RXT_Pos = 0x2
	// Bit mask of RXT field.
	USB_ENDPTCTRL0_RXT_Msk = 0xc
	// Position of RXE field.
	USB_ENDPTCTRL0_RXE_Pos = 0x7
	// Bit mask of RXE field.
	USB_ENDPTCTRL0_RXE_Msk = 0x80
	// Bit RXE.
	USB_ENDPTCTRL0_RXE = 0x80
	// Position of TXS field.
	USB_ENDPTCTRL0_TXS_Pos = 0x10
	// Bit mask of TXS field.
	USB_ENDPTCTRL0_TXS_Msk = 0x10000
	// Bit TXS.
	USB_ENDPTCTRL0_TXS = 0x10000
	// Position of TXT field.
	USB_ENDPTCTRL0_TXT_Pos = 0x12
	// Bit mask of TXT field.
	USB_ENDPTCTRL0_TXT_Msk = 0xc0000
	// Position of TXE field.
	USB_ENDPTCTRL0_TXE_Pos = 0x17
	// Bit mask of TXE field.
	USB_ENDPTCTRL0_TXE_Msk = 0x800000
	// Bit TXE.
	USB_ENDPTCTRL0_TXE = 0x800000

	// ENDPTCTRL1: Endpoint Control 1
	// Position of RXS field.
	USB_ENDPTCTRL1_RXS_Pos = 0x0
	// Bit mask of RXS field.
	USB_ENDPTCTRL1_RXS_Msk = 0x1
	// Bit RXS.
	USB_ENDPTCTRL1_RXS = 0x1
	// Position of RXD field.
	USB_ENDPTCTRL1_RXD_Pos = 0x1
	// Bit mask of RXD field.
	USB_ENDPTCTRL1_RXD_Msk = 0x2
	// Bit RXD.
	USB_ENDPTCTRL1_RXD = 0x2
	// Position of RXT field.
	USB_ENDPTCTRL1_RXT_Pos = 0x2
	// Bit mask of RXT field.
	USB_ENDPTCTRL1_RXT_Msk = 0xc
	// Position of RXI field.
	USB_ENDPTCTRL1_RXI_Pos = 0x5
	// Bit mask of RXI field.
	USB_ENDPTCTRL1_RXI_Msk = 0x20
	// Bit RXI.
	USB_ENDPTCTRL1_RXI = 0x20
	// Position of RXR field.
	USB_ENDPTCTRL1_RXR_Pos = 0x6
	// Bit mask of RXR field.
	USB_ENDPTCTRL1_RXR_Msk = 0x40
	// Bit RXR.
	USB_ENDPTCTRL1_RXR = 0x40
	// Position of RXE field.
	USB_ENDPTCTRL1_RXE_Pos = 0x7
	// Bit mask of RXE field.
	USB_ENDPTCTRL1_RXE_Msk = 0x80
	// Bit RXE.
	USB_ENDPTCTRL1_RXE = 0x80
	// Position of TXS field.
	USB_ENDPTCTRL1_TXS_Pos = 0x10
	// Bit mask of TXS field.
	USB_ENDPTCTRL1_TXS_Msk = 0x10000
	// Bit TXS.
	USB_ENDPTCTRL1_TXS = 0x10000
	// Position of TXD field.
	USB_ENDPTCTRL1_TXD_Pos = 0x11
	// Bit mask of TXD field.
	USB_ENDPTCTRL1_TXD_Msk = 0x20000
	// Bit TXD.
	USB_ENDPTCTRL1_TXD = 0x20000
	// Position of TXT field.
	USB_ENDPTCTRL1_TXT_Pos = 0x12
	// Bit mask of TXT field.
	USB_ENDPTCTRL1_TXT_Msk = 0xc0000
	// Position of TXI field.
	USB_ENDPTCTRL1_TXI_Pos = 0x15
	// Bit mask of TXI field.
	USB_ENDPTCTRL1_TXI_Msk = 0x200000
	// Bit TXI.
	USB_ENDPTCTRL1_TXI = 0x200000
	// Position of TXR field.
	USB_ENDPTCTRL1_TXR_Pos = 0x16
	// Bit mask of TXR field.
	USB_ENDPTCTRL1_TXR_Msk = 0x400000
	// Bit TXR.
	USB_ENDPTCTRL1_TXR = 0x400000
	// Position of TXE field.
	USB_ENDPTCTRL1_TXE_Pos = 0x17
	// Bit mask of TXE field.
	USB_ENDPTCTRL1_TXE_Msk = 0x800000
	// Bit TXE.
	USB_ENDPTCTRL1_TXE = 0x800000

	// ENDPTCTRL2: Endpoint Control 2
	// Position of RXS field.
	USB_ENDPTCTRL2_RXS_Pos = 0x0
	// Bit mask of RXS field.
	USB_ENDPTCTRL2_RXS_Msk = 0x1
	// Bit RXS.
	USB_ENDPTCTRL2_RXS = 0x1
	// Position of RXD field.
	USB_ENDPTCTRL2_RXD_Pos = 0x1
	// Bit mask of RXD field.
	USB_ENDPTCTRL2_RXD_Msk = 0x2
	// Bit RXD.
	USB_ENDPTCTRL2_RXD = 0x2
	// Position of RXT field.
	USB_ENDPTCTRL2_RXT_Pos = 0x2
	// Bit mask of RXT field.
	USB_ENDPTCTRL2_RXT_Msk = 0xc
	// Position of RXI field.
	USB_ENDPTCTRL2_RXI_Pos = 0x5
	// Bit mask of RXI field.
	USB_ENDPTCTRL2_RXI_Msk = 0x20
	// Bit RXI.
	USB_ENDPTCTRL2_RXI = 0x20
	// Position of RXR field.
	USB_ENDPTCTRL2_RXR_Pos = 0x6
	// Bit mask of RXR field.
	USB_ENDPTCTRL2_RXR_Msk = 0x40
	// Bit RXR.
	USB_ENDPTCTRL2_RXR = 0x40
	// Position of RXE field.
	USB_ENDPTCTRL2_RXE_Pos = 0x7
	// Bit mask of RXE field.
	USB_ENDPTCTRL2_RXE_Msk = 0x80
	// Bit RXE.
	USB_ENDPTCTRL2_RXE = 0x80
	// Position of TXS field.
	USB_ENDPTCTRL2_TXS_Pos = 0x10
	// Bit mask of TXS field.
	USB_ENDPTCTRL2_TXS_Msk = 0x10000
	// Bit TXS.
	USB_ENDPTCTRL2_TXS = 0x10000
	// Position of TXD field.
	USB_ENDPTCTRL2_TXD_Pos = 0x11
	// Bit mask of TXD field.
	USB_ENDPTCTRL2_TXD_Msk = 0x20000
	// Bit TXD.
	USB_ENDPTCTRL2_TXD = 0x20000
	// Position of TXT field.
	USB_ENDPTCTRL2_TXT_Pos = 0x12
	// Bit mask of TXT field.
	USB_ENDPTCTRL2_TXT_Msk = 0xc0000
	// Position of TXI field.
	USB_ENDPTCTRL2_TXI_Pos = 0x15
	// Bit mask of TXI field.
	USB_ENDPTCTRL2_TXI_Msk = 0x200000
	// Bit TXI.
	USB_ENDPTCTRL2_TXI = 0x200000
	// Position of TXR field.
	USB_ENDPTCTRL2_TXR_Pos = 0x16
	// Bit mask of TXR field.
	USB_ENDPTCTRL2_TXR_Msk = 0x400000
	// Bit TXR.
	USB_ENDPTCTRL2_TXR = 0x400000
	// Position of TXE field.
	USB_ENDPTCTRL2_TXE_Pos = 0x17
	// Bit mask of TXE field.
	USB_ENDPTCTRL2_TXE_Msk = 0x800000
	// Bit TXE.
	USB_ENDPTCTRL2_TXE = 0x800000

	// ENDPTCTRL3: Endpoint Control 3
	// Position of RXS field.
	USB_ENDPTCTRL3_RXS_Pos = 0x0
	// Bit mask of RXS field.
	USB_ENDPTCTRL3_RXS_Msk = 0x1
	// Bit RXS.
	USB_ENDPTCTRL3_RXS = 0x1
	// Position of RXD field.
	USB_ENDPTCTRL3_RXD_Pos = 0x1
	// Bit mask of RXD field.
	USB_ENDPTCTRL3_RXD_Msk = 0x2
	// Bit RXD.
	USB_ENDPTCTRL3_RXD = 0x2
	// Position of RXT field.
	USB_ENDPTCTRL3_RXT_Pos = 0x2
	// Bit mask of RXT field.
	USB_ENDPTCTRL3_RXT_Msk = 0xc
	// Position of RXI field.
	USB_ENDPTCTRL3_RXI_Pos = 0x5
	// Bit mask of RXI field.
	USB_ENDPTCTRL3_RXI_Msk = 0x20
	// Bit RXI.
	USB_ENDPTCTRL3_RXI = 0x20
	// Position of RXR field.
	USB_ENDPTCTRL3_RXR_Pos = 0x6
	// Bit mask of RXR field.
	USB_ENDPTCTRL3_RXR_Msk = 0x40
	// Bit RXR.
	USB_ENDPTCTRL3_RXR = 0x40
	// Position of RXE field.
	USB_ENDPTCTRL3_RXE_Pos = 0x7
	// Bit mask of RXE field.
	USB_ENDPTCTRL3_RXE_Msk = 0x80
	// Bit RXE.
	USB_ENDPTCTRL3_RXE = 0x80
	// Position of TXS field.
	USB_ENDPTCTRL3_TXS_Pos = 0x10
	// Bit mask of TXS field.
	USB_ENDPTCTRL3_TXS_Msk = 0x10000
	// Bit TXS.
	USB_ENDPTCTRL3_TXS = 0x10000
	// Position of TXD field.
	USB_ENDPTCTRL3_TXD_Pos = 0x11
	// Bit mask of TXD field.
	USB_ENDPTCTRL3_TXD_Msk = 0x20000
	// Bit TXD.
	USB_ENDPTCTRL3_TXD = 0x20000
	// Position of TXT field.
	USB_ENDPTCTRL3_TXT_Pos = 0x12
	// Bit mask of TXT field.
	USB_ENDPTCTRL3_TXT_Msk = 0xc0000
	// Position of TXI field.
	USB_ENDPTCTRL3_TXI_Pos = 0x15
	// Bit mask of TXI field.
	USB_ENDPTCTRL3_TXI_Msk = 0x200000
	// Bit TXI.
	USB_ENDPTCTRL3_TXI = 0x200000
	// Position of TXR field.
	USB_ENDPTCTRL3_TXR_Pos = 0x16
	// Bit mask of TXR field.
	USB_ENDPTCTRL3_TXR_Msk = 0x400000
	// Bit TXR.
	USB_ENDPTCTRL3_TXR = 0x400000
	// Position of TXE field.
	USB_ENDPTCTRL3_TXE_Pos = 0x17
	// Bit mask of TXE field.
	USB_ENDPTCTRL3_TXE_Msk = 0x800000
	// Bit TXE.
	USB_ENDPTCTRL3_TXE = 0x800000

	// ENDPTCTRL4: Endpoint Control 4
	// Position of RXS field.
	USB_ENDPTCTRL4_RXS_Pos = 0x0
	// Bit mask of RXS field.
	USB_ENDPTCTRL4_RXS_Msk = 0x1
	// Bit RXS.
	USB_ENDPTCTRL4_RXS = 0x1
	// Position of RXD field.
	USB_ENDPTCTRL4_RXD_Pos = 0x1
	// Bit mask of RXD field.
	USB_ENDPTCTRL4_RXD_Msk = 0x2
	// Bit RXD.
	USB_ENDPTCTRL4_RXD = 0x2
	// Position of RXT field.
	USB_ENDPTCTRL4_RXT_Pos = 0x2
	// Bit mask of RXT field.
	USB_ENDPTCTRL4_RXT_Msk = 0xc
	// Position of RXI field.
	USB_ENDPTCTRL4_RXI_Pos = 0x5
	// Bit mask of RXI field.
	USB_ENDPTCTRL4_RXI_Msk = 0x20
	// Bit RXI.
	USB_ENDPTCTRL4_RXI = 0x20
	// Position of RXR field.
	USB_ENDPTCTRL4_RXR_Pos = 0x6
	// Bit mask of RXR field.
	USB_ENDPTCTRL4_RXR_Msk = 0x40
	// Bit RXR.
	USB_ENDPTCTRL4_RXR = 0x40
	// Position of RXE field.
	USB_ENDPTCTRL4_RXE_Pos = 0x7
	// Bit mask of RXE field.
	USB_ENDPTCTRL4_RXE_Msk = 0x80
	// Bit RXE.
	USB_ENDPTCTRL4_RXE = 0x80
	// Position of TXS field.
	USB_ENDPTCTRL4_TXS_Pos = 0x10
	// Bit mask of TXS field.
	USB_ENDPTCTRL4_TXS_Msk = 0x10000
	// Bit TXS.
	USB_ENDPTCTRL4_TXS = 0x10000
	// Position of TXD field.
	USB_ENDPTCTRL4_TXD_Pos = 0x11
	// Bit mask of TXD field.
	USB_ENDPTCTRL4_TXD_Msk = 0x20000
	// Bit TXD.
	USB_ENDPTCTRL4_TXD = 0x20000
	// Position of TXT field.
	USB_ENDPTCTRL4_TXT_Pos = 0x12
	// Bit mask of TXT field.
	USB_ENDPTCTRL4_TXT_Msk = 0xc0000
	// Position of TXI field.
	USB_ENDPTCTRL4_TXI_Pos = 0x15
	// Bit mask of TXI field.
	USB_ENDPTCTRL4_TXI_Msk = 0x200000
	// Bit TXI.
	USB_ENDPTCTRL4_TXI = 0x200000
	// Position of TXR field.
	USB_ENDPTCTRL4_TXR_Pos = 0x16
	// Bit mask of TXR field.
	USB_ENDPTCTRL4_TXR_Msk = 0x400000
	// Bit TXR.
	USB_ENDPTCTRL4_TXR = 0x400000
	// Position of TXE field.
	USB_ENDPTCTRL4_TXE_Pos = 0x17
	// Bit mask of TXE field.
	USB_ENDPTCTRL4_TXE_Msk = 0x800000
	// Bit TXE.
	USB_ENDPTCTRL4_TXE = 0x800000

	// ENDPTCTRL5: Endpoint Control 5
	// Position of RXS field.
	USB_ENDPTCTRL5_RXS_Pos = 0x0
	// Bit mask of RXS field.
	USB_ENDPTCTRL5_RXS_Msk = 0x1
	// Bit RXS.
	USB_ENDPTCTRL5_RXS = 0x1
	// Position of RXD field.
	USB_ENDPTCTRL5_RXD_Pos = 0x1
	// Bit mask of RXD field.
	USB_ENDPTCTRL5_RXD_Msk = 0x2
	// Bit RXD.
	USB_ENDPTCTRL5_RXD = 0x2
	// Position of RXT field.
	USB_ENDPTCTRL5_RXT_Pos = 0x2
	// Bit mask of RXT field.
	USB_ENDPTCTRL5_RXT_Msk = 0xc
	// Position of RXI field.
	USB_ENDPTCTRL5_RXI_Pos = 0x5
	// Bit mask of RXI field.
	USB_ENDPTCTRL5_RXI_Msk = 0x20
	// Bit RXI.
	USB_ENDPTCTRL5_RXI = 0x20
	// Position of RXR field.
	USB_ENDPTCTRL5_RXR_Pos = 0x6
	// Bit mask of RXR field.
	USB_ENDPTCTRL5_RXR_Msk = 0x40
	// Bit RXR.
	USB_ENDPTCTRL5_RXR = 0x40
	// Position of RXE field.
	USB_ENDPTCTRL5_RXE_Pos = 0x7
	// Bit mask of RXE field.
	USB_ENDPTCTRL5_RXE_Msk = 0x80
	// Bit RXE.
	USB_ENDPTCTRL5_RXE = 0x80
	// Position of TXS field.
	USB_ENDPTCTRL5_TXS_Pos = 0x10
	// Bit mask of TXS field.
	USB_ENDPTCTRL5_TXS_Msk = 0x10000
	// Bit TXS.
	USB_ENDPTCTRL5_TXS = 0x10000
	// Position of TXD field.
	USB_ENDPTCTRL5_TXD_Pos = 0x11
	// Bit mask of TXD field.
	USB_ENDPTCTRL5_TXD_Msk = 0x20000
	// Bit TXD.
	USB_ENDPTCTRL5_TXD = 0x20000
	// Position of TXT field.
	USB_ENDPTCTRL5_TXT_Pos = 0x12
	// Bit mask of TXT field.
	USB_ENDPTCTRL5_TXT_Msk = 0xc0000
	// Position of TXI field.
	USB_ENDPTCTRL5_TXI_Pos = 0x15
	// Bit mask of TXI field.
	USB_ENDPTCTRL5_TXI_Msk = 0x200000
	// Bit TXI.
	USB_ENDPTCTRL5_TXI = 0x200000
	// Position of TXR field.
	USB_ENDPTCTRL5_TXR_Pos = 0x16
	// Bit mask of TXR field.
	USB_ENDPTCTRL5_TXR_Msk = 0x400000
	// Bit TXR.
	USB_ENDPTCTRL5_TXR = 0x400000
	// Position of TXE field.
	USB_ENDPTCTRL5_TXE_Pos = 0x17
	// Bit mask of TXE field.
	USB_ENDPTCTRL5_TXE_Msk = 0x800000
	// Bit TXE.
	USB_ENDPTCTRL5_TXE = 0x800000

	// ENDPTCTRL6: Endpoint Control 6
	// Position of RXS field.
	USB_ENDPTCTRL6_RXS_Pos = 0x0
	// Bit mask of RXS field.
	USB_ENDPTCTRL6_RXS_Msk = 0x1
	// Bit RXS.
	USB_ENDPTCTRL6_RXS = 0x1
	// Position of RXD field.
	USB_ENDPTCTRL6_RXD_Pos = 0x1
	// Bit mask of RXD field.
	USB_ENDPTCTRL6_RXD_Msk = 0x2
	// Bit RXD.
	USB_ENDPTCTRL6_RXD = 0x2
	// Position of RXT field.
	USB_ENDPTCTRL6_RXT_Pos = 0x2
	// Bit mask of RXT field.
	USB_ENDPTCTRL6_RXT_Msk = 0xc
	// Position of RXI field.
	USB_ENDPTCTRL6_RXI_Pos = 0x5
	// Bit mask of RXI field.
	USB_ENDPTCTRL6_RXI_Msk = 0x20
	// Bit RXI.
	USB_ENDPTCTRL6_RXI = 0x20
	// Position of RXR field.
	USB_ENDPTCTRL6_RXR_Pos = 0x6
	// Bit mask of RXR field.
	USB_ENDPTCTRL6_RXR_Msk = 0x40
	// Bit RXR.
	USB_ENDPTCTRL6_RXR = 0x40
	// Position of RXE field.
	USB_ENDPTCTRL6_RXE_Pos = 0x7
	// Bit mask of RXE field.
	USB_ENDPTCTRL6_RXE_Msk = 0x80
	// Bit RXE.
	USB_ENDPTCTRL6_RXE = 0x80
	// Position of TXS field.
	USB_ENDPTCTRL6_TXS_Pos = 0x10
	// Bit mask of TXS field.
	USB_ENDPTCTRL6_TXS_Msk = 0x10000
	// Bit TXS.
	USB_ENDPTCTRL6_TXS = 0x10000
	// Position of TXD field.
	USB_ENDPTCTRL6_TXD_Pos = 0x11
	// Bit mask of TXD field.
	USB_ENDPTCTRL6_TXD_Msk = 0x20000
	// Bit TXD.
	USB_ENDPTCTRL6_TXD = 0x20000
	// Position of TXT field.
	USB_ENDPTCTRL6_TXT_Pos = 0x12
	// Bit mask of TXT field.
	USB_ENDPTCTRL6_TXT_Msk = 0xc0000
	// Position of TXI field.
	USB_ENDPTCTRL6_TXI_Pos = 0x15
	// Bit mask of TXI field.
	USB_ENDPTCTRL6_TXI_Msk = 0x200000
	// Bit TXI.
	USB_ENDPTCTRL6_TXI = 0x200000
	// Position of TXR field.
	USB_ENDPTCTRL6_TXR_Pos = 0x16
	// Bit mask of TXR field.
	USB_ENDPTCTRL6_TXR_Msk = 0x400000
	// Bit TXR.
	USB_ENDPTCTRL6_TXR = 0x400000
	// Position of TXE field.
	USB_ENDPTCTRL6_TXE_Pos = 0x17
	// Bit mask of TXE field.
	USB_ENDPTCTRL6_TXE_Msk = 0x800000
	// Bit TXE.
	USB_ENDPTCTRL6_TXE = 0x800000

	// ENDPTCTRL7: Endpoint Control 7
	// Position of RXS field.
	USB_ENDPTCTRL7_RXS_Pos = 0x0
	// Bit mask of RXS field.
	USB_ENDPTCTRL7_RXS_Msk = 0x1
	// Bit RXS.
	USB_ENDPTCTRL7_RXS = 0x1
	// Position of RXD field.
	USB_ENDPTCTRL7_RXD_Pos = 0x1
	// Bit mask of RXD field.
	USB_ENDPTCTRL7_RXD_Msk = 0x2
	// Bit RXD.
	USB_ENDPTCTRL7_RXD = 0x2
	// Position of RXT field.
	USB_ENDPTCTRL7_RXT_Pos = 0x2
	// Bit mask of RXT field.
	USB_ENDPTCTRL7_RXT_Msk = 0xc
	// Position of RXI field.
	USB_ENDPTCTRL7_RXI_Pos = 0x5
	// Bit mask of RXI field.
	USB_ENDPTCTRL7_RXI_Msk = 0x20
	// Bit RXI.
	USB_ENDPTCTRL7_RXI = 0x20
	// Position of RXR field.
	USB_ENDPTCTRL7_RXR_Pos = 0x6
	// Bit mask of RXR field.
	USB_ENDPTCTRL7_RXR_Msk = 0x40
	// Bit RXR.
	USB_ENDPTCTRL7_RXR = 0x40
	// Position of RXE field.
	USB_ENDPTCTRL7_RXE_Pos = 0x7
	// Bit mask of RXE field.
	USB_ENDPTCTRL7_RXE_Msk = 0x80
	// Bit RXE.
	USB_ENDPTCTRL7_RXE = 0x80
	// Position of TXS field.
	USB_ENDPTCTRL7_TXS_Pos = 0x10
	// Bit mask of TXS field.
	USB_ENDPTCTRL7_TXS_Msk = 0x10000
	// Bit TXS.
	USB_ENDPTCTRL7_TXS = 0x10000
	// Position of TXD field.
	USB_ENDPTCTRL7_TXD_Pos = 0x11
	// Bit mask of TXD field.
	USB_ENDPTCTRL7_TXD_Msk = 0x20000
	// Bit TXD.
	USB_ENDPTCTRL7_TXD = 0x20000
	// Position of TXT field.
	USB_ENDPTCTRL7_TXT_Pos = 0x12
	// Bit mask of TXT field.
	USB_ENDPTCTRL7_TXT_Msk = 0xc0000
	// Position of TXI field.
	USB_ENDPTCTRL7_TXI_Pos = 0x15
	// Bit mask of TXI field.
	USB_ENDPTCTRL7_TXI_Msk = 0x200000
	// Bit TXI.
	USB_ENDPTCTRL7_TXI = 0x200000
	// Position of TXR field.
	USB_ENDPTCTRL7_TXR_Pos = 0x16
	// Bit mask of TXR field.
	USB_ENDPTCTRL7_TXR_Msk = 0x400000
	// Bit TXR.
	USB_ENDPTCTRL7_TXR = 0x400000
	// Position of TXE field.
	USB_ENDPTCTRL7_TXE_Pos = 0x17
	// Bit mask of TXE field.
	USB_ENDPTCTRL7_TXE_Msk = 0x800000
	// Bit TXE.
	USB_ENDPTCTRL7_TXE = 0x800000
)

// Constants for USBNC: USB
const (
	// USB_OTG1_CTRL: USB OTG1 Control Register
	// Position of OVER_CUR_DIS field.
	USBNC_USB_OTG1_CTRL_OVER_CUR_DIS_Pos = 0x7
	// Bit mask of OVER_CUR_DIS field.
	USBNC_USB_OTG1_CTRL_OVER_CUR_DIS_Msk = 0x80
	// Bit OVER_CUR_DIS.
	USBNC_USB_OTG1_CTRL_OVER_CUR_DIS = 0x80
	// Enables overcurrent detection
	USBNC_USB_OTG1_CTRL_OVER_CUR_DIS_OVER_CUR_DIS_0 = 0x0
	// Disables overcurrent detection
	USBNC_USB_OTG1_CTRL_OVER_CUR_DIS_OVER_CUR_DIS_1 = 0x1
	// Position of OVER_CUR_POL field.
	USBNC_USB_OTG1_CTRL_OVER_CUR_POL_Pos = 0x8
	// Bit mask of OVER_CUR_POL field.
	USBNC_USB_OTG1_CTRL_OVER_CUR_POL_Msk = 0x100
	// Bit OVER_CUR_POL.
	USBNC_USB_OTG1_CTRL_OVER_CUR_POL = 0x100
	// High active (high on this signal represents an overcurrent condition)
	USBNC_USB_OTG1_CTRL_OVER_CUR_POL_OVER_CUR_POL_0 = 0x0
	// Low active (low on this signal represents an overcurrent condition)
	USBNC_USB_OTG1_CTRL_OVER_CUR_POL_OVER_CUR_POL_1 = 0x1
	// Position of PWR_POL field.
	USBNC_USB_OTG1_CTRL_PWR_POL_Pos = 0x9
	// Bit mask of PWR_POL field.
	USBNC_USB_OTG1_CTRL_PWR_POL_Msk = 0x200
	// Bit PWR_POL.
	USBNC_USB_OTG1_CTRL_PWR_POL = 0x200
	// PMIC Power Pin is Low active.
	USBNC_USB_OTG1_CTRL_PWR_POL_PWR_POL_0 = 0x0
	// PMIC Power Pin is High active.
	USBNC_USB_OTG1_CTRL_PWR_POL_PWR_POL_1 = 0x1
	// Position of WIE field.
	USBNC_USB_OTG1_CTRL_WIE_Pos = 0xa
	// Bit mask of WIE field.
	USBNC_USB_OTG1_CTRL_WIE_Msk = 0x400
	// Bit WIE.
	USBNC_USB_OTG1_CTRL_WIE = 0x400
	// Interrupt Disabled
	USBNC_USB_OTG1_CTRL_WIE_WIE_0 = 0x0
	// Interrupt Enabled
	USBNC_USB_OTG1_CTRL_WIE_WIE_1 = 0x1
	// Position of WKUP_SW_EN field.
	USBNC_USB_OTG1_CTRL_WKUP_SW_EN_Pos = 0xe
	// Bit mask of WKUP_SW_EN field.
	USBNC_USB_OTG1_CTRL_WKUP_SW_EN_Msk = 0x4000
	// Bit WKUP_SW_EN.
	USBNC_USB_OTG1_CTRL_WKUP_SW_EN = 0x4000
	// Disable
	USBNC_USB_OTG1_CTRL_WKUP_SW_EN_WKUP_SW_EN_0 = 0x0
	// Enable
	USBNC_USB_OTG1_CTRL_WKUP_SW_EN_WKUP_SW_EN_1 = 0x1
	// Position of WKUP_SW field.
	USBNC_USB_OTG1_CTRL_WKUP_SW_Pos = 0xf
	// Bit mask of WKUP_SW field.
	USBNC_USB_OTG1_CTRL_WKUP_SW_Msk = 0x8000
	// Bit WKUP_SW.
	USBNC_USB_OTG1_CTRL_WKUP_SW = 0x8000
	// Inactive
	USBNC_USB_OTG1_CTRL_WKUP_SW_WKUP_SW_0 = 0x0
	// Force wake-up
	USBNC_USB_OTG1_CTRL_WKUP_SW_WKUP_SW_1 = 0x1
	// Position of WKUP_ID_EN field.
	USBNC_USB_OTG1_CTRL_WKUP_ID_EN_Pos = 0x10
	// Bit mask of WKUP_ID_EN field.
	USBNC_USB_OTG1_CTRL_WKUP_ID_EN_Msk = 0x10000
	// Bit WKUP_ID_EN.
	USBNC_USB_OTG1_CTRL_WKUP_ID_EN = 0x10000
	// Disable
	USBNC_USB_OTG1_CTRL_WKUP_ID_EN_WKUP_ID_EN_0 = 0x0
	// Enable
	USBNC_USB_OTG1_CTRL_WKUP_ID_EN_WKUP_ID_EN_1 = 0x1
	// Position of WKUP_VBUS_EN field.
	USBNC_USB_OTG1_CTRL_WKUP_VBUS_EN_Pos = 0x11
	// Bit mask of WKUP_VBUS_EN field.
	USBNC_USB_OTG1_CTRL_WKUP_VBUS_EN_Msk = 0x20000
	// Bit WKUP_VBUS_EN.
	USBNC_USB_OTG1_CTRL_WKUP_VBUS_EN = 0x20000
	// Disable
	USBNC_USB_OTG1_CTRL_WKUP_VBUS_EN_WKUP_VBUS_EN_0 = 0x0
	// Enable
	USBNC_USB_OTG1_CTRL_WKUP_VBUS_EN_WKUP_VBUS_EN_1 = 0x1
	// Position of WKUP_DPDM_EN field.
	USBNC_USB_OTG1_CTRL_WKUP_DPDM_EN_Pos = 0x1d
	// Bit mask of WKUP_DPDM_EN field.
	USBNC_USB_OTG1_CTRL_WKUP_DPDM_EN_Msk = 0x20000000
	// Bit WKUP_DPDM_EN.
	USBNC_USB_OTG1_CTRL_WKUP_DPDM_EN = 0x20000000
	// DPDM changes wake-up to be disabled only when VBUS is 0.
	USBNC_USB_OTG1_CTRL_WKUP_DPDM_EN_WKUP_DPDM_EN_0 = 0x0
	// (Default) DPDM changes wake-up to be enabled, it is for device only.
	USBNC_USB_OTG1_CTRL_WKUP_DPDM_EN_WKUP_DPDM_EN_1 = 0x1
	// Position of WIR field.
	USBNC_USB_OTG1_CTRL_WIR_Pos = 0x1f
	// Bit mask of WIR field.
	USBNC_USB_OTG1_CTRL_WIR_Msk = 0x80000000
	// Bit WIR.
	USBNC_USB_OTG1_CTRL_WIR = 0x80000000
	// No wake-up interrupt request received
	USBNC_USB_OTG1_CTRL_WIR_WIR_0 = 0x0
	// Wake-up Interrupt Request received
	USBNC_USB_OTG1_CTRL_WIR_WIR_1 = 0x1

	// USB_OTG1_PHY_CTRL_0: OTG1 UTMI PHY Control 0 Register
	// Position of UTMI_CLK_VLD field.
	USBNC_USB_OTG1_PHY_CTRL_0_UTMI_CLK_VLD_Pos = 0x1f
	// Bit mask of UTMI_CLK_VLD field.
	USBNC_USB_OTG1_PHY_CTRL_0_UTMI_CLK_VLD_Msk = 0x80000000
	// Bit UTMI_CLK_VLD.
	USBNC_USB_OTG1_PHY_CTRL_0_UTMI_CLK_VLD = 0x80000000
	// Invalid
	USBNC_USB_OTG1_PHY_CTRL_0_UTMI_CLK_VLD_UTMI_CLK_VLD_0 = 0x0
	// Valid
	USBNC_USB_OTG1_PHY_CTRL_0_UTMI_CLK_VLD_UTMI_CLK_VLD_1 = 0x1
)

// Constants for DMA0: DMA
const (
	// CR: Control Register
	// Position of EDBG field.
	DMA_CR_EDBG_Pos = 0x1
	// Bit mask of EDBG field.
	DMA_CR_EDBG_Msk = 0x2
	// Bit EDBG.
	DMA_CR_EDBG = 0x2
	// When in debug mode, the DMA continues to operate.
	DMA_CR_EDBG_EDBG_0 = 0x0
	// When in debug mode, the DMA stalls the start of a new channel. Executing channels are allowed to complete. Channel execution resumes when the system exits debug mode or the EDBG bit is cleared.
	DMA_CR_EDBG_EDBG_1 = 0x1
	// Position of ERCA field.
	DMA_CR_ERCA_Pos = 0x2
	// Bit mask of ERCA field.
	DMA_CR_ERCA_Msk = 0x4
	// Bit ERCA.
	DMA_CR_ERCA = 0x4
	// Fixed priority arbitration is used for channel selection .
	DMA_CR_ERCA_ERCA_0 = 0x0
	// Round robin arbitration is used for channel selection .
	DMA_CR_ERCA_ERCA_1 = 0x1
	// Position of HOE field.
	DMA_CR_HOE_Pos = 0x4
	// Bit mask of HOE field.
	DMA_CR_HOE_Msk = 0x10
	// Bit HOE.
	DMA_CR_HOE = 0x10
	// Normal operation
	DMA_CR_HOE_HOE_0 = 0x0
	// Any error causes the HALT bit to set. Subsequently, all service requests are ignored until the HALT bit is cleared.
	DMA_CR_HOE_HOE_1 = 0x1
	// Position of HALT field.
	DMA_CR_HALT_Pos = 0x5
	// Bit mask of HALT field.
	DMA_CR_HALT_Msk = 0x20
	// Bit HALT.
	DMA_CR_HALT = 0x20
	// Normal operation
	DMA_CR_HALT_HALT_0 = 0x0
	// Stall the start of any new channels. Executing channels are allowed to complete. Channel execution resumes when this bit is cleared.
	DMA_CR_HALT_HALT_1 = 0x1
	// Position of CLM field.
	DMA_CR_CLM_Pos = 0x6
	// Bit mask of CLM field.
	DMA_CR_CLM_Msk = 0x40
	// Bit CLM.
	DMA_CR_CLM = 0x40
	// A minor loop channel link made to itself goes through channel arbitration before being activated again.
	DMA_CR_CLM_CLM_0 = 0x0
	// A minor loop channel link made to itself does not go through channel arbitration before being activated again. Upon minor loop completion, the channel activates again if that channel has a minor loop channel link enabled and the link channel is itself. This effectively applies the minor loop offsets and restarts the next minor loop.
	DMA_CR_CLM_CLM_1 = 0x1
	// Position of EMLM field.
	DMA_CR_EMLM_Pos = 0x7
	// Bit mask of EMLM field.
	DMA_CR_EMLM_Msk = 0x80
	// Bit EMLM.
	DMA_CR_EMLM = 0x80
	// Disabled. TCDn.word2 is defined as a 32-bit NBYTES field.
	DMA_CR_EMLM_EMLM_0 = 0x0
	// Enabled. TCDn.word2 is redefined to include individual enable fields, an offset field, and the NBYTES field. The individual enable fields allow the minor loop offset to be applied to the source address, the destination address, or both. The NBYTES field is reduced when either offset is enabled.
	DMA_CR_EMLM_EMLM_1 = 0x1
	// Position of ECX field.
	DMA_CR_ECX_Pos = 0x10
	// Bit mask of ECX field.
	DMA_CR_ECX_Msk = 0x10000
	// Bit ECX.
	DMA_CR_ECX = 0x10000
	// Normal operation
	DMA_CR_ECX_ECX_0 = 0x0
	// Cancel the remaining data transfer in the same fashion as the CX bit. Stop the executing channel and force the minor loop to finish. The cancel takes effect after the last write of the current read/write sequence. The ECX bit clears itself after the cancel is honored. In addition to cancelling the transfer, ECX treats the cancel as an error condition, thus updating the Error Status register (DMAx_ES) and generating an optional error interrupt.
	DMA_CR_ECX_ECX_1 = 0x1
	// Position of CX field.
	DMA_CR_CX_Pos = 0x11
	// Bit mask of CX field.
	DMA_CR_CX_Msk = 0x20000
	// Bit CX.
	DMA_CR_CX = 0x20000
	// Normal operation
	DMA_CR_CX_CX_0 = 0x0
	// Cancel the remaining data transfer. Stop the executing channel and force the minor loop to finish. The cancel takes effect after the last write of the current read/write sequence. The CX bit clears itself after the cancel has been honored. This cancel retires the channel normally as if the minor loop was completed.
	DMA_CR_CX_CX_1 = 0x1
	// Position of ACTIVE field.
	DMA_CR_ACTIVE_Pos = 0x1f
	// Bit mask of ACTIVE field.
	DMA_CR_ACTIVE_Msk = 0x80000000
	// Bit ACTIVE.
	DMA_CR_ACTIVE = 0x80000000
	// eDMA is idle.
	DMA_CR_ACTIVE_ACTIVE_0 = 0x0
	// eDMA is executing a channel.
	DMA_CR_ACTIVE_ACTIVE_1 = 0x1

	// ES: Error Status Register
	// Position of DBE field.
	DMA_ES_DBE_Pos = 0x0
	// Bit mask of DBE field.
	DMA_ES_DBE_Msk = 0x1
	// Bit DBE.
	DMA_ES_DBE = 0x1
	// No destination bus error
	DMA_ES_DBE_DBE_0 = 0x0
	// The last recorded error was a bus error on a destination write
	DMA_ES_DBE_DBE_1 = 0x1
	// Position of SBE field.
	DMA_ES_SBE_Pos = 0x1
	// Bit mask of SBE field.
	DMA_ES_SBE_Msk = 0x2
	// Bit SBE.
	DMA_ES_SBE = 0x2
	// No source bus error
	DMA_ES_SBE_SBE_0 = 0x0
	// The last recorded error was a bus error on a source read
	DMA_ES_SBE_SBE_1 = 0x1
	// Position of SGE field.
	DMA_ES_SGE_Pos = 0x2
	// Bit mask of SGE field.
	DMA_ES_SGE_Msk = 0x4
	// Bit SGE.
	DMA_ES_SGE = 0x4
	// No scatter/gather configuration error
	DMA_ES_SGE_SGE_0 = 0x0
	// The last recorded error was a configuration error detected in the TCDn_DLASTSGA field. This field is checked at the beginning of a scatter/gather operation after major loop completion if TCDn_CSR[ESG] is enabled. TCDn_DLASTSGA is not on a 32 byte boundary.
	DMA_ES_SGE_SGE_1 = 0x1
	// Position of NCE field.
	DMA_ES_NCE_Pos = 0x3
	// Bit mask of NCE field.
	DMA_ES_NCE_Msk = 0x8
	// Bit NCE.
	DMA_ES_NCE = 0x8
	// No NBYTES/CITER configuration error
	DMA_ES_NCE_NCE_0 = 0x0
	// The last recorded error was a configuration error detected in the TCDn_NBYTES or TCDn_CITER fields. TCDn_NBYTES is not a multiple of TCDn_ATTR[SSIZE] and TCDn_ATTR[DSIZE], or TCDn_CITER[CITER] is equal to zero, or TCDn_CITER[ELINK] is not equal to TCDn_BITER[ELINK]
	DMA_ES_NCE_NCE_1 = 0x1
	// Position of DOE field.
	DMA_ES_DOE_Pos = 0x4
	// Bit mask of DOE field.
	DMA_ES_DOE_Msk = 0x10
	// Bit DOE.
	DMA_ES_DOE = 0x10
	// No destination offset configuration error
	DMA_ES_DOE_DOE_0 = 0x0
	// The last recorded error was a configuration error detected in the TCDn_DOFF field. TCDn_DOFF is inconsistent with TCDn_ATTR[DSIZE].
	DMA_ES_DOE_DOE_1 = 0x1
	// Position of DAE field.
	DMA_ES_DAE_Pos = 0x5
	// Bit mask of DAE field.
	DMA_ES_DAE_Msk = 0x20
	// Bit DAE.
	DMA_ES_DAE = 0x20
	// No destination address configuration error
	DMA_ES_DAE_DAE_0 = 0x0
	// The last recorded error was a configuration error detected in the TCDn_DADDR field. TCDn_DADDR is inconsistent with TCDn_ATTR[DSIZE].
	DMA_ES_DAE_DAE_1 = 0x1
	// Position of SOE field.
	DMA_ES_SOE_Pos = 0x6
	// Bit mask of SOE field.
	DMA_ES_SOE_Msk = 0x40
	// Bit SOE.
	DMA_ES_SOE = 0x40
	// No source offset configuration error
	DMA_ES_SOE_SOE_0 = 0x0
	// The last recorded error was a configuration error detected in the TCDn_SOFF field. TCDn_SOFF is inconsistent with TCDn_ATTR[SSIZE].
	DMA_ES_SOE_SOE_1 = 0x1
	// Position of SAE field.
	DMA_ES_SAE_Pos = 0x7
	// Bit mask of SAE field.
	DMA_ES_SAE_Msk = 0x80
	// Bit SAE.
	DMA_ES_SAE = 0x80
	// No source address configuration error.
	DMA_ES_SAE_SAE_0 = 0x0
	// The last recorded error was a configuration error detected in the TCDn_SADDR field. TCDn_SADDR is inconsistent with TCDn_ATTR[SSIZE].
	DMA_ES_SAE_SAE_1 = 0x1
	// Position of ERRCHN field.
	DMA_ES_ERRCHN_Pos = 0x8
	// Bit mask of ERRCHN field.
	DMA_ES_ERRCHN_Msk = 0xf00
	// Position of CPE field.
	DMA_ES_CPE_Pos = 0xe
	// Bit mask of CPE field.
	DMA_ES_CPE_Msk = 0x4000
	// Bit CPE.
	DMA_ES_CPE = 0x4000
	// No channel priority error
	DMA_ES_CPE_CPE_0 = 0x0
	// The last recorded error was a configuration error in the channel priorities . Channel priorities are not unique.
	DMA_ES_CPE_CPE_1 = 0x1
	// Position of ECX field.
	DMA_ES_ECX_Pos = 0x10
	// Bit mask of ECX field.
	DMA_ES_ECX_Msk = 0x10000
	// Bit ECX.
	DMA_ES_ECX = 0x10000
	// No canceled transfers
	DMA_ES_ECX_ECX_0 = 0x0
	// The last recorded entry was a canceled transfer by the error cancel transfer input
	DMA_ES_ECX_ECX_1 = 0x1
	// Position of VLD field.
	DMA_ES_VLD_Pos = 0x1f
	// Bit mask of VLD field.
	DMA_ES_VLD_Msk = 0x80000000
	// Bit VLD.
	DMA_ES_VLD = 0x80000000
	// No ERR bits are set.
	DMA_ES_VLD_VLD_0 = 0x0
	// At least one ERR bit is set indicating a valid error exists that has not been cleared.
	DMA_ES_VLD_VLD_1 = 0x1

	// ERQ: Enable Request Register
	// Position of ERQ0 field.
	DMA_ERQ_ERQ0_Pos = 0x0
	// Bit mask of ERQ0 field.
	DMA_ERQ_ERQ0_Msk = 0x1
	// Bit ERQ0.
	DMA_ERQ_ERQ0 = 0x1
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ0_ERQ0_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ0_ERQ0_1 = 0x1
	// Position of ERQ1 field.
	DMA_ERQ_ERQ1_Pos = 0x1
	// Bit mask of ERQ1 field.
	DMA_ERQ_ERQ1_Msk = 0x2
	// Bit ERQ1.
	DMA_ERQ_ERQ1 = 0x2
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ1_ERQ1_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ1_ERQ1_1 = 0x1
	// Position of ERQ2 field.
	DMA_ERQ_ERQ2_Pos = 0x2
	// Bit mask of ERQ2 field.
	DMA_ERQ_ERQ2_Msk = 0x4
	// Bit ERQ2.
	DMA_ERQ_ERQ2 = 0x4
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ2_ERQ2_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ2_ERQ2_1 = 0x1
	// Position of ERQ3 field.
	DMA_ERQ_ERQ3_Pos = 0x3
	// Bit mask of ERQ3 field.
	DMA_ERQ_ERQ3_Msk = 0x8
	// Bit ERQ3.
	DMA_ERQ_ERQ3 = 0x8
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ3_ERQ3_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ3_ERQ3_1 = 0x1
	// Position of ERQ4 field.
	DMA_ERQ_ERQ4_Pos = 0x4
	// Bit mask of ERQ4 field.
	DMA_ERQ_ERQ4_Msk = 0x10
	// Bit ERQ4.
	DMA_ERQ_ERQ4 = 0x10
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ4_ERQ4_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ4_ERQ4_1 = 0x1
	// Position of ERQ5 field.
	DMA_ERQ_ERQ5_Pos = 0x5
	// Bit mask of ERQ5 field.
	DMA_ERQ_ERQ5_Msk = 0x20
	// Bit ERQ5.
	DMA_ERQ_ERQ5 = 0x20
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ5_ERQ5_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ5_ERQ5_1 = 0x1
	// Position of ERQ6 field.
	DMA_ERQ_ERQ6_Pos = 0x6
	// Bit mask of ERQ6 field.
	DMA_ERQ_ERQ6_Msk = 0x40
	// Bit ERQ6.
	DMA_ERQ_ERQ6 = 0x40
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ6_ERQ6_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ6_ERQ6_1 = 0x1
	// Position of ERQ7 field.
	DMA_ERQ_ERQ7_Pos = 0x7
	// Bit mask of ERQ7 field.
	DMA_ERQ_ERQ7_Msk = 0x80
	// Bit ERQ7.
	DMA_ERQ_ERQ7 = 0x80
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ7_ERQ7_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ7_ERQ7_1 = 0x1
	// Position of ERQ8 field.
	DMA_ERQ_ERQ8_Pos = 0x8
	// Bit mask of ERQ8 field.
	DMA_ERQ_ERQ8_Msk = 0x100
	// Bit ERQ8.
	DMA_ERQ_ERQ8 = 0x100
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ8_ERQ8_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ8_ERQ8_1 = 0x1
	// Position of ERQ9 field.
	DMA_ERQ_ERQ9_Pos = 0x9
	// Bit mask of ERQ9 field.
	DMA_ERQ_ERQ9_Msk = 0x200
	// Bit ERQ9.
	DMA_ERQ_ERQ9 = 0x200
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ9_ERQ9_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ9_ERQ9_1 = 0x1
	// Position of ERQ10 field.
	DMA_ERQ_ERQ10_Pos = 0xa
	// Bit mask of ERQ10 field.
	DMA_ERQ_ERQ10_Msk = 0x400
	// Bit ERQ10.
	DMA_ERQ_ERQ10 = 0x400
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ10_ERQ10_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ10_ERQ10_1 = 0x1
	// Position of ERQ11 field.
	DMA_ERQ_ERQ11_Pos = 0xb
	// Bit mask of ERQ11 field.
	DMA_ERQ_ERQ11_Msk = 0x800
	// Bit ERQ11.
	DMA_ERQ_ERQ11 = 0x800
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ11_ERQ11_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ11_ERQ11_1 = 0x1
	// Position of ERQ12 field.
	DMA_ERQ_ERQ12_Pos = 0xc
	// Bit mask of ERQ12 field.
	DMA_ERQ_ERQ12_Msk = 0x1000
	// Bit ERQ12.
	DMA_ERQ_ERQ12 = 0x1000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ12_ERQ12_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ12_ERQ12_1 = 0x1
	// Position of ERQ13 field.
	DMA_ERQ_ERQ13_Pos = 0xd
	// Bit mask of ERQ13 field.
	DMA_ERQ_ERQ13_Msk = 0x2000
	// Bit ERQ13.
	DMA_ERQ_ERQ13 = 0x2000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ13_ERQ13_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ13_ERQ13_1 = 0x1
	// Position of ERQ14 field.
	DMA_ERQ_ERQ14_Pos = 0xe
	// Bit mask of ERQ14 field.
	DMA_ERQ_ERQ14_Msk = 0x4000
	// Bit ERQ14.
	DMA_ERQ_ERQ14 = 0x4000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ14_ERQ14_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ14_ERQ14_1 = 0x1
	// Position of ERQ15 field.
	DMA_ERQ_ERQ15_Pos = 0xf
	// Bit mask of ERQ15 field.
	DMA_ERQ_ERQ15_Msk = 0x8000
	// Bit ERQ15.
	DMA_ERQ_ERQ15 = 0x8000
	// The DMA request signal for the corresponding channel is disabled
	DMA_ERQ_ERQ15_ERQ15_0 = 0x0
	// The DMA request signal for the corresponding channel is enabled
	DMA_ERQ_ERQ15_ERQ15_1 = 0x1

	// EEI: Enable Error Interrupt Register
	// Position of EEI0 field.
	DMA_EEI_EEI0_Pos = 0x0
	// Bit mask of EEI0 field.
	DMA_EEI_EEI0_Msk = 0x1
	// Bit EEI0.
	DMA_EEI_EEI0 = 0x1
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI0_EEI0_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI0_EEI0_1 = 0x1
	// Position of EEI1 field.
	DMA_EEI_EEI1_Pos = 0x1
	// Bit mask of EEI1 field.
	DMA_EEI_EEI1_Msk = 0x2
	// Bit EEI1.
	DMA_EEI_EEI1 = 0x2
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI1_EEI1_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI1_EEI1_1 = 0x1
	// Position of EEI2 field.
	DMA_EEI_EEI2_Pos = 0x2
	// Bit mask of EEI2 field.
	DMA_EEI_EEI2_Msk = 0x4
	// Bit EEI2.
	DMA_EEI_EEI2 = 0x4
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI2_EEI2_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI2_EEI2_1 = 0x1
	// Position of EEI3 field.
	DMA_EEI_EEI3_Pos = 0x3
	// Bit mask of EEI3 field.
	DMA_EEI_EEI3_Msk = 0x8
	// Bit EEI3.
	DMA_EEI_EEI3 = 0x8
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI3_EEI3_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI3_EEI3_1 = 0x1
	// Position of EEI4 field.
	DMA_EEI_EEI4_Pos = 0x4
	// Bit mask of EEI4 field.
	DMA_EEI_EEI4_Msk = 0x10
	// Bit EEI4.
	DMA_EEI_EEI4 = 0x10
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI4_EEI4_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI4_EEI4_1 = 0x1
	// Position of EEI5 field.
	DMA_EEI_EEI5_Pos = 0x5
	// Bit mask of EEI5 field.
	DMA_EEI_EEI5_Msk = 0x20
	// Bit EEI5.
	DMA_EEI_EEI5 = 0x20
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI5_EEI5_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI5_EEI5_1 = 0x1
	// Position of EEI6 field.
	DMA_EEI_EEI6_Pos = 0x6
	// Bit mask of EEI6 field.
	DMA_EEI_EEI6_Msk = 0x40
	// Bit EEI6.
	DMA_EEI_EEI6 = 0x40
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI6_EEI6_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI6_EEI6_1 = 0x1
	// Position of EEI7 field.
	DMA_EEI_EEI7_Pos = 0x7
	// Bit mask of EEI7 field.
	DMA_EEI_EEI7_Msk = 0x80
	// Bit EEI7.
	DMA_EEI_EEI7 = 0x80
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI7_EEI7_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI7_EEI7_1 = 0x1
	// Position of EEI8 field.
	DMA_EEI_EEI8_Pos = 0x8
	// Bit mask of EEI8 field.
	DMA_EEI_EEI8_Msk = 0x100
	// Bit EEI8.
	DMA_EEI_EEI8 = 0x100
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI8_EEI8_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI8_EEI8_1 = 0x1
	// Position of EEI9 field.
	DMA_EEI_EEI9_Pos = 0x9
	// Bit mask of EEI9 field.
	DMA_EEI_EEI9_Msk = 0x200
	// Bit EEI9.
	DMA_EEI_EEI9 = 0x200
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI9_EEI9_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI9_EEI9_1 = 0x1
	// Position of EEI10 field.
	DMA_EEI_EEI10_Pos = 0xa
	// Bit mask of EEI10 field.
	DMA_EEI_EEI10_Msk = 0x400
	// Bit EEI10.
	DMA_EEI_EEI10 = 0x400
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI10_EEI10_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI10_EEI10_1 = 0x1
	// Position of EEI11 field.
	DMA_EEI_EEI11_Pos = 0xb
	// Bit mask of EEI11 field.
	DMA_EEI_EEI11_Msk = 0x800
	// Bit EEI11.
	DMA_EEI_EEI11 = 0x800
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI11_EEI11_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI11_EEI11_1 = 0x1
	// Position of EEI12 field.
	DMA_EEI_EEI12_Pos = 0xc
	// Bit mask of EEI12 field.
	DMA_EEI_EEI12_Msk = 0x1000
	// Bit EEI12.
	DMA_EEI_EEI12 = 0x1000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI12_EEI12_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI12_EEI12_1 = 0x1
	// Position of EEI13 field.
	DMA_EEI_EEI13_Pos = 0xd
	// Bit mask of EEI13 field.
	DMA_EEI_EEI13_Msk = 0x2000
	// Bit EEI13.
	DMA_EEI_EEI13 = 0x2000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI13_EEI13_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI13_EEI13_1 = 0x1
	// Position of EEI14 field.
	DMA_EEI_EEI14_Pos = 0xe
	// Bit mask of EEI14 field.
	DMA_EEI_EEI14_Msk = 0x4000
	// Bit EEI14.
	DMA_EEI_EEI14 = 0x4000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI14_EEI14_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI14_EEI14_1 = 0x1
	// Position of EEI15 field.
	DMA_EEI_EEI15_Pos = 0xf
	// Bit mask of EEI15 field.
	DMA_EEI_EEI15_Msk = 0x8000
	// Bit EEI15.
	DMA_EEI_EEI15 = 0x8000
	// The error signal for corresponding channel does not generate an error interrupt
	DMA_EEI_EEI15_EEI15_0 = 0x0
	// The assertion of the error signal for corresponding channel generates an error interrupt request
	DMA_EEI_EEI15_EEI15_1 = 0x1

	// CEEI: Clear Enable Error Interrupt Register
	// Position of CEEI field.
	DMA_CEEI_CEEI_Pos = 0x0
	// Bit mask of CEEI field.
	DMA_CEEI_CEEI_Msk = 0xf
	// Position of CAEE field.
	DMA_CEEI_CAEE_Pos = 0x6
	// Bit mask of CAEE field.
	DMA_CEEI_CAEE_Msk = 0x40
	// Bit CAEE.
	DMA_CEEI_CAEE = 0x40
	// Clear only the EEI bit specified in the CEEI field
	DMA_CEEI_CAEE_CAEE_0 = 0x0
	// Clear all bits in EEI
	DMA_CEEI_CAEE_CAEE_1 = 0x1
	// Position of NOP field.
	DMA_CEEI_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_CEEI_NOP_Msk = 0x80
	// Bit NOP.
	DMA_CEEI_NOP = 0x80
	// Normal operation
	DMA_CEEI_NOP_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_CEEI_NOP_NOP_1 = 0x1

	// SEEI: Set Enable Error Interrupt Register
	// Position of SEEI field.
	DMA_SEEI_SEEI_Pos = 0x0
	// Bit mask of SEEI field.
	DMA_SEEI_SEEI_Msk = 0xf
	// Position of SAEE field.
	DMA_SEEI_SAEE_Pos = 0x6
	// Bit mask of SAEE field.
	DMA_SEEI_SAEE_Msk = 0x40
	// Bit SAEE.
	DMA_SEEI_SAEE = 0x40
	// Set only the EEI bit specified in the SEEI field.
	DMA_SEEI_SAEE_SAEE_0 = 0x0
	// Sets all bits in EEI
	DMA_SEEI_SAEE_SAEE_1 = 0x1
	// Position of NOP field.
	DMA_SEEI_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_SEEI_NOP_Msk = 0x80
	// Bit NOP.
	DMA_SEEI_NOP = 0x80
	// Normal operation
	DMA_SEEI_NOP_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_SEEI_NOP_NOP_1 = 0x1

	// CERQ: Clear Enable Request Register
	// Position of CERQ field.
	DMA_CERQ_CERQ_Pos = 0x0
	// Bit mask of CERQ field.
	DMA_CERQ_CERQ_Msk = 0xf
	// Position of CAER field.
	DMA_CERQ_CAER_Pos = 0x6
	// Bit mask of CAER field.
	DMA_CERQ_CAER_Msk = 0x40
	// Bit CAER.
	DMA_CERQ_CAER = 0x40
	// Clear only the ERQ bit specified in the CERQ field
	DMA_CERQ_CAER_CAER_0 = 0x0
	// Clear all bits in ERQ
	DMA_CERQ_CAER_CAER_1 = 0x1
	// Position of NOP field.
	DMA_CERQ_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_CERQ_NOP_Msk = 0x80
	// Bit NOP.
	DMA_CERQ_NOP = 0x80
	// Normal operation
	DMA_CERQ_NOP_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_CERQ_NOP_NOP_1 = 0x1

	// SERQ: Set Enable Request Register
	// Position of SERQ field.
	DMA_SERQ_SERQ_Pos = 0x0
	// Bit mask of SERQ field.
	DMA_SERQ_SERQ_Msk = 0xf
	// Position of SAER field.
	DMA_SERQ_SAER_Pos = 0x6
	// Bit mask of SAER field.
	DMA_SERQ_SAER_Msk = 0x40
	// Bit SAER.
	DMA_SERQ_SAER = 0x40
	// Set only the ERQ bit specified in the SERQ field
	DMA_SERQ_SAER_SAER_0 = 0x0
	// Set all bits in ERQ
	DMA_SERQ_SAER_SAER_1 = 0x1
	// Position of NOP field.
	DMA_SERQ_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_SERQ_NOP_Msk = 0x80
	// Bit NOP.
	DMA_SERQ_NOP = 0x80
	// Normal operation
	DMA_SERQ_NOP_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_SERQ_NOP_NOP_1 = 0x1

	// CDNE: Clear DONE Status Bit Register
	// Position of CDNE field.
	DMA_CDNE_CDNE_Pos = 0x0
	// Bit mask of CDNE field.
	DMA_CDNE_CDNE_Msk = 0xf
	// Position of CADN field.
	DMA_CDNE_CADN_Pos = 0x6
	// Bit mask of CADN field.
	DMA_CDNE_CADN_Msk = 0x40
	// Bit CADN.
	DMA_CDNE_CADN = 0x40
	// Clears only the TCDn_CSR[DONE] bit specified in the CDNE field
	DMA_CDNE_CADN_CADN_0 = 0x0
	// Clears all bits in TCDn_CSR[DONE]
	DMA_CDNE_CADN_CADN_1 = 0x1
	// Position of NOP field.
	DMA_CDNE_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_CDNE_NOP_Msk = 0x80
	// Bit NOP.
	DMA_CDNE_NOP = 0x80
	// Normal operation
	DMA_CDNE_NOP_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_CDNE_NOP_NOP_1 = 0x1

	// SSRT: Set START Bit Register
	// Position of SSRT field.
	DMA_SSRT_SSRT_Pos = 0x0
	// Bit mask of SSRT field.
	DMA_SSRT_SSRT_Msk = 0xf
	// Position of SAST field.
	DMA_SSRT_SAST_Pos = 0x6
	// Bit mask of SAST field.
	DMA_SSRT_SAST_Msk = 0x40
	// Bit SAST.
	DMA_SSRT_SAST = 0x40
	// Set only the TCDn_CSR[START] bit specified in the SSRT field
	DMA_SSRT_SAST_SAST_0 = 0x0
	// Set all bits in TCDn_CSR[START]
	DMA_SSRT_SAST_SAST_1 = 0x1
	// Position of NOP field.
	DMA_SSRT_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_SSRT_NOP_Msk = 0x80
	// Bit NOP.
	DMA_SSRT_NOP = 0x80
	// Normal operation
	DMA_SSRT_NOP_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_SSRT_NOP_NOP_1 = 0x1

	// CERR: Clear Error Register
	// Position of CERR field.
	DMA_CERR_CERR_Pos = 0x0
	// Bit mask of CERR field.
	DMA_CERR_CERR_Msk = 0xf
	// Position of CAEI field.
	DMA_CERR_CAEI_Pos = 0x6
	// Bit mask of CAEI field.
	DMA_CERR_CAEI_Msk = 0x40
	// Bit CAEI.
	DMA_CERR_CAEI = 0x40
	// Clear only the ERR bit specified in the CERR field
	DMA_CERR_CAEI_CAEI_0 = 0x0
	// Clear all bits in ERR
	DMA_CERR_CAEI_CAEI_1 = 0x1
	// Position of NOP field.
	DMA_CERR_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_CERR_NOP_Msk = 0x80
	// Bit NOP.
	DMA_CERR_NOP = 0x80
	// Normal operation
	DMA_CERR_NOP_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_CERR_NOP_NOP_1 = 0x1

	// CINT: Clear Interrupt Request Register
	// Position of CINT field.
	DMA_CINT_CINT_Pos = 0x0
	// Bit mask of CINT field.
	DMA_CINT_CINT_Msk = 0xf
	// Position of CAIR field.
	DMA_CINT_CAIR_Pos = 0x6
	// Bit mask of CAIR field.
	DMA_CINT_CAIR_Msk = 0x40
	// Bit CAIR.
	DMA_CINT_CAIR = 0x40
	// Clear only the INT bit specified in the CINT field
	DMA_CINT_CAIR_CAIR_0 = 0x0
	// Clear all bits in INT
	DMA_CINT_CAIR_CAIR_1 = 0x1
	// Position of NOP field.
	DMA_CINT_NOP_Pos = 0x7
	// Bit mask of NOP field.
	DMA_CINT_NOP_Msk = 0x80
	// Bit NOP.
	DMA_CINT_NOP = 0x80
	// Normal operation
	DMA_CINT_NOP_NOP_0 = 0x0
	// No operation, ignore the other bits in this register
	DMA_CINT_NOP_NOP_1 = 0x1

	// INT: Interrupt Request Register
	// Position of INT0 field.
	DMA_INT_INT0_Pos = 0x0
	// Bit mask of INT0 field.
	DMA_INT_INT0_Msk = 0x1
	// Bit INT0.
	DMA_INT_INT0 = 0x1
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT0_INT0_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT0_INT0_1 = 0x1
	// Position of INT1 field.
	DMA_INT_INT1_Pos = 0x1
	// Bit mask of INT1 field.
	DMA_INT_INT1_Msk = 0x2
	// Bit INT1.
	DMA_INT_INT1 = 0x2
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT1_INT1_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT1_INT1_1 = 0x1
	// Position of INT2 field.
	DMA_INT_INT2_Pos = 0x2
	// Bit mask of INT2 field.
	DMA_INT_INT2_Msk = 0x4
	// Bit INT2.
	DMA_INT_INT2 = 0x4
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT2_INT2_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT2_INT2_1 = 0x1
	// Position of INT3 field.
	DMA_INT_INT3_Pos = 0x3
	// Bit mask of INT3 field.
	DMA_INT_INT3_Msk = 0x8
	// Bit INT3.
	DMA_INT_INT3 = 0x8
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT3_INT3_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT3_INT3_1 = 0x1
	// Position of INT4 field.
	DMA_INT_INT4_Pos = 0x4
	// Bit mask of INT4 field.
	DMA_INT_INT4_Msk = 0x10
	// Bit INT4.
	DMA_INT_INT4 = 0x10
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT4_INT4_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT4_INT4_1 = 0x1
	// Position of INT5 field.
	DMA_INT_INT5_Pos = 0x5
	// Bit mask of INT5 field.
	DMA_INT_INT5_Msk = 0x20
	// Bit INT5.
	DMA_INT_INT5 = 0x20
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT5_INT5_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT5_INT5_1 = 0x1
	// Position of INT6 field.
	DMA_INT_INT6_Pos = 0x6
	// Bit mask of INT6 field.
	DMA_INT_INT6_Msk = 0x40
	// Bit INT6.
	DMA_INT_INT6 = 0x40
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT6_INT6_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT6_INT6_1 = 0x1
	// Position of INT7 field.
	DMA_INT_INT7_Pos = 0x7
	// Bit mask of INT7 field.
	DMA_INT_INT7_Msk = 0x80
	// Bit INT7.
	DMA_INT_INT7 = 0x80
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT7_INT7_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT7_INT7_1 = 0x1
	// Position of INT8 field.
	DMA_INT_INT8_Pos = 0x8
	// Bit mask of INT8 field.
	DMA_INT_INT8_Msk = 0x100
	// Bit INT8.
	DMA_INT_INT8 = 0x100
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT8_INT8_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT8_INT8_1 = 0x1
	// Position of INT9 field.
	DMA_INT_INT9_Pos = 0x9
	// Bit mask of INT9 field.
	DMA_INT_INT9_Msk = 0x200
	// Bit INT9.
	DMA_INT_INT9 = 0x200
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT9_INT9_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT9_INT9_1 = 0x1
	// Position of INT10 field.
	DMA_INT_INT10_Pos = 0xa
	// Bit mask of INT10 field.
	DMA_INT_INT10_Msk = 0x400
	// Bit INT10.
	DMA_INT_INT10 = 0x400
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT10_INT10_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT10_INT10_1 = 0x1
	// Position of INT11 field.
	DMA_INT_INT11_Pos = 0xb
	// Bit mask of INT11 field.
	DMA_INT_INT11_Msk = 0x800
	// Bit INT11.
	DMA_INT_INT11 = 0x800
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT11_INT11_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT11_INT11_1 = 0x1
	// Position of INT12 field.
	DMA_INT_INT12_Pos = 0xc
	// Bit mask of INT12 field.
	DMA_INT_INT12_Msk = 0x1000
	// Bit INT12.
	DMA_INT_INT12 = 0x1000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT12_INT12_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT12_INT12_1 = 0x1
	// Position of INT13 field.
	DMA_INT_INT13_Pos = 0xd
	// Bit mask of INT13 field.
	DMA_INT_INT13_Msk = 0x2000
	// Bit INT13.
	DMA_INT_INT13 = 0x2000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT13_INT13_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT13_INT13_1 = 0x1
	// Position of INT14 field.
	DMA_INT_INT14_Pos = 0xe
	// Bit mask of INT14 field.
	DMA_INT_INT14_Msk = 0x4000
	// Bit INT14.
	DMA_INT_INT14 = 0x4000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT14_INT14_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT14_INT14_1 = 0x1
	// Position of INT15 field.
	DMA_INT_INT15_Pos = 0xf
	// Bit mask of INT15 field.
	DMA_INT_INT15_Msk = 0x8000
	// Bit INT15.
	DMA_INT_INT15 = 0x8000
	// The interrupt request for corresponding channel is cleared
	DMA_INT_INT15_INT15_0 = 0x0
	// The interrupt request for corresponding channel is active
	DMA_INT_INT15_INT15_1 = 0x1

	// ERR: Error Register
	// Position of ERR0 field.
	DMA_ERR_ERR0_Pos = 0x0
	// Bit mask of ERR0 field.
	DMA_ERR_ERR0_Msk = 0x1
	// Bit ERR0.
	DMA_ERR_ERR0 = 0x1
	// An error in this channel has not occurred
	DMA_ERR_ERR0_ERR0_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR0_ERR0_1 = 0x1
	// Position of ERR1 field.
	DMA_ERR_ERR1_Pos = 0x1
	// Bit mask of ERR1 field.
	DMA_ERR_ERR1_Msk = 0x2
	// Bit ERR1.
	DMA_ERR_ERR1 = 0x2
	// An error in this channel has not occurred
	DMA_ERR_ERR1_ERR1_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR1_ERR1_1 = 0x1
	// Position of ERR2 field.
	DMA_ERR_ERR2_Pos = 0x2
	// Bit mask of ERR2 field.
	DMA_ERR_ERR2_Msk = 0x4
	// Bit ERR2.
	DMA_ERR_ERR2 = 0x4
	// An error in this channel has not occurred
	DMA_ERR_ERR2_ERR2_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR2_ERR2_1 = 0x1
	// Position of ERR3 field.
	DMA_ERR_ERR3_Pos = 0x3
	// Bit mask of ERR3 field.
	DMA_ERR_ERR3_Msk = 0x8
	// Bit ERR3.
	DMA_ERR_ERR3 = 0x8
	// An error in this channel has not occurred
	DMA_ERR_ERR3_ERR3_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR3_ERR3_1 = 0x1
	// Position of ERR4 field.
	DMA_ERR_ERR4_Pos = 0x4
	// Bit mask of ERR4 field.
	DMA_ERR_ERR4_Msk = 0x10
	// Bit ERR4.
	DMA_ERR_ERR4 = 0x10
	// An error in this channel has not occurred
	DMA_ERR_ERR4_ERR4_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR4_ERR4_1 = 0x1
	// Position of ERR5 field.
	DMA_ERR_ERR5_Pos = 0x5
	// Bit mask of ERR5 field.
	DMA_ERR_ERR5_Msk = 0x20
	// Bit ERR5.
	DMA_ERR_ERR5 = 0x20
	// An error in this channel has not occurred
	DMA_ERR_ERR5_ERR5_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR5_ERR5_1 = 0x1
	// Position of ERR6 field.
	DMA_ERR_ERR6_Pos = 0x6
	// Bit mask of ERR6 field.
	DMA_ERR_ERR6_Msk = 0x40
	// Bit ERR6.
	DMA_ERR_ERR6 = 0x40
	// An error in this channel has not occurred
	DMA_ERR_ERR6_ERR6_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR6_ERR6_1 = 0x1
	// Position of ERR7 field.
	DMA_ERR_ERR7_Pos = 0x7
	// Bit mask of ERR7 field.
	DMA_ERR_ERR7_Msk = 0x80
	// Bit ERR7.
	DMA_ERR_ERR7 = 0x80
	// An error in this channel has not occurred
	DMA_ERR_ERR7_ERR7_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR7_ERR7_1 = 0x1
	// Position of ERR8 field.
	DMA_ERR_ERR8_Pos = 0x8
	// Bit mask of ERR8 field.
	DMA_ERR_ERR8_Msk = 0x100
	// Bit ERR8.
	DMA_ERR_ERR8 = 0x100
	// An error in this channel has not occurred
	DMA_ERR_ERR8_ERR8_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR8_ERR8_1 = 0x1
	// Position of ERR9 field.
	DMA_ERR_ERR9_Pos = 0x9
	// Bit mask of ERR9 field.
	DMA_ERR_ERR9_Msk = 0x200
	// Bit ERR9.
	DMA_ERR_ERR9 = 0x200
	// An error in this channel has not occurred
	DMA_ERR_ERR9_ERR9_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR9_ERR9_1 = 0x1
	// Position of ERR10 field.
	DMA_ERR_ERR10_Pos = 0xa
	// Bit mask of ERR10 field.
	DMA_ERR_ERR10_Msk = 0x400
	// Bit ERR10.
	DMA_ERR_ERR10 = 0x400
	// An error in this channel has not occurred
	DMA_ERR_ERR10_ERR10_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR10_ERR10_1 = 0x1
	// Position of ERR11 field.
	DMA_ERR_ERR11_Pos = 0xb
	// Bit mask of ERR11 field.
	DMA_ERR_ERR11_Msk = 0x800
	// Bit ERR11.
	DMA_ERR_ERR11 = 0x800
	// An error in this channel has not occurred
	DMA_ERR_ERR11_ERR11_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR11_ERR11_1 = 0x1
	// Position of ERR12 field.
	DMA_ERR_ERR12_Pos = 0xc
	// Bit mask of ERR12 field.
	DMA_ERR_ERR12_Msk = 0x1000
	// Bit ERR12.
	DMA_ERR_ERR12 = 0x1000
	// An error in this channel has not occurred
	DMA_ERR_ERR12_ERR12_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR12_ERR12_1 = 0x1
	// Position of ERR13 field.
	DMA_ERR_ERR13_Pos = 0xd
	// Bit mask of ERR13 field.
	DMA_ERR_ERR13_Msk = 0x2000
	// Bit ERR13.
	DMA_ERR_ERR13 = 0x2000
	// An error in this channel has not occurred
	DMA_ERR_ERR13_ERR13_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR13_ERR13_1 = 0x1
	// Position of ERR14 field.
	DMA_ERR_ERR14_Pos = 0xe
	// Bit mask of ERR14 field.
	DMA_ERR_ERR14_Msk = 0x4000
	// Bit ERR14.
	DMA_ERR_ERR14 = 0x4000
	// An error in this channel has not occurred
	DMA_ERR_ERR14_ERR14_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR14_ERR14_1 = 0x1
	// Position of ERR15 field.
	DMA_ERR_ERR15_Pos = 0xf
	// Bit mask of ERR15 field.
	DMA_ERR_ERR15_Msk = 0x8000
	// Bit ERR15.
	DMA_ERR_ERR15 = 0x8000
	// An error in this channel has not occurred
	DMA_ERR_ERR15_ERR15_0 = 0x0
	// An error in this channel has occurred
	DMA_ERR_ERR15_ERR15_1 = 0x1

	// HRS: Hardware Request Status Register
	// Position of HRS0 field.
	DMA_HRS_HRS0_Pos = 0x0
	// Bit mask of HRS0 field.
	DMA_HRS_HRS0_Msk = 0x1
	// Bit HRS0.
	DMA_HRS_HRS0 = 0x1
	// A hardware service request for channel 0 is not present
	DMA_HRS_HRS0_HRS0_0 = 0x0
	// A hardware service request for channel 0 is present
	DMA_HRS_HRS0_HRS0_1 = 0x1
	// Position of HRS1 field.
	DMA_HRS_HRS1_Pos = 0x1
	// Bit mask of HRS1 field.
	DMA_HRS_HRS1_Msk = 0x2
	// Bit HRS1.
	DMA_HRS_HRS1 = 0x2
	// A hardware service request for channel 1 is not present
	DMA_HRS_HRS1_HRS1_0 = 0x0
	// A hardware service request for channel 1 is present
	DMA_HRS_HRS1_HRS1_1 = 0x1
	// Position of HRS2 field.
	DMA_HRS_HRS2_Pos = 0x2
	// Bit mask of HRS2 field.
	DMA_HRS_HRS2_Msk = 0x4
	// Bit HRS2.
	DMA_HRS_HRS2 = 0x4
	// A hardware service request for channel 2 is not present
	DMA_HRS_HRS2_HRS2_0 = 0x0
	// A hardware service request for channel 2 is present
	DMA_HRS_HRS2_HRS2_1 = 0x1
	// Position of HRS3 field.
	DMA_HRS_HRS3_Pos = 0x3
	// Bit mask of HRS3 field.
	DMA_HRS_HRS3_Msk = 0x8
	// Bit HRS3.
	DMA_HRS_HRS3 = 0x8
	// A hardware service request for channel 3 is not present
	DMA_HRS_HRS3_HRS3_0 = 0x0
	// A hardware service request for channel 3 is present
	DMA_HRS_HRS3_HRS3_1 = 0x1
	// Position of HRS4 field.
	DMA_HRS_HRS4_Pos = 0x4
	// Bit mask of HRS4 field.
	DMA_HRS_HRS4_Msk = 0x10
	// Bit HRS4.
	DMA_HRS_HRS4 = 0x10
	// A hardware service request for channel 4 is not present
	DMA_HRS_HRS4_HRS4_0 = 0x0
	// A hardware service request for channel 4 is present
	DMA_HRS_HRS4_HRS4_1 = 0x1
	// Position of HRS5 field.
	DMA_HRS_HRS5_Pos = 0x5
	// Bit mask of HRS5 field.
	DMA_HRS_HRS5_Msk = 0x20
	// Bit HRS5.
	DMA_HRS_HRS5 = 0x20
	// A hardware service request for channel 5 is not present
	DMA_HRS_HRS5_HRS5_0 = 0x0
	// A hardware service request for channel 5 is present
	DMA_HRS_HRS5_HRS5_1 = 0x1
	// Position of HRS6 field.
	DMA_HRS_HRS6_Pos = 0x6
	// Bit mask of HRS6 field.
	DMA_HRS_HRS6_Msk = 0x40
	// Bit HRS6.
	DMA_HRS_HRS6 = 0x40
	// A hardware service request for channel 6 is not present
	DMA_HRS_HRS6_HRS6_0 = 0x0
	// A hardware service request for channel 6 is present
	DMA_HRS_HRS6_HRS6_1 = 0x1
	// Position of HRS7 field.
	DMA_HRS_HRS7_Pos = 0x7
	// Bit mask of HRS7 field.
	DMA_HRS_HRS7_Msk = 0x80
	// Bit HRS7.
	DMA_HRS_HRS7 = 0x80
	// A hardware service request for channel 7 is not present
	DMA_HRS_HRS7_HRS7_0 = 0x0
	// A hardware service request for channel 7 is present
	DMA_HRS_HRS7_HRS7_1 = 0x1
	// Position of HRS8 field.
	DMA_HRS_HRS8_Pos = 0x8
	// Bit mask of HRS8 field.
	DMA_HRS_HRS8_Msk = 0x100
	// Bit HRS8.
	DMA_HRS_HRS8 = 0x100
	// A hardware service request for channel 8 is not present
	DMA_HRS_HRS8_HRS8_0 = 0x0
	// A hardware service request for channel 8 is present
	DMA_HRS_HRS8_HRS8_1 = 0x1
	// Position of HRS9 field.
	DMA_HRS_HRS9_Pos = 0x9
	// Bit mask of HRS9 field.
	DMA_HRS_HRS9_Msk = 0x200
	// Bit HRS9.
	DMA_HRS_HRS9 = 0x200
	// A hardware service request for channel 9 is not present
	DMA_HRS_HRS9_HRS9_0 = 0x0
	// A hardware service request for channel 9 is present
	DMA_HRS_HRS9_HRS9_1 = 0x1
	// Position of HRS10 field.
	DMA_HRS_HRS10_Pos = 0xa
	// Bit mask of HRS10 field.
	DMA_HRS_HRS10_Msk = 0x400
	// Bit HRS10.
	DMA_HRS_HRS10 = 0x400
	// A hardware service request for channel 10 is not present
	DMA_HRS_HRS10_HRS10_0 = 0x0
	// A hardware service request for channel 10 is present
	DMA_HRS_HRS10_HRS10_1 = 0x1
	// Position of HRS11 field.
	DMA_HRS_HRS11_Pos = 0xb
	// Bit mask of HRS11 field.
	DMA_HRS_HRS11_Msk = 0x800
	// Bit HRS11.
	DMA_HRS_HRS11 = 0x800
	// A hardware service request for channel 11 is not present
	DMA_HRS_HRS11_HRS11_0 = 0x0
	// A hardware service request for channel 11 is present
	DMA_HRS_HRS11_HRS11_1 = 0x1
	// Position of HRS12 field.
	DMA_HRS_HRS12_Pos = 0xc
	// Bit mask of HRS12 field.
	DMA_HRS_HRS12_Msk = 0x1000
	// Bit HRS12.
	DMA_HRS_HRS12 = 0x1000
	// A hardware service request for channel 12 is not present
	DMA_HRS_HRS12_HRS12_0 = 0x0
	// A hardware service request for channel 12 is present
	DMA_HRS_HRS12_HRS12_1 = 0x1
	// Position of HRS13 field.
	DMA_HRS_HRS13_Pos = 0xd
	// Bit mask of HRS13 field.
	DMA_HRS_HRS13_Msk = 0x2000
	// Bit HRS13.
	DMA_HRS_HRS13 = 0x2000
	// A hardware service request for channel 13 is not present
	DMA_HRS_HRS13_HRS13_0 = 0x0
	// A hardware service request for channel 13 is present
	DMA_HRS_HRS13_HRS13_1 = 0x1
	// Position of HRS14 field.
	DMA_HRS_HRS14_Pos = 0xe
	// Bit mask of HRS14 field.
	DMA_HRS_HRS14_Msk = 0x4000
	// Bit HRS14.
	DMA_HRS_HRS14 = 0x4000
	// A hardware service request for channel 14 is not present
	DMA_HRS_HRS14_HRS14_0 = 0x0
	// A hardware service request for channel 14 is present
	DMA_HRS_HRS14_HRS14_1 = 0x1
	// Position of HRS15 field.
	DMA_HRS_HRS15_Pos = 0xf
	// Bit mask of HRS15 field.
	DMA_HRS_HRS15_Msk = 0x8000
	// Bit HRS15.
	DMA_HRS_HRS15 = 0x8000
	// A hardware service request for channel 15 is not present
	DMA_HRS_HRS15_HRS15_0 = 0x0
	// A hardware service request for channel 15 is present
	DMA_HRS_HRS15_HRS15_1 = 0x1

	// EARS: Enable Asynchronous Request in Stop Register
	// Position of EDREQ_0 field.
	DMA_EARS_EDREQ_0_Pos = 0x0
	// Bit mask of EDREQ_0 field.
	DMA_EARS_EDREQ_0_Msk = 0x1
	// Bit EDREQ_0.
	DMA_EARS_EDREQ_0 = 0x1
	// Disable asynchronous DMA request for channel 0.
	DMA_EARS_EDREQ_0_EDREQ_0_0 = 0x0
	// Enable asynchronous DMA request for channel 0.
	DMA_EARS_EDREQ_0_EDREQ_0_1 = 0x1
	// Position of EDREQ_1 field.
	DMA_EARS_EDREQ_1_Pos = 0x1
	// Bit mask of EDREQ_1 field.
	DMA_EARS_EDREQ_1_Msk = 0x2
	// Bit EDREQ_1.
	DMA_EARS_EDREQ_1 = 0x2
	// Disable asynchronous DMA request for channel 1
	DMA_EARS_EDREQ_1_EDREQ_1_0 = 0x0
	// Enable asynchronous DMA request for channel 1.
	DMA_EARS_EDREQ_1_EDREQ_1_1 = 0x1
	// Position of EDREQ_2 field.
	DMA_EARS_EDREQ_2_Pos = 0x2
	// Bit mask of EDREQ_2 field.
	DMA_EARS_EDREQ_2_Msk = 0x4
	// Bit EDREQ_2.
	DMA_EARS_EDREQ_2 = 0x4
	// Disable asynchronous DMA request for channel 2.
	DMA_EARS_EDREQ_2_EDREQ_2_0 = 0x0
	// Enable asynchronous DMA request for channel 2.
	DMA_EARS_EDREQ_2_EDREQ_2_1 = 0x1
	// Position of EDREQ_3 field.
	DMA_EARS_EDREQ_3_Pos = 0x3
	// Bit mask of EDREQ_3 field.
	DMA_EARS_EDREQ_3_Msk = 0x8
	// Bit EDREQ_3.
	DMA_EARS_EDREQ_3 = 0x8
	// Disable asynchronous DMA request for channel 3.
	DMA_EARS_EDREQ_3_EDREQ_3_0 = 0x0
	// Enable asynchronous DMA request for channel 3.
	DMA_EARS_EDREQ_3_EDREQ_3_1 = 0x1
	// Position of EDREQ_4 field.
	DMA_EARS_EDREQ_4_Pos = 0x4
	// Bit mask of EDREQ_4 field.
	DMA_EARS_EDREQ_4_Msk = 0x10
	// Bit EDREQ_4.
	DMA_EARS_EDREQ_4 = 0x10
	// Disable asynchronous DMA request for channel 4.
	DMA_EARS_EDREQ_4_EDREQ_4_0 = 0x0
	// Enable asynchronous DMA request for channel 4.
	DMA_EARS_EDREQ_4_EDREQ_4_1 = 0x1
	// Position of EDREQ_5 field.
	DMA_EARS_EDREQ_5_Pos = 0x5
	// Bit mask of EDREQ_5 field.
	DMA_EARS_EDREQ_5_Msk = 0x20
	// Bit EDREQ_5.
	DMA_EARS_EDREQ_5 = 0x20
	// Disable asynchronous DMA request for channel 5.
	DMA_EARS_EDREQ_5_EDREQ_5_0 = 0x0
	// Enable asynchronous DMA request for channel 5.
	DMA_EARS_EDREQ_5_EDREQ_5_1 = 0x1
	// Position of EDREQ_6 field.
	DMA_EARS_EDREQ_6_Pos = 0x6
	// Bit mask of EDREQ_6 field.
	DMA_EARS_EDREQ_6_Msk = 0x40
	// Bit EDREQ_6.
	DMA_EARS_EDREQ_6 = 0x40
	// Disable asynchronous DMA request for channel 6.
	DMA_EARS_EDREQ_6_EDREQ_6_0 = 0x0
	// Enable asynchronous DMA request for channel 6.
	DMA_EARS_EDREQ_6_EDREQ_6_1 = 0x1
	// Position of EDREQ_7 field.
	DMA_EARS_EDREQ_7_Pos = 0x7
	// Bit mask of EDREQ_7 field.
	DMA_EARS_EDREQ_7_Msk = 0x80
	// Bit EDREQ_7.
	DMA_EARS_EDREQ_7 = 0x80
	// Disable asynchronous DMA request for channel 7.
	DMA_EARS_EDREQ_7_EDREQ_7_0 = 0x0
	// Enable asynchronous DMA request for channel 7.
	DMA_EARS_EDREQ_7_EDREQ_7_1 = 0x1
	// Position of EDREQ_8 field.
	DMA_EARS_EDREQ_8_Pos = 0x8
	// Bit mask of EDREQ_8 field.
	DMA_EARS_EDREQ_8_Msk = 0x100
	// Bit EDREQ_8.
	DMA_EARS_EDREQ_8 = 0x100
	// Disable asynchronous DMA request for channel 8.
	DMA_EARS_EDREQ_8_EDREQ_8_0 = 0x0
	// Enable asynchronous DMA request for channel 8.
	DMA_EARS_EDREQ_8_EDREQ_8_1 = 0x1
	// Position of EDREQ_9 field.
	DMA_EARS_EDREQ_9_Pos = 0x9
	// Bit mask of EDREQ_9 field.
	DMA_EARS_EDREQ_9_Msk = 0x200
	// Bit EDREQ_9.
	DMA_EARS_EDREQ_9 = 0x200
	// Disable asynchronous DMA request for channel 9.
	DMA_EARS_EDREQ_9_EDREQ_9_0 = 0x0
	// Enable asynchronous DMA request for channel 9.
	DMA_EARS_EDREQ_9_EDREQ_9_1 = 0x1
	// Position of EDREQ_10 field.
	DMA_EARS_EDREQ_10_Pos = 0xa
	// Bit mask of EDREQ_10 field.
	DMA_EARS_EDREQ_10_Msk = 0x400
	// Bit EDREQ_10.
	DMA_EARS_EDREQ_10 = 0x400
	// Disable asynchronous DMA request for channel 10.
	DMA_EARS_EDREQ_10_EDREQ_10_0 = 0x0
	// Enable asynchronous DMA request for channel 10.
	DMA_EARS_EDREQ_10_EDREQ_10_1 = 0x1
	// Position of EDREQ_11 field.
	DMA_EARS_EDREQ_11_Pos = 0xb
	// Bit mask of EDREQ_11 field.
	DMA_EARS_EDREQ_11_Msk = 0x800
	// Bit EDREQ_11.
	DMA_EARS_EDREQ_11 = 0x800
	// Disable asynchronous DMA request for channel 11.
	DMA_EARS_EDREQ_11_EDREQ_11_0 = 0x0
	// Enable asynchronous DMA request for channel 11.
	DMA_EARS_EDREQ_11_EDREQ_11_1 = 0x1
	// Position of EDREQ_12 field.
	DMA_EARS_EDREQ_12_Pos = 0xc
	// Bit mask of EDREQ_12 field.
	DMA_EARS_EDREQ_12_Msk = 0x1000
	// Bit EDREQ_12.
	DMA_EARS_EDREQ_12 = 0x1000
	// Disable asynchronous DMA request for channel 12.
	DMA_EARS_EDREQ_12_EDREQ_12_0 = 0x0
	// Enable asynchronous DMA request for channel 12.
	DMA_EARS_EDREQ_12_EDREQ_12_1 = 0x1
	// Position of EDREQ_13 field.
	DMA_EARS_EDREQ_13_Pos = 0xd
	// Bit mask of EDREQ_13 field.
	DMA_EARS_EDREQ_13_Msk = 0x2000
	// Bit EDREQ_13.
	DMA_EARS_EDREQ_13 = 0x2000
	// Disable asynchronous DMA request for channel 13.
	DMA_EARS_EDREQ_13_EDREQ_13_0 = 0x0
	// Enable asynchronous DMA request for channel 13.
	DMA_EARS_EDREQ_13_EDREQ_13_1 = 0x1
	// Position of EDREQ_14 field.
	DMA_EARS_EDREQ_14_Pos = 0xe
	// Bit mask of EDREQ_14 field.
	DMA_EARS_EDREQ_14_Msk = 0x4000
	// Bit EDREQ_14.
	DMA_EARS_EDREQ_14 = 0x4000
	// Disable asynchronous DMA request for channel 14.
	DMA_EARS_EDREQ_14_EDREQ_14_0 = 0x0
	// Enable asynchronous DMA request for channel 14.
	DMA_EARS_EDREQ_14_EDREQ_14_1 = 0x1
	// Position of EDREQ_15 field.
	DMA_EARS_EDREQ_15_Pos = 0xf
	// Bit mask of EDREQ_15 field.
	DMA_EARS_EDREQ_15_Msk = 0x8000
	// Bit EDREQ_15.
	DMA_EARS_EDREQ_15 = 0x8000
	// Disable asynchronous DMA request for channel 15.
	DMA_EARS_EDREQ_15_EDREQ_15_0 = 0x0
	// Enable asynchronous DMA request for channel 15.
	DMA_EARS_EDREQ_15_EDREQ_15_1 = 0x1

	// DCHPRI3: Channel Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI3_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI3_CHPRI_Msk = 0xf
	// Position of DPA field.
	DMA_DCHPRI3_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI3_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI3_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI3_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI3_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI3_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI3_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI3_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI3_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI3_ECP_ECP_1 = 0x1

	// DCHPRI2: Channel Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI2_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI2_CHPRI_Msk = 0xf
	// Position of DPA field.
	DMA_DCHPRI2_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI2_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI2_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI2_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI2_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI2_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI2_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI2_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI2_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI2_ECP_ECP_1 = 0x1

	// DCHPRI1: Channel Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI1_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI1_CHPRI_Msk = 0xf
	// Position of DPA field.
	DMA_DCHPRI1_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI1_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI1_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI1_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI1_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI1_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI1_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI1_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI1_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI1_ECP_ECP_1 = 0x1

	// DCHPRI0: Channel Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI0_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI0_CHPRI_Msk = 0xf
	// Position of DPA field.
	DMA_DCHPRI0_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI0_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI0_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI0_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI0_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI0_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI0_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI0_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI0_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI0_ECP_ECP_1 = 0x1

	// DCHPRI7: Channel Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI7_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI7_CHPRI_Msk = 0xf
	// Position of DPA field.
	DMA_DCHPRI7_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI7_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI7_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI7_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI7_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI7_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI7_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI7_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI7_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI7_ECP_ECP_1 = 0x1

	// DCHPRI6: Channel Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI6_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI6_CHPRI_Msk = 0xf
	// Position of DPA field.
	DMA_DCHPRI6_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI6_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI6_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI6_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI6_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI6_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI6_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI6_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI6_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI6_ECP_ECP_1 = 0x1

	// DCHPRI5: Channel Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI5_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI5_CHPRI_Msk = 0xf
	// Position of DPA field.
	DMA_DCHPRI5_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI5_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI5_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI5_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI5_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI5_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI5_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI5_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI5_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI5_ECP_ECP_1 = 0x1

	// DCHPRI4: Channel Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI4_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI4_CHPRI_Msk = 0xf
	// Position of DPA field.
	DMA_DCHPRI4_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI4_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI4_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI4_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI4_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI4_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI4_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI4_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI4_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI4_ECP_ECP_1 = 0x1

	// DCHPRI11: Channel Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI11_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI11_CHPRI_Msk = 0xf
	// Position of DPA field.
	DMA_DCHPRI11_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI11_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI11_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI11_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI11_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI11_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI11_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI11_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI11_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI11_ECP_ECP_1 = 0x1

	// DCHPRI10: Channel Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI10_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI10_CHPRI_Msk = 0xf
	// Position of DPA field.
	DMA_DCHPRI10_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI10_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI10_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI10_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI10_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI10_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI10_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI10_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI10_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI10_ECP_ECP_1 = 0x1

	// DCHPRI9: Channel Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI9_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI9_CHPRI_Msk = 0xf
	// Position of DPA field.
	DMA_DCHPRI9_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI9_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI9_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI9_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI9_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI9_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI9_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI9_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI9_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI9_ECP_ECP_1 = 0x1

	// DCHPRI8: Channel Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI8_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI8_CHPRI_Msk = 0xf
	// Position of DPA field.
	DMA_DCHPRI8_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI8_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI8_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI8_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI8_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI8_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI8_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI8_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI8_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI8_ECP_ECP_1 = 0x1

	// DCHPRI15: Channel Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI15_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI15_CHPRI_Msk = 0xf
	// Position of DPA field.
	DMA_DCHPRI15_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI15_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI15_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI15_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI15_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI15_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI15_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI15_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI15_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI15_ECP_ECP_1 = 0x1

	// DCHPRI14: Channel Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI14_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI14_CHPRI_Msk = 0xf
	// Position of DPA field.
	DMA_DCHPRI14_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI14_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI14_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI14_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI14_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI14_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI14_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI14_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI14_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI14_ECP_ECP_1 = 0x1

	// DCHPRI13: Channel Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI13_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI13_CHPRI_Msk = 0xf
	// Position of DPA field.
	DMA_DCHPRI13_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI13_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI13_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI13_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI13_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI13_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI13_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI13_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI13_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI13_ECP_ECP_1 = 0x1

	// DCHPRI12: Channel Priority Register
	// Position of CHPRI field.
	DMA_DCHPRI12_CHPRI_Pos = 0x0
	// Bit mask of CHPRI field.
	DMA_DCHPRI12_CHPRI_Msk = 0xf
	// Position of DPA field.
	DMA_DCHPRI12_DPA_Pos = 0x6
	// Bit mask of DPA field.
	DMA_DCHPRI12_DPA_Msk = 0x40
	// Bit DPA.
	DMA_DCHPRI12_DPA = 0x40
	// Channel n can suspend a lower priority channel.
	DMA_DCHPRI12_DPA_DPA_0 = 0x0
	// Channel n cannot suspend any channel, regardless of channel priority.
	DMA_DCHPRI12_DPA_DPA_1 = 0x1
	// Position of ECP field.
	DMA_DCHPRI12_ECP_Pos = 0x7
	// Bit mask of ECP field.
	DMA_DCHPRI12_ECP_Msk = 0x80
	// Bit ECP.
	DMA_DCHPRI12_ECP = 0x80
	// Channel n cannot be suspended by a higher priority channel's service request.
	DMA_DCHPRI12_ECP_ECP_0 = 0x0
	// Channel n can be temporarily suspended by the service request of a higher priority channel.
	DMA_DCHPRI12_ECP_ECP_1 = 0x1

	// TCD0_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD0_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD0_SADDR_SADDR_Msk = 0xffffffff

	// TCD0_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD0_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD0_SOFF_SOFF_Msk = 0xffff

	// TCD0_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD0_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD0_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD0_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD0_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD0_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD0_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD0_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD0_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD0_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD0_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD0_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD0_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD0_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD0_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD0_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD0_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD0_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD0_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD0_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD0_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD0_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD0_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD0_ATTR_SMOD_SMOD_9 = 0x9

	// TCD0_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD0_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD0_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD0_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD0_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD0_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD0_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD0_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD0_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD0_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD0_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD0_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD0_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD0_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD0_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD0_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD0_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD0_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD0_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD0_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD0_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD0_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD0_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD0_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD0_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD0_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD0_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD0_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD0_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD0_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD0_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD0_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD0_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD0_SLAST_SLAST_Msk = 0xffffffff

	// TCD0_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD0_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD0_DADDR_DADDR_Msk = 0xffffffff

	// TCD0_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD0_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD0_DOFF_DOFF_Msk = 0xffff

	// TCD0_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD0_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD0_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD0_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD0_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD0_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD0_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD0_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD0_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD0_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD0_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD0_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD0_CITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD0_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD0_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD0_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD0_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD0_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD0_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD0_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD0_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD0_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD0_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD0_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD0_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD0_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD0_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD0_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD0_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD0_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD0_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD0_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD0_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD0_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD0_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD0_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD0_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD0_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD0_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD0_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD0_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD0_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD0_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD0_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD0_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD0_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD0_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD0_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD0_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD0_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD0_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD0_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD0_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD0_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD0_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD0_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD0_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD0_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD0_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD0_CSR_MAJORLINKCH_Msk = 0xf00
	// Position of BWC field.
	DMA_TCD0_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD0_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD0_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD0_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD0_CSR_BWC_BWC_3 = 0x3

	// TCD0_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD0_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD0_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD0_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD0_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD0_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD0_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD0_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD0_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD0_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD0_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD0_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD0_BITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD0_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD0_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD0_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD0_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD0_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD1_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD1_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD1_SADDR_SADDR_Msk = 0xffffffff

	// TCD1_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD1_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD1_SOFF_SOFF_Msk = 0xffff

	// TCD1_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD1_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD1_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD1_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD1_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD1_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD1_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD1_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD1_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD1_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD1_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD1_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD1_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD1_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD1_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD1_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD1_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD1_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD1_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD1_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD1_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD1_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD1_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD1_ATTR_SMOD_SMOD_9 = 0x9

	// TCD1_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD1_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD1_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD1_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD1_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD1_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD1_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD1_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD1_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD1_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD1_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD1_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD1_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD1_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD1_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD1_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD1_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD1_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD1_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD1_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD1_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD1_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD1_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD1_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD1_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD1_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD1_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD1_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD1_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD1_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD1_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD1_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD1_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD1_SLAST_SLAST_Msk = 0xffffffff

	// TCD1_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD1_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD1_DADDR_DADDR_Msk = 0xffffffff

	// TCD1_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD1_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD1_DOFF_DOFF_Msk = 0xffff

	// TCD1_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD1_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD1_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD1_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD1_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD1_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD1_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD1_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD1_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD1_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD1_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD1_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD1_CITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD1_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD1_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD1_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD1_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD1_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD1_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD1_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD1_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD1_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD1_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD1_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD1_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD1_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD1_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD1_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD1_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD1_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD1_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD1_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD1_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD1_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD1_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD1_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD1_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD1_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD1_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD1_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD1_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD1_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD1_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD1_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD1_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD1_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD1_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD1_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD1_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD1_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD1_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD1_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD1_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD1_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD1_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD1_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD1_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD1_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD1_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD1_CSR_MAJORLINKCH_Msk = 0xf00
	// Position of BWC field.
	DMA_TCD1_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD1_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD1_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD1_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD1_CSR_BWC_BWC_3 = 0x3

	// TCD1_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD1_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD1_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD1_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD1_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD1_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD1_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD1_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD1_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD1_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD1_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD1_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD1_BITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD1_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD1_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD1_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD1_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD1_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD2_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD2_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD2_SADDR_SADDR_Msk = 0xffffffff

	// TCD2_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD2_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD2_SOFF_SOFF_Msk = 0xffff

	// TCD2_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD2_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD2_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD2_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD2_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD2_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD2_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD2_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD2_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD2_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD2_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD2_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD2_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD2_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD2_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD2_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD2_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD2_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD2_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD2_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD2_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD2_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD2_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD2_ATTR_SMOD_SMOD_9 = 0x9

	// TCD2_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD2_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD2_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD2_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD2_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD2_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD2_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD2_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD2_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD2_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD2_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD2_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD2_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD2_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD2_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD2_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD2_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD2_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD2_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD2_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD2_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD2_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD2_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD2_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD2_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD2_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD2_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD2_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD2_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD2_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD2_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD2_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD2_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD2_SLAST_SLAST_Msk = 0xffffffff

	// TCD2_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD2_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD2_DADDR_DADDR_Msk = 0xffffffff

	// TCD2_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD2_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD2_DOFF_DOFF_Msk = 0xffff

	// TCD2_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD2_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD2_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD2_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD2_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD2_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD2_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD2_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD2_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD2_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD2_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD2_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD2_CITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD2_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD2_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD2_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD2_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD2_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD2_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD2_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD2_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD2_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD2_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD2_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD2_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD2_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD2_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD2_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD2_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD2_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD2_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD2_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD2_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD2_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD2_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD2_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD2_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD2_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD2_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD2_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD2_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD2_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD2_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD2_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD2_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD2_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD2_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD2_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD2_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD2_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD2_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD2_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD2_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD2_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD2_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD2_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD2_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD2_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD2_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD2_CSR_MAJORLINKCH_Msk = 0xf00
	// Position of BWC field.
	DMA_TCD2_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD2_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD2_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD2_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD2_CSR_BWC_BWC_3 = 0x3

	// TCD2_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD2_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD2_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD2_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD2_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD2_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD2_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD2_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD2_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD2_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD2_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD2_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD2_BITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD2_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD2_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD2_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD2_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD2_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD3_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD3_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD3_SADDR_SADDR_Msk = 0xffffffff

	// TCD3_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD3_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD3_SOFF_SOFF_Msk = 0xffff

	// TCD3_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD3_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD3_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD3_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD3_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD3_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD3_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD3_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD3_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD3_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD3_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD3_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD3_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD3_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD3_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD3_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD3_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD3_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD3_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD3_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD3_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD3_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD3_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD3_ATTR_SMOD_SMOD_9 = 0x9

	// TCD3_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD3_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD3_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD3_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD3_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD3_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD3_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD3_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD3_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD3_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD3_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD3_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD3_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD3_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD3_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD3_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD3_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD3_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD3_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD3_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD3_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD3_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD3_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD3_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD3_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD3_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD3_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD3_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD3_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD3_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD3_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD3_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD3_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD3_SLAST_SLAST_Msk = 0xffffffff

	// TCD3_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD3_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD3_DADDR_DADDR_Msk = 0xffffffff

	// TCD3_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD3_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD3_DOFF_DOFF_Msk = 0xffff

	// TCD3_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD3_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD3_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD3_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD3_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD3_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD3_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD3_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD3_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD3_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD3_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD3_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD3_CITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD3_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD3_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD3_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD3_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD3_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD3_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD3_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD3_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD3_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD3_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD3_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD3_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD3_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD3_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD3_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD3_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD3_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD3_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD3_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD3_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD3_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD3_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD3_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD3_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD3_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD3_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD3_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD3_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD3_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD3_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD3_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD3_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD3_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD3_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD3_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD3_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD3_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD3_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD3_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD3_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD3_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD3_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD3_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD3_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD3_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD3_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD3_CSR_MAJORLINKCH_Msk = 0xf00
	// Position of BWC field.
	DMA_TCD3_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD3_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD3_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD3_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD3_CSR_BWC_BWC_3 = 0x3

	// TCD3_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD3_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD3_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD3_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD3_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD3_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD3_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD3_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD3_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD3_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD3_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD3_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD3_BITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD3_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD3_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD3_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD3_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD3_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD4_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD4_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD4_SADDR_SADDR_Msk = 0xffffffff

	// TCD4_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD4_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD4_SOFF_SOFF_Msk = 0xffff

	// TCD4_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD4_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD4_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD4_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD4_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD4_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD4_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD4_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD4_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD4_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD4_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD4_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD4_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD4_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD4_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD4_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD4_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD4_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD4_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD4_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD4_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD4_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD4_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD4_ATTR_SMOD_SMOD_9 = 0x9

	// TCD4_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD4_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD4_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD4_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD4_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD4_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD4_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD4_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD4_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD4_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD4_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD4_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD4_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD4_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD4_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD4_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD4_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD4_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD4_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD4_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD4_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD4_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD4_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD4_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD4_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD4_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD4_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD4_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD4_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD4_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD4_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD4_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD4_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD4_SLAST_SLAST_Msk = 0xffffffff

	// TCD4_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD4_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD4_DADDR_DADDR_Msk = 0xffffffff

	// TCD4_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD4_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD4_DOFF_DOFF_Msk = 0xffff

	// TCD4_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD4_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD4_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD4_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD4_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD4_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD4_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD4_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD4_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD4_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD4_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD4_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD4_CITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD4_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD4_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD4_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD4_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD4_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD4_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD4_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD4_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD4_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD4_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD4_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD4_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD4_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD4_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD4_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD4_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD4_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD4_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD4_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD4_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD4_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD4_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD4_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD4_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD4_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD4_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD4_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD4_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD4_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD4_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD4_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD4_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD4_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD4_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD4_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD4_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD4_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD4_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD4_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD4_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD4_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD4_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD4_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD4_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD4_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD4_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD4_CSR_MAJORLINKCH_Msk = 0xf00
	// Position of BWC field.
	DMA_TCD4_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD4_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD4_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD4_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD4_CSR_BWC_BWC_3 = 0x3

	// TCD4_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD4_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD4_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD4_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD4_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD4_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD4_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD4_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD4_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD4_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD4_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD4_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD4_BITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD4_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD4_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD4_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD4_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD4_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD5_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD5_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD5_SADDR_SADDR_Msk = 0xffffffff

	// TCD5_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD5_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD5_SOFF_SOFF_Msk = 0xffff

	// TCD5_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD5_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD5_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD5_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD5_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD5_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD5_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD5_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD5_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD5_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD5_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD5_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD5_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD5_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD5_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD5_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD5_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD5_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD5_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD5_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD5_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD5_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD5_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD5_ATTR_SMOD_SMOD_9 = 0x9

	// TCD5_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD5_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD5_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD5_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD5_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD5_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD5_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD5_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD5_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD5_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD5_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD5_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD5_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD5_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD5_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD5_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD5_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD5_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD5_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD5_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD5_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD5_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD5_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD5_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD5_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD5_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD5_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD5_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD5_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD5_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD5_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD5_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD5_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD5_SLAST_SLAST_Msk = 0xffffffff

	// TCD5_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD5_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD5_DADDR_DADDR_Msk = 0xffffffff

	// TCD5_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD5_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD5_DOFF_DOFF_Msk = 0xffff

	// TCD5_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD5_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD5_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD5_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD5_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD5_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD5_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD5_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD5_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD5_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD5_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD5_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD5_CITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD5_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD5_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD5_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD5_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD5_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD5_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD5_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD5_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD5_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD5_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD5_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD5_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD5_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD5_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD5_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD5_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD5_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD5_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD5_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD5_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD5_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD5_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD5_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD5_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD5_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD5_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD5_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD5_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD5_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD5_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD5_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD5_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD5_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD5_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD5_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD5_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD5_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD5_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD5_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD5_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD5_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD5_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD5_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD5_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD5_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD5_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD5_CSR_MAJORLINKCH_Msk = 0xf00
	// Position of BWC field.
	DMA_TCD5_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD5_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD5_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD5_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD5_CSR_BWC_BWC_3 = 0x3

	// TCD5_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD5_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD5_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD5_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD5_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD5_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD5_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD5_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD5_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD5_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD5_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD5_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD5_BITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD5_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD5_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD5_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD5_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD5_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD6_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD6_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD6_SADDR_SADDR_Msk = 0xffffffff

	// TCD6_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD6_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD6_SOFF_SOFF_Msk = 0xffff

	// TCD6_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD6_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD6_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD6_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD6_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD6_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD6_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD6_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD6_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD6_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD6_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD6_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD6_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD6_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD6_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD6_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD6_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD6_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD6_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD6_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD6_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD6_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD6_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD6_ATTR_SMOD_SMOD_9 = 0x9

	// TCD6_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD6_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD6_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD6_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD6_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD6_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD6_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD6_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD6_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD6_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD6_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD6_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD6_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD6_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD6_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD6_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD6_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD6_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD6_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD6_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD6_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD6_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD6_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD6_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD6_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD6_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD6_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD6_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD6_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD6_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD6_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD6_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD6_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD6_SLAST_SLAST_Msk = 0xffffffff

	// TCD6_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD6_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD6_DADDR_DADDR_Msk = 0xffffffff

	// TCD6_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD6_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD6_DOFF_DOFF_Msk = 0xffff

	// TCD6_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD6_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD6_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD6_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD6_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD6_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD6_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD6_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD6_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD6_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD6_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD6_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD6_CITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD6_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD6_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD6_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD6_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD6_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD6_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD6_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD6_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD6_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD6_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD6_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD6_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD6_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD6_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD6_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD6_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD6_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD6_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD6_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD6_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD6_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD6_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD6_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD6_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD6_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD6_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD6_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD6_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD6_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD6_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD6_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD6_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD6_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD6_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD6_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD6_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD6_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD6_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD6_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD6_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD6_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD6_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD6_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD6_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD6_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD6_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD6_CSR_MAJORLINKCH_Msk = 0xf00
	// Position of BWC field.
	DMA_TCD6_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD6_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD6_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD6_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD6_CSR_BWC_BWC_3 = 0x3

	// TCD6_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD6_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD6_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD6_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD6_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD6_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD6_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD6_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD6_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD6_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD6_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD6_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD6_BITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD6_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD6_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD6_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD6_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD6_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD7_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD7_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD7_SADDR_SADDR_Msk = 0xffffffff

	// TCD7_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD7_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD7_SOFF_SOFF_Msk = 0xffff

	// TCD7_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD7_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD7_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD7_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD7_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD7_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD7_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD7_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD7_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD7_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD7_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD7_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD7_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD7_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD7_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD7_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD7_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD7_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD7_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD7_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD7_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD7_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD7_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD7_ATTR_SMOD_SMOD_9 = 0x9

	// TCD7_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD7_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD7_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD7_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD7_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD7_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD7_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD7_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD7_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD7_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD7_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD7_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD7_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD7_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD7_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD7_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD7_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD7_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD7_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD7_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD7_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD7_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD7_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD7_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD7_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD7_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD7_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD7_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD7_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD7_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD7_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD7_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD7_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD7_SLAST_SLAST_Msk = 0xffffffff

	// TCD7_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD7_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD7_DADDR_DADDR_Msk = 0xffffffff

	// TCD7_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD7_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD7_DOFF_DOFF_Msk = 0xffff

	// TCD7_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD7_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD7_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD7_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD7_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD7_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD7_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD7_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD7_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD7_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD7_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD7_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD7_CITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD7_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD7_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD7_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD7_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD7_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD7_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD7_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD7_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD7_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD7_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD7_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD7_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD7_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD7_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD7_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD7_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD7_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD7_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD7_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD7_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD7_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD7_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD7_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD7_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD7_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD7_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD7_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD7_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD7_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD7_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD7_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD7_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD7_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD7_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD7_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD7_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD7_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD7_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD7_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD7_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD7_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD7_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD7_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD7_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD7_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD7_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD7_CSR_MAJORLINKCH_Msk = 0xf00
	// Position of BWC field.
	DMA_TCD7_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD7_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD7_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD7_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD7_CSR_BWC_BWC_3 = 0x3

	// TCD7_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD7_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD7_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD7_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD7_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD7_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD7_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD7_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD7_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD7_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD7_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD7_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD7_BITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD7_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD7_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD7_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD7_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD7_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD8_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD8_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD8_SADDR_SADDR_Msk = 0xffffffff

	// TCD8_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD8_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD8_SOFF_SOFF_Msk = 0xffff

	// TCD8_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD8_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD8_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD8_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD8_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD8_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD8_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD8_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD8_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD8_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD8_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD8_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD8_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD8_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD8_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD8_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD8_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD8_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD8_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD8_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD8_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD8_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD8_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD8_ATTR_SMOD_SMOD_9 = 0x9

	// TCD8_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD8_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD8_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD8_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD8_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD8_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD8_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD8_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD8_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD8_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD8_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD8_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD8_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD8_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD8_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD8_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD8_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD8_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD8_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD8_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD8_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD8_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD8_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD8_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD8_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD8_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD8_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD8_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD8_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD8_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD8_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD8_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD8_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD8_SLAST_SLAST_Msk = 0xffffffff

	// TCD8_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD8_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD8_DADDR_DADDR_Msk = 0xffffffff

	// TCD8_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD8_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD8_DOFF_DOFF_Msk = 0xffff

	// TCD8_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD8_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD8_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD8_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD8_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD8_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD8_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD8_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD8_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD8_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD8_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD8_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD8_CITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD8_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD8_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD8_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD8_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD8_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD8_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD8_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD8_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD8_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD8_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD8_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD8_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD8_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD8_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD8_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD8_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD8_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD8_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD8_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD8_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD8_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD8_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD8_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD8_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD8_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD8_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD8_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD8_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD8_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD8_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD8_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD8_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD8_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD8_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD8_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD8_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD8_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD8_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD8_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD8_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD8_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD8_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD8_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD8_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD8_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD8_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD8_CSR_MAJORLINKCH_Msk = 0xf00
	// Position of BWC field.
	DMA_TCD8_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD8_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD8_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD8_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD8_CSR_BWC_BWC_3 = 0x3

	// TCD8_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD8_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD8_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD8_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD8_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD8_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD8_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD8_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD8_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD8_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD8_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD8_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD8_BITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD8_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD8_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD8_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD8_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD8_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD9_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD9_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD9_SADDR_SADDR_Msk = 0xffffffff

	// TCD9_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD9_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD9_SOFF_SOFF_Msk = 0xffff

	// TCD9_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD9_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD9_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD9_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD9_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD9_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD9_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD9_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD9_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD9_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD9_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD9_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD9_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD9_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD9_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD9_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD9_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD9_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD9_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD9_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD9_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD9_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD9_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD9_ATTR_SMOD_SMOD_9 = 0x9

	// TCD9_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD9_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD9_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD9_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD9_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD9_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD9_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD9_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD9_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD9_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD9_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD9_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD9_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD9_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD9_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD9_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD9_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD9_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD9_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD9_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD9_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD9_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD9_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD9_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD9_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD9_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD9_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD9_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD9_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD9_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD9_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD9_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD9_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD9_SLAST_SLAST_Msk = 0xffffffff

	// TCD9_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD9_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD9_DADDR_DADDR_Msk = 0xffffffff

	// TCD9_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD9_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD9_DOFF_DOFF_Msk = 0xffff

	// TCD9_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD9_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD9_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD9_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD9_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD9_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD9_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD9_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD9_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD9_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD9_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD9_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD9_CITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD9_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD9_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD9_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD9_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD9_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD9_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD9_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD9_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD9_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD9_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD9_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD9_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD9_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD9_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD9_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD9_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD9_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD9_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD9_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD9_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD9_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD9_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD9_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD9_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD9_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD9_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD9_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD9_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD9_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD9_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD9_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD9_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD9_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD9_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD9_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD9_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD9_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD9_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD9_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD9_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD9_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD9_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD9_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD9_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD9_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD9_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD9_CSR_MAJORLINKCH_Msk = 0xf00
	// Position of BWC field.
	DMA_TCD9_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD9_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD9_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD9_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD9_CSR_BWC_BWC_3 = 0x3

	// TCD9_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD9_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD9_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD9_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD9_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD9_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD9_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD9_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD9_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD9_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD9_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD9_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD9_BITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD9_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD9_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD9_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD9_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD9_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD10_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD10_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD10_SADDR_SADDR_Msk = 0xffffffff

	// TCD10_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD10_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD10_SOFF_SOFF_Msk = 0xffff

	// TCD10_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD10_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD10_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD10_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD10_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD10_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD10_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD10_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD10_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD10_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD10_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD10_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD10_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD10_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD10_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD10_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD10_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD10_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD10_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD10_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD10_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD10_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD10_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD10_ATTR_SMOD_SMOD_9 = 0x9

	// TCD10_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD10_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD10_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD10_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD10_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD10_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD10_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD10_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD10_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD10_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD10_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD10_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD10_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD10_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD10_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD10_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD10_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD10_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD10_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD10_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD10_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD10_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD10_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD10_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD10_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD10_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD10_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD10_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD10_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD10_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD10_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD10_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD10_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD10_SLAST_SLAST_Msk = 0xffffffff

	// TCD10_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD10_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD10_DADDR_DADDR_Msk = 0xffffffff

	// TCD10_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD10_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD10_DOFF_DOFF_Msk = 0xffff

	// TCD10_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD10_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD10_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD10_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD10_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD10_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD10_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD10_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD10_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD10_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD10_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD10_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD10_CITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD10_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD10_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD10_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD10_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD10_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD10_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD10_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD10_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD10_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD10_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD10_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD10_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD10_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD10_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD10_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD10_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD10_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD10_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD10_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD10_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD10_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD10_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD10_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD10_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD10_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD10_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD10_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD10_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD10_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD10_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD10_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD10_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD10_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD10_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD10_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD10_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD10_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD10_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD10_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD10_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD10_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD10_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD10_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD10_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD10_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD10_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD10_CSR_MAJORLINKCH_Msk = 0xf00
	// Position of BWC field.
	DMA_TCD10_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD10_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD10_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD10_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD10_CSR_BWC_BWC_3 = 0x3

	// TCD10_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD10_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD10_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD10_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD10_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD10_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD10_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD10_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD10_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD10_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD10_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD10_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD10_BITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD10_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD10_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD10_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD10_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD10_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD11_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD11_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD11_SADDR_SADDR_Msk = 0xffffffff

	// TCD11_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD11_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD11_SOFF_SOFF_Msk = 0xffff

	// TCD11_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD11_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD11_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD11_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD11_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD11_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD11_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD11_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD11_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD11_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD11_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD11_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD11_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD11_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD11_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD11_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD11_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD11_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD11_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD11_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD11_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD11_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD11_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD11_ATTR_SMOD_SMOD_9 = 0x9

	// TCD11_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD11_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD11_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD11_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD11_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD11_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD11_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD11_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD11_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD11_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD11_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD11_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD11_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD11_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD11_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD11_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD11_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD11_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD11_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD11_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD11_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD11_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD11_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD11_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD11_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD11_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD11_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD11_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD11_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD11_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD11_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD11_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD11_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD11_SLAST_SLAST_Msk = 0xffffffff

	// TCD11_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD11_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD11_DADDR_DADDR_Msk = 0xffffffff

	// TCD11_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD11_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD11_DOFF_DOFF_Msk = 0xffff

	// TCD11_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD11_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD11_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD11_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD11_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD11_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD11_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD11_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD11_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD11_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD11_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD11_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD11_CITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD11_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD11_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD11_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD11_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD11_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD11_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD11_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD11_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD11_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD11_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD11_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD11_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD11_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD11_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD11_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD11_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD11_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD11_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD11_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD11_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD11_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD11_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD11_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD11_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD11_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD11_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD11_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD11_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD11_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD11_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD11_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD11_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD11_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD11_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD11_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD11_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD11_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD11_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD11_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD11_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD11_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD11_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD11_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD11_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD11_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD11_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD11_CSR_MAJORLINKCH_Msk = 0xf00
	// Position of BWC field.
	DMA_TCD11_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD11_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD11_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD11_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD11_CSR_BWC_BWC_3 = 0x3

	// TCD11_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD11_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD11_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD11_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD11_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD11_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD11_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD11_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD11_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD11_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD11_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD11_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD11_BITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD11_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD11_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD11_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD11_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD11_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD12_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD12_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD12_SADDR_SADDR_Msk = 0xffffffff

	// TCD12_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD12_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD12_SOFF_SOFF_Msk = 0xffff

	// TCD12_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD12_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD12_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD12_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD12_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD12_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD12_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD12_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD12_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD12_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD12_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD12_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD12_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD12_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD12_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD12_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD12_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD12_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD12_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD12_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD12_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD12_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD12_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD12_ATTR_SMOD_SMOD_9 = 0x9

	// TCD12_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD12_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD12_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD12_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD12_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD12_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD12_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD12_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD12_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD12_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD12_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD12_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD12_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD12_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD12_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD12_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD12_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD12_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD12_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD12_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD12_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD12_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD12_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD12_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD12_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD12_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD12_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD12_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD12_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD12_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD12_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD12_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD12_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD12_SLAST_SLAST_Msk = 0xffffffff

	// TCD12_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD12_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD12_DADDR_DADDR_Msk = 0xffffffff

	// TCD12_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD12_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD12_DOFF_DOFF_Msk = 0xffff

	// TCD12_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD12_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD12_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD12_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD12_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD12_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD12_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD12_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD12_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD12_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD12_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD12_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD12_CITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD12_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD12_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD12_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD12_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD12_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD12_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD12_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD12_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD12_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD12_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD12_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD12_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD12_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD12_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD12_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD12_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD12_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD12_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD12_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD12_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD12_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD12_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD12_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD12_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD12_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD12_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD12_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD12_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD12_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD12_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD12_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD12_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD12_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD12_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD12_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD12_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD12_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD12_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD12_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD12_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD12_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD12_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD12_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD12_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD12_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD12_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD12_CSR_MAJORLINKCH_Msk = 0xf00
	// Position of BWC field.
	DMA_TCD12_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD12_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD12_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD12_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD12_CSR_BWC_BWC_3 = 0x3

	// TCD12_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD12_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD12_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD12_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD12_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD12_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD12_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD12_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD12_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD12_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD12_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD12_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD12_BITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD12_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD12_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD12_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD12_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD12_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD13_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD13_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD13_SADDR_SADDR_Msk = 0xffffffff

	// TCD13_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD13_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD13_SOFF_SOFF_Msk = 0xffff

	// TCD13_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD13_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD13_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD13_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD13_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD13_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD13_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD13_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD13_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD13_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD13_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD13_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD13_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD13_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD13_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD13_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD13_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD13_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD13_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD13_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD13_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD13_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD13_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD13_ATTR_SMOD_SMOD_9 = 0x9

	// TCD13_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD13_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD13_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD13_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD13_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD13_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD13_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD13_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD13_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD13_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD13_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD13_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD13_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD13_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD13_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD13_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD13_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD13_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD13_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD13_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD13_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD13_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD13_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD13_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD13_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD13_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD13_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD13_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD13_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD13_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD13_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD13_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD13_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD13_SLAST_SLAST_Msk = 0xffffffff

	// TCD13_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD13_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD13_DADDR_DADDR_Msk = 0xffffffff

	// TCD13_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD13_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD13_DOFF_DOFF_Msk = 0xffff

	// TCD13_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD13_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD13_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD13_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD13_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD13_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD13_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD13_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD13_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD13_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD13_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD13_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD13_CITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD13_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD13_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD13_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD13_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD13_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD13_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD13_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD13_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD13_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD13_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD13_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD13_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD13_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD13_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD13_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD13_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD13_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD13_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD13_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD13_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD13_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD13_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD13_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD13_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD13_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD13_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD13_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD13_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD13_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD13_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD13_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD13_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD13_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD13_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD13_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD13_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD13_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD13_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD13_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD13_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD13_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD13_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD13_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD13_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD13_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD13_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD13_CSR_MAJORLINKCH_Msk = 0xf00
	// Position of BWC field.
	DMA_TCD13_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD13_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD13_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD13_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD13_CSR_BWC_BWC_3 = 0x3

	// TCD13_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD13_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD13_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD13_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD13_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD13_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD13_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD13_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD13_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD13_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD13_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD13_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD13_BITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD13_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD13_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD13_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD13_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD13_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD14_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD14_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD14_SADDR_SADDR_Msk = 0xffffffff

	// TCD14_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD14_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD14_SOFF_SOFF_Msk = 0xffff

	// TCD14_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD14_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD14_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD14_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD14_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD14_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD14_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD14_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD14_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD14_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD14_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD14_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD14_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD14_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD14_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD14_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD14_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD14_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD14_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD14_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD14_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD14_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD14_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD14_ATTR_SMOD_SMOD_9 = 0x9

	// TCD14_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD14_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD14_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD14_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD14_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD14_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD14_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD14_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD14_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD14_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD14_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD14_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD14_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD14_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD14_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD14_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD14_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD14_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD14_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD14_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD14_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD14_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD14_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD14_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD14_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD14_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD14_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD14_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD14_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD14_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD14_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD14_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD14_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD14_SLAST_SLAST_Msk = 0xffffffff

	// TCD14_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD14_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD14_DADDR_DADDR_Msk = 0xffffffff

	// TCD14_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD14_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD14_DOFF_DOFF_Msk = 0xffff

	// TCD14_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD14_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD14_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD14_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD14_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD14_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD14_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD14_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD14_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD14_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD14_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD14_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD14_CITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD14_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD14_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD14_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD14_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD14_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD14_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD14_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD14_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD14_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD14_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD14_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD14_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD14_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD14_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD14_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD14_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD14_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD14_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD14_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD14_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD14_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD14_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD14_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD14_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD14_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD14_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD14_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD14_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD14_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD14_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD14_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD14_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD14_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD14_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD14_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD14_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD14_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD14_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD14_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD14_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD14_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD14_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD14_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD14_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD14_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD14_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD14_CSR_MAJORLINKCH_Msk = 0xf00
	// Position of BWC field.
	DMA_TCD14_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD14_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD14_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD14_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD14_CSR_BWC_BWC_3 = 0x3

	// TCD14_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD14_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD14_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD14_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD14_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD14_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD14_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD14_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD14_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD14_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD14_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD14_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD14_BITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD14_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD14_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD14_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD14_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD14_BITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD15_SADDR: TCD Source Address
	// Position of SADDR field.
	DMA_TCD15_SADDR_SADDR_Pos = 0x0
	// Bit mask of SADDR field.
	DMA_TCD15_SADDR_SADDR_Msk = 0xffffffff

	// TCD15_SOFF: TCD Signed Source Address Offset
	// Position of SOFF field.
	DMA_TCD15_SOFF_SOFF_Pos = 0x0
	// Bit mask of SOFF field.
	DMA_TCD15_SOFF_SOFF_Msk = 0xffff

	// TCD15_ATTR: TCD Transfer Attributes
	// Position of DSIZE field.
	DMA_TCD15_ATTR_DSIZE_Pos = 0x0
	// Bit mask of DSIZE field.
	DMA_TCD15_ATTR_DSIZE_Msk = 0x7
	// Position of DMOD field.
	DMA_TCD15_ATTR_DMOD_Pos = 0x3
	// Bit mask of DMOD field.
	DMA_TCD15_ATTR_DMOD_Msk = 0xf8
	// Position of SSIZE field.
	DMA_TCD15_ATTR_SSIZE_Pos = 0x8
	// Bit mask of SSIZE field.
	DMA_TCD15_ATTR_SSIZE_Msk = 0x700
	// 8-bit
	DMA_TCD15_ATTR_SSIZE_SSIZE_0 = 0x0
	// 16-bit
	DMA_TCD15_ATTR_SSIZE_SSIZE_1 = 0x1
	// 32-bit
	DMA_TCD15_ATTR_SSIZE_SSIZE_2 = 0x2
	// 64-bit
	DMA_TCD15_ATTR_SSIZE_SSIZE_3 = 0x3
	// 32-byte burst (4 beats of 64 bits)
	DMA_TCD15_ATTR_SSIZE_SSIZE_5 = 0x5
	// Position of SMOD field.
	DMA_TCD15_ATTR_SMOD_Pos = 0xb
	// Bit mask of SMOD field.
	DMA_TCD15_ATTR_SMOD_Msk = 0xf800
	// Source address modulo feature is disabled
	DMA_TCD15_ATTR_SMOD_SMOD_0 = 0x0
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD15_ATTR_SMOD_SMOD_1 = 0x1
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD15_ATTR_SMOD_SMOD_2 = 0x2
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD15_ATTR_SMOD_SMOD_3 = 0x3
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD15_ATTR_SMOD_SMOD_4 = 0x4
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD15_ATTR_SMOD_SMOD_5 = 0x5
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD15_ATTR_SMOD_SMOD_6 = 0x6
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD15_ATTR_SMOD_SMOD_7 = 0x7
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD15_ATTR_SMOD_SMOD_8 = 0x8
	// This value defines a specific address range specified to be the value after SADDR + SOFF calculation is performed on the original register value. Setting this field provides the ability to implement a circular data queue easily. For data queues requiring power-of-2 size bytes, the queue should start at a 0-modulo-size address and the SMOD field should be set to the appropriate value for the queue, freezing the desired number of upper address bits. The value programmed into this field specifies the number of lower address bits allowed to change. For a circular queue application, the SOFF is typically set to the transfer size to implement post-increment addressing with the SMOD function constraining the addresses to a 0-modulo-size range.
	DMA_TCD15_ATTR_SMOD_SMOD_9 = 0x9

	// TCD15_NBYTES_MLNO: TCD Minor Byte Count (Minor Loop Mapping Disabled)
	// Position of NBYTES field.
	DMA_TCD15_NBYTES_MLNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD15_NBYTES_MLNO_NBYTES_Msk = 0xffffffff

	// TCD15_NBYTES_MLOFFNO: TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
	// Position of NBYTES field.
	DMA_TCD15_NBYTES_MLOFFNO_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD15_NBYTES_MLOFFNO_NBYTES_Msk = 0x3fffffff
	// Position of DMLOE field.
	DMA_TCD15_NBYTES_MLOFFNO_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD15_NBYTES_MLOFFNO_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD15_NBYTES_MLOFFNO_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD15_NBYTES_MLOFFNO_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD15_NBYTES_MLOFFNO_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD15_NBYTES_MLOFFNO_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD15_NBYTES_MLOFFNO_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD15_NBYTES_MLOFFNO_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD15_NBYTES_MLOFFNO_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD15_NBYTES_MLOFFNO_SMLOE_SMLOE_1 = 0x1

	// TCD15_NBYTES_MLOFFYES: TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
	// Position of NBYTES field.
	DMA_TCD15_NBYTES_MLOFFYES_NBYTES_Pos = 0x0
	// Bit mask of NBYTES field.
	DMA_TCD15_NBYTES_MLOFFYES_NBYTES_Msk = 0x3ff
	// Position of MLOFF field.
	DMA_TCD15_NBYTES_MLOFFYES_MLOFF_Pos = 0xa
	// Bit mask of MLOFF field.
	DMA_TCD15_NBYTES_MLOFFYES_MLOFF_Msk = 0x3ffffc00
	// Position of DMLOE field.
	DMA_TCD15_NBYTES_MLOFFYES_DMLOE_Pos = 0x1e
	// Bit mask of DMLOE field.
	DMA_TCD15_NBYTES_MLOFFYES_DMLOE_Msk = 0x40000000
	// Bit DMLOE.
	DMA_TCD15_NBYTES_MLOFFYES_DMLOE = 0x40000000
	// The minor loop offset is not applied to the DADDR
	DMA_TCD15_NBYTES_MLOFFYES_DMLOE_DMLOE_0 = 0x0
	// The minor loop offset is applied to the DADDR
	DMA_TCD15_NBYTES_MLOFFYES_DMLOE_DMLOE_1 = 0x1
	// Position of SMLOE field.
	DMA_TCD15_NBYTES_MLOFFYES_SMLOE_Pos = 0x1f
	// Bit mask of SMLOE field.
	DMA_TCD15_NBYTES_MLOFFYES_SMLOE_Msk = 0x80000000
	// Bit SMLOE.
	DMA_TCD15_NBYTES_MLOFFYES_SMLOE = 0x80000000
	// The minor loop offset is not applied to the SADDR
	DMA_TCD15_NBYTES_MLOFFYES_SMLOE_SMLOE_0 = 0x0
	// The minor loop offset is applied to the SADDR
	DMA_TCD15_NBYTES_MLOFFYES_SMLOE_SMLOE_1 = 0x1

	// TCD15_SLAST: TCD Last Source Address Adjustment
	// Position of SLAST field.
	DMA_TCD15_SLAST_SLAST_Pos = 0x0
	// Bit mask of SLAST field.
	DMA_TCD15_SLAST_SLAST_Msk = 0xffffffff

	// TCD15_DADDR: TCD Destination Address
	// Position of DADDR field.
	DMA_TCD15_DADDR_DADDR_Pos = 0x0
	// Bit mask of DADDR field.
	DMA_TCD15_DADDR_DADDR_Msk = 0xffffffff

	// TCD15_DOFF: TCD Signed Destination Address Offset
	// Position of DOFF field.
	DMA_TCD15_DOFF_DOFF_Pos = 0x0
	// Bit mask of DOFF field.
	DMA_TCD15_DOFF_DOFF_Msk = 0xffff

	// TCD15_CITER_ELINKNO: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of CITER field.
	DMA_TCD15_CITER_ELINKNO_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD15_CITER_ELINKNO_CITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD15_CITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD15_CITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD15_CITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD15_CITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD15_CITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD15_CITER_ELINKYES: TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of CITER field.
	DMA_TCD15_CITER_ELINKYES_CITER_Pos = 0x0
	// Bit mask of CITER field.
	DMA_TCD15_CITER_ELINKYES_CITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD15_CITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD15_CITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD15_CITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD15_CITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD15_CITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD15_CITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD15_CITER_ELINKYES_ELINK_ELINK_1 = 0x1

	// TCD15_DLASTSGA: TCD Last Destination Address Adjustment/Scatter Gather Address
	// Position of DLASTSGA field.
	DMA_TCD15_DLASTSGA_DLASTSGA_Pos = 0x0
	// Bit mask of DLASTSGA field.
	DMA_TCD15_DLASTSGA_DLASTSGA_Msk = 0xffffffff

	// TCD15_CSR: TCD Control and Status
	// Position of START field.
	DMA_TCD15_CSR_START_Pos = 0x0
	// Bit mask of START field.
	DMA_TCD15_CSR_START_Msk = 0x1
	// Bit START.
	DMA_TCD15_CSR_START = 0x1
	// The channel is not explicitly started.
	DMA_TCD15_CSR_START_START_0 = 0x0
	// The channel is explicitly started via a software initiated service request.
	DMA_TCD15_CSR_START_START_1 = 0x1
	// Position of INTMAJOR field.
	DMA_TCD15_CSR_INTMAJOR_Pos = 0x1
	// Bit mask of INTMAJOR field.
	DMA_TCD15_CSR_INTMAJOR_Msk = 0x2
	// Bit INTMAJOR.
	DMA_TCD15_CSR_INTMAJOR = 0x2
	// The end-of-major loop interrupt is disabled.
	DMA_TCD15_CSR_INTMAJOR_INTMAJOR_0 = 0x0
	// The end-of-major loop interrupt is enabled.
	DMA_TCD15_CSR_INTMAJOR_INTMAJOR_1 = 0x1
	// Position of INTHALF field.
	DMA_TCD15_CSR_INTHALF_Pos = 0x2
	// Bit mask of INTHALF field.
	DMA_TCD15_CSR_INTHALF_Msk = 0x4
	// Bit INTHALF.
	DMA_TCD15_CSR_INTHALF = 0x4
	// The half-point interrupt is disabled.
	DMA_TCD15_CSR_INTHALF_INTHALF_0 = 0x0
	// The half-point interrupt is enabled.
	DMA_TCD15_CSR_INTHALF_INTHALF_1 = 0x1
	// Position of DREQ field.
	DMA_TCD15_CSR_DREQ_Pos = 0x3
	// Bit mask of DREQ field.
	DMA_TCD15_CSR_DREQ_Msk = 0x8
	// Bit DREQ.
	DMA_TCD15_CSR_DREQ = 0x8
	// The channel's ERQ bit is not affected.
	DMA_TCD15_CSR_DREQ_DREQ_0 = 0x0
	// The channel's ERQ bit is cleared when the major loop is complete.
	DMA_TCD15_CSR_DREQ_DREQ_1 = 0x1
	// Position of ESG field.
	DMA_TCD15_CSR_ESG_Pos = 0x4
	// Bit mask of ESG field.
	DMA_TCD15_CSR_ESG_Msk = 0x10
	// Bit ESG.
	DMA_TCD15_CSR_ESG = 0x10
	// The current channel's TCD is normal format.
	DMA_TCD15_CSR_ESG_ESG_0 = 0x0
	// The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
	DMA_TCD15_CSR_ESG_ESG_1 = 0x1
	// Position of MAJORELINK field.
	DMA_TCD15_CSR_MAJORELINK_Pos = 0x5
	// Bit mask of MAJORELINK field.
	DMA_TCD15_CSR_MAJORELINK_Msk = 0x20
	// Bit MAJORELINK.
	DMA_TCD15_CSR_MAJORELINK = 0x20
	// The channel-to-channel linking is disabled.
	DMA_TCD15_CSR_MAJORELINK_MAJORELINK_0 = 0x0
	// The channel-to-channel linking is enabled.
	DMA_TCD15_CSR_MAJORELINK_MAJORELINK_1 = 0x1
	// Position of ACTIVE field.
	DMA_TCD15_CSR_ACTIVE_Pos = 0x6
	// Bit mask of ACTIVE field.
	DMA_TCD15_CSR_ACTIVE_Msk = 0x40
	// Bit ACTIVE.
	DMA_TCD15_CSR_ACTIVE = 0x40
	// Position of DONE field.
	DMA_TCD15_CSR_DONE_Pos = 0x7
	// Bit mask of DONE field.
	DMA_TCD15_CSR_DONE_Msk = 0x80
	// Bit DONE.
	DMA_TCD15_CSR_DONE = 0x80
	// Position of MAJORLINKCH field.
	DMA_TCD15_CSR_MAJORLINKCH_Pos = 0x8
	// Bit mask of MAJORLINKCH field.
	DMA_TCD15_CSR_MAJORLINKCH_Msk = 0xf00
	// Position of BWC field.
	DMA_TCD15_CSR_BWC_Pos = 0xe
	// Bit mask of BWC field.
	DMA_TCD15_CSR_BWC_Msk = 0xc000
	// No eDMA engine stalls.
	DMA_TCD15_CSR_BWC_BWC_0 = 0x0
	// eDMA engine stalls for 4 cycles after each R/W.
	DMA_TCD15_CSR_BWC_BWC_2 = 0x2
	// eDMA engine stalls for 8 cycles after each R/W.
	DMA_TCD15_CSR_BWC_BWC_3 = 0x3

	// TCD15_BITER_ELINKNO: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
	// Position of BITER field.
	DMA_TCD15_BITER_ELINKNO_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD15_BITER_ELINKNO_BITER_Msk = 0x7fff
	// Position of ELINK field.
	DMA_TCD15_BITER_ELINKNO_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD15_BITER_ELINKNO_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD15_BITER_ELINKNO_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD15_BITER_ELINKNO_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD15_BITER_ELINKNO_ELINK_ELINK_1 = 0x1

	// TCD15_BITER_ELINKYES: TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
	// Position of BITER field.
	DMA_TCD15_BITER_ELINKYES_BITER_Pos = 0x0
	// Bit mask of BITER field.
	DMA_TCD15_BITER_ELINKYES_BITER_Msk = 0x1ff
	// Position of LINKCH field.
	DMA_TCD15_BITER_ELINKYES_LINKCH_Pos = 0x9
	// Bit mask of LINKCH field.
	DMA_TCD15_BITER_ELINKYES_LINKCH_Msk = 0x1e00
	// Position of ELINK field.
	DMA_TCD15_BITER_ELINKYES_ELINK_Pos = 0xf
	// Bit mask of ELINK field.
	DMA_TCD15_BITER_ELINKYES_ELINK_Msk = 0x8000
	// Bit ELINK.
	DMA_TCD15_BITER_ELINKYES_ELINK = 0x8000
	// The channel-to-channel linking is disabled
	DMA_TCD15_BITER_ELINKYES_ELINK_ELINK_0 = 0x0
	// The channel-to-channel linking is enabled
	DMA_TCD15_BITER_ELINKYES_ELINK_ELINK_1 = 0x1
)

// Constants for DMAMUX: DMAMUX
const (
	// CHCFG: Channel 0 Configuration Register
	// Position of SOURCE field.
	DMAMUX_CHCFG_SOURCE_Pos = 0x0
	// Bit mask of SOURCE field.
	DMAMUX_CHCFG_SOURCE_Msk = 0x7f
	// Position of A_ON field.
	DMAMUX_CHCFG_A_ON_Pos = 0x1d
	// Bit mask of A_ON field.
	DMAMUX_CHCFG_A_ON_Msk = 0x20000000
	// Bit A_ON.
	DMAMUX_CHCFG_A_ON = 0x20000000
	// DMA Channel Always ON function is disabled
	DMAMUX_CHCFG_A_ON_A_ON_0 = 0x0
	// DMA Channel Always ON function is enabled
	DMAMUX_CHCFG_A_ON_A_ON_1 = 0x1
	// Position of TRIG field.
	DMAMUX_CHCFG_TRIG_Pos = 0x1e
	// Bit mask of TRIG field.
	DMAMUX_CHCFG_TRIG_Msk = 0x40000000
	// Bit TRIG.
	DMAMUX_CHCFG_TRIG = 0x40000000
	// Triggering is disabled. If triggering is disabled and ENBL is set, the DMA Channel will simply route the specified source to the DMA channel. (Normal mode)
	DMAMUX_CHCFG_TRIG_TRIG_0 = 0x0
	// Triggering is enabled. If triggering is enabled and ENBL is set, the DMA_CH_MUX is in Periodic Trigger mode.
	DMAMUX_CHCFG_TRIG_TRIG_1 = 0x1
	// Position of ENBL field.
	DMAMUX_CHCFG_ENBL_Pos = 0x1f
	// Bit mask of ENBL field.
	DMAMUX_CHCFG_ENBL_Msk = 0x80000000
	// Bit ENBL.
	DMAMUX_CHCFG_ENBL = 0x80000000
	// DMA Mux channel is disabled
	DMAMUX_CHCFG_ENBL_ENBL_0 = 0x0
	// DMA Mux channel is enabled
	DMAMUX_CHCFG_ENBL_ENBL_1 = 0x1
)

// Constants for DCP: DCP register reference index
const (
	// CTRL: DCP control register 0
	// Position of CHANNEL_INTERRUPT_ENABLE field.
	DCP_CTRL_CHANNEL_INTERRUPT_ENABLE_Pos = 0x0
	// Bit mask of CHANNEL_INTERRUPT_ENABLE field.
	DCP_CTRL_CHANNEL_INTERRUPT_ENABLE_Msk = 0xff
	// CH0
	DCP_CTRL_CHANNEL_INTERRUPT_ENABLE_CH0 = 0x1
	// CH1
	DCP_CTRL_CHANNEL_INTERRUPT_ENABLE_CH1 = 0x2
	// CH2
	DCP_CTRL_CHANNEL_INTERRUPT_ENABLE_CH2 = 0x4
	// CH3
	DCP_CTRL_CHANNEL_INTERRUPT_ENABLE_CH3 = 0x8
	// Position of ENABLE_CONTEXT_SWITCHING field.
	DCP_CTRL_ENABLE_CONTEXT_SWITCHING_Pos = 0x15
	// Bit mask of ENABLE_CONTEXT_SWITCHING field.
	DCP_CTRL_ENABLE_CONTEXT_SWITCHING_Msk = 0x200000
	// Bit ENABLE_CONTEXT_SWITCHING.
	DCP_CTRL_ENABLE_CONTEXT_SWITCHING = 0x200000
	// Position of ENABLE_CONTEXT_CACHING field.
	DCP_CTRL_ENABLE_CONTEXT_CACHING_Pos = 0x16
	// Bit mask of ENABLE_CONTEXT_CACHING field.
	DCP_CTRL_ENABLE_CONTEXT_CACHING_Msk = 0x400000
	// Bit ENABLE_CONTEXT_CACHING.
	DCP_CTRL_ENABLE_CONTEXT_CACHING = 0x400000
	// Position of GATHER_RESIDUAL_WRITES field.
	DCP_CTRL_GATHER_RESIDUAL_WRITES_Pos = 0x17
	// Bit mask of GATHER_RESIDUAL_WRITES field.
	DCP_CTRL_GATHER_RESIDUAL_WRITES_Msk = 0x800000
	// Bit GATHER_RESIDUAL_WRITES.
	DCP_CTRL_GATHER_RESIDUAL_WRITES = 0x800000
	// Position of PRESENT_SHA field.
	DCP_CTRL_PRESENT_SHA_Pos = 0x1c
	// Bit mask of PRESENT_SHA field.
	DCP_CTRL_PRESENT_SHA_Msk = 0x10000000
	// Bit PRESENT_SHA.
	DCP_CTRL_PRESENT_SHA = 0x10000000
	// Absent
	DCP_CTRL_PRESENT_SHA_Absent = 0x0
	// Present
	DCP_CTRL_PRESENT_SHA_Present = 0x1
	// Position of PRESENT_CRYPTO field.
	DCP_CTRL_PRESENT_CRYPTO_Pos = 0x1d
	// Bit mask of PRESENT_CRYPTO field.
	DCP_CTRL_PRESENT_CRYPTO_Msk = 0x20000000
	// Bit PRESENT_CRYPTO.
	DCP_CTRL_PRESENT_CRYPTO = 0x20000000
	// Absent
	DCP_CTRL_PRESENT_CRYPTO_Absent = 0x0
	// Present
	DCP_CTRL_PRESENT_CRYPTO_Present = 0x1
	// Position of CLKGATE field.
	DCP_CTRL_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	DCP_CTRL_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	DCP_CTRL_CLKGATE = 0x40000000
	// Position of SFTRST field.
	DCP_CTRL_SFTRST_Pos = 0x1f
	// Bit mask of SFTRST field.
	DCP_CTRL_SFTRST_Msk = 0x80000000
	// Bit SFTRST.
	DCP_CTRL_SFTRST = 0x80000000

	// CTRL_SET: DCP control register 0
	// Position of CHANNEL_INTERRUPT_ENABLE field.
	DCP_CTRL_SET_CHANNEL_INTERRUPT_ENABLE_Pos = 0x0
	// Bit mask of CHANNEL_INTERRUPT_ENABLE field.
	DCP_CTRL_SET_CHANNEL_INTERRUPT_ENABLE_Msk = 0xff
	// CH0
	DCP_CTRL_SET_CHANNEL_INTERRUPT_ENABLE_CH0 = 0x1
	// CH1
	DCP_CTRL_SET_CHANNEL_INTERRUPT_ENABLE_CH1 = 0x2
	// CH2
	DCP_CTRL_SET_CHANNEL_INTERRUPT_ENABLE_CH2 = 0x4
	// CH3
	DCP_CTRL_SET_CHANNEL_INTERRUPT_ENABLE_CH3 = 0x8
	// Position of ENABLE_CONTEXT_SWITCHING field.
	DCP_CTRL_SET_ENABLE_CONTEXT_SWITCHING_Pos = 0x15
	// Bit mask of ENABLE_CONTEXT_SWITCHING field.
	DCP_CTRL_SET_ENABLE_CONTEXT_SWITCHING_Msk = 0x200000
	// Bit ENABLE_CONTEXT_SWITCHING.
	DCP_CTRL_SET_ENABLE_CONTEXT_SWITCHING = 0x200000
	// Position of ENABLE_CONTEXT_CACHING field.
	DCP_CTRL_SET_ENABLE_CONTEXT_CACHING_Pos = 0x16
	// Bit mask of ENABLE_CONTEXT_CACHING field.
	DCP_CTRL_SET_ENABLE_CONTEXT_CACHING_Msk = 0x400000
	// Bit ENABLE_CONTEXT_CACHING.
	DCP_CTRL_SET_ENABLE_CONTEXT_CACHING = 0x400000
	// Position of GATHER_RESIDUAL_WRITES field.
	DCP_CTRL_SET_GATHER_RESIDUAL_WRITES_Pos = 0x17
	// Bit mask of GATHER_RESIDUAL_WRITES field.
	DCP_CTRL_SET_GATHER_RESIDUAL_WRITES_Msk = 0x800000
	// Bit GATHER_RESIDUAL_WRITES.
	DCP_CTRL_SET_GATHER_RESIDUAL_WRITES = 0x800000
	// Position of PRESENT_SHA field.
	DCP_CTRL_SET_PRESENT_SHA_Pos = 0x1c
	// Bit mask of PRESENT_SHA field.
	DCP_CTRL_SET_PRESENT_SHA_Msk = 0x10000000
	// Bit PRESENT_SHA.
	DCP_CTRL_SET_PRESENT_SHA = 0x10000000
	// Absent
	DCP_CTRL_SET_PRESENT_SHA_Absent = 0x0
	// Present
	DCP_CTRL_SET_PRESENT_SHA_Present = 0x1
	// Position of PRESENT_CRYPTO field.
	DCP_CTRL_SET_PRESENT_CRYPTO_Pos = 0x1d
	// Bit mask of PRESENT_CRYPTO field.
	DCP_CTRL_SET_PRESENT_CRYPTO_Msk = 0x20000000
	// Bit PRESENT_CRYPTO.
	DCP_CTRL_SET_PRESENT_CRYPTO = 0x20000000
	// Absent
	DCP_CTRL_SET_PRESENT_CRYPTO_Absent = 0x0
	// Present
	DCP_CTRL_SET_PRESENT_CRYPTO_Present = 0x1
	// Position of CLKGATE field.
	DCP_CTRL_SET_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	DCP_CTRL_SET_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	DCP_CTRL_SET_CLKGATE = 0x40000000
	// Position of SFTRST field.
	DCP_CTRL_SET_SFTRST_Pos = 0x1f
	// Bit mask of SFTRST field.
	DCP_CTRL_SET_SFTRST_Msk = 0x80000000
	// Bit SFTRST.
	DCP_CTRL_SET_SFTRST = 0x80000000

	// CTRL_CLR: DCP control register 0
	// Position of CHANNEL_INTERRUPT_ENABLE field.
	DCP_CTRL_CLR_CHANNEL_INTERRUPT_ENABLE_Pos = 0x0
	// Bit mask of CHANNEL_INTERRUPT_ENABLE field.
	DCP_CTRL_CLR_CHANNEL_INTERRUPT_ENABLE_Msk = 0xff
	// CH0
	DCP_CTRL_CLR_CHANNEL_INTERRUPT_ENABLE_CH0 = 0x1
	// CH1
	DCP_CTRL_CLR_CHANNEL_INTERRUPT_ENABLE_CH1 = 0x2
	// CH2
	DCP_CTRL_CLR_CHANNEL_INTERRUPT_ENABLE_CH2 = 0x4
	// CH3
	DCP_CTRL_CLR_CHANNEL_INTERRUPT_ENABLE_CH3 = 0x8
	// Position of ENABLE_CONTEXT_SWITCHING field.
	DCP_CTRL_CLR_ENABLE_CONTEXT_SWITCHING_Pos = 0x15
	// Bit mask of ENABLE_CONTEXT_SWITCHING field.
	DCP_CTRL_CLR_ENABLE_CONTEXT_SWITCHING_Msk = 0x200000
	// Bit ENABLE_CONTEXT_SWITCHING.
	DCP_CTRL_CLR_ENABLE_CONTEXT_SWITCHING = 0x200000
	// Position of ENABLE_CONTEXT_CACHING field.
	DCP_CTRL_CLR_ENABLE_CONTEXT_CACHING_Pos = 0x16
	// Bit mask of ENABLE_CONTEXT_CACHING field.
	DCP_CTRL_CLR_ENABLE_CONTEXT_CACHING_Msk = 0x400000
	// Bit ENABLE_CONTEXT_CACHING.
	DCP_CTRL_CLR_ENABLE_CONTEXT_CACHING = 0x400000
	// Position of GATHER_RESIDUAL_WRITES field.
	DCP_CTRL_CLR_GATHER_RESIDUAL_WRITES_Pos = 0x17
	// Bit mask of GATHER_RESIDUAL_WRITES field.
	DCP_CTRL_CLR_GATHER_RESIDUAL_WRITES_Msk = 0x800000
	// Bit GATHER_RESIDUAL_WRITES.
	DCP_CTRL_CLR_GATHER_RESIDUAL_WRITES = 0x800000
	// Position of PRESENT_SHA field.
	DCP_CTRL_CLR_PRESENT_SHA_Pos = 0x1c
	// Bit mask of PRESENT_SHA field.
	DCP_CTRL_CLR_PRESENT_SHA_Msk = 0x10000000
	// Bit PRESENT_SHA.
	DCP_CTRL_CLR_PRESENT_SHA = 0x10000000
	// Absent
	DCP_CTRL_CLR_PRESENT_SHA_Absent = 0x0
	// Present
	DCP_CTRL_CLR_PRESENT_SHA_Present = 0x1
	// Position of PRESENT_CRYPTO field.
	DCP_CTRL_CLR_PRESENT_CRYPTO_Pos = 0x1d
	// Bit mask of PRESENT_CRYPTO field.
	DCP_CTRL_CLR_PRESENT_CRYPTO_Msk = 0x20000000
	// Bit PRESENT_CRYPTO.
	DCP_CTRL_CLR_PRESENT_CRYPTO = 0x20000000
	// Absent
	DCP_CTRL_CLR_PRESENT_CRYPTO_Absent = 0x0
	// Present
	DCP_CTRL_CLR_PRESENT_CRYPTO_Present = 0x1
	// Position of CLKGATE field.
	DCP_CTRL_CLR_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	DCP_CTRL_CLR_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	DCP_CTRL_CLR_CLKGATE = 0x40000000
	// Position of SFTRST field.
	DCP_CTRL_CLR_SFTRST_Pos = 0x1f
	// Bit mask of SFTRST field.
	DCP_CTRL_CLR_SFTRST_Msk = 0x80000000
	// Bit SFTRST.
	DCP_CTRL_CLR_SFTRST = 0x80000000

	// CTRL_TOG: DCP control register 0
	// Position of CHANNEL_INTERRUPT_ENABLE field.
	DCP_CTRL_TOG_CHANNEL_INTERRUPT_ENABLE_Pos = 0x0
	// Bit mask of CHANNEL_INTERRUPT_ENABLE field.
	DCP_CTRL_TOG_CHANNEL_INTERRUPT_ENABLE_Msk = 0xff
	// CH0
	DCP_CTRL_TOG_CHANNEL_INTERRUPT_ENABLE_CH0 = 0x1
	// CH1
	DCP_CTRL_TOG_CHANNEL_INTERRUPT_ENABLE_CH1 = 0x2
	// CH2
	DCP_CTRL_TOG_CHANNEL_INTERRUPT_ENABLE_CH2 = 0x4
	// CH3
	DCP_CTRL_TOG_CHANNEL_INTERRUPT_ENABLE_CH3 = 0x8
	// Position of ENABLE_CONTEXT_SWITCHING field.
	DCP_CTRL_TOG_ENABLE_CONTEXT_SWITCHING_Pos = 0x15
	// Bit mask of ENABLE_CONTEXT_SWITCHING field.
	DCP_CTRL_TOG_ENABLE_CONTEXT_SWITCHING_Msk = 0x200000
	// Bit ENABLE_CONTEXT_SWITCHING.
	DCP_CTRL_TOG_ENABLE_CONTEXT_SWITCHING = 0x200000
	// Position of ENABLE_CONTEXT_CACHING field.
	DCP_CTRL_TOG_ENABLE_CONTEXT_CACHING_Pos = 0x16
	// Bit mask of ENABLE_CONTEXT_CACHING field.
	DCP_CTRL_TOG_ENABLE_CONTEXT_CACHING_Msk = 0x400000
	// Bit ENABLE_CONTEXT_CACHING.
	DCP_CTRL_TOG_ENABLE_CONTEXT_CACHING = 0x400000
	// Position of GATHER_RESIDUAL_WRITES field.
	DCP_CTRL_TOG_GATHER_RESIDUAL_WRITES_Pos = 0x17
	// Bit mask of GATHER_RESIDUAL_WRITES field.
	DCP_CTRL_TOG_GATHER_RESIDUAL_WRITES_Msk = 0x800000
	// Bit GATHER_RESIDUAL_WRITES.
	DCP_CTRL_TOG_GATHER_RESIDUAL_WRITES = 0x800000
	// Position of PRESENT_SHA field.
	DCP_CTRL_TOG_PRESENT_SHA_Pos = 0x1c
	// Bit mask of PRESENT_SHA field.
	DCP_CTRL_TOG_PRESENT_SHA_Msk = 0x10000000
	// Bit PRESENT_SHA.
	DCP_CTRL_TOG_PRESENT_SHA = 0x10000000
	// Absent
	DCP_CTRL_TOG_PRESENT_SHA_Absent = 0x0
	// Present
	DCP_CTRL_TOG_PRESENT_SHA_Present = 0x1
	// Position of PRESENT_CRYPTO field.
	DCP_CTRL_TOG_PRESENT_CRYPTO_Pos = 0x1d
	// Bit mask of PRESENT_CRYPTO field.
	DCP_CTRL_TOG_PRESENT_CRYPTO_Msk = 0x20000000
	// Bit PRESENT_CRYPTO.
	DCP_CTRL_TOG_PRESENT_CRYPTO = 0x20000000
	// Absent
	DCP_CTRL_TOG_PRESENT_CRYPTO_Absent = 0x0
	// Present
	DCP_CTRL_TOG_PRESENT_CRYPTO_Present = 0x1
	// Position of CLKGATE field.
	DCP_CTRL_TOG_CLKGATE_Pos = 0x1e
	// Bit mask of CLKGATE field.
	DCP_CTRL_TOG_CLKGATE_Msk = 0x40000000
	// Bit CLKGATE.
	DCP_CTRL_TOG_CLKGATE = 0x40000000
	// Position of SFTRST field.
	DCP_CTRL_TOG_SFTRST_Pos = 0x1f
	// Bit mask of SFTRST field.
	DCP_CTRL_TOG_SFTRST_Msk = 0x80000000
	// Bit SFTRST.
	DCP_CTRL_TOG_SFTRST = 0x80000000

	// STAT: DCP status register
	// Position of IRQ field.
	DCP_STAT_IRQ_Pos = 0x0
	// Bit mask of IRQ field.
	DCP_STAT_IRQ_Msk = 0xf
	// Position of READY_CHANNELS field.
	DCP_STAT_READY_CHANNELS_Pos = 0x10
	// Bit mask of READY_CHANNELS field.
	DCP_STAT_READY_CHANNELS_Msk = 0xff0000
	// CH0
	DCP_STAT_READY_CHANNELS_CH0 = 0x1
	// CH1
	DCP_STAT_READY_CHANNELS_CH1 = 0x2
	// CH2
	DCP_STAT_READY_CHANNELS_CH2 = 0x4
	// CH3
	DCP_STAT_READY_CHANNELS_CH3 = 0x8
	// Position of CUR_CHANNEL field.
	DCP_STAT_CUR_CHANNEL_Pos = 0x18
	// Bit mask of CUR_CHANNEL field.
	DCP_STAT_CUR_CHANNEL_Msk = 0xf000000
	// None
	DCP_STAT_CUR_CHANNEL_None = 0x0
	// CH0
	DCP_STAT_CUR_CHANNEL_CH0 = 0x1
	// CH1
	DCP_STAT_CUR_CHANNEL_CH1 = 0x2
	// CH2
	DCP_STAT_CUR_CHANNEL_CH2 = 0x3
	// CH3
	DCP_STAT_CUR_CHANNEL_CH3 = 0x4
	// Position of OTP_KEY_READY field.
	DCP_STAT_OTP_KEY_READY_Pos = 0x1c
	// Bit mask of OTP_KEY_READY field.
	DCP_STAT_OTP_KEY_READY_Msk = 0x10000000
	// Bit OTP_KEY_READY.
	DCP_STAT_OTP_KEY_READY = 0x10000000

	// STAT_SET: DCP status register
	// Position of IRQ field.
	DCP_STAT_SET_IRQ_Pos = 0x0
	// Bit mask of IRQ field.
	DCP_STAT_SET_IRQ_Msk = 0xf
	// Position of READY_CHANNELS field.
	DCP_STAT_SET_READY_CHANNELS_Pos = 0x10
	// Bit mask of READY_CHANNELS field.
	DCP_STAT_SET_READY_CHANNELS_Msk = 0xff0000
	// CH0
	DCP_STAT_SET_READY_CHANNELS_CH0 = 0x1
	// CH1
	DCP_STAT_SET_READY_CHANNELS_CH1 = 0x2
	// CH2
	DCP_STAT_SET_READY_CHANNELS_CH2 = 0x4
	// CH3
	DCP_STAT_SET_READY_CHANNELS_CH3 = 0x8
	// Position of CUR_CHANNEL field.
	DCP_STAT_SET_CUR_CHANNEL_Pos = 0x18
	// Bit mask of CUR_CHANNEL field.
	DCP_STAT_SET_CUR_CHANNEL_Msk = 0xf000000
	// None
	DCP_STAT_SET_CUR_CHANNEL_None = 0x0
	// CH0
	DCP_STAT_SET_CUR_CHANNEL_CH0 = 0x1
	// CH1
	DCP_STAT_SET_CUR_CHANNEL_CH1 = 0x2
	// CH2
	DCP_STAT_SET_CUR_CHANNEL_CH2 = 0x3
	// CH3
	DCP_STAT_SET_CUR_CHANNEL_CH3 = 0x4
	// Position of OTP_KEY_READY field.
	DCP_STAT_SET_OTP_KEY_READY_Pos = 0x1c
	// Bit mask of OTP_KEY_READY field.
	DCP_STAT_SET_OTP_KEY_READY_Msk = 0x10000000
	// Bit OTP_KEY_READY.
	DCP_STAT_SET_OTP_KEY_READY = 0x10000000

	// STAT_CLR: DCP status register
	// Position of IRQ field.
	DCP_STAT_CLR_IRQ_Pos = 0x0
	// Bit mask of IRQ field.
	DCP_STAT_CLR_IRQ_Msk = 0xf
	// Position of READY_CHANNELS field.
	DCP_STAT_CLR_READY_CHANNELS_Pos = 0x10
	// Bit mask of READY_CHANNELS field.
	DCP_STAT_CLR_READY_CHANNELS_Msk = 0xff0000
	// CH0
	DCP_STAT_CLR_READY_CHANNELS_CH0 = 0x1
	// CH1
	DCP_STAT_CLR_READY_CHANNELS_CH1 = 0x2
	// CH2
	DCP_STAT_CLR_READY_CHANNELS_CH2 = 0x4
	// CH3
	DCP_STAT_CLR_READY_CHANNELS_CH3 = 0x8
	// Position of CUR_CHANNEL field.
	DCP_STAT_CLR_CUR_CHANNEL_Pos = 0x18
	// Bit mask of CUR_CHANNEL field.
	DCP_STAT_CLR_CUR_CHANNEL_Msk = 0xf000000
	// None
	DCP_STAT_CLR_CUR_CHANNEL_None = 0x0
	// CH0
	DCP_STAT_CLR_CUR_CHANNEL_CH0 = 0x1
	// CH1
	DCP_STAT_CLR_CUR_CHANNEL_CH1 = 0x2
	// CH2
	DCP_STAT_CLR_CUR_CHANNEL_CH2 = 0x3
	// CH3
	DCP_STAT_CLR_CUR_CHANNEL_CH3 = 0x4
	// Position of OTP_KEY_READY field.
	DCP_STAT_CLR_OTP_KEY_READY_Pos = 0x1c
	// Bit mask of OTP_KEY_READY field.
	DCP_STAT_CLR_OTP_KEY_READY_Msk = 0x10000000
	// Bit OTP_KEY_READY.
	DCP_STAT_CLR_OTP_KEY_READY = 0x10000000

	// STAT_TOG: DCP status register
	// Position of IRQ field.
	DCP_STAT_TOG_IRQ_Pos = 0x0
	// Bit mask of IRQ field.
	DCP_STAT_TOG_IRQ_Msk = 0xf
	// Position of READY_CHANNELS field.
	DCP_STAT_TOG_READY_CHANNELS_Pos = 0x10
	// Bit mask of READY_CHANNELS field.
	DCP_STAT_TOG_READY_CHANNELS_Msk = 0xff0000
	// CH0
	DCP_STAT_TOG_READY_CHANNELS_CH0 = 0x1
	// CH1
	DCP_STAT_TOG_READY_CHANNELS_CH1 = 0x2
	// CH2
	DCP_STAT_TOG_READY_CHANNELS_CH2 = 0x4
	// CH3
	DCP_STAT_TOG_READY_CHANNELS_CH3 = 0x8
	// Position of CUR_CHANNEL field.
	DCP_STAT_TOG_CUR_CHANNEL_Pos = 0x18
	// Bit mask of CUR_CHANNEL field.
	DCP_STAT_TOG_CUR_CHANNEL_Msk = 0xf000000
	// None
	DCP_STAT_TOG_CUR_CHANNEL_None = 0x0
	// CH0
	DCP_STAT_TOG_CUR_CHANNEL_CH0 = 0x1
	// CH1
	DCP_STAT_TOG_CUR_CHANNEL_CH1 = 0x2
	// CH2
	DCP_STAT_TOG_CUR_CHANNEL_CH2 = 0x3
	// CH3
	DCP_STAT_TOG_CUR_CHANNEL_CH3 = 0x4
	// Position of OTP_KEY_READY field.
	DCP_STAT_TOG_OTP_KEY_READY_Pos = 0x1c
	// Bit mask of OTP_KEY_READY field.
	DCP_STAT_TOG_OTP_KEY_READY_Msk = 0x10000000
	// Bit OTP_KEY_READY.
	DCP_STAT_TOG_OTP_KEY_READY = 0x10000000

	// CHANNELCTRL: DCP channel control register
	// Position of ENABLE_CHANNEL field.
	DCP_CHANNELCTRL_ENABLE_CHANNEL_Pos = 0x0
	// Bit mask of ENABLE_CHANNEL field.
	DCP_CHANNELCTRL_ENABLE_CHANNEL_Msk = 0xff
	// CH0
	DCP_CHANNELCTRL_ENABLE_CHANNEL_CH0 = 0x1
	// CH1
	DCP_CHANNELCTRL_ENABLE_CHANNEL_CH1 = 0x2
	// CH2
	DCP_CHANNELCTRL_ENABLE_CHANNEL_CH2 = 0x4
	// CH3
	DCP_CHANNELCTRL_ENABLE_CHANNEL_CH3 = 0x8
	// Position of HIGH_PRIORITY_CHANNEL field.
	DCP_CHANNELCTRL_HIGH_PRIORITY_CHANNEL_Pos = 0x8
	// Bit mask of HIGH_PRIORITY_CHANNEL field.
	DCP_CHANNELCTRL_HIGH_PRIORITY_CHANNEL_Msk = 0xff00
	// CH0
	DCP_CHANNELCTRL_HIGH_PRIORITY_CHANNEL_CH0 = 0x1
	// CH1
	DCP_CHANNELCTRL_HIGH_PRIORITY_CHANNEL_CH1 = 0x2
	// CH2
	DCP_CHANNELCTRL_HIGH_PRIORITY_CHANNEL_CH2 = 0x4
	// CH3
	DCP_CHANNELCTRL_HIGH_PRIORITY_CHANNEL_CH3 = 0x8
	// Position of CH0_IRQ_MERGED field.
	DCP_CHANNELCTRL_CH0_IRQ_MERGED_Pos = 0x10
	// Bit mask of CH0_IRQ_MERGED field.
	DCP_CHANNELCTRL_CH0_IRQ_MERGED_Msk = 0x10000
	// Bit CH0_IRQ_MERGED.
	DCP_CHANNELCTRL_CH0_IRQ_MERGED = 0x10000

	// CHANNELCTRL_SET: DCP channel control register
	// Position of ENABLE_CHANNEL field.
	DCP_CHANNELCTRL_SET_ENABLE_CHANNEL_Pos = 0x0
	// Bit mask of ENABLE_CHANNEL field.
	DCP_CHANNELCTRL_SET_ENABLE_CHANNEL_Msk = 0xff
	// CH0
	DCP_CHANNELCTRL_SET_ENABLE_CHANNEL_CH0 = 0x1
	// CH1
	DCP_CHANNELCTRL_SET_ENABLE_CHANNEL_CH1 = 0x2
	// CH2
	DCP_CHANNELCTRL_SET_ENABLE_CHANNEL_CH2 = 0x4
	// CH3
	DCP_CHANNELCTRL_SET_ENABLE_CHANNEL_CH3 = 0x8
	// Position of HIGH_PRIORITY_CHANNEL field.
	DCP_CHANNELCTRL_SET_HIGH_PRIORITY_CHANNEL_Pos = 0x8
	// Bit mask of HIGH_PRIORITY_CHANNEL field.
	DCP_CHANNELCTRL_SET_HIGH_PRIORITY_CHANNEL_Msk = 0xff00
	// CH0
	DCP_CHANNELCTRL_SET_HIGH_PRIORITY_CHANNEL_CH0 = 0x1
	// CH1
	DCP_CHANNELCTRL_SET_HIGH_PRIORITY_CHANNEL_CH1 = 0x2
	// CH2
	DCP_CHANNELCTRL_SET_HIGH_PRIORITY_CHANNEL_CH2 = 0x4
	// CH3
	DCP_CHANNELCTRL_SET_HIGH_PRIORITY_CHANNEL_CH3 = 0x8
	// Position of CH0_IRQ_MERGED field.
	DCP_CHANNELCTRL_SET_CH0_IRQ_MERGED_Pos = 0x10
	// Bit mask of CH0_IRQ_MERGED field.
	DCP_CHANNELCTRL_SET_CH0_IRQ_MERGED_Msk = 0x10000
	// Bit CH0_IRQ_MERGED.
	DCP_CHANNELCTRL_SET_CH0_IRQ_MERGED = 0x10000

	// CHANNELCTRL_CLR: DCP channel control register
	// Position of ENABLE_CHANNEL field.
	DCP_CHANNELCTRL_CLR_ENABLE_CHANNEL_Pos = 0x0
	// Bit mask of ENABLE_CHANNEL field.
	DCP_CHANNELCTRL_CLR_ENABLE_CHANNEL_Msk = 0xff
	// CH0
	DCP_CHANNELCTRL_CLR_ENABLE_CHANNEL_CH0 = 0x1
	// CH1
	DCP_CHANNELCTRL_CLR_ENABLE_CHANNEL_CH1 = 0x2
	// CH2
	DCP_CHANNELCTRL_CLR_ENABLE_CHANNEL_CH2 = 0x4
	// CH3
	DCP_CHANNELCTRL_CLR_ENABLE_CHANNEL_CH3 = 0x8
	// Position of HIGH_PRIORITY_CHANNEL field.
	DCP_CHANNELCTRL_CLR_HIGH_PRIORITY_CHANNEL_Pos = 0x8
	// Bit mask of HIGH_PRIORITY_CHANNEL field.
	DCP_CHANNELCTRL_CLR_HIGH_PRIORITY_CHANNEL_Msk = 0xff00
	// CH0
	DCP_CHANNELCTRL_CLR_HIGH_PRIORITY_CHANNEL_CH0 = 0x1
	// CH1
	DCP_CHANNELCTRL_CLR_HIGH_PRIORITY_CHANNEL_CH1 = 0x2
	// CH2
	DCP_CHANNELCTRL_CLR_HIGH_PRIORITY_CHANNEL_CH2 = 0x4
	// CH3
	DCP_CHANNELCTRL_CLR_HIGH_PRIORITY_CHANNEL_CH3 = 0x8
	// Position of CH0_IRQ_MERGED field.
	DCP_CHANNELCTRL_CLR_CH0_IRQ_MERGED_Pos = 0x10
	// Bit mask of CH0_IRQ_MERGED field.
	DCP_CHANNELCTRL_CLR_CH0_IRQ_MERGED_Msk = 0x10000
	// Bit CH0_IRQ_MERGED.
	DCP_CHANNELCTRL_CLR_CH0_IRQ_MERGED = 0x10000

	// CHANNELCTRL_TOG: DCP channel control register
	// Position of ENABLE_CHANNEL field.
	DCP_CHANNELCTRL_TOG_ENABLE_CHANNEL_Pos = 0x0
	// Bit mask of ENABLE_CHANNEL field.
	DCP_CHANNELCTRL_TOG_ENABLE_CHANNEL_Msk = 0xff
	// CH0
	DCP_CHANNELCTRL_TOG_ENABLE_CHANNEL_CH0 = 0x1
	// CH1
	DCP_CHANNELCTRL_TOG_ENABLE_CHANNEL_CH1 = 0x2
	// CH2
	DCP_CHANNELCTRL_TOG_ENABLE_CHANNEL_CH2 = 0x4
	// CH3
	DCP_CHANNELCTRL_TOG_ENABLE_CHANNEL_CH3 = 0x8
	// Position of HIGH_PRIORITY_CHANNEL field.
	DCP_CHANNELCTRL_TOG_HIGH_PRIORITY_CHANNEL_Pos = 0x8
	// Bit mask of HIGH_PRIORITY_CHANNEL field.
	DCP_CHANNELCTRL_TOG_HIGH_PRIORITY_CHANNEL_Msk = 0xff00
	// CH0
	DCP_CHANNELCTRL_TOG_HIGH_PRIORITY_CHANNEL_CH0 = 0x1
	// CH1
	DCP_CHANNELCTRL_TOG_HIGH_PRIORITY_CHANNEL_CH1 = 0x2
	// CH2
	DCP_CHANNELCTRL_TOG_HIGH_PRIORITY_CHANNEL_CH2 = 0x4
	// CH3
	DCP_CHANNELCTRL_TOG_HIGH_PRIORITY_CHANNEL_CH3 = 0x8
	// Position of CH0_IRQ_MERGED field.
	DCP_CHANNELCTRL_TOG_CH0_IRQ_MERGED_Pos = 0x10
	// Bit mask of CH0_IRQ_MERGED field.
	DCP_CHANNELCTRL_TOG_CH0_IRQ_MERGED_Msk = 0x10000
	// Bit CH0_IRQ_MERGED.
	DCP_CHANNELCTRL_TOG_CH0_IRQ_MERGED = 0x10000

	// CAPABILITY0: DCP capability 0 register
	// Position of NUM_KEYS field.
	DCP_CAPABILITY0_NUM_KEYS_Pos = 0x0
	// Bit mask of NUM_KEYS field.
	DCP_CAPABILITY0_NUM_KEYS_Msk = 0xff
	// Position of NUM_CHANNELS field.
	DCP_CAPABILITY0_NUM_CHANNELS_Pos = 0x8
	// Bit mask of NUM_CHANNELS field.
	DCP_CAPABILITY0_NUM_CHANNELS_Msk = 0xf00
	// Position of DISABLE_UNIQUE_KEY field.
	DCP_CAPABILITY0_DISABLE_UNIQUE_KEY_Pos = 0x1d
	// Bit mask of DISABLE_UNIQUE_KEY field.
	DCP_CAPABILITY0_DISABLE_UNIQUE_KEY_Msk = 0x20000000
	// Bit DISABLE_UNIQUE_KEY.
	DCP_CAPABILITY0_DISABLE_UNIQUE_KEY = 0x20000000
	// Position of DISABLE_DECRYPT field.
	DCP_CAPABILITY0_DISABLE_DECRYPT_Pos = 0x1f
	// Bit mask of DISABLE_DECRYPT field.
	DCP_CAPABILITY0_DISABLE_DECRYPT_Msk = 0x80000000
	// Bit DISABLE_DECRYPT.
	DCP_CAPABILITY0_DISABLE_DECRYPT = 0x80000000

	// CAPABILITY1: DCP capability 1 register
	// Position of CIPHER_ALGORITHMS field.
	DCP_CAPABILITY1_CIPHER_ALGORITHMS_Pos = 0x0
	// Bit mask of CIPHER_ALGORITHMS field.
	DCP_CAPABILITY1_CIPHER_ALGORITHMS_Msk = 0xffff
	// AES128
	DCP_CAPABILITY1_CIPHER_ALGORITHMS_AES128 = 0x1
	// Position of HASH_ALGORITHMS field.
	DCP_CAPABILITY1_HASH_ALGORITHMS_Pos = 0x10
	// Bit mask of HASH_ALGORITHMS field.
	DCP_CAPABILITY1_HASH_ALGORITHMS_Msk = 0xffff0000
	// SHA1
	DCP_CAPABILITY1_HASH_ALGORITHMS_SHA1 = 0x1
	// CRC32
	DCP_CAPABILITY1_HASH_ALGORITHMS_CRC32 = 0x2
	// SHA256
	DCP_CAPABILITY1_HASH_ALGORITHMS_SHA256 = 0x4

	// CONTEXT: DCP context buffer pointer
	// Position of ADDR field.
	DCP_CONTEXT_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	DCP_CONTEXT_ADDR_Msk = 0xffffffff

	// KEY: DCP key index
	// Position of SUBWORD field.
	DCP_KEY_SUBWORD_Pos = 0x0
	// Bit mask of SUBWORD field.
	DCP_KEY_SUBWORD_Msk = 0x3
	// Position of INDEX field.
	DCP_KEY_INDEX_Pos = 0x4
	// Bit mask of INDEX field.
	DCP_KEY_INDEX_Msk = 0x30

	// KEYDATA: DCP key data
	// Position of DATA field.
	DCP_KEYDATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	DCP_KEYDATA_DATA_Msk = 0xffffffff

	// PACKET0: DCP work packet 0 status register
	// Position of ADDR field.
	DCP_PACKET0_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	DCP_PACKET0_ADDR_Msk = 0xffffffff

	// PACKET1: DCP work packet 1 status register
	// Position of INTERRUPT field.
	DCP_PACKET1_INTERRUPT_Pos = 0x0
	// Bit mask of INTERRUPT field.
	DCP_PACKET1_INTERRUPT_Msk = 0x1
	// Bit INTERRUPT.
	DCP_PACKET1_INTERRUPT = 0x1
	// Position of DECR_SEMAPHORE field.
	DCP_PACKET1_DECR_SEMAPHORE_Pos = 0x1
	// Bit mask of DECR_SEMAPHORE field.
	DCP_PACKET1_DECR_SEMAPHORE_Msk = 0x2
	// Bit DECR_SEMAPHORE.
	DCP_PACKET1_DECR_SEMAPHORE = 0x2
	// Position of CHAIN field.
	DCP_PACKET1_CHAIN_Pos = 0x2
	// Bit mask of CHAIN field.
	DCP_PACKET1_CHAIN_Msk = 0x4
	// Bit CHAIN.
	DCP_PACKET1_CHAIN = 0x4
	// Position of CHAIN_CONTIGUOUS field.
	DCP_PACKET1_CHAIN_CONTIGUOUS_Pos = 0x3
	// Bit mask of CHAIN_CONTIGUOUS field.
	DCP_PACKET1_CHAIN_CONTIGUOUS_Msk = 0x8
	// Bit CHAIN_CONTIGUOUS.
	DCP_PACKET1_CHAIN_CONTIGUOUS = 0x8
	// Position of ENABLE_MEMCOPY field.
	DCP_PACKET1_ENABLE_MEMCOPY_Pos = 0x4
	// Bit mask of ENABLE_MEMCOPY field.
	DCP_PACKET1_ENABLE_MEMCOPY_Msk = 0x10
	// Bit ENABLE_MEMCOPY.
	DCP_PACKET1_ENABLE_MEMCOPY = 0x10
	// Position of ENABLE_CIPHER field.
	DCP_PACKET1_ENABLE_CIPHER_Pos = 0x5
	// Bit mask of ENABLE_CIPHER field.
	DCP_PACKET1_ENABLE_CIPHER_Msk = 0x20
	// Bit ENABLE_CIPHER.
	DCP_PACKET1_ENABLE_CIPHER = 0x20
	// Position of ENABLE_HASH field.
	DCP_PACKET1_ENABLE_HASH_Pos = 0x6
	// Bit mask of ENABLE_HASH field.
	DCP_PACKET1_ENABLE_HASH_Msk = 0x40
	// Bit ENABLE_HASH.
	DCP_PACKET1_ENABLE_HASH = 0x40
	// Position of ENABLE_BLIT field.
	DCP_PACKET1_ENABLE_BLIT_Pos = 0x7
	// Bit mask of ENABLE_BLIT field.
	DCP_PACKET1_ENABLE_BLIT_Msk = 0x80
	// Bit ENABLE_BLIT.
	DCP_PACKET1_ENABLE_BLIT = 0x80
	// Position of CIPHER_ENCRYPT field.
	DCP_PACKET1_CIPHER_ENCRYPT_Pos = 0x8
	// Bit mask of CIPHER_ENCRYPT field.
	DCP_PACKET1_CIPHER_ENCRYPT_Msk = 0x100
	// Bit CIPHER_ENCRYPT.
	DCP_PACKET1_CIPHER_ENCRYPT = 0x100
	// DECRYPT
	DCP_PACKET1_CIPHER_ENCRYPT_DECRYPT = 0x0
	// ENCRYPT
	DCP_PACKET1_CIPHER_ENCRYPT_ENCRYPT = 0x1
	// Position of CIPHER_INIT field.
	DCP_PACKET1_CIPHER_INIT_Pos = 0x9
	// Bit mask of CIPHER_INIT field.
	DCP_PACKET1_CIPHER_INIT_Msk = 0x200
	// Bit CIPHER_INIT.
	DCP_PACKET1_CIPHER_INIT = 0x200
	// Position of OTP_KEY field.
	DCP_PACKET1_OTP_KEY_Pos = 0xa
	// Bit mask of OTP_KEY field.
	DCP_PACKET1_OTP_KEY_Msk = 0x400
	// Bit OTP_KEY.
	DCP_PACKET1_OTP_KEY = 0x400
	// Position of PAYLOAD_KEY field.
	DCP_PACKET1_PAYLOAD_KEY_Pos = 0xb
	// Bit mask of PAYLOAD_KEY field.
	DCP_PACKET1_PAYLOAD_KEY_Msk = 0x800
	// Bit PAYLOAD_KEY.
	DCP_PACKET1_PAYLOAD_KEY = 0x800
	// Position of HASH_INIT field.
	DCP_PACKET1_HASH_INIT_Pos = 0xc
	// Bit mask of HASH_INIT field.
	DCP_PACKET1_HASH_INIT_Msk = 0x1000
	// Bit HASH_INIT.
	DCP_PACKET1_HASH_INIT = 0x1000
	// Position of HASH_TERM field.
	DCP_PACKET1_HASH_TERM_Pos = 0xd
	// Bit mask of HASH_TERM field.
	DCP_PACKET1_HASH_TERM_Msk = 0x2000
	// Bit HASH_TERM.
	DCP_PACKET1_HASH_TERM = 0x2000
	// Position of CHECK_HASH field.
	DCP_PACKET1_CHECK_HASH_Pos = 0xe
	// Bit mask of CHECK_HASH field.
	DCP_PACKET1_CHECK_HASH_Msk = 0x4000
	// Bit CHECK_HASH.
	DCP_PACKET1_CHECK_HASH = 0x4000
	// Position of HASH_OUTPUT field.
	DCP_PACKET1_HASH_OUTPUT_Pos = 0xf
	// Bit mask of HASH_OUTPUT field.
	DCP_PACKET1_HASH_OUTPUT_Msk = 0x8000
	// Bit HASH_OUTPUT.
	DCP_PACKET1_HASH_OUTPUT = 0x8000
	// INPUT
	DCP_PACKET1_HASH_OUTPUT_INPUT = 0x0
	// OUTPUT
	DCP_PACKET1_HASH_OUTPUT_OUTPUT = 0x1
	// Position of CONSTANT_FILL field.
	DCP_PACKET1_CONSTANT_FILL_Pos = 0x10
	// Bit mask of CONSTANT_FILL field.
	DCP_PACKET1_CONSTANT_FILL_Msk = 0x10000
	// Bit CONSTANT_FILL.
	DCP_PACKET1_CONSTANT_FILL = 0x10000
	// Position of TEST_SEMA_IRQ field.
	DCP_PACKET1_TEST_SEMA_IRQ_Pos = 0x11
	// Bit mask of TEST_SEMA_IRQ field.
	DCP_PACKET1_TEST_SEMA_IRQ_Msk = 0x20000
	// Bit TEST_SEMA_IRQ.
	DCP_PACKET1_TEST_SEMA_IRQ = 0x20000
	// Position of KEY_BYTESWAP field.
	DCP_PACKET1_KEY_BYTESWAP_Pos = 0x12
	// Bit mask of KEY_BYTESWAP field.
	DCP_PACKET1_KEY_BYTESWAP_Msk = 0x40000
	// Bit KEY_BYTESWAP.
	DCP_PACKET1_KEY_BYTESWAP = 0x40000
	// Position of KEY_WORDSWAP field.
	DCP_PACKET1_KEY_WORDSWAP_Pos = 0x13
	// Bit mask of KEY_WORDSWAP field.
	DCP_PACKET1_KEY_WORDSWAP_Msk = 0x80000
	// Bit KEY_WORDSWAP.
	DCP_PACKET1_KEY_WORDSWAP = 0x80000
	// Position of INPUT_BYTESWAP field.
	DCP_PACKET1_INPUT_BYTESWAP_Pos = 0x14
	// Bit mask of INPUT_BYTESWAP field.
	DCP_PACKET1_INPUT_BYTESWAP_Msk = 0x100000
	// Bit INPUT_BYTESWAP.
	DCP_PACKET1_INPUT_BYTESWAP = 0x100000
	// Position of INPUT_WORDSWAP field.
	DCP_PACKET1_INPUT_WORDSWAP_Pos = 0x15
	// Bit mask of INPUT_WORDSWAP field.
	DCP_PACKET1_INPUT_WORDSWAP_Msk = 0x200000
	// Bit INPUT_WORDSWAP.
	DCP_PACKET1_INPUT_WORDSWAP = 0x200000
	// Position of OUTPUT_BYTESWAP field.
	DCP_PACKET1_OUTPUT_BYTESWAP_Pos = 0x16
	// Bit mask of OUTPUT_BYTESWAP field.
	DCP_PACKET1_OUTPUT_BYTESWAP_Msk = 0x400000
	// Bit OUTPUT_BYTESWAP.
	DCP_PACKET1_OUTPUT_BYTESWAP = 0x400000
	// Position of OUTPUT_WORDSWAP field.
	DCP_PACKET1_OUTPUT_WORDSWAP_Pos = 0x17
	// Bit mask of OUTPUT_WORDSWAP field.
	DCP_PACKET1_OUTPUT_WORDSWAP_Msk = 0x800000
	// Bit OUTPUT_WORDSWAP.
	DCP_PACKET1_OUTPUT_WORDSWAP = 0x800000
	// Position of TAG field.
	DCP_PACKET1_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_PACKET1_TAG_Msk = 0xff000000

	// PACKET2: DCP work packet 2 status register
	// Position of CIPHER_SELECT field.
	DCP_PACKET2_CIPHER_SELECT_Pos = 0x0
	// Bit mask of CIPHER_SELECT field.
	DCP_PACKET2_CIPHER_SELECT_Msk = 0xf
	// AES128
	DCP_PACKET2_CIPHER_SELECT_AES128 = 0x0
	// Position of CIPHER_MODE field.
	DCP_PACKET2_CIPHER_MODE_Pos = 0x4
	// Bit mask of CIPHER_MODE field.
	DCP_PACKET2_CIPHER_MODE_Msk = 0xf0
	// ECB
	DCP_PACKET2_CIPHER_MODE_ECB = 0x0
	// CBC
	DCP_PACKET2_CIPHER_MODE_CBC = 0x1
	// Position of KEY_SELECT field.
	DCP_PACKET2_KEY_SELECT_Pos = 0x8
	// Bit mask of KEY_SELECT field.
	DCP_PACKET2_KEY_SELECT_Msk = 0xff00
	// KEY0
	DCP_PACKET2_KEY_SELECT_KEY0 = 0x0
	// KEY1
	DCP_PACKET2_KEY_SELECT_KEY1 = 0x1
	// KEY2
	DCP_PACKET2_KEY_SELECT_KEY2 = 0x2
	// KEY3
	DCP_PACKET2_KEY_SELECT_KEY3 = 0x3
	// UNIQUE_KEY
	DCP_PACKET2_KEY_SELECT_UNIQUE_KEY = 0xfe
	// OTP_KEY
	DCP_PACKET2_KEY_SELECT_OTP_KEY = 0xff
	// Position of HASH_SELECT field.
	DCP_PACKET2_HASH_SELECT_Pos = 0x10
	// Bit mask of HASH_SELECT field.
	DCP_PACKET2_HASH_SELECT_Msk = 0xf0000
	// SHA1
	DCP_PACKET2_HASH_SELECT_SHA1 = 0x0
	// CRC32
	DCP_PACKET2_HASH_SELECT_CRC32 = 0x1
	// SHA256
	DCP_PACKET2_HASH_SELECT_SHA256 = 0x2
	// Position of CIPHER_CFG field.
	DCP_PACKET2_CIPHER_CFG_Pos = 0x18
	// Bit mask of CIPHER_CFG field.
	DCP_PACKET2_CIPHER_CFG_Msk = 0xff000000

	// PACKET3: DCP work packet 3 status register
	// Position of ADDR field.
	DCP_PACKET3_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	DCP_PACKET3_ADDR_Msk = 0xffffffff

	// PACKET4: DCP work packet 4 status register
	// Position of ADDR field.
	DCP_PACKET4_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	DCP_PACKET4_ADDR_Msk = 0xffffffff

	// PACKET5: DCP work packet 5 status register
	// Position of COUNT field.
	DCP_PACKET5_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	DCP_PACKET5_COUNT_Msk = 0xffffffff

	// PACKET6: DCP work packet 6 status register
	// Position of ADDR field.
	DCP_PACKET6_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	DCP_PACKET6_ADDR_Msk = 0xffffffff

	// CH0CMDPTR: DCP channel 0 command pointer address register
	// Position of ADDR field.
	DCP_CH0CMDPTR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	DCP_CH0CMDPTR_ADDR_Msk = 0xffffffff

	// CH0SEMA: DCP channel 0 semaphore register
	// Position of INCREMENT field.
	DCP_CH0SEMA_INCREMENT_Pos = 0x0
	// Bit mask of INCREMENT field.
	DCP_CH0SEMA_INCREMENT_Msk = 0xff
	// Position of VALUE field.
	DCP_CH0SEMA_VALUE_Pos = 0x10
	// Bit mask of VALUE field.
	DCP_CH0SEMA_VALUE_Msk = 0xff0000

	// CH0STAT: DCP channel 0 status register
	// Position of HASH_MISMATCH field.
	DCP_CH0STAT_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH0STAT_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH0STAT_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH0STAT_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH0STAT_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH0STAT_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH0STAT_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH0STAT_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH0STAT_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH0STAT_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH0STAT_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH0STAT_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH0STAT_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH0STAT_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH0STAT_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH0STAT_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH0STAT_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH0STAT_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH0STAT_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH0STAT_ERROR_CODE_Msk = 0xff0000
	// Error signalled because the next pointer is 0x00000000
	DCP_CH0STAT_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error signalled because the semaphore is non-zero and neither chain bit is set
	DCP_CH0STAT_ERROR_CODE_NO_CHAIN = 0x2
	// Error signalled because an error is reported reading/writing the context buffer
	DCP_CH0STAT_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error signalled because an error is reported reading/writing the payload
	DCP_CH0STAT_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error signalled because the control packet specifies an invalid mode select (for instance, blit + hash)
	DCP_CH0STAT_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH0STAT_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH0STAT_TAG_Msk = 0xff000000

	// CH0STAT_SET: DCP channel 0 status register
	// Position of HASH_MISMATCH field.
	DCP_CH0STAT_SET_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH0STAT_SET_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH0STAT_SET_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH0STAT_SET_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH0STAT_SET_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH0STAT_SET_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH0STAT_SET_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH0STAT_SET_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH0STAT_SET_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH0STAT_SET_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH0STAT_SET_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH0STAT_SET_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH0STAT_SET_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH0STAT_SET_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH0STAT_SET_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH0STAT_SET_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH0STAT_SET_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH0STAT_SET_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH0STAT_SET_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH0STAT_SET_ERROR_CODE_Msk = 0xff0000
	// Error signalled because the next pointer is 0x00000000
	DCP_CH0STAT_SET_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error signalled because the semaphore is non-zero and neither chain bit is set
	DCP_CH0STAT_SET_ERROR_CODE_NO_CHAIN = 0x2
	// Error signalled because an error is reported reading/writing the context buffer
	DCP_CH0STAT_SET_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error signalled because an error is reported reading/writing the payload
	DCP_CH0STAT_SET_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error signalled because the control packet specifies an invalid mode select (for instance, blit + hash)
	DCP_CH0STAT_SET_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH0STAT_SET_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH0STAT_SET_TAG_Msk = 0xff000000

	// CH0STAT_CLR: DCP channel 0 status register
	// Position of HASH_MISMATCH field.
	DCP_CH0STAT_CLR_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH0STAT_CLR_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH0STAT_CLR_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH0STAT_CLR_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH0STAT_CLR_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH0STAT_CLR_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH0STAT_CLR_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH0STAT_CLR_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH0STAT_CLR_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH0STAT_CLR_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH0STAT_CLR_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH0STAT_CLR_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH0STAT_CLR_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH0STAT_CLR_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH0STAT_CLR_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH0STAT_CLR_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH0STAT_CLR_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH0STAT_CLR_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH0STAT_CLR_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH0STAT_CLR_ERROR_CODE_Msk = 0xff0000
	// Error signalled because the next pointer is 0x00000000
	DCP_CH0STAT_CLR_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error signalled because the semaphore is non-zero and neither chain bit is set
	DCP_CH0STAT_CLR_ERROR_CODE_NO_CHAIN = 0x2
	// Error signalled because an error is reported reading/writing the context buffer
	DCP_CH0STAT_CLR_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error signalled because an error is reported reading/writing the payload
	DCP_CH0STAT_CLR_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error signalled because the control packet specifies an invalid mode select (for instance, blit + hash)
	DCP_CH0STAT_CLR_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH0STAT_CLR_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH0STAT_CLR_TAG_Msk = 0xff000000

	// CH0STAT_TOG: DCP channel 0 status register
	// Position of HASH_MISMATCH field.
	DCP_CH0STAT_TOG_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH0STAT_TOG_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH0STAT_TOG_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH0STAT_TOG_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH0STAT_TOG_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH0STAT_TOG_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH0STAT_TOG_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH0STAT_TOG_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH0STAT_TOG_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH0STAT_TOG_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH0STAT_TOG_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH0STAT_TOG_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH0STAT_TOG_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH0STAT_TOG_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH0STAT_TOG_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH0STAT_TOG_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH0STAT_TOG_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH0STAT_TOG_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH0STAT_TOG_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH0STAT_TOG_ERROR_CODE_Msk = 0xff0000
	// Error signalled because the next pointer is 0x00000000
	DCP_CH0STAT_TOG_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error signalled because the semaphore is non-zero and neither chain bit is set
	DCP_CH0STAT_TOG_ERROR_CODE_NO_CHAIN = 0x2
	// Error signalled because an error is reported reading/writing the context buffer
	DCP_CH0STAT_TOG_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error signalled because an error is reported reading/writing the payload
	DCP_CH0STAT_TOG_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error signalled because the control packet specifies an invalid mode select (for instance, blit + hash)
	DCP_CH0STAT_TOG_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH0STAT_TOG_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH0STAT_TOG_TAG_Msk = 0xff000000

	// CH0OPTS: DCP channel 0 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH0OPTS_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH0OPTS_RECOVERY_TIMER_Msk = 0xffff

	// CH0OPTS_SET: DCP channel 0 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH0OPTS_SET_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH0OPTS_SET_RECOVERY_TIMER_Msk = 0xffff

	// CH0OPTS_CLR: DCP channel 0 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH0OPTS_CLR_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH0OPTS_CLR_RECOVERY_TIMER_Msk = 0xffff

	// CH0OPTS_TOG: DCP channel 0 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH0OPTS_TOG_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH0OPTS_TOG_RECOVERY_TIMER_Msk = 0xffff

	// CH1CMDPTR: DCP channel 1 command pointer address register
	// Position of ADDR field.
	DCP_CH1CMDPTR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	DCP_CH1CMDPTR_ADDR_Msk = 0xffffffff

	// CH1SEMA: DCP channel 1 semaphore register
	// Position of INCREMENT field.
	DCP_CH1SEMA_INCREMENT_Pos = 0x0
	// Bit mask of INCREMENT field.
	DCP_CH1SEMA_INCREMENT_Msk = 0xff
	// Position of VALUE field.
	DCP_CH1SEMA_VALUE_Pos = 0x10
	// Bit mask of VALUE field.
	DCP_CH1SEMA_VALUE_Msk = 0xff0000

	// CH1STAT: DCP channel 1 status register
	// Position of HASH_MISMATCH field.
	DCP_CH1STAT_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH1STAT_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH1STAT_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH1STAT_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH1STAT_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH1STAT_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH1STAT_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH1STAT_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH1STAT_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH1STAT_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH1STAT_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH1STAT_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH1STAT_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH1STAT_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH1STAT_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH1STAT_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH1STAT_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH1STAT_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH1STAT_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH1STAT_ERROR_CODE_Msk = 0xff0000
	// Error is signalled because the next pointer is 0x00000000.
	DCP_CH1STAT_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	DCP_CH1STAT_ERROR_CODE_NO_CHAIN = 0x2
	// Error is signalled because an error was reported when reading/writing the context buffer.
	DCP_CH1STAT_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error is signalled because an error was reported when reading/writing the payload.
	DCP_CH1STAT_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
	DCP_CH1STAT_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH1STAT_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH1STAT_TAG_Msk = 0xff000000

	// CH1STAT_SET: DCP channel 1 status register
	// Position of HASH_MISMATCH field.
	DCP_CH1STAT_SET_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH1STAT_SET_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH1STAT_SET_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH1STAT_SET_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH1STAT_SET_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH1STAT_SET_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH1STAT_SET_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH1STAT_SET_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH1STAT_SET_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH1STAT_SET_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH1STAT_SET_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH1STAT_SET_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH1STAT_SET_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH1STAT_SET_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH1STAT_SET_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH1STAT_SET_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH1STAT_SET_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH1STAT_SET_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH1STAT_SET_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH1STAT_SET_ERROR_CODE_Msk = 0xff0000
	// Error is signalled because the next pointer is 0x00000000.
	DCP_CH1STAT_SET_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	DCP_CH1STAT_SET_ERROR_CODE_NO_CHAIN = 0x2
	// Error is signalled because an error was reported when reading/writing the context buffer.
	DCP_CH1STAT_SET_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error is signalled because an error was reported when reading/writing the payload.
	DCP_CH1STAT_SET_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
	DCP_CH1STAT_SET_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH1STAT_SET_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH1STAT_SET_TAG_Msk = 0xff000000

	// CH1STAT_CLR: DCP channel 1 status register
	// Position of HASH_MISMATCH field.
	DCP_CH1STAT_CLR_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH1STAT_CLR_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH1STAT_CLR_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH1STAT_CLR_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH1STAT_CLR_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH1STAT_CLR_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH1STAT_CLR_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH1STAT_CLR_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH1STAT_CLR_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH1STAT_CLR_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH1STAT_CLR_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH1STAT_CLR_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH1STAT_CLR_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH1STAT_CLR_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH1STAT_CLR_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH1STAT_CLR_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH1STAT_CLR_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH1STAT_CLR_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH1STAT_CLR_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH1STAT_CLR_ERROR_CODE_Msk = 0xff0000
	// Error is signalled because the next pointer is 0x00000000.
	DCP_CH1STAT_CLR_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	DCP_CH1STAT_CLR_ERROR_CODE_NO_CHAIN = 0x2
	// Error is signalled because an error was reported when reading/writing the context buffer.
	DCP_CH1STAT_CLR_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error is signalled because an error was reported when reading/writing the payload.
	DCP_CH1STAT_CLR_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
	DCP_CH1STAT_CLR_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH1STAT_CLR_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH1STAT_CLR_TAG_Msk = 0xff000000

	// CH1STAT_TOG: DCP channel 1 status register
	// Position of HASH_MISMATCH field.
	DCP_CH1STAT_TOG_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH1STAT_TOG_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH1STAT_TOG_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH1STAT_TOG_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH1STAT_TOG_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH1STAT_TOG_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH1STAT_TOG_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH1STAT_TOG_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH1STAT_TOG_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH1STAT_TOG_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH1STAT_TOG_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH1STAT_TOG_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH1STAT_TOG_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH1STAT_TOG_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH1STAT_TOG_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH1STAT_TOG_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH1STAT_TOG_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH1STAT_TOG_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH1STAT_TOG_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH1STAT_TOG_ERROR_CODE_Msk = 0xff0000
	// Error is signalled because the next pointer is 0x00000000.
	DCP_CH1STAT_TOG_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	DCP_CH1STAT_TOG_ERROR_CODE_NO_CHAIN = 0x2
	// Error is signalled because an error was reported when reading/writing the context buffer.
	DCP_CH1STAT_TOG_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error is signalled because an error was reported when reading/writing the payload.
	DCP_CH1STAT_TOG_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
	DCP_CH1STAT_TOG_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH1STAT_TOG_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH1STAT_TOG_TAG_Msk = 0xff000000

	// CH1OPTS: DCP channel 1 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH1OPTS_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH1OPTS_RECOVERY_TIMER_Msk = 0xffff

	// CH1OPTS_SET: DCP channel 1 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH1OPTS_SET_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH1OPTS_SET_RECOVERY_TIMER_Msk = 0xffff

	// CH1OPTS_CLR: DCP channel 1 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH1OPTS_CLR_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH1OPTS_CLR_RECOVERY_TIMER_Msk = 0xffff

	// CH1OPTS_TOG: DCP channel 1 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH1OPTS_TOG_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH1OPTS_TOG_RECOVERY_TIMER_Msk = 0xffff

	// CH2CMDPTR: DCP channel 2 command pointer address register
	// Position of ADDR field.
	DCP_CH2CMDPTR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	DCP_CH2CMDPTR_ADDR_Msk = 0xffffffff

	// CH2SEMA: DCP channel 2 semaphore register
	// Position of INCREMENT field.
	DCP_CH2SEMA_INCREMENT_Pos = 0x0
	// Bit mask of INCREMENT field.
	DCP_CH2SEMA_INCREMENT_Msk = 0xff
	// Position of VALUE field.
	DCP_CH2SEMA_VALUE_Pos = 0x10
	// Bit mask of VALUE field.
	DCP_CH2SEMA_VALUE_Msk = 0xff0000

	// CH2STAT: DCP channel 2 status register
	// Position of HASH_MISMATCH field.
	DCP_CH2STAT_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH2STAT_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH2STAT_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH2STAT_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH2STAT_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH2STAT_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH2STAT_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH2STAT_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH2STAT_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH2STAT_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH2STAT_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH2STAT_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH2STAT_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH2STAT_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH2STAT_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH2STAT_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH2STAT_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH2STAT_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH2STAT_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH2STAT_ERROR_CODE_Msk = 0xff0000
	// Error is signalled because the next pointer is 0x00000000.
	DCP_CH2STAT_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	DCP_CH2STAT_ERROR_CODE_NO_CHAIN = 0x2
	// Error is signalled because an error was reported while reading/writing the context buffer.
	DCP_CH2STAT_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error is signalled because an error was reported while reading/writing the payload.
	DCP_CH2STAT_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error is signalled because the control packet specifies an invalid mode select (for instance, blit + hash).
	DCP_CH2STAT_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH2STAT_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH2STAT_TAG_Msk = 0xff000000

	// CH2STAT_SET: DCP channel 2 status register
	// Position of HASH_MISMATCH field.
	DCP_CH2STAT_SET_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH2STAT_SET_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH2STAT_SET_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH2STAT_SET_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH2STAT_SET_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH2STAT_SET_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH2STAT_SET_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH2STAT_SET_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH2STAT_SET_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH2STAT_SET_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH2STAT_SET_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH2STAT_SET_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH2STAT_SET_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH2STAT_SET_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH2STAT_SET_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH2STAT_SET_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH2STAT_SET_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH2STAT_SET_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH2STAT_SET_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH2STAT_SET_ERROR_CODE_Msk = 0xff0000
	// Error is signalled because the next pointer is 0x00000000.
	DCP_CH2STAT_SET_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	DCP_CH2STAT_SET_ERROR_CODE_NO_CHAIN = 0x2
	// Error is signalled because an error was reported while reading/writing the context buffer.
	DCP_CH2STAT_SET_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error is signalled because an error was reported while reading/writing the payload.
	DCP_CH2STAT_SET_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error is signalled because the control packet specifies an invalid mode select (for instance, blit + hash).
	DCP_CH2STAT_SET_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH2STAT_SET_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH2STAT_SET_TAG_Msk = 0xff000000

	// CH2STAT_CLR: DCP channel 2 status register
	// Position of HASH_MISMATCH field.
	DCP_CH2STAT_CLR_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH2STAT_CLR_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH2STAT_CLR_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH2STAT_CLR_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH2STAT_CLR_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH2STAT_CLR_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH2STAT_CLR_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH2STAT_CLR_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH2STAT_CLR_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH2STAT_CLR_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH2STAT_CLR_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH2STAT_CLR_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH2STAT_CLR_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH2STAT_CLR_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH2STAT_CLR_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH2STAT_CLR_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH2STAT_CLR_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH2STAT_CLR_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH2STAT_CLR_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH2STAT_CLR_ERROR_CODE_Msk = 0xff0000
	// Error is signalled because the next pointer is 0x00000000.
	DCP_CH2STAT_CLR_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	DCP_CH2STAT_CLR_ERROR_CODE_NO_CHAIN = 0x2
	// Error is signalled because an error was reported while reading/writing the context buffer.
	DCP_CH2STAT_CLR_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error is signalled because an error was reported while reading/writing the payload.
	DCP_CH2STAT_CLR_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error is signalled because the control packet specifies an invalid mode select (for instance, blit + hash).
	DCP_CH2STAT_CLR_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH2STAT_CLR_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH2STAT_CLR_TAG_Msk = 0xff000000

	// CH2STAT_TOG: DCP channel 2 status register
	// Position of HASH_MISMATCH field.
	DCP_CH2STAT_TOG_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH2STAT_TOG_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH2STAT_TOG_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH2STAT_TOG_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH2STAT_TOG_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH2STAT_TOG_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH2STAT_TOG_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH2STAT_TOG_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH2STAT_TOG_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH2STAT_TOG_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH2STAT_TOG_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH2STAT_TOG_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH2STAT_TOG_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH2STAT_TOG_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH2STAT_TOG_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH2STAT_TOG_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH2STAT_TOG_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH2STAT_TOG_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH2STAT_TOG_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH2STAT_TOG_ERROR_CODE_Msk = 0xff0000
	// Error is signalled because the next pointer is 0x00000000.
	DCP_CH2STAT_TOG_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	DCP_CH2STAT_TOG_ERROR_CODE_NO_CHAIN = 0x2
	// Error is signalled because an error was reported while reading/writing the context buffer.
	DCP_CH2STAT_TOG_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error is signalled because an error was reported while reading/writing the payload.
	DCP_CH2STAT_TOG_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error is signalled because the control packet specifies an invalid mode select (for instance, blit + hash).
	DCP_CH2STAT_TOG_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH2STAT_TOG_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH2STAT_TOG_TAG_Msk = 0xff000000

	// CH2OPTS: DCP channel 2 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH2OPTS_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH2OPTS_RECOVERY_TIMER_Msk = 0xffff

	// CH2OPTS_SET: DCP channel 2 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH2OPTS_SET_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH2OPTS_SET_RECOVERY_TIMER_Msk = 0xffff

	// CH2OPTS_CLR: DCP channel 2 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH2OPTS_CLR_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH2OPTS_CLR_RECOVERY_TIMER_Msk = 0xffff

	// CH2OPTS_TOG: DCP channel 2 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH2OPTS_TOG_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH2OPTS_TOG_RECOVERY_TIMER_Msk = 0xffff

	// CH3CMDPTR: DCP channel 3 command pointer address register
	// Position of ADDR field.
	DCP_CH3CMDPTR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	DCP_CH3CMDPTR_ADDR_Msk = 0xffffffff

	// CH3SEMA: DCP channel 3 semaphore register
	// Position of INCREMENT field.
	DCP_CH3SEMA_INCREMENT_Pos = 0x0
	// Bit mask of INCREMENT field.
	DCP_CH3SEMA_INCREMENT_Msk = 0xff
	// Position of VALUE field.
	DCP_CH3SEMA_VALUE_Pos = 0x10
	// Bit mask of VALUE field.
	DCP_CH3SEMA_VALUE_Msk = 0xff0000

	// CH3STAT: DCP channel 3 status register
	// Position of HASH_MISMATCH field.
	DCP_CH3STAT_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH3STAT_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH3STAT_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH3STAT_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH3STAT_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH3STAT_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH3STAT_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH3STAT_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH3STAT_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH3STAT_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH3STAT_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH3STAT_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH3STAT_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH3STAT_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH3STAT_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH3STAT_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH3STAT_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH3STAT_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH3STAT_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH3STAT_ERROR_CODE_Msk = 0xff0000
	// Error is signalled because the next pointer is 0x00000000.
	DCP_CH3STAT_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	DCP_CH3STAT_ERROR_CODE_NO_CHAIN = 0x2
	// Error is signalled because an error was reported while reading/writing the context buffer.
	DCP_CH3STAT_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error is signalled because an error was reported while reading/writing the payload.
	DCP_CH3STAT_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
	DCP_CH3STAT_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH3STAT_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH3STAT_TAG_Msk = 0xff000000

	// CH3STAT_SET: DCP channel 3 status register
	// Position of HASH_MISMATCH field.
	DCP_CH3STAT_SET_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH3STAT_SET_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH3STAT_SET_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH3STAT_SET_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH3STAT_SET_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH3STAT_SET_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH3STAT_SET_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH3STAT_SET_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH3STAT_SET_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH3STAT_SET_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH3STAT_SET_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH3STAT_SET_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH3STAT_SET_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH3STAT_SET_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH3STAT_SET_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH3STAT_SET_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH3STAT_SET_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH3STAT_SET_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH3STAT_SET_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH3STAT_SET_ERROR_CODE_Msk = 0xff0000
	// Error is signalled because the next pointer is 0x00000000.
	DCP_CH3STAT_SET_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	DCP_CH3STAT_SET_ERROR_CODE_NO_CHAIN = 0x2
	// Error is signalled because an error was reported while reading/writing the context buffer.
	DCP_CH3STAT_SET_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error is signalled because an error was reported while reading/writing the payload.
	DCP_CH3STAT_SET_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
	DCP_CH3STAT_SET_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH3STAT_SET_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH3STAT_SET_TAG_Msk = 0xff000000

	// CH3STAT_CLR: DCP channel 3 status register
	// Position of HASH_MISMATCH field.
	DCP_CH3STAT_CLR_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH3STAT_CLR_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH3STAT_CLR_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH3STAT_CLR_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH3STAT_CLR_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH3STAT_CLR_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH3STAT_CLR_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH3STAT_CLR_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH3STAT_CLR_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH3STAT_CLR_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH3STAT_CLR_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH3STAT_CLR_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH3STAT_CLR_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH3STAT_CLR_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH3STAT_CLR_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH3STAT_CLR_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH3STAT_CLR_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH3STAT_CLR_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH3STAT_CLR_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH3STAT_CLR_ERROR_CODE_Msk = 0xff0000
	// Error is signalled because the next pointer is 0x00000000.
	DCP_CH3STAT_CLR_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	DCP_CH3STAT_CLR_ERROR_CODE_NO_CHAIN = 0x2
	// Error is signalled because an error was reported while reading/writing the context buffer.
	DCP_CH3STAT_CLR_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error is signalled because an error was reported while reading/writing the payload.
	DCP_CH3STAT_CLR_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
	DCP_CH3STAT_CLR_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH3STAT_CLR_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH3STAT_CLR_TAG_Msk = 0xff000000

	// CH3STAT_TOG: DCP channel 3 status register
	// Position of HASH_MISMATCH field.
	DCP_CH3STAT_TOG_HASH_MISMATCH_Pos = 0x1
	// Bit mask of HASH_MISMATCH field.
	DCP_CH3STAT_TOG_HASH_MISMATCH_Msk = 0x2
	// Bit HASH_MISMATCH.
	DCP_CH3STAT_TOG_HASH_MISMATCH = 0x2
	// Position of ERROR_SETUP field.
	DCP_CH3STAT_TOG_ERROR_SETUP_Pos = 0x2
	// Bit mask of ERROR_SETUP field.
	DCP_CH3STAT_TOG_ERROR_SETUP_Msk = 0x4
	// Bit ERROR_SETUP.
	DCP_CH3STAT_TOG_ERROR_SETUP = 0x4
	// Position of ERROR_PACKET field.
	DCP_CH3STAT_TOG_ERROR_PACKET_Pos = 0x3
	// Bit mask of ERROR_PACKET field.
	DCP_CH3STAT_TOG_ERROR_PACKET_Msk = 0x8
	// Bit ERROR_PACKET.
	DCP_CH3STAT_TOG_ERROR_PACKET = 0x8
	// Position of ERROR_SRC field.
	DCP_CH3STAT_TOG_ERROR_SRC_Pos = 0x4
	// Bit mask of ERROR_SRC field.
	DCP_CH3STAT_TOG_ERROR_SRC_Msk = 0x10
	// Bit ERROR_SRC.
	DCP_CH3STAT_TOG_ERROR_SRC = 0x10
	// Position of ERROR_DST field.
	DCP_CH3STAT_TOG_ERROR_DST_Pos = 0x5
	// Bit mask of ERROR_DST field.
	DCP_CH3STAT_TOG_ERROR_DST_Msk = 0x20
	// Bit ERROR_DST.
	DCP_CH3STAT_TOG_ERROR_DST = 0x20
	// Position of ERROR_PAGEFAULT field.
	DCP_CH3STAT_TOG_ERROR_PAGEFAULT_Pos = 0x6
	// Bit mask of ERROR_PAGEFAULT field.
	DCP_CH3STAT_TOG_ERROR_PAGEFAULT_Msk = 0x40
	// Bit ERROR_PAGEFAULT.
	DCP_CH3STAT_TOG_ERROR_PAGEFAULT = 0x40
	// Position of ERROR_CODE field.
	DCP_CH3STAT_TOG_ERROR_CODE_Pos = 0x10
	// Bit mask of ERROR_CODE field.
	DCP_CH3STAT_TOG_ERROR_CODE_Msk = 0xff0000
	// Error is signalled because the next pointer is 0x00000000.
	DCP_CH3STAT_TOG_ERROR_CODE_NEXT_CHAIN_IS_0 = 0x1
	// Error is signalled because the semaphore is of a non-zero value and neither of the chain bits is set.
	DCP_CH3STAT_TOG_ERROR_CODE_NO_CHAIN = 0x2
	// Error is signalled because an error was reported while reading/writing the context buffer.
	DCP_CH3STAT_TOG_ERROR_CODE_CONTEXT_ERROR = 0x3
	// Error is signalled because an error was reported while reading/writing the payload.
	DCP_CH3STAT_TOG_ERROR_CODE_PAYLOAD_ERROR = 0x4
	// Error is signalled because the control packet specifies an invalid mode select (for example, blit + hash).
	DCP_CH3STAT_TOG_ERROR_CODE_INVALID_MODE = 0x5
	// Position of TAG field.
	DCP_CH3STAT_TOG_TAG_Pos = 0x18
	// Bit mask of TAG field.
	DCP_CH3STAT_TOG_TAG_Msk = 0xff000000

	// CH3OPTS: DCP channel 3 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH3OPTS_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH3OPTS_RECOVERY_TIMER_Msk = 0xffff

	// CH3OPTS_SET: DCP channel 3 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH3OPTS_SET_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH3OPTS_SET_RECOVERY_TIMER_Msk = 0xffff

	// CH3OPTS_CLR: DCP channel 3 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH3OPTS_CLR_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH3OPTS_CLR_RECOVERY_TIMER_Msk = 0xffff

	// CH3OPTS_TOG: DCP channel 3 options register
	// Position of RECOVERY_TIMER field.
	DCP_CH3OPTS_TOG_RECOVERY_TIMER_Pos = 0x0
	// Bit mask of RECOVERY_TIMER field.
	DCP_CH3OPTS_TOG_RECOVERY_TIMER_Msk = 0xffff

	// DBGSELECT: DCP debug select register
	// Position of INDEX field.
	DCP_DBGSELECT_INDEX_Pos = 0x0
	// Bit mask of INDEX field.
	DCP_DBGSELECT_INDEX_Msk = 0xff
	// CONTROL
	DCP_DBGSELECT_INDEX_CONTROL = 0x1
	// OTPKEY0
	DCP_DBGSELECT_INDEX_OTPKEY0 = 0x10
	// OTPKEY1
	DCP_DBGSELECT_INDEX_OTPKEY1 = 0x11
	// OTPKEY2
	DCP_DBGSELECT_INDEX_OTPKEY2 = 0x12
	// OTPKEY3
	DCP_DBGSELECT_INDEX_OTPKEY3 = 0x13

	// DBGDATA: DCP debug data register
	// Position of DATA field.
	DCP_DBGDATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	DCP_DBGDATA_DATA_Msk = 0xffffffff

	// PAGETABLE: DCP page table register
	// Position of ENABLE field.
	DCP_PAGETABLE_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	DCP_PAGETABLE_ENABLE_Msk = 0x1
	// Bit ENABLE.
	DCP_PAGETABLE_ENABLE = 0x1
	// Position of FLUSH field.
	DCP_PAGETABLE_FLUSH_Pos = 0x1
	// Bit mask of FLUSH field.
	DCP_PAGETABLE_FLUSH_Msk = 0x2
	// Bit FLUSH.
	DCP_PAGETABLE_FLUSH = 0x2
	// Position of BASE field.
	DCP_PAGETABLE_BASE_Pos = 0x2
	// Bit mask of BASE field.
	DCP_PAGETABLE_BASE_Msk = 0xfffffffc

	// VERSION: DCP version register
	// Position of STEP field.
	DCP_VERSION_STEP_Pos = 0x0
	// Bit mask of STEP field.
	DCP_VERSION_STEP_Msk = 0xffff
	// Position of MINOR field.
	DCP_VERSION_MINOR_Pos = 0x10
	// Bit mask of MINOR field.
	DCP_VERSION_MINOR_Msk = 0xff0000
	// Position of MAJOR field.
	DCP_VERSION_MAJOR_Pos = 0x18
	// Bit mask of MAJOR field.
	DCP_VERSION_MAJOR_Msk = 0xff000000
)

// Constants for GPC: GPC
const (
	// CNTR: GPC Interface control register
	// Position of MEGA_PDN_REQ field.
	GPC_CNTR_MEGA_PDN_REQ_Pos = 0x2
	// Bit mask of MEGA_PDN_REQ field.
	GPC_CNTR_MEGA_PDN_REQ_Msk = 0x4
	// Bit MEGA_PDN_REQ.
	GPC_CNTR_MEGA_PDN_REQ = 0x4
	// No Request
	GPC_CNTR_MEGA_PDN_REQ_MEGA_PDN_REQ_0 = 0x0
	// Request power down sequence
	GPC_CNTR_MEGA_PDN_REQ_MEGA_PDN_REQ_1 = 0x1
	// Position of MEGA_PUP_REQ field.
	GPC_CNTR_MEGA_PUP_REQ_Pos = 0x3
	// Bit mask of MEGA_PUP_REQ field.
	GPC_CNTR_MEGA_PUP_REQ_Msk = 0x8
	// Bit MEGA_PUP_REQ.
	GPC_CNTR_MEGA_PUP_REQ = 0x8
	// No Request
	GPC_CNTR_MEGA_PUP_REQ_MEGA_PUP_REQ_0 = 0x0
	// Request power up sequence
	GPC_CNTR_MEGA_PUP_REQ_MEGA_PUP_REQ_1 = 0x1
	// Position of PDRAM0_PGE field.
	GPC_CNTR_PDRAM0_PGE_Pos = 0x16
	// Bit mask of PDRAM0_PGE field.
	GPC_CNTR_PDRAM0_PGE_Msk = 0x400000
	// Bit PDRAM0_PGE.
	GPC_CNTR_PDRAM0_PGE = 0x400000
	// FlexRAM PDRAM0 domain will keep power even if the CPU core is powered down.
	GPC_CNTR_PDRAM0_PGE_PDRAM0_PGE_0 = 0x0
	// FlexRAM PDRAM0 domain will be powered down when the CPU core is powered down..
	GPC_CNTR_PDRAM0_PGE_PDRAM0_PGE_1 = 0x1

	// IMR1: IRQ masking register 1
	// Position of IMR1 field.
	GPC_IMR1_IMR1_Pos = 0x0
	// Bit mask of IMR1 field.
	GPC_IMR1_IMR1_Msk = 0xffffffff

	// IMR2: IRQ masking register 2
	// Position of IMR2 field.
	GPC_IMR2_IMR2_Pos = 0x0
	// Bit mask of IMR2 field.
	GPC_IMR2_IMR2_Msk = 0xffffffff

	// IMR3: IRQ masking register 3
	// Position of IMR3 field.
	GPC_IMR3_IMR3_Pos = 0x0
	// Bit mask of IMR3 field.
	GPC_IMR3_IMR3_Msk = 0xffffffff

	// IMR4: IRQ masking register 4
	// Position of IMR4 field.
	GPC_IMR4_IMR4_Pos = 0x0
	// Bit mask of IMR4 field.
	GPC_IMR4_IMR4_Msk = 0xffffffff

	// ISR1: IRQ status resister 1
	// Position of ISR1 field.
	GPC_ISR1_ISR1_Pos = 0x0
	// Bit mask of ISR1 field.
	GPC_ISR1_ISR1_Msk = 0xffffffff

	// ISR2: IRQ status resister 2
	// Position of ISR2 field.
	GPC_ISR2_ISR2_Pos = 0x0
	// Bit mask of ISR2 field.
	GPC_ISR2_ISR2_Msk = 0xffffffff

	// ISR3: IRQ status resister 3
	// Position of ISR3 field.
	GPC_ISR3_ISR3_Pos = 0x0
	// Bit mask of ISR3 field.
	GPC_ISR3_ISR3_Msk = 0xffffffff

	// ISR4: IRQ status resister 4
	// Position of ISR4 field.
	GPC_ISR4_ISR4_Pos = 0x0
	// Bit mask of ISR4 field.
	GPC_ISR4_ISR4_Msk = 0xffffffff

	// IMR5: IRQ masking register 5
	// Position of IMR5 field.
	GPC_IMR5_IMR5_Pos = 0x0
	// Bit mask of IMR5 field.
	GPC_IMR5_IMR5_Msk = 0xffffffff

	// ISR5: IRQ status resister 5
	// Position of ISR4 field.
	GPC_ISR5_ISR4_Pos = 0x0
	// Bit mask of ISR4 field.
	GPC_ISR5_ISR4_Msk = 0xffffffff
)

// Constants for PGC: PGC
const (
	// MEGA_CTRL: PGC Mega Control Register
	// Position of PCR field.
	PGC_MEGA_CTRL_PCR_Pos = 0x0
	// Bit mask of PCR field.
	PGC_MEGA_CTRL_PCR_Msk = 0x1
	// Bit PCR.
	PGC_MEGA_CTRL_PCR = 0x1
	// Do not switch off power even if pdn_req is asserted.
	PGC_MEGA_CTRL_PCR_PCR_0 = 0x0
	// Switch off power when pdn_req is asserted.
	PGC_MEGA_CTRL_PCR_PCR_1 = 0x1

	// MEGA_PUPSCR: PGC Mega Power Up Sequence Control Register
	// Position of SW field.
	PGC_MEGA_PUPSCR_SW_Pos = 0x0
	// Bit mask of SW field.
	PGC_MEGA_PUPSCR_SW_Msk = 0x3f
	// Position of SW2ISO field.
	PGC_MEGA_PUPSCR_SW2ISO_Pos = 0x8
	// Bit mask of SW2ISO field.
	PGC_MEGA_PUPSCR_SW2ISO_Msk = 0x3f00

	// MEGA_PDNSCR: PGC Mega Pull Down Sequence Control Register
	// Position of ISO field.
	PGC_MEGA_PDNSCR_ISO_Pos = 0x0
	// Bit mask of ISO field.
	PGC_MEGA_PDNSCR_ISO_Msk = 0x3f
	// Position of ISO2SW field.
	PGC_MEGA_PDNSCR_ISO2SW_Pos = 0x8
	// Bit mask of ISO2SW field.
	PGC_MEGA_PDNSCR_ISO2SW_Msk = 0x3f00

	// MEGA_SR: PGC Mega Power Gating Controller Status Register
	// Position of PSR field.
	PGC_MEGA_SR_PSR_Pos = 0x0
	// Bit mask of PSR field.
	PGC_MEGA_SR_PSR_Msk = 0x1
	// Bit PSR.
	PGC_MEGA_SR_PSR = 0x1
	// The target subsystem was not powered down for the previous power-down request.
	PGC_MEGA_SR_PSR_PSR_0 = 0x0
	// The target subsystem was powered down for the previous power-down request.
	PGC_MEGA_SR_PSR_PSR_1 = 0x1

	// CPU_CTRL: PGC CPU Control Register
	// Position of PCR field.
	PGC_CPU_CTRL_PCR_Pos = 0x0
	// Bit mask of PCR field.
	PGC_CPU_CTRL_PCR_Msk = 0x1
	// Bit PCR.
	PGC_CPU_CTRL_PCR = 0x1
	// Do not switch off power even if pdn_req is asserted.
	PGC_CPU_CTRL_PCR_PCR_0 = 0x0
	// Switch off power when pdn_req is asserted.
	PGC_CPU_CTRL_PCR_PCR_1 = 0x1

	// CPU_PUPSCR: PGC CPU Power Up Sequence Control Register
	// Position of SW field.
	PGC_CPU_PUPSCR_SW_Pos = 0x0
	// Bit mask of SW field.
	PGC_CPU_PUPSCR_SW_Msk = 0x3f
	// Position of SW2ISO field.
	PGC_CPU_PUPSCR_SW2ISO_Pos = 0x8
	// Bit mask of SW2ISO field.
	PGC_CPU_PUPSCR_SW2ISO_Msk = 0x3f00

	// CPU_PDNSCR: PGC CPU Pull Down Sequence Control Register
	// Position of ISO field.
	PGC_CPU_PDNSCR_ISO_Pos = 0x0
	// Bit mask of ISO field.
	PGC_CPU_PDNSCR_ISO_Msk = 0x3f
	// Position of ISO2SW field.
	PGC_CPU_PDNSCR_ISO2SW_Pos = 0x8
	// Bit mask of ISO2SW field.
	PGC_CPU_PDNSCR_ISO2SW_Msk = 0x3f00

	// CPU_SR: PGC CPU Power Gating Controller Status Register
	// Position of PSR field.
	PGC_CPU_SR_PSR_Pos = 0x0
	// Bit mask of PSR field.
	PGC_CPU_SR_PSR_Msk = 0x1
	// Bit PSR.
	PGC_CPU_SR_PSR = 0x1
	// The target subsystem was not powered down for the previous power-down request.
	PGC_CPU_SR_PSR_PSR_0 = 0x0
	// The target subsystem was powered down for the previous power-down request.
	PGC_CPU_SR_PSR_PSR_1 = 0x1
)

// Constants for SRC: SRC
const (
	// SCR: SRC Control Register
	// Position of LOCKUP_RST field.
	SRC_SCR_LOCKUP_RST_Pos = 0x4
	// Bit mask of LOCKUP_RST field.
	SRC_SCR_LOCKUP_RST_Msk = 0x10
	// Bit LOCKUP_RST.
	SRC_SCR_LOCKUP_RST = 0x10
	// disabled
	SRC_SCR_LOCKUP_RST_LOCKUP_RST_0 = 0x0
	// enabled
	SRC_SCR_LOCKUP_RST_LOCKUP_RST_1 = 0x1
	// Position of MASK_WDOG_RST field.
	SRC_SCR_MASK_WDOG_RST_Pos = 0x7
	// Bit mask of MASK_WDOG_RST field.
	SRC_SCR_MASK_WDOG_RST_Msk = 0x780
	// wdog_rst_b is masked
	SRC_SCR_MASK_WDOG_RST_MASK_WDOG_RST_5 = 0x5
	// wdog_rst_b is not masked (default)
	SRC_SCR_MASK_WDOG_RST_MASK_WDOG_RST_10 = 0xa
	// Position of CORE0_RST field.
	SRC_SCR_CORE0_RST_Pos = 0xd
	// Bit mask of CORE0_RST field.
	SRC_SCR_CORE0_RST_Msk = 0x2000
	// Bit CORE0_RST.
	SRC_SCR_CORE0_RST = 0x2000
	// do not assert core0 reset
	SRC_SCR_CORE0_RST_CORE0_RST_0 = 0x0
	// assert core0 reset
	SRC_SCR_CORE0_RST_CORE0_RST_1 = 0x1
	// Position of CORE0_DBG_RST field.
	SRC_SCR_CORE0_DBG_RST_Pos = 0x11
	// Bit mask of CORE0_DBG_RST field.
	SRC_SCR_CORE0_DBG_RST_Msk = 0x20000
	// Bit CORE0_DBG_RST.
	SRC_SCR_CORE0_DBG_RST = 0x20000
	// do not assert core0 debug reset
	SRC_SCR_CORE0_DBG_RST_CORE0_DBG_RST_0 = 0x0
	// assert core0 debug reset
	SRC_SCR_CORE0_DBG_RST_CORE0_DBG_RST_1 = 0x1
	// Position of DBG_RST_MSK_PG field.
	SRC_SCR_DBG_RST_MSK_PG_Pos = 0x19
	// Bit mask of DBG_RST_MSK_PG field.
	SRC_SCR_DBG_RST_MSK_PG_Msk = 0x2000000
	// Bit DBG_RST_MSK_PG.
	SRC_SCR_DBG_RST_MSK_PG = 0x2000000
	// do not mask core debug resets (debug resets will be asserted after power gating event)
	SRC_SCR_DBG_RST_MSK_PG_DBG_RST_MSK_PG_0 = 0x0
	// mask core debug resets (debug resets won't be asserted after power gating event)
	SRC_SCR_DBG_RST_MSK_PG_DBG_RST_MSK_PG_1 = 0x1
	// Position of MASK_WDOG3_RST field.
	SRC_SCR_MASK_WDOG3_RST_Pos = 0x1c
	// Bit mask of MASK_WDOG3_RST field.
	SRC_SCR_MASK_WDOG3_RST_Msk = 0xf0000000
	// wdog3_rst_b is masked
	SRC_SCR_MASK_WDOG3_RST_MASK_WDOG3_RST_5 = 0x5
	// wdog3_rst_b is not masked
	SRC_SCR_MASK_WDOG3_RST_MASK_WDOG3_RST_10 = 0xa

	// SBMR1: SRC Boot Mode Register 1
	// Position of BOOT_CFG1 field.
	SRC_SBMR1_BOOT_CFG1_Pos = 0x0
	// Bit mask of BOOT_CFG1 field.
	SRC_SBMR1_BOOT_CFG1_Msk = 0xff
	// Position of BOOT_CFG2 field.
	SRC_SBMR1_BOOT_CFG2_Pos = 0x8
	// Bit mask of BOOT_CFG2 field.
	SRC_SBMR1_BOOT_CFG2_Msk = 0xff00
	// Position of BOOT_CFG3 field.
	SRC_SBMR1_BOOT_CFG3_Pos = 0x10
	// Bit mask of BOOT_CFG3 field.
	SRC_SBMR1_BOOT_CFG3_Msk = 0xff0000
	// Position of BOOT_CFG4 field.
	SRC_SBMR1_BOOT_CFG4_Pos = 0x18
	// Bit mask of BOOT_CFG4 field.
	SRC_SBMR1_BOOT_CFG4_Msk = 0xff000000

	// SRSR: SRC Reset Status Register
	// Position of IPP_RESET_B field.
	SRC_SRSR_IPP_RESET_B_Pos = 0x0
	// Bit mask of IPP_RESET_B field.
	SRC_SRSR_IPP_RESET_B_Msk = 0x1
	// Bit IPP_RESET_B.
	SRC_SRSR_IPP_RESET_B = 0x1
	// Reset is not a result of ipp_reset_b pin.
	SRC_SRSR_IPP_RESET_B_IPP_RESET_B_0 = 0x0
	// Reset is a result of ipp_reset_b pin.
	SRC_SRSR_IPP_RESET_B_IPP_RESET_B_1 = 0x1
	// Position of LOCKUP field.
	SRC_SRSR_LOCKUP_Pos = 0x1
	// Bit mask of LOCKUP field.
	SRC_SRSR_LOCKUP_Msk = 0x2
	// Bit LOCKUP.
	SRC_SRSR_LOCKUP = 0x2
	// Reset is not a result of the mentioned case.
	SRC_SRSR_LOCKUP_LOCKUP_0 = 0x0
	// Reset is a result of the mentioned case.
	SRC_SRSR_LOCKUP_LOCKUP_1 = 0x1
	// Position of CSU_RESET_B field.
	SRC_SRSR_CSU_RESET_B_Pos = 0x2
	// Bit mask of CSU_RESET_B field.
	SRC_SRSR_CSU_RESET_B_Msk = 0x4
	// Bit CSU_RESET_B.
	SRC_SRSR_CSU_RESET_B = 0x4
	// Reset is not a result of the csu_reset_b event.
	SRC_SRSR_CSU_RESET_B_CSU_RESET_B_0 = 0x0
	// Reset is a result of the csu_reset_b event.
	SRC_SRSR_CSU_RESET_B_CSU_RESET_B_1 = 0x1
	// Position of IPP_USER_RESET_B field.
	SRC_SRSR_IPP_USER_RESET_B_Pos = 0x3
	// Bit mask of IPP_USER_RESET_B field.
	SRC_SRSR_IPP_USER_RESET_B_Msk = 0x8
	// Bit IPP_USER_RESET_B.
	SRC_SRSR_IPP_USER_RESET_B = 0x8
	// Reset is not a result of the ipp_user_reset_b qualified as COLD reset event.
	SRC_SRSR_IPP_USER_RESET_B_IPP_USER_RESET_B_0 = 0x0
	// Reset is a result of the ipp_user_reset_b qualified as COLD reset event.
	SRC_SRSR_IPP_USER_RESET_B_IPP_USER_RESET_B_1 = 0x1
	// Position of WDOG_RST_B field.
	SRC_SRSR_WDOG_RST_B_Pos = 0x4
	// Bit mask of WDOG_RST_B field.
	SRC_SRSR_WDOG_RST_B_Msk = 0x10
	// Bit WDOG_RST_B.
	SRC_SRSR_WDOG_RST_B = 0x10
	// Reset is not a result of the watchdog time-out event.
	SRC_SRSR_WDOG_RST_B_WDOG_RST_B_0 = 0x0
	// Reset is a result of the watchdog time-out event.
	SRC_SRSR_WDOG_RST_B_WDOG_RST_B_1 = 0x1
	// Position of JTAG_RST_B field.
	SRC_SRSR_JTAG_RST_B_Pos = 0x5
	// Bit mask of JTAG_RST_B field.
	SRC_SRSR_JTAG_RST_B_Msk = 0x20
	// Bit JTAG_RST_B.
	SRC_SRSR_JTAG_RST_B = 0x20
	// Reset is not a result of HIGH-Z reset from JTAG.
	SRC_SRSR_JTAG_RST_B_JTAG_RST_B_0 = 0x0
	// Reset is a result of HIGH-Z reset from JTAG.
	SRC_SRSR_JTAG_RST_B_JTAG_RST_B_1 = 0x1
	// Position of JTAG_SW_RST field.
	SRC_SRSR_JTAG_SW_RST_Pos = 0x6
	// Bit mask of JTAG_SW_RST field.
	SRC_SRSR_JTAG_SW_RST_Msk = 0x40
	// Bit JTAG_SW_RST.
	SRC_SRSR_JTAG_SW_RST = 0x40
	// Reset is not a result of the mentioned case.
	SRC_SRSR_JTAG_SW_RST_JTAG_SW_RST_0 = 0x0
	// Reset is not a result of the mentioned case.
	SRC_SRSR_JTAG_SW_RST_JTAG_SW_RST_1 = 0x1
	// Position of WDOG3_RST_B field.
	SRC_SRSR_WDOG3_RST_B_Pos = 0x7
	// Bit mask of WDOG3_RST_B field.
	SRC_SRSR_WDOG3_RST_B_Msk = 0x80
	// Bit WDOG3_RST_B.
	SRC_SRSR_WDOG3_RST_B = 0x80
	// Reset is not a result of the watchdog3 time-out event.
	SRC_SRSR_WDOG3_RST_B_WDOG3_RST_B_0 = 0x0
	// Reset is a result of the watchdog3 time-out event.
	SRC_SRSR_WDOG3_RST_B_WDOG3_RST_B_1 = 0x1
	// Position of TEMPSENSE_RST_B field.
	SRC_SRSR_TEMPSENSE_RST_B_Pos = 0x8
	// Bit mask of TEMPSENSE_RST_B field.
	SRC_SRSR_TEMPSENSE_RST_B_Msk = 0x100
	// Bit TEMPSENSE_RST_B.
	SRC_SRSR_TEMPSENSE_RST_B = 0x100
	// Reset is not a result of software reset from Temperature Sensor.
	SRC_SRSR_TEMPSENSE_RST_B_TEMPSENSE_RST_B_0 = 0x0
	// Reset is a result of software reset from Temperature Sensor.
	SRC_SRSR_TEMPSENSE_RST_B_TEMPSENSE_RST_B_1 = 0x1

	// SBMR2: SRC Boot Mode Register 2
	// Position of SEC_CONFIG field.
	SRC_SBMR2_SEC_CONFIG_Pos = 0x0
	// Bit mask of SEC_CONFIG field.
	SRC_SBMR2_SEC_CONFIG_Msk = 0x3
	// Position of DIR_BT_DIS field.
	SRC_SBMR2_DIR_BT_DIS_Pos = 0x3
	// Bit mask of DIR_BT_DIS field.
	SRC_SBMR2_DIR_BT_DIS_Msk = 0x8
	// Bit DIR_BT_DIS.
	SRC_SBMR2_DIR_BT_DIS = 0x8
	// Position of BT_FUSE_SEL field.
	SRC_SBMR2_BT_FUSE_SEL_Pos = 0x4
	// Bit mask of BT_FUSE_SEL field.
	SRC_SBMR2_BT_FUSE_SEL_Msk = 0x10
	// Bit BT_FUSE_SEL.
	SRC_SBMR2_BT_FUSE_SEL = 0x10
	// Position of BMOD field.
	SRC_SBMR2_BMOD_Pos = 0x18
	// Bit mask of BMOD field.
	SRC_SBMR2_BMOD_Msk = 0x3000000

	// GPR1: SRC General Purpose Register 1
	// Position of PERSISTENT_ENTRY0 field.
	SRC_GPR1_PERSISTENT_ENTRY0_Pos = 0x0
	// Bit mask of PERSISTENT_ENTRY0 field.
	SRC_GPR1_PERSISTENT_ENTRY0_Msk = 0xffffffff

	// GPR2: SRC General Purpose Register 2
	// Position of PERSISTENT_ARG0 field.
	SRC_GPR2_PERSISTENT_ARG0_Pos = 0x0
	// Bit mask of PERSISTENT_ARG0 field.
	SRC_GPR2_PERSISTENT_ARG0_Msk = 0xffffffff

	// GPR10: SRC General Purpose Register 10
	// Position of PERSIST_REDUNDANT_BOOT field.
	SRC_GPR10_PERSIST_REDUNDANT_BOOT_Pos = 0x1a
	// Bit mask of PERSIST_REDUNDANT_BOOT field.
	SRC_GPR10_PERSIST_REDUNDANT_BOOT_Msk = 0xc000000
	// Position of PERSIST_SECONDARY_BOOT field.
	SRC_GPR10_PERSIST_SECONDARY_BOOT_Pos = 0x1e
	// Bit mask of PERSIST_SECONDARY_BOOT field.
	SRC_GPR10_PERSIST_SECONDARY_BOOT_Msk = 0x40000000
	// Bit PERSIST_SECONDARY_BOOT.
	SRC_GPR10_PERSIST_SECONDARY_BOOT = 0x40000000
)

// Constants for CCM: CCM
const (
	// CCR: CCM Control Register
	// Position of OSCNT field.
	CCM_CCR_OSCNT_Pos = 0x0
	// Bit mask of OSCNT field.
	CCM_CCR_OSCNT_Msk = 0xff
	// Position of COSC_EN field.
	CCM_CCR_COSC_EN_Pos = 0xc
	// Bit mask of COSC_EN field.
	CCM_CCR_COSC_EN_Msk = 0x1000
	// Bit COSC_EN.
	CCM_CCR_COSC_EN = 0x1000
	// disable on chip oscillator
	CCM_CCR_COSC_EN_COSC_EN_0 = 0x0
	// enable on chip oscillator
	CCM_CCR_COSC_EN_COSC_EN_1 = 0x1
	// Position of REG_BYPASS_COUNT field.
	CCM_CCR_REG_BYPASS_COUNT_Pos = 0x15
	// Bit mask of REG_BYPASS_COUNT field.
	CCM_CCR_REG_BYPASS_COUNT_Msk = 0x7e00000
	// no delay
	CCM_CCR_REG_BYPASS_COUNT_REG_BYPASS_COUNT_0 = 0x0
	// 1 CKIL clock period delay
	CCM_CCR_REG_BYPASS_COUNT_REG_BYPASS_COUNT_1 = 0x1
	// 63 CKIL clock periods delay
	CCM_CCR_REG_BYPASS_COUNT_REG_BYPASS_COUNT_63 = 0x3f
	// Position of RBC_EN field.
	CCM_CCR_RBC_EN_Pos = 0x1b
	// Bit mask of RBC_EN field.
	CCM_CCR_RBC_EN_Msk = 0x8000000
	// Bit RBC_EN.
	CCM_CCR_RBC_EN = 0x8000000
	// REG_BYPASS_COUNTER disabled
	CCM_CCR_RBC_EN_RBC_EN_0 = 0x0
	// REG_BYPASS_COUNTER enabled.
	CCM_CCR_RBC_EN_RBC_EN_1 = 0x1

	// CSR: CCM Status Register
	// Position of REF_EN_B field.
	CCM_CSR_REF_EN_B_Pos = 0x0
	// Bit mask of REF_EN_B field.
	CCM_CSR_REF_EN_B_Msk = 0x1
	// Bit REF_EN_B.
	CCM_CSR_REF_EN_B = 0x1
	// value of CCM_REF_EN_B is '0'
	CCM_CSR_REF_EN_B_REF_EN_B_0 = 0x0
	// value of CCM_REF_EN_B is '1'
	CCM_CSR_REF_EN_B_REF_EN_B_1 = 0x1
	// Position of CAMP2_READY field.
	CCM_CSR_CAMP2_READY_Pos = 0x3
	// Bit mask of CAMP2_READY field.
	CCM_CSR_CAMP2_READY_Msk = 0x8
	// Bit CAMP2_READY.
	CCM_CSR_CAMP2_READY = 0x8
	// CAMP2 is not ready.
	CCM_CSR_CAMP2_READY_CAMP2_READY_0 = 0x0
	// CAMP2 is ready.
	CCM_CSR_CAMP2_READY_CAMP2_READY_1 = 0x1
	// Position of COSC_READY field.
	CCM_CSR_COSC_READY_Pos = 0x5
	// Bit mask of COSC_READY field.
	CCM_CSR_COSC_READY_Msk = 0x20
	// Bit COSC_READY.
	CCM_CSR_COSC_READY = 0x20
	// on board oscillator is not ready.
	CCM_CSR_COSC_READY_COSC_READY_0 = 0x0
	// on board oscillator is ready.
	CCM_CSR_COSC_READY_COSC_READY_1 = 0x1

	// CCSR: CCM Clock Switcher Register
	// Position of PLL3_SW_CLK_SEL field.
	CCM_CCSR_PLL3_SW_CLK_SEL_Pos = 0x0
	// Bit mask of PLL3_SW_CLK_SEL field.
	CCM_CCSR_PLL3_SW_CLK_SEL_Msk = 0x1
	// Bit PLL3_SW_CLK_SEL.
	CCM_CCSR_PLL3_SW_CLK_SEL = 0x1
	// pll3_main_clk
	CCM_CCSR_PLL3_SW_CLK_SEL_PLL3_SW_CLK_SEL_0 = 0x0
	// pll3 bypass clock
	CCM_CCSR_PLL3_SW_CLK_SEL_PLL3_SW_CLK_SEL_1 = 0x1

	// CBCDR: CCM Bus Clock Divider Register
	// Position of IPG_PODF field.
	CCM_CBCDR_IPG_PODF_Pos = 0x8
	// Bit mask of IPG_PODF field.
	CCM_CBCDR_IPG_PODF_Msk = 0x300
	// divide by 1
	CCM_CBCDR_IPG_PODF_IPG_PODF_0 = 0x0
	// divide by 2
	CCM_CBCDR_IPG_PODF_IPG_PODF_1 = 0x1
	// divide by 3
	CCM_CBCDR_IPG_PODF_IPG_PODF_2 = 0x2
	// divide by 4
	CCM_CBCDR_IPG_PODF_IPG_PODF_3 = 0x3
	// Position of AHB_PODF field.
	CCM_CBCDR_AHB_PODF_Pos = 0xa
	// Bit mask of AHB_PODF field.
	CCM_CBCDR_AHB_PODF_Msk = 0x1c00
	// divide by 1
	CCM_CBCDR_AHB_PODF_AHB_PODF_0 = 0x0
	// divide by 2
	CCM_CBCDR_AHB_PODF_AHB_PODF_1 = 0x1
	// divide by 3
	CCM_CBCDR_AHB_PODF_AHB_PODF_2 = 0x2
	// divide by 4
	CCM_CBCDR_AHB_PODF_AHB_PODF_3 = 0x3
	// divide by 5
	CCM_CBCDR_AHB_PODF_AHB_PODF_4 = 0x4
	// divide by 6
	CCM_CBCDR_AHB_PODF_AHB_PODF_5 = 0x5
	// divide by 7
	CCM_CBCDR_AHB_PODF_AHB_PODF_6 = 0x6
	// divide by 8
	CCM_CBCDR_AHB_PODF_AHB_PODF_7 = 0x7
	// Position of PERIPH_CLK_SEL field.
	CCM_CBCDR_PERIPH_CLK_SEL_Pos = 0x19
	// Bit mask of PERIPH_CLK_SEL field.
	CCM_CBCDR_PERIPH_CLK_SEL_Msk = 0x2000000
	// Bit PERIPH_CLK_SEL.
	CCM_CBCDR_PERIPH_CLK_SEL = 0x2000000
	// derive clock selected by CCM_CBCMR[CORE_CLK_PRE_SEL]
	CCM_CBCDR_PERIPH_CLK_SEL_PERIPH_CLK_SEL_0 = 0x0
	// derive clock selected by CCM_CBCMR[PERIPH_CLK2_SEL]
	CCM_CBCDR_PERIPH_CLK_SEL_PERIPH_CLK_SEL_1 = 0x1

	// CBCMR: CCM Bus Clock Multiplexer Register
	// Position of LPSPI_CLK_SEL field.
	CCM_CBCMR_LPSPI_CLK_SEL_Pos = 0x4
	// Bit mask of LPSPI_CLK_SEL field.
	CCM_CBCMR_LPSPI_CLK_SEL_Msk = 0x30
	// derive clock from PLL3 PFD1 clk
	CCM_CBCMR_LPSPI_CLK_SEL_LPSPI_CLK_SEL_0 = 0x0
	// derive clock from PLL3 PFD0
	CCM_CBCMR_LPSPI_CLK_SEL_LPSPI_CLK_SEL_1 = 0x1
	// derive clock from PLL2
	CCM_CBCMR_LPSPI_CLK_SEL_LPSPI_CLK_SEL_2 = 0x2
	// derive clock from PLL2 PFD2
	CCM_CBCMR_LPSPI_CLK_SEL_LPSPI_CLK_SEL_3 = 0x3
	// Position of PERIPH_CLK2_SEL field.
	CCM_CBCMR_PERIPH_CLK2_SEL_Pos = 0xc
	// Bit mask of PERIPH_CLK2_SEL field.
	CCM_CBCMR_PERIPH_CLK2_SEL_Msk = 0x3000
	// derive clock from pll3_sw_clk
	CCM_CBCMR_PERIPH_CLK2_SEL_PERIPH_CLK2_SEL_0 = 0x0
	// derive clock from osc_clk
	CCM_CBCMR_PERIPH_CLK2_SEL_PERIPH_CLK2_SEL_1 = 0x1
	// derive clock from pll2_bypass_clk
	CCM_CBCMR_PERIPH_CLK2_SEL_PERIPH_CLK2_SEL_2 = 0x2
	// Position of TRACE_CLK_SEL field.
	CCM_CBCMR_TRACE_CLK_SEL_Pos = 0xe
	// Bit mask of TRACE_CLK_SEL field.
	CCM_CBCMR_TRACE_CLK_SEL_Msk = 0xc000
	// derive clock from PLL2
	CCM_CBCMR_TRACE_CLK_SEL_TRACE_CLK_SEL_0 = 0x0
	// derive clock from PLL2 PFD2
	CCM_CBCMR_TRACE_CLK_SEL_TRACE_CLK_SEL_1 = 0x1
	// derive clock from PLL2 PFD0
	CCM_CBCMR_TRACE_CLK_SEL_TRACE_CLK_SEL_2 = 0x2
	// derive clock from PLL2 PFD1
	CCM_CBCMR_TRACE_CLK_SEL_TRACE_CLK_SEL_3 = 0x3
	// Position of PRE_PERIPH_CLK_SEL field.
	CCM_CBCMR_PRE_PERIPH_CLK_SEL_Pos = 0x12
	// Bit mask of PRE_PERIPH_CLK_SEL field.
	CCM_CBCMR_PRE_PERIPH_CLK_SEL_Msk = 0xc0000
	// derive clock from PLL2
	CCM_CBCMR_PRE_PERIPH_CLK_SEL_PRE_PERIPH_CLK_SEL_0 = 0x0
	// derive clock from PLL3 PFD3
	CCM_CBCMR_PRE_PERIPH_CLK_SEL_PRE_PERIPH_CLK_SEL_1 = 0x1
	// derive clock from PLL2 PFD3
	CCM_CBCMR_PRE_PERIPH_CLK_SEL_PRE_PERIPH_CLK_SEL_2 = 0x2
	// derive clock from PLL6
	CCM_CBCMR_PRE_PERIPH_CLK_SEL_PRE_PERIPH_CLK_SEL_3 = 0x3
	// Position of LPSPI_PODF field.
	CCM_CBCMR_LPSPI_PODF_Pos = 0x1a
	// Bit mask of LPSPI_PODF field.
	CCM_CBCMR_LPSPI_PODF_Msk = 0x3c000000
	// divide by 1
	CCM_CBCMR_LPSPI_PODF_LPSPI_PODF_0 = 0x0
	// divide by 2
	CCM_CBCMR_LPSPI_PODF_LPSPI_PODF_1 = 0x1
	// divide by 3
	CCM_CBCMR_LPSPI_PODF_LPSPI_PODF_2 = 0x2
	// divide by 4
	CCM_CBCMR_LPSPI_PODF_LPSPI_PODF_3 = 0x3
	// divide by 5
	CCM_CBCMR_LPSPI_PODF_LPSPI_PODF_4 = 0x4
	// divide by 6
	CCM_CBCMR_LPSPI_PODF_LPSPI_PODF_5 = 0x5
	// divide by 7
	CCM_CBCMR_LPSPI_PODF_LPSPI_PODF_6 = 0x6
	// divide by 8
	CCM_CBCMR_LPSPI_PODF_LPSPI_PODF_7 = 0x7
	// divide by 9
	CCM_CBCMR_LPSPI_PODF_LPSPI_PODF_8 = 0x8
	// divide by 10
	CCM_CBCMR_LPSPI_PODF_LPSPI_PODF_9 = 0x9
	// divide by 11
	CCM_CBCMR_LPSPI_PODF_LPSPI_PODF_10 = 0xa
	// divide by 12
	CCM_CBCMR_LPSPI_PODF_LPSPI_PODF_11 = 0xb
	// divide by 13
	CCM_CBCMR_LPSPI_PODF_LPSPI_PODF_12 = 0xc
	// divide by 14
	CCM_CBCMR_LPSPI_PODF_LPSPI_PODF_13 = 0xd
	// divide by 15
	CCM_CBCMR_LPSPI_PODF_LPSPI_PODF_14 = 0xe
	// divide by 16
	CCM_CBCMR_LPSPI_PODF_LPSPI_PODF_15 = 0xf

	// CSCMR1: CCM Serial Clock Multiplexer Register 1
	// Position of PERCLK_PODF field.
	CCM_CSCMR1_PERCLK_PODF_Pos = 0x0
	// Bit mask of PERCLK_PODF field.
	CCM_CSCMR1_PERCLK_PODF_Msk = 0x3f
	// Divide by 1
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_1 = 0x0
	// Divide by 2
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_2 = 0x1
	// Divide by 3
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_3 = 0x2
	// Divide by 4
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_4 = 0x3
	// Divide by 5
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_5 = 0x4
	// Divide by 6
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_6 = 0x5
	// Divide by 7
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_7 = 0x6
	// Divide by 8
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_8 = 0x7
	// Divide by 9
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_9 = 0x8
	// Divide by 10
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_10 = 0x9
	// Divide by 11
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_11 = 0xa
	// Divide by 12
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_12 = 0xb
	// Divide by 13
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_13 = 0xc
	// Divide by 14
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_14 = 0xd
	// Divide by 15
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_15 = 0xe
	// Divide by 16
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_16 = 0xf
	// Divide by 17
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_17 = 0x10
	// Divide by 18
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_18 = 0x11
	// Divide by 19
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_19 = 0x12
	// Divide by 20
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_20 = 0x13
	// Divide by 21
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_21 = 0x14
	// Divide by 22
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_22 = 0x15
	// Divide by 23
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_23 = 0x16
	// Divide by 24
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_24 = 0x17
	// Divide by 25
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_25 = 0x18
	// Divide by 26
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_26 = 0x19
	// Divide by 27
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_27 = 0x1a
	// Divide by 28
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_28 = 0x1b
	// Divide by 29
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_29 = 0x1c
	// Divide by 30
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_30 = 0x1d
	// Divide by 31
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_31 = 0x1e
	// Divide by 32
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_32 = 0x1f
	// Divide by 33
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_33 = 0x20
	// Divide by 34
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_34 = 0x21
	// Divide by 35
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_35 = 0x22
	// Divide by 36
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_36 = 0x23
	// Divide by 37
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_37 = 0x24
	// Divide by 38
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_38 = 0x25
	// Divide by 39
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_39 = 0x26
	// Divide by 40
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_40 = 0x27
	// Divide by 41
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_41 = 0x28
	// Divide by 42
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_42 = 0x29
	// Divide by 43
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_43 = 0x2a
	// Divide by 44
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_44 = 0x2b
	// Divide by 45
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_45 = 0x2c
	// Divide by 46
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_46 = 0x2d
	// Divide by 47
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_47 = 0x2e
	// Divide by 48
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_48 = 0x2f
	// Divide by 49
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_49 = 0x30
	// Divide by 50
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_50 = 0x31
	// Divide by 51
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_51 = 0x32
	// Divide by 52
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_52 = 0x33
	// Divide by 53
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_53 = 0x34
	// Divide by 54
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_54 = 0x35
	// Divide by 55
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_55 = 0x36
	// Divide by 56
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_56 = 0x37
	// Divide by 57
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_57 = 0x38
	// Divide by 58
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_58 = 0x39
	// Divide by 59
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_59 = 0x3a
	// Divide by 60
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_60 = 0x3b
	// Divide by 61
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_61 = 0x3c
	// Divide by 62
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_62 = 0x3d
	// Divide by 63
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_63 = 0x3e
	// Divide by 64
	CCM_CSCMR1_PERCLK_PODF_DIVIDE_64 = 0x3f
	// Position of PERCLK_CLK_SEL field.
	CCM_CSCMR1_PERCLK_CLK_SEL_Pos = 0x6
	// Bit mask of PERCLK_CLK_SEL field.
	CCM_CSCMR1_PERCLK_CLK_SEL_Msk = 0x40
	// Bit PERCLK_CLK_SEL.
	CCM_CSCMR1_PERCLK_CLK_SEL = 0x40
	// derive clock from ipg clk root
	CCM_CSCMR1_PERCLK_CLK_SEL_PERCLK_CLK_SEL_0 = 0x0
	// derive clock from osc_clk
	CCM_CSCMR1_PERCLK_CLK_SEL_PERCLK_CLK_SEL_1 = 0x1
	// Position of SAI1_CLK_SEL field.
	CCM_CSCMR1_SAI1_CLK_SEL_Pos = 0xa
	// Bit mask of SAI1_CLK_SEL field.
	CCM_CSCMR1_SAI1_CLK_SEL_Msk = 0xc00
	// derive clock from PLL3 PFD2
	CCM_CSCMR1_SAI1_CLK_SEL_SAI1_CLK_SEL_0 = 0x0
	// derive from pll3_sw_clk
	CCM_CSCMR1_SAI1_CLK_SEL_SAI1_CLK_SEL_1 = 0x1
	// derive clock from PLL4
	CCM_CSCMR1_SAI1_CLK_SEL_SAI1_CLK_SEL_2 = 0x2
	// Position of SAI3_CLK_SEL field.
	CCM_CSCMR1_SAI3_CLK_SEL_Pos = 0xe
	// Bit mask of SAI3_CLK_SEL field.
	CCM_CSCMR1_SAI3_CLK_SEL_Msk = 0xc000
	// derive clock from PLL3 PFD2
	CCM_CSCMR1_SAI3_CLK_SEL_SAI3_CLK_SEL_0 = 0x0
	// derive from pll3_sw_clk
	CCM_CSCMR1_SAI3_CLK_SEL_SAI3_CLK_SEL_1 = 0x1
	// derive clock from PLL4
	CCM_CSCMR1_SAI3_CLK_SEL_SAI3_CLK_SEL_2 = 0x2
	// Position of FLEXSPI_PODF field.
	CCM_CSCMR1_FLEXSPI_PODF_Pos = 0x17
	// Bit mask of FLEXSPI_PODF field.
	CCM_CSCMR1_FLEXSPI_PODF_Msk = 0x3800000
	// divide by 1
	CCM_CSCMR1_FLEXSPI_PODF_FLEXSPI_PODF_0 = 0x0
	// divide by 2
	CCM_CSCMR1_FLEXSPI_PODF_FLEXSPI_PODF_1 = 0x1
	// divide by 3
	CCM_CSCMR1_FLEXSPI_PODF_FLEXSPI_PODF_2 = 0x2
	// divide by 4
	CCM_CSCMR1_FLEXSPI_PODF_FLEXSPI_PODF_3 = 0x3
	// divide by 5
	CCM_CSCMR1_FLEXSPI_PODF_FLEXSPI_PODF_4 = 0x4
	// divide by 6
	CCM_CSCMR1_FLEXSPI_PODF_FLEXSPI_PODF_5 = 0x5
	// divide by 7
	CCM_CSCMR1_FLEXSPI_PODF_FLEXSPI_PODF_6 = 0x6
	// divide by 8
	CCM_CSCMR1_FLEXSPI_PODF_FLEXSPI_PODF_7 = 0x7
	// Position of FLEXSPI_CLK_SEL field.
	CCM_CSCMR1_FLEXSPI_CLK_SEL_Pos = 0x1d
	// Bit mask of FLEXSPI_CLK_SEL field.
	CCM_CSCMR1_FLEXSPI_CLK_SEL_Msk = 0x60000000
	// derive clock from PLL2
	CCM_CSCMR1_FLEXSPI_CLK_SEL_FLEXSPI_CLK_SEL_0 = 0x0
	// derive clock from pll3_sw_clk
	CCM_CSCMR1_FLEXSPI_CLK_SEL_FLEXSPI_CLK_SEL_1 = 0x1
	// derive clock from PLL2 PFD2
	CCM_CSCMR1_FLEXSPI_CLK_SEL_FLEXSPI_CLK_SEL_2 = 0x2
	// derive clock from PLL3 PFD0
	CCM_CSCMR1_FLEXSPI_CLK_SEL_FLEXSPI_CLK_SEL_3 = 0x3
	// Position of FLEXSPI_CLK_SRC field.
	CCM_CSCMR1_FLEXSPI_CLK_SRC_Pos = 0x1f
	// Bit mask of FLEXSPI_CLK_SRC field.
	CCM_CSCMR1_FLEXSPI_CLK_SRC_Msk = 0x80000000
	// Bit FLEXSPI_CLK_SRC.
	CCM_CSCMR1_FLEXSPI_CLK_SRC = 0x80000000
	// derive clock selected by CCM_CSCMR1[FLEXSPI_CLK_SEL]
	CCM_CSCMR1_FLEXSPI_CLK_SRC_FLEXSPI_CLK_SRC_0 = 0x0
	// derive clock selected by CCM_CBCMR[PERIPH_CLK2_ SEL]
	CCM_CSCMR1_FLEXSPI_CLK_SRC_FLEXSPI_CLK_SRC_1 = 0x1

	// CSCMR2: CCM Serial Clock Multiplexer Register 2
	// Position of FLEXIO1_CLK_SEL field.
	CCM_CSCMR2_FLEXIO1_CLK_SEL_Pos = 0x13
	// Bit mask of FLEXIO1_CLK_SEL field.
	CCM_CSCMR2_FLEXIO1_CLK_SEL_Msk = 0x180000
	// derive clock from PLL4 divided clock
	CCM_CSCMR2_FLEXIO1_CLK_SEL_FLEXIO1_CLK_SEL_0 = 0x0
	// derive clock from PLL3 PFD2 clock
	CCM_CSCMR2_FLEXIO1_CLK_SEL_FLEXIO1_CLK_SEL_1 = 0x1
	// derive from PLL2
	CCM_CSCMR2_FLEXIO1_CLK_SEL_FLEXIO1_CLK_SEL_2 = 0x2
	// derive clock from pll3_sw_clk
	CCM_CSCMR2_FLEXIO1_CLK_SEL_FLEXIO1_CLK_SEL_3 = 0x3
	// Position of ADC_ACLK_PODF field.
	CCM_CSCMR2_ADC_ACLK_PODF_Pos = 0x1b
	// Bit mask of ADC_ACLK_PODF field.
	CCM_CSCMR2_ADC_ACLK_PODF_Msk = 0x78000000
	// pll3_sw_clk / 8
	CCM_CSCMR2_ADC_ACLK_PODF_ADC_ACLK_PODF_7 = 0x7
	// pll3_sw_clk / 12
	CCM_CSCMR2_ADC_ACLK_PODF_ADC_ACLK_PODF_11 = 0xb
	// pll3_sw_clk / 16
	CCM_CSCMR2_ADC_ACLK_PODF_ADC_ACLK_PODF_15 = 0xf
	// Position of ADC_ACLK_EN field.
	CCM_CSCMR2_ADC_ACLK_EN_Pos = 0x1f
	// Bit mask of ADC_ACLK_EN field.
	CCM_CSCMR2_ADC_ACLK_EN_Msk = 0x80000000
	// Bit ADC_ACLK_EN.
	CCM_CSCMR2_ADC_ACLK_EN = 0x80000000
	// ADC alt_clk source is disabled
	CCM_CSCMR2_ADC_ACLK_EN_ADC_ACLK_EN_0 = 0x0
	// ADC alt_clk source is enabled
	CCM_CSCMR2_ADC_ACLK_EN_ADC_ACLK_EN_1 = 0x1

	// CSCDR1: CCM Serial Clock Divider Register 1
	// Position of UART_CLK_PODF field.
	CCM_CSCDR1_UART_CLK_PODF_Pos = 0x0
	// Bit mask of UART_CLK_PODF field.
	CCM_CSCDR1_UART_CLK_PODF_Msk = 0x3f
	// Divide by 1
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_1 = 0x0
	// Divide by 2
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_2 = 0x1
	// Divide by 3
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_3 = 0x2
	// Divide by 4
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_4 = 0x3
	// Divide by 5
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_5 = 0x4
	// Divide by 6
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_6 = 0x5
	// Divide by 7
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_7 = 0x6
	// Divide by 8
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_8 = 0x7
	// Divide by 9
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_9 = 0x8
	// Divide by 10
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_10 = 0x9
	// Divide by 11
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_11 = 0xa
	// Divide by 12
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_12 = 0xb
	// Divide by 13
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_13 = 0xc
	// Divide by 14
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_14 = 0xd
	// Divide by 15
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_15 = 0xe
	// Divide by 16
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_16 = 0xf
	// Divide by 17
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_17 = 0x10
	// Divide by 18
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_18 = 0x11
	// Divide by 19
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_19 = 0x12
	// Divide by 20
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_20 = 0x13
	// Divide by 21
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_21 = 0x14
	// Divide by 22
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_22 = 0x15
	// Divide by 23
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_23 = 0x16
	// Divide by 24
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_24 = 0x17
	// Divide by 25
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_25 = 0x18
	// Divide by 26
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_26 = 0x19
	// Divide by 27
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_27 = 0x1a
	// Divide by 28
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_28 = 0x1b
	// Divide by 29
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_29 = 0x1c
	// Divide by 30
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_30 = 0x1d
	// Divide by 31
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_31 = 0x1e
	// Divide by 32
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_32 = 0x1f
	// Divide by 33
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_33 = 0x20
	// Divide by 34
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_34 = 0x21
	// Divide by 35
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_35 = 0x22
	// Divide by 36
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_36 = 0x23
	// Divide by 37
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_37 = 0x24
	// Divide by 38
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_38 = 0x25
	// Divide by 39
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_39 = 0x26
	// Divide by 40
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_40 = 0x27
	// Divide by 41
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_41 = 0x28
	// Divide by 42
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_42 = 0x29
	// Divide by 43
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_43 = 0x2a
	// Divide by 44
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_44 = 0x2b
	// Divide by 45
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_45 = 0x2c
	// Divide by 46
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_46 = 0x2d
	// Divide by 47
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_47 = 0x2e
	// Divide by 48
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_48 = 0x2f
	// Divide by 49
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_49 = 0x30
	// Divide by 50
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_50 = 0x31
	// Divide by 51
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_51 = 0x32
	// Divide by 52
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_52 = 0x33
	// Divide by 53
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_53 = 0x34
	// Divide by 54
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_54 = 0x35
	// Divide by 55
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_55 = 0x36
	// Divide by 56
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_56 = 0x37
	// Divide by 57
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_57 = 0x38
	// Divide by 58
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_58 = 0x39
	// Divide by 59
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_59 = 0x3a
	// Divide by 60
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_60 = 0x3b
	// Divide by 61
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_61 = 0x3c
	// Divide by 62
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_62 = 0x3d
	// Divide by 63
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_63 = 0x3e
	// Divide by 64
	CCM_CSCDR1_UART_CLK_PODF_DIVIDE_64 = 0x3f
	// Position of UART_CLK_SEL field.
	CCM_CSCDR1_UART_CLK_SEL_Pos = 0x6
	// Bit mask of UART_CLK_SEL field.
	CCM_CSCDR1_UART_CLK_SEL_Msk = 0xc0
	// derive clock from pll3_80m
	CCM_CSCDR1_UART_CLK_SEL_UART_CLK_SEL_0 = 0x0
	// derive clock from osc_clk
	CCM_CSCDR1_UART_CLK_SEL_UART_CLK_SEL_1 = 0x1
	// derive clock from per_clk_root
	CCM_CSCDR1_UART_CLK_SEL_UART_CLK_SEL_2 = 0x2
	// Position of TRACE_PODF field.
	CCM_CSCDR1_TRACE_PODF_Pos = 0x19
	// Bit mask of TRACE_PODF field.
	CCM_CSCDR1_TRACE_PODF_Msk = 0x1e000000
	// divide by 1
	CCM_CSCDR1_TRACE_PODF_TRACE_PODF_0 = 0x0
	// divide by 2
	CCM_CSCDR1_TRACE_PODF_TRACE_PODF_1 = 0x1
	// divide by 3
	CCM_CSCDR1_TRACE_PODF_TRACE_PODF_2 = 0x2
	// divide by 4
	CCM_CSCDR1_TRACE_PODF_TRACE_PODF_3 = 0x3
	// divide by 5
	CCM_CSCDR1_TRACE_PODF_TRACE_PODF_4 = 0x4
	// divide by 6
	CCM_CSCDR1_TRACE_PODF_TRACE_PODF_5 = 0x5
	// divide by 7
	CCM_CSCDR1_TRACE_PODF_TRACE_PODF_6 = 0x6
	// divide by 8
	CCM_CSCDR1_TRACE_PODF_TRACE_PODF_7 = 0x7
	// divide by 9
	CCM_CSCDR1_TRACE_PODF_TRACE_PODF_8 = 0x8
	// divide by 10
	CCM_CSCDR1_TRACE_PODF_TRACE_PODF_9 = 0x9
	// divide by 11
	CCM_CSCDR1_TRACE_PODF_TRACE_PODF_10 = 0xa
	// divide by 12
	CCM_CSCDR1_TRACE_PODF_TRACE_PODF_11 = 0xb
	// divide by 13
	CCM_CSCDR1_TRACE_PODF_TRACE_PODF_12 = 0xc
	// divide by 14
	CCM_CSCDR1_TRACE_PODF_TRACE_PODF_13 = 0xd
	// divide by 15
	CCM_CSCDR1_TRACE_PODF_TRACE_PODF_14 = 0xe
	// divide by 16
	CCM_CSCDR1_TRACE_PODF_TRACE_PODF_15 = 0xf

	// CS1CDR: CCM Clock Divider Register
	// Position of SAI1_CLK_PODF field.
	CCM_CS1CDR_SAI1_CLK_PODF_Pos = 0x0
	// Bit mask of SAI1_CLK_PODF field.
	CCM_CS1CDR_SAI1_CLK_PODF_Msk = 0x3f
	// Divide by 1
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_1 = 0x0
	// Divide by 2
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_2 = 0x1
	// Divide by 3
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_3 = 0x2
	// Divide by 4
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_4 = 0x3
	// Divide by 5
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_5 = 0x4
	// Divide by 6
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_6 = 0x5
	// Divide by 7
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_7 = 0x6
	// Divide by 8
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_8 = 0x7
	// Divide by 9
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_9 = 0x8
	// Divide by 10
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_10 = 0x9
	// Divide by 11
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_11 = 0xa
	// Divide by 12
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_12 = 0xb
	// Divide by 13
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_13 = 0xc
	// Divide by 14
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_14 = 0xd
	// Divide by 15
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_15 = 0xe
	// Divide by 16
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_16 = 0xf
	// Divide by 17
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_17 = 0x10
	// Divide by 18
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_18 = 0x11
	// Divide by 19
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_19 = 0x12
	// Divide by 20
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_20 = 0x13
	// Divide by 21
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_21 = 0x14
	// Divide by 22
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_22 = 0x15
	// Divide by 23
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_23 = 0x16
	// Divide by 24
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_24 = 0x17
	// Divide by 25
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_25 = 0x18
	// Divide by 26
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_26 = 0x19
	// Divide by 27
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_27 = 0x1a
	// Divide by 28
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_28 = 0x1b
	// Divide by 29
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_29 = 0x1c
	// Divide by 30
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_30 = 0x1d
	// Divide by 31
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_31 = 0x1e
	// Divide by 32
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_32 = 0x1f
	// Divide by 33
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_33 = 0x20
	// Divide by 34
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_34 = 0x21
	// Divide by 35
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_35 = 0x22
	// Divide by 36
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_36 = 0x23
	// Divide by 37
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_37 = 0x24
	// Divide by 38
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_38 = 0x25
	// Divide by 39
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_39 = 0x26
	// Divide by 40
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_40 = 0x27
	// Divide by 41
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_41 = 0x28
	// Divide by 42
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_42 = 0x29
	// Divide by 43
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_43 = 0x2a
	// Divide by 44
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_44 = 0x2b
	// Divide by 45
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_45 = 0x2c
	// Divide by 46
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_46 = 0x2d
	// Divide by 47
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_47 = 0x2e
	// Divide by 48
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_48 = 0x2f
	// Divide by 49
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_49 = 0x30
	// Divide by 50
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_50 = 0x31
	// Divide by 51
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_51 = 0x32
	// Divide by 52
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_52 = 0x33
	// Divide by 53
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_53 = 0x34
	// Divide by 54
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_54 = 0x35
	// Divide by 55
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_55 = 0x36
	// Divide by 56
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_56 = 0x37
	// Divide by 57
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_57 = 0x38
	// Divide by 58
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_58 = 0x39
	// Divide by 59
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_59 = 0x3a
	// Divide by 60
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_60 = 0x3b
	// Divide by 61
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_61 = 0x3c
	// Divide by 62
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_62 = 0x3d
	// Divide by 63
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_63 = 0x3e
	// Divide by 64
	CCM_CS1CDR_SAI1_CLK_PODF_DIVIDE_64 = 0x3f
	// Position of SAI1_CLK_PRED field.
	CCM_CS1CDR_SAI1_CLK_PRED_Pos = 0x6
	// Bit mask of SAI1_CLK_PRED field.
	CCM_CS1CDR_SAI1_CLK_PRED_Msk = 0x1c0
	// divide by 1
	CCM_CS1CDR_SAI1_CLK_PRED_SAI1_CLK_PRED_0 = 0x0
	// divide by 2
	CCM_CS1CDR_SAI1_CLK_PRED_SAI1_CLK_PRED_1 = 0x1
	// divide by 3
	CCM_CS1CDR_SAI1_CLK_PRED_SAI1_CLK_PRED_2 = 0x2
	// divide by 4
	CCM_CS1CDR_SAI1_CLK_PRED_SAI1_CLK_PRED_3 = 0x3
	// divide by 5
	CCM_CS1CDR_SAI1_CLK_PRED_SAI1_CLK_PRED_4 = 0x4
	// divide by 6
	CCM_CS1CDR_SAI1_CLK_PRED_SAI1_CLK_PRED_5 = 0x5
	// divide by 7
	CCM_CS1CDR_SAI1_CLK_PRED_SAI1_CLK_PRED_6 = 0x6
	// divide by 8
	CCM_CS1CDR_SAI1_CLK_PRED_SAI1_CLK_PRED_7 = 0x7
	// Position of FLEXIO1_CLK_PRED field.
	CCM_CS1CDR_FLEXIO1_CLK_PRED_Pos = 0x9
	// Bit mask of FLEXIO1_CLK_PRED field.
	CCM_CS1CDR_FLEXIO1_CLK_PRED_Msk = 0xe00
	// divide by 1
	CCM_CS1CDR_FLEXIO1_CLK_PRED_FLEXIO1_CLK_PRED_0 = 0x0
	// divide by 2
	CCM_CS1CDR_FLEXIO1_CLK_PRED_FLEXIO1_CLK_PRED_1 = 0x1
	// divide by 3
	CCM_CS1CDR_FLEXIO1_CLK_PRED_FLEXIO1_CLK_PRED_2 = 0x2
	// divide by 4
	CCM_CS1CDR_FLEXIO1_CLK_PRED_FLEXIO1_CLK_PRED_3 = 0x3
	// divide by 5
	CCM_CS1CDR_FLEXIO1_CLK_PRED_FLEXIO1_CLK_PRED_4 = 0x4
	// divide by 6
	CCM_CS1CDR_FLEXIO1_CLK_PRED_FLEXIO1_CLK_PRED_5 = 0x5
	// divide by 7
	CCM_CS1CDR_FLEXIO1_CLK_PRED_FLEXIO1_CLK_PRED_6 = 0x6
	// divide by 8
	CCM_CS1CDR_FLEXIO1_CLK_PRED_FLEXIO1_CLK_PRED_7 = 0x7
	// Position of SAI3_CLK_PODF field.
	CCM_CS1CDR_SAI3_CLK_PODF_Pos = 0x10
	// Bit mask of SAI3_CLK_PODF field.
	CCM_CS1CDR_SAI3_CLK_PODF_Msk = 0x3f0000
	// Divide by 1
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_1 = 0x0
	// Divide by 2
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_2 = 0x1
	// Divide by 3
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_3 = 0x2
	// Divide by 4
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_4 = 0x3
	// Divide by 5
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_5 = 0x4
	// Divide by 6
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_6 = 0x5
	// Divide by 7
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_7 = 0x6
	// Divide by 8
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_8 = 0x7
	// Divide by 9
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_9 = 0x8
	// Divide by 10
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_10 = 0x9
	// Divide by 11
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_11 = 0xa
	// Divide by 12
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_12 = 0xb
	// Divide by 13
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_13 = 0xc
	// Divide by 14
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_14 = 0xd
	// Divide by 15
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_15 = 0xe
	// Divide by 16
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_16 = 0xf
	// Divide by 17
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_17 = 0x10
	// Divide by 18
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_18 = 0x11
	// Divide by 19
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_19 = 0x12
	// Divide by 20
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_20 = 0x13
	// Divide by 21
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_21 = 0x14
	// Divide by 22
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_22 = 0x15
	// Divide by 23
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_23 = 0x16
	// Divide by 24
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_24 = 0x17
	// Divide by 25
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_25 = 0x18
	// Divide by 26
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_26 = 0x19
	// Divide by 27
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_27 = 0x1a
	// Divide by 28
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_28 = 0x1b
	// Divide by 29
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_29 = 0x1c
	// Divide by 30
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_30 = 0x1d
	// Divide by 31
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_31 = 0x1e
	// Divide by 32
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_32 = 0x1f
	// Divide by 33
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_33 = 0x20
	// Divide by 34
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_34 = 0x21
	// Divide by 35
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_35 = 0x22
	// Divide by 36
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_36 = 0x23
	// Divide by 37
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_37 = 0x24
	// Divide by 38
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_38 = 0x25
	// Divide by 39
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_39 = 0x26
	// Divide by 40
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_40 = 0x27
	// Divide by 41
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_41 = 0x28
	// Divide by 42
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_42 = 0x29
	// Divide by 43
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_43 = 0x2a
	// Divide by 44
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_44 = 0x2b
	// Divide by 45
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_45 = 0x2c
	// Divide by 46
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_46 = 0x2d
	// Divide by 47
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_47 = 0x2e
	// Divide by 48
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_48 = 0x2f
	// Divide by 49
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_49 = 0x30
	// Divide by 50
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_50 = 0x31
	// Divide by 51
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_51 = 0x32
	// Divide by 52
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_52 = 0x33
	// Divide by 53
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_53 = 0x34
	// Divide by 54
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_54 = 0x35
	// Divide by 55
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_55 = 0x36
	// Divide by 56
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_56 = 0x37
	// Divide by 57
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_57 = 0x38
	// Divide by 58
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_58 = 0x39
	// Divide by 59
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_59 = 0x3a
	// Divide by 60
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_60 = 0x3b
	// Divide by 61
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_61 = 0x3c
	// Divide by 62
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_62 = 0x3d
	// Divide by 63
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_63 = 0x3e
	// Divide by 64
	CCM_CS1CDR_SAI3_CLK_PODF_DIVIDE_64 = 0x3f
	// Position of SAI3_CLK_PRED field.
	CCM_CS1CDR_SAI3_CLK_PRED_Pos = 0x16
	// Bit mask of SAI3_CLK_PRED field.
	CCM_CS1CDR_SAI3_CLK_PRED_Msk = 0x1c00000
	// divide by 1
	CCM_CS1CDR_SAI3_CLK_PRED_SAI3_CLK_PRED_0 = 0x0
	// divide by 2
	CCM_CS1CDR_SAI3_CLK_PRED_SAI3_CLK_PRED_1 = 0x1
	// divide by 3
	CCM_CS1CDR_SAI3_CLK_PRED_SAI3_CLK_PRED_2 = 0x2
	// divide by 4
	CCM_CS1CDR_SAI3_CLK_PRED_SAI3_CLK_PRED_3 = 0x3
	// divide by 5
	CCM_CS1CDR_SAI3_CLK_PRED_SAI3_CLK_PRED_4 = 0x4
	// divide by 6
	CCM_CS1CDR_SAI3_CLK_PRED_SAI3_CLK_PRED_5 = 0x5
	// divide by 7
	CCM_CS1CDR_SAI3_CLK_PRED_SAI3_CLK_PRED_6 = 0x6
	// divide by 8
	CCM_CS1CDR_SAI3_CLK_PRED_SAI3_CLK_PRED_7 = 0x7
	// Position of FLEXIO1_CLK_PODF field.
	CCM_CS1CDR_FLEXIO1_CLK_PODF_Pos = 0x19
	// Bit mask of FLEXIO1_CLK_PODF field.
	CCM_CS1CDR_FLEXIO1_CLK_PODF_Msk = 0x1e000000
	// Divide by 1
	CCM_CS1CDR_FLEXIO1_CLK_PODF_DIVIDE_1 = 0x0
	// Divide by 2
	CCM_CS1CDR_FLEXIO1_CLK_PODF_DIVIDE_2 = 0x1
	// Divide by 3
	CCM_CS1CDR_FLEXIO1_CLK_PODF_DIVIDE_3 = 0x2
	// Divide by 4
	CCM_CS1CDR_FLEXIO1_CLK_PODF_DIVIDE_4 = 0x3
	// Divide by 5
	CCM_CS1CDR_FLEXIO1_CLK_PODF_DIVIDE_5 = 0x4
	// Divide by 6
	CCM_CS1CDR_FLEXIO1_CLK_PODF_DIVIDE_6 = 0x5
	// Divide by 7
	CCM_CS1CDR_FLEXIO1_CLK_PODF_DIVIDE_7 = 0x6
	// Divide by 8
	CCM_CS1CDR_FLEXIO1_CLK_PODF_DIVIDE_8 = 0x7
	// Divide by 9
	CCM_CS1CDR_FLEXIO1_CLK_PODF_DIVIDE_9 = 0x8
	// Divide by 10
	CCM_CS1CDR_FLEXIO1_CLK_PODF_DIVIDE_10 = 0x9
	// Divide by 11
	CCM_CS1CDR_FLEXIO1_CLK_PODF_DIVIDE_11 = 0xa
	// Divide by 12
	CCM_CS1CDR_FLEXIO1_CLK_PODF_DIVIDE_12 = 0xb
	// Divide by 13
	CCM_CS1CDR_FLEXIO1_CLK_PODF_DIVIDE_13 = 0xc
	// Divide by 14
	CCM_CS1CDR_FLEXIO1_CLK_PODF_DIVIDE_14 = 0xd
	// Divide by 15
	CCM_CS1CDR_FLEXIO1_CLK_PODF_DIVIDE_15 = 0xe
	// Divide by 16
	CCM_CS1CDR_FLEXIO1_CLK_PODF_DIVIDE_16 = 0xf

	// CDCDR: CCM D1 Clock Divider Register
	// Position of SPDIF0_CLK_SEL field.
	CCM_CDCDR_SPDIF0_CLK_SEL_Pos = 0x14
	// Bit mask of SPDIF0_CLK_SEL field.
	CCM_CDCDR_SPDIF0_CLK_SEL_Msk = 0x300000
	// derive clock from PLL4
	CCM_CDCDR_SPDIF0_CLK_SEL_SPDIF0_CLK_SEL_0 = 0x0
	// derive clock from PLL3 PFD2
	CCM_CDCDR_SPDIF0_CLK_SEL_SPDIF0_CLK_SEL_1 = 0x1
	// derive clock from pll3_sw_clk
	CCM_CDCDR_SPDIF0_CLK_SEL_SPDIF0_CLK_SEL_3 = 0x3
	// Position of SPDIF0_CLK_PODF field.
	CCM_CDCDR_SPDIF0_CLK_PODF_Pos = 0x16
	// Bit mask of SPDIF0_CLK_PODF field.
	CCM_CDCDR_SPDIF0_CLK_PODF_Msk = 0x1c00000
	// Divide by 1
	CCM_CDCDR_SPDIF0_CLK_PODF_DIVIDE_1 = 0x0
	// Divide by 2
	CCM_CDCDR_SPDIF0_CLK_PODF_DIVIDE_2 = 0x1
	// Divide by 3
	CCM_CDCDR_SPDIF0_CLK_PODF_DIVIDE_3 = 0x2
	// Divide by 4
	CCM_CDCDR_SPDIF0_CLK_PODF_DIVIDE_4 = 0x3
	// Divide by 5
	CCM_CDCDR_SPDIF0_CLK_PODF_DIVIDE_5 = 0x4
	// Divide by 6
	CCM_CDCDR_SPDIF0_CLK_PODF_DIVIDE_6 = 0x5
	// Divide by 7
	CCM_CDCDR_SPDIF0_CLK_PODF_DIVIDE_7 = 0x6
	// Divide by 8
	CCM_CDCDR_SPDIF0_CLK_PODF_DIVIDE_8 = 0x7
	// Position of SPDIF0_CLK_PRED field.
	CCM_CDCDR_SPDIF0_CLK_PRED_Pos = 0x19
	// Bit mask of SPDIF0_CLK_PRED field.
	CCM_CDCDR_SPDIF0_CLK_PRED_Msk = 0xe000000
	// Divide by 1
	CCM_CDCDR_SPDIF0_CLK_PRED_DIVIDE_1 = 0x0
	// Divide by 2
	CCM_CDCDR_SPDIF0_CLK_PRED_DIVIDE_2 = 0x1
	// Divide by 3
	CCM_CDCDR_SPDIF0_CLK_PRED_DIVIDE_3 = 0x2
	// Divide by 4
	CCM_CDCDR_SPDIF0_CLK_PRED_DIVIDE_4 = 0x3
	// Divide by 5
	CCM_CDCDR_SPDIF0_CLK_PRED_DIVIDE_5 = 0x4
	// Divide by 6
	CCM_CDCDR_SPDIF0_CLK_PRED_DIVIDE_6 = 0x5
	// Divide by 7
	CCM_CDCDR_SPDIF0_CLK_PRED_DIVIDE_7 = 0x6
	// Divide by 8
	CCM_CDCDR_SPDIF0_CLK_PRED_DIVIDE_8 = 0x7

	// CSCDR2: CCM Serial Clock Divider Register 2
	// Position of LPI2C_CLK_SEL field.
	CCM_CSCDR2_LPI2C_CLK_SEL_Pos = 0x12
	// Bit mask of LPI2C_CLK_SEL field.
	CCM_CSCDR2_LPI2C_CLK_SEL_Msk = 0x40000
	// Bit LPI2C_CLK_SEL.
	CCM_CSCDR2_LPI2C_CLK_SEL = 0x40000
	// derive clock from pll3_60m
	CCM_CSCDR2_LPI2C_CLK_SEL_LPI2C_CLK_SEL_0 = 0x0
	// derive clock from osc_clk
	CCM_CSCDR2_LPI2C_CLK_SEL_LPI2C_CLK_SEL_1 = 0x1
	// Position of LPI2C_CLK_PODF field.
	CCM_CSCDR2_LPI2C_CLK_PODF_Pos = 0x13
	// Bit mask of LPI2C_CLK_PODF field.
	CCM_CSCDR2_LPI2C_CLK_PODF_Msk = 0x1f80000
	// Divide by 1
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_1 = 0x0
	// Divide by 2
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_2 = 0x1
	// Divide by 3
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_3 = 0x2
	// Divide by 4
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_4 = 0x3
	// Divide by 5
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_5 = 0x4
	// Divide by 6
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_6 = 0x5
	// Divide by 7
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_7 = 0x6
	// Divide by 8
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_8 = 0x7
	// Divide by 9
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_9 = 0x8
	// Divide by 10
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_10 = 0x9
	// Divide by 11
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_11 = 0xa
	// Divide by 12
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_12 = 0xb
	// Divide by 13
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_13 = 0xc
	// Divide by 14
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_14 = 0xd
	// Divide by 15
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_15 = 0xe
	// Divide by 16
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_16 = 0xf
	// Divide by 17
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_17 = 0x10
	// Divide by 18
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_18 = 0x11
	// Divide by 19
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_19 = 0x12
	// Divide by 20
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_20 = 0x13
	// Divide by 21
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_21 = 0x14
	// Divide by 22
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_22 = 0x15
	// Divide by 23
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_23 = 0x16
	// Divide by 24
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_24 = 0x17
	// Divide by 25
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_25 = 0x18
	// Divide by 26
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_26 = 0x19
	// Divide by 27
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_27 = 0x1a
	// Divide by 28
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_28 = 0x1b
	// Divide by 29
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_29 = 0x1c
	// Divide by 30
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_30 = 0x1d
	// Divide by 31
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_31 = 0x1e
	// Divide by 32
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_32 = 0x1f
	// Divide by 33
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_33 = 0x20
	// Divide by 34
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_34 = 0x21
	// Divide by 35
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_35 = 0x22
	// Divide by 36
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_36 = 0x23
	// Divide by 37
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_37 = 0x24
	// Divide by 38
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_38 = 0x25
	// Divide by 39
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_39 = 0x26
	// Divide by 40
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_40 = 0x27
	// Divide by 41
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_41 = 0x28
	// Divide by 42
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_42 = 0x29
	// Divide by 43
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_43 = 0x2a
	// Divide by 44
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_44 = 0x2b
	// Divide by 45
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_45 = 0x2c
	// Divide by 46
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_46 = 0x2d
	// Divide by 47
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_47 = 0x2e
	// Divide by 48
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_48 = 0x2f
	// Divide by 49
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_49 = 0x30
	// Divide by 50
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_50 = 0x31
	// Divide by 51
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_51 = 0x32
	// Divide by 52
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_52 = 0x33
	// Divide by 53
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_53 = 0x34
	// Divide by 54
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_54 = 0x35
	// Divide by 55
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_55 = 0x36
	// Divide by 56
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_56 = 0x37
	// Divide by 57
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_57 = 0x38
	// Divide by 58
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_58 = 0x39
	// Divide by 59
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_59 = 0x3a
	// Divide by 60
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_60 = 0x3b
	// Divide by 61
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_61 = 0x3c
	// Divide by 62
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_62 = 0x3d
	// Divide by 63
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_63 = 0x3e
	// Divide by 64
	CCM_CSCDR2_LPI2C_CLK_PODF_DIVIDE_64 = 0x3f

	// CDHIPR: CCM Divider Handshake In-Process Register
	// Position of AHB_PODF_BUSY field.
	CCM_CDHIPR_AHB_PODF_BUSY_Pos = 0x1
	// Bit mask of AHB_PODF_BUSY field.
	CCM_CDHIPR_AHB_PODF_BUSY_Msk = 0x2
	// Bit AHB_PODF_BUSY.
	CCM_CDHIPR_AHB_PODF_BUSY = 0x2
	// divider is not busy and its value represents the actual division.
	CCM_CDHIPR_AHB_PODF_BUSY_AHB_PODF_BUSY_0 = 0x0
	// divider is busy with handshake process with module. The value read in the divider represents the previous value of the division factor, and after the handshake the written value of the ahb_podf will be applied.
	CCM_CDHIPR_AHB_PODF_BUSY_AHB_PODF_BUSY_1 = 0x1
	// Position of FLEXSPI_PODF_BUSY field.
	CCM_CDHIPR_FLEXSPI_PODF_BUSY_Pos = 0x3
	// Bit mask of FLEXSPI_PODF_BUSY field.
	CCM_CDHIPR_FLEXSPI_PODF_BUSY_Msk = 0x8
	// Bit FLEXSPI_PODF_BUSY.
	CCM_CDHIPR_FLEXSPI_PODF_BUSY = 0x8
	// divider is not busy and its value represents the actual division.
	CCM_CDHIPR_FLEXSPI_PODF_BUSY_FLEXSPI_PODF_BUSY_0 = 0x0
	// divider is busy with handshake process with module. The value read in the divider represents the previous value of the division factor, and after the handshake the written value of the flexspi_podf will be applied.
	CCM_CDHIPR_FLEXSPI_PODF_BUSY_FLEXSPI_PODF_BUSY_1 = 0x1
	// Position of PERCLK_PODF_BUSY field.
	CCM_CDHIPR_PERCLK_PODF_BUSY_Pos = 0x4
	// Bit mask of PERCLK_PODF_BUSY field.
	CCM_CDHIPR_PERCLK_PODF_BUSY_Msk = 0x10
	// Bit PERCLK_PODF_BUSY.
	CCM_CDHIPR_PERCLK_PODF_BUSY = 0x10
	// divider is not busy and its value represents the actual division.
	CCM_CDHIPR_PERCLK_PODF_BUSY_PERCLK_PODF_BUSY_0 = 0x0
	// divider is busy with handshake process with module. The value read in the divider represents the previous value of the division factor, and after the handshake the written value of the perclk_podf will be applied.
	CCM_CDHIPR_PERCLK_PODF_BUSY_PERCLK_PODF_BUSY_1 = 0x1
	// Position of PERIPH_CLK_SEL_BUSY field.
	CCM_CDHIPR_PERIPH_CLK_SEL_BUSY_Pos = 0x5
	// Bit mask of PERIPH_CLK_SEL_BUSY field.
	CCM_CDHIPR_PERIPH_CLK_SEL_BUSY_Msk = 0x20
	// Bit PERIPH_CLK_SEL_BUSY.
	CCM_CDHIPR_PERIPH_CLK_SEL_BUSY = 0x20
	// mux is not busy and its value represents the actual division.
	CCM_CDHIPR_PERIPH_CLK_SEL_BUSY_PERIPH_CLK_SEL_BUSY_0 = 0x0
	// mux is busy with handshake process with module. The value read in the periph_clk_sel represents the previous value of select, and after the handshake periph_clk_sel value will be applied.
	CCM_CDHIPR_PERIPH_CLK_SEL_BUSY_PERIPH_CLK_SEL_BUSY_1 = 0x1

	// CLPCR: CCM Low Power Control Register
	// Position of LPM field.
	CCM_CLPCR_LPM_Pos = 0x0
	// Bit mask of LPM field.
	CCM_CLPCR_LPM_Msk = 0x3
	// Remain in run mode
	CCM_CLPCR_LPM_LPM_0 = 0x0
	// Transfer to wait mode
	CCM_CLPCR_LPM_LPM_1 = 0x1
	// Transfer to stop mode
	CCM_CLPCR_LPM_LPM_2 = 0x2
	// Position of ARM_CLK_DIS_ON_LPM field.
	CCM_CLPCR_ARM_CLK_DIS_ON_LPM_Pos = 0x5
	// Bit mask of ARM_CLK_DIS_ON_LPM field.
	CCM_CLPCR_ARM_CLK_DIS_ON_LPM_Msk = 0x20
	// Bit ARM_CLK_DIS_ON_LPM.
	CCM_CLPCR_ARM_CLK_DIS_ON_LPM = 0x20
	// ARM clock enabled on wait mode.
	CCM_CLPCR_ARM_CLK_DIS_ON_LPM_ARM_CLK_DIS_ON_LPM_0 = 0x0
	// ARM clock disabled on wait mode. .
	CCM_CLPCR_ARM_CLK_DIS_ON_LPM_ARM_CLK_DIS_ON_LPM_1 = 0x1
	// Position of SBYOS field.
	CCM_CLPCR_SBYOS_Pos = 0x6
	// Bit mask of SBYOS field.
	CCM_CLPCR_SBYOS_Msk = 0x40
	// Bit SBYOS.
	CCM_CLPCR_SBYOS = 0x40
	// On-chip oscillator will not be powered down, after next entrance to STOP mode. (CCM_REF_EN_B will remain asserted - '0' and cosc_pwrdown will remain de asserted - '0')
	CCM_CLPCR_SBYOS_SBYOS_0 = 0x0
	// On-chip oscillator will be powered down, after next entrance to STOP mode. (CCM_REF_EN_B will be deasserted - '1' and cosc_pwrdown will be asserted - '1'). When returning from STOP mode, external oscillator will be enabled again, on-chip oscillator will return to oscillator mode, and after oscnt count, CCM will continue with the exit from the STOP mode process.
	CCM_CLPCR_SBYOS_SBYOS_1 = 0x1
	// Position of DIS_REF_OSC field.
	CCM_CLPCR_DIS_REF_OSC_Pos = 0x7
	// Bit mask of DIS_REF_OSC field.
	CCM_CLPCR_DIS_REF_OSC_Msk = 0x80
	// Bit DIS_REF_OSC.
	CCM_CLPCR_DIS_REF_OSC = 0x80
	// external high frequency oscillator will be enabled, i.e. CCM_REF_EN_B = '0'.
	CCM_CLPCR_DIS_REF_OSC_DIS_REF_OSC_0 = 0x0
	// external high frequency oscillator will be disabled, i.e. CCM_REF_EN_B = '1'
	CCM_CLPCR_DIS_REF_OSC_DIS_REF_OSC_1 = 0x1
	// Position of VSTBY field.
	CCM_CLPCR_VSTBY_Pos = 0x8
	// Bit mask of VSTBY field.
	CCM_CLPCR_VSTBY_Msk = 0x100
	// Bit VSTBY.
	CCM_CLPCR_VSTBY = 0x100
	// Voltage will not be changed to standby voltage after next entrance to STOP mode. ( PMIC_STBY_REQ will remain negated - '0')
	CCM_CLPCR_VSTBY_VSTBY_0 = 0x0
	// Voltage will be requested to change to standby voltage after next entrance to stop mode. ( PMIC_STBY_REQ will be asserted - '1').
	CCM_CLPCR_VSTBY_VSTBY_1 = 0x1
	// Position of STBY_COUNT field.
	CCM_CLPCR_STBY_COUNT_Pos = 0x9
	// Bit mask of STBY_COUNT field.
	CCM_CLPCR_STBY_COUNT_Msk = 0x600
	// CCM will wait (1*pmic_delay_scaler)+1 ckil clock cycles
	CCM_CLPCR_STBY_COUNT_STBY_COUNT_0 = 0x0
	// CCM will wait (3*pmic_delay_scaler)+1 ckil clock cycles
	CCM_CLPCR_STBY_COUNT_STBY_COUNT_1 = 0x1
	// CCM will wait (7*pmic_delay_scaler)+1 ckil clock cycles
	CCM_CLPCR_STBY_COUNT_STBY_COUNT_2 = 0x2
	// CCM will wait (15*pmic_delay_scaler)+1 ckil clock cycles
	CCM_CLPCR_STBY_COUNT_STBY_COUNT_3 = 0x3
	// Position of COSC_PWRDOWN field.
	CCM_CLPCR_COSC_PWRDOWN_Pos = 0xb
	// Bit mask of COSC_PWRDOWN field.
	CCM_CLPCR_COSC_PWRDOWN_Msk = 0x800
	// Bit COSC_PWRDOWN.
	CCM_CLPCR_COSC_PWRDOWN = 0x800
	// On chip oscillator will not be powered down, i.e. cosc_pwrdown = '0'.
	CCM_CLPCR_COSC_PWRDOWN_COSC_PWRDOWN_0 = 0x0
	// On chip oscillator will be powered down, i.e. cosc_pwrdown = '1'.
	CCM_CLPCR_COSC_PWRDOWN_COSC_PWRDOWN_1 = 0x1
	// Position of MASK_CORE0_WFI field.
	CCM_CLPCR_MASK_CORE0_WFI_Pos = 0x16
	// Bit mask of MASK_CORE0_WFI field.
	CCM_CLPCR_MASK_CORE0_WFI_Msk = 0x400000
	// Bit MASK_CORE0_WFI.
	CCM_CLPCR_MASK_CORE0_WFI = 0x400000
	// WFI of core0 is not masked
	CCM_CLPCR_MASK_CORE0_WFI_MASK_CORE0_WFI_0 = 0x0
	// WFI of core0 is masked
	CCM_CLPCR_MASK_CORE0_WFI_MASK_CORE0_WFI_1 = 0x1
	// Position of MASK_SCU_IDLE field.
	CCM_CLPCR_MASK_SCU_IDLE_Pos = 0x1a
	// Bit mask of MASK_SCU_IDLE field.
	CCM_CLPCR_MASK_SCU_IDLE_Msk = 0x4000000
	// Bit MASK_SCU_IDLE.
	CCM_CLPCR_MASK_SCU_IDLE = 0x4000000
	// SCU IDLE is not masked
	CCM_CLPCR_MASK_SCU_IDLE_MASK_SCU_IDLE_0 = 0x0
	// SCU IDLE is masked
	CCM_CLPCR_MASK_SCU_IDLE_MASK_SCU_IDLE_1 = 0x1
	// Position of MASK_L2CC_IDLE field.
	CCM_CLPCR_MASK_L2CC_IDLE_Pos = 0x1b
	// Bit mask of MASK_L2CC_IDLE field.
	CCM_CLPCR_MASK_L2CC_IDLE_Msk = 0x8000000
	// Bit MASK_L2CC_IDLE.
	CCM_CLPCR_MASK_L2CC_IDLE = 0x8000000
	// L2CC IDLE is not masked
	CCM_CLPCR_MASK_L2CC_IDLE_MASK_L2CC_IDLE_0 = 0x0
	// L2CC IDLE is masked
	CCM_CLPCR_MASK_L2CC_IDLE_MASK_L2CC_IDLE_1 = 0x1

	// CISR: CCM Interrupt Status Register
	// Position of LRF_PLL field.
	CCM_CISR_LRF_PLL_Pos = 0x0
	// Bit mask of LRF_PLL field.
	CCM_CISR_LRF_PLL_Msk = 0x1
	// Bit LRF_PLL.
	CCM_CISR_LRF_PLL = 0x1
	// interrupt is not generated due to lock ready of all enabled and not bypaseed PLLs
	CCM_CISR_LRF_PLL_LRF_PLL_0 = 0x0
	// interrupt generated due to lock ready of all enabled and not bypaseed PLLs
	CCM_CISR_LRF_PLL_LRF_PLL_1 = 0x1
	// Position of COSC_READY field.
	CCM_CISR_COSC_READY_Pos = 0x6
	// Bit mask of COSC_READY field.
	CCM_CISR_COSC_READY_Msk = 0x40
	// Bit COSC_READY.
	CCM_CISR_COSC_READY = 0x40
	// interrupt is not generated due to on board oscillator ready
	CCM_CISR_COSC_READY_COSC_READY_0 = 0x0
	// interrupt generated due to on board oscillator ready
	CCM_CISR_COSC_READY_COSC_READY_1 = 0x1
	// Position of FLEXSPI_PODF_LOADED field.
	CCM_CISR_FLEXSPI_PODF_LOADED_Pos = 0x10
	// Bit mask of FLEXSPI_PODF_LOADED field.
	CCM_CISR_FLEXSPI_PODF_LOADED_Msk = 0x10000
	// Bit FLEXSPI_PODF_LOADED.
	CCM_CISR_FLEXSPI_PODF_LOADED = 0x10000
	// interrupt is not generated due to frequency change of flexspi_podf
	CCM_CISR_FLEXSPI_PODF_LOADED_FLEXSPI_PODF_LOADED_0 = 0x0
	// interrupt generated due to frequency change of flexspi_podf
	CCM_CISR_FLEXSPI_PODF_LOADED_FLEXSPI_PODF_LOADED_1 = 0x1
	// Position of PERCLK_PODF_LOADED field.
	CCM_CISR_PERCLK_PODF_LOADED_Pos = 0x12
	// Bit mask of PERCLK_PODF_LOADED field.
	CCM_CISR_PERCLK_PODF_LOADED_Msk = 0x40000
	// Bit PERCLK_PODF_LOADED.
	CCM_CISR_PERCLK_PODF_LOADED = 0x40000
	// interrupt is not generated due to frequency change of perclk_podf
	CCM_CISR_PERCLK_PODF_LOADED_PERCLK_PODF_LOADED_0 = 0x0
	// interrupt generated due to frequency change of perclk_podf
	CCM_CISR_PERCLK_PODF_LOADED_PERCLK_PODF_LOADED_1 = 0x1
	// Position of AHB_PODF_LOADED field.
	CCM_CISR_AHB_PODF_LOADED_Pos = 0x14
	// Bit mask of AHB_PODF_LOADED field.
	CCM_CISR_AHB_PODF_LOADED_Msk = 0x100000
	// Bit AHB_PODF_LOADED.
	CCM_CISR_AHB_PODF_LOADED = 0x100000
	// interrupt is not generated due to frequency change of ahb_podf
	CCM_CISR_AHB_PODF_LOADED_AHB_PODF_LOADED_0 = 0x0
	// interrupt generated due to frequency change of ahb_podf
	CCM_CISR_AHB_PODF_LOADED_AHB_PODF_LOADED_1 = 0x1
	// Position of PERIPH_CLK_SEL_LOADED field.
	CCM_CISR_PERIPH_CLK_SEL_LOADED_Pos = 0x16
	// Bit mask of PERIPH_CLK_SEL_LOADED field.
	CCM_CISR_PERIPH_CLK_SEL_LOADED_Msk = 0x400000
	// Bit PERIPH_CLK_SEL_LOADED.
	CCM_CISR_PERIPH_CLK_SEL_LOADED = 0x400000
	// interrupt is not generated due to update of periph_clk_sel.
	CCM_CISR_PERIPH_CLK_SEL_LOADED_PERIPH_CLK_SEL_LOADED_0 = 0x0
	// interrupt generated due to update of periph_clk_sel.
	CCM_CISR_PERIPH_CLK_SEL_LOADED_PERIPH_CLK_SEL_LOADED_1 = 0x1

	// CIMR: CCM Interrupt Mask Register
	// Position of MASK_LRF_PLL field.
	CCM_CIMR_MASK_LRF_PLL_Pos = 0x0
	// Bit mask of MASK_LRF_PLL field.
	CCM_CIMR_MASK_LRF_PLL_Msk = 0x1
	// Bit MASK_LRF_PLL.
	CCM_CIMR_MASK_LRF_PLL = 0x1
	// don't mask interrupt due to lrf of PLLs - interrupt will be created
	CCM_CIMR_MASK_LRF_PLL_MASK_LRF_PLL_0 = 0x0
	// mask interrupt due to lrf of PLLs
	CCM_CIMR_MASK_LRF_PLL_MASK_LRF_PLL_1 = 0x1
	// Position of MASK_COSC_READY field.
	CCM_CIMR_MASK_COSC_READY_Pos = 0x6
	// Bit mask of MASK_COSC_READY field.
	CCM_CIMR_MASK_COSC_READY_Msk = 0x40
	// Bit MASK_COSC_READY.
	CCM_CIMR_MASK_COSC_READY = 0x40
	// don't mask interrupt due to on board oscillator ready - interrupt will be created
	CCM_CIMR_MASK_COSC_READY_MASK_COSC_READY_0 = 0x0
	// mask interrupt due to on board oscillator ready
	CCM_CIMR_MASK_COSC_READY_MASK_COSC_READY_1 = 0x1
	// Position of MASK_FLEXSPI_PODF_LOADED field.
	CCM_CIMR_MASK_FLEXSPI_PODF_LOADED_Pos = 0x10
	// Bit mask of MASK_FLEXSPI_PODF_LOADED field.
	CCM_CIMR_MASK_FLEXSPI_PODF_LOADED_Msk = 0x10000
	// Bit MASK_FLEXSPI_PODF_LOADED.
	CCM_CIMR_MASK_FLEXSPI_PODF_LOADED = 0x10000
	// don't mask interrupt due to update of flexspi_podf
	CCM_CIMR_MASK_FLEXSPI_PODF_LOADED_MASK_FLEXSPI_PODF_LOADED_0 = 0x0
	// mask interrupt due to update of flexspi_podf
	CCM_CIMR_MASK_FLEXSPI_PODF_LOADED_MASK_FLEXSPI_PODF_LOADED_1 = 0x1
	// Position of MASK_PERCLK_PODF_LOADED field.
	CCM_CIMR_MASK_PERCLK_PODF_LOADED_Pos = 0x12
	// Bit mask of MASK_PERCLK_PODF_LOADED field.
	CCM_CIMR_MASK_PERCLK_PODF_LOADED_Msk = 0x40000
	// Bit MASK_PERCLK_PODF_LOADED.
	CCM_CIMR_MASK_PERCLK_PODF_LOADED = 0x40000
	// don't mask interrupt due to update of perclk_podf
	CCM_CIMR_MASK_PERCLK_PODF_LOADED_MASK_PERCLK_PODF_LOADED_0 = 0x0
	// mask interrupt due to update of perclk_podf
	CCM_CIMR_MASK_PERCLK_PODF_LOADED_MASK_PERCLK_PODF_LOADED_1 = 0x1
	// Position of MASK_AHB_PODF_LOADED field.
	CCM_CIMR_MASK_AHB_PODF_LOADED_Pos = 0x14
	// Bit mask of MASK_AHB_PODF_LOADED field.
	CCM_CIMR_MASK_AHB_PODF_LOADED_Msk = 0x100000
	// Bit MASK_AHB_PODF_LOADED.
	CCM_CIMR_MASK_AHB_PODF_LOADED = 0x100000
	// don't mask interrupt due to frequency change of ahb_podf - interrupt will be created
	CCM_CIMR_MASK_AHB_PODF_LOADED_MASK_AHB_PODF_LOADED_0 = 0x0
	// mask interrupt due to frequency change of ahb_podf
	CCM_CIMR_MASK_AHB_PODF_LOADED_MASK_AHB_PODF_LOADED_1 = 0x1
	// Position of MASK_PERIPH_CLK_SEL_LOADED field.
	CCM_CIMR_MASK_PERIPH_CLK_SEL_LOADED_Pos = 0x16
	// Bit mask of MASK_PERIPH_CLK_SEL_LOADED field.
	CCM_CIMR_MASK_PERIPH_CLK_SEL_LOADED_Msk = 0x400000
	// Bit MASK_PERIPH_CLK_SEL_LOADED.
	CCM_CIMR_MASK_PERIPH_CLK_SEL_LOADED = 0x400000
	// don't mask interrupt due to update of periph_clk_sel - interrupt will be created
	CCM_CIMR_MASK_PERIPH_CLK_SEL_LOADED_MASK_PERIPH_CLK_SEL_LOADED_0 = 0x0
	// mask interrupt due to update of periph_clk_sel
	CCM_CIMR_MASK_PERIPH_CLK_SEL_LOADED_MASK_PERIPH_CLK_SEL_LOADED_1 = 0x1

	// CCOSR: CCM Clock Output Source Register
	// Position of CLKO1_SEL field.
	CCM_CCOSR_CLKO1_SEL_Pos = 0x0
	// Bit mask of CLKO1_SEL field.
	CCM_CCOSR_CLKO1_SEL_Msk = 0xf
	// pll3_sw_clk (divided by 2)
	CCM_CCOSR_CLKO1_SEL_CLKO1_SEL_0 = 0x0
	// PLL2 (divided by 2)
	CCM_CCOSR_CLKO1_SEL_CLKO1_SEL_1 = 0x1
	// ENET PLL (divided by 2)
	CCM_CCOSR_CLKO1_SEL_CLKO1_SEL_2 = 0x2
	// core_clk_root
	CCM_CCOSR_CLKO1_SEL_CLKO1_SEL_11 = 0xb
	// ipg_clk_root
	CCM_CCOSR_CLKO1_SEL_CLKO1_SEL_12 = 0xc
	// perclk_root
	CCM_CCOSR_CLKO1_SEL_CLKO1_SEL_13 = 0xd
	// pll4_main_clk
	CCM_CCOSR_CLKO1_SEL_CLKO1_SEL_15 = 0xf
	// Position of CLKO1_DIV field.
	CCM_CCOSR_CLKO1_DIV_Pos = 0x4
	// Bit mask of CLKO1_DIV field.
	CCM_CCOSR_CLKO1_DIV_Msk = 0x70
	// divide by 1
	CCM_CCOSR_CLKO1_DIV_CLKO1_DIV_0 = 0x0
	// divide by 2
	CCM_CCOSR_CLKO1_DIV_CLKO1_DIV_1 = 0x1
	// divide by 3
	CCM_CCOSR_CLKO1_DIV_CLKO1_DIV_2 = 0x2
	// divide by 4
	CCM_CCOSR_CLKO1_DIV_CLKO1_DIV_3 = 0x3
	// divide by 5
	CCM_CCOSR_CLKO1_DIV_CLKO1_DIV_4 = 0x4
	// divide by 6
	CCM_CCOSR_CLKO1_DIV_CLKO1_DIV_5 = 0x5
	// divide by 7
	CCM_CCOSR_CLKO1_DIV_CLKO1_DIV_6 = 0x6
	// divide by 8
	CCM_CCOSR_CLKO1_DIV_CLKO1_DIV_7 = 0x7
	// Position of CLKO1_EN field.
	CCM_CCOSR_CLKO1_EN_Pos = 0x7
	// Bit mask of CLKO1_EN field.
	CCM_CCOSR_CLKO1_EN_Msk = 0x80
	// Bit CLKO1_EN.
	CCM_CCOSR_CLKO1_EN = 0x80
	// CCM_CLKO1 disabled.
	CCM_CCOSR_CLKO1_EN_CLKO1_EN_0 = 0x0
	// CCM_CLKO1 enabled.
	CCM_CCOSR_CLKO1_EN_CLKO1_EN_1 = 0x1
	// Position of CLK_OUT_SEL field.
	CCM_CCOSR_CLK_OUT_SEL_Pos = 0x8
	// Bit mask of CLK_OUT_SEL field.
	CCM_CCOSR_CLK_OUT_SEL_Msk = 0x100
	// Bit CLK_OUT_SEL.
	CCM_CCOSR_CLK_OUT_SEL = 0x100
	// CCM_CLKO1 output drives CCM_CLKO1 clock
	CCM_CCOSR_CLK_OUT_SEL_CLK_OUT_SEL_0 = 0x0
	// CCM_CLKO1 output drives CCM_CLKO2 clock
	CCM_CCOSR_CLK_OUT_SEL_CLK_OUT_SEL_1 = 0x1
	// Position of CLKO2_SEL field.
	CCM_CCOSR_CLKO2_SEL_Pos = 0x10
	// Bit mask of CLKO2_SEL field.
	CCM_CCOSR_CLKO2_SEL_Msk = 0x1f0000
	// lpi2c_clk_root
	CCM_CCOSR_CLKO2_SEL_CLKO2_SEL_6 = 0x6
	// osc_clk
	CCM_CCOSR_CLKO2_SEL_CLKO2_SEL_14 = 0xe
	// lpspi_clk_root
	CCM_CCOSR_CLKO2_SEL_CLKO2_SEL_16 = 0x10
	// sai1_clk_root
	CCM_CCOSR_CLKO2_SEL_CLKO2_SEL_18 = 0x12
	// sai3_clk_root
	CCM_CCOSR_CLKO2_SEL_CLKO2_SEL_20 = 0x14
	// trace_clk_root
	CCM_CCOSR_CLKO2_SEL_CLKO2_SEL_22 = 0x16
	// flexspi_clk_root
	CCM_CCOSR_CLKO2_SEL_CLKO2_SEL_27 = 0x1b
	// uart_clk_root
	CCM_CCOSR_CLKO2_SEL_CLKO2_SEL_28 = 0x1c
	// spdif0_clk_root
	CCM_CCOSR_CLKO2_SEL_CLKO2_SEL_29 = 0x1d
	// Position of CLKO2_DIV field.
	CCM_CCOSR_CLKO2_DIV_Pos = 0x15
	// Bit mask of CLKO2_DIV field.
	CCM_CCOSR_CLKO2_DIV_Msk = 0xe00000
	// divide by 1
	CCM_CCOSR_CLKO2_DIV_CLKO2_DIV_0 = 0x0
	// divide by 2
	CCM_CCOSR_CLKO2_DIV_CLKO2_DIV_1 = 0x1
	// divide by 3
	CCM_CCOSR_CLKO2_DIV_CLKO2_DIV_2 = 0x2
	// divide by 4
	CCM_CCOSR_CLKO2_DIV_CLKO2_DIV_3 = 0x3
	// divide by 5
	CCM_CCOSR_CLKO2_DIV_CLKO2_DIV_4 = 0x4
	// divide by 6
	CCM_CCOSR_CLKO2_DIV_CLKO2_DIV_5 = 0x5
	// divide by 7
	CCM_CCOSR_CLKO2_DIV_CLKO2_DIV_6 = 0x6
	// divide by 8
	CCM_CCOSR_CLKO2_DIV_CLKO2_DIV_7 = 0x7
	// Position of CLKO2_EN field.
	CCM_CCOSR_CLKO2_EN_Pos = 0x18
	// Bit mask of CLKO2_EN field.
	CCM_CCOSR_CLKO2_EN_Msk = 0x1000000
	// Bit CLKO2_EN.
	CCM_CCOSR_CLKO2_EN = 0x1000000
	// CCM_CLKO2 disabled.
	CCM_CCOSR_CLKO2_EN_CLKO2_EN_0 = 0x0
	// CCM_CLKO2 enabled.
	CCM_CCOSR_CLKO2_EN_CLKO2_EN_1 = 0x1

	// CGPR: CCM General Purpose Register
	// Position of PMIC_DELAY_SCALER field.
	CCM_CGPR_PMIC_DELAY_SCALER_Pos = 0x0
	// Bit mask of PMIC_DELAY_SCALER field.
	CCM_CGPR_PMIC_DELAY_SCALER_Msk = 0x1
	// Bit PMIC_DELAY_SCALER.
	CCM_CGPR_PMIC_DELAY_SCALER = 0x1
	// clock is not divided
	CCM_CGPR_PMIC_DELAY_SCALER_PMIC_DELAY_SCALER_0 = 0x0
	// clock is divided /8
	CCM_CGPR_PMIC_DELAY_SCALER_PMIC_DELAY_SCALER_1 = 0x1
	// Position of EFUSE_PROG_SUPPLY_GATE field.
	CCM_CGPR_EFUSE_PROG_SUPPLY_GATE_Pos = 0x4
	// Bit mask of EFUSE_PROG_SUPPLY_GATE field.
	CCM_CGPR_EFUSE_PROG_SUPPLY_GATE_Msk = 0x10
	// Bit EFUSE_PROG_SUPPLY_GATE.
	CCM_CGPR_EFUSE_PROG_SUPPLY_GATE = 0x10
	// fuse programing supply voltage is gated off to the efuse module
	CCM_CGPR_EFUSE_PROG_SUPPLY_GATE_EFUSE_PROG_SUPPLY_GATE_0 = 0x0
	// allow fuse programing.
	CCM_CGPR_EFUSE_PROG_SUPPLY_GATE_EFUSE_PROG_SUPPLY_GATE_1 = 0x1
	// Position of SYS_MEM_DS_CTRL field.
	CCM_CGPR_SYS_MEM_DS_CTRL_Pos = 0xe
	// Bit mask of SYS_MEM_DS_CTRL field.
	CCM_CGPR_SYS_MEM_DS_CTRL_Msk = 0xc000
	// Disable memory DS mode always
	CCM_CGPR_SYS_MEM_DS_CTRL_SYS_MEM_DS_CTRL_0 = 0x0
	// Enable memory (outside ARM platform) DS mode when system STOP and PLL are disabled
	CCM_CGPR_SYS_MEM_DS_CTRL_SYS_MEM_DS_CTRL_1 = 0x1
	// enable memory (outside ARM platform) DS mode when system is in STOP mode
	CCM_CGPR_SYS_MEM_DS_CTRL_SYS_MEM_DS_CTRL_2 = 0x2
	// Position of FPL field.
	CCM_CGPR_FPL_Pos = 0x10
	// Bit mask of FPL field.
	CCM_CGPR_FPL_Msk = 0x10000
	// Bit FPL.
	CCM_CGPR_FPL = 0x10000
	// Engage PLL enable default way.
	CCM_CGPR_FPL_FPL_0 = 0x0
	// Engage PLL enable 3 CKIL clocks earlier at exiting low power mode (STOP). Should be used only if 24MHz OSC was active in low power mode.
	CCM_CGPR_FPL_FPL_1 = 0x1
	// Position of INT_MEM_CLK_LPM field.
	CCM_CGPR_INT_MEM_CLK_LPM_Pos = 0x11
	// Bit mask of INT_MEM_CLK_LPM field.
	CCM_CGPR_INT_MEM_CLK_LPM_Msk = 0x20000
	// Bit INT_MEM_CLK_LPM.
	CCM_CGPR_INT_MEM_CLK_LPM = 0x20000
	// Disable the clock to the ARM platform memories when entering Low Power Mode
	CCM_CGPR_INT_MEM_CLK_LPM_INT_MEM_CLK_LPM_0 = 0x0
	// Keep the clocks to the ARM platform memories enabled only if an interrupt is pending when entering Low Power Modes (WAIT and STOP without power gating)
	CCM_CGPR_INT_MEM_CLK_LPM_INT_MEM_CLK_LPM_1 = 0x1

	// CCGR0: CCM Clock Gating Register 0
	// Position of CG0 field.
	CCM_CCGR0_CG0_Pos = 0x0
	// Bit mask of CG0 field.
	CCM_CCGR0_CG0_Msk = 0x3
	// Position of CG1 field.
	CCM_CCGR0_CG1_Pos = 0x2
	// Bit mask of CG1 field.
	CCM_CCGR0_CG1_Msk = 0xc
	// Position of CG2 field.
	CCM_CCGR0_CG2_Pos = 0x4
	// Bit mask of CG2 field.
	CCM_CCGR0_CG2_Msk = 0x30
	// Position of CG3 field.
	CCM_CCGR0_CG3_Pos = 0x6
	// Bit mask of CG3 field.
	CCM_CCGR0_CG3_Msk = 0xc0
	// Position of CG4 field.
	CCM_CCGR0_CG4_Pos = 0x8
	// Bit mask of CG4 field.
	CCM_CCGR0_CG4_Msk = 0x300
	// Position of CG5 field.
	CCM_CCGR0_CG5_Pos = 0xa
	// Bit mask of CG5 field.
	CCM_CCGR0_CG5_Msk = 0xc00
	// Position of CG6 field.
	CCM_CCGR0_CG6_Pos = 0xc
	// Bit mask of CG6 field.
	CCM_CCGR0_CG6_Msk = 0x3000
	// Position of CG7 field.
	CCM_CCGR0_CG7_Pos = 0xe
	// Bit mask of CG7 field.
	CCM_CCGR0_CG7_Msk = 0xc000
	// Position of CG8 field.
	CCM_CCGR0_CG8_Pos = 0x10
	// Bit mask of CG8 field.
	CCM_CCGR0_CG8_Msk = 0x30000
	// Position of CG9 field.
	CCM_CCGR0_CG9_Pos = 0x12
	// Bit mask of CG9 field.
	CCM_CCGR0_CG9_Msk = 0xc0000
	// Position of CG10 field.
	CCM_CCGR0_CG10_Pos = 0x14
	// Bit mask of CG10 field.
	CCM_CCGR0_CG10_Msk = 0x300000
	// Position of CG11 field.
	CCM_CCGR0_CG11_Pos = 0x16
	// Bit mask of CG11 field.
	CCM_CCGR0_CG11_Msk = 0xc00000
	// Position of CG12 field.
	CCM_CCGR0_CG12_Pos = 0x18
	// Bit mask of CG12 field.
	CCM_CCGR0_CG12_Msk = 0x3000000
	// Position of CG13 field.
	CCM_CCGR0_CG13_Pos = 0x1a
	// Bit mask of CG13 field.
	CCM_CCGR0_CG13_Msk = 0xc000000
	// Position of CG14 field.
	CCM_CCGR0_CG14_Pos = 0x1c
	// Bit mask of CG14 field.
	CCM_CCGR0_CG14_Msk = 0x30000000
	// Position of CG15 field.
	CCM_CCGR0_CG15_Pos = 0x1e
	// Bit mask of CG15 field.
	CCM_CCGR0_CG15_Msk = 0xc0000000

	// CCGR1: CCM Clock Gating Register 1
	// Position of CG0 field.
	CCM_CCGR1_CG0_Pos = 0x0
	// Bit mask of CG0 field.
	CCM_CCGR1_CG0_Msk = 0x3
	// Position of CG1 field.
	CCM_CCGR1_CG1_Pos = 0x2
	// Bit mask of CG1 field.
	CCM_CCGR1_CG1_Msk = 0xc
	// Position of CG2 field.
	CCM_CCGR1_CG2_Pos = 0x4
	// Bit mask of CG2 field.
	CCM_CCGR1_CG2_Msk = 0x30
	// Position of CG3 field.
	CCM_CCGR1_CG3_Pos = 0x6
	// Bit mask of CG3 field.
	CCM_CCGR1_CG3_Msk = 0xc0
	// Position of CG4 field.
	CCM_CCGR1_CG4_Pos = 0x8
	// Bit mask of CG4 field.
	CCM_CCGR1_CG4_Msk = 0x300
	// Position of CG5 field.
	CCM_CCGR1_CG5_Pos = 0xa
	// Bit mask of CG5 field.
	CCM_CCGR1_CG5_Msk = 0xc00
	// Position of CG6 field.
	CCM_CCGR1_CG6_Pos = 0xc
	// Bit mask of CG6 field.
	CCM_CCGR1_CG6_Msk = 0x3000
	// Position of CG7 field.
	CCM_CCGR1_CG7_Pos = 0xe
	// Bit mask of CG7 field.
	CCM_CCGR1_CG7_Msk = 0xc000
	// Position of CG8 field.
	CCM_CCGR1_CG8_Pos = 0x10
	// Bit mask of CG8 field.
	CCM_CCGR1_CG8_Msk = 0x30000
	// Position of CG9 field.
	CCM_CCGR1_CG9_Pos = 0x12
	// Bit mask of CG9 field.
	CCM_CCGR1_CG9_Msk = 0xc0000
	// Position of CG10 field.
	CCM_CCGR1_CG10_Pos = 0x14
	// Bit mask of CG10 field.
	CCM_CCGR1_CG10_Msk = 0x300000
	// Position of CG11 field.
	CCM_CCGR1_CG11_Pos = 0x16
	// Bit mask of CG11 field.
	CCM_CCGR1_CG11_Msk = 0xc00000
	// Position of CG12 field.
	CCM_CCGR1_CG12_Pos = 0x18
	// Bit mask of CG12 field.
	CCM_CCGR1_CG12_Msk = 0x3000000
	// Position of CG13 field.
	CCM_CCGR1_CG13_Pos = 0x1a
	// Bit mask of CG13 field.
	CCM_CCGR1_CG13_Msk = 0xc000000
	// Position of CG14 field.
	CCM_CCGR1_CG14_Pos = 0x1c
	// Bit mask of CG14 field.
	CCM_CCGR1_CG14_Msk = 0x30000000
	// Position of CG15 field.
	CCM_CCGR1_CG15_Pos = 0x1e
	// Bit mask of CG15 field.
	CCM_CCGR1_CG15_Msk = 0xc0000000

	// CCGR2: CCM Clock Gating Register 2
	// Position of CG0 field.
	CCM_CCGR2_CG0_Pos = 0x0
	// Bit mask of CG0 field.
	CCM_CCGR2_CG0_Msk = 0x3
	// Position of CG1 field.
	CCM_CCGR2_CG1_Pos = 0x2
	// Bit mask of CG1 field.
	CCM_CCGR2_CG1_Msk = 0xc
	// Position of CG2 field.
	CCM_CCGR2_CG2_Pos = 0x4
	// Bit mask of CG2 field.
	CCM_CCGR2_CG2_Msk = 0x30
	// Position of CG3 field.
	CCM_CCGR2_CG3_Pos = 0x6
	// Bit mask of CG3 field.
	CCM_CCGR2_CG3_Msk = 0xc0
	// Position of CG4 field.
	CCM_CCGR2_CG4_Pos = 0x8
	// Bit mask of CG4 field.
	CCM_CCGR2_CG4_Msk = 0x300
	// Position of CG5 field.
	CCM_CCGR2_CG5_Pos = 0xa
	// Bit mask of CG5 field.
	CCM_CCGR2_CG5_Msk = 0xc00
	// Position of CG6 field.
	CCM_CCGR2_CG6_Pos = 0xc
	// Bit mask of CG6 field.
	CCM_CCGR2_CG6_Msk = 0x3000
	// Position of CG7 field.
	CCM_CCGR2_CG7_Pos = 0xe
	// Bit mask of CG7 field.
	CCM_CCGR2_CG7_Msk = 0xc000
	// Position of CG8 field.
	CCM_CCGR2_CG8_Pos = 0x10
	// Bit mask of CG8 field.
	CCM_CCGR2_CG8_Msk = 0x30000
	// Position of CG9 field.
	CCM_CCGR2_CG9_Pos = 0x12
	// Bit mask of CG9 field.
	CCM_CCGR2_CG9_Msk = 0xc0000
	// Position of CG10 field.
	CCM_CCGR2_CG10_Pos = 0x14
	// Bit mask of CG10 field.
	CCM_CCGR2_CG10_Msk = 0x300000
	// Position of CG11 field.
	CCM_CCGR2_CG11_Pos = 0x16
	// Bit mask of CG11 field.
	CCM_CCGR2_CG11_Msk = 0xc00000
	// Position of CG12 field.
	CCM_CCGR2_CG12_Pos = 0x18
	// Bit mask of CG12 field.
	CCM_CCGR2_CG12_Msk = 0x3000000
	// Position of CG13 field.
	CCM_CCGR2_CG13_Pos = 0x1a
	// Bit mask of CG13 field.
	CCM_CCGR2_CG13_Msk = 0xc000000
	// Position of CG14 field.
	CCM_CCGR2_CG14_Pos = 0x1c
	// Bit mask of CG14 field.
	CCM_CCGR2_CG14_Msk = 0x30000000
	// Position of CG15 field.
	CCM_CCGR2_CG15_Pos = 0x1e
	// Bit mask of CG15 field.
	CCM_CCGR2_CG15_Msk = 0xc0000000

	// CCGR3: CCM Clock Gating Register 3
	// Position of CG0 field.
	CCM_CCGR3_CG0_Pos = 0x0
	// Bit mask of CG0 field.
	CCM_CCGR3_CG0_Msk = 0x3
	// Position of CG1 field.
	CCM_CCGR3_CG1_Pos = 0x2
	// Bit mask of CG1 field.
	CCM_CCGR3_CG1_Msk = 0xc
	// Position of CG2 field.
	CCM_CCGR3_CG2_Pos = 0x4
	// Bit mask of CG2 field.
	CCM_CCGR3_CG2_Msk = 0x30
	// Position of CG3 field.
	CCM_CCGR3_CG3_Pos = 0x6
	// Bit mask of CG3 field.
	CCM_CCGR3_CG3_Msk = 0xc0
	// Position of CG4 field.
	CCM_CCGR3_CG4_Pos = 0x8
	// Bit mask of CG4 field.
	CCM_CCGR3_CG4_Msk = 0x300
	// Position of CG5 field.
	CCM_CCGR3_CG5_Pos = 0xa
	// Bit mask of CG5 field.
	CCM_CCGR3_CG5_Msk = 0xc00
	// Position of CG6 field.
	CCM_CCGR3_CG6_Pos = 0xc
	// Bit mask of CG6 field.
	CCM_CCGR3_CG6_Msk = 0x3000
	// Position of CG7 field.
	CCM_CCGR3_CG7_Pos = 0xe
	// Bit mask of CG7 field.
	CCM_CCGR3_CG7_Msk = 0xc000
	// Position of CG8 field.
	CCM_CCGR3_CG8_Pos = 0x10
	// Bit mask of CG8 field.
	CCM_CCGR3_CG8_Msk = 0x30000
	// Position of CG9 field.
	CCM_CCGR3_CG9_Pos = 0x12
	// Bit mask of CG9 field.
	CCM_CCGR3_CG9_Msk = 0xc0000
	// Position of CG10 field.
	CCM_CCGR3_CG10_Pos = 0x14
	// Bit mask of CG10 field.
	CCM_CCGR3_CG10_Msk = 0x300000
	// Position of CG11 field.
	CCM_CCGR3_CG11_Pos = 0x16
	// Bit mask of CG11 field.
	CCM_CCGR3_CG11_Msk = 0xc00000
	// Position of CG12 field.
	CCM_CCGR3_CG12_Pos = 0x18
	// Bit mask of CG12 field.
	CCM_CCGR3_CG12_Msk = 0x3000000
	// Position of CG13 field.
	CCM_CCGR3_CG13_Pos = 0x1a
	// Bit mask of CG13 field.
	CCM_CCGR3_CG13_Msk = 0xc000000
	// Position of CG14 field.
	CCM_CCGR3_CG14_Pos = 0x1c
	// Bit mask of CG14 field.
	CCM_CCGR3_CG14_Msk = 0x30000000
	// Position of CG15 field.
	CCM_CCGR3_CG15_Pos = 0x1e
	// Bit mask of CG15 field.
	CCM_CCGR3_CG15_Msk = 0xc0000000

	// CCGR4: CCM Clock Gating Register 4
	// Position of CG0 field.
	CCM_CCGR4_CG0_Pos = 0x0
	// Bit mask of CG0 field.
	CCM_CCGR4_CG0_Msk = 0x3
	// Position of CG1 field.
	CCM_CCGR4_CG1_Pos = 0x2
	// Bit mask of CG1 field.
	CCM_CCGR4_CG1_Msk = 0xc
	// Position of CG2 field.
	CCM_CCGR4_CG2_Pos = 0x4
	// Bit mask of CG2 field.
	CCM_CCGR4_CG2_Msk = 0x30
	// Position of CG3 field.
	CCM_CCGR4_CG3_Pos = 0x6
	// Bit mask of CG3 field.
	CCM_CCGR4_CG3_Msk = 0xc0
	// Position of CG4 field.
	CCM_CCGR4_CG4_Pos = 0x8
	// Bit mask of CG4 field.
	CCM_CCGR4_CG4_Msk = 0x300
	// Position of CG5 field.
	CCM_CCGR4_CG5_Pos = 0xa
	// Bit mask of CG5 field.
	CCM_CCGR4_CG5_Msk = 0xc00
	// Position of CG6 field.
	CCM_CCGR4_CG6_Pos = 0xc
	// Bit mask of CG6 field.
	CCM_CCGR4_CG6_Msk = 0x3000
	// Position of CG7 field.
	CCM_CCGR4_CG7_Pos = 0xe
	// Bit mask of CG7 field.
	CCM_CCGR4_CG7_Msk = 0xc000
	// Position of CG8 field.
	CCM_CCGR4_CG8_Pos = 0x10
	// Bit mask of CG8 field.
	CCM_CCGR4_CG8_Msk = 0x30000
	// Position of CG9 field.
	CCM_CCGR4_CG9_Pos = 0x12
	// Bit mask of CG9 field.
	CCM_CCGR4_CG9_Msk = 0xc0000
	// Position of CG10 field.
	CCM_CCGR4_CG10_Pos = 0x14
	// Bit mask of CG10 field.
	CCM_CCGR4_CG10_Msk = 0x300000
	// Position of CG11 field.
	CCM_CCGR4_CG11_Pos = 0x16
	// Bit mask of CG11 field.
	CCM_CCGR4_CG11_Msk = 0xc00000
	// Position of CG12 field.
	CCM_CCGR4_CG12_Pos = 0x18
	// Bit mask of CG12 field.
	CCM_CCGR4_CG12_Msk = 0x3000000
	// Position of CG13 field.
	CCM_CCGR4_CG13_Pos = 0x1a
	// Bit mask of CG13 field.
	CCM_CCGR4_CG13_Msk = 0xc000000
	// Position of CG14 field.
	CCM_CCGR4_CG14_Pos = 0x1c
	// Bit mask of CG14 field.
	CCM_CCGR4_CG14_Msk = 0x30000000
	// Position of CG15 field.
	CCM_CCGR4_CG15_Pos = 0x1e
	// Bit mask of CG15 field.
	CCM_CCGR4_CG15_Msk = 0xc0000000

	// CCGR5: CCM Clock Gating Register 5
	// Position of CG0 field.
	CCM_CCGR5_CG0_Pos = 0x0
	// Bit mask of CG0 field.
	CCM_CCGR5_CG0_Msk = 0x3
	// Position of CG1 field.
	CCM_CCGR5_CG1_Pos = 0x2
	// Bit mask of CG1 field.
	CCM_CCGR5_CG1_Msk = 0xc
	// Position of CG2 field.
	CCM_CCGR5_CG2_Pos = 0x4
	// Bit mask of CG2 field.
	CCM_CCGR5_CG2_Msk = 0x30
	// Position of CG3 field.
	CCM_CCGR5_CG3_Pos = 0x6
	// Bit mask of CG3 field.
	CCM_CCGR5_CG3_Msk = 0xc0
	// Position of CG4 field.
	CCM_CCGR5_CG4_Pos = 0x8
	// Bit mask of CG4 field.
	CCM_CCGR5_CG4_Msk = 0x300
	// Position of CG5 field.
	CCM_CCGR5_CG5_Pos = 0xa
	// Bit mask of CG5 field.
	CCM_CCGR5_CG5_Msk = 0xc00
	// Position of CG6 field.
	CCM_CCGR5_CG6_Pos = 0xc
	// Bit mask of CG6 field.
	CCM_CCGR5_CG6_Msk = 0x3000
	// Position of CG7 field.
	CCM_CCGR5_CG7_Pos = 0xe
	// Bit mask of CG7 field.
	CCM_CCGR5_CG7_Msk = 0xc000
	// Position of CG8 field.
	CCM_CCGR5_CG8_Pos = 0x10
	// Bit mask of CG8 field.
	CCM_CCGR5_CG8_Msk = 0x30000
	// Position of CG9 field.
	CCM_CCGR5_CG9_Pos = 0x12
	// Bit mask of CG9 field.
	CCM_CCGR5_CG9_Msk = 0xc0000
	// Position of CG10 field.
	CCM_CCGR5_CG10_Pos = 0x14
	// Bit mask of CG10 field.
	CCM_CCGR5_CG10_Msk = 0x300000
	// Position of CG11 field.
	CCM_CCGR5_CG11_Pos = 0x16
	// Bit mask of CG11 field.
	CCM_CCGR5_CG11_Msk = 0xc00000
	// Position of CG12 field.
	CCM_CCGR5_CG12_Pos = 0x18
	// Bit mask of CG12 field.
	CCM_CCGR5_CG12_Msk = 0x3000000
	// Position of CG13 field.
	CCM_CCGR5_CG13_Pos = 0x1a
	// Bit mask of CG13 field.
	CCM_CCGR5_CG13_Msk = 0xc000000
	// Position of CG14 field.
	CCM_CCGR5_CG14_Pos = 0x1c
	// Bit mask of CG14 field.
	CCM_CCGR5_CG14_Msk = 0x30000000
	// Position of CG15 field.
	CCM_CCGR5_CG15_Pos = 0x1e
	// Bit mask of CG15 field.
	CCM_CCGR5_CG15_Msk = 0xc0000000

	// CCGR6: CCM Clock Gating Register 6
	// Position of CG0 field.
	CCM_CCGR6_CG0_Pos = 0x0
	// Bit mask of CG0 field.
	CCM_CCGR6_CG0_Msk = 0x3
	// Position of CG1 field.
	CCM_CCGR6_CG1_Pos = 0x2
	// Bit mask of CG1 field.
	CCM_CCGR6_CG1_Msk = 0xc
	// Position of CG2 field.
	CCM_CCGR6_CG2_Pos = 0x4
	// Bit mask of CG2 field.
	CCM_CCGR6_CG2_Msk = 0x30
	// Position of CG3 field.
	CCM_CCGR6_CG3_Pos = 0x6
	// Bit mask of CG3 field.
	CCM_CCGR6_CG3_Msk = 0xc0
	// Position of CG4 field.
	CCM_CCGR6_CG4_Pos = 0x8
	// Bit mask of CG4 field.
	CCM_CCGR6_CG4_Msk = 0x300
	// Position of CG5 field.
	CCM_CCGR6_CG5_Pos = 0xa
	// Bit mask of CG5 field.
	CCM_CCGR6_CG5_Msk = 0xc00
	// Position of CG6 field.
	CCM_CCGR6_CG6_Pos = 0xc
	// Bit mask of CG6 field.
	CCM_CCGR6_CG6_Msk = 0x3000
	// Position of CG7 field.
	CCM_CCGR6_CG7_Pos = 0xe
	// Bit mask of CG7 field.
	CCM_CCGR6_CG7_Msk = 0xc000
	// Position of CG8 field.
	CCM_CCGR6_CG8_Pos = 0x10
	// Bit mask of CG8 field.
	CCM_CCGR6_CG8_Msk = 0x30000
	// Position of CG9 field.
	CCM_CCGR6_CG9_Pos = 0x12
	// Bit mask of CG9 field.
	CCM_CCGR6_CG9_Msk = 0xc0000
	// Position of CG10 field.
	CCM_CCGR6_CG10_Pos = 0x14
	// Bit mask of CG10 field.
	CCM_CCGR6_CG10_Msk = 0x300000
	// Position of CG11 field.
	CCM_CCGR6_CG11_Pos = 0x16
	// Bit mask of CG11 field.
	CCM_CCGR6_CG11_Msk = 0xc00000
	// Position of CG12 field.
	CCM_CCGR6_CG12_Pos = 0x18
	// Bit mask of CG12 field.
	CCM_CCGR6_CG12_Msk = 0x3000000
	// Position of CG13 field.
	CCM_CCGR6_CG13_Pos = 0x1a
	// Bit mask of CG13 field.
	CCM_CCGR6_CG13_Msk = 0xc000000
	// Position of CG14 field.
	CCM_CCGR6_CG14_Pos = 0x1c
	// Bit mask of CG14 field.
	CCM_CCGR6_CG14_Msk = 0x30000000
	// Position of CG15 field.
	CCM_CCGR6_CG15_Pos = 0x1e
	// Bit mask of CG15 field.
	CCM_CCGR6_CG15_Msk = 0xc0000000

	// CMEOR: CCM Module Enable Overide Register
	// Position of MOD_EN_OV_GPT field.
	CCM_CMEOR_MOD_EN_OV_GPT_Pos = 0x5
	// Bit mask of MOD_EN_OV_GPT field.
	CCM_CMEOR_MOD_EN_OV_GPT_Msk = 0x20
	// Bit MOD_EN_OV_GPT.
	CCM_CMEOR_MOD_EN_OV_GPT = 0x20
	// don't override module enable signal
	CCM_CMEOR_MOD_EN_OV_GPT_MOD_EN_OV_GPT_0 = 0x0
	// override module enable signal
	CCM_CMEOR_MOD_EN_OV_GPT_MOD_EN_OV_GPT_1 = 0x1
	// Position of MOD_EN_OV_PIT field.
	CCM_CMEOR_MOD_EN_OV_PIT_Pos = 0x6
	// Bit mask of MOD_EN_OV_PIT field.
	CCM_CMEOR_MOD_EN_OV_PIT_Msk = 0x40
	// Bit MOD_EN_OV_PIT.
	CCM_CMEOR_MOD_EN_OV_PIT = 0x40
	// don't override module enable signal
	CCM_CMEOR_MOD_EN_OV_PIT_MOD_EN_OV_PIT_0 = 0x0
	// override module enable signal
	CCM_CMEOR_MOD_EN_OV_PIT_MOD_EN_OV_PIT_1 = 0x1
	// Position of MOD_EN_OV_TRNG field.
	CCM_CMEOR_MOD_EN_OV_TRNG_Pos = 0x9
	// Bit mask of MOD_EN_OV_TRNG field.
	CCM_CMEOR_MOD_EN_OV_TRNG_Msk = 0x200
	// Bit MOD_EN_OV_TRNG.
	CCM_CMEOR_MOD_EN_OV_TRNG = 0x200
	// don't override module enable signal
	CCM_CMEOR_MOD_EN_OV_TRNG_MOD_EN_OV_TRNG_0 = 0x0
	// override module enable signal
	CCM_CMEOR_MOD_EN_OV_TRNG_MOD_EN_OV_TRNG_1 = 0x1
)

// Constants for ROMC: ROMC
const (
	// ROMPATCH7D: ROMC Data Registers
	// Position of DATAX field.
	ROMC_ROMPATCHD_DATAX_Pos = 0x0
	// Bit mask of DATAX field.
	ROMC_ROMPATCHD_DATAX_Msk = 0xffffffff

	// ROMPATCHCNTL: ROMC Control Register
	// Position of DATAFIX field.
	ROMC_ROMPATCHCNTL_DATAFIX_Pos = 0x0
	// Bit mask of DATAFIX field.
	ROMC_ROMPATCHCNTL_DATAFIX_Msk = 0xff
	// Address comparator triggers a opcode patch
	ROMC_ROMPATCHCNTL_DATAFIX_DATAFIX_0 = 0x0
	// Address comparator triggers a data fix
	ROMC_ROMPATCHCNTL_DATAFIX_DATAFIX_1 = 0x1
	// Position of DIS field.
	ROMC_ROMPATCHCNTL_DIS_Pos = 0x1d
	// Bit mask of DIS field.
	ROMC_ROMPATCHCNTL_DIS_Msk = 0x20000000
	// Bit DIS.
	ROMC_ROMPATCHCNTL_DIS = 0x20000000
	// Does not affect any ROMC functions (default)
	ROMC_ROMPATCHCNTL_DIS_DIS_0 = 0x0
	// Disable all ROMC functions: data fixing, and opcode patching
	ROMC_ROMPATCHCNTL_DIS_DIS_1 = 0x1

	// ROMPATCHENL: ROMC Enable Register Low
	// Position of ENABLE field.
	ROMC_ROMPATCHENL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	ROMC_ROMPATCHENL_ENABLE_Msk = 0xffff
	// Address comparator disabled
	ROMC_ROMPATCHENL_ENABLE_ENABLE_0 = 0x0
	// Address comparator enabled, ROMC will trigger a opcode patch or data fix event upon matching of the associated address
	ROMC_ROMPATCHENL_ENABLE_ENABLE_1 = 0x1

	// ROMPATCH0A: ROMC Address Registers
	// Position of THUMBX field.
	ROMC_ROMPATCHA_THUMBX_Pos = 0x0
	// Bit mask of THUMBX field.
	ROMC_ROMPATCHA_THUMBX_Msk = 0x1
	// Bit THUMBX.
	ROMC_ROMPATCHA_THUMBX = 0x1
	// Arm patch
	ROMC_ROMPATCHA_THUMBX_THUMBX_0 = 0x0
	// THUMB patch (ignore if data fix)
	ROMC_ROMPATCHA_THUMBX_THUMBX_1 = 0x1
	// Position of ADDRX field.
	ROMC_ROMPATCHA_ADDRX_Pos = 0x1
	// Bit mask of ADDRX field.
	ROMC_ROMPATCHA_ADDRX_Msk = 0x7ffffe

	// ROMPATCHSR: ROMC Status Register
	// Position of SOURCE field.
	ROMC_ROMPATCHSR_SOURCE_Pos = 0x0
	// Bit mask of SOURCE field.
	ROMC_ROMPATCHSR_SOURCE_Msk = 0x3f
	// Address Comparator 0 matched
	ROMC_ROMPATCHSR_SOURCE_SOURCE_0 = 0x0
	// Address Comparator 1 matched
	ROMC_ROMPATCHSR_SOURCE_SOURCE_1 = 0x1
	// Address Comparator 15 matched
	ROMC_ROMPATCHSR_SOURCE_SOURCE_15 = 0xf
	// Position of SW field.
	ROMC_ROMPATCHSR_SW_Pos = 0x11
	// Bit mask of SW field.
	ROMC_ROMPATCHSR_SW_Msk = 0x20000
	// Bit SW.
	ROMC_ROMPATCHSR_SW = 0x20000
	// no event or comparator collisions
	ROMC_ROMPATCHSR_SW_SW_0 = 0x0
	// a collision has occurred
	ROMC_ROMPATCHSR_SW_SW_1 = 0x1
)

// Constants for LPUART1: LPUART
const (
	// VERID: Version ID Register
	// Position of FEATURE field.
	LPUART_VERID_FEATURE_Pos = 0x0
	// Bit mask of FEATURE field.
	LPUART_VERID_FEATURE_Msk = 0xffff
	// Standard feature set.
	LPUART_VERID_FEATURE_FEATURE_1 = 0x1
	// Standard feature set with MODEM/IrDA support.
	LPUART_VERID_FEATURE_FEATURE_3 = 0x3
	// Position of MINOR field.
	LPUART_VERID_MINOR_Pos = 0x10
	// Bit mask of MINOR field.
	LPUART_VERID_MINOR_Msk = 0xff0000
	// Position of MAJOR field.
	LPUART_VERID_MAJOR_Pos = 0x18
	// Bit mask of MAJOR field.
	LPUART_VERID_MAJOR_Msk = 0xff000000

	// PARAM: Parameter Register
	// Position of TXFIFO field.
	LPUART_PARAM_TXFIFO_Pos = 0x0
	// Bit mask of TXFIFO field.
	LPUART_PARAM_TXFIFO_Msk = 0xff
	// Position of RXFIFO field.
	LPUART_PARAM_RXFIFO_Pos = 0x8
	// Bit mask of RXFIFO field.
	LPUART_PARAM_RXFIFO_Msk = 0xff00

	// GLOBAL: LPUART Global Register
	// Position of RST field.
	LPUART_GLOBAL_RST_Pos = 0x1
	// Bit mask of RST field.
	LPUART_GLOBAL_RST_Msk = 0x2
	// Bit RST.
	LPUART_GLOBAL_RST = 0x2
	// Module is not reset.
	LPUART_GLOBAL_RST_RST_0 = 0x0
	// Module is reset.
	LPUART_GLOBAL_RST_RST_1 = 0x1

	// PINCFG: LPUART Pin Configuration Register
	// Position of TRGSEL field.
	LPUART_PINCFG_TRGSEL_Pos = 0x0
	// Bit mask of TRGSEL field.
	LPUART_PINCFG_TRGSEL_Msk = 0x3
	// Input trigger is disabled.
	LPUART_PINCFG_TRGSEL_TRGSEL_0 = 0x0
	// Input trigger is used instead of RXD pin input.
	LPUART_PINCFG_TRGSEL_TRGSEL_1 = 0x1
	// Input trigger is used instead of CTS_B pin input.
	LPUART_PINCFG_TRGSEL_TRGSEL_2 = 0x2
	// Input trigger is used to modulate the TXD pin output. The TXD pin output (after TXINV configuration) is ANDed with the input trigger.
	LPUART_PINCFG_TRGSEL_TRGSEL_3 = 0x3

	// BAUD: LPUART Baud Rate Register
	// Position of SBR field.
	LPUART_BAUD_SBR_Pos = 0x0
	// Bit mask of SBR field.
	LPUART_BAUD_SBR_Msk = 0x1fff
	// Position of SBNS field.
	LPUART_BAUD_SBNS_Pos = 0xd
	// Bit mask of SBNS field.
	LPUART_BAUD_SBNS_Msk = 0x2000
	// Bit SBNS.
	LPUART_BAUD_SBNS = 0x2000
	// One stop bit.
	LPUART_BAUD_SBNS_SBNS_0 = 0x0
	// Two stop bits.
	LPUART_BAUD_SBNS_SBNS_1 = 0x1
	// Position of RXEDGIE field.
	LPUART_BAUD_RXEDGIE_Pos = 0xe
	// Bit mask of RXEDGIE field.
	LPUART_BAUD_RXEDGIE_Msk = 0x4000
	// Bit RXEDGIE.
	LPUART_BAUD_RXEDGIE = 0x4000
	// Hardware interrupts from STAT[RXEDGIF] are disabled.
	LPUART_BAUD_RXEDGIE_RXEDGIE_0 = 0x0
	// Hardware interrupt is requested when STAT[RXEDGIF] flag is 1.
	LPUART_BAUD_RXEDGIE_RXEDGIE_1 = 0x1
	// Position of LBKDIE field.
	LPUART_BAUD_LBKDIE_Pos = 0xf
	// Bit mask of LBKDIE field.
	LPUART_BAUD_LBKDIE_Msk = 0x8000
	// Bit LBKDIE.
	LPUART_BAUD_LBKDIE = 0x8000
	// Hardware interrupts from STAT[LBKDIF] flag are disabled (use polling).
	LPUART_BAUD_LBKDIE_LBKDIE_0 = 0x0
	// Hardware interrupt requested when STAT[LBKDIF] flag is 1.
	LPUART_BAUD_LBKDIE_LBKDIE_1 = 0x1
	// Position of RESYNCDIS field.
	LPUART_BAUD_RESYNCDIS_Pos = 0x10
	// Bit mask of RESYNCDIS field.
	LPUART_BAUD_RESYNCDIS_Msk = 0x10000
	// Bit RESYNCDIS.
	LPUART_BAUD_RESYNCDIS = 0x10000
	// Resynchronization during received data word is supported
	LPUART_BAUD_RESYNCDIS_RESYNCDIS_0 = 0x0
	// Resynchronization during received data word is disabled
	LPUART_BAUD_RESYNCDIS_RESYNCDIS_1 = 0x1
	// Position of BOTHEDGE field.
	LPUART_BAUD_BOTHEDGE_Pos = 0x11
	// Bit mask of BOTHEDGE field.
	LPUART_BAUD_BOTHEDGE_Msk = 0x20000
	// Bit BOTHEDGE.
	LPUART_BAUD_BOTHEDGE = 0x20000
	// Receiver samples input data using the rising edge of the baud rate clock.
	LPUART_BAUD_BOTHEDGE_BOTHEDGE_0 = 0x0
	// Receiver samples input data using the rising and falling edge of the baud rate clock.
	LPUART_BAUD_BOTHEDGE_BOTHEDGE_1 = 0x1
	// Position of MATCFG field.
	LPUART_BAUD_MATCFG_Pos = 0x12
	// Bit mask of MATCFG field.
	LPUART_BAUD_MATCFG_Msk = 0xc0000
	// Address Match Wakeup
	LPUART_BAUD_MATCFG_MATCFG_0 = 0x0
	// Idle Match Wakeup
	LPUART_BAUD_MATCFG_MATCFG_1 = 0x1
	// Match On and Match Off
	LPUART_BAUD_MATCFG_MATCFG_2 = 0x2
	// Enables RWU on Data Match and Match On/Off for transmitter CTS input
	LPUART_BAUD_MATCFG_MATCFG_3 = 0x3
	// Position of RIDMAE field.
	LPUART_BAUD_RIDMAE_Pos = 0x14
	// Bit mask of RIDMAE field.
	LPUART_BAUD_RIDMAE_Msk = 0x100000
	// Bit RIDMAE.
	LPUART_BAUD_RIDMAE = 0x100000
	// DMA request disabled.
	LPUART_BAUD_RIDMAE_RIDMAE_0 = 0x0
	// DMA request enabled.
	LPUART_BAUD_RIDMAE_RIDMAE_1 = 0x1
	// Position of RDMAE field.
	LPUART_BAUD_RDMAE_Pos = 0x15
	// Bit mask of RDMAE field.
	LPUART_BAUD_RDMAE_Msk = 0x200000
	// Bit RDMAE.
	LPUART_BAUD_RDMAE = 0x200000
	// DMA request disabled.
	LPUART_BAUD_RDMAE_RDMAE_0 = 0x0
	// DMA request enabled.
	LPUART_BAUD_RDMAE_RDMAE_1 = 0x1
	// Position of TDMAE field.
	LPUART_BAUD_TDMAE_Pos = 0x17
	// Bit mask of TDMAE field.
	LPUART_BAUD_TDMAE_Msk = 0x800000
	// Bit TDMAE.
	LPUART_BAUD_TDMAE = 0x800000
	// DMA request disabled.
	LPUART_BAUD_TDMAE_TDMAE_0 = 0x0
	// DMA request enabled.
	LPUART_BAUD_TDMAE_TDMAE_1 = 0x1
	// Position of OSR field.
	LPUART_BAUD_OSR_Pos = 0x18
	// Bit mask of OSR field.
	LPUART_BAUD_OSR_Msk = 0x1f000000
	// Writing 0 to this field will result in an oversampling ratio of 16
	LPUART_BAUD_OSR_OSR_0 = 0x0
	// Oversampling ratio of 4, requires BOTHEDGE to be set.
	LPUART_BAUD_OSR_OSR_3 = 0x3
	// Oversampling ratio of 5, requires BOTHEDGE to be set.
	LPUART_BAUD_OSR_OSR_4 = 0x4
	// Oversampling ratio of 6, requires BOTHEDGE to be set.
	LPUART_BAUD_OSR_OSR_5 = 0x5
	// Oversampling ratio of 7, requires BOTHEDGE to be set.
	LPUART_BAUD_OSR_OSR_6 = 0x6
	// Oversampling ratio of 8.
	LPUART_BAUD_OSR_OSR_7 = 0x7
	// Oversampling ratio of 9.
	LPUART_BAUD_OSR_OSR_8 = 0x8
	// Oversampling ratio of 10.
	LPUART_BAUD_OSR_OSR_9 = 0x9
	// Oversampling ratio of 11.
	LPUART_BAUD_OSR_OSR_10 = 0xa
	// Oversampling ratio of 12.
	LPUART_BAUD_OSR_OSR_11 = 0xb
	// Oversampling ratio of 13.
	LPUART_BAUD_OSR_OSR_12 = 0xc
	// Oversampling ratio of 14.
	LPUART_BAUD_OSR_OSR_13 = 0xd
	// Oversampling ratio of 15.
	LPUART_BAUD_OSR_OSR_14 = 0xe
	// Oversampling ratio of 16.
	LPUART_BAUD_OSR_OSR_15 = 0xf
	// Oversampling ratio of 17.
	LPUART_BAUD_OSR_OSR_16 = 0x10
	// Oversampling ratio of 18.
	LPUART_BAUD_OSR_OSR_17 = 0x11
	// Oversampling ratio of 19.
	LPUART_BAUD_OSR_OSR_18 = 0x12
	// Oversampling ratio of 20.
	LPUART_BAUD_OSR_OSR_19 = 0x13
	// Oversampling ratio of 21.
	LPUART_BAUD_OSR_OSR_20 = 0x14
	// Oversampling ratio of 22.
	LPUART_BAUD_OSR_OSR_21 = 0x15
	// Oversampling ratio of 23.
	LPUART_BAUD_OSR_OSR_22 = 0x16
	// Oversampling ratio of 24.
	LPUART_BAUD_OSR_OSR_23 = 0x17
	// Oversampling ratio of 25.
	LPUART_BAUD_OSR_OSR_24 = 0x18
	// Oversampling ratio of 26.
	LPUART_BAUD_OSR_OSR_25 = 0x19
	// Oversampling ratio of 27.
	LPUART_BAUD_OSR_OSR_26 = 0x1a
	// Oversampling ratio of 28.
	LPUART_BAUD_OSR_OSR_27 = 0x1b
	// Oversampling ratio of 29.
	LPUART_BAUD_OSR_OSR_28 = 0x1c
	// Oversampling ratio of 30.
	LPUART_BAUD_OSR_OSR_29 = 0x1d
	// Oversampling ratio of 31.
	LPUART_BAUD_OSR_OSR_30 = 0x1e
	// Oversampling ratio of 32.
	LPUART_BAUD_OSR_OSR_31 = 0x1f
	// Position of M10 field.
	LPUART_BAUD_M10_Pos = 0x1d
	// Bit mask of M10 field.
	LPUART_BAUD_M10_Msk = 0x20000000
	// Bit M10.
	LPUART_BAUD_M10 = 0x20000000
	// Receiver and transmitter use 7-bit to 9-bit data characters.
	LPUART_BAUD_M10_M10_0 = 0x0
	// Receiver and transmitter use 10-bit data characters.
	LPUART_BAUD_M10_M10_1 = 0x1
	// Position of MAEN2 field.
	LPUART_BAUD_MAEN2_Pos = 0x1e
	// Bit mask of MAEN2 field.
	LPUART_BAUD_MAEN2_Msk = 0x40000000
	// Bit MAEN2.
	LPUART_BAUD_MAEN2 = 0x40000000
	// Normal operation.
	LPUART_BAUD_MAEN2_MAEN2_0 = 0x0
	// Enables automatic address matching or data matching mode for MATCH[MA2].
	LPUART_BAUD_MAEN2_MAEN2_1 = 0x1
	// Position of MAEN1 field.
	LPUART_BAUD_MAEN1_Pos = 0x1f
	// Bit mask of MAEN1 field.
	LPUART_BAUD_MAEN1_Msk = 0x80000000
	// Bit MAEN1.
	LPUART_BAUD_MAEN1 = 0x80000000
	// Normal operation.
	LPUART_BAUD_MAEN1_MAEN1_0 = 0x0
	// Enables automatic address matching or data matching mode for MATCH[MA1].
	LPUART_BAUD_MAEN1_MAEN1_1 = 0x1

	// STAT: LPUART Status Register
	// Position of MA2F field.
	LPUART_STAT_MA2F_Pos = 0xe
	// Bit mask of MA2F field.
	LPUART_STAT_MA2F_Msk = 0x4000
	// Bit MA2F.
	LPUART_STAT_MA2F = 0x4000
	// Received data is not equal to MA2
	LPUART_STAT_MA2F_MA2F_0 = 0x0
	// Received data is equal to MA2
	LPUART_STAT_MA2F_MA2F_1 = 0x1
	// Position of MA1F field.
	LPUART_STAT_MA1F_Pos = 0xf
	// Bit mask of MA1F field.
	LPUART_STAT_MA1F_Msk = 0x8000
	// Bit MA1F.
	LPUART_STAT_MA1F = 0x8000
	// Received data is not equal to MA1
	LPUART_STAT_MA1F_MA1F_0 = 0x0
	// Received data is equal to MA1
	LPUART_STAT_MA1F_MA1F_1 = 0x1
	// Position of PF field.
	LPUART_STAT_PF_Pos = 0x10
	// Bit mask of PF field.
	LPUART_STAT_PF_Msk = 0x10000
	// Bit PF.
	LPUART_STAT_PF = 0x10000
	// No parity error.
	LPUART_STAT_PF_PF_0 = 0x0
	// Parity error.
	LPUART_STAT_PF_PF_1 = 0x1
	// Position of FE field.
	LPUART_STAT_FE_Pos = 0x11
	// Bit mask of FE field.
	LPUART_STAT_FE_Msk = 0x20000
	// Bit FE.
	LPUART_STAT_FE = 0x20000
	// No framing error detected. This does not guarantee the framing is correct.
	LPUART_STAT_FE_FE_0 = 0x0
	// Framing error.
	LPUART_STAT_FE_FE_1 = 0x1
	// Position of NF field.
	LPUART_STAT_NF_Pos = 0x12
	// Bit mask of NF field.
	LPUART_STAT_NF_Msk = 0x40000
	// Bit NF.
	LPUART_STAT_NF = 0x40000
	// No noise detected.
	LPUART_STAT_NF_NF_0 = 0x0
	// Noise detected in the received character in the DATA register.
	LPUART_STAT_NF_NF_1 = 0x1
	// Position of OR field.
	LPUART_STAT_OR_Pos = 0x13
	// Bit mask of OR field.
	LPUART_STAT_OR_Msk = 0x80000
	// Bit OR.
	LPUART_STAT_OR = 0x80000
	// No overrun.
	LPUART_STAT_OR_OR_0 = 0x0
	// Receive overrun (new LPUART data lost).
	LPUART_STAT_OR_OR_1 = 0x1
	// Position of IDLE field.
	LPUART_STAT_IDLE_Pos = 0x14
	// Bit mask of IDLE field.
	LPUART_STAT_IDLE_Msk = 0x100000
	// Bit IDLE.
	LPUART_STAT_IDLE = 0x100000
	// No idle line detected.
	LPUART_STAT_IDLE_IDLE_0 = 0x0
	// Idle line was detected.
	LPUART_STAT_IDLE_IDLE_1 = 0x1
	// Position of RDRF field.
	LPUART_STAT_RDRF_Pos = 0x15
	// Bit mask of RDRF field.
	LPUART_STAT_RDRF_Msk = 0x200000
	// Bit RDRF.
	LPUART_STAT_RDRF = 0x200000
	// Receive data buffer empty.
	LPUART_STAT_RDRF_RDRF_0 = 0x0
	// Receive data buffer full.
	LPUART_STAT_RDRF_RDRF_1 = 0x1
	// Position of TC field.
	LPUART_STAT_TC_Pos = 0x16
	// Bit mask of TC field.
	LPUART_STAT_TC_Msk = 0x400000
	// Bit TC.
	LPUART_STAT_TC = 0x400000
	// Transmitter active (sending data, a preamble, or a break).
	LPUART_STAT_TC_TC_0 = 0x0
	// Transmitter idle (transmission activity complete).
	LPUART_STAT_TC_TC_1 = 0x1
	// Position of TDRE field.
	LPUART_STAT_TDRE_Pos = 0x17
	// Bit mask of TDRE field.
	LPUART_STAT_TDRE_Msk = 0x800000
	// Bit TDRE.
	LPUART_STAT_TDRE = 0x800000
	// Transmit data buffer full.
	LPUART_STAT_TDRE_TDRE_0 = 0x0
	// Transmit data buffer empty.
	LPUART_STAT_TDRE_TDRE_1 = 0x1
	// Position of RAF field.
	LPUART_STAT_RAF_Pos = 0x18
	// Bit mask of RAF field.
	LPUART_STAT_RAF_Msk = 0x1000000
	// Bit RAF.
	LPUART_STAT_RAF = 0x1000000
	// LPUART receiver idle waiting for a start bit.
	LPUART_STAT_RAF_RAF_0 = 0x0
	// LPUART receiver active (RXD input not idle).
	LPUART_STAT_RAF_RAF_1 = 0x1
	// Position of LBKDE field.
	LPUART_STAT_LBKDE_Pos = 0x19
	// Bit mask of LBKDE field.
	LPUART_STAT_LBKDE_Msk = 0x2000000
	// Bit LBKDE.
	LPUART_STAT_LBKDE = 0x2000000
	// LIN break detect is disabled, normal break character can be detected.
	LPUART_STAT_LBKDE_LBKDE_0 = 0x0
	// LIN break detect is enabled. LIN break character is detected at length of 11 bit times (if M = 0) or 12 (if M = 1) or 13 (M10 = 1).
	LPUART_STAT_LBKDE_LBKDE_1 = 0x1
	// Position of BRK13 field.
	LPUART_STAT_BRK13_Pos = 0x1a
	// Bit mask of BRK13 field.
	LPUART_STAT_BRK13_Msk = 0x4000000
	// Bit BRK13.
	LPUART_STAT_BRK13 = 0x4000000
	// Break character is transmitted with length of 9 to 13 bit times.
	LPUART_STAT_BRK13_BRK13_0 = 0x0
	// Break character is transmitted with length of 12 to 15 bit times.
	LPUART_STAT_BRK13_BRK13_1 = 0x1
	// Position of RWUID field.
	LPUART_STAT_RWUID_Pos = 0x1b
	// Bit mask of RWUID field.
	LPUART_STAT_RWUID_Msk = 0x8000000
	// Bit RWUID.
	LPUART_STAT_RWUID = 0x8000000
	// During receive standby state (RWU = 1), the IDLE bit does not get set upon detection of an idle character. During address match wakeup, the IDLE bit does not set when an address does not match.
	LPUART_STAT_RWUID_RWUID_0 = 0x0
	// During receive standby state (RWU = 1), the IDLE bit gets set upon detection of an idle character. During address match wakeup, the IDLE bit does set when an address does not match.
	LPUART_STAT_RWUID_RWUID_1 = 0x1
	// Position of RXINV field.
	LPUART_STAT_RXINV_Pos = 0x1c
	// Bit mask of RXINV field.
	LPUART_STAT_RXINV_Msk = 0x10000000
	// Bit RXINV.
	LPUART_STAT_RXINV = 0x10000000
	// Receive data not inverted.
	LPUART_STAT_RXINV_RXINV_0 = 0x0
	// Receive data inverted.
	LPUART_STAT_RXINV_RXINV_1 = 0x1
	// Position of MSBF field.
	LPUART_STAT_MSBF_Pos = 0x1d
	// Bit mask of MSBF field.
	LPUART_STAT_MSBF_Msk = 0x20000000
	// Bit MSBF.
	LPUART_STAT_MSBF = 0x20000000
	// LSB (bit0) is the first bit that is transmitted following the start bit. Further, the first bit received after the start bit is identified as bit0.
	LPUART_STAT_MSBF_MSBF_0 = 0x0
	// MSB (bit9, bit8, bit7 or bit6) is the first bit that is transmitted following the start bit depending on the setting of CTRL[M], CTRL[PE] and BAUD[M10]. Further, the first bit received after the start bit is identified as bit9, bit8, bit7 or bit6 depending on the setting of CTRL[M] and CTRL[PE].
	LPUART_STAT_MSBF_MSBF_1 = 0x1
	// Position of RXEDGIF field.
	LPUART_STAT_RXEDGIF_Pos = 0x1e
	// Bit mask of RXEDGIF field.
	LPUART_STAT_RXEDGIF_Msk = 0x40000000
	// Bit RXEDGIF.
	LPUART_STAT_RXEDGIF = 0x40000000
	// No active edge on the receive pin has occurred.
	LPUART_STAT_RXEDGIF_RXEDGIF_0 = 0x0
	// An active edge on the receive pin has occurred.
	LPUART_STAT_RXEDGIF_RXEDGIF_1 = 0x1
	// Position of LBKDIF field.
	LPUART_STAT_LBKDIF_Pos = 0x1f
	// Bit mask of LBKDIF field.
	LPUART_STAT_LBKDIF_Msk = 0x80000000
	// Bit LBKDIF.
	LPUART_STAT_LBKDIF = 0x80000000
	// No LIN break character has been detected.
	LPUART_STAT_LBKDIF_LBKDIF_0 = 0x0
	// LIN break character has been detected.
	LPUART_STAT_LBKDIF_LBKDIF_1 = 0x1

	// CTRL: LPUART Control Register
	// Position of PT field.
	LPUART_CTRL_PT_Pos = 0x0
	// Bit mask of PT field.
	LPUART_CTRL_PT_Msk = 0x1
	// Bit PT.
	LPUART_CTRL_PT = 0x1
	// Even parity.
	LPUART_CTRL_PT_PT_0 = 0x0
	// Odd parity.
	LPUART_CTRL_PT_PT_1 = 0x1
	// Position of PE field.
	LPUART_CTRL_PE_Pos = 0x1
	// Bit mask of PE field.
	LPUART_CTRL_PE_Msk = 0x2
	// Bit PE.
	LPUART_CTRL_PE = 0x2
	// No hardware parity generation or checking.
	LPUART_CTRL_PE_PE_0 = 0x0
	// Parity enabled.
	LPUART_CTRL_PE_PE_1 = 0x1
	// Position of ILT field.
	LPUART_CTRL_ILT_Pos = 0x2
	// Bit mask of ILT field.
	LPUART_CTRL_ILT_Msk = 0x4
	// Bit ILT.
	LPUART_CTRL_ILT = 0x4
	// Idle character bit count starts after start bit.
	LPUART_CTRL_ILT_ILT_0 = 0x0
	// Idle character bit count starts after stop bit.
	LPUART_CTRL_ILT_ILT_1 = 0x1
	// Position of WAKE field.
	LPUART_CTRL_WAKE_Pos = 0x3
	// Bit mask of WAKE field.
	LPUART_CTRL_WAKE_Msk = 0x8
	// Bit WAKE.
	LPUART_CTRL_WAKE = 0x8
	// Configures RWU for idle-line wakeup.
	LPUART_CTRL_WAKE_WAKE_0 = 0x0
	// Configures RWU with address-mark wakeup.
	LPUART_CTRL_WAKE_WAKE_1 = 0x1
	// Position of M field.
	LPUART_CTRL_M_Pos = 0x4
	// Bit mask of M field.
	LPUART_CTRL_M_Msk = 0x10
	// Bit M.
	LPUART_CTRL_M = 0x10
	// Receiver and transmitter use 8-bit data characters.
	LPUART_CTRL_M_M_0 = 0x0
	// Receiver and transmitter use 9-bit data characters.
	LPUART_CTRL_M_M_1 = 0x1
	// Position of RSRC field.
	LPUART_CTRL_RSRC_Pos = 0x5
	// Bit mask of RSRC field.
	LPUART_CTRL_RSRC_Msk = 0x20
	// Bit RSRC.
	LPUART_CTRL_RSRC = 0x20
	// Provided LOOPS is set, RSRC is cleared, selects internal loop back mode and the LPUART does not use the RXD pin.
	LPUART_CTRL_RSRC_RSRC_0 = 0x0
	// Single-wire LPUART mode where the TXD pin is connected to the transmitter output and receiver input.
	LPUART_CTRL_RSRC_RSRC_1 = 0x1
	// Position of DOZEEN field.
	LPUART_CTRL_DOZEEN_Pos = 0x6
	// Bit mask of DOZEEN field.
	LPUART_CTRL_DOZEEN_Msk = 0x40
	// Bit DOZEEN.
	LPUART_CTRL_DOZEEN = 0x40
	// LPUART is enabled in Doze mode.
	LPUART_CTRL_DOZEEN_DOZEEN_0 = 0x0
	// LPUART is disabled in Doze mode.
	LPUART_CTRL_DOZEEN_DOZEEN_1 = 0x1
	// Position of LOOPS field.
	LPUART_CTRL_LOOPS_Pos = 0x7
	// Bit mask of LOOPS field.
	LPUART_CTRL_LOOPS_Msk = 0x80
	// Bit LOOPS.
	LPUART_CTRL_LOOPS = 0x80
	// Normal operation - RXD and TXD use separate pins.
	LPUART_CTRL_LOOPS_LOOPS_0 = 0x0
	// Loop mode or single-wire mode where transmitter outputs are internally connected to receiver input (see RSRC bit).
	LPUART_CTRL_LOOPS_LOOPS_1 = 0x1
	// Position of IDLECFG field.
	LPUART_CTRL_IDLECFG_Pos = 0x8
	// Bit mask of IDLECFG field.
	LPUART_CTRL_IDLECFG_Msk = 0x700
	// 1 idle character
	LPUART_CTRL_IDLECFG_IDLECFG_0 = 0x0
	// 2 idle characters
	LPUART_CTRL_IDLECFG_IDLECFG_1 = 0x1
	// 4 idle characters
	LPUART_CTRL_IDLECFG_IDLECFG_2 = 0x2
	// 8 idle characters
	LPUART_CTRL_IDLECFG_IDLECFG_3 = 0x3
	// 16 idle characters
	LPUART_CTRL_IDLECFG_IDLECFG_4 = 0x4
	// 32 idle characters
	LPUART_CTRL_IDLECFG_IDLECFG_5 = 0x5
	// 64 idle characters
	LPUART_CTRL_IDLECFG_IDLECFG_6 = 0x6
	// 128 idle characters
	LPUART_CTRL_IDLECFG_IDLECFG_7 = 0x7
	// Position of M7 field.
	LPUART_CTRL_M7_Pos = 0xb
	// Bit mask of M7 field.
	LPUART_CTRL_M7_Msk = 0x800
	// Bit M7.
	LPUART_CTRL_M7 = 0x800
	// Receiver and transmitter use 8-bit to 10-bit data characters.
	LPUART_CTRL_M7_M7_0 = 0x0
	// Receiver and transmitter use 7-bit data characters.
	LPUART_CTRL_M7_M7_1 = 0x1
	// Position of MA2IE field.
	LPUART_CTRL_MA2IE_Pos = 0xe
	// Bit mask of MA2IE field.
	LPUART_CTRL_MA2IE_Msk = 0x4000
	// Bit MA2IE.
	LPUART_CTRL_MA2IE = 0x4000
	// MA2F interrupt disabled
	LPUART_CTRL_MA2IE_MA2IE_0 = 0x0
	// MA2F interrupt enabled
	LPUART_CTRL_MA2IE_MA2IE_1 = 0x1
	// Position of MA1IE field.
	LPUART_CTRL_MA1IE_Pos = 0xf
	// Bit mask of MA1IE field.
	LPUART_CTRL_MA1IE_Msk = 0x8000
	// Bit MA1IE.
	LPUART_CTRL_MA1IE = 0x8000
	// MA1F interrupt disabled
	LPUART_CTRL_MA1IE_MA1IE_0 = 0x0
	// MA1F interrupt enabled
	LPUART_CTRL_MA1IE_MA1IE_1 = 0x1
	// Position of SBK field.
	LPUART_CTRL_SBK_Pos = 0x10
	// Bit mask of SBK field.
	LPUART_CTRL_SBK_Msk = 0x10000
	// Bit SBK.
	LPUART_CTRL_SBK = 0x10000
	// Normal transmitter operation.
	LPUART_CTRL_SBK_SBK_0 = 0x0
	// Queue break character(s) to be sent.
	LPUART_CTRL_SBK_SBK_1 = 0x1
	// Position of RWU field.
	LPUART_CTRL_RWU_Pos = 0x11
	// Bit mask of RWU field.
	LPUART_CTRL_RWU_Msk = 0x20000
	// Bit RWU.
	LPUART_CTRL_RWU = 0x20000
	// Normal receiver operation.
	LPUART_CTRL_RWU_RWU_0 = 0x0
	// LPUART receiver in standby waiting for wakeup condition.
	LPUART_CTRL_RWU_RWU_1 = 0x1
	// Position of RE field.
	LPUART_CTRL_RE_Pos = 0x12
	// Bit mask of RE field.
	LPUART_CTRL_RE_Msk = 0x40000
	// Bit RE.
	LPUART_CTRL_RE = 0x40000
	// Receiver disabled.
	LPUART_CTRL_RE_RE_0 = 0x0
	// Receiver enabled.
	LPUART_CTRL_RE_RE_1 = 0x1
	// Position of TE field.
	LPUART_CTRL_TE_Pos = 0x13
	// Bit mask of TE field.
	LPUART_CTRL_TE_Msk = 0x80000
	// Bit TE.
	LPUART_CTRL_TE = 0x80000
	// Transmitter disabled.
	LPUART_CTRL_TE_TE_0 = 0x0
	// Transmitter enabled.
	LPUART_CTRL_TE_TE_1 = 0x1
	// Position of ILIE field.
	LPUART_CTRL_ILIE_Pos = 0x14
	// Bit mask of ILIE field.
	LPUART_CTRL_ILIE_Msk = 0x100000
	// Bit ILIE.
	LPUART_CTRL_ILIE = 0x100000
	// Hardware interrupts from IDLE disabled; use polling.
	LPUART_CTRL_ILIE_ILIE_0 = 0x0
	// Hardware interrupt requested when IDLE flag is 1.
	LPUART_CTRL_ILIE_ILIE_1 = 0x1
	// Position of RIE field.
	LPUART_CTRL_RIE_Pos = 0x15
	// Bit mask of RIE field.
	LPUART_CTRL_RIE_Msk = 0x200000
	// Bit RIE.
	LPUART_CTRL_RIE = 0x200000
	// Hardware interrupts from RDRF disabled; use polling.
	LPUART_CTRL_RIE_RIE_0 = 0x0
	// Hardware interrupt requested when RDRF flag is 1.
	LPUART_CTRL_RIE_RIE_1 = 0x1
	// Position of TCIE field.
	LPUART_CTRL_TCIE_Pos = 0x16
	// Bit mask of TCIE field.
	LPUART_CTRL_TCIE_Msk = 0x400000
	// Bit TCIE.
	LPUART_CTRL_TCIE = 0x400000
	// Hardware interrupts from TC disabled; use polling.
	LPUART_CTRL_TCIE_TCIE_0 = 0x0
	// Hardware interrupt requested when TC flag is 1.
	LPUART_CTRL_TCIE_TCIE_1 = 0x1
	// Position of TIE field.
	LPUART_CTRL_TIE_Pos = 0x17
	// Bit mask of TIE field.
	LPUART_CTRL_TIE_Msk = 0x800000
	// Bit TIE.
	LPUART_CTRL_TIE = 0x800000
	// Hardware interrupts from TDRE disabled; use polling.
	LPUART_CTRL_TIE_TIE_0 = 0x0
	// Hardware interrupt requested when TDRE flag is 1.
	LPUART_CTRL_TIE_TIE_1 = 0x1
	// Position of PEIE field.
	LPUART_CTRL_PEIE_Pos = 0x18
	// Bit mask of PEIE field.
	LPUART_CTRL_PEIE_Msk = 0x1000000
	// Bit PEIE.
	LPUART_CTRL_PEIE = 0x1000000
	// PF interrupts disabled; use polling).
	LPUART_CTRL_PEIE_PEIE_0 = 0x0
	// Hardware interrupt requested when PF is set.
	LPUART_CTRL_PEIE_PEIE_1 = 0x1
	// Position of FEIE field.
	LPUART_CTRL_FEIE_Pos = 0x19
	// Bit mask of FEIE field.
	LPUART_CTRL_FEIE_Msk = 0x2000000
	// Bit FEIE.
	LPUART_CTRL_FEIE = 0x2000000
	// FE interrupts disabled; use polling.
	LPUART_CTRL_FEIE_FEIE_0 = 0x0
	// Hardware interrupt requested when FE is set.
	LPUART_CTRL_FEIE_FEIE_1 = 0x1
	// Position of NEIE field.
	LPUART_CTRL_NEIE_Pos = 0x1a
	// Bit mask of NEIE field.
	LPUART_CTRL_NEIE_Msk = 0x4000000
	// Bit NEIE.
	LPUART_CTRL_NEIE = 0x4000000
	// NF interrupts disabled; use polling.
	LPUART_CTRL_NEIE_NEIE_0 = 0x0
	// Hardware interrupt requested when NF is set.
	LPUART_CTRL_NEIE_NEIE_1 = 0x1
	// Position of ORIE field.
	LPUART_CTRL_ORIE_Pos = 0x1b
	// Bit mask of ORIE field.
	LPUART_CTRL_ORIE_Msk = 0x8000000
	// Bit ORIE.
	LPUART_CTRL_ORIE = 0x8000000
	// OR interrupts disabled; use polling.
	LPUART_CTRL_ORIE_ORIE_0 = 0x0
	// Hardware interrupt requested when OR is set.
	LPUART_CTRL_ORIE_ORIE_1 = 0x1
	// Position of TXINV field.
	LPUART_CTRL_TXINV_Pos = 0x1c
	// Bit mask of TXINV field.
	LPUART_CTRL_TXINV_Msk = 0x10000000
	// Bit TXINV.
	LPUART_CTRL_TXINV = 0x10000000
	// Transmit data not inverted.
	LPUART_CTRL_TXINV_TXINV_0 = 0x0
	// Transmit data inverted.
	LPUART_CTRL_TXINV_TXINV_1 = 0x1
	// Position of TXDIR field.
	LPUART_CTRL_TXDIR_Pos = 0x1d
	// Bit mask of TXDIR field.
	LPUART_CTRL_TXDIR_Msk = 0x20000000
	// Bit TXDIR.
	LPUART_CTRL_TXDIR = 0x20000000
	// TXD pin is an input in single-wire mode.
	LPUART_CTRL_TXDIR_TXDIR_0 = 0x0
	// TXD pin is an output in single-wire mode.
	LPUART_CTRL_TXDIR_TXDIR_1 = 0x1
	// Position of R9T8 field.
	LPUART_CTRL_R9T8_Pos = 0x1e
	// Bit mask of R9T8 field.
	LPUART_CTRL_R9T8_Msk = 0x40000000
	// Bit R9T8.
	LPUART_CTRL_R9T8 = 0x40000000
	// Position of R8T9 field.
	LPUART_CTRL_R8T9_Pos = 0x1f
	// Bit mask of R8T9 field.
	LPUART_CTRL_R8T9_Msk = 0x80000000
	// Bit R8T9.
	LPUART_CTRL_R8T9 = 0x80000000

	// DATA: LPUART Data Register
	// Position of R0T0 field.
	LPUART_DATA_R0T0_Pos = 0x0
	// Bit mask of R0T0 field.
	LPUART_DATA_R0T0_Msk = 0x1
	// Bit R0T0.
	LPUART_DATA_R0T0 = 0x1
	// Position of R1T1 field.
	LPUART_DATA_R1T1_Pos = 0x1
	// Bit mask of R1T1 field.
	LPUART_DATA_R1T1_Msk = 0x2
	// Bit R1T1.
	LPUART_DATA_R1T1 = 0x2
	// Position of R2T2 field.
	LPUART_DATA_R2T2_Pos = 0x2
	// Bit mask of R2T2 field.
	LPUART_DATA_R2T2_Msk = 0x4
	// Bit R2T2.
	LPUART_DATA_R2T2 = 0x4
	// Position of R3T3 field.
	LPUART_DATA_R3T3_Pos = 0x3
	// Bit mask of R3T3 field.
	LPUART_DATA_R3T3_Msk = 0x8
	// Bit R3T3.
	LPUART_DATA_R3T3 = 0x8
	// Position of R4T4 field.
	LPUART_DATA_R4T4_Pos = 0x4
	// Bit mask of R4T4 field.
	LPUART_DATA_R4T4_Msk = 0x10
	// Bit R4T4.
	LPUART_DATA_R4T4 = 0x10
	// Position of R5T5 field.
	LPUART_DATA_R5T5_Pos = 0x5
	// Bit mask of R5T5 field.
	LPUART_DATA_R5T5_Msk = 0x20
	// Bit R5T5.
	LPUART_DATA_R5T5 = 0x20
	// Position of R6T6 field.
	LPUART_DATA_R6T6_Pos = 0x6
	// Bit mask of R6T6 field.
	LPUART_DATA_R6T6_Msk = 0x40
	// Bit R6T6.
	LPUART_DATA_R6T6 = 0x40
	// Position of R7T7 field.
	LPUART_DATA_R7T7_Pos = 0x7
	// Bit mask of R7T7 field.
	LPUART_DATA_R7T7_Msk = 0x80
	// Bit R7T7.
	LPUART_DATA_R7T7 = 0x80
	// Position of R8T8 field.
	LPUART_DATA_R8T8_Pos = 0x8
	// Bit mask of R8T8 field.
	LPUART_DATA_R8T8_Msk = 0x100
	// Bit R8T8.
	LPUART_DATA_R8T8 = 0x100
	// Position of R9T9 field.
	LPUART_DATA_R9T9_Pos = 0x9
	// Bit mask of R9T9 field.
	LPUART_DATA_R9T9_Msk = 0x200
	// Bit R9T9.
	LPUART_DATA_R9T9 = 0x200
	// Position of IDLINE field.
	LPUART_DATA_IDLINE_Pos = 0xb
	// Bit mask of IDLINE field.
	LPUART_DATA_IDLINE_Msk = 0x800
	// Bit IDLINE.
	LPUART_DATA_IDLINE = 0x800
	// Receiver was not idle before receiving this character.
	LPUART_DATA_IDLINE_IDLINE_0 = 0x0
	// Receiver was idle before receiving this character.
	LPUART_DATA_IDLINE_IDLINE_1 = 0x1
	// Position of RXEMPT field.
	LPUART_DATA_RXEMPT_Pos = 0xc
	// Bit mask of RXEMPT field.
	LPUART_DATA_RXEMPT_Msk = 0x1000
	// Bit RXEMPT.
	LPUART_DATA_RXEMPT = 0x1000
	// Receive buffer contains valid data.
	LPUART_DATA_RXEMPT_RXEMPT_0 = 0x0
	// Receive buffer is empty, data returned on read is not valid.
	LPUART_DATA_RXEMPT_RXEMPT_1 = 0x1
	// Position of FRETSC field.
	LPUART_DATA_FRETSC_Pos = 0xd
	// Bit mask of FRETSC field.
	LPUART_DATA_FRETSC_Msk = 0x2000
	// Bit FRETSC.
	LPUART_DATA_FRETSC = 0x2000
	// The dataword was received without a frame error on read, or transmit a normal character on write.
	LPUART_DATA_FRETSC_FRETSC_0 = 0x0
	// The dataword was received with a frame error, or transmit an idle or break character on transmit.
	LPUART_DATA_FRETSC_FRETSC_1 = 0x1
	// Position of PARITYE field.
	LPUART_DATA_PARITYE_Pos = 0xe
	// Bit mask of PARITYE field.
	LPUART_DATA_PARITYE_Msk = 0x4000
	// Bit PARITYE.
	LPUART_DATA_PARITYE = 0x4000
	// The dataword was received without a parity error.
	LPUART_DATA_PARITYE_PARITYE_0 = 0x0
	// The dataword was received with a parity error.
	LPUART_DATA_PARITYE_PARITYE_1 = 0x1
	// Position of NOISY field.
	LPUART_DATA_NOISY_Pos = 0xf
	// Bit mask of NOISY field.
	LPUART_DATA_NOISY_Msk = 0x8000
	// Bit NOISY.
	LPUART_DATA_NOISY = 0x8000
	// The dataword was received without noise.
	LPUART_DATA_NOISY_NOISY_0 = 0x0
	// The data was received with noise.
	LPUART_DATA_NOISY_NOISY_1 = 0x1

	// MATCH: LPUART Match Address Register
	// Position of MA1 field.
	LPUART_MATCH_MA1_Pos = 0x0
	// Bit mask of MA1 field.
	LPUART_MATCH_MA1_Msk = 0x3ff
	// Position of MA2 field.
	LPUART_MATCH_MA2_Pos = 0x10
	// Bit mask of MA2 field.
	LPUART_MATCH_MA2_Msk = 0x3ff0000

	// MODIR: LPUART Modem IrDA Register
	// Position of TXCTSE field.
	LPUART_MODIR_TXCTSE_Pos = 0x0
	// Bit mask of TXCTSE field.
	LPUART_MODIR_TXCTSE_Msk = 0x1
	// Bit TXCTSE.
	LPUART_MODIR_TXCTSE = 0x1
	// CTS has no effect on the transmitter.
	LPUART_MODIR_TXCTSE_TXCTSE_0 = 0x0
	// Enables clear-to-send operation. The transmitter checks the state of CTS each time it is ready to send a character. If CTS is asserted, the character is sent. If CTS is deasserted, the signal TXD remains in the mark state and transmission is delayed until CTS is asserted. Changes in CTS as a character is being sent do not affect its transmission.
	LPUART_MODIR_TXCTSE_TXCTSE_1 = 0x1
	// Position of TXRTSE field.
	LPUART_MODIR_TXRTSE_Pos = 0x1
	// Bit mask of TXRTSE field.
	LPUART_MODIR_TXRTSE_Msk = 0x2
	// Bit TXRTSE.
	LPUART_MODIR_TXRTSE = 0x2
	// The transmitter has no effect on RTS.
	LPUART_MODIR_TXRTSE_TXRTSE_0 = 0x0
	// When a character is placed into an empty transmitter data buffer , RTS asserts one bit time before the start bit is transmitted. RTS deasserts one bit time after all characters in the transmitter data buffer and shift register are completely sent, including the last stop bit.
	LPUART_MODIR_TXRTSE_TXRTSE_1 = 0x1
	// Position of TXRTSPOL field.
	LPUART_MODIR_TXRTSPOL_Pos = 0x2
	// Bit mask of TXRTSPOL field.
	LPUART_MODIR_TXRTSPOL_Msk = 0x4
	// Bit TXRTSPOL.
	LPUART_MODIR_TXRTSPOL = 0x4
	// Transmitter RTS is active low.
	LPUART_MODIR_TXRTSPOL_TXRTSPOL_0 = 0x0
	// Transmitter RTS is active high.
	LPUART_MODIR_TXRTSPOL_TXRTSPOL_1 = 0x1
	// Position of RXRTSE field.
	LPUART_MODIR_RXRTSE_Pos = 0x3
	// Bit mask of RXRTSE field.
	LPUART_MODIR_RXRTSE_Msk = 0x8
	// Bit RXRTSE.
	LPUART_MODIR_RXRTSE = 0x8
	// The receiver has no effect on RTS.
	LPUART_MODIR_RXRTSE_RXRTSE_0 = 0x0
	// RTS is deasserted if the receiver data register is full or a start bit has been detected that would cause the receiver data register to become full. RTS is asserted if the receiver data register is not full and has not detected a start bit that would cause the receiver data register to become full.
	LPUART_MODIR_RXRTSE_RXRTSE_1 = 0x1
	// Position of TXCTSC field.
	LPUART_MODIR_TXCTSC_Pos = 0x4
	// Bit mask of TXCTSC field.
	LPUART_MODIR_TXCTSC_Msk = 0x10
	// Bit TXCTSC.
	LPUART_MODIR_TXCTSC = 0x10
	// CTS input is sampled at the start of each character.
	LPUART_MODIR_TXCTSC_TXCTSC_0 = 0x0
	// CTS input is sampled when the transmitter is idle.
	LPUART_MODIR_TXCTSC_TXCTSC_1 = 0x1
	// Position of TXCTSSRC field.
	LPUART_MODIR_TXCTSSRC_Pos = 0x5
	// Bit mask of TXCTSSRC field.
	LPUART_MODIR_TXCTSSRC_Msk = 0x20
	// Bit TXCTSSRC.
	LPUART_MODIR_TXCTSSRC = 0x20
	// CTS input is the CTS_B pin.
	LPUART_MODIR_TXCTSSRC_TXCTSSRC_0 = 0x0
	// CTS input is the inverted Receiver Match result.
	LPUART_MODIR_TXCTSSRC_TXCTSSRC_1 = 0x1
	// Position of RTSWATER field.
	LPUART_MODIR_RTSWATER_Pos = 0x8
	// Bit mask of RTSWATER field.
	LPUART_MODIR_RTSWATER_Msk = 0x300
	// Position of TNP field.
	LPUART_MODIR_TNP_Pos = 0x10
	// Bit mask of TNP field.
	LPUART_MODIR_TNP_Msk = 0x30000
	// 1/OSR.
	LPUART_MODIR_TNP_TNP_0 = 0x0
	// 2/OSR.
	LPUART_MODIR_TNP_TNP_1 = 0x1
	// 3/OSR.
	LPUART_MODIR_TNP_TNP_2 = 0x2
	// 4/OSR.
	LPUART_MODIR_TNP_TNP_3 = 0x3
	// Position of IREN field.
	LPUART_MODIR_IREN_Pos = 0x12
	// Bit mask of IREN field.
	LPUART_MODIR_IREN_Msk = 0x40000
	// Bit IREN.
	LPUART_MODIR_IREN = 0x40000
	// IR disabled.
	LPUART_MODIR_IREN_IREN_0 = 0x0
	// IR enabled.
	LPUART_MODIR_IREN_IREN_1 = 0x1

	// FIFO: LPUART FIFO Register
	// Position of RXFIFOSIZE field.
	LPUART_FIFO_RXFIFOSIZE_Pos = 0x0
	// Bit mask of RXFIFOSIZE field.
	LPUART_FIFO_RXFIFOSIZE_Msk = 0x7
	// Receive FIFO/Buffer depth = 1 dataword.
	LPUART_FIFO_RXFIFOSIZE_RXFIFOSIZE_0 = 0x0
	// Receive FIFO/Buffer depth = 4 datawords.
	LPUART_FIFO_RXFIFOSIZE_RXFIFOSIZE_1 = 0x1
	// Receive FIFO/Buffer depth = 8 datawords.
	LPUART_FIFO_RXFIFOSIZE_RXFIFOSIZE_2 = 0x2
	// Receive FIFO/Buffer depth = 16 datawords.
	LPUART_FIFO_RXFIFOSIZE_RXFIFOSIZE_3 = 0x3
	// Receive FIFO/Buffer depth = 32 datawords.
	LPUART_FIFO_RXFIFOSIZE_RXFIFOSIZE_4 = 0x4
	// Receive FIFO/Buffer depth = 64 datawords.
	LPUART_FIFO_RXFIFOSIZE_RXFIFOSIZE_5 = 0x5
	// Receive FIFO/Buffer depth = 128 datawords.
	LPUART_FIFO_RXFIFOSIZE_RXFIFOSIZE_6 = 0x6
	// Receive FIFO/Buffer depth = 256 datawords.
	LPUART_FIFO_RXFIFOSIZE_RXFIFOSIZE_7 = 0x7
	// Position of RXFE field.
	LPUART_FIFO_RXFE_Pos = 0x3
	// Bit mask of RXFE field.
	LPUART_FIFO_RXFE_Msk = 0x8
	// Bit RXFE.
	LPUART_FIFO_RXFE = 0x8
	// Receive FIFO is not enabled. Buffer is depth 1.
	LPUART_FIFO_RXFE_RXFE_0 = 0x0
	// Receive FIFO is enabled. Buffer is depth indicted by RXFIFOSIZE.
	LPUART_FIFO_RXFE_RXFE_1 = 0x1
	// Position of TXFIFOSIZE field.
	LPUART_FIFO_TXFIFOSIZE_Pos = 0x4
	// Bit mask of TXFIFOSIZE field.
	LPUART_FIFO_TXFIFOSIZE_Msk = 0x70
	// Transmit FIFO/Buffer depth = 1 dataword.
	LPUART_FIFO_TXFIFOSIZE_TXFIFOSIZE_0 = 0x0
	// Transmit FIFO/Buffer depth = 4 datawords.
	LPUART_FIFO_TXFIFOSIZE_TXFIFOSIZE_1 = 0x1
	// Transmit FIFO/Buffer depth = 8 datawords.
	LPUART_FIFO_TXFIFOSIZE_TXFIFOSIZE_2 = 0x2
	// Transmit FIFO/Buffer depth = 16 datawords.
	LPUART_FIFO_TXFIFOSIZE_TXFIFOSIZE_3 = 0x3
	// Transmit FIFO/Buffer depth = 32 datawords.
	LPUART_FIFO_TXFIFOSIZE_TXFIFOSIZE_4 = 0x4
	// Transmit FIFO/Buffer depth = 64 datawords.
	LPUART_FIFO_TXFIFOSIZE_TXFIFOSIZE_5 = 0x5
	// Transmit FIFO/Buffer depth = 128 datawords.
	LPUART_FIFO_TXFIFOSIZE_TXFIFOSIZE_6 = 0x6
	// Transmit FIFO/Buffer depth = 256 datawords
	LPUART_FIFO_TXFIFOSIZE_TXFIFOSIZE_7 = 0x7
	// Position of TXFE field.
	LPUART_FIFO_TXFE_Pos = 0x7
	// Bit mask of TXFE field.
	LPUART_FIFO_TXFE_Msk = 0x80
	// Bit TXFE.
	LPUART_FIFO_TXFE = 0x80
	// Transmit FIFO is not enabled. Buffer is depth 1.
	LPUART_FIFO_TXFE_TXFE_0 = 0x0
	// Transmit FIFO is enabled. Buffer is depth indicated by TXFIFOSIZE.
	LPUART_FIFO_TXFE_TXFE_1 = 0x1
	// Position of RXUFE field.
	LPUART_FIFO_RXUFE_Pos = 0x8
	// Bit mask of RXUFE field.
	LPUART_FIFO_RXUFE_Msk = 0x100
	// Bit RXUFE.
	LPUART_FIFO_RXUFE = 0x100
	// RXUF flag does not generate an interrupt to the host.
	LPUART_FIFO_RXUFE_RXUFE_0 = 0x0
	// RXUF flag generates an interrupt to the host.
	LPUART_FIFO_RXUFE_RXUFE_1 = 0x1
	// Position of TXOFE field.
	LPUART_FIFO_TXOFE_Pos = 0x9
	// Bit mask of TXOFE field.
	LPUART_FIFO_TXOFE_Msk = 0x200
	// Bit TXOFE.
	LPUART_FIFO_TXOFE = 0x200
	// TXOF flag does not generate an interrupt to the host.
	LPUART_FIFO_TXOFE_TXOFE_0 = 0x0
	// TXOF flag generates an interrupt to the host.
	LPUART_FIFO_TXOFE_TXOFE_1 = 0x1
	// Position of RXIDEN field.
	LPUART_FIFO_RXIDEN_Pos = 0xa
	// Bit mask of RXIDEN field.
	LPUART_FIFO_RXIDEN_Msk = 0x1c00
	// Disable RDRF assertion due to partially filled FIFO when receiver is idle.
	LPUART_FIFO_RXIDEN_RXIDEN_0 = 0x0
	// Enable RDRF assertion due to partially filled FIFO when receiver is idle for 1 character.
	LPUART_FIFO_RXIDEN_RXIDEN_1 = 0x1
	// Enable RDRF assertion due to partially filled FIFO when receiver is idle for 2 characters.
	LPUART_FIFO_RXIDEN_RXIDEN_2 = 0x2
	// Enable RDRF assertion due to partially filled FIFO when receiver is idle for 4 characters.
	LPUART_FIFO_RXIDEN_RXIDEN_3 = 0x3
	// Enable RDRF assertion due to partially filled FIFO when receiver is idle for 8 characters.
	LPUART_FIFO_RXIDEN_RXIDEN_4 = 0x4
	// Enable RDRF assertion due to partially filled FIFO when receiver is idle for 16 characters.
	LPUART_FIFO_RXIDEN_RXIDEN_5 = 0x5
	// Enable RDRF assertion due to partially filled FIFO when receiver is idle for 32 characters.
	LPUART_FIFO_RXIDEN_RXIDEN_6 = 0x6
	// Enable RDRF assertion due to partially filled FIFO when receiver is idle for 64 characters.
	LPUART_FIFO_RXIDEN_RXIDEN_7 = 0x7
	// Position of RXFLUSH field.
	LPUART_FIFO_RXFLUSH_Pos = 0xe
	// Bit mask of RXFLUSH field.
	LPUART_FIFO_RXFLUSH_Msk = 0x4000
	// Bit RXFLUSH.
	LPUART_FIFO_RXFLUSH = 0x4000
	// No flush operation occurs.
	LPUART_FIFO_RXFLUSH_RXFLUSH_0 = 0x0
	// All data in the receive FIFO/buffer is cleared out.
	LPUART_FIFO_RXFLUSH_RXFLUSH_1 = 0x1
	// Position of TXFLUSH field.
	LPUART_FIFO_TXFLUSH_Pos = 0xf
	// Bit mask of TXFLUSH field.
	LPUART_FIFO_TXFLUSH_Msk = 0x8000
	// Bit TXFLUSH.
	LPUART_FIFO_TXFLUSH = 0x8000
	// No flush operation occurs.
	LPUART_FIFO_TXFLUSH_TXFLUSH_0 = 0x0
	// All data in the transmit FIFO/Buffer is cleared out.
	LPUART_FIFO_TXFLUSH_TXFLUSH_1 = 0x1
	// Position of RXUF field.
	LPUART_FIFO_RXUF_Pos = 0x10
	// Bit mask of RXUF field.
	LPUART_FIFO_RXUF_Msk = 0x10000
	// Bit RXUF.
	LPUART_FIFO_RXUF = 0x10000
	// No receive buffer underflow has occurred since the last time the flag was cleared.
	LPUART_FIFO_RXUF_RXUF_0 = 0x0
	// At least one receive buffer underflow has occurred since the last time the flag was cleared.
	LPUART_FIFO_RXUF_RXUF_1 = 0x1
	// Position of TXOF field.
	LPUART_FIFO_TXOF_Pos = 0x11
	// Bit mask of TXOF field.
	LPUART_FIFO_TXOF_Msk = 0x20000
	// Bit TXOF.
	LPUART_FIFO_TXOF = 0x20000
	// No transmit buffer overflow has occurred since the last time the flag was cleared.
	LPUART_FIFO_TXOF_TXOF_0 = 0x0
	// At least one transmit buffer overflow has occurred since the last time the flag was cleared.
	LPUART_FIFO_TXOF_TXOF_1 = 0x1
	// Position of RXEMPT field.
	LPUART_FIFO_RXEMPT_Pos = 0x16
	// Bit mask of RXEMPT field.
	LPUART_FIFO_RXEMPT_Msk = 0x400000
	// Bit RXEMPT.
	LPUART_FIFO_RXEMPT = 0x400000
	// Receive buffer is not empty.
	LPUART_FIFO_RXEMPT_RXEMPT_0 = 0x0
	// Receive buffer is empty.
	LPUART_FIFO_RXEMPT_RXEMPT_1 = 0x1
	// Position of TXEMPT field.
	LPUART_FIFO_TXEMPT_Pos = 0x17
	// Bit mask of TXEMPT field.
	LPUART_FIFO_TXEMPT_Msk = 0x800000
	// Bit TXEMPT.
	LPUART_FIFO_TXEMPT = 0x800000
	// Transmit buffer is not empty.
	LPUART_FIFO_TXEMPT_TXEMPT_0 = 0x0
	// Transmit buffer is empty.
	LPUART_FIFO_TXEMPT_TXEMPT_1 = 0x1

	// WATER: LPUART Watermark Register
	// Position of TXWATER field.
	LPUART_WATER_TXWATER_Pos = 0x0
	// Bit mask of TXWATER field.
	LPUART_WATER_TXWATER_Msk = 0x3
	// Position of TXCOUNT field.
	LPUART_WATER_TXCOUNT_Pos = 0x8
	// Bit mask of TXCOUNT field.
	LPUART_WATER_TXCOUNT_Msk = 0x700
	// Position of RXWATER field.
	LPUART_WATER_RXWATER_Pos = 0x10
	// Bit mask of RXWATER field.
	LPUART_WATER_RXWATER_Msk = 0x30000
	// Position of RXCOUNT field.
	LPUART_WATER_RXCOUNT_Pos = 0x18
	// Bit mask of RXCOUNT field.
	LPUART_WATER_RXCOUNT_Msk = 0x7000000
)

// Constants for LPSPI1: LPSPI
const (
	// VERID: Version ID Register
	// Position of FEATURE field.
	LPSPI_VERID_FEATURE_Pos = 0x0
	// Bit mask of FEATURE field.
	LPSPI_VERID_FEATURE_Msk = 0xffff
	// Standard feature set supporting a 32-bit shift register.
	LPSPI_VERID_FEATURE_FEATURE_4 = 0x4
	// Position of MINOR field.
	LPSPI_VERID_MINOR_Pos = 0x10
	// Bit mask of MINOR field.
	LPSPI_VERID_MINOR_Msk = 0xff0000
	// Position of MAJOR field.
	LPSPI_VERID_MAJOR_Pos = 0x18
	// Bit mask of MAJOR field.
	LPSPI_VERID_MAJOR_Msk = 0xff000000

	// PARAM: Parameter Register
	// Position of TXFIFO field.
	LPSPI_PARAM_TXFIFO_Pos = 0x0
	// Bit mask of TXFIFO field.
	LPSPI_PARAM_TXFIFO_Msk = 0xff
	// Position of RXFIFO field.
	LPSPI_PARAM_RXFIFO_Pos = 0x8
	// Bit mask of RXFIFO field.
	LPSPI_PARAM_RXFIFO_Msk = 0xff00
	// Position of PCSNUM field.
	LPSPI_PARAM_PCSNUM_Pos = 0x10
	// Bit mask of PCSNUM field.
	LPSPI_PARAM_PCSNUM_Msk = 0xff0000

	// CR: Control Register
	// Position of MEN field.
	LPSPI_CR_MEN_Pos = 0x0
	// Bit mask of MEN field.
	LPSPI_CR_MEN_Msk = 0x1
	// Bit MEN.
	LPSPI_CR_MEN = 0x1
	// Module is disabled
	LPSPI_CR_MEN_MEN_0 = 0x0
	// Module is enabled
	LPSPI_CR_MEN_MEN_1 = 0x1
	// Position of RST field.
	LPSPI_CR_RST_Pos = 0x1
	// Bit mask of RST field.
	LPSPI_CR_RST_Msk = 0x2
	// Bit RST.
	LPSPI_CR_RST = 0x2
	// Module is not reset
	LPSPI_CR_RST_RST_0 = 0x0
	// Module is reset
	LPSPI_CR_RST_RST_1 = 0x1
	// Position of DOZEN field.
	LPSPI_CR_DOZEN_Pos = 0x2
	// Bit mask of DOZEN field.
	LPSPI_CR_DOZEN_Msk = 0x4
	// Bit DOZEN.
	LPSPI_CR_DOZEN = 0x4
	// LPSPI module is enabled in Doze mode
	LPSPI_CR_DOZEN_DOZEN_0 = 0x0
	// LPSPI module is disabled in Doze mode
	LPSPI_CR_DOZEN_DOZEN_1 = 0x1
	// Position of DBGEN field.
	LPSPI_CR_DBGEN_Pos = 0x3
	// Bit mask of DBGEN field.
	LPSPI_CR_DBGEN_Msk = 0x8
	// Bit DBGEN.
	LPSPI_CR_DBGEN = 0x8
	// LPSPI module is disabled in debug mode
	LPSPI_CR_DBGEN_DBGEN_0 = 0x0
	// LPSPI module is enabled in debug mode
	LPSPI_CR_DBGEN_DBGEN_1 = 0x1
	// Position of RTF field.
	LPSPI_CR_RTF_Pos = 0x8
	// Bit mask of RTF field.
	LPSPI_CR_RTF_Msk = 0x100
	// Bit RTF.
	LPSPI_CR_RTF = 0x100
	// No effect
	LPSPI_CR_RTF_RTF_0 = 0x0
	// Transmit FIFO is reset
	LPSPI_CR_RTF_RTF_1 = 0x1
	// Position of RRF field.
	LPSPI_CR_RRF_Pos = 0x9
	// Bit mask of RRF field.
	LPSPI_CR_RRF_Msk = 0x200
	// Bit RRF.
	LPSPI_CR_RRF = 0x200
	// No effect
	LPSPI_CR_RRF_RRF_0 = 0x0
	// Receive FIFO is reset
	LPSPI_CR_RRF_RRF_1 = 0x1

	// SR: Status Register
	// Position of TDF field.
	LPSPI_SR_TDF_Pos = 0x0
	// Bit mask of TDF field.
	LPSPI_SR_TDF_Msk = 0x1
	// Bit TDF.
	LPSPI_SR_TDF = 0x1
	// Transmit data not requested
	LPSPI_SR_TDF_TDF_0 = 0x0
	// Transmit data is requested
	LPSPI_SR_TDF_TDF_1 = 0x1
	// Position of RDF field.
	LPSPI_SR_RDF_Pos = 0x1
	// Bit mask of RDF field.
	LPSPI_SR_RDF_Msk = 0x2
	// Bit RDF.
	LPSPI_SR_RDF = 0x2
	// Receive Data is not ready
	LPSPI_SR_RDF_RDF_0 = 0x0
	// Receive data is ready
	LPSPI_SR_RDF_RDF_1 = 0x1
	// Position of WCF field.
	LPSPI_SR_WCF_Pos = 0x8
	// Bit mask of WCF field.
	LPSPI_SR_WCF_Msk = 0x100
	// Bit WCF.
	LPSPI_SR_WCF = 0x100
	// Transfer of a received word has not yet completed
	LPSPI_SR_WCF_WCF_0 = 0x0
	// Transfer of a received word has completed
	LPSPI_SR_WCF_WCF_1 = 0x1
	// Position of FCF field.
	LPSPI_SR_FCF_Pos = 0x9
	// Bit mask of FCF field.
	LPSPI_SR_FCF_Msk = 0x200
	// Bit FCF.
	LPSPI_SR_FCF = 0x200
	// Frame transfer has not completed
	LPSPI_SR_FCF_FCF_0 = 0x0
	// Frame transfer has completed
	LPSPI_SR_FCF_FCF_1 = 0x1
	// Position of TCF field.
	LPSPI_SR_TCF_Pos = 0xa
	// Bit mask of TCF field.
	LPSPI_SR_TCF_Msk = 0x400
	// Bit TCF.
	LPSPI_SR_TCF = 0x400
	// All transfers have not completed
	LPSPI_SR_TCF_TCF_0 = 0x0
	// All transfers have completed
	LPSPI_SR_TCF_TCF_1 = 0x1
	// Position of TEF field.
	LPSPI_SR_TEF_Pos = 0xb
	// Bit mask of TEF field.
	LPSPI_SR_TEF_Msk = 0x800
	// Bit TEF.
	LPSPI_SR_TEF = 0x800
	// Transmit FIFO underrun has not occurred
	LPSPI_SR_TEF_TEF_0 = 0x0
	// Transmit FIFO underrun has occurred
	LPSPI_SR_TEF_TEF_1 = 0x1
	// Position of REF field.
	LPSPI_SR_REF_Pos = 0xc
	// Bit mask of REF field.
	LPSPI_SR_REF_Msk = 0x1000
	// Bit REF.
	LPSPI_SR_REF = 0x1000
	// Receive FIFO has not overflowed
	LPSPI_SR_REF_REF_0 = 0x0
	// Receive FIFO has overflowed
	LPSPI_SR_REF_REF_1 = 0x1
	// Position of DMF field.
	LPSPI_SR_DMF_Pos = 0xd
	// Bit mask of DMF field.
	LPSPI_SR_DMF_Msk = 0x2000
	// Bit DMF.
	LPSPI_SR_DMF = 0x2000
	// Have not received matching data
	LPSPI_SR_DMF_DMF_0 = 0x0
	// Have received matching data
	LPSPI_SR_DMF_DMF_1 = 0x1
	// Position of MBF field.
	LPSPI_SR_MBF_Pos = 0x18
	// Bit mask of MBF field.
	LPSPI_SR_MBF_Msk = 0x1000000
	// Bit MBF.
	LPSPI_SR_MBF = 0x1000000
	// LPSPI is idle
	LPSPI_SR_MBF_MBF_0 = 0x0
	// LPSPI is busy
	LPSPI_SR_MBF_MBF_1 = 0x1

	// IER: Interrupt Enable Register
	// Position of TDIE field.
	LPSPI_IER_TDIE_Pos = 0x0
	// Bit mask of TDIE field.
	LPSPI_IER_TDIE_Msk = 0x1
	// Bit TDIE.
	LPSPI_IER_TDIE = 0x1
	// Disabled
	LPSPI_IER_TDIE_TDIE_0 = 0x0
	// Enabled
	LPSPI_IER_TDIE_TDIE_1 = 0x1
	// Position of RDIE field.
	LPSPI_IER_RDIE_Pos = 0x1
	// Bit mask of RDIE field.
	LPSPI_IER_RDIE_Msk = 0x2
	// Bit RDIE.
	LPSPI_IER_RDIE = 0x2
	// Disabled
	LPSPI_IER_RDIE_RDIE_0 = 0x0
	// Enabled
	LPSPI_IER_RDIE_RDIE_1 = 0x1
	// Position of WCIE field.
	LPSPI_IER_WCIE_Pos = 0x8
	// Bit mask of WCIE field.
	LPSPI_IER_WCIE_Msk = 0x100
	// Bit WCIE.
	LPSPI_IER_WCIE = 0x100
	// Disabled
	LPSPI_IER_WCIE_WCIE_0 = 0x0
	// Enabled
	LPSPI_IER_WCIE_WCIE_1 = 0x1
	// Position of FCIE field.
	LPSPI_IER_FCIE_Pos = 0x9
	// Bit mask of FCIE field.
	LPSPI_IER_FCIE_Msk = 0x200
	// Bit FCIE.
	LPSPI_IER_FCIE = 0x200
	// Disabled
	LPSPI_IER_FCIE_FCIE_0 = 0x0
	// Enabled
	LPSPI_IER_FCIE_FCIE_1 = 0x1
	// Position of TCIE field.
	LPSPI_IER_TCIE_Pos = 0xa
	// Bit mask of TCIE field.
	LPSPI_IER_TCIE_Msk = 0x400
	// Bit TCIE.
	LPSPI_IER_TCIE = 0x400
	// Disabled
	LPSPI_IER_TCIE_TCIE_0 = 0x0
	// Enabled
	LPSPI_IER_TCIE_TCIE_1 = 0x1
	// Position of TEIE field.
	LPSPI_IER_TEIE_Pos = 0xb
	// Bit mask of TEIE field.
	LPSPI_IER_TEIE_Msk = 0x800
	// Bit TEIE.
	LPSPI_IER_TEIE = 0x800
	// Disabled
	LPSPI_IER_TEIE_TEIE_0 = 0x0
	// Enabled
	LPSPI_IER_TEIE_TEIE_1 = 0x1
	// Position of REIE field.
	LPSPI_IER_REIE_Pos = 0xc
	// Bit mask of REIE field.
	LPSPI_IER_REIE_Msk = 0x1000
	// Bit REIE.
	LPSPI_IER_REIE = 0x1000
	// Disabled
	LPSPI_IER_REIE_REIE_0 = 0x0
	// Enabled
	LPSPI_IER_REIE_REIE_1 = 0x1
	// Position of DMIE field.
	LPSPI_IER_DMIE_Pos = 0xd
	// Bit mask of DMIE field.
	LPSPI_IER_DMIE_Msk = 0x2000
	// Bit DMIE.
	LPSPI_IER_DMIE = 0x2000
	// Disabled
	LPSPI_IER_DMIE_DMIE_0 = 0x0
	// Enabled
	LPSPI_IER_DMIE_DMIE_1 = 0x1

	// DER: DMA Enable Register
	// Position of TDDE field.
	LPSPI_DER_TDDE_Pos = 0x0
	// Bit mask of TDDE field.
	LPSPI_DER_TDDE_Msk = 0x1
	// Bit TDDE.
	LPSPI_DER_TDDE = 0x1
	// DMA request is disabled
	LPSPI_DER_TDDE_TDDE_0 = 0x0
	// DMA request is enabled
	LPSPI_DER_TDDE_TDDE_1 = 0x1
	// Position of RDDE field.
	LPSPI_DER_RDDE_Pos = 0x1
	// Bit mask of RDDE field.
	LPSPI_DER_RDDE_Msk = 0x2
	// Bit RDDE.
	LPSPI_DER_RDDE = 0x2
	// DMA request is disabled
	LPSPI_DER_RDDE_RDDE_0 = 0x0
	// DMA request is enabled
	LPSPI_DER_RDDE_RDDE_1 = 0x1

	// CFGR0: Configuration Register 0
	// Position of HREN field.
	LPSPI_CFGR0_HREN_Pos = 0x0
	// Bit mask of HREN field.
	LPSPI_CFGR0_HREN_Msk = 0x1
	// Bit HREN.
	LPSPI_CFGR0_HREN = 0x1
	// Host request is disabled
	LPSPI_CFGR0_HREN_HREN_0 = 0x0
	// Host request is enabled
	LPSPI_CFGR0_HREN_HREN_1 = 0x1
	// Position of HRPOL field.
	LPSPI_CFGR0_HRPOL_Pos = 0x1
	// Bit mask of HRPOL field.
	LPSPI_CFGR0_HRPOL_Msk = 0x2
	// Bit HRPOL.
	LPSPI_CFGR0_HRPOL = 0x2
	// Active low
	LPSPI_CFGR0_HRPOL_HRPOL_0 = 0x0
	// Active high
	LPSPI_CFGR0_HRPOL_HRPOL_1 = 0x1
	// Position of HRSEL field.
	LPSPI_CFGR0_HRSEL_Pos = 0x2
	// Bit mask of HRSEL field.
	LPSPI_CFGR0_HRSEL_Msk = 0x4
	// Bit HRSEL.
	LPSPI_CFGR0_HRSEL = 0x4
	// Host request input is the LPSPI_HREQ pin
	LPSPI_CFGR0_HRSEL_HRSEL_0 = 0x0
	// Host request input is the input trigger
	LPSPI_CFGR0_HRSEL_HRSEL_1 = 0x1
	// Position of CIRFIFO field.
	LPSPI_CFGR0_CIRFIFO_Pos = 0x8
	// Bit mask of CIRFIFO field.
	LPSPI_CFGR0_CIRFIFO_Msk = 0x100
	// Bit CIRFIFO.
	LPSPI_CFGR0_CIRFIFO = 0x100
	// Circular FIFO is disabled
	LPSPI_CFGR0_CIRFIFO_CIRFIFO_0 = 0x0
	// Circular FIFO is enabled
	LPSPI_CFGR0_CIRFIFO_CIRFIFO_1 = 0x1
	// Position of RDMO field.
	LPSPI_CFGR0_RDMO_Pos = 0x9
	// Bit mask of RDMO field.
	LPSPI_CFGR0_RDMO_Msk = 0x200
	// Bit RDMO.
	LPSPI_CFGR0_RDMO = 0x200
	// Received data is stored in the receive FIFO as in normal operations
	LPSPI_CFGR0_RDMO_RDMO_0 = 0x0
	// Received data is discarded unless the Data Match Flag (DMF) is set
	LPSPI_CFGR0_RDMO_RDMO_1 = 0x1

	// CFGR1: Configuration Register 1
	// Position of MASTER field.
	LPSPI_CFGR1_MASTER_Pos = 0x0
	// Bit mask of MASTER field.
	LPSPI_CFGR1_MASTER_Msk = 0x1
	// Bit MASTER.
	LPSPI_CFGR1_MASTER = 0x1
	// Slave mode
	LPSPI_CFGR1_MASTER_MASTER_0 = 0x0
	// Master mode
	LPSPI_CFGR1_MASTER_MASTER_1 = 0x1
	// Position of SAMPLE field.
	LPSPI_CFGR1_SAMPLE_Pos = 0x1
	// Bit mask of SAMPLE field.
	LPSPI_CFGR1_SAMPLE_Msk = 0x2
	// Bit SAMPLE.
	LPSPI_CFGR1_SAMPLE = 0x2
	// Input data is sampled on SCK edge
	LPSPI_CFGR1_SAMPLE_SAMPLE_0 = 0x0
	// Input data is sampled on delayed SCK edge
	LPSPI_CFGR1_SAMPLE_SAMPLE_1 = 0x1
	// Position of AUTOPCS field.
	LPSPI_CFGR1_AUTOPCS_Pos = 0x2
	// Bit mask of AUTOPCS field.
	LPSPI_CFGR1_AUTOPCS_Msk = 0x4
	// Bit AUTOPCS.
	LPSPI_CFGR1_AUTOPCS = 0x4
	// Automatic PCS generation is disabled
	LPSPI_CFGR1_AUTOPCS_AUTOPCS_0 = 0x0
	// Automatic PCS generation is enabled
	LPSPI_CFGR1_AUTOPCS_AUTOPCS_1 = 0x1
	// Position of NOSTALL field.
	LPSPI_CFGR1_NOSTALL_Pos = 0x3
	// Bit mask of NOSTALL field.
	LPSPI_CFGR1_NOSTALL_Msk = 0x8
	// Bit NOSTALL.
	LPSPI_CFGR1_NOSTALL = 0x8
	// Transfers will stall when the transmit FIFO is empty or the receive FIFO is full
	LPSPI_CFGR1_NOSTALL_NOSTALL_0 = 0x0
	// Transfers will not stall, allowing transmit FIFO underruns or receive FIFO overruns to occur
	LPSPI_CFGR1_NOSTALL_NOSTALL_1 = 0x1
	// Position of PCSPOL field.
	LPSPI_CFGR1_PCSPOL_Pos = 0x8
	// Bit mask of PCSPOL field.
	LPSPI_CFGR1_PCSPOL_Msk = 0xf00
	// The Peripheral Chip Select pin PCSx is active low
	LPSPI_CFGR1_PCSPOL_PCSPOL_0 = 0x0
	// The Peripheral Chip Select pin PCSx is active high
	LPSPI_CFGR1_PCSPOL_PCSPOL_1 = 0x1
	// Position of MATCFG field.
	LPSPI_CFGR1_MATCFG_Pos = 0x10
	// Bit mask of MATCFG field.
	LPSPI_CFGR1_MATCFG_Msk = 0x70000
	// Match is disabled
	LPSPI_CFGR1_MATCFG_MATCFG_0 = 0x0
	// 010b - Match is enabled, if 1st data word equals MATCH0 OR MATCH1, i.e., (1st data word = MATCH0 + MATCH1)
	LPSPI_CFGR1_MATCFG_MATCFG_2 = 0x2
	// 011b - Match is enabled, if any data word equals MATCH0 OR MATCH1, i.e., (any data word = MATCH0 + MATCH1)
	LPSPI_CFGR1_MATCFG_MATCFG_3 = 0x3
	// 100b - Match is enabled, if 1st data word equals MATCH0 AND 2nd data word equals MATCH1, i.e., [(1st data word = MATCH0) * (2nd data word = MATCH1)]
	LPSPI_CFGR1_MATCFG_MATCFG_4 = 0x4
	// 101b - Match is enabled, if any data word equals MATCH0 AND the next data word equals MATCH1, i.e., [(any data word = MATCH0) * (next data word = MATCH1)]
	LPSPI_CFGR1_MATCFG_MATCFG_5 = 0x5
	// 110b - Match is enabled, if (1st data word AND MATCH1) equals (MATCH0 AND MATCH1), i.e., [(1st data word * MATCH1) = (MATCH0 * MATCH1)]
	LPSPI_CFGR1_MATCFG_MATCFG_6 = 0x6
	// 111b - Match is enabled, if (any data word AND MATCH1) equals (MATCH0 AND MATCH1), i.e., [(any data word * MATCH1) = (MATCH0 * MATCH1)]
	LPSPI_CFGR1_MATCFG_MATCFG_7 = 0x7
	// Position of PINCFG field.
	LPSPI_CFGR1_PINCFG_Pos = 0x18
	// Bit mask of PINCFG field.
	LPSPI_CFGR1_PINCFG_Msk = 0x3000000
	// SIN is used for input data and SOUT is used for output data
	LPSPI_CFGR1_PINCFG_PINCFG_0 = 0x0
	// SIN is used for both input and output data
	LPSPI_CFGR1_PINCFG_PINCFG_1 = 0x1
	// SOUT is used for both input and output data
	LPSPI_CFGR1_PINCFG_PINCFG_2 = 0x2
	// SOUT is used for input data and SIN is used for output data
	LPSPI_CFGR1_PINCFG_PINCFG_3 = 0x3
	// Position of OUTCFG field.
	LPSPI_CFGR1_OUTCFG_Pos = 0x1a
	// Bit mask of OUTCFG field.
	LPSPI_CFGR1_OUTCFG_Msk = 0x4000000
	// Bit OUTCFG.
	LPSPI_CFGR1_OUTCFG = 0x4000000
	// Output data retains last value when chip select is negated
	LPSPI_CFGR1_OUTCFG_OUTCFG_0 = 0x0
	// Output data is tristated when chip select is negated
	LPSPI_CFGR1_OUTCFG_OUTCFG_1 = 0x1
	// Position of PCSCFG field.
	LPSPI_CFGR1_PCSCFG_Pos = 0x1b
	// Bit mask of PCSCFG field.
	LPSPI_CFGR1_PCSCFG_Msk = 0x8000000
	// Bit PCSCFG.
	LPSPI_CFGR1_PCSCFG = 0x8000000
	// PCS[3:2] are enabled
	LPSPI_CFGR1_PCSCFG_PCSCFG_0 = 0x0
	// PCS[3:2] are disabled
	LPSPI_CFGR1_PCSCFG_PCSCFG_1 = 0x1

	// DMR0: Data Match Register 0
	// Position of MATCH0 field.
	LPSPI_DMR0_MATCH0_Pos = 0x0
	// Bit mask of MATCH0 field.
	LPSPI_DMR0_MATCH0_Msk = 0xffffffff

	// DMR1: Data Match Register 1
	// Position of MATCH1 field.
	LPSPI_DMR1_MATCH1_Pos = 0x0
	// Bit mask of MATCH1 field.
	LPSPI_DMR1_MATCH1_Msk = 0xffffffff

	// CCR: Clock Configuration Register
	// Position of SCKDIV field.
	LPSPI_CCR_SCKDIV_Pos = 0x0
	// Bit mask of SCKDIV field.
	LPSPI_CCR_SCKDIV_Msk = 0xff
	// Position of DBT field.
	LPSPI_CCR_DBT_Pos = 0x8
	// Bit mask of DBT field.
	LPSPI_CCR_DBT_Msk = 0xff00
	// Position of PCSSCK field.
	LPSPI_CCR_PCSSCK_Pos = 0x10
	// Bit mask of PCSSCK field.
	LPSPI_CCR_PCSSCK_Msk = 0xff0000
	// Position of SCKPCS field.
	LPSPI_CCR_SCKPCS_Pos = 0x18
	// Bit mask of SCKPCS field.
	LPSPI_CCR_SCKPCS_Msk = 0xff000000

	// FCR: FIFO Control Register
	// Position of TXWATER field.
	LPSPI_FCR_TXWATER_Pos = 0x0
	// Bit mask of TXWATER field.
	LPSPI_FCR_TXWATER_Msk = 0xf
	// Position of RXWATER field.
	LPSPI_FCR_RXWATER_Pos = 0x10
	// Bit mask of RXWATER field.
	LPSPI_FCR_RXWATER_Msk = 0xf0000

	// FSR: FIFO Status Register
	// Position of TXCOUNT field.
	LPSPI_FSR_TXCOUNT_Pos = 0x0
	// Bit mask of TXCOUNT field.
	LPSPI_FSR_TXCOUNT_Msk = 0x1f
	// Position of RXCOUNT field.
	LPSPI_FSR_RXCOUNT_Pos = 0x10
	// Bit mask of RXCOUNT field.
	LPSPI_FSR_RXCOUNT_Msk = 0x1f0000

	// TCR: Transmit Command Register
	// Position of FRAMESZ field.
	LPSPI_TCR_FRAMESZ_Pos = 0x0
	// Bit mask of FRAMESZ field.
	LPSPI_TCR_FRAMESZ_Msk = 0xfff
	// Position of WIDTH field.
	LPSPI_TCR_WIDTH_Pos = 0x10
	// Bit mask of WIDTH field.
	LPSPI_TCR_WIDTH_Msk = 0x30000
	// 1 bit transfer
	LPSPI_TCR_WIDTH_WIDTH_0 = 0x0
	// 2 bit transfer
	LPSPI_TCR_WIDTH_WIDTH_1 = 0x1
	// 4 bit transfer
	LPSPI_TCR_WIDTH_WIDTH_2 = 0x2
	// Position of TXMSK field.
	LPSPI_TCR_TXMSK_Pos = 0x12
	// Bit mask of TXMSK field.
	LPSPI_TCR_TXMSK_Msk = 0x40000
	// Bit TXMSK.
	LPSPI_TCR_TXMSK = 0x40000
	// Normal transfer
	LPSPI_TCR_TXMSK_TXMSK_0 = 0x0
	// Mask transmit data
	LPSPI_TCR_TXMSK_TXMSK_1 = 0x1
	// Position of RXMSK field.
	LPSPI_TCR_RXMSK_Pos = 0x13
	// Bit mask of RXMSK field.
	LPSPI_TCR_RXMSK_Msk = 0x80000
	// Bit RXMSK.
	LPSPI_TCR_RXMSK = 0x80000
	// Normal transfer
	LPSPI_TCR_RXMSK_RXMSK_0 = 0x0
	// Receive data is masked
	LPSPI_TCR_RXMSK_RXMSK_1 = 0x1
	// Position of CONTC field.
	LPSPI_TCR_CONTC_Pos = 0x14
	// Bit mask of CONTC field.
	LPSPI_TCR_CONTC_Msk = 0x100000
	// Bit CONTC.
	LPSPI_TCR_CONTC = 0x100000
	// Command word for start of new transfer
	LPSPI_TCR_CONTC_CONTC_0 = 0x0
	// Command word for continuing transfer
	LPSPI_TCR_CONTC_CONTC_1 = 0x1
	// Position of CONT field.
	LPSPI_TCR_CONT_Pos = 0x15
	// Bit mask of CONT field.
	LPSPI_TCR_CONT_Msk = 0x200000
	// Bit CONT.
	LPSPI_TCR_CONT = 0x200000
	// Continuous transfer is disabled
	LPSPI_TCR_CONT_CONT_0 = 0x0
	// Continuous transfer is enabled
	LPSPI_TCR_CONT_CONT_1 = 0x1
	// Position of BYSW field.
	LPSPI_TCR_BYSW_Pos = 0x16
	// Bit mask of BYSW field.
	LPSPI_TCR_BYSW_Msk = 0x400000
	// Bit BYSW.
	LPSPI_TCR_BYSW = 0x400000
	// Byte swap is disabled
	LPSPI_TCR_BYSW_BYSW_0 = 0x0
	// Byte swap is enabled
	LPSPI_TCR_BYSW_BYSW_1 = 0x1
	// Position of LSBF field.
	LPSPI_TCR_LSBF_Pos = 0x17
	// Bit mask of LSBF field.
	LPSPI_TCR_LSBF_Msk = 0x800000
	// Bit LSBF.
	LPSPI_TCR_LSBF = 0x800000
	// Data is transferred MSB first
	LPSPI_TCR_LSBF_LSBF_0 = 0x0
	// Data is transferred LSB first
	LPSPI_TCR_LSBF_LSBF_1 = 0x1
	// Position of PCS field.
	LPSPI_TCR_PCS_Pos = 0x18
	// Bit mask of PCS field.
	LPSPI_TCR_PCS_Msk = 0x3000000
	// Transfer using LPSPI_PCS[0]
	LPSPI_TCR_PCS_PCS_0 = 0x0
	// Transfer using LPSPI_PCS[1]
	LPSPI_TCR_PCS_PCS_1 = 0x1
	// Transfer using LPSPI_PCS[2]
	LPSPI_TCR_PCS_PCS_2 = 0x2
	// Transfer using LPSPI_PCS[3]
	LPSPI_TCR_PCS_PCS_3 = 0x3
	// Position of PRESCALE field.
	LPSPI_TCR_PRESCALE_Pos = 0x1b
	// Bit mask of PRESCALE field.
	LPSPI_TCR_PRESCALE_Msk = 0x38000000
	// Divide by 1
	LPSPI_TCR_PRESCALE_PRESCALE_0 = 0x0
	// Divide by 2
	LPSPI_TCR_PRESCALE_PRESCALE_1 = 0x1
	// Divide by 4
	LPSPI_TCR_PRESCALE_PRESCALE_2 = 0x2
	// Divide by 8
	LPSPI_TCR_PRESCALE_PRESCALE_3 = 0x3
	// Divide by 16
	LPSPI_TCR_PRESCALE_PRESCALE_4 = 0x4
	// Divide by 32
	LPSPI_TCR_PRESCALE_PRESCALE_5 = 0x5
	// Divide by 64
	LPSPI_TCR_PRESCALE_PRESCALE_6 = 0x6
	// Divide by 128
	LPSPI_TCR_PRESCALE_PRESCALE_7 = 0x7
	// Position of CPHA field.
	LPSPI_TCR_CPHA_Pos = 0x1e
	// Bit mask of CPHA field.
	LPSPI_TCR_CPHA_Msk = 0x40000000
	// Bit CPHA.
	LPSPI_TCR_CPHA = 0x40000000
	// Data is captured on the leading edge of SCK and changed on the following edge of SCK
	LPSPI_TCR_CPHA_CPHA_0 = 0x0
	// Data is changed on the leading edge of SCK and captured on the following edge of SCK
	LPSPI_TCR_CPHA_CPHA_1 = 0x1
	// Position of CPOL field.
	LPSPI_TCR_CPOL_Pos = 0x1f
	// Bit mask of CPOL field.
	LPSPI_TCR_CPOL_Msk = 0x80000000
	// Bit CPOL.
	LPSPI_TCR_CPOL = 0x80000000
	// The inactive state value of SCK is low
	LPSPI_TCR_CPOL_CPOL_0 = 0x0
	// The inactive state value of SCK is high
	LPSPI_TCR_CPOL_CPOL_1 = 0x1

	// TDR: Transmit Data Register
	// Position of DATA field.
	LPSPI_TDR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	LPSPI_TDR_DATA_Msk = 0xffffffff

	// RSR: Receive Status Register
	// Position of SOF field.
	LPSPI_RSR_SOF_Pos = 0x0
	// Bit mask of SOF field.
	LPSPI_RSR_SOF_Msk = 0x1
	// Bit SOF.
	LPSPI_RSR_SOF = 0x1
	// Subsequent data word received after LPSPI_PCS assertion
	LPSPI_RSR_SOF_SOF_0 = 0x0
	// First data word received after LPSPI_PCS assertion
	LPSPI_RSR_SOF_SOF_1 = 0x1
	// Position of RXEMPTY field.
	LPSPI_RSR_RXEMPTY_Pos = 0x1
	// Bit mask of RXEMPTY field.
	LPSPI_RSR_RXEMPTY_Msk = 0x2
	// Bit RXEMPTY.
	LPSPI_RSR_RXEMPTY = 0x2
	// RX FIFO is not empty
	LPSPI_RSR_RXEMPTY_RXEMPTY_0 = 0x0
	// RX FIFO is empty
	LPSPI_RSR_RXEMPTY_RXEMPTY_1 = 0x1

	// RDR: Receive Data Register
	// Position of DATA field.
	LPSPI_RDR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	LPSPI_RDR_DATA_Msk = 0xffffffff
)

// Constants for LPI2C1: LPI2C
const (
	// VERID: Version ID Register
	// Position of FEATURE field.
	LPI2C_VERID_FEATURE_Pos = 0x0
	// Bit mask of FEATURE field.
	LPI2C_VERID_FEATURE_Msk = 0xffff
	// Master only, with standard feature set
	LPI2C_VERID_FEATURE_FEATURE_2 = 0x2
	// Master and slave, with standard feature set
	LPI2C_VERID_FEATURE_FEATURE_3 = 0x3
	// Position of MINOR field.
	LPI2C_VERID_MINOR_Pos = 0x10
	// Bit mask of MINOR field.
	LPI2C_VERID_MINOR_Msk = 0xff0000
	// Position of MAJOR field.
	LPI2C_VERID_MAJOR_Pos = 0x18
	// Bit mask of MAJOR field.
	LPI2C_VERID_MAJOR_Msk = 0xff000000

	// PARAM: Parameter Register
	// Position of MTXFIFO field.
	LPI2C_PARAM_MTXFIFO_Pos = 0x0
	// Bit mask of MTXFIFO field.
	LPI2C_PARAM_MTXFIFO_Msk = 0xf
	// Position of MRXFIFO field.
	LPI2C_PARAM_MRXFIFO_Pos = 0x8
	// Bit mask of MRXFIFO field.
	LPI2C_PARAM_MRXFIFO_Msk = 0xf00

	// MCR: Master Control Register
	// Position of MEN field.
	LPI2C_MCR_MEN_Pos = 0x0
	// Bit mask of MEN field.
	LPI2C_MCR_MEN_Msk = 0x1
	// Bit MEN.
	LPI2C_MCR_MEN = 0x1
	// Master logic is disabled
	LPI2C_MCR_MEN_MEN_0 = 0x0
	// Master logic is enabled
	LPI2C_MCR_MEN_MEN_1 = 0x1
	// Position of RST field.
	LPI2C_MCR_RST_Pos = 0x1
	// Bit mask of RST field.
	LPI2C_MCR_RST_Msk = 0x2
	// Bit RST.
	LPI2C_MCR_RST = 0x2
	// Master logic is not reset
	LPI2C_MCR_RST_RST_0 = 0x0
	// Master logic is reset
	LPI2C_MCR_RST_RST_1 = 0x1
	// Position of DOZEN field.
	LPI2C_MCR_DOZEN_Pos = 0x2
	// Bit mask of DOZEN field.
	LPI2C_MCR_DOZEN_Msk = 0x4
	// Bit DOZEN.
	LPI2C_MCR_DOZEN = 0x4
	// Master is enabled in Doze mode
	LPI2C_MCR_DOZEN_DOZEN_0 = 0x0
	// Master is disabled in Doze mode
	LPI2C_MCR_DOZEN_DOZEN_1 = 0x1
	// Position of DBGEN field.
	LPI2C_MCR_DBGEN_Pos = 0x3
	// Bit mask of DBGEN field.
	LPI2C_MCR_DBGEN_Msk = 0x8
	// Bit DBGEN.
	LPI2C_MCR_DBGEN = 0x8
	// Master is disabled in debug mode
	LPI2C_MCR_DBGEN_DBGEN_0 = 0x0
	// Master is enabled in debug mode
	LPI2C_MCR_DBGEN_DBGEN_1 = 0x1
	// Position of RTF field.
	LPI2C_MCR_RTF_Pos = 0x8
	// Bit mask of RTF field.
	LPI2C_MCR_RTF_Msk = 0x100
	// Bit RTF.
	LPI2C_MCR_RTF = 0x100
	// No effect
	LPI2C_MCR_RTF_RTF_0 = 0x0
	// Transmit FIFO is reset
	LPI2C_MCR_RTF_RTF_1 = 0x1
	// Position of RRF field.
	LPI2C_MCR_RRF_Pos = 0x9
	// Bit mask of RRF field.
	LPI2C_MCR_RRF_Msk = 0x200
	// Bit RRF.
	LPI2C_MCR_RRF = 0x200
	// No effect
	LPI2C_MCR_RRF_RRF_0 = 0x0
	// Receive FIFO is reset
	LPI2C_MCR_RRF_RRF_1 = 0x1

	// MSR: Master Status Register
	// Position of TDF field.
	LPI2C_MSR_TDF_Pos = 0x0
	// Bit mask of TDF field.
	LPI2C_MSR_TDF_Msk = 0x1
	// Bit TDF.
	LPI2C_MSR_TDF = 0x1
	// Transmit data is not requested
	LPI2C_MSR_TDF_TDF_0 = 0x0
	// Transmit data is requested
	LPI2C_MSR_TDF_TDF_1 = 0x1
	// Position of RDF field.
	LPI2C_MSR_RDF_Pos = 0x1
	// Bit mask of RDF field.
	LPI2C_MSR_RDF_Msk = 0x2
	// Bit RDF.
	LPI2C_MSR_RDF = 0x2
	// Receive Data is not ready
	LPI2C_MSR_RDF_RDF_0 = 0x0
	// Receive data is ready
	LPI2C_MSR_RDF_RDF_1 = 0x1
	// Position of EPF field.
	LPI2C_MSR_EPF_Pos = 0x8
	// Bit mask of EPF field.
	LPI2C_MSR_EPF_Msk = 0x100
	// Bit EPF.
	LPI2C_MSR_EPF = 0x100
	// Master has not generated a STOP or Repeated START condition
	LPI2C_MSR_EPF_EPF_0 = 0x0
	// Master has generated a STOP or Repeated START condition
	LPI2C_MSR_EPF_EPF_1 = 0x1
	// Position of SDF field.
	LPI2C_MSR_SDF_Pos = 0x9
	// Bit mask of SDF field.
	LPI2C_MSR_SDF_Msk = 0x200
	// Bit SDF.
	LPI2C_MSR_SDF = 0x200
	// Master has not generated a STOP condition
	LPI2C_MSR_SDF_SDF_0 = 0x0
	// Master has generated a STOP condition
	LPI2C_MSR_SDF_SDF_1 = 0x1
	// Position of NDF field.
	LPI2C_MSR_NDF_Pos = 0xa
	// Bit mask of NDF field.
	LPI2C_MSR_NDF_Msk = 0x400
	// Bit NDF.
	LPI2C_MSR_NDF = 0x400
	// Unexpected NACK was not detected
	LPI2C_MSR_NDF_NDF_0 = 0x0
	// Unexpected NACK was detected
	LPI2C_MSR_NDF_NDF_1 = 0x1
	// Position of ALF field.
	LPI2C_MSR_ALF_Pos = 0xb
	// Bit mask of ALF field.
	LPI2C_MSR_ALF_Msk = 0x800
	// Bit ALF.
	LPI2C_MSR_ALF = 0x800
	// Master has not lost arbitration
	LPI2C_MSR_ALF_ALF_0 = 0x0
	// Master has lost arbitration
	LPI2C_MSR_ALF_ALF_1 = 0x1
	// Position of FEF field.
	LPI2C_MSR_FEF_Pos = 0xc
	// Bit mask of FEF field.
	LPI2C_MSR_FEF_Msk = 0x1000
	// Bit FEF.
	LPI2C_MSR_FEF = 0x1000
	// No error
	LPI2C_MSR_FEF_FEF_0 = 0x0
	// Master sending or receiving data without a START condition
	LPI2C_MSR_FEF_FEF_1 = 0x1
	// Position of PLTF field.
	LPI2C_MSR_PLTF_Pos = 0xd
	// Bit mask of PLTF field.
	LPI2C_MSR_PLTF_Msk = 0x2000
	// Bit PLTF.
	LPI2C_MSR_PLTF = 0x2000
	// Pin low timeout has not occurred or is disabled
	LPI2C_MSR_PLTF_PLTF_0 = 0x0
	// Pin low timeout has occurred
	LPI2C_MSR_PLTF_PLTF_1 = 0x1
	// Position of DMF field.
	LPI2C_MSR_DMF_Pos = 0xe
	// Bit mask of DMF field.
	LPI2C_MSR_DMF_Msk = 0x4000
	// Bit DMF.
	LPI2C_MSR_DMF = 0x4000
	// Have not received matching data
	LPI2C_MSR_DMF_DMF_0 = 0x0
	// Have received matching data
	LPI2C_MSR_DMF_DMF_1 = 0x1
	// Position of MBF field.
	LPI2C_MSR_MBF_Pos = 0x18
	// Bit mask of MBF field.
	LPI2C_MSR_MBF_Msk = 0x1000000
	// Bit MBF.
	LPI2C_MSR_MBF = 0x1000000
	// I2C Master is idle
	LPI2C_MSR_MBF_MBF_0 = 0x0
	// I2C Master is busy
	LPI2C_MSR_MBF_MBF_1 = 0x1
	// Position of BBF field.
	LPI2C_MSR_BBF_Pos = 0x19
	// Bit mask of BBF field.
	LPI2C_MSR_BBF_Msk = 0x2000000
	// Bit BBF.
	LPI2C_MSR_BBF = 0x2000000
	// I2C Bus is idle
	LPI2C_MSR_BBF_BBF_0 = 0x0
	// I2C Bus is busy
	LPI2C_MSR_BBF_BBF_1 = 0x1

	// MIER: Master Interrupt Enable Register
	// Position of TDIE field.
	LPI2C_MIER_TDIE_Pos = 0x0
	// Bit mask of TDIE field.
	LPI2C_MIER_TDIE_Msk = 0x1
	// Bit TDIE.
	LPI2C_MIER_TDIE = 0x1
	// Disabled
	LPI2C_MIER_TDIE_TDIE_0 = 0x0
	// Enabled
	LPI2C_MIER_TDIE_TDIE_1 = 0x1
	// Position of RDIE field.
	LPI2C_MIER_RDIE_Pos = 0x1
	// Bit mask of RDIE field.
	LPI2C_MIER_RDIE_Msk = 0x2
	// Bit RDIE.
	LPI2C_MIER_RDIE = 0x2
	// Disabled
	LPI2C_MIER_RDIE_RDIE_0 = 0x0
	// Enabled
	LPI2C_MIER_RDIE_RDIE_1 = 0x1
	// Position of EPIE field.
	LPI2C_MIER_EPIE_Pos = 0x8
	// Bit mask of EPIE field.
	LPI2C_MIER_EPIE_Msk = 0x100
	// Bit EPIE.
	LPI2C_MIER_EPIE = 0x100
	// Disabled
	LPI2C_MIER_EPIE_EPIE_0 = 0x0
	// Enabled
	LPI2C_MIER_EPIE_EPIE_1 = 0x1
	// Position of SDIE field.
	LPI2C_MIER_SDIE_Pos = 0x9
	// Bit mask of SDIE field.
	LPI2C_MIER_SDIE_Msk = 0x200
	// Bit SDIE.
	LPI2C_MIER_SDIE = 0x200
	// Disabled
	LPI2C_MIER_SDIE_SDIE_0 = 0x0
	// Enabled
	LPI2C_MIER_SDIE_SDIE_1 = 0x1
	// Position of NDIE field.
	LPI2C_MIER_NDIE_Pos = 0xa
	// Bit mask of NDIE field.
	LPI2C_MIER_NDIE_Msk = 0x400
	// Bit NDIE.
	LPI2C_MIER_NDIE = 0x400
	// Disabled
	LPI2C_MIER_NDIE_NDIE_0 = 0x0
	// Enabled
	LPI2C_MIER_NDIE_NDIE_1 = 0x1
	// Position of ALIE field.
	LPI2C_MIER_ALIE_Pos = 0xb
	// Bit mask of ALIE field.
	LPI2C_MIER_ALIE_Msk = 0x800
	// Bit ALIE.
	LPI2C_MIER_ALIE = 0x800
	// Disabled
	LPI2C_MIER_ALIE_ALIE_0 = 0x0
	// Enabled
	LPI2C_MIER_ALIE_ALIE_1 = 0x1
	// Position of FEIE field.
	LPI2C_MIER_FEIE_Pos = 0xc
	// Bit mask of FEIE field.
	LPI2C_MIER_FEIE_Msk = 0x1000
	// Bit FEIE.
	LPI2C_MIER_FEIE = 0x1000
	// Enabled
	LPI2C_MIER_FEIE_FEIE_0 = 0x0
	// Disabled
	LPI2C_MIER_FEIE_FEIE_1 = 0x1
	// Position of PLTIE field.
	LPI2C_MIER_PLTIE_Pos = 0xd
	// Bit mask of PLTIE field.
	LPI2C_MIER_PLTIE_Msk = 0x2000
	// Bit PLTIE.
	LPI2C_MIER_PLTIE = 0x2000
	// Disabled
	LPI2C_MIER_PLTIE_PLTIE_0 = 0x0
	// Enabled
	LPI2C_MIER_PLTIE_PLTIE_1 = 0x1
	// Position of DMIE field.
	LPI2C_MIER_DMIE_Pos = 0xe
	// Bit mask of DMIE field.
	LPI2C_MIER_DMIE_Msk = 0x4000
	// Bit DMIE.
	LPI2C_MIER_DMIE = 0x4000
	// Disabled
	LPI2C_MIER_DMIE_DMIE_0 = 0x0
	// Enabled
	LPI2C_MIER_DMIE_DMIE_1 = 0x1

	// MDER: Master DMA Enable Register
	// Position of TDDE field.
	LPI2C_MDER_TDDE_Pos = 0x0
	// Bit mask of TDDE field.
	LPI2C_MDER_TDDE_Msk = 0x1
	// Bit TDDE.
	LPI2C_MDER_TDDE = 0x1
	// DMA request is disabled
	LPI2C_MDER_TDDE_TDDE_0 = 0x0
	// DMA request is enabled
	LPI2C_MDER_TDDE_TDDE_1 = 0x1
	// Position of RDDE field.
	LPI2C_MDER_RDDE_Pos = 0x1
	// Bit mask of RDDE field.
	LPI2C_MDER_RDDE_Msk = 0x2
	// Bit RDDE.
	LPI2C_MDER_RDDE = 0x2
	// DMA request is disabled
	LPI2C_MDER_RDDE_RDDE_0 = 0x0
	// DMA request is enabled
	LPI2C_MDER_RDDE_RDDE_1 = 0x1

	// MCFGR0: Master Configuration Register 0
	// Position of HREN field.
	LPI2C_MCFGR0_HREN_Pos = 0x0
	// Bit mask of HREN field.
	LPI2C_MCFGR0_HREN_Msk = 0x1
	// Bit HREN.
	LPI2C_MCFGR0_HREN = 0x1
	// Host request input is disabled
	LPI2C_MCFGR0_HREN_HREN_0 = 0x0
	// Host request input is enabled
	LPI2C_MCFGR0_HREN_HREN_1 = 0x1
	// Position of HRPOL field.
	LPI2C_MCFGR0_HRPOL_Pos = 0x1
	// Bit mask of HRPOL field.
	LPI2C_MCFGR0_HRPOL_Msk = 0x2
	// Bit HRPOL.
	LPI2C_MCFGR0_HRPOL = 0x2
	// Active low
	LPI2C_MCFGR0_HRPOL_HRPOL_0 = 0x0
	// Active high
	LPI2C_MCFGR0_HRPOL_HRPOL_1 = 0x1
	// Position of HRSEL field.
	LPI2C_MCFGR0_HRSEL_Pos = 0x2
	// Bit mask of HRSEL field.
	LPI2C_MCFGR0_HRSEL_Msk = 0x4
	// Bit HRSEL.
	LPI2C_MCFGR0_HRSEL = 0x4
	// Host request input is pin HREQ
	LPI2C_MCFGR0_HRSEL_HRSEL_0 = 0x0
	// Host request input is input trigger
	LPI2C_MCFGR0_HRSEL_HRSEL_1 = 0x1
	// Position of CIRFIFO field.
	LPI2C_MCFGR0_CIRFIFO_Pos = 0x8
	// Bit mask of CIRFIFO field.
	LPI2C_MCFGR0_CIRFIFO_Msk = 0x100
	// Bit CIRFIFO.
	LPI2C_MCFGR0_CIRFIFO = 0x100
	// Circular FIFO is disabled
	LPI2C_MCFGR0_CIRFIFO_CIRFIFO_0 = 0x0
	// Circular FIFO is enabled
	LPI2C_MCFGR0_CIRFIFO_CIRFIFO_1 = 0x1
	// Position of RDMO field.
	LPI2C_MCFGR0_RDMO_Pos = 0x9
	// Bit mask of RDMO field.
	LPI2C_MCFGR0_RDMO_Msk = 0x200
	// Bit RDMO.
	LPI2C_MCFGR0_RDMO = 0x200
	// Received data is stored in the receive FIFO
	LPI2C_MCFGR0_RDMO_RDMO_0 = 0x0
	// Received data is discarded unless the the Data Match Flag (MSR[DMF]) is set
	LPI2C_MCFGR0_RDMO_RDMO_1 = 0x1

	// MCFGR1: Master Configuration Register 1
	// Position of PRESCALE field.
	LPI2C_MCFGR1_PRESCALE_Pos = 0x0
	// Bit mask of PRESCALE field.
	LPI2C_MCFGR1_PRESCALE_Msk = 0x7
	// Divide by 1
	LPI2C_MCFGR1_PRESCALE_PRESCALE_0 = 0x0
	// Divide by 2
	LPI2C_MCFGR1_PRESCALE_PRESCALE_1 = 0x1
	// Divide by 4
	LPI2C_MCFGR1_PRESCALE_PRESCALE_2 = 0x2
	// Divide by 8
	LPI2C_MCFGR1_PRESCALE_PRESCALE_3 = 0x3
	// Divide by 16
	LPI2C_MCFGR1_PRESCALE_PRESCALE_4 = 0x4
	// Divide by 32
	LPI2C_MCFGR1_PRESCALE_PRESCALE_5 = 0x5
	// Divide by 64
	LPI2C_MCFGR1_PRESCALE_PRESCALE_6 = 0x6
	// Divide by 128
	LPI2C_MCFGR1_PRESCALE_PRESCALE_7 = 0x7
	// Position of AUTOSTOP field.
	LPI2C_MCFGR1_AUTOSTOP_Pos = 0x8
	// Bit mask of AUTOSTOP field.
	LPI2C_MCFGR1_AUTOSTOP_Msk = 0x100
	// Bit AUTOSTOP.
	LPI2C_MCFGR1_AUTOSTOP = 0x100
	// No effect
	LPI2C_MCFGR1_AUTOSTOP_AUTOSTOP_0 = 0x0
	// STOP condition is automatically generated whenever the transmit FIFO is empty and the LPI2C master is busy
	LPI2C_MCFGR1_AUTOSTOP_AUTOSTOP_1 = 0x1
	// Position of IGNACK field.
	LPI2C_MCFGR1_IGNACK_Pos = 0x9
	// Bit mask of IGNACK field.
	LPI2C_MCFGR1_IGNACK_Msk = 0x200
	// Bit IGNACK.
	LPI2C_MCFGR1_IGNACK = 0x200
	// LPI2C Master will receive ACK and NACK normally
	LPI2C_MCFGR1_IGNACK_IGNACK_0 = 0x0
	// LPI2C Master will treat a received NACK as if it (NACK) was an ACK
	LPI2C_MCFGR1_IGNACK_IGNACK_1 = 0x1
	// Position of TIMECFG field.
	LPI2C_MCFGR1_TIMECFG_Pos = 0xa
	// Bit mask of TIMECFG field.
	LPI2C_MCFGR1_TIMECFG_Msk = 0x400
	// Bit TIMECFG.
	LPI2C_MCFGR1_TIMECFG = 0x400
	// Pin Low Timeout Flag will set if SCL is low for longer than the configured timeout
	LPI2C_MCFGR1_TIMECFG_TIMECFG_0 = 0x0
	// Pin Low Timeout Flag will set if either SCL or SDA is low for longer than the configured timeout
	LPI2C_MCFGR1_TIMECFG_TIMECFG_1 = 0x1
	// Position of MATCFG field.
	LPI2C_MCFGR1_MATCFG_Pos = 0x10
	// Bit mask of MATCFG field.
	LPI2C_MCFGR1_MATCFG_Msk = 0x70000
	// Match is disabled
	LPI2C_MCFGR1_MATCFG_MATCFG_0 = 0x0
	// Match is enabled (1st data word equals MATCH0 OR MATCH1)
	LPI2C_MCFGR1_MATCFG_MATCFG_2 = 0x2
	// Match is enabled (any data word equals MATCH0 OR MATCH1)
	LPI2C_MCFGR1_MATCFG_MATCFG_3 = 0x3
	// Match is enabled (1st data word equals MATCH0 AND 2nd data word equals MATCH1)
	LPI2C_MCFGR1_MATCFG_MATCFG_4 = 0x4
	// Match is enabled (any data word equals MATCH0 AND next data word equals MATCH1)
	LPI2C_MCFGR1_MATCFG_MATCFG_5 = 0x5
	// Match is enabled (1st data word AND MATCH1 equals MATCH0 AND MATCH1)
	LPI2C_MCFGR1_MATCFG_MATCFG_6 = 0x6
	// Match is enabled (any data word AND MATCH1 equals MATCH0 AND MATCH1)
	LPI2C_MCFGR1_MATCFG_MATCFG_7 = 0x7
	// Position of PINCFG field.
	LPI2C_MCFGR1_PINCFG_Pos = 0x18
	// Bit mask of PINCFG field.
	LPI2C_MCFGR1_PINCFG_Msk = 0x7000000
	// 2-pin open drain mode
	LPI2C_MCFGR1_PINCFG_PINCFG_0 = 0x0
	// 2-pin output only mode (ultra-fast mode)
	LPI2C_MCFGR1_PINCFG_PINCFG_1 = 0x1
	// 2-pin push-pull mode
	LPI2C_MCFGR1_PINCFG_PINCFG_2 = 0x2
	// 4-pin push-pull mode
	LPI2C_MCFGR1_PINCFG_PINCFG_3 = 0x3
	// 2-pin open drain mode with separate LPI2C slave
	LPI2C_MCFGR1_PINCFG_PINCFG_4 = 0x4
	// 2-pin output only mode (ultra-fast mode) with separate LPI2C slave
	LPI2C_MCFGR1_PINCFG_PINCFG_5 = 0x5
	// 2-pin push-pull mode with separate LPI2C slave
	LPI2C_MCFGR1_PINCFG_PINCFG_6 = 0x6
	// 4-pin push-pull mode (inverted outputs)
	LPI2C_MCFGR1_PINCFG_PINCFG_7 = 0x7

	// MCFGR2: Master Configuration Register 2
	// Position of BUSIDLE field.
	LPI2C_MCFGR2_BUSIDLE_Pos = 0x0
	// Bit mask of BUSIDLE field.
	LPI2C_MCFGR2_BUSIDLE_Msk = 0xfff
	// Position of FILTSCL field.
	LPI2C_MCFGR2_FILTSCL_Pos = 0x10
	// Bit mask of FILTSCL field.
	LPI2C_MCFGR2_FILTSCL_Msk = 0xf0000
	// Position of FILTSDA field.
	LPI2C_MCFGR2_FILTSDA_Pos = 0x18
	// Bit mask of FILTSDA field.
	LPI2C_MCFGR2_FILTSDA_Msk = 0xf000000

	// MCFGR3: Master Configuration Register 3
	// Position of PINLOW field.
	LPI2C_MCFGR3_PINLOW_Pos = 0x8
	// Bit mask of PINLOW field.
	LPI2C_MCFGR3_PINLOW_Msk = 0xfff00

	// MDMR: Master Data Match Register
	// Position of MATCH0 field.
	LPI2C_MDMR_MATCH0_Pos = 0x0
	// Bit mask of MATCH0 field.
	LPI2C_MDMR_MATCH0_Msk = 0xff
	// Position of MATCH1 field.
	LPI2C_MDMR_MATCH1_Pos = 0x10
	// Bit mask of MATCH1 field.
	LPI2C_MDMR_MATCH1_Msk = 0xff0000

	// MCCR0: Master Clock Configuration Register 0
	// Position of CLKLO field.
	LPI2C_MCCR0_CLKLO_Pos = 0x0
	// Bit mask of CLKLO field.
	LPI2C_MCCR0_CLKLO_Msk = 0x3f
	// Position of CLKHI field.
	LPI2C_MCCR0_CLKHI_Pos = 0x8
	// Bit mask of CLKHI field.
	LPI2C_MCCR0_CLKHI_Msk = 0x3f00
	// Position of SETHOLD field.
	LPI2C_MCCR0_SETHOLD_Pos = 0x10
	// Bit mask of SETHOLD field.
	LPI2C_MCCR0_SETHOLD_Msk = 0x3f0000
	// Position of DATAVD field.
	LPI2C_MCCR0_DATAVD_Pos = 0x18
	// Bit mask of DATAVD field.
	LPI2C_MCCR0_DATAVD_Msk = 0x3f000000

	// MCCR1: Master Clock Configuration Register 1
	// Position of CLKLO field.
	LPI2C_MCCR1_CLKLO_Pos = 0x0
	// Bit mask of CLKLO field.
	LPI2C_MCCR1_CLKLO_Msk = 0x3f
	// Position of CLKHI field.
	LPI2C_MCCR1_CLKHI_Pos = 0x8
	// Bit mask of CLKHI field.
	LPI2C_MCCR1_CLKHI_Msk = 0x3f00
	// Position of SETHOLD field.
	LPI2C_MCCR1_SETHOLD_Pos = 0x10
	// Bit mask of SETHOLD field.
	LPI2C_MCCR1_SETHOLD_Msk = 0x3f0000
	// Position of DATAVD field.
	LPI2C_MCCR1_DATAVD_Pos = 0x18
	// Bit mask of DATAVD field.
	LPI2C_MCCR1_DATAVD_Msk = 0x3f000000

	// MFCR: Master FIFO Control Register
	// Position of TXWATER field.
	LPI2C_MFCR_TXWATER_Pos = 0x0
	// Bit mask of TXWATER field.
	LPI2C_MFCR_TXWATER_Msk = 0x3
	// Position of RXWATER field.
	LPI2C_MFCR_RXWATER_Pos = 0x10
	// Bit mask of RXWATER field.
	LPI2C_MFCR_RXWATER_Msk = 0x30000

	// MFSR: Master FIFO Status Register
	// Position of TXCOUNT field.
	LPI2C_MFSR_TXCOUNT_Pos = 0x0
	// Bit mask of TXCOUNT field.
	LPI2C_MFSR_TXCOUNT_Msk = 0x7
	// Position of RXCOUNT field.
	LPI2C_MFSR_RXCOUNT_Pos = 0x10
	// Bit mask of RXCOUNT field.
	LPI2C_MFSR_RXCOUNT_Msk = 0x70000

	// MTDR: Master Transmit Data Register
	// Position of DATA field.
	LPI2C_MTDR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	LPI2C_MTDR_DATA_Msk = 0xff
	// Position of CMD field.
	LPI2C_MTDR_CMD_Pos = 0x8
	// Bit mask of CMD field.
	LPI2C_MTDR_CMD_Msk = 0x700
	// Transmit DATA[7:0]
	LPI2C_MTDR_CMD_CMD_0 = 0x0
	// Receive (DATA[7:0] + 1) bytes
	LPI2C_MTDR_CMD_CMD_1 = 0x1
	// Generate STOP condition
	LPI2C_MTDR_CMD_CMD_2 = 0x2
	// Receive and discard (DATA[7:0] + 1) bytes
	LPI2C_MTDR_CMD_CMD_3 = 0x3
	// Generate (repeated) START and transmit address in DATA[7:0]
	LPI2C_MTDR_CMD_CMD_4 = 0x4
	// Generate (repeated) START and transmit address in DATA[7:0]. This transfer expects a NACK to be returned.
	LPI2C_MTDR_CMD_CMD_5 = 0x5
	// Generate (repeated) START and transmit address in DATA[7:0] using high speed mode
	LPI2C_MTDR_CMD_CMD_6 = 0x6
	// Generate (repeated) START and transmit address in DATA[7:0] using high speed mode. This transfer expects a NACK to be returned.
	LPI2C_MTDR_CMD_CMD_7 = 0x7

	// MRDR: Master Receive Data Register
	// Position of DATA field.
	LPI2C_MRDR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	LPI2C_MRDR_DATA_Msk = 0xff
	// Position of RXEMPTY field.
	LPI2C_MRDR_RXEMPTY_Pos = 0xe
	// Bit mask of RXEMPTY field.
	LPI2C_MRDR_RXEMPTY_Msk = 0x4000
	// Bit RXEMPTY.
	LPI2C_MRDR_RXEMPTY = 0x4000
	// Receive FIFO is not empty
	LPI2C_MRDR_RXEMPTY_RXEMPTY_0 = 0x0
	// Receive FIFO is empty
	LPI2C_MRDR_RXEMPTY_RXEMPTY_1 = 0x1

	// SCR: Slave Control Register
	// Position of SEN field.
	LPI2C_SCR_SEN_Pos = 0x0
	// Bit mask of SEN field.
	LPI2C_SCR_SEN_Msk = 0x1
	// Bit SEN.
	LPI2C_SCR_SEN = 0x1
	// I2C Slave mode is disabled
	LPI2C_SCR_SEN_SEN_0 = 0x0
	// I2C Slave mode is enabled
	LPI2C_SCR_SEN_SEN_1 = 0x1
	// Position of RST field.
	LPI2C_SCR_RST_Pos = 0x1
	// Bit mask of RST field.
	LPI2C_SCR_RST_Msk = 0x2
	// Bit RST.
	LPI2C_SCR_RST = 0x2
	// Slave mode logic is not reset
	LPI2C_SCR_RST_RST_0 = 0x0
	// Slave mode logic is reset
	LPI2C_SCR_RST_RST_1 = 0x1
	// Position of FILTEN field.
	LPI2C_SCR_FILTEN_Pos = 0x4
	// Bit mask of FILTEN field.
	LPI2C_SCR_FILTEN_Msk = 0x10
	// Bit FILTEN.
	LPI2C_SCR_FILTEN = 0x10
	// Disable digital filter and output delay counter for slave mode
	LPI2C_SCR_FILTEN_FILTEN_0 = 0x0
	// Enable digital filter and output delay counter for slave mode
	LPI2C_SCR_FILTEN_FILTEN_1 = 0x1
	// Position of FILTDZ field.
	LPI2C_SCR_FILTDZ_Pos = 0x5
	// Bit mask of FILTDZ field.
	LPI2C_SCR_FILTDZ_Msk = 0x20
	// Bit FILTDZ.
	LPI2C_SCR_FILTDZ = 0x20
	// Filter remains enabled in Doze mode
	LPI2C_SCR_FILTDZ_FILTDZ_0 = 0x0
	// Filter is disabled in Doze mode
	LPI2C_SCR_FILTDZ_FILTDZ_1 = 0x1
	// Position of RTF field.
	LPI2C_SCR_RTF_Pos = 0x8
	// Bit mask of RTF field.
	LPI2C_SCR_RTF_Msk = 0x100
	// Bit RTF.
	LPI2C_SCR_RTF = 0x100
	// No effect
	LPI2C_SCR_RTF_RTF_0 = 0x0
	// Transmit Data Register is now empty
	LPI2C_SCR_RTF_RTF_1 = 0x1
	// Position of RRF field.
	LPI2C_SCR_RRF_Pos = 0x9
	// Bit mask of RRF field.
	LPI2C_SCR_RRF_Msk = 0x200
	// Bit RRF.
	LPI2C_SCR_RRF = 0x200
	// No effect
	LPI2C_SCR_RRF_RRF_0 = 0x0
	// Receive Data Register is now empty
	LPI2C_SCR_RRF_RRF_1 = 0x1

	// SSR: Slave Status Register
	// Position of TDF field.
	LPI2C_SSR_TDF_Pos = 0x0
	// Bit mask of TDF field.
	LPI2C_SSR_TDF_Msk = 0x1
	// Bit TDF.
	LPI2C_SSR_TDF = 0x1
	// Transmit data not requested
	LPI2C_SSR_TDF_TDF_0 = 0x0
	// Transmit data is requested
	LPI2C_SSR_TDF_TDF_1 = 0x1
	// Position of RDF field.
	LPI2C_SSR_RDF_Pos = 0x1
	// Bit mask of RDF field.
	LPI2C_SSR_RDF_Msk = 0x2
	// Bit RDF.
	LPI2C_SSR_RDF = 0x2
	// Receive data is not ready
	LPI2C_SSR_RDF_RDF_0 = 0x0
	// Receive data is ready
	LPI2C_SSR_RDF_RDF_1 = 0x1
	// Position of AVF field.
	LPI2C_SSR_AVF_Pos = 0x2
	// Bit mask of AVF field.
	LPI2C_SSR_AVF_Msk = 0x4
	// Bit AVF.
	LPI2C_SSR_AVF = 0x4
	// Address Status Register is not valid
	LPI2C_SSR_AVF_AVF_0 = 0x0
	// Address Status Register is valid
	LPI2C_SSR_AVF_AVF_1 = 0x1
	// Position of TAF field.
	LPI2C_SSR_TAF_Pos = 0x3
	// Bit mask of TAF field.
	LPI2C_SSR_TAF_Msk = 0x8
	// Bit TAF.
	LPI2C_SSR_TAF = 0x8
	// Transmit ACK/NACK is not required
	LPI2C_SSR_TAF_TAF_0 = 0x0
	// Transmit ACK/NACK is required
	LPI2C_SSR_TAF_TAF_1 = 0x1
	// Position of RSF field.
	LPI2C_SSR_RSF_Pos = 0x8
	// Bit mask of RSF field.
	LPI2C_SSR_RSF_Msk = 0x100
	// Bit RSF.
	LPI2C_SSR_RSF = 0x100
	// Slave has not detected a Repeated START condition
	LPI2C_SSR_RSF_RSF_0 = 0x0
	// Slave has detected a Repeated START condition
	LPI2C_SSR_RSF_RSF_1 = 0x1
	// Position of SDF field.
	LPI2C_SSR_SDF_Pos = 0x9
	// Bit mask of SDF field.
	LPI2C_SSR_SDF_Msk = 0x200
	// Bit SDF.
	LPI2C_SSR_SDF = 0x200
	// Slave has not detected a STOP condition
	LPI2C_SSR_SDF_SDF_0 = 0x0
	// Slave has detected a STOP condition
	LPI2C_SSR_SDF_SDF_1 = 0x1
	// Position of BEF field.
	LPI2C_SSR_BEF_Pos = 0xa
	// Bit mask of BEF field.
	LPI2C_SSR_BEF_Msk = 0x400
	// Bit BEF.
	LPI2C_SSR_BEF = 0x400
	// Slave has not detected a bit error
	LPI2C_SSR_BEF_BEF_0 = 0x0
	// Slave has detected a bit error
	LPI2C_SSR_BEF_BEF_1 = 0x1
	// Position of FEF field.
	LPI2C_SSR_FEF_Pos = 0xb
	// Bit mask of FEF field.
	LPI2C_SSR_FEF_Msk = 0x800
	// Bit FEF.
	LPI2C_SSR_FEF = 0x800
	// FIFO underflow or overflow was not detected
	LPI2C_SSR_FEF_FEF_0 = 0x0
	// FIFO underflow or overflow was detected
	LPI2C_SSR_FEF_FEF_1 = 0x1
	// Position of AM0F field.
	LPI2C_SSR_AM0F_Pos = 0xc
	// Bit mask of AM0F field.
	LPI2C_SSR_AM0F_Msk = 0x1000
	// Bit AM0F.
	LPI2C_SSR_AM0F = 0x1000
	// Have not received an ADDR0 matching address
	LPI2C_SSR_AM0F_AM0F_0 = 0x0
	// Have received an ADDR0 matching address
	LPI2C_SSR_AM0F_AM0F_1 = 0x1
	// Position of AM1F field.
	LPI2C_SSR_AM1F_Pos = 0xd
	// Bit mask of AM1F field.
	LPI2C_SSR_AM1F_Msk = 0x2000
	// Bit AM1F.
	LPI2C_SSR_AM1F = 0x2000
	// Have not received an ADDR1 or ADDR0/ADDR1 range matching address
	LPI2C_SSR_AM1F_AM1F_0 = 0x0
	// Have received an ADDR1 or ADDR0/ADDR1 range matching address
	LPI2C_SSR_AM1F_AM1F_1 = 0x1
	// Position of GCF field.
	LPI2C_SSR_GCF_Pos = 0xe
	// Bit mask of GCF field.
	LPI2C_SSR_GCF_Msk = 0x4000
	// Bit GCF.
	LPI2C_SSR_GCF = 0x4000
	// Slave has not detected the General Call Address or the General Call Address is disabled
	LPI2C_SSR_GCF_GCF_0 = 0x0
	// Slave has detected the General Call Address
	LPI2C_SSR_GCF_GCF_1 = 0x1
	// Position of SARF field.
	LPI2C_SSR_SARF_Pos = 0xf
	// Bit mask of SARF field.
	LPI2C_SSR_SARF_Msk = 0x8000
	// Bit SARF.
	LPI2C_SSR_SARF = 0x8000
	// SMBus Alert Response is disabled or not detected
	LPI2C_SSR_SARF_SARF_0 = 0x0
	// SMBus Alert Response is enabled and detected
	LPI2C_SSR_SARF_SARF_1 = 0x1
	// Position of SBF field.
	LPI2C_SSR_SBF_Pos = 0x18
	// Bit mask of SBF field.
	LPI2C_SSR_SBF_Msk = 0x1000000
	// Bit SBF.
	LPI2C_SSR_SBF = 0x1000000
	// I2C Slave is idle
	LPI2C_SSR_SBF_SBF_0 = 0x0
	// I2C Slave is busy
	LPI2C_SSR_SBF_SBF_1 = 0x1
	// Position of BBF field.
	LPI2C_SSR_BBF_Pos = 0x19
	// Bit mask of BBF field.
	LPI2C_SSR_BBF_Msk = 0x2000000
	// Bit BBF.
	LPI2C_SSR_BBF = 0x2000000
	// I2C Bus is idle
	LPI2C_SSR_BBF_BBF_0 = 0x0
	// I2C Bus is busy
	LPI2C_SSR_BBF_BBF_1 = 0x1

	// SIER: Slave Interrupt Enable Register
	// Position of TDIE field.
	LPI2C_SIER_TDIE_Pos = 0x0
	// Bit mask of TDIE field.
	LPI2C_SIER_TDIE_Msk = 0x1
	// Bit TDIE.
	LPI2C_SIER_TDIE = 0x1
	// Disabled
	LPI2C_SIER_TDIE_TDIE_0 = 0x0
	// Enabled
	LPI2C_SIER_TDIE_TDIE_1 = 0x1
	// Position of RDIE field.
	LPI2C_SIER_RDIE_Pos = 0x1
	// Bit mask of RDIE field.
	LPI2C_SIER_RDIE_Msk = 0x2
	// Bit RDIE.
	LPI2C_SIER_RDIE = 0x2
	// Disabled
	LPI2C_SIER_RDIE_RDIE_0 = 0x0
	// Enabled
	LPI2C_SIER_RDIE_RDIE_1 = 0x1
	// Position of AVIE field.
	LPI2C_SIER_AVIE_Pos = 0x2
	// Bit mask of AVIE field.
	LPI2C_SIER_AVIE_Msk = 0x4
	// Bit AVIE.
	LPI2C_SIER_AVIE = 0x4
	// Disabled
	LPI2C_SIER_AVIE_AVIE_0 = 0x0
	// Enabled
	LPI2C_SIER_AVIE_AVIE_1 = 0x1
	// Position of TAIE field.
	LPI2C_SIER_TAIE_Pos = 0x3
	// Bit mask of TAIE field.
	LPI2C_SIER_TAIE_Msk = 0x8
	// Bit TAIE.
	LPI2C_SIER_TAIE = 0x8
	// Disabled
	LPI2C_SIER_TAIE_TAIE_0 = 0x0
	// Enabled
	LPI2C_SIER_TAIE_TAIE_1 = 0x1
	// Position of RSIE field.
	LPI2C_SIER_RSIE_Pos = 0x8
	// Bit mask of RSIE field.
	LPI2C_SIER_RSIE_Msk = 0x100
	// Bit RSIE.
	LPI2C_SIER_RSIE = 0x100
	// Disabled
	LPI2C_SIER_RSIE_RSIE_0 = 0x0
	// Enabled
	LPI2C_SIER_RSIE_RSIE_1 = 0x1
	// Position of SDIE field.
	LPI2C_SIER_SDIE_Pos = 0x9
	// Bit mask of SDIE field.
	LPI2C_SIER_SDIE_Msk = 0x200
	// Bit SDIE.
	LPI2C_SIER_SDIE = 0x200
	// Disabled
	LPI2C_SIER_SDIE_SDIE_0 = 0x0
	// Enabled
	LPI2C_SIER_SDIE_SDIE_1 = 0x1
	// Position of BEIE field.
	LPI2C_SIER_BEIE_Pos = 0xa
	// Bit mask of BEIE field.
	LPI2C_SIER_BEIE_Msk = 0x400
	// Bit BEIE.
	LPI2C_SIER_BEIE = 0x400
	// Disabled
	LPI2C_SIER_BEIE_BEIE_0 = 0x0
	// Enabled
	LPI2C_SIER_BEIE_BEIE_1 = 0x1
	// Position of FEIE field.
	LPI2C_SIER_FEIE_Pos = 0xb
	// Bit mask of FEIE field.
	LPI2C_SIER_FEIE_Msk = 0x800
	// Bit FEIE.
	LPI2C_SIER_FEIE = 0x800
	// Disabled
	LPI2C_SIER_FEIE_FEIE_0 = 0x0
	// Enabled
	LPI2C_SIER_FEIE_FEIE_1 = 0x1
	// Position of AM0IE field.
	LPI2C_SIER_AM0IE_Pos = 0xc
	// Bit mask of AM0IE field.
	LPI2C_SIER_AM0IE_Msk = 0x1000
	// Bit AM0IE.
	LPI2C_SIER_AM0IE = 0x1000
	// Enabled
	LPI2C_SIER_AM0IE_AM0IE_0 = 0x0
	// Disabled
	LPI2C_SIER_AM0IE_AM0IE_1 = 0x1
	// Position of AM1F field.
	LPI2C_SIER_AM1F_Pos = 0xd
	// Bit mask of AM1F field.
	LPI2C_SIER_AM1F_Msk = 0x2000
	// Bit AM1F.
	LPI2C_SIER_AM1F = 0x2000
	// Disabled
	LPI2C_SIER_AM1F_AM1F_0 = 0x0
	// Enabled
	LPI2C_SIER_AM1F_AM1F_1 = 0x1
	// Position of GCIE field.
	LPI2C_SIER_GCIE_Pos = 0xe
	// Bit mask of GCIE field.
	LPI2C_SIER_GCIE_Msk = 0x4000
	// Bit GCIE.
	LPI2C_SIER_GCIE = 0x4000
	// Disabled
	LPI2C_SIER_GCIE_GCIE_0 = 0x0
	// Enabled
	LPI2C_SIER_GCIE_GCIE_1 = 0x1
	// Position of SARIE field.
	LPI2C_SIER_SARIE_Pos = 0xf
	// Bit mask of SARIE field.
	LPI2C_SIER_SARIE_Msk = 0x8000
	// Bit SARIE.
	LPI2C_SIER_SARIE = 0x8000
	// Disabled
	LPI2C_SIER_SARIE_SARIE_0 = 0x0
	// Enabled
	LPI2C_SIER_SARIE_SARIE_1 = 0x1

	// SDER: Slave DMA Enable Register
	// Position of TDDE field.
	LPI2C_SDER_TDDE_Pos = 0x0
	// Bit mask of TDDE field.
	LPI2C_SDER_TDDE_Msk = 0x1
	// Bit TDDE.
	LPI2C_SDER_TDDE = 0x1
	// DMA request is disabled
	LPI2C_SDER_TDDE_TDDE_0 = 0x0
	// DMA request is enabled
	LPI2C_SDER_TDDE_TDDE_1 = 0x1
	// Position of RDDE field.
	LPI2C_SDER_RDDE_Pos = 0x1
	// Bit mask of RDDE field.
	LPI2C_SDER_RDDE_Msk = 0x2
	// Bit RDDE.
	LPI2C_SDER_RDDE = 0x2
	// DMA request is disabled
	LPI2C_SDER_RDDE_RDDE_0 = 0x0
	// DMA request is enabled
	LPI2C_SDER_RDDE_RDDE_1 = 0x1
	// Position of AVDE field.
	LPI2C_SDER_AVDE_Pos = 0x2
	// Bit mask of AVDE field.
	LPI2C_SDER_AVDE_Msk = 0x4
	// Bit AVDE.
	LPI2C_SDER_AVDE = 0x4
	// DMA request is disabled
	LPI2C_SDER_AVDE_AVDE_0 = 0x0
	// DMA request is enabled
	LPI2C_SDER_AVDE_AVDE_1 = 0x1

	// SCFGR1: Slave Configuration Register 1
	// Position of ADRSTALL field.
	LPI2C_SCFGR1_ADRSTALL_Pos = 0x0
	// Bit mask of ADRSTALL field.
	LPI2C_SCFGR1_ADRSTALL_Msk = 0x1
	// Bit ADRSTALL.
	LPI2C_SCFGR1_ADRSTALL = 0x1
	// Clock stretching is disabled
	LPI2C_SCFGR1_ADRSTALL_ADRSTALL_0 = 0x0
	// Clock stretching is enabled
	LPI2C_SCFGR1_ADRSTALL_ADRSTALL_1 = 0x1
	// Position of RXSTALL field.
	LPI2C_SCFGR1_RXSTALL_Pos = 0x1
	// Bit mask of RXSTALL field.
	LPI2C_SCFGR1_RXSTALL_Msk = 0x2
	// Bit RXSTALL.
	LPI2C_SCFGR1_RXSTALL = 0x2
	// Clock stretching is disabled
	LPI2C_SCFGR1_RXSTALL_RXSTALL_0 = 0x0
	// Clock stretching is enabled
	LPI2C_SCFGR1_RXSTALL_RXSTALL_1 = 0x1
	// Position of TXDSTALL field.
	LPI2C_SCFGR1_TXDSTALL_Pos = 0x2
	// Bit mask of TXDSTALL field.
	LPI2C_SCFGR1_TXDSTALL_Msk = 0x4
	// Bit TXDSTALL.
	LPI2C_SCFGR1_TXDSTALL = 0x4
	// Clock stretching is disabled
	LPI2C_SCFGR1_TXDSTALL_TXDSTALL_0 = 0x0
	// Clock stretching is enabled
	LPI2C_SCFGR1_TXDSTALL_TXDSTALL_1 = 0x1
	// Position of ACKSTALL field.
	LPI2C_SCFGR1_ACKSTALL_Pos = 0x3
	// Bit mask of ACKSTALL field.
	LPI2C_SCFGR1_ACKSTALL_Msk = 0x8
	// Bit ACKSTALL.
	LPI2C_SCFGR1_ACKSTALL = 0x8
	// Clock stretching is disabled
	LPI2C_SCFGR1_ACKSTALL_ACKSTALL_0 = 0x0
	// Clock stretching is enabled
	LPI2C_SCFGR1_ACKSTALL_ACKSTALL_1 = 0x1
	// Position of GCEN field.
	LPI2C_SCFGR1_GCEN_Pos = 0x8
	// Bit mask of GCEN field.
	LPI2C_SCFGR1_GCEN_Msk = 0x100
	// Bit GCEN.
	LPI2C_SCFGR1_GCEN = 0x100
	// General Call address is disabled
	LPI2C_SCFGR1_GCEN_GCEN_0 = 0x0
	// General Call address is enabled
	LPI2C_SCFGR1_GCEN_GCEN_1 = 0x1
	// Position of SAEN field.
	LPI2C_SCFGR1_SAEN_Pos = 0x9
	// Bit mask of SAEN field.
	LPI2C_SCFGR1_SAEN_Msk = 0x200
	// Bit SAEN.
	LPI2C_SCFGR1_SAEN = 0x200
	// Disables match on SMBus Alert
	LPI2C_SCFGR1_SAEN_SAEN_0 = 0x0
	// Enables match on SMBus Alert
	LPI2C_SCFGR1_SAEN_SAEN_1 = 0x1
	// Position of TXCFG field.
	LPI2C_SCFGR1_TXCFG_Pos = 0xa
	// Bit mask of TXCFG field.
	LPI2C_SCFGR1_TXCFG_Msk = 0x400
	// Bit TXCFG.
	LPI2C_SCFGR1_TXCFG = 0x400
	// Transmit Data Flag will only assert during a slave-transmit transfer when the Transmit Data register is empty
	LPI2C_SCFGR1_TXCFG_TXCFG_0 = 0x0
	// Transmit Data Flag will assert whenever the Transmit Data register is empty
	LPI2C_SCFGR1_TXCFG_TXCFG_1 = 0x1
	// Position of RXCFG field.
	LPI2C_SCFGR1_RXCFG_Pos = 0xb
	// Bit mask of RXCFG field.
	LPI2C_SCFGR1_RXCFG_Msk = 0x800
	// Bit RXCFG.
	LPI2C_SCFGR1_RXCFG = 0x800
	// Reading the Receive Data register will return received data and clear the Receive Data flag (MSR[RDF]).
	LPI2C_SCFGR1_RXCFG_RXCFG_0 = 0x0
	// Reading the Receive Data register when the Address Valid flag (SSR[AVF])is set, will return the Address Status register and clear the Address Valid flag. Reading the Receive Data register when the Address Valid flag is clear, will return received data and clear the Receive Data flag (MSR[RDF]).
	LPI2C_SCFGR1_RXCFG_RXCFG_1 = 0x1
	// Position of IGNACK field.
	LPI2C_SCFGR1_IGNACK_Pos = 0xc
	// Bit mask of IGNACK field.
	LPI2C_SCFGR1_IGNACK_Msk = 0x1000
	// Bit IGNACK.
	LPI2C_SCFGR1_IGNACK = 0x1000
	// Slave will end transfer when NACK is detected
	LPI2C_SCFGR1_IGNACK_IGNACK_0 = 0x0
	// Slave will not end transfer when NACK detected
	LPI2C_SCFGR1_IGNACK_IGNACK_1 = 0x1
	// Position of HSMEN field.
	LPI2C_SCFGR1_HSMEN_Pos = 0xd
	// Bit mask of HSMEN field.
	LPI2C_SCFGR1_HSMEN_Msk = 0x2000
	// Bit HSMEN.
	LPI2C_SCFGR1_HSMEN = 0x2000
	// Disables detection of HS-mode master code
	LPI2C_SCFGR1_HSMEN_HSMEN_0 = 0x0
	// Enables detection of HS-mode master code
	LPI2C_SCFGR1_HSMEN_HSMEN_1 = 0x1
	// Position of ADDRCFG field.
	LPI2C_SCFGR1_ADDRCFG_Pos = 0x10
	// Bit mask of ADDRCFG field.
	LPI2C_SCFGR1_ADDRCFG_Msk = 0x70000
	// Address match 0 (7-bit)
	LPI2C_SCFGR1_ADDRCFG_ADDRCFG_0 = 0x0
	// Address match 0 (10-bit)
	LPI2C_SCFGR1_ADDRCFG_ADDRCFG_1 = 0x1
	// Address match 0 (7-bit) or Address match 1 (7-bit)
	LPI2C_SCFGR1_ADDRCFG_ADDRCFG_2 = 0x2
	// Address match 0 (10-bit) or Address match 1 (10-bit)
	LPI2C_SCFGR1_ADDRCFG_ADDRCFG_3 = 0x3
	// Address match 0 (7-bit) or Address match 1 (10-bit)
	LPI2C_SCFGR1_ADDRCFG_ADDRCFG_4 = 0x4
	// Address match 0 (10-bit) or Address match 1 (7-bit)
	LPI2C_SCFGR1_ADDRCFG_ADDRCFG_5 = 0x5
	// From Address match 0 (7-bit) to Address match 1 (7-bit)
	LPI2C_SCFGR1_ADDRCFG_ADDRCFG_6 = 0x6
	// From Address match 0 (10-bit) to Address match 1 (10-bit)
	LPI2C_SCFGR1_ADDRCFG_ADDRCFG_7 = 0x7

	// SCFGR2: Slave Configuration Register 2
	// Position of CLKHOLD field.
	LPI2C_SCFGR2_CLKHOLD_Pos = 0x0
	// Bit mask of CLKHOLD field.
	LPI2C_SCFGR2_CLKHOLD_Msk = 0xf
	// Position of DATAVD field.
	LPI2C_SCFGR2_DATAVD_Pos = 0x8
	// Bit mask of DATAVD field.
	LPI2C_SCFGR2_DATAVD_Msk = 0x3f00
	// Position of FILTSCL field.
	LPI2C_SCFGR2_FILTSCL_Pos = 0x10
	// Bit mask of FILTSCL field.
	LPI2C_SCFGR2_FILTSCL_Msk = 0xf0000
	// Position of FILTSDA field.
	LPI2C_SCFGR2_FILTSDA_Pos = 0x18
	// Bit mask of FILTSDA field.
	LPI2C_SCFGR2_FILTSDA_Msk = 0xf000000

	// SAMR: Slave Address Match Register
	// Position of ADDR0 field.
	LPI2C_SAMR_ADDR0_Pos = 0x1
	// Bit mask of ADDR0 field.
	LPI2C_SAMR_ADDR0_Msk = 0x7fe
	// Position of ADDR1 field.
	LPI2C_SAMR_ADDR1_Pos = 0x11
	// Bit mask of ADDR1 field.
	LPI2C_SAMR_ADDR1_Msk = 0x7fe0000

	// SASR: Slave Address Status Register
	// Position of RADDR field.
	LPI2C_SASR_RADDR_Pos = 0x0
	// Bit mask of RADDR field.
	LPI2C_SASR_RADDR_Msk = 0x7ff
	// Position of ANV field.
	LPI2C_SASR_ANV_Pos = 0xe
	// Bit mask of ANV field.
	LPI2C_SASR_ANV_Msk = 0x4000
	// Bit ANV.
	LPI2C_SASR_ANV = 0x4000
	// Received Address (RADDR) is valid
	LPI2C_SASR_ANV_ANV_0 = 0x0
	// Received Address (RADDR) is not valid
	LPI2C_SASR_ANV_ANV_1 = 0x1

	// STAR: Slave Transmit ACK Register
	// Position of TXNACK field.
	LPI2C_STAR_TXNACK_Pos = 0x0
	// Bit mask of TXNACK field.
	LPI2C_STAR_TXNACK_Msk = 0x1
	// Bit TXNACK.
	LPI2C_STAR_TXNACK = 0x1
	// Write a Transmit ACK for each received word
	LPI2C_STAR_TXNACK_TXNACK_0 = 0x0
	// Write a Transmit NACK for each received word
	LPI2C_STAR_TXNACK_TXNACK_1 = 0x1

	// STDR: Slave Transmit Data Register
	// Position of DATA field.
	LPI2C_STDR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	LPI2C_STDR_DATA_Msk = 0xff

	// SRDR: Slave Receive Data Register
	// Position of DATA field.
	LPI2C_SRDR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	LPI2C_SRDR_DATA_Msk = 0xff
	// Position of RXEMPTY field.
	LPI2C_SRDR_RXEMPTY_Pos = 0xe
	// Bit mask of RXEMPTY field.
	LPI2C_SRDR_RXEMPTY_Msk = 0x4000
	// Bit RXEMPTY.
	LPI2C_SRDR_RXEMPTY = 0x4000
	// The Receive Data Register is not empty
	LPI2C_SRDR_RXEMPTY_RXEMPTY_0 = 0x0
	// The Receive Data Register is empty
	LPI2C_SRDR_RXEMPTY_RXEMPTY_1 = 0x1
	// Position of SOF field.
	LPI2C_SRDR_SOF_Pos = 0xf
	// Bit mask of SOF field.
	LPI2C_SRDR_SOF_Msk = 0x8000
	// Bit SOF.
	LPI2C_SRDR_SOF = 0x8000
	// Indicates this is not the first data word since a (repeated) START or STOP condition
	LPI2C_SRDR_SOF_SOF_0 = 0x0
	// Indicates this is the first data word since a (repeated) START or STOP condition
	LPI2C_SRDR_SOF_SOF_1 = 0x1
)

// Constants for FLEXIO1: FLEXIO
const (
	// VERID: Version ID Register
	// Position of FEATURE field.
	FLEXIO_VERID_FEATURE_Pos = 0x0
	// Bit mask of FEATURE field.
	FLEXIO_VERID_FEATURE_Msk = 0xffff
	// Standard features implemented.
	FLEXIO_VERID_FEATURE_FEATURE_0 = 0x0
	// Supports state, logic and parallel modes.
	FLEXIO_VERID_FEATURE_FEATURE_1 = 0x1
	// Position of MINOR field.
	FLEXIO_VERID_MINOR_Pos = 0x10
	// Bit mask of MINOR field.
	FLEXIO_VERID_MINOR_Msk = 0xff0000
	// Position of MAJOR field.
	FLEXIO_VERID_MAJOR_Pos = 0x18
	// Bit mask of MAJOR field.
	FLEXIO_VERID_MAJOR_Msk = 0xff000000

	// PARAM: Parameter Register
	// Position of SHIFTER field.
	FLEXIO_PARAM_SHIFTER_Pos = 0x0
	// Bit mask of SHIFTER field.
	FLEXIO_PARAM_SHIFTER_Msk = 0xff
	// Position of TIMER field.
	FLEXIO_PARAM_TIMER_Pos = 0x8
	// Bit mask of TIMER field.
	FLEXIO_PARAM_TIMER_Msk = 0xff00
	// Position of PIN field.
	FLEXIO_PARAM_PIN_Pos = 0x10
	// Bit mask of PIN field.
	FLEXIO_PARAM_PIN_Msk = 0xff0000
	// Position of TRIGGER field.
	FLEXIO_PARAM_TRIGGER_Pos = 0x18
	// Bit mask of TRIGGER field.
	FLEXIO_PARAM_TRIGGER_Msk = 0xff000000

	// CTRL: FlexIO Control Register
	// Position of FLEXEN field.
	FLEXIO_CTRL_FLEXEN_Pos = 0x0
	// Bit mask of FLEXEN field.
	FLEXIO_CTRL_FLEXEN_Msk = 0x1
	// Bit FLEXEN.
	FLEXIO_CTRL_FLEXEN = 0x1
	// FlexIO module is disabled.
	FLEXIO_CTRL_FLEXEN_FLEXEN_0 = 0x0
	// FlexIO module is enabled.
	FLEXIO_CTRL_FLEXEN_FLEXEN_1 = 0x1
	// Position of SWRST field.
	FLEXIO_CTRL_SWRST_Pos = 0x1
	// Bit mask of SWRST field.
	FLEXIO_CTRL_SWRST_Msk = 0x2
	// Bit SWRST.
	FLEXIO_CTRL_SWRST = 0x2
	// Software reset is disabled
	FLEXIO_CTRL_SWRST_SWRST_0 = 0x0
	// Software reset is enabled, all FlexIO registers except the Control Register are reset.
	FLEXIO_CTRL_SWRST_SWRST_1 = 0x1
	// Position of FASTACC field.
	FLEXIO_CTRL_FASTACC_Pos = 0x2
	// Bit mask of FASTACC field.
	FLEXIO_CTRL_FASTACC_Msk = 0x4
	// Bit FASTACC.
	FLEXIO_CTRL_FASTACC = 0x4
	// Configures for normal register accesses to FlexIO
	FLEXIO_CTRL_FASTACC_FASTACC_0 = 0x0
	// Configures for fast register accesses to FlexIO
	FLEXIO_CTRL_FASTACC_FASTACC_1 = 0x1
	// Position of DBGE field.
	FLEXIO_CTRL_DBGE_Pos = 0x1e
	// Bit mask of DBGE field.
	FLEXIO_CTRL_DBGE_Msk = 0x40000000
	// Bit DBGE.
	FLEXIO_CTRL_DBGE = 0x40000000
	// FlexIO is disabled in debug modes.
	FLEXIO_CTRL_DBGE_DBGE_0 = 0x0
	// FlexIO is enabled in debug modes
	FLEXIO_CTRL_DBGE_DBGE_1 = 0x1
	// Position of DOZEN field.
	FLEXIO_CTRL_DOZEN_Pos = 0x1f
	// Bit mask of DOZEN field.
	FLEXIO_CTRL_DOZEN_Msk = 0x80000000
	// Bit DOZEN.
	FLEXIO_CTRL_DOZEN = 0x80000000
	// FlexIO enabled in Doze modes.
	FLEXIO_CTRL_DOZEN_DOZEN_0 = 0x0
	// FlexIO disabled in Doze modes.
	FLEXIO_CTRL_DOZEN_DOZEN_1 = 0x1

	// PIN: Pin State Register
	// Position of PDI field.
	FLEXIO_PIN_PDI_Pos = 0x0
	// Bit mask of PDI field.
	FLEXIO_PIN_PDI_Msk = 0xffffffff

	// SHIFTSTAT: Shifter Status Register
	// Position of SSF field.
	FLEXIO_SHIFTSTAT_SSF_Pos = 0x0
	// Bit mask of SSF field.
	FLEXIO_SHIFTSTAT_SSF_Msk = 0xff

	// SHIFTERR: Shifter Error Register
	// Position of SEF field.
	FLEXIO_SHIFTERR_SEF_Pos = 0x0
	// Bit mask of SEF field.
	FLEXIO_SHIFTERR_SEF_Msk = 0xff

	// TIMSTAT: Timer Status Register
	// Position of TSF field.
	FLEXIO_TIMSTAT_TSF_Pos = 0x0
	// Bit mask of TSF field.
	FLEXIO_TIMSTAT_TSF_Msk = 0xff

	// SHIFTSIEN: Shifter Status Interrupt Enable
	// Position of SSIE field.
	FLEXIO_SHIFTSIEN_SSIE_Pos = 0x0
	// Bit mask of SSIE field.
	FLEXIO_SHIFTSIEN_SSIE_Msk = 0xff

	// SHIFTEIEN: Shifter Error Interrupt Enable
	// Position of SEIE field.
	FLEXIO_SHIFTEIEN_SEIE_Pos = 0x0
	// Bit mask of SEIE field.
	FLEXIO_SHIFTEIEN_SEIE_Msk = 0xff

	// TIMIEN: Timer Interrupt Enable Register
	// Position of TEIE field.
	FLEXIO_TIMIEN_TEIE_Pos = 0x0
	// Bit mask of TEIE field.
	FLEXIO_TIMIEN_TEIE_Msk = 0xff

	// SHIFTSDEN: Shifter Status DMA Enable
	// Position of SSDE field.
	FLEXIO_SHIFTSDEN_SSDE_Pos = 0x0
	// Bit mask of SSDE field.
	FLEXIO_SHIFTSDEN_SSDE_Msk = 0xff

	// SHIFTSTATE: Shifter State Register
	// Position of STATE field.
	FLEXIO_SHIFTSTATE_STATE_Pos = 0x0
	// Bit mask of STATE field.
	FLEXIO_SHIFTSTATE_STATE_Msk = 0x7

	// SHIFTCTL: Shifter Control N Register
	// Position of SMOD field.
	FLEXIO_SHIFTCTL_SMOD_Pos = 0x0
	// Bit mask of SMOD field.
	FLEXIO_SHIFTCTL_SMOD_Msk = 0x7
	// Disabled.
	FLEXIO_SHIFTCTL_SMOD_SMOD_0 = 0x0
	// Receive mode. Captures the current Shifter content into the SHIFTBUF on expiration of the Timer.
	FLEXIO_SHIFTCTL_SMOD_SMOD_1 = 0x1
	// Transmit mode. Load SHIFTBUF contents into the Shifter on expiration of the Timer.
	FLEXIO_SHIFTCTL_SMOD_SMOD_2 = 0x2
	// Match Store mode. Shifter data is compared to SHIFTBUF content on expiration of the Timer.
	FLEXIO_SHIFTCTL_SMOD_SMOD_4 = 0x4
	// Match Continuous mode. Shifter data is continuously compared to SHIFTBUF contents.
	FLEXIO_SHIFTCTL_SMOD_SMOD_5 = 0x5
	// State mode. SHIFTBUF contents are used for storing programmable state attributes.
	FLEXIO_SHIFTCTL_SMOD_SMOD_6 = 0x6
	// Logic mode. SHIFTBUF contents are used for implementing programmable logic look up table.
	FLEXIO_SHIFTCTL_SMOD_SMOD_7 = 0x7
	// Position of PINPOL field.
	FLEXIO_SHIFTCTL_PINPOL_Pos = 0x7
	// Bit mask of PINPOL field.
	FLEXIO_SHIFTCTL_PINPOL_Msk = 0x80
	// Bit PINPOL.
	FLEXIO_SHIFTCTL_PINPOL = 0x80
	// Pin is active high
	FLEXIO_SHIFTCTL_PINPOL_PINPOL_0 = 0x0
	// Pin is active low
	FLEXIO_SHIFTCTL_PINPOL_PINPOL_1 = 0x1
	// Position of PINSEL field.
	FLEXIO_SHIFTCTL_PINSEL_Pos = 0x8
	// Bit mask of PINSEL field.
	FLEXIO_SHIFTCTL_PINSEL_Msk = 0x1f00
	// Position of PINCFG field.
	FLEXIO_SHIFTCTL_PINCFG_Pos = 0x10
	// Bit mask of PINCFG field.
	FLEXIO_SHIFTCTL_PINCFG_Msk = 0x30000
	// Shifter pin output disabled
	FLEXIO_SHIFTCTL_PINCFG_PINCFG_0 = 0x0
	// Shifter pin open drain or bidirectional output enable
	FLEXIO_SHIFTCTL_PINCFG_PINCFG_1 = 0x1
	// Shifter pin bidirectional output data
	FLEXIO_SHIFTCTL_PINCFG_PINCFG_2 = 0x2
	// Shifter pin output
	FLEXIO_SHIFTCTL_PINCFG_PINCFG_3 = 0x3
	// Position of TIMPOL field.
	FLEXIO_SHIFTCTL_TIMPOL_Pos = 0x17
	// Bit mask of TIMPOL field.
	FLEXIO_SHIFTCTL_TIMPOL_Msk = 0x800000
	// Bit TIMPOL.
	FLEXIO_SHIFTCTL_TIMPOL = 0x800000
	// Shift on posedge of Shift clock
	FLEXIO_SHIFTCTL_TIMPOL_TIMPOL_0 = 0x0
	// Shift on negedge of Shift clock
	FLEXIO_SHIFTCTL_TIMPOL_TIMPOL_1 = 0x1
	// Position of TIMSEL field.
	FLEXIO_SHIFTCTL_TIMSEL_Pos = 0x18
	// Bit mask of TIMSEL field.
	FLEXIO_SHIFTCTL_TIMSEL_Msk = 0x7000000

	// SHIFTCFG: Shifter Configuration N Register
	// Position of SSTART field.
	FLEXIO_SHIFTCFG_SSTART_Pos = 0x0
	// Bit mask of SSTART field.
	FLEXIO_SHIFTCFG_SSTART_Msk = 0x3
	// Start bit disabled for transmitter/receiver/match store, transmitter loads data on enable
	FLEXIO_SHIFTCFG_SSTART_SSTART_0 = 0x0
	// Start bit disabled for transmitter/receiver/match store, transmitter loads data on first shift
	FLEXIO_SHIFTCFG_SSTART_SSTART_1 = 0x1
	// Transmitter outputs start bit value 0 before loading data on first shift, receiver/match store sets error flag if start bit is not 0
	FLEXIO_SHIFTCFG_SSTART_SSTART_2 = 0x2
	// Transmitter outputs start bit value 1 before loading data on first shift, receiver/match store sets error flag if start bit is not 1
	FLEXIO_SHIFTCFG_SSTART_SSTART_3 = 0x3
	// Position of SSTOP field.
	FLEXIO_SHIFTCFG_SSTOP_Pos = 0x4
	// Bit mask of SSTOP field.
	FLEXIO_SHIFTCFG_SSTOP_Msk = 0x30
	// Stop bit disabled for transmitter/receiver/match store
	FLEXIO_SHIFTCFG_SSTOP_SSTOP_0 = 0x0
	// Transmitter outputs stop bit value 0 on store, receiver/match store sets error flag if stop bit is not 0
	FLEXIO_SHIFTCFG_SSTOP_SSTOP_2 = 0x2
	// Transmitter outputs stop bit value 1 on store, receiver/match store sets error flag if stop bit is not 1
	FLEXIO_SHIFTCFG_SSTOP_SSTOP_3 = 0x3
	// Position of INSRC field.
	FLEXIO_SHIFTCFG_INSRC_Pos = 0x8
	// Bit mask of INSRC field.
	FLEXIO_SHIFTCFG_INSRC_Msk = 0x100
	// Bit INSRC.
	FLEXIO_SHIFTCFG_INSRC = 0x100
	// Pin
	FLEXIO_SHIFTCFG_INSRC_INSRC_0 = 0x0
	// Shifter N+1 Output
	FLEXIO_SHIFTCFG_INSRC_INSRC_1 = 0x1
	// Position of PWIDTH field.
	FLEXIO_SHIFTCFG_PWIDTH_Pos = 0x10
	// Bit mask of PWIDTH field.
	FLEXIO_SHIFTCFG_PWIDTH_Msk = 0x1f0000

	// SHIFTBUF: Shifter Buffer N Register
	// Position of SHIFTBUF field.
	FLEXIO_SHIFTBUF_SHIFTBUF_Pos = 0x0
	// Bit mask of SHIFTBUF field.
	FLEXIO_SHIFTBUF_SHIFTBUF_Msk = 0xffffffff

	// SHIFTBUFBIS: Shifter Buffer N Bit Swapped Register
	// Position of SHIFTBUFBIS field.
	FLEXIO_SHIFTBUFBIS_SHIFTBUFBIS_Pos = 0x0
	// Bit mask of SHIFTBUFBIS field.
	FLEXIO_SHIFTBUFBIS_SHIFTBUFBIS_Msk = 0xffffffff

	// SHIFTBUFBYS: Shifter Buffer N Byte Swapped Register
	// Position of SHIFTBUFBYS field.
	FLEXIO_SHIFTBUFBYS_SHIFTBUFBYS_Pos = 0x0
	// Bit mask of SHIFTBUFBYS field.
	FLEXIO_SHIFTBUFBYS_SHIFTBUFBYS_Msk = 0xffffffff

	// SHIFTBUFBBS: Shifter Buffer N Bit Byte Swapped Register
	// Position of SHIFTBUFBBS field.
	FLEXIO_SHIFTBUFBBS_SHIFTBUFBBS_Pos = 0x0
	// Bit mask of SHIFTBUFBBS field.
	FLEXIO_SHIFTBUFBBS_SHIFTBUFBBS_Msk = 0xffffffff

	// TIMCTL: Timer Control N Register
	// Position of TIMOD field.
	FLEXIO_TIMCTL_TIMOD_Pos = 0x0
	// Bit mask of TIMOD field.
	FLEXIO_TIMCTL_TIMOD_Msk = 0x3
	// Timer Disabled.
	FLEXIO_TIMCTL_TIMOD_TIMOD_0 = 0x0
	// Dual 8-bit counters baud mode.
	FLEXIO_TIMCTL_TIMOD_TIMOD_1 = 0x1
	// Dual 8-bit counters PWM high mode.
	FLEXIO_TIMCTL_TIMOD_TIMOD_2 = 0x2
	// Single 16-bit counter mode.
	FLEXIO_TIMCTL_TIMOD_TIMOD_3 = 0x3
	// Position of PINPOL field.
	FLEXIO_TIMCTL_PINPOL_Pos = 0x7
	// Bit mask of PINPOL field.
	FLEXIO_TIMCTL_PINPOL_Msk = 0x80
	// Bit PINPOL.
	FLEXIO_TIMCTL_PINPOL = 0x80
	// Pin is active high
	FLEXIO_TIMCTL_PINPOL_PINPOL_0 = 0x0
	// Pin is active low
	FLEXIO_TIMCTL_PINPOL_PINPOL_1 = 0x1
	// Position of PINSEL field.
	FLEXIO_TIMCTL_PINSEL_Pos = 0x8
	// Bit mask of PINSEL field.
	FLEXIO_TIMCTL_PINSEL_Msk = 0x1f00
	// Position of PINCFG field.
	FLEXIO_TIMCTL_PINCFG_Pos = 0x10
	// Bit mask of PINCFG field.
	FLEXIO_TIMCTL_PINCFG_Msk = 0x30000
	// Timer pin output disabled
	FLEXIO_TIMCTL_PINCFG_PINCFG_0 = 0x0
	// Timer pin open drain or bidirectional output enable
	FLEXIO_TIMCTL_PINCFG_PINCFG_1 = 0x1
	// Timer pin bidirectional output data
	FLEXIO_TIMCTL_PINCFG_PINCFG_2 = 0x2
	// Timer pin output
	FLEXIO_TIMCTL_PINCFG_PINCFG_3 = 0x3
	// Position of TRGSRC field.
	FLEXIO_TIMCTL_TRGSRC_Pos = 0x16
	// Bit mask of TRGSRC field.
	FLEXIO_TIMCTL_TRGSRC_Msk = 0x400000
	// Bit TRGSRC.
	FLEXIO_TIMCTL_TRGSRC = 0x400000
	// External trigger selected
	FLEXIO_TIMCTL_TRGSRC_TRGSRC_0 = 0x0
	// Internal trigger selected
	FLEXIO_TIMCTL_TRGSRC_TRGSRC_1 = 0x1
	// Position of TRGPOL field.
	FLEXIO_TIMCTL_TRGPOL_Pos = 0x17
	// Bit mask of TRGPOL field.
	FLEXIO_TIMCTL_TRGPOL_Msk = 0x800000
	// Bit TRGPOL.
	FLEXIO_TIMCTL_TRGPOL = 0x800000
	// Trigger active high
	FLEXIO_TIMCTL_TRGPOL_TRGPOL_0 = 0x0
	// Trigger active low
	FLEXIO_TIMCTL_TRGPOL_TRGPOL_1 = 0x1
	// Position of TRGSEL field.
	FLEXIO_TIMCTL_TRGSEL_Pos = 0x18
	// Bit mask of TRGSEL field.
	FLEXIO_TIMCTL_TRGSEL_Msk = 0x3f000000

	// TIMCFG: Timer Configuration N Register
	// Position of TSTART field.
	FLEXIO_TIMCFG_TSTART_Pos = 0x1
	// Bit mask of TSTART field.
	FLEXIO_TIMCFG_TSTART_Msk = 0x2
	// Bit TSTART.
	FLEXIO_TIMCFG_TSTART = 0x2
	// Start bit disabled
	FLEXIO_TIMCFG_TSTART_TSTART_0 = 0x0
	// Start bit enabled
	FLEXIO_TIMCFG_TSTART_TSTART_1 = 0x1
	// Position of TSTOP field.
	FLEXIO_TIMCFG_TSTOP_Pos = 0x4
	// Bit mask of TSTOP field.
	FLEXIO_TIMCFG_TSTOP_Msk = 0x30
	// Stop bit disabled
	FLEXIO_TIMCFG_TSTOP_TSTOP_0 = 0x0
	// Stop bit is enabled on timer compare
	FLEXIO_TIMCFG_TSTOP_TSTOP_1 = 0x1
	// Stop bit is enabled on timer disable
	FLEXIO_TIMCFG_TSTOP_TSTOP_2 = 0x2
	// Stop bit is enabled on timer compare and timer disable
	FLEXIO_TIMCFG_TSTOP_TSTOP_3 = 0x3
	// Position of TIMENA field.
	FLEXIO_TIMCFG_TIMENA_Pos = 0x8
	// Bit mask of TIMENA field.
	FLEXIO_TIMCFG_TIMENA_Msk = 0x700
	// Timer always enabled
	FLEXIO_TIMCFG_TIMENA_TIMENA_0 = 0x0
	// Timer enabled on Timer N-1 enable
	FLEXIO_TIMCFG_TIMENA_TIMENA_1 = 0x1
	// Timer enabled on Trigger high
	FLEXIO_TIMCFG_TIMENA_TIMENA_2 = 0x2
	// Timer enabled on Trigger high and Pin high
	FLEXIO_TIMCFG_TIMENA_TIMENA_3 = 0x3
	// Timer enabled on Pin rising edge
	FLEXIO_TIMCFG_TIMENA_TIMENA_4 = 0x4
	// Timer enabled on Pin rising edge and Trigger high
	FLEXIO_TIMCFG_TIMENA_TIMENA_5 = 0x5
	// Timer enabled on Trigger rising edge
	FLEXIO_TIMCFG_TIMENA_TIMENA_6 = 0x6
	// Timer enabled on Trigger rising or falling edge
	FLEXIO_TIMCFG_TIMENA_TIMENA_7 = 0x7
	// Position of TIMDIS field.
	FLEXIO_TIMCFG_TIMDIS_Pos = 0xc
	// Bit mask of TIMDIS field.
	FLEXIO_TIMCFG_TIMDIS_Msk = 0x7000
	// Timer never disabled
	FLEXIO_TIMCFG_TIMDIS_TIMDIS_0 = 0x0
	// Timer disabled on Timer N-1 disable
	FLEXIO_TIMCFG_TIMDIS_TIMDIS_1 = 0x1
	// Timer disabled on Timer compare (upper 8-bits match and decrement)
	FLEXIO_TIMCFG_TIMDIS_TIMDIS_2 = 0x2
	// Timer disabled on Timer compare (upper 8-bits match and decrement) and Trigger Low
	FLEXIO_TIMCFG_TIMDIS_TIMDIS_3 = 0x3
	// Timer disabled on Pin rising or falling edge
	FLEXIO_TIMCFG_TIMDIS_TIMDIS_4 = 0x4
	// Timer disabled on Pin rising or falling edge provided Trigger is high
	FLEXIO_TIMCFG_TIMDIS_TIMDIS_5 = 0x5
	// Timer disabled on Trigger falling edge
	FLEXIO_TIMCFG_TIMDIS_TIMDIS_6 = 0x6
	// Position of TIMRST field.
	FLEXIO_TIMCFG_TIMRST_Pos = 0x10
	// Bit mask of TIMRST field.
	FLEXIO_TIMCFG_TIMRST_Msk = 0x70000
	// Timer never reset
	FLEXIO_TIMCFG_TIMRST_TIMRST_0 = 0x0
	// Timer reset on Timer Pin equal to Timer Output
	FLEXIO_TIMCFG_TIMRST_TIMRST_2 = 0x2
	// Timer reset on Timer Trigger equal to Timer Output
	FLEXIO_TIMCFG_TIMRST_TIMRST_3 = 0x3
	// Timer reset on Timer Pin rising edge
	FLEXIO_TIMCFG_TIMRST_TIMRST_4 = 0x4
	// Timer reset on Trigger rising edge
	FLEXIO_TIMCFG_TIMRST_TIMRST_6 = 0x6
	// Timer reset on Trigger rising or falling edge
	FLEXIO_TIMCFG_TIMRST_TIMRST_7 = 0x7
	// Position of TIMDEC field.
	FLEXIO_TIMCFG_TIMDEC_Pos = 0x14
	// Bit mask of TIMDEC field.
	FLEXIO_TIMCFG_TIMDEC_Msk = 0x300000
	// Decrement counter on FlexIO clock, Shift clock equals Timer output.
	FLEXIO_TIMCFG_TIMDEC_TIMDEC_0 = 0x0
	// Decrement counter on Trigger input (both edges), Shift clock equals Timer output.
	FLEXIO_TIMCFG_TIMDEC_TIMDEC_1 = 0x1
	// Decrement counter on Pin input (both edges), Shift clock equals Pin input.
	FLEXIO_TIMCFG_TIMDEC_TIMDEC_2 = 0x2
	// Decrement counter on Trigger input (both edges), Shift clock equals Trigger input.
	FLEXIO_TIMCFG_TIMDEC_TIMDEC_3 = 0x3
	// Position of TIMOUT field.
	FLEXIO_TIMCFG_TIMOUT_Pos = 0x18
	// Bit mask of TIMOUT field.
	FLEXIO_TIMCFG_TIMOUT_Msk = 0x3000000
	// Timer output is logic one when enabled and is not affected by timer reset
	FLEXIO_TIMCFG_TIMOUT_TIMOUT_0 = 0x0
	// Timer output is logic zero when enabled and is not affected by timer reset
	FLEXIO_TIMCFG_TIMOUT_TIMOUT_1 = 0x1
	// Timer output is logic one when enabled and on timer reset
	FLEXIO_TIMCFG_TIMOUT_TIMOUT_2 = 0x2
	// Timer output is logic zero when enabled and on timer reset
	FLEXIO_TIMCFG_TIMOUT_TIMOUT_3 = 0x3

	// TIMCMP: Timer Compare N Register
	// Position of CMP field.
	FLEXIO_TIMCMP_CMP_Pos = 0x0
	// Bit mask of CMP field.
	FLEXIO_TIMCMP_CMP_Msk = 0xffff

	// SHIFTBUFNBS: Shifter Buffer N Nibble Byte Swapped Register
	// Position of SHIFTBUFNBS field.
	FLEXIO_SHIFTBUFNBS_SHIFTBUFNBS_Pos = 0x0
	// Bit mask of SHIFTBUFNBS field.
	FLEXIO_SHIFTBUFNBS_SHIFTBUFNBS_Msk = 0xffffffff

	// SHIFTBUFHWS: Shifter Buffer N Half Word Swapped Register
	// Position of SHIFTBUFHWS field.
	FLEXIO_SHIFTBUFHWS_SHIFTBUFHWS_Pos = 0x0
	// Bit mask of SHIFTBUFHWS field.
	FLEXIO_SHIFTBUFHWS_SHIFTBUFHWS_Msk = 0xffffffff

	// SHIFTBUFNIS: Shifter Buffer N Nibble Swapped Register
	// Position of SHIFTBUFNIS field.
	FLEXIO_SHIFTBUFNIS_SHIFTBUFNIS_Pos = 0x0
	// Bit mask of SHIFTBUFNIS field.
	FLEXIO_SHIFTBUFNIS_SHIFTBUFNIS_Msk = 0xffffffff
)

// Constants for GPIO1: GPIO
const (
	// DR: GPIO data register
	// Position of DR field.
	GPIO_DR_DR_Pos = 0x0
	// Bit mask of DR field.
	GPIO_DR_DR_Msk = 0xffffffff

	// GDIR: GPIO direction register
	// Position of GDIR field.
	GPIO_GDIR_GDIR_Pos = 0x0
	// Bit mask of GDIR field.
	GPIO_GDIR_GDIR_Msk = 0xffffffff

	// PSR: GPIO pad status register
	// Position of PSR field.
	GPIO_PSR_PSR_Pos = 0x0
	// Bit mask of PSR field.
	GPIO_PSR_PSR_Msk = 0xffffffff

	// ICR1: GPIO interrupt configuration register1
	// Position of ICR0 field.
	GPIO_ICR1_ICR0_Pos = 0x0
	// Bit mask of ICR0 field.
	GPIO_ICR1_ICR0_Msk = 0x3
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR0_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR0_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR0_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR0_FALLING_EDGE = 0x3
	// Position of ICR1 field.
	GPIO_ICR1_ICR1_Pos = 0x2
	// Bit mask of ICR1 field.
	GPIO_ICR1_ICR1_Msk = 0xc
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR1_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR1_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR1_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR1_FALLING_EDGE = 0x3
	// Position of ICR2 field.
	GPIO_ICR1_ICR2_Pos = 0x4
	// Bit mask of ICR2 field.
	GPIO_ICR1_ICR2_Msk = 0x30
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR2_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR2_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR2_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR2_FALLING_EDGE = 0x3
	// Position of ICR3 field.
	GPIO_ICR1_ICR3_Pos = 0x6
	// Bit mask of ICR3 field.
	GPIO_ICR1_ICR3_Msk = 0xc0
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR3_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR3_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR3_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR3_FALLING_EDGE = 0x3
	// Position of ICR4 field.
	GPIO_ICR1_ICR4_Pos = 0x8
	// Bit mask of ICR4 field.
	GPIO_ICR1_ICR4_Msk = 0x300
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR4_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR4_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR4_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR4_FALLING_EDGE = 0x3
	// Position of ICR5 field.
	GPIO_ICR1_ICR5_Pos = 0xa
	// Bit mask of ICR5 field.
	GPIO_ICR1_ICR5_Msk = 0xc00
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR5_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR5_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR5_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR5_FALLING_EDGE = 0x3
	// Position of ICR6 field.
	GPIO_ICR1_ICR6_Pos = 0xc
	// Bit mask of ICR6 field.
	GPIO_ICR1_ICR6_Msk = 0x3000
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR6_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR6_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR6_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR6_FALLING_EDGE = 0x3
	// Position of ICR7 field.
	GPIO_ICR1_ICR7_Pos = 0xe
	// Bit mask of ICR7 field.
	GPIO_ICR1_ICR7_Msk = 0xc000
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR7_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR7_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR7_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR7_FALLING_EDGE = 0x3
	// Position of ICR8 field.
	GPIO_ICR1_ICR8_Pos = 0x10
	// Bit mask of ICR8 field.
	GPIO_ICR1_ICR8_Msk = 0x30000
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR8_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR8_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR8_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR8_FALLING_EDGE = 0x3
	// Position of ICR9 field.
	GPIO_ICR1_ICR9_Pos = 0x12
	// Bit mask of ICR9 field.
	GPIO_ICR1_ICR9_Msk = 0xc0000
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR9_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR9_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR9_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR9_FALLING_EDGE = 0x3
	// Position of ICR10 field.
	GPIO_ICR1_ICR10_Pos = 0x14
	// Bit mask of ICR10 field.
	GPIO_ICR1_ICR10_Msk = 0x300000
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR10_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR10_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR10_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR10_FALLING_EDGE = 0x3
	// Position of ICR11 field.
	GPIO_ICR1_ICR11_Pos = 0x16
	// Bit mask of ICR11 field.
	GPIO_ICR1_ICR11_Msk = 0xc00000
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR11_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR11_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR11_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR11_FALLING_EDGE = 0x3
	// Position of ICR12 field.
	GPIO_ICR1_ICR12_Pos = 0x18
	// Bit mask of ICR12 field.
	GPIO_ICR1_ICR12_Msk = 0x3000000
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR12_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR12_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR12_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR12_FALLING_EDGE = 0x3
	// Position of ICR13 field.
	GPIO_ICR1_ICR13_Pos = 0x1a
	// Bit mask of ICR13 field.
	GPIO_ICR1_ICR13_Msk = 0xc000000
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR13_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR13_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR13_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR13_FALLING_EDGE = 0x3
	// Position of ICR14 field.
	GPIO_ICR1_ICR14_Pos = 0x1c
	// Bit mask of ICR14 field.
	GPIO_ICR1_ICR14_Msk = 0x30000000
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR14_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR14_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR14_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR14_FALLING_EDGE = 0x3
	// Position of ICR15 field.
	GPIO_ICR1_ICR15_Pos = 0x1e
	// Bit mask of ICR15 field.
	GPIO_ICR1_ICR15_Msk = 0xc0000000
	// Interrupt n is low-level sensitive.
	GPIO_ICR1_ICR15_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR1_ICR15_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR1_ICR15_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR1_ICR15_FALLING_EDGE = 0x3

	// ICR2: GPIO interrupt configuration register2
	// Position of ICR16 field.
	GPIO_ICR2_ICR16_Pos = 0x0
	// Bit mask of ICR16 field.
	GPIO_ICR2_ICR16_Msk = 0x3
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR16_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR16_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR16_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR16_FALLING_EDGE = 0x3
	// Position of ICR17 field.
	GPIO_ICR2_ICR17_Pos = 0x2
	// Bit mask of ICR17 field.
	GPIO_ICR2_ICR17_Msk = 0xc
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR17_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR17_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR17_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR17_FALLING_EDGE = 0x3
	// Position of ICR18 field.
	GPIO_ICR2_ICR18_Pos = 0x4
	// Bit mask of ICR18 field.
	GPIO_ICR2_ICR18_Msk = 0x30
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR18_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR18_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR18_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR18_FALLING_EDGE = 0x3
	// Position of ICR19 field.
	GPIO_ICR2_ICR19_Pos = 0x6
	// Bit mask of ICR19 field.
	GPIO_ICR2_ICR19_Msk = 0xc0
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR19_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR19_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR19_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR19_FALLING_EDGE = 0x3
	// Position of ICR20 field.
	GPIO_ICR2_ICR20_Pos = 0x8
	// Bit mask of ICR20 field.
	GPIO_ICR2_ICR20_Msk = 0x300
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR20_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR20_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR20_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR20_FALLING_EDGE = 0x3
	// Position of ICR21 field.
	GPIO_ICR2_ICR21_Pos = 0xa
	// Bit mask of ICR21 field.
	GPIO_ICR2_ICR21_Msk = 0xc00
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR21_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR21_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR21_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR21_FALLING_EDGE = 0x3
	// Position of ICR22 field.
	GPIO_ICR2_ICR22_Pos = 0xc
	// Bit mask of ICR22 field.
	GPIO_ICR2_ICR22_Msk = 0x3000
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR22_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR22_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR22_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR22_FALLING_EDGE = 0x3
	// Position of ICR23 field.
	GPIO_ICR2_ICR23_Pos = 0xe
	// Bit mask of ICR23 field.
	GPIO_ICR2_ICR23_Msk = 0xc000
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR23_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR23_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR23_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR23_FALLING_EDGE = 0x3
	// Position of ICR24 field.
	GPIO_ICR2_ICR24_Pos = 0x10
	// Bit mask of ICR24 field.
	GPIO_ICR2_ICR24_Msk = 0x30000
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR24_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR24_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR24_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR24_FALLING_EDGE = 0x3
	// Position of ICR25 field.
	GPIO_ICR2_ICR25_Pos = 0x12
	// Bit mask of ICR25 field.
	GPIO_ICR2_ICR25_Msk = 0xc0000
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR25_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR25_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR25_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR25_FALLING_EDGE = 0x3
	// Position of ICR26 field.
	GPIO_ICR2_ICR26_Pos = 0x14
	// Bit mask of ICR26 field.
	GPIO_ICR2_ICR26_Msk = 0x300000
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR26_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR26_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR26_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR26_FALLING_EDGE = 0x3
	// Position of ICR27 field.
	GPIO_ICR2_ICR27_Pos = 0x16
	// Bit mask of ICR27 field.
	GPIO_ICR2_ICR27_Msk = 0xc00000
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR27_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR27_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR27_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR27_FALLING_EDGE = 0x3
	// Position of ICR28 field.
	GPIO_ICR2_ICR28_Pos = 0x18
	// Bit mask of ICR28 field.
	GPIO_ICR2_ICR28_Msk = 0x3000000
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR28_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR28_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR28_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR28_FALLING_EDGE = 0x3
	// Position of ICR29 field.
	GPIO_ICR2_ICR29_Pos = 0x1a
	// Bit mask of ICR29 field.
	GPIO_ICR2_ICR29_Msk = 0xc000000
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR29_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR29_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR29_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR29_FALLING_EDGE = 0x3
	// Position of ICR30 field.
	GPIO_ICR2_ICR30_Pos = 0x1c
	// Bit mask of ICR30 field.
	GPIO_ICR2_ICR30_Msk = 0x30000000
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR30_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR30_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR30_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR30_FALLING_EDGE = 0x3
	// Position of ICR31 field.
	GPIO_ICR2_ICR31_Pos = 0x1e
	// Bit mask of ICR31 field.
	GPIO_ICR2_ICR31_Msk = 0xc0000000
	// Interrupt n is low-level sensitive.
	GPIO_ICR2_ICR31_LOW_LEVEL = 0x0
	// Interrupt n is high-level sensitive.
	GPIO_ICR2_ICR31_HIGH_LEVEL = 0x1
	// Interrupt n is rising-edge sensitive.
	GPIO_ICR2_ICR31_RISING_EDGE = 0x2
	// Interrupt n is falling-edge sensitive.
	GPIO_ICR2_ICR31_FALLING_EDGE = 0x3

	// IMR: GPIO interrupt mask register
	// Position of IMR field.
	GPIO_IMR_IMR_Pos = 0x0
	// Bit mask of IMR field.
	GPIO_IMR_IMR_Msk = 0xffffffff

	// ISR: GPIO interrupt status register
	// Position of ISR field.
	GPIO_ISR_ISR_Pos = 0x0
	// Bit mask of ISR field.
	GPIO_ISR_ISR_Msk = 0xffffffff

	// EDGE_SEL: GPIO edge select register
	// Position of GPIO_EDGE_SEL field.
	GPIO_EDGE_SEL_GPIO_EDGE_SEL_Pos = 0x0
	// Bit mask of GPIO_EDGE_SEL field.
	GPIO_EDGE_SEL_GPIO_EDGE_SEL_Msk = 0xffffffff

	// DR_SET: GPIO data register SET
	// Position of DR_SET field.
	GPIO_DR_SET_DR_SET_Pos = 0x0
	// Bit mask of DR_SET field.
	GPIO_DR_SET_DR_SET_Msk = 0xffffffff

	// DR_CLEAR: GPIO data register CLEAR
	// Position of DR_CLEAR field.
	GPIO_DR_CLEAR_DR_CLEAR_Pos = 0x0
	// Bit mask of DR_CLEAR field.
	GPIO_DR_CLEAR_DR_CLEAR_Msk = 0xffffffff

	// DR_TOGGLE: GPIO data register TOGGLE
	// Position of DR_TOGGLE field.
	GPIO_DR_TOGGLE_DR_TOGGLE_Pos = 0x0
	// Bit mask of DR_TOGGLE field.
	GPIO_DR_TOGGLE_DR_TOGGLE_Msk = 0xffffffff
)

// Constants for PWM1: PWM
const (
	// SM0CNT: Counter Register
	// Position of CNT field.
	PWM_SM0CNT_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PWM_SM0CNT_CNT_Msk = 0xffff

	// SM0INIT: Initial Count Register
	// Position of INIT field.
	PWM_SM0INIT_INIT_Pos = 0x0
	// Bit mask of INIT field.
	PWM_SM0INIT_INIT_Msk = 0xffff

	// SM0CTRL2: Control 2 Register
	// Position of CLK_SEL field.
	PWM_SM0CTRL2_CLK_SEL_Pos = 0x0
	// Bit mask of CLK_SEL field.
	PWM_SM0CTRL2_CLK_SEL_Msk = 0x3
	// The IPBus clock is used as the clock for the local prescaler and counter.
	PWM_SM0CTRL2_CLK_SEL_CLK_SEL_0 = 0x0
	// EXT_CLK is used as the clock for the local prescaler and counter.
	PWM_SM0CTRL2_CLK_SEL_CLK_SEL_1 = 0x1
	// Submodule 0's clock (AUX_CLK) is used as the source clock for the local prescaler and counter. This setting should not be used in submodule 0 as it will force the clock to logic 0.
	PWM_SM0CTRL2_CLK_SEL_CLK_SEL_2 = 0x2
	// Position of RELOAD_SEL field.
	PWM_SM0CTRL2_RELOAD_SEL_Pos = 0x2
	// Bit mask of RELOAD_SEL field.
	PWM_SM0CTRL2_RELOAD_SEL_Msk = 0x4
	// Bit RELOAD_SEL.
	PWM_SM0CTRL2_RELOAD_SEL = 0x4
	// The local RELOAD signal is used to reload registers.
	PWM_SM0CTRL2_RELOAD_SEL_RELOAD_SEL_0 = 0x0
	// The master RELOAD signal (from submodule 0) is used to reload registers. This setting should not be used in submodule 0 as it will force the RELOAD signal to logic 0.
	PWM_SM0CTRL2_RELOAD_SEL_RELOAD_SEL_1 = 0x1
	// Position of FORCE_SEL field.
	PWM_SM0CTRL2_FORCE_SEL_Pos = 0x3
	// Bit mask of FORCE_SEL field.
	PWM_SM0CTRL2_FORCE_SEL_Msk = 0x38
	// The local force signal, CTRL2[FORCE], from this submodule is used to force updates.
	PWM_SM0CTRL2_FORCE_SEL_FORCE_SEL_0 = 0x0
	// The master force signal from submodule 0 is used to force updates. This setting should not be used in submodule 0 as it will hold the FORCE OUTPUT signal to logic 0.
	PWM_SM0CTRL2_FORCE_SEL_FORCE_SEL_1 = 0x1
	// The local reload signal from this submodule is used to force updates without regard to the state of LDOK.
	PWM_SM0CTRL2_FORCE_SEL_FORCE_SEL_2 = 0x2
	// The master reload signal from submodule0 is used to force updates if LDOK is set. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	PWM_SM0CTRL2_FORCE_SEL_FORCE_SEL_3 = 0x3
	// The local sync signal from this submodule is used to force updates.
	PWM_SM0CTRL2_FORCE_SEL_FORCE_SEL_4 = 0x4
	// The master sync signal from submodule0 is used to force updates. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	PWM_SM0CTRL2_FORCE_SEL_FORCE_SEL_5 = 0x5
	// The external force signal, EXT_FORCE, from outside the PWM module causes updates.
	PWM_SM0CTRL2_FORCE_SEL_FORCE_SEL_6 = 0x6
	// The external sync signal, EXT_SYNC, from outside the PWM module causes updates.
	PWM_SM0CTRL2_FORCE_SEL_FORCE_SEL_7 = 0x7
	// Position of FORCE field.
	PWM_SM0CTRL2_FORCE_Pos = 0x6
	// Bit mask of FORCE field.
	PWM_SM0CTRL2_FORCE_Msk = 0x40
	// Bit FORCE.
	PWM_SM0CTRL2_FORCE = 0x40
	// Position of FRCEN field.
	PWM_SM0CTRL2_FRCEN_Pos = 0x7
	// Bit mask of FRCEN field.
	PWM_SM0CTRL2_FRCEN_Msk = 0x80
	// Bit FRCEN.
	PWM_SM0CTRL2_FRCEN = 0x80
	// Initialization from a FORCE_OUT is disabled.
	PWM_SM0CTRL2_FRCEN_FRCEN_0 = 0x0
	// Initialization from a FORCE_OUT is enabled.
	PWM_SM0CTRL2_FRCEN_FRCEN_1 = 0x1
	// Position of INIT_SEL field.
	PWM_SM0CTRL2_INIT_SEL_Pos = 0x8
	// Bit mask of INIT_SEL field.
	PWM_SM0CTRL2_INIT_SEL_Msk = 0x300
	// Local sync (PWM_X) causes initialization.
	PWM_SM0CTRL2_INIT_SEL_INIT_SEL_0 = 0x0
	// Master reload from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0. The submodule counter will only reinitialize when a master reload occurs.
	PWM_SM0CTRL2_INIT_SEL_INIT_SEL_1 = 0x1
	// Master sync from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0.
	PWM_SM0CTRL2_INIT_SEL_INIT_SEL_2 = 0x2
	// EXT_SYNC causes initialization.
	PWM_SM0CTRL2_INIT_SEL_INIT_SEL_3 = 0x3
	// Position of PWMX_INIT field.
	PWM_SM0CTRL2_PWMX_INIT_Pos = 0xa
	// Bit mask of PWMX_INIT field.
	PWM_SM0CTRL2_PWMX_INIT_Msk = 0x400
	// Bit PWMX_INIT.
	PWM_SM0CTRL2_PWMX_INIT = 0x400
	// Position of PWM45_INIT field.
	PWM_SM0CTRL2_PWM45_INIT_Pos = 0xb
	// Bit mask of PWM45_INIT field.
	PWM_SM0CTRL2_PWM45_INIT_Msk = 0x800
	// Bit PWM45_INIT.
	PWM_SM0CTRL2_PWM45_INIT = 0x800
	// Position of PWM23_INIT field.
	PWM_SM0CTRL2_PWM23_INIT_Pos = 0xc
	// Bit mask of PWM23_INIT field.
	PWM_SM0CTRL2_PWM23_INIT_Msk = 0x1000
	// Bit PWM23_INIT.
	PWM_SM0CTRL2_PWM23_INIT = 0x1000
	// Position of INDEP field.
	PWM_SM0CTRL2_INDEP_Pos = 0xd
	// Bit mask of INDEP field.
	PWM_SM0CTRL2_INDEP_Msk = 0x2000
	// Bit INDEP.
	PWM_SM0CTRL2_INDEP = 0x2000
	// PWM_A and PWM_B form a complementary PWM pair.
	PWM_SM0CTRL2_INDEP_INDEP_0 = 0x0
	// PWM_A and PWM_B outputs are independent PWMs.
	PWM_SM0CTRL2_INDEP_INDEP_1 = 0x1
	// Position of WAITEN field.
	PWM_SM0CTRL2_WAITEN_Pos = 0xe
	// Bit mask of WAITEN field.
	PWM_SM0CTRL2_WAITEN_Msk = 0x4000
	// Bit WAITEN.
	PWM_SM0CTRL2_WAITEN = 0x4000
	// Position of DBGEN field.
	PWM_SM0CTRL2_DBGEN_Pos = 0xf
	// Bit mask of DBGEN field.
	PWM_SM0CTRL2_DBGEN_Msk = 0x8000
	// Bit DBGEN.
	PWM_SM0CTRL2_DBGEN = 0x8000

	// SM0CTRL: Control Register
	// Position of DBLEN field.
	PWM_SM0CTRL_DBLEN_Pos = 0x0
	// Bit mask of DBLEN field.
	PWM_SM0CTRL_DBLEN_Msk = 0x1
	// Bit DBLEN.
	PWM_SM0CTRL_DBLEN = 0x1
	// Double switching disabled.
	PWM_SM0CTRL_DBLEN_DBLEN_0 = 0x0
	// Double switching enabled.
	PWM_SM0CTRL_DBLEN_DBLEN_1 = 0x1
	// Position of DBLX field.
	PWM_SM0CTRL_DBLX_Pos = 0x1
	// Bit mask of DBLX field.
	PWM_SM0CTRL_DBLX_Msk = 0x2
	// Bit DBLX.
	PWM_SM0CTRL_DBLX = 0x2
	// PWMX double pulse disabled.
	PWM_SM0CTRL_DBLX_DBLX_0 = 0x0
	// PWMX double pulse enabled.
	PWM_SM0CTRL_DBLX_DBLX_1 = 0x1
	// Position of LDMOD field.
	PWM_SM0CTRL_LDMOD_Pos = 0x2
	// Bit mask of LDMOD field.
	PWM_SM0CTRL_LDMOD_Msk = 0x4
	// Bit LDMOD.
	PWM_SM0CTRL_LDMOD = 0x4
	// Buffered registers of this submodule are loaded and take effect at the next PWM reload if MCTRL[LDOK] is set.
	PWM_SM0CTRL_LDMOD_LDMOD_0 = 0x0
	// Buffered registers of this submodule are loaded and take effect immediately upon MCTRL[LDOK] being set. In this case it is not necessary to set CTRL[FULL] or CTRL[HALF].
	PWM_SM0CTRL_LDMOD_LDMOD_1 = 0x1
	// Position of SPLIT field.
	PWM_SM0CTRL_SPLIT_Pos = 0x3
	// Bit mask of SPLIT field.
	PWM_SM0CTRL_SPLIT_Msk = 0x8
	// Bit SPLIT.
	PWM_SM0CTRL_SPLIT = 0x8
	// DBLPWM is not split. PWMA and PWMB each have double pulses.
	PWM_SM0CTRL_SPLIT_SPLIT_0 = 0x0
	// DBLPWM is split to PWMA and PWMB.
	PWM_SM0CTRL_SPLIT_SPLIT_1 = 0x1
	// Position of PRSC field.
	PWM_SM0CTRL_PRSC_Pos = 0x4
	// Bit mask of PRSC field.
	PWM_SM0CTRL_PRSC_Msk = 0x70
	// PWM clock frequency = fclk
	PWM_SM0CTRL_PRSC_PRSC_0 = 0x0
	// PWM clock frequency = fclk/2
	PWM_SM0CTRL_PRSC_PRSC_1 = 0x1
	// PWM clock frequency = fclk/4
	PWM_SM0CTRL_PRSC_PRSC_2 = 0x2
	// PWM clock frequency = fclk/8
	PWM_SM0CTRL_PRSC_PRSC_3 = 0x3
	// PWM clock frequency = fclk/16
	PWM_SM0CTRL_PRSC_PRSC_4 = 0x4
	// PWM clock frequency = fclk/32
	PWM_SM0CTRL_PRSC_PRSC_5 = 0x5
	// PWM clock frequency = fclk/64
	PWM_SM0CTRL_PRSC_PRSC_6 = 0x6
	// PWM clock frequency = fclk/128
	PWM_SM0CTRL_PRSC_PRSC_7 = 0x7
	// Position of COMPMODE field.
	PWM_SM0CTRL_COMPMODE_Pos = 0x7
	// Bit mask of COMPMODE field.
	PWM_SM0CTRL_COMPMODE_Msk = 0x80
	// Bit COMPMODE.
	PWM_SM0CTRL_COMPMODE = 0x80
	// The VAL* registers and the PWM counter are compared using an "equal to" method. This means that PWM edges are only produced when the counter is equal to one of the VAL* register values. This implies that a PWMA output that is high at the end of a period will maintain this state until a match with VAL3 clears the output in the following period.
	PWM_SM0CTRL_COMPMODE_COMPMODE_0 = 0x0
	// The VAL* registers and the PWM counter are compared using an "equal to or greater than" method. This means that PWM edges are produced when the counter is equal to or greater than one of the VAL* register values. This implies that a PWMA output that is high at the end of a period could go low at the start of the next period if the starting counter value is greater than (but not necessarily equal to) the new VAL3 value.
	PWM_SM0CTRL_COMPMODE_COMPMODE_1 = 0x1
	// Position of DT field.
	PWM_SM0CTRL_DT_Pos = 0x8
	// Bit mask of DT field.
	PWM_SM0CTRL_DT_Msk = 0x300
	// Position of FULL field.
	PWM_SM0CTRL_FULL_Pos = 0xa
	// Bit mask of FULL field.
	PWM_SM0CTRL_FULL_Msk = 0x400
	// Bit FULL.
	PWM_SM0CTRL_FULL = 0x400
	// Full-cycle reloads disabled.
	PWM_SM0CTRL_FULL_FULL_0 = 0x0
	// Full-cycle reloads enabled.
	PWM_SM0CTRL_FULL_FULL_1 = 0x1
	// Position of HALF field.
	PWM_SM0CTRL_HALF_Pos = 0xb
	// Bit mask of HALF field.
	PWM_SM0CTRL_HALF_Msk = 0x800
	// Bit HALF.
	PWM_SM0CTRL_HALF = 0x800
	// Half-cycle reloads disabled.
	PWM_SM0CTRL_HALF_HALF_0 = 0x0
	// Half-cycle reloads enabled.
	PWM_SM0CTRL_HALF_HALF_1 = 0x1
	// Position of LDFQ field.
	PWM_SM0CTRL_LDFQ_Pos = 0xc
	// Bit mask of LDFQ field.
	PWM_SM0CTRL_LDFQ_Msk = 0xf000
	// Every PWM opportunity
	PWM_SM0CTRL_LDFQ_LDFQ_0 = 0x0
	// Every 2 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_1 = 0x1
	// Every 3 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_2 = 0x2
	// Every 4 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_3 = 0x3
	// Every 5 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_4 = 0x4
	// Every 6 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_5 = 0x5
	// Every 7 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_6 = 0x6
	// Every 8 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_7 = 0x7
	// Every 9 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_8 = 0x8
	// Every 10 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_9 = 0x9
	// Every 11 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_10 = 0xa
	// Every 12 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_11 = 0xb
	// Every 13 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_12 = 0xc
	// Every 14 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_13 = 0xd
	// Every 15 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_14 = 0xe
	// Every 16 PWM opportunities
	PWM_SM0CTRL_LDFQ_LDFQ_15 = 0xf

	// SM0VAL0: Value Register 0
	// Position of VAL0 field.
	PWM_SM0VAL0_VAL0_Pos = 0x0
	// Bit mask of VAL0 field.
	PWM_SM0VAL0_VAL0_Msk = 0xffff

	// SM0FRACVAL1: Fractional Value Register 1
	// Position of FRACVAL1 field.
	PWM_SM0FRACVAL1_FRACVAL1_Pos = 0xb
	// Bit mask of FRACVAL1 field.
	PWM_SM0FRACVAL1_FRACVAL1_Msk = 0xf800

	// SM0VAL1: Value Register 1
	// Position of VAL1 field.
	PWM_SM0VAL1_VAL1_Pos = 0x0
	// Bit mask of VAL1 field.
	PWM_SM0VAL1_VAL1_Msk = 0xffff

	// SM0FRACVAL2: Fractional Value Register 2
	// Position of FRACVAL2 field.
	PWM_SM0FRACVAL2_FRACVAL2_Pos = 0xb
	// Bit mask of FRACVAL2 field.
	PWM_SM0FRACVAL2_FRACVAL2_Msk = 0xf800

	// SM0VAL2: Value Register 2
	// Position of VAL2 field.
	PWM_SM0VAL2_VAL2_Pos = 0x0
	// Bit mask of VAL2 field.
	PWM_SM0VAL2_VAL2_Msk = 0xffff

	// SM0FRACVAL3: Fractional Value Register 3
	// Position of FRACVAL3 field.
	PWM_SM0FRACVAL3_FRACVAL3_Pos = 0xb
	// Bit mask of FRACVAL3 field.
	PWM_SM0FRACVAL3_FRACVAL3_Msk = 0xf800

	// SM0VAL3: Value Register 3
	// Position of VAL3 field.
	PWM_SM0VAL3_VAL3_Pos = 0x0
	// Bit mask of VAL3 field.
	PWM_SM0VAL3_VAL3_Msk = 0xffff

	// SM0FRACVAL4: Fractional Value Register 4
	// Position of FRACVAL4 field.
	PWM_SM0FRACVAL4_FRACVAL4_Pos = 0xb
	// Bit mask of FRACVAL4 field.
	PWM_SM0FRACVAL4_FRACVAL4_Msk = 0xf800

	// SM0VAL4: Value Register 4
	// Position of VAL4 field.
	PWM_SM0VAL4_VAL4_Pos = 0x0
	// Bit mask of VAL4 field.
	PWM_SM0VAL4_VAL4_Msk = 0xffff

	// SM0FRACVAL5: Fractional Value Register 5
	// Position of FRACVAL5 field.
	PWM_SM0FRACVAL5_FRACVAL5_Pos = 0xb
	// Bit mask of FRACVAL5 field.
	PWM_SM0FRACVAL5_FRACVAL5_Msk = 0xf800

	// SM0VAL5: Value Register 5
	// Position of VAL5 field.
	PWM_SM0VAL5_VAL5_Pos = 0x0
	// Bit mask of VAL5 field.
	PWM_SM0VAL5_VAL5_Msk = 0xffff

	// SM0FRCTRL: Fractional Control Register
	// Position of FRAC1_EN field.
	PWM_SM0FRCTRL_FRAC1_EN_Pos = 0x1
	// Bit mask of FRAC1_EN field.
	PWM_SM0FRCTRL_FRAC1_EN_Msk = 0x2
	// Bit FRAC1_EN.
	PWM_SM0FRCTRL_FRAC1_EN = 0x2
	// Disable fractional cycle length for the PWM period.
	PWM_SM0FRCTRL_FRAC1_EN_FRAC1_EN_0 = 0x0
	// Enable fractional cycle length for the PWM period.
	PWM_SM0FRCTRL_FRAC1_EN_FRAC1_EN_1 = 0x1
	// Position of FRAC23_EN field.
	PWM_SM0FRCTRL_FRAC23_EN_Pos = 0x2
	// Bit mask of FRAC23_EN field.
	PWM_SM0FRCTRL_FRAC23_EN_Msk = 0x4
	// Bit FRAC23_EN.
	PWM_SM0FRCTRL_FRAC23_EN = 0x4
	// Disable fractional cycle placement for PWM_A.
	PWM_SM0FRCTRL_FRAC23_EN_FRAC23_EN_0 = 0x0
	// Enable fractional cycle placement for PWM_A.
	PWM_SM0FRCTRL_FRAC23_EN_FRAC23_EN_1 = 0x1
	// Position of FRAC45_EN field.
	PWM_SM0FRCTRL_FRAC45_EN_Pos = 0x4
	// Bit mask of FRAC45_EN field.
	PWM_SM0FRCTRL_FRAC45_EN_Msk = 0x10
	// Bit FRAC45_EN.
	PWM_SM0FRCTRL_FRAC45_EN = 0x10
	// Disable fractional cycle placement for PWM_B.
	PWM_SM0FRCTRL_FRAC45_EN_FRAC45_EN_0 = 0x0
	// Enable fractional cycle placement for PWM_B.
	PWM_SM0FRCTRL_FRAC45_EN_FRAC45_EN_1 = 0x1
	// Position of FRAC_PU field.
	PWM_SM0FRCTRL_FRAC_PU_Pos = 0x8
	// Bit mask of FRAC_PU field.
	PWM_SM0FRCTRL_FRAC_PU_Msk = 0x100
	// Bit FRAC_PU.
	PWM_SM0FRCTRL_FRAC_PU = 0x100
	// Turn off fractional delay logic.
	PWM_SM0FRCTRL_FRAC_PU_FRAC_PU_0 = 0x0
	// Power up fractional delay logic.
	PWM_SM0FRCTRL_FRAC_PU_FRAC_PU_1 = 0x1
	// Position of TEST field.
	PWM_SM0FRCTRL_TEST_Pos = 0xf
	// Bit mask of TEST field.
	PWM_SM0FRCTRL_TEST_Msk = 0x8000
	// Bit TEST.
	PWM_SM0FRCTRL_TEST = 0x8000

	// SM0OCTRL: Output Control Register
	// Position of PWMXFS field.
	PWM_SM0OCTRL_PWMXFS_Pos = 0x0
	// Bit mask of PWMXFS field.
	PWM_SM0OCTRL_PWMXFS_Msk = 0x3
	// Output is forced to logic 0 state prior to consideration of output polarity control.
	PWM_SM0OCTRL_PWMXFS_PWMXFS_0 = 0x0
	// Output is forced to logic 1 state prior to consideration of output polarity control.
	PWM_SM0OCTRL_PWMXFS_PWMXFS_1 = 0x1
	// Output is tristated.
	PWM_SM0OCTRL_PWMXFS_PWMXFS_2 = 0x2
	// Output is tristated.
	PWM_SM0OCTRL_PWMXFS_PWMXFS_3 = 0x3
	// Position of PWMBFS field.
	PWM_SM0OCTRL_PWMBFS_Pos = 0x2
	// Bit mask of PWMBFS field.
	PWM_SM0OCTRL_PWMBFS_Msk = 0xc
	// Output is forced to logic 0 state prior to consideration of output polarity control.
	PWM_SM0OCTRL_PWMBFS_PWMBFS_0 = 0x0
	// Output is forced to logic 1 state prior to consideration of output polarity control.
	PWM_SM0OCTRL_PWMBFS_PWMBFS_1 = 0x1
	// Output is tristated.
	PWM_SM0OCTRL_PWMBFS_PWMBFS_2 = 0x2
	// Output is tristated.
	PWM_SM0OCTRL_PWMBFS_PWMBFS_3 = 0x3
	// Position of PWMAFS field.
	PWM_SM0OCTRL_PWMAFS_Pos = 0x4
	// Bit mask of PWMAFS field.
	PWM_SM0OCTRL_PWMAFS_Msk = 0x30
	// Output is forced to logic 0 state prior to consideration of output polarity control.
	PWM_SM0OCTRL_PWMAFS_PWMAFS_0 = 0x0
	// Output is forced to logic 1 state prior to consideration of output polarity control.
	PWM_SM0OCTRL_PWMAFS_PWMAFS_1 = 0x1
	// Output is tristated.
	PWM_SM0OCTRL_PWMAFS_PWMAFS_2 = 0x2
	// Output is tristated.
	PWM_SM0OCTRL_PWMAFS_PWMAFS_3 = 0x3
	// Position of POLX field.
	PWM_SM0OCTRL_POLX_Pos = 0x8
	// Bit mask of POLX field.
	PWM_SM0OCTRL_POLX_Msk = 0x100
	// Bit POLX.
	PWM_SM0OCTRL_POLX = 0x100
	// PWM_X output not inverted. A high level on the PWM_X pin represents the "on" or "active" state.
	PWM_SM0OCTRL_POLX_POLX_0 = 0x0
	// PWM_X output inverted. A low level on the PWM_X pin represents the "on" or "active" state.
	PWM_SM0OCTRL_POLX_POLX_1 = 0x1
	// Position of POLB field.
	PWM_SM0OCTRL_POLB_Pos = 0x9
	// Bit mask of POLB field.
	PWM_SM0OCTRL_POLB_Msk = 0x200
	// Bit POLB.
	PWM_SM0OCTRL_POLB = 0x200
	// PWM_B output not inverted. A high level on the PWM_B pin represents the "on" or "active" state.
	PWM_SM0OCTRL_POLB_POLB_0 = 0x0
	// PWM_B output inverted. A low level on the PWM_B pin represents the "on" or "active" state.
	PWM_SM0OCTRL_POLB_POLB_1 = 0x1
	// Position of POLA field.
	PWM_SM0OCTRL_POLA_Pos = 0xa
	// Bit mask of POLA field.
	PWM_SM0OCTRL_POLA_Msk = 0x400
	// Bit POLA.
	PWM_SM0OCTRL_POLA = 0x400
	// PWM_A output not inverted. A high level on the PWM_A pin represents the "on" or "active" state.
	PWM_SM0OCTRL_POLA_POLA_0 = 0x0
	// PWM_A output inverted. A low level on the PWM_A pin represents the "on" or "active" state.
	PWM_SM0OCTRL_POLA_POLA_1 = 0x1
	// Position of PWMX_IN field.
	PWM_SM0OCTRL_PWMX_IN_Pos = 0xd
	// Bit mask of PWMX_IN field.
	PWM_SM0OCTRL_PWMX_IN_Msk = 0x2000
	// Bit PWMX_IN.
	PWM_SM0OCTRL_PWMX_IN = 0x2000
	// Position of PWMB_IN field.
	PWM_SM0OCTRL_PWMB_IN_Pos = 0xe
	// Bit mask of PWMB_IN field.
	PWM_SM0OCTRL_PWMB_IN_Msk = 0x4000
	// Bit PWMB_IN.
	PWM_SM0OCTRL_PWMB_IN = 0x4000
	// Position of PWMA_IN field.
	PWM_SM0OCTRL_PWMA_IN_Pos = 0xf
	// Bit mask of PWMA_IN field.
	PWM_SM0OCTRL_PWMA_IN_Msk = 0x8000
	// Bit PWMA_IN.
	PWM_SM0OCTRL_PWMA_IN = 0x8000

	// SM0STS: Status Register
	// Position of CMPF field.
	PWM_SM0STS_CMPF_Pos = 0x0
	// Bit mask of CMPF field.
	PWM_SM0STS_CMPF_Msk = 0x3f
	// No compare event has occurred for a particular VALx value.
	PWM_SM0STS_CMPF_CMPF_0 = 0x0
	// A compare event has occurred for a particular VALx value.
	PWM_SM0STS_CMPF_CMPF_1 = 0x1
	// Position of CFX0 field.
	PWM_SM0STS_CFX0_Pos = 0x6
	// Bit mask of CFX0 field.
	PWM_SM0STS_CFX0_Msk = 0x40
	// Bit CFX0.
	PWM_SM0STS_CFX0 = 0x40
	// Position of CFX1 field.
	PWM_SM0STS_CFX1_Pos = 0x7
	// Bit mask of CFX1 field.
	PWM_SM0STS_CFX1_Msk = 0x80
	// Bit CFX1.
	PWM_SM0STS_CFX1 = 0x80
	// Position of CFB0 field.
	PWM_SM0STS_CFB0_Pos = 0x8
	// Bit mask of CFB0 field.
	PWM_SM0STS_CFB0_Msk = 0x100
	// Bit CFB0.
	PWM_SM0STS_CFB0 = 0x100
	// Position of CFB1 field.
	PWM_SM0STS_CFB1_Pos = 0x9
	// Bit mask of CFB1 field.
	PWM_SM0STS_CFB1_Msk = 0x200
	// Bit CFB1.
	PWM_SM0STS_CFB1 = 0x200
	// Position of CFA0 field.
	PWM_SM0STS_CFA0_Pos = 0xa
	// Bit mask of CFA0 field.
	PWM_SM0STS_CFA0_Msk = 0x400
	// Bit CFA0.
	PWM_SM0STS_CFA0 = 0x400
	// Position of CFA1 field.
	PWM_SM0STS_CFA1_Pos = 0xb
	// Bit mask of CFA1 field.
	PWM_SM0STS_CFA1_Msk = 0x800
	// Bit CFA1.
	PWM_SM0STS_CFA1 = 0x800
	// Position of RF field.
	PWM_SM0STS_RF_Pos = 0xc
	// Bit mask of RF field.
	PWM_SM0STS_RF_Msk = 0x1000
	// Bit RF.
	PWM_SM0STS_RF = 0x1000
	// No new reload cycle since last STS[RF] clearing
	PWM_SM0STS_RF_RF_0 = 0x0
	// New reload cycle since last STS[RF] clearing
	PWM_SM0STS_RF_RF_1 = 0x1
	// Position of REF field.
	PWM_SM0STS_REF_Pos = 0xd
	// Bit mask of REF field.
	PWM_SM0STS_REF_Msk = 0x2000
	// Bit REF.
	PWM_SM0STS_REF = 0x2000
	// No reload error occurred.
	PWM_SM0STS_REF_REF_0 = 0x0
	// Reload signal occurred with non-coherent data and MCTRL[LDOK] = 0.
	PWM_SM0STS_REF_REF_1 = 0x1
	// Position of RUF field.
	PWM_SM0STS_RUF_Pos = 0xe
	// Bit mask of RUF field.
	PWM_SM0STS_RUF_Msk = 0x4000
	// Bit RUF.
	PWM_SM0STS_RUF = 0x4000
	// No register update has occurred since last reload.
	PWM_SM0STS_RUF_RUF_0 = 0x0
	// At least one of the double buffered registers has been updated since the last reload.
	PWM_SM0STS_RUF_RUF_1 = 0x1

	// SM0INTEN: Interrupt Enable Register
	// Position of CMPIE field.
	PWM_SM0INTEN_CMPIE_Pos = 0x0
	// Bit mask of CMPIE field.
	PWM_SM0INTEN_CMPIE_Msk = 0x3f
	// The corresponding STS[CMPF] bit will not cause an interrupt request.
	PWM_SM0INTEN_CMPIE_CMPIE_0 = 0x0
	// The corresponding STS[CMPF] bit will cause an interrupt request.
	PWM_SM0INTEN_CMPIE_CMPIE_1 = 0x1
	// Position of CX0IE field.
	PWM_SM0INTEN_CX0IE_Pos = 0x6
	// Bit mask of CX0IE field.
	PWM_SM0INTEN_CX0IE_Msk = 0x40
	// Bit CX0IE.
	PWM_SM0INTEN_CX0IE = 0x40
	// Interrupt request disabled for STS[CFX0].
	PWM_SM0INTEN_CX0IE_CX0IE_0 = 0x0
	// Interrupt request enabled for STS[CFX0].
	PWM_SM0INTEN_CX0IE_CX0IE_1 = 0x1
	// Position of CX1IE field.
	PWM_SM0INTEN_CX1IE_Pos = 0x7
	// Bit mask of CX1IE field.
	PWM_SM0INTEN_CX1IE_Msk = 0x80
	// Bit CX1IE.
	PWM_SM0INTEN_CX1IE = 0x80
	// Interrupt request disabled for STS[CFX1].
	PWM_SM0INTEN_CX1IE_CX1IE_0 = 0x0
	// Interrupt request enabled for STS[CFX1].
	PWM_SM0INTEN_CX1IE_CX1IE_1 = 0x1
	// Position of CB0IE field.
	PWM_SM0INTEN_CB0IE_Pos = 0x8
	// Bit mask of CB0IE field.
	PWM_SM0INTEN_CB0IE_Msk = 0x100
	// Bit CB0IE.
	PWM_SM0INTEN_CB0IE = 0x100
	// Interrupt request disabled for STS[CFB0].
	PWM_SM0INTEN_CB0IE_CB0IE_0 = 0x0
	// Interrupt request enabled for STS[CFB0].
	PWM_SM0INTEN_CB0IE_CB0IE_1 = 0x1
	// Position of CB1IE field.
	PWM_SM0INTEN_CB1IE_Pos = 0x9
	// Bit mask of CB1IE field.
	PWM_SM0INTEN_CB1IE_Msk = 0x200
	// Bit CB1IE.
	PWM_SM0INTEN_CB1IE = 0x200
	// Interrupt request disabled for STS[CFB1].
	PWM_SM0INTEN_CB1IE_CB1IE_0 = 0x0
	// Interrupt request enabled for STS[CFB1].
	PWM_SM0INTEN_CB1IE_CB1IE_1 = 0x1
	// Position of CA0IE field.
	PWM_SM0INTEN_CA0IE_Pos = 0xa
	// Bit mask of CA0IE field.
	PWM_SM0INTEN_CA0IE_Msk = 0x400
	// Bit CA0IE.
	PWM_SM0INTEN_CA0IE = 0x400
	// Interrupt request disabled for STS[CFA0].
	PWM_SM0INTEN_CA0IE_CA0IE_0 = 0x0
	// Interrupt request enabled for STS[CFA0].
	PWM_SM0INTEN_CA0IE_CA0IE_1 = 0x1
	// Position of CA1IE field.
	PWM_SM0INTEN_CA1IE_Pos = 0xb
	// Bit mask of CA1IE field.
	PWM_SM0INTEN_CA1IE_Msk = 0x800
	// Bit CA1IE.
	PWM_SM0INTEN_CA1IE = 0x800
	// Interrupt request disabled for STS[CFA1].
	PWM_SM0INTEN_CA1IE_CA1IE_0 = 0x0
	// Interrupt request enabled for STS[CFA1].
	PWM_SM0INTEN_CA1IE_CA1IE_1 = 0x1
	// Position of RIE field.
	PWM_SM0INTEN_RIE_Pos = 0xc
	// Bit mask of RIE field.
	PWM_SM0INTEN_RIE_Msk = 0x1000
	// Bit RIE.
	PWM_SM0INTEN_RIE = 0x1000
	// STS[RF] CPU interrupt requests disabled
	PWM_SM0INTEN_RIE_RIE_0 = 0x0
	// STS[RF] CPU interrupt requests enabled
	PWM_SM0INTEN_RIE_RIE_1 = 0x1
	// Position of REIE field.
	PWM_SM0INTEN_REIE_Pos = 0xd
	// Bit mask of REIE field.
	PWM_SM0INTEN_REIE_Msk = 0x2000
	// Bit REIE.
	PWM_SM0INTEN_REIE = 0x2000
	// STS[REF] CPU interrupt requests disabled
	PWM_SM0INTEN_REIE_REIE_0 = 0x0
	// STS[REF] CPU interrupt requests enabled
	PWM_SM0INTEN_REIE_REIE_1 = 0x1

	// SM0DMAEN: DMA Enable Register
	// Position of CX0DE field.
	PWM_SM0DMAEN_CX0DE_Pos = 0x0
	// Bit mask of CX0DE field.
	PWM_SM0DMAEN_CX0DE_Msk = 0x1
	// Bit CX0DE.
	PWM_SM0DMAEN_CX0DE = 0x1
	// Position of CX1DE field.
	PWM_SM0DMAEN_CX1DE_Pos = 0x1
	// Bit mask of CX1DE field.
	PWM_SM0DMAEN_CX1DE_Msk = 0x2
	// Bit CX1DE.
	PWM_SM0DMAEN_CX1DE = 0x2
	// Position of CB0DE field.
	PWM_SM0DMAEN_CB0DE_Pos = 0x2
	// Bit mask of CB0DE field.
	PWM_SM0DMAEN_CB0DE_Msk = 0x4
	// Bit CB0DE.
	PWM_SM0DMAEN_CB0DE = 0x4
	// Position of CB1DE field.
	PWM_SM0DMAEN_CB1DE_Pos = 0x3
	// Bit mask of CB1DE field.
	PWM_SM0DMAEN_CB1DE_Msk = 0x8
	// Bit CB1DE.
	PWM_SM0DMAEN_CB1DE = 0x8
	// Position of CA0DE field.
	PWM_SM0DMAEN_CA0DE_Pos = 0x4
	// Bit mask of CA0DE field.
	PWM_SM0DMAEN_CA0DE_Msk = 0x10
	// Bit CA0DE.
	PWM_SM0DMAEN_CA0DE = 0x10
	// Position of CA1DE field.
	PWM_SM0DMAEN_CA1DE_Pos = 0x5
	// Bit mask of CA1DE field.
	PWM_SM0DMAEN_CA1DE_Msk = 0x20
	// Bit CA1DE.
	PWM_SM0DMAEN_CA1DE = 0x20
	// Position of CAPTDE field.
	PWM_SM0DMAEN_CAPTDE_Pos = 0x6
	// Bit mask of CAPTDE field.
	PWM_SM0DMAEN_CAPTDE_Msk = 0xc0
	// Read DMA requests disabled.
	PWM_SM0DMAEN_CAPTDE_CAPTDE_0 = 0x0
	// Exceeding a FIFO watermark sets the DMA read request. This requires at least one of DMAEN[CA1DE], DMAEN[CA0DE], DMAEN[CB1DE], DMAEN[CB0DE], DMAEN[CX1DE], or DMAEN[CX0DE] to also be set in order to determine to which watermark(s) the DMA request is sensitive.
	PWM_SM0DMAEN_CAPTDE_CAPTDE_1 = 0x1
	// A local sync (VAL1 matches counter) sets the read DMA request.
	PWM_SM0DMAEN_CAPTDE_CAPTDE_2 = 0x2
	// A local reload (STS[RF] being set) sets the read DMA request.
	PWM_SM0DMAEN_CAPTDE_CAPTDE_3 = 0x3
	// Position of FAND field.
	PWM_SM0DMAEN_FAND_Pos = 0x8
	// Bit mask of FAND field.
	PWM_SM0DMAEN_FAND_Msk = 0x100
	// Bit FAND.
	PWM_SM0DMAEN_FAND = 0x100
	// Selected FIFO watermarks are OR'ed together.
	PWM_SM0DMAEN_FAND_FAND_0 = 0x0
	// Selected FIFO watermarks are AND'ed together.
	PWM_SM0DMAEN_FAND_FAND_1 = 0x1
	// Position of VALDE field.
	PWM_SM0DMAEN_VALDE_Pos = 0x9
	// Bit mask of VALDE field.
	PWM_SM0DMAEN_VALDE_Msk = 0x200
	// Bit VALDE.
	PWM_SM0DMAEN_VALDE = 0x200
	// DMA write requests disabled
	PWM_SM0DMAEN_VALDE_VALDE_0 = 0x0
	// DMA write requests for the VALx and FRACVALx registers enabled
	PWM_SM0DMAEN_VALDE_VALDE_1 = 0x1

	// SM0TCTRL: Output Trigger Control Register
	// Position of OUT_TRIG_EN field.
	PWM_SM0TCTRL_OUT_TRIG_EN_Pos = 0x0
	// Bit mask of OUT_TRIG_EN field.
	PWM_SM0TCTRL_OUT_TRIG_EN_Msk = 0x3f
	// PWM_OUT_TRIGx will not set when the counter value matches the VALx value.
	PWM_SM0TCTRL_OUT_TRIG_EN_OUT_TRIG_EN_0 = 0x0
	// PWM_OUT_TRIGx will set when the counter value matches the VALx value.
	PWM_SM0TCTRL_OUT_TRIG_EN_OUT_TRIG_EN_1 = 0x1
	// Position of TRGFRQ field.
	PWM_SM0TCTRL_TRGFRQ_Pos = 0xc
	// Bit mask of TRGFRQ field.
	PWM_SM0TCTRL_TRGFRQ_Msk = 0x1000
	// Bit TRGFRQ.
	PWM_SM0TCTRL_TRGFRQ = 0x1000
	// Trigger outputs are generated during every PWM period even if the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
	PWM_SM0TCTRL_TRGFRQ_TRGFRQ_0 = 0x0
	// Trigger outputs are generated only during the final PWM period prior to a reload opportunity when the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
	PWM_SM0TCTRL_TRGFRQ_TRGFRQ_1 = 0x1
	// Position of PWBOT1 field.
	PWM_SM0TCTRL_PWBOT1_Pos = 0xe
	// Bit mask of PWBOT1 field.
	PWM_SM0TCTRL_PWBOT1_Msk = 0x4000
	// Bit PWBOT1.
	PWM_SM0TCTRL_PWBOT1 = 0x4000
	// Route the PWM_OUT_TRIG1 signal to PWM_OUT_TRIG1 port.
	PWM_SM0TCTRL_PWBOT1_PWBOT1_0 = 0x0
	// Route the PWMB output to the PWM_OUT_TRIG1 port.
	PWM_SM0TCTRL_PWBOT1_PWBOT1_1 = 0x1
	// Position of PWAOT0 field.
	PWM_SM0TCTRL_PWAOT0_Pos = 0xf
	// Bit mask of PWAOT0 field.
	PWM_SM0TCTRL_PWAOT0_Msk = 0x8000
	// Bit PWAOT0.
	PWM_SM0TCTRL_PWAOT0 = 0x8000
	// Route the PWM_OUT_TRIG0 signal to PWM_OUT_TRIG0 port.
	PWM_SM0TCTRL_PWAOT0_PWAOT0_0 = 0x0
	// Route the PWMA output to the PWM_OUT_TRIG0 port.
	PWM_SM0TCTRL_PWAOT0_PWAOT0_1 = 0x1

	// SM0DISMAP0: Fault Disable Mapping Register 0
	// Position of DIS0A field.
	PWM_SM0DISMAP0_DIS0A_Pos = 0x0
	// Bit mask of DIS0A field.
	PWM_SM0DISMAP0_DIS0A_Msk = 0xf
	// Position of DIS0B field.
	PWM_SM0DISMAP0_DIS0B_Pos = 0x4
	// Bit mask of DIS0B field.
	PWM_SM0DISMAP0_DIS0B_Msk = 0xf0
	// Position of DIS0X field.
	PWM_SM0DISMAP0_DIS0X_Pos = 0x8
	// Bit mask of DIS0X field.
	PWM_SM0DISMAP0_DIS0X_Msk = 0xf00

	// SM0DISMAP1: Fault Disable Mapping Register 1
	// Position of DIS1A field.
	PWM_SM0DISMAP1_DIS1A_Pos = 0x0
	// Bit mask of DIS1A field.
	PWM_SM0DISMAP1_DIS1A_Msk = 0xf
	// Position of DIS1B field.
	PWM_SM0DISMAP1_DIS1B_Pos = 0x4
	// Bit mask of DIS1B field.
	PWM_SM0DISMAP1_DIS1B_Msk = 0xf0
	// Position of DIS1X field.
	PWM_SM0DISMAP1_DIS1X_Pos = 0x8
	// Bit mask of DIS1X field.
	PWM_SM0DISMAP1_DIS1X_Msk = 0xf00

	// SM0DTCNT0: Deadtime Count Register 0
	// Position of DTCNT0 field.
	PWM_SM0DTCNT0_DTCNT0_Pos = 0x0
	// Bit mask of DTCNT0 field.
	PWM_SM0DTCNT0_DTCNT0_Msk = 0xffff

	// SM0DTCNT1: Deadtime Count Register 1
	// Position of DTCNT1 field.
	PWM_SM0DTCNT1_DTCNT1_Pos = 0x0
	// Bit mask of DTCNT1 field.
	PWM_SM0DTCNT1_DTCNT1_Msk = 0xffff

	// SM0CAPTCTRLA: Capture Control A Register
	// Position of ARMA field.
	PWM_SM0CAPTCTRLA_ARMA_Pos = 0x0
	// Bit mask of ARMA field.
	PWM_SM0CAPTCTRLA_ARMA_Msk = 0x1
	// Bit ARMA.
	PWM_SM0CAPTCTRLA_ARMA = 0x1
	// Input capture operation is disabled.
	PWM_SM0CAPTCTRLA_ARMA_ARMA_0 = 0x0
	// Input capture operation as specified by CAPTCTRLA[EDGAx] is enabled.
	PWM_SM0CAPTCTRLA_ARMA_ARMA_1 = 0x1
	// Position of ONESHOTA field.
	PWM_SM0CAPTCTRLA_ONESHOTA_Pos = 0x1
	// Bit mask of ONESHOTA field.
	PWM_SM0CAPTCTRLA_ONESHOTA_Msk = 0x2
	// Bit ONESHOTA.
	PWM_SM0CAPTCTRLA_ONESHOTA = 0x2
	// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	PWM_SM0CAPTCTRLA_ONESHOTA_ONESHOTA_0 = 0x0
	// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLA[ARMA] is cleared. No further captures will be performed until CAPTCTRLA[ARMA] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLA[ARMA] is then cleared.
	PWM_SM0CAPTCTRLA_ONESHOTA_ONESHOTA_1 = 0x1
	// Position of EDGA0 field.
	PWM_SM0CAPTCTRLA_EDGA0_Pos = 0x2
	// Bit mask of EDGA0 field.
	PWM_SM0CAPTCTRLA_EDGA0_Msk = 0xc
	// Disabled
	PWM_SM0CAPTCTRLA_EDGA0_EDGA0_0 = 0x0
	// Capture falling edges
	PWM_SM0CAPTCTRLA_EDGA0_EDGA0_1 = 0x1
	// Capture rising edges
	PWM_SM0CAPTCTRLA_EDGA0_EDGA0_2 = 0x2
	// Capture any edge
	PWM_SM0CAPTCTRLA_EDGA0_EDGA0_3 = 0x3
	// Position of EDGA1 field.
	PWM_SM0CAPTCTRLA_EDGA1_Pos = 0x4
	// Bit mask of EDGA1 field.
	PWM_SM0CAPTCTRLA_EDGA1_Msk = 0x30
	// Disabled
	PWM_SM0CAPTCTRLA_EDGA1_EDGA1_0 = 0x0
	// Capture falling edges
	PWM_SM0CAPTCTRLA_EDGA1_EDGA1_1 = 0x1
	// Capture rising edges
	PWM_SM0CAPTCTRLA_EDGA1_EDGA1_2 = 0x2
	// Capture any edge
	PWM_SM0CAPTCTRLA_EDGA1_EDGA1_3 = 0x3
	// Position of INP_SELA field.
	PWM_SM0CAPTCTRLA_INP_SELA_Pos = 0x6
	// Bit mask of INP_SELA field.
	PWM_SM0CAPTCTRLA_INP_SELA_Msk = 0x40
	// Bit INP_SELA.
	PWM_SM0CAPTCTRLA_INP_SELA = 0x40
	// Raw PWM_A input signal selected as source.
	PWM_SM0CAPTCTRLA_INP_SELA_INP_SELA_0 = 0x0
	// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLA[EDGA0] and CAPTCTRLA[EDGA1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRA[EDGA0] and/or CAPTCTRLA[EDGA1] fields in order to enable one or both of the capture registers.
	PWM_SM0CAPTCTRLA_INP_SELA_INP_SELA_1 = 0x1
	// Position of EDGCNTA_EN field.
	PWM_SM0CAPTCTRLA_EDGCNTA_EN_Pos = 0x7
	// Bit mask of EDGCNTA_EN field.
	PWM_SM0CAPTCTRLA_EDGCNTA_EN_Msk = 0x80
	// Bit EDGCNTA_EN.
	PWM_SM0CAPTCTRLA_EDGCNTA_EN = 0x80
	// Edge counter disabled and held in reset
	PWM_SM0CAPTCTRLA_EDGCNTA_EN_EDGCNTA_EN_0 = 0x0
	// Edge counter enabled
	PWM_SM0CAPTCTRLA_EDGCNTA_EN_EDGCNTA_EN_1 = 0x1
	// Position of CFAWM field.
	PWM_SM0CAPTCTRLA_CFAWM_Pos = 0x8
	// Bit mask of CFAWM field.
	PWM_SM0CAPTCTRLA_CFAWM_Msk = 0x300
	// Position of CA0CNT field.
	PWM_SM0CAPTCTRLA_CA0CNT_Pos = 0xa
	// Bit mask of CA0CNT field.
	PWM_SM0CAPTCTRLA_CA0CNT_Msk = 0x1c00
	// Position of CA1CNT field.
	PWM_SM0CAPTCTRLA_CA1CNT_Pos = 0xd
	// Bit mask of CA1CNT field.
	PWM_SM0CAPTCTRLA_CA1CNT_Msk = 0xe000

	// SM0CAPTCOMPA: Capture Compare A Register
	// Position of EDGCMPA field.
	PWM_SM0CAPTCOMPA_EDGCMPA_Pos = 0x0
	// Bit mask of EDGCMPA field.
	PWM_SM0CAPTCOMPA_EDGCMPA_Msk = 0xff
	// Position of EDGCNTA field.
	PWM_SM0CAPTCOMPA_EDGCNTA_Pos = 0x8
	// Bit mask of EDGCNTA field.
	PWM_SM0CAPTCOMPA_EDGCNTA_Msk = 0xff00

	// SM0CAPTCTRLB: Capture Control B Register
	// Position of ARMB field.
	PWM_SM0CAPTCTRLB_ARMB_Pos = 0x0
	// Bit mask of ARMB field.
	PWM_SM0CAPTCTRLB_ARMB_Msk = 0x1
	// Bit ARMB.
	PWM_SM0CAPTCTRLB_ARMB = 0x1
	// Input capture operation is disabled.
	PWM_SM0CAPTCTRLB_ARMB_ARMB_0 = 0x0
	// Input capture operation as specified by CAPTCTRLB[EDGBx] is enabled.
	PWM_SM0CAPTCTRLB_ARMB_ARMB_1 = 0x1
	// Position of ONESHOTB field.
	PWM_SM0CAPTCTRLB_ONESHOTB_Pos = 0x1
	// Bit mask of ONESHOTB field.
	PWM_SM0CAPTCTRLB_ONESHOTB_Msk = 0x2
	// Bit ONESHOTB.
	PWM_SM0CAPTCTRLB_ONESHOTB = 0x2
	// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	PWM_SM0CAPTCTRLB_ONESHOTB_ONESHOTB_0 = 0x0
	// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLB[ARMB] is cleared. No further captures will be performed until CAPTCTRLB[ARMB] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLB[ARMB] is then cleared.
	PWM_SM0CAPTCTRLB_ONESHOTB_ONESHOTB_1 = 0x1
	// Position of EDGB0 field.
	PWM_SM0CAPTCTRLB_EDGB0_Pos = 0x2
	// Bit mask of EDGB0 field.
	PWM_SM0CAPTCTRLB_EDGB0_Msk = 0xc
	// Disabled
	PWM_SM0CAPTCTRLB_EDGB0_EDGB0_0 = 0x0
	// Capture falling edges
	PWM_SM0CAPTCTRLB_EDGB0_EDGB0_1 = 0x1
	// Capture rising edges
	PWM_SM0CAPTCTRLB_EDGB0_EDGB0_2 = 0x2
	// Capture any edge
	PWM_SM0CAPTCTRLB_EDGB0_EDGB0_3 = 0x3
	// Position of EDGB1 field.
	PWM_SM0CAPTCTRLB_EDGB1_Pos = 0x4
	// Bit mask of EDGB1 field.
	PWM_SM0CAPTCTRLB_EDGB1_Msk = 0x30
	// Disabled
	PWM_SM0CAPTCTRLB_EDGB1_EDGB1_0 = 0x0
	// Capture falling edges
	PWM_SM0CAPTCTRLB_EDGB1_EDGB1_1 = 0x1
	// Capture rising edges
	PWM_SM0CAPTCTRLB_EDGB1_EDGB1_2 = 0x2
	// Capture any edge
	PWM_SM0CAPTCTRLB_EDGB1_EDGB1_3 = 0x3
	// Position of INP_SELB field.
	PWM_SM0CAPTCTRLB_INP_SELB_Pos = 0x6
	// Bit mask of INP_SELB field.
	PWM_SM0CAPTCTRLB_INP_SELB_Msk = 0x40
	// Bit INP_SELB.
	PWM_SM0CAPTCTRLB_INP_SELB = 0x40
	// Raw PWM_B input signal selected as source.
	PWM_SM0CAPTCTRLB_INP_SELB_INP_SELB_0 = 0x0
	// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLB[EDGB0] and CAPTCTRLB[EDGB1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRB[EDGB0] and/or CAPTCTRLB[EDGB1] fields in order to enable one or both of the capture registers.
	PWM_SM0CAPTCTRLB_INP_SELB_INP_SELB_1 = 0x1
	// Position of EDGCNTB_EN field.
	PWM_SM0CAPTCTRLB_EDGCNTB_EN_Pos = 0x7
	// Bit mask of EDGCNTB_EN field.
	PWM_SM0CAPTCTRLB_EDGCNTB_EN_Msk = 0x80
	// Bit EDGCNTB_EN.
	PWM_SM0CAPTCTRLB_EDGCNTB_EN = 0x80
	// Edge counter disabled and held in reset
	PWM_SM0CAPTCTRLB_EDGCNTB_EN_EDGCNTB_EN_0 = 0x0
	// Edge counter enabled
	PWM_SM0CAPTCTRLB_EDGCNTB_EN_EDGCNTB_EN_1 = 0x1
	// Position of CFBWM field.
	PWM_SM0CAPTCTRLB_CFBWM_Pos = 0x8
	// Bit mask of CFBWM field.
	PWM_SM0CAPTCTRLB_CFBWM_Msk = 0x300
	// Position of CB0CNT field.
	PWM_SM0CAPTCTRLB_CB0CNT_Pos = 0xa
	// Bit mask of CB0CNT field.
	PWM_SM0CAPTCTRLB_CB0CNT_Msk = 0x1c00
	// Position of CB1CNT field.
	PWM_SM0CAPTCTRLB_CB1CNT_Pos = 0xd
	// Bit mask of CB1CNT field.
	PWM_SM0CAPTCTRLB_CB1CNT_Msk = 0xe000

	// SM0CAPTCOMPB: Capture Compare B Register
	// Position of EDGCMPB field.
	PWM_SM0CAPTCOMPB_EDGCMPB_Pos = 0x0
	// Bit mask of EDGCMPB field.
	PWM_SM0CAPTCOMPB_EDGCMPB_Msk = 0xff
	// Position of EDGCNTB field.
	PWM_SM0CAPTCOMPB_EDGCNTB_Pos = 0x8
	// Bit mask of EDGCNTB field.
	PWM_SM0CAPTCOMPB_EDGCNTB_Msk = 0xff00

	// SM0CAPTCTRLX: Capture Control X Register
	// Position of ARMX field.
	PWM_SM0CAPTCTRLX_ARMX_Pos = 0x0
	// Bit mask of ARMX field.
	PWM_SM0CAPTCTRLX_ARMX_Msk = 0x1
	// Bit ARMX.
	PWM_SM0CAPTCTRLX_ARMX = 0x1
	// Input capture operation is disabled.
	PWM_SM0CAPTCTRLX_ARMX_ARMX_0 = 0x0
	// Input capture operation as specified by CAPTCTRLX[EDGXx] is enabled.
	PWM_SM0CAPTCTRLX_ARMX_ARMX_1 = 0x1
	// Position of ONESHOTX field.
	PWM_SM0CAPTCTRLX_ONESHOTX_Pos = 0x1
	// Bit mask of ONESHOTX field.
	PWM_SM0CAPTCTRLX_ONESHOTX_Msk = 0x2
	// Bit ONESHOTX.
	PWM_SM0CAPTCTRLX_ONESHOTX = 0x2
	// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	PWM_SM0CAPTCTRLX_ONESHOTX_ONESHOTX_0 = 0x0
	// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and the ARMX bit is cleared. No further captures will be performed until the ARMX bit is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and the ARMX bit is then cleared.
	PWM_SM0CAPTCTRLX_ONESHOTX_ONESHOTX_1 = 0x1
	// Position of EDGX0 field.
	PWM_SM0CAPTCTRLX_EDGX0_Pos = 0x2
	// Bit mask of EDGX0 field.
	PWM_SM0CAPTCTRLX_EDGX0_Msk = 0xc
	// Disabled
	PWM_SM0CAPTCTRLX_EDGX0_EDGX0_0 = 0x0
	// Capture falling edges
	PWM_SM0CAPTCTRLX_EDGX0_EDGX0_1 = 0x1
	// Capture rising edges
	PWM_SM0CAPTCTRLX_EDGX0_EDGX0_2 = 0x2
	// Capture any edge
	PWM_SM0CAPTCTRLX_EDGX0_EDGX0_3 = 0x3
	// Position of EDGX1 field.
	PWM_SM0CAPTCTRLX_EDGX1_Pos = 0x4
	// Bit mask of EDGX1 field.
	PWM_SM0CAPTCTRLX_EDGX1_Msk = 0x30
	// Disabled
	PWM_SM0CAPTCTRLX_EDGX1_EDGX1_0 = 0x0
	// Capture falling edges
	PWM_SM0CAPTCTRLX_EDGX1_EDGX1_1 = 0x1
	// Capture rising edges
	PWM_SM0CAPTCTRLX_EDGX1_EDGX1_2 = 0x2
	// Capture any edge
	PWM_SM0CAPTCTRLX_EDGX1_EDGX1_3 = 0x3
	// Position of INP_SELX field.
	PWM_SM0CAPTCTRLX_INP_SELX_Pos = 0x6
	// Bit mask of INP_SELX field.
	PWM_SM0CAPTCTRLX_INP_SELX_Msk = 0x40
	// Bit INP_SELX.
	PWM_SM0CAPTCTRLX_INP_SELX = 0x40
	// Raw PWM_X input signal selected as source.
	PWM_SM0CAPTCTRLX_INP_SELX_INP_SELX_0 = 0x0
	// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLX[EDGX0] and CAPTCTRLX[EDGX1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRX[EDGX0] and/or CAPTCTRLX[EDGX1] fields in order to enable one or both of the capture registers.
	PWM_SM0CAPTCTRLX_INP_SELX_INP_SELX_1 = 0x1
	// Position of EDGCNTX_EN field.
	PWM_SM0CAPTCTRLX_EDGCNTX_EN_Pos = 0x7
	// Bit mask of EDGCNTX_EN field.
	PWM_SM0CAPTCTRLX_EDGCNTX_EN_Msk = 0x80
	// Bit EDGCNTX_EN.
	PWM_SM0CAPTCTRLX_EDGCNTX_EN = 0x80
	// Edge counter disabled and held in reset
	PWM_SM0CAPTCTRLX_EDGCNTX_EN_EDGCNTX_EN_0 = 0x0
	// Edge counter enabled
	PWM_SM0CAPTCTRLX_EDGCNTX_EN_EDGCNTX_EN_1 = 0x1
	// Position of CFXWM field.
	PWM_SM0CAPTCTRLX_CFXWM_Pos = 0x8
	// Bit mask of CFXWM field.
	PWM_SM0CAPTCTRLX_CFXWM_Msk = 0x300
	// Position of CX0CNT field.
	PWM_SM0CAPTCTRLX_CX0CNT_Pos = 0xa
	// Bit mask of CX0CNT field.
	PWM_SM0CAPTCTRLX_CX0CNT_Msk = 0x1c00
	// Position of CX1CNT field.
	PWM_SM0CAPTCTRLX_CX1CNT_Pos = 0xd
	// Bit mask of CX1CNT field.
	PWM_SM0CAPTCTRLX_CX1CNT_Msk = 0xe000

	// SM0CAPTCOMPX: Capture Compare X Register
	// Position of EDGCMPX field.
	PWM_SM0CAPTCOMPX_EDGCMPX_Pos = 0x0
	// Bit mask of EDGCMPX field.
	PWM_SM0CAPTCOMPX_EDGCMPX_Msk = 0xff
	// Position of EDGCNTX field.
	PWM_SM0CAPTCOMPX_EDGCNTX_Pos = 0x8
	// Bit mask of EDGCNTX field.
	PWM_SM0CAPTCOMPX_EDGCNTX_Msk = 0xff00

	// SM0CVAL0: Capture Value 0 Register
	// Position of CAPTVAL0 field.
	PWM_SM0CVAL0_CAPTVAL0_Pos = 0x0
	// Bit mask of CAPTVAL0 field.
	PWM_SM0CVAL0_CAPTVAL0_Msk = 0xffff

	// SM0CVAL0CYC: Capture Value 0 Cycle Register
	// Position of CVAL0CYC field.
	PWM_SM0CVAL0CYC_CVAL0CYC_Pos = 0x0
	// Bit mask of CVAL0CYC field.
	PWM_SM0CVAL0CYC_CVAL0CYC_Msk = 0xf

	// SM0CVAL1: Capture Value 1 Register
	// Position of CAPTVAL1 field.
	PWM_SM0CVAL1_CAPTVAL1_Pos = 0x0
	// Bit mask of CAPTVAL1 field.
	PWM_SM0CVAL1_CAPTVAL1_Msk = 0xffff

	// SM0CVAL1CYC: Capture Value 1 Cycle Register
	// Position of CVAL1CYC field.
	PWM_SM0CVAL1CYC_CVAL1CYC_Pos = 0x0
	// Bit mask of CVAL1CYC field.
	PWM_SM0CVAL1CYC_CVAL1CYC_Msk = 0xf

	// SM0CVAL2: Capture Value 2 Register
	// Position of CAPTVAL2 field.
	PWM_SM0CVAL2_CAPTVAL2_Pos = 0x0
	// Bit mask of CAPTVAL2 field.
	PWM_SM0CVAL2_CAPTVAL2_Msk = 0xffff

	// SM0CVAL2CYC: Capture Value 2 Cycle Register
	// Position of CVAL2CYC field.
	PWM_SM0CVAL2CYC_CVAL2CYC_Pos = 0x0
	// Bit mask of CVAL2CYC field.
	PWM_SM0CVAL2CYC_CVAL2CYC_Msk = 0xf

	// SM0CVAL3: Capture Value 3 Register
	// Position of CAPTVAL3 field.
	PWM_SM0CVAL3_CAPTVAL3_Pos = 0x0
	// Bit mask of CAPTVAL3 field.
	PWM_SM0CVAL3_CAPTVAL3_Msk = 0xffff

	// SM0CVAL3CYC: Capture Value 3 Cycle Register
	// Position of CVAL3CYC field.
	PWM_SM0CVAL3CYC_CVAL3CYC_Pos = 0x0
	// Bit mask of CVAL3CYC field.
	PWM_SM0CVAL3CYC_CVAL3CYC_Msk = 0xf

	// SM0CVAL4: Capture Value 4 Register
	// Position of CAPTVAL4 field.
	PWM_SM0CVAL4_CAPTVAL4_Pos = 0x0
	// Bit mask of CAPTVAL4 field.
	PWM_SM0CVAL4_CAPTVAL4_Msk = 0xffff

	// SM0CVAL4CYC: Capture Value 4 Cycle Register
	// Position of CVAL4CYC field.
	PWM_SM0CVAL4CYC_CVAL4CYC_Pos = 0x0
	// Bit mask of CVAL4CYC field.
	PWM_SM0CVAL4CYC_CVAL4CYC_Msk = 0xf

	// SM0CVAL5: Capture Value 5 Register
	// Position of CAPTVAL5 field.
	PWM_SM0CVAL5_CAPTVAL5_Pos = 0x0
	// Bit mask of CAPTVAL5 field.
	PWM_SM0CVAL5_CAPTVAL5_Msk = 0xffff

	// SM0CVAL5CYC: Capture Value 5 Cycle Register
	// Position of CVAL5CYC field.
	PWM_SM0CVAL5CYC_CVAL5CYC_Pos = 0x0
	// Bit mask of CVAL5CYC field.
	PWM_SM0CVAL5CYC_CVAL5CYC_Msk = 0xf

	// SM0PHASEDLY: Phase Delay Register
	// Position of PHASEDLY field.
	PWM_SM0PHASEDLY_PHASEDLY_Pos = 0x0
	// Bit mask of PHASEDLY field.
	PWM_SM0PHASEDLY_PHASEDLY_Msk = 0xffff

	// SM1CNT: Counter Register
	// Position of CNT field.
	PWM_SM1CNT_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PWM_SM1CNT_CNT_Msk = 0xffff

	// SM1INIT: Initial Count Register
	// Position of INIT field.
	PWM_SM1INIT_INIT_Pos = 0x0
	// Bit mask of INIT field.
	PWM_SM1INIT_INIT_Msk = 0xffff

	// SM1CTRL2: Control 2 Register
	// Position of CLK_SEL field.
	PWM_SM1CTRL2_CLK_SEL_Pos = 0x0
	// Bit mask of CLK_SEL field.
	PWM_SM1CTRL2_CLK_SEL_Msk = 0x3
	// The IPBus clock is used as the clock for the local prescaler and counter.
	PWM_SM1CTRL2_CLK_SEL_CLK_SEL_0 = 0x0
	// EXT_CLK is used as the clock for the local prescaler and counter.
	PWM_SM1CTRL2_CLK_SEL_CLK_SEL_1 = 0x1
	// Submodule 0's clock (AUX_CLK) is used as the source clock for the local prescaler and counter. This setting should not be used in submodule 0 as it will force the clock to logic 0.
	PWM_SM1CTRL2_CLK_SEL_CLK_SEL_2 = 0x2
	// Position of RELOAD_SEL field.
	PWM_SM1CTRL2_RELOAD_SEL_Pos = 0x2
	// Bit mask of RELOAD_SEL field.
	PWM_SM1CTRL2_RELOAD_SEL_Msk = 0x4
	// Bit RELOAD_SEL.
	PWM_SM1CTRL2_RELOAD_SEL = 0x4
	// The local RELOAD signal is used to reload registers.
	PWM_SM1CTRL2_RELOAD_SEL_RELOAD_SEL_0 = 0x0
	// The master RELOAD signal (from submodule 0) is used to reload registers. This setting should not be used in submodule 0 as it will force the RELOAD signal to logic 0.
	PWM_SM1CTRL2_RELOAD_SEL_RELOAD_SEL_1 = 0x1
	// Position of FORCE_SEL field.
	PWM_SM1CTRL2_FORCE_SEL_Pos = 0x3
	// Bit mask of FORCE_SEL field.
	PWM_SM1CTRL2_FORCE_SEL_Msk = 0x38
	// The local force signal, CTRL2[FORCE], from this submodule is used to force updates.
	PWM_SM1CTRL2_FORCE_SEL_FORCE_SEL_0 = 0x0
	// The master force signal from submodule 0 is used to force updates. This setting should not be used in submodule 0 as it will hold the FORCE OUTPUT signal to logic 0.
	PWM_SM1CTRL2_FORCE_SEL_FORCE_SEL_1 = 0x1
	// The local reload signal from this submodule is used to force updates without regard to the state of LDOK.
	PWM_SM1CTRL2_FORCE_SEL_FORCE_SEL_2 = 0x2
	// The master reload signal from submodule0 is used to force updates if LDOK is set. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	PWM_SM1CTRL2_FORCE_SEL_FORCE_SEL_3 = 0x3
	// The local sync signal from this submodule is used to force updates.
	PWM_SM1CTRL2_FORCE_SEL_FORCE_SEL_4 = 0x4
	// The master sync signal from submodule0 is used to force updates. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	PWM_SM1CTRL2_FORCE_SEL_FORCE_SEL_5 = 0x5
	// The external force signal, EXT_FORCE, from outside the PWM module causes updates.
	PWM_SM1CTRL2_FORCE_SEL_FORCE_SEL_6 = 0x6
	// The external sync signal, EXT_SYNC, from outside the PWM module causes updates.
	PWM_SM1CTRL2_FORCE_SEL_FORCE_SEL_7 = 0x7
	// Position of FORCE field.
	PWM_SM1CTRL2_FORCE_Pos = 0x6
	// Bit mask of FORCE field.
	PWM_SM1CTRL2_FORCE_Msk = 0x40
	// Bit FORCE.
	PWM_SM1CTRL2_FORCE = 0x40
	// Position of FRCEN field.
	PWM_SM1CTRL2_FRCEN_Pos = 0x7
	// Bit mask of FRCEN field.
	PWM_SM1CTRL2_FRCEN_Msk = 0x80
	// Bit FRCEN.
	PWM_SM1CTRL2_FRCEN = 0x80
	// Initialization from a FORCE_OUT is disabled.
	PWM_SM1CTRL2_FRCEN_FRCEN_0 = 0x0
	// Initialization from a FORCE_OUT is enabled.
	PWM_SM1CTRL2_FRCEN_FRCEN_1 = 0x1
	// Position of INIT_SEL field.
	PWM_SM1CTRL2_INIT_SEL_Pos = 0x8
	// Bit mask of INIT_SEL field.
	PWM_SM1CTRL2_INIT_SEL_Msk = 0x300
	// Local sync (PWM_X) causes initialization.
	PWM_SM1CTRL2_INIT_SEL_INIT_SEL_0 = 0x0
	// Master reload from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0. The submodule counter will only reinitialize when a master reload occurs.
	PWM_SM1CTRL2_INIT_SEL_INIT_SEL_1 = 0x1
	// Master sync from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0.
	PWM_SM1CTRL2_INIT_SEL_INIT_SEL_2 = 0x2
	// EXT_SYNC causes initialization.
	PWM_SM1CTRL2_INIT_SEL_INIT_SEL_3 = 0x3
	// Position of PWMX_INIT field.
	PWM_SM1CTRL2_PWMX_INIT_Pos = 0xa
	// Bit mask of PWMX_INIT field.
	PWM_SM1CTRL2_PWMX_INIT_Msk = 0x400
	// Bit PWMX_INIT.
	PWM_SM1CTRL2_PWMX_INIT = 0x400
	// Position of PWM45_INIT field.
	PWM_SM1CTRL2_PWM45_INIT_Pos = 0xb
	// Bit mask of PWM45_INIT field.
	PWM_SM1CTRL2_PWM45_INIT_Msk = 0x800
	// Bit PWM45_INIT.
	PWM_SM1CTRL2_PWM45_INIT = 0x800
	// Position of PWM23_INIT field.
	PWM_SM1CTRL2_PWM23_INIT_Pos = 0xc
	// Bit mask of PWM23_INIT field.
	PWM_SM1CTRL2_PWM23_INIT_Msk = 0x1000
	// Bit PWM23_INIT.
	PWM_SM1CTRL2_PWM23_INIT = 0x1000
	// Position of INDEP field.
	PWM_SM1CTRL2_INDEP_Pos = 0xd
	// Bit mask of INDEP field.
	PWM_SM1CTRL2_INDEP_Msk = 0x2000
	// Bit INDEP.
	PWM_SM1CTRL2_INDEP = 0x2000
	// PWM_A and PWM_B form a complementary PWM pair.
	PWM_SM1CTRL2_INDEP_INDEP_0 = 0x0
	// PWM_A and PWM_B outputs are independent PWMs.
	PWM_SM1CTRL2_INDEP_INDEP_1 = 0x1
	// Position of WAITEN field.
	PWM_SM1CTRL2_WAITEN_Pos = 0xe
	// Bit mask of WAITEN field.
	PWM_SM1CTRL2_WAITEN_Msk = 0x4000
	// Bit WAITEN.
	PWM_SM1CTRL2_WAITEN = 0x4000
	// Position of DBGEN field.
	PWM_SM1CTRL2_DBGEN_Pos = 0xf
	// Bit mask of DBGEN field.
	PWM_SM1CTRL2_DBGEN_Msk = 0x8000
	// Bit DBGEN.
	PWM_SM1CTRL2_DBGEN = 0x8000

	// SM1CTRL: Control Register
	// Position of DBLEN field.
	PWM_SM1CTRL_DBLEN_Pos = 0x0
	// Bit mask of DBLEN field.
	PWM_SM1CTRL_DBLEN_Msk = 0x1
	// Bit DBLEN.
	PWM_SM1CTRL_DBLEN = 0x1
	// Double switching disabled.
	PWM_SM1CTRL_DBLEN_DBLEN_0 = 0x0
	// Double switching enabled.
	PWM_SM1CTRL_DBLEN_DBLEN_1 = 0x1
	// Position of DBLX field.
	PWM_SM1CTRL_DBLX_Pos = 0x1
	// Bit mask of DBLX field.
	PWM_SM1CTRL_DBLX_Msk = 0x2
	// Bit DBLX.
	PWM_SM1CTRL_DBLX = 0x2
	// PWMX double pulse disabled.
	PWM_SM1CTRL_DBLX_DBLX_0 = 0x0
	// PWMX double pulse enabled.
	PWM_SM1CTRL_DBLX_DBLX_1 = 0x1
	// Position of LDMOD field.
	PWM_SM1CTRL_LDMOD_Pos = 0x2
	// Bit mask of LDMOD field.
	PWM_SM1CTRL_LDMOD_Msk = 0x4
	// Bit LDMOD.
	PWM_SM1CTRL_LDMOD = 0x4
	// Buffered registers of this submodule are loaded and take effect at the next PWM reload if MCTRL[LDOK] is set.
	PWM_SM1CTRL_LDMOD_LDMOD_0 = 0x0
	// Buffered registers of this submodule are loaded and take effect immediately upon MCTRL[LDOK] being set. In this case it is not necessary to set CTRL[FULL] or CTRL[HALF].
	PWM_SM1CTRL_LDMOD_LDMOD_1 = 0x1
	// Position of SPLIT field.
	PWM_SM1CTRL_SPLIT_Pos = 0x3
	// Bit mask of SPLIT field.
	PWM_SM1CTRL_SPLIT_Msk = 0x8
	// Bit SPLIT.
	PWM_SM1CTRL_SPLIT = 0x8
	// DBLPWM is not split. PWMA and PWMB each have double pulses.
	PWM_SM1CTRL_SPLIT_SPLIT_0 = 0x0
	// DBLPWM is split to PWMA and PWMB.
	PWM_SM1CTRL_SPLIT_SPLIT_1 = 0x1
	// Position of PRSC field.
	PWM_SM1CTRL_PRSC_Pos = 0x4
	// Bit mask of PRSC field.
	PWM_SM1CTRL_PRSC_Msk = 0x70
	// PWM clock frequency = fclk
	PWM_SM1CTRL_PRSC_PRSC_0 = 0x0
	// PWM clock frequency = fclk/2
	PWM_SM1CTRL_PRSC_PRSC_1 = 0x1
	// PWM clock frequency = fclk/4
	PWM_SM1CTRL_PRSC_PRSC_2 = 0x2
	// PWM clock frequency = fclk/8
	PWM_SM1CTRL_PRSC_PRSC_3 = 0x3
	// PWM clock frequency = fclk/16
	PWM_SM1CTRL_PRSC_PRSC_4 = 0x4
	// PWM clock frequency = fclk/32
	PWM_SM1CTRL_PRSC_PRSC_5 = 0x5
	// PWM clock frequency = fclk/64
	PWM_SM1CTRL_PRSC_PRSC_6 = 0x6
	// PWM clock frequency = fclk/128
	PWM_SM1CTRL_PRSC_PRSC_7 = 0x7
	// Position of COMPMODE field.
	PWM_SM1CTRL_COMPMODE_Pos = 0x7
	// Bit mask of COMPMODE field.
	PWM_SM1CTRL_COMPMODE_Msk = 0x80
	// Bit COMPMODE.
	PWM_SM1CTRL_COMPMODE = 0x80
	// The VAL* registers and the PWM counter are compared using an "equal to" method. This means that PWM edges are only produced when the counter is equal to one of the VAL* register values. This implies that a PWMA output that is high at the end of a period will maintain this state until a match with VAL3 clears the output in the following period.
	PWM_SM1CTRL_COMPMODE_COMPMODE_0 = 0x0
	// The VAL* registers and the PWM counter are compared using an "equal to or greater than" method. This means that PWM edges are produced when the counter is equal to or greater than one of the VAL* register values. This implies that a PWMA output that is high at the end of a period could go low at the start of the next period if the starting counter value is greater than (but not necessarily equal to) the new VAL3 value.
	PWM_SM1CTRL_COMPMODE_COMPMODE_1 = 0x1
	// Position of DT field.
	PWM_SM1CTRL_DT_Pos = 0x8
	// Bit mask of DT field.
	PWM_SM1CTRL_DT_Msk = 0x300
	// Position of FULL field.
	PWM_SM1CTRL_FULL_Pos = 0xa
	// Bit mask of FULL field.
	PWM_SM1CTRL_FULL_Msk = 0x400
	// Bit FULL.
	PWM_SM1CTRL_FULL = 0x400
	// Full-cycle reloads disabled.
	PWM_SM1CTRL_FULL_FULL_0 = 0x0
	// Full-cycle reloads enabled.
	PWM_SM1CTRL_FULL_FULL_1 = 0x1
	// Position of HALF field.
	PWM_SM1CTRL_HALF_Pos = 0xb
	// Bit mask of HALF field.
	PWM_SM1CTRL_HALF_Msk = 0x800
	// Bit HALF.
	PWM_SM1CTRL_HALF = 0x800
	// Half-cycle reloads disabled.
	PWM_SM1CTRL_HALF_HALF_0 = 0x0
	// Half-cycle reloads enabled.
	PWM_SM1CTRL_HALF_HALF_1 = 0x1
	// Position of LDFQ field.
	PWM_SM1CTRL_LDFQ_Pos = 0xc
	// Bit mask of LDFQ field.
	PWM_SM1CTRL_LDFQ_Msk = 0xf000
	// Every PWM opportunity
	PWM_SM1CTRL_LDFQ_LDFQ_0 = 0x0
	// Every 2 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_1 = 0x1
	// Every 3 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_2 = 0x2
	// Every 4 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_3 = 0x3
	// Every 5 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_4 = 0x4
	// Every 6 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_5 = 0x5
	// Every 7 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_6 = 0x6
	// Every 8 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_7 = 0x7
	// Every 9 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_8 = 0x8
	// Every 10 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_9 = 0x9
	// Every 11 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_10 = 0xa
	// Every 12 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_11 = 0xb
	// Every 13 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_12 = 0xc
	// Every 14 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_13 = 0xd
	// Every 15 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_14 = 0xe
	// Every 16 PWM opportunities
	PWM_SM1CTRL_LDFQ_LDFQ_15 = 0xf

	// SM1VAL0: Value Register 0
	// Position of VAL0 field.
	PWM_SM1VAL0_VAL0_Pos = 0x0
	// Bit mask of VAL0 field.
	PWM_SM1VAL0_VAL0_Msk = 0xffff

	// SM1FRACVAL1: Fractional Value Register 1
	// Position of FRACVAL1 field.
	PWM_SM1FRACVAL1_FRACVAL1_Pos = 0xb
	// Bit mask of FRACVAL1 field.
	PWM_SM1FRACVAL1_FRACVAL1_Msk = 0xf800

	// SM1VAL1: Value Register 1
	// Position of VAL1 field.
	PWM_SM1VAL1_VAL1_Pos = 0x0
	// Bit mask of VAL1 field.
	PWM_SM1VAL1_VAL1_Msk = 0xffff

	// SM1FRACVAL2: Fractional Value Register 2
	// Position of FRACVAL2 field.
	PWM_SM1FRACVAL2_FRACVAL2_Pos = 0xb
	// Bit mask of FRACVAL2 field.
	PWM_SM1FRACVAL2_FRACVAL2_Msk = 0xf800

	// SM1VAL2: Value Register 2
	// Position of VAL2 field.
	PWM_SM1VAL2_VAL2_Pos = 0x0
	// Bit mask of VAL2 field.
	PWM_SM1VAL2_VAL2_Msk = 0xffff

	// SM1FRACVAL3: Fractional Value Register 3
	// Position of FRACVAL3 field.
	PWM_SM1FRACVAL3_FRACVAL3_Pos = 0xb
	// Bit mask of FRACVAL3 field.
	PWM_SM1FRACVAL3_FRACVAL3_Msk = 0xf800

	// SM1VAL3: Value Register 3
	// Position of VAL3 field.
	PWM_SM1VAL3_VAL3_Pos = 0x0
	// Bit mask of VAL3 field.
	PWM_SM1VAL3_VAL3_Msk = 0xffff

	// SM1FRACVAL4: Fractional Value Register 4
	// Position of FRACVAL4 field.
	PWM_SM1FRACVAL4_FRACVAL4_Pos = 0xb
	// Bit mask of FRACVAL4 field.
	PWM_SM1FRACVAL4_FRACVAL4_Msk = 0xf800

	// SM1VAL4: Value Register 4
	// Position of VAL4 field.
	PWM_SM1VAL4_VAL4_Pos = 0x0
	// Bit mask of VAL4 field.
	PWM_SM1VAL4_VAL4_Msk = 0xffff

	// SM1FRACVAL5: Fractional Value Register 5
	// Position of FRACVAL5 field.
	PWM_SM1FRACVAL5_FRACVAL5_Pos = 0xb
	// Bit mask of FRACVAL5 field.
	PWM_SM1FRACVAL5_FRACVAL5_Msk = 0xf800

	// SM1VAL5: Value Register 5
	// Position of VAL5 field.
	PWM_SM1VAL5_VAL5_Pos = 0x0
	// Bit mask of VAL5 field.
	PWM_SM1VAL5_VAL5_Msk = 0xffff

	// SM1FRCTRL: Fractional Control Register
	// Position of FRAC1_EN field.
	PWM_SM1FRCTRL_FRAC1_EN_Pos = 0x1
	// Bit mask of FRAC1_EN field.
	PWM_SM1FRCTRL_FRAC1_EN_Msk = 0x2
	// Bit FRAC1_EN.
	PWM_SM1FRCTRL_FRAC1_EN = 0x2
	// Disable fractional cycle length for the PWM period.
	PWM_SM1FRCTRL_FRAC1_EN_FRAC1_EN_0 = 0x0
	// Enable fractional cycle length for the PWM period.
	PWM_SM1FRCTRL_FRAC1_EN_FRAC1_EN_1 = 0x1
	// Position of FRAC23_EN field.
	PWM_SM1FRCTRL_FRAC23_EN_Pos = 0x2
	// Bit mask of FRAC23_EN field.
	PWM_SM1FRCTRL_FRAC23_EN_Msk = 0x4
	// Bit FRAC23_EN.
	PWM_SM1FRCTRL_FRAC23_EN = 0x4
	// Disable fractional cycle placement for PWM_A.
	PWM_SM1FRCTRL_FRAC23_EN_FRAC23_EN_0 = 0x0
	// Enable fractional cycle placement for PWM_A.
	PWM_SM1FRCTRL_FRAC23_EN_FRAC23_EN_1 = 0x1
	// Position of FRAC45_EN field.
	PWM_SM1FRCTRL_FRAC45_EN_Pos = 0x4
	// Bit mask of FRAC45_EN field.
	PWM_SM1FRCTRL_FRAC45_EN_Msk = 0x10
	// Bit FRAC45_EN.
	PWM_SM1FRCTRL_FRAC45_EN = 0x10
	// Disable fractional cycle placement for PWM_B.
	PWM_SM1FRCTRL_FRAC45_EN_FRAC45_EN_0 = 0x0
	// Enable fractional cycle placement for PWM_B.
	PWM_SM1FRCTRL_FRAC45_EN_FRAC45_EN_1 = 0x1
	// Position of FRAC_PU field.
	PWM_SM1FRCTRL_FRAC_PU_Pos = 0x8
	// Bit mask of FRAC_PU field.
	PWM_SM1FRCTRL_FRAC_PU_Msk = 0x100
	// Bit FRAC_PU.
	PWM_SM1FRCTRL_FRAC_PU = 0x100
	// Turn off fractional delay logic.
	PWM_SM1FRCTRL_FRAC_PU_FRAC_PU_0 = 0x0
	// Power up fractional delay logic.
	PWM_SM1FRCTRL_FRAC_PU_FRAC_PU_1 = 0x1
	// Position of TEST field.
	PWM_SM1FRCTRL_TEST_Pos = 0xf
	// Bit mask of TEST field.
	PWM_SM1FRCTRL_TEST_Msk = 0x8000
	// Bit TEST.
	PWM_SM1FRCTRL_TEST = 0x8000

	// SM1OCTRL: Output Control Register
	// Position of PWMXFS field.
	PWM_SM1OCTRL_PWMXFS_Pos = 0x0
	// Bit mask of PWMXFS field.
	PWM_SM1OCTRL_PWMXFS_Msk = 0x3
	// Output is forced to logic 0 state prior to consideration of output polarity control.
	PWM_SM1OCTRL_PWMXFS_PWMXFS_0 = 0x0
	// Output is forced to logic 1 state prior to consideration of output polarity control.
	PWM_SM1OCTRL_PWMXFS_PWMXFS_1 = 0x1
	// Output is tristated.
	PWM_SM1OCTRL_PWMXFS_PWMXFS_2 = 0x2
	// Output is tristated.
	PWM_SM1OCTRL_PWMXFS_PWMXFS_3 = 0x3
	// Position of PWMBFS field.
	PWM_SM1OCTRL_PWMBFS_Pos = 0x2
	// Bit mask of PWMBFS field.
	PWM_SM1OCTRL_PWMBFS_Msk = 0xc
	// Output is forced to logic 0 state prior to consideration of output polarity control.
	PWM_SM1OCTRL_PWMBFS_PWMBFS_0 = 0x0
	// Output is forced to logic 1 state prior to consideration of output polarity control.
	PWM_SM1OCTRL_PWMBFS_PWMBFS_1 = 0x1
	// Output is tristated.
	PWM_SM1OCTRL_PWMBFS_PWMBFS_2 = 0x2
	// Output is tristated.
	PWM_SM1OCTRL_PWMBFS_PWMBFS_3 = 0x3
	// Position of PWMAFS field.
	PWM_SM1OCTRL_PWMAFS_Pos = 0x4
	// Bit mask of PWMAFS field.
	PWM_SM1OCTRL_PWMAFS_Msk = 0x30
	// Output is forced to logic 0 state prior to consideration of output polarity control.
	PWM_SM1OCTRL_PWMAFS_PWMAFS_0 = 0x0
	// Output is forced to logic 1 state prior to consideration of output polarity control.
	PWM_SM1OCTRL_PWMAFS_PWMAFS_1 = 0x1
	// Output is tristated.
	PWM_SM1OCTRL_PWMAFS_PWMAFS_2 = 0x2
	// Output is tristated.
	PWM_SM1OCTRL_PWMAFS_PWMAFS_3 = 0x3
	// Position of POLX field.
	PWM_SM1OCTRL_POLX_Pos = 0x8
	// Bit mask of POLX field.
	PWM_SM1OCTRL_POLX_Msk = 0x100
	// Bit POLX.
	PWM_SM1OCTRL_POLX = 0x100
	// PWM_X output not inverted. A high level on the PWM_X pin represents the "on" or "active" state.
	PWM_SM1OCTRL_POLX_POLX_0 = 0x0
	// PWM_X output inverted. A low level on the PWM_X pin represents the "on" or "active" state.
	PWM_SM1OCTRL_POLX_POLX_1 = 0x1
	// Position of POLB field.
	PWM_SM1OCTRL_POLB_Pos = 0x9
	// Bit mask of POLB field.
	PWM_SM1OCTRL_POLB_Msk = 0x200
	// Bit POLB.
	PWM_SM1OCTRL_POLB = 0x200
	// PWM_B output not inverted. A high level on the PWM_B pin represents the "on" or "active" state.
	PWM_SM1OCTRL_POLB_POLB_0 = 0x0
	// PWM_B output inverted. A low level on the PWM_B pin represents the "on" or "active" state.
	PWM_SM1OCTRL_POLB_POLB_1 = 0x1
	// Position of POLA field.
	PWM_SM1OCTRL_POLA_Pos = 0xa
	// Bit mask of POLA field.
	PWM_SM1OCTRL_POLA_Msk = 0x400
	// Bit POLA.
	PWM_SM1OCTRL_POLA = 0x400
	// PWM_A output not inverted. A high level on the PWM_A pin represents the "on" or "active" state.
	PWM_SM1OCTRL_POLA_POLA_0 = 0x0
	// PWM_A output inverted. A low level on the PWM_A pin represents the "on" or "active" state.
	PWM_SM1OCTRL_POLA_POLA_1 = 0x1
	// Position of PWMX_IN field.
	PWM_SM1OCTRL_PWMX_IN_Pos = 0xd
	// Bit mask of PWMX_IN field.
	PWM_SM1OCTRL_PWMX_IN_Msk = 0x2000
	// Bit PWMX_IN.
	PWM_SM1OCTRL_PWMX_IN = 0x2000
	// Position of PWMB_IN field.
	PWM_SM1OCTRL_PWMB_IN_Pos = 0xe
	// Bit mask of PWMB_IN field.
	PWM_SM1OCTRL_PWMB_IN_Msk = 0x4000
	// Bit PWMB_IN.
	PWM_SM1OCTRL_PWMB_IN = 0x4000
	// Position of PWMA_IN field.
	PWM_SM1OCTRL_PWMA_IN_Pos = 0xf
	// Bit mask of PWMA_IN field.
	PWM_SM1OCTRL_PWMA_IN_Msk = 0x8000
	// Bit PWMA_IN.
	PWM_SM1OCTRL_PWMA_IN = 0x8000

	// SM1STS: Status Register
	// Position of CMPF field.
	PWM_SM1STS_CMPF_Pos = 0x0
	// Bit mask of CMPF field.
	PWM_SM1STS_CMPF_Msk = 0x3f
	// No compare event has occurred for a particular VALx value.
	PWM_SM1STS_CMPF_CMPF_0 = 0x0
	// A compare event has occurred for a particular VALx value.
	PWM_SM1STS_CMPF_CMPF_1 = 0x1
	// Position of CFX0 field.
	PWM_SM1STS_CFX0_Pos = 0x6
	// Bit mask of CFX0 field.
	PWM_SM1STS_CFX0_Msk = 0x40
	// Bit CFX0.
	PWM_SM1STS_CFX0 = 0x40
	// Position of CFX1 field.
	PWM_SM1STS_CFX1_Pos = 0x7
	// Bit mask of CFX1 field.
	PWM_SM1STS_CFX1_Msk = 0x80
	// Bit CFX1.
	PWM_SM1STS_CFX1 = 0x80
	// Position of CFB0 field.
	PWM_SM1STS_CFB0_Pos = 0x8
	// Bit mask of CFB0 field.
	PWM_SM1STS_CFB0_Msk = 0x100
	// Bit CFB0.
	PWM_SM1STS_CFB0 = 0x100
	// Position of CFB1 field.
	PWM_SM1STS_CFB1_Pos = 0x9
	// Bit mask of CFB1 field.
	PWM_SM1STS_CFB1_Msk = 0x200
	// Bit CFB1.
	PWM_SM1STS_CFB1 = 0x200
	// Position of CFA0 field.
	PWM_SM1STS_CFA0_Pos = 0xa
	// Bit mask of CFA0 field.
	PWM_SM1STS_CFA0_Msk = 0x400
	// Bit CFA0.
	PWM_SM1STS_CFA0 = 0x400
	// Position of CFA1 field.
	PWM_SM1STS_CFA1_Pos = 0xb
	// Bit mask of CFA1 field.
	PWM_SM1STS_CFA1_Msk = 0x800
	// Bit CFA1.
	PWM_SM1STS_CFA1 = 0x800
	// Position of RF field.
	PWM_SM1STS_RF_Pos = 0xc
	// Bit mask of RF field.
	PWM_SM1STS_RF_Msk = 0x1000
	// Bit RF.
	PWM_SM1STS_RF = 0x1000
	// No new reload cycle since last STS[RF] clearing
	PWM_SM1STS_RF_RF_0 = 0x0
	// New reload cycle since last STS[RF] clearing
	PWM_SM1STS_RF_RF_1 = 0x1
	// Position of REF field.
	PWM_SM1STS_REF_Pos = 0xd
	// Bit mask of REF field.
	PWM_SM1STS_REF_Msk = 0x2000
	// Bit REF.
	PWM_SM1STS_REF = 0x2000
	// No reload error occurred.
	PWM_SM1STS_REF_REF_0 = 0x0
	// Reload signal occurred with non-coherent data and MCTRL[LDOK] = 0.
	PWM_SM1STS_REF_REF_1 = 0x1
	// Position of RUF field.
	PWM_SM1STS_RUF_Pos = 0xe
	// Bit mask of RUF field.
	PWM_SM1STS_RUF_Msk = 0x4000
	// Bit RUF.
	PWM_SM1STS_RUF = 0x4000
	// No register update has occurred since last reload.
	PWM_SM1STS_RUF_RUF_0 = 0x0
	// At least one of the double buffered registers has been updated since the last reload.
	PWM_SM1STS_RUF_RUF_1 = 0x1

	// SM1INTEN: Interrupt Enable Register
	// Position of CMPIE field.
	PWM_SM1INTEN_CMPIE_Pos = 0x0
	// Bit mask of CMPIE field.
	PWM_SM1INTEN_CMPIE_Msk = 0x3f
	// The corresponding STS[CMPF] bit will not cause an interrupt request.
	PWM_SM1INTEN_CMPIE_CMPIE_0 = 0x0
	// The corresponding STS[CMPF] bit will cause an interrupt request.
	PWM_SM1INTEN_CMPIE_CMPIE_1 = 0x1
	// Position of CX0IE field.
	PWM_SM1INTEN_CX0IE_Pos = 0x6
	// Bit mask of CX0IE field.
	PWM_SM1INTEN_CX0IE_Msk = 0x40
	// Bit CX0IE.
	PWM_SM1INTEN_CX0IE = 0x40
	// Interrupt request disabled for STS[CFX0].
	PWM_SM1INTEN_CX0IE_CX0IE_0 = 0x0
	// Interrupt request enabled for STS[CFX0].
	PWM_SM1INTEN_CX0IE_CX0IE_1 = 0x1
	// Position of CX1IE field.
	PWM_SM1INTEN_CX1IE_Pos = 0x7
	// Bit mask of CX1IE field.
	PWM_SM1INTEN_CX1IE_Msk = 0x80
	// Bit CX1IE.
	PWM_SM1INTEN_CX1IE = 0x80
	// Interrupt request disabled for STS[CFX1].
	PWM_SM1INTEN_CX1IE_CX1IE_0 = 0x0
	// Interrupt request enabled for STS[CFX1].
	PWM_SM1INTEN_CX1IE_CX1IE_1 = 0x1
	// Position of CB0IE field.
	PWM_SM1INTEN_CB0IE_Pos = 0x8
	// Bit mask of CB0IE field.
	PWM_SM1INTEN_CB0IE_Msk = 0x100
	// Bit CB0IE.
	PWM_SM1INTEN_CB0IE = 0x100
	// Interrupt request disabled for STS[CFB0].
	PWM_SM1INTEN_CB0IE_CB0IE_0 = 0x0
	// Interrupt request enabled for STS[CFB0].
	PWM_SM1INTEN_CB0IE_CB0IE_1 = 0x1
	// Position of CB1IE field.
	PWM_SM1INTEN_CB1IE_Pos = 0x9
	// Bit mask of CB1IE field.
	PWM_SM1INTEN_CB1IE_Msk = 0x200
	// Bit CB1IE.
	PWM_SM1INTEN_CB1IE = 0x200
	// Interrupt request disabled for STS[CFB1].
	PWM_SM1INTEN_CB1IE_CB1IE_0 = 0x0
	// Interrupt request enabled for STS[CFB1].
	PWM_SM1INTEN_CB1IE_CB1IE_1 = 0x1
	// Position of CA0IE field.
	PWM_SM1INTEN_CA0IE_Pos = 0xa
	// Bit mask of CA0IE field.
	PWM_SM1INTEN_CA0IE_Msk = 0x400
	// Bit CA0IE.
	PWM_SM1INTEN_CA0IE = 0x400
	// Interrupt request disabled for STS[CFA0].
	PWM_SM1INTEN_CA0IE_CA0IE_0 = 0x0
	// Interrupt request enabled for STS[CFA0].
	PWM_SM1INTEN_CA0IE_CA0IE_1 = 0x1
	// Position of CA1IE field.
	PWM_SM1INTEN_CA1IE_Pos = 0xb
	// Bit mask of CA1IE field.
	PWM_SM1INTEN_CA1IE_Msk = 0x800
	// Bit CA1IE.
	PWM_SM1INTEN_CA1IE = 0x800
	// Interrupt request disabled for STS[CFA1].
	PWM_SM1INTEN_CA1IE_CA1IE_0 = 0x0
	// Interrupt request enabled for STS[CFA1].
	PWM_SM1INTEN_CA1IE_CA1IE_1 = 0x1
	// Position of RIE field.
	PWM_SM1INTEN_RIE_Pos = 0xc
	// Bit mask of RIE field.
	PWM_SM1INTEN_RIE_Msk = 0x1000
	// Bit RIE.
	PWM_SM1INTEN_RIE = 0x1000
	// STS[RF] CPU interrupt requests disabled
	PWM_SM1INTEN_RIE_RIE_0 = 0x0
	// STS[RF] CPU interrupt requests enabled
	PWM_SM1INTEN_RIE_RIE_1 = 0x1
	// Position of REIE field.
	PWM_SM1INTEN_REIE_Pos = 0xd
	// Bit mask of REIE field.
	PWM_SM1INTEN_REIE_Msk = 0x2000
	// Bit REIE.
	PWM_SM1INTEN_REIE = 0x2000
	// STS[REF] CPU interrupt requests disabled
	PWM_SM1INTEN_REIE_REIE_0 = 0x0
	// STS[REF] CPU interrupt requests enabled
	PWM_SM1INTEN_REIE_REIE_1 = 0x1

	// SM1DMAEN: DMA Enable Register
	// Position of CX0DE field.
	PWM_SM1DMAEN_CX0DE_Pos = 0x0
	// Bit mask of CX0DE field.
	PWM_SM1DMAEN_CX0DE_Msk = 0x1
	// Bit CX0DE.
	PWM_SM1DMAEN_CX0DE = 0x1
	// Position of CX1DE field.
	PWM_SM1DMAEN_CX1DE_Pos = 0x1
	// Bit mask of CX1DE field.
	PWM_SM1DMAEN_CX1DE_Msk = 0x2
	// Bit CX1DE.
	PWM_SM1DMAEN_CX1DE = 0x2
	// Position of CB0DE field.
	PWM_SM1DMAEN_CB0DE_Pos = 0x2
	// Bit mask of CB0DE field.
	PWM_SM1DMAEN_CB0DE_Msk = 0x4
	// Bit CB0DE.
	PWM_SM1DMAEN_CB0DE = 0x4
	// Position of CB1DE field.
	PWM_SM1DMAEN_CB1DE_Pos = 0x3
	// Bit mask of CB1DE field.
	PWM_SM1DMAEN_CB1DE_Msk = 0x8
	// Bit CB1DE.
	PWM_SM1DMAEN_CB1DE = 0x8
	// Position of CA0DE field.
	PWM_SM1DMAEN_CA0DE_Pos = 0x4
	// Bit mask of CA0DE field.
	PWM_SM1DMAEN_CA0DE_Msk = 0x10
	// Bit CA0DE.
	PWM_SM1DMAEN_CA0DE = 0x10
	// Position of CA1DE field.
	PWM_SM1DMAEN_CA1DE_Pos = 0x5
	// Bit mask of CA1DE field.
	PWM_SM1DMAEN_CA1DE_Msk = 0x20
	// Bit CA1DE.
	PWM_SM1DMAEN_CA1DE = 0x20
	// Position of CAPTDE field.
	PWM_SM1DMAEN_CAPTDE_Pos = 0x6
	// Bit mask of CAPTDE field.
	PWM_SM1DMAEN_CAPTDE_Msk = 0xc0
	// Read DMA requests disabled.
	PWM_SM1DMAEN_CAPTDE_CAPTDE_0 = 0x0
	// Exceeding a FIFO watermark sets the DMA read request. This requires at least one of DMAEN[CA1DE], DMAEN[CA0DE], DMAEN[CB1DE], DMAEN[CB0DE], DMAEN[CX1DE], or DMAEN[CX0DE] to also be set in order to determine to which watermark(s) the DMA request is sensitive.
	PWM_SM1DMAEN_CAPTDE_CAPTDE_1 = 0x1
	// A local sync (VAL1 matches counter) sets the read DMA request.
	PWM_SM1DMAEN_CAPTDE_CAPTDE_2 = 0x2
	// A local reload (STS[RF] being set) sets the read DMA request.
	PWM_SM1DMAEN_CAPTDE_CAPTDE_3 = 0x3
	// Position of FAND field.
	PWM_SM1DMAEN_FAND_Pos = 0x8
	// Bit mask of FAND field.
	PWM_SM1DMAEN_FAND_Msk = 0x100
	// Bit FAND.
	PWM_SM1DMAEN_FAND = 0x100
	// Selected FIFO watermarks are OR'ed together.
	PWM_SM1DMAEN_FAND_FAND_0 = 0x0
	// Selected FIFO watermarks are AND'ed together.
	PWM_SM1DMAEN_FAND_FAND_1 = 0x1
	// Position of VALDE field.
	PWM_SM1DMAEN_VALDE_Pos = 0x9
	// Bit mask of VALDE field.
	PWM_SM1DMAEN_VALDE_Msk = 0x200
	// Bit VALDE.
	PWM_SM1DMAEN_VALDE = 0x200
	// DMA write requests disabled
	PWM_SM1DMAEN_VALDE_VALDE_0 = 0x0
	// DMA write requests for the VALx and FRACVALx registers enabled
	PWM_SM1DMAEN_VALDE_VALDE_1 = 0x1

	// SM1TCTRL: Output Trigger Control Register
	// Position of OUT_TRIG_EN field.
	PWM_SM1TCTRL_OUT_TRIG_EN_Pos = 0x0
	// Bit mask of OUT_TRIG_EN field.
	PWM_SM1TCTRL_OUT_TRIG_EN_Msk = 0x3f
	// PWM_OUT_TRIGx will not set when the counter value matches the VALx value.
	PWM_SM1TCTRL_OUT_TRIG_EN_OUT_TRIG_EN_0 = 0x0
	// PWM_OUT_TRIGx will set when the counter value matches the VALx value.
	PWM_SM1TCTRL_OUT_TRIG_EN_OUT_TRIG_EN_1 = 0x1
	// Position of TRGFRQ field.
	PWM_SM1TCTRL_TRGFRQ_Pos = 0xc
	// Bit mask of TRGFRQ field.
	PWM_SM1TCTRL_TRGFRQ_Msk = 0x1000
	// Bit TRGFRQ.
	PWM_SM1TCTRL_TRGFRQ = 0x1000
	// Trigger outputs are generated during every PWM period even if the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
	PWM_SM1TCTRL_TRGFRQ_TRGFRQ_0 = 0x0
	// Trigger outputs are generated only during the final PWM period prior to a reload opportunity when the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
	PWM_SM1TCTRL_TRGFRQ_TRGFRQ_1 = 0x1
	// Position of PWBOT1 field.
	PWM_SM1TCTRL_PWBOT1_Pos = 0xe
	// Bit mask of PWBOT1 field.
	PWM_SM1TCTRL_PWBOT1_Msk = 0x4000
	// Bit PWBOT1.
	PWM_SM1TCTRL_PWBOT1 = 0x4000
	// Route the PWM_OUT_TRIG1 signal to PWM_OUT_TRIG1 port.
	PWM_SM1TCTRL_PWBOT1_PWBOT1_0 = 0x0
	// Route the PWMB output to the PWM_OUT_TRIG1 port.
	PWM_SM1TCTRL_PWBOT1_PWBOT1_1 = 0x1
	// Position of PWAOT0 field.
	PWM_SM1TCTRL_PWAOT0_Pos = 0xf
	// Bit mask of PWAOT0 field.
	PWM_SM1TCTRL_PWAOT0_Msk = 0x8000
	// Bit PWAOT0.
	PWM_SM1TCTRL_PWAOT0 = 0x8000
	// Route the PWM_OUT_TRIG0 signal to PWM_OUT_TRIG0 port.
	PWM_SM1TCTRL_PWAOT0_PWAOT0_0 = 0x0
	// Route the PWMA output to the PWM_OUT_TRIG0 port.
	PWM_SM1TCTRL_PWAOT0_PWAOT0_1 = 0x1

	// SM1DISMAP0: Fault Disable Mapping Register 0
	// Position of DIS0A field.
	PWM_SM1DISMAP0_DIS0A_Pos = 0x0
	// Bit mask of DIS0A field.
	PWM_SM1DISMAP0_DIS0A_Msk = 0xf
	// Position of DIS0B field.
	PWM_SM1DISMAP0_DIS0B_Pos = 0x4
	// Bit mask of DIS0B field.
	PWM_SM1DISMAP0_DIS0B_Msk = 0xf0
	// Position of DIS0X field.
	PWM_SM1DISMAP0_DIS0X_Pos = 0x8
	// Bit mask of DIS0X field.
	PWM_SM1DISMAP0_DIS0X_Msk = 0xf00

	// SM1DISMAP1: Fault Disable Mapping Register 1
	// Position of DIS1A field.
	PWM_SM1DISMAP1_DIS1A_Pos = 0x0
	// Bit mask of DIS1A field.
	PWM_SM1DISMAP1_DIS1A_Msk = 0xf
	// Position of DIS1B field.
	PWM_SM1DISMAP1_DIS1B_Pos = 0x4
	// Bit mask of DIS1B field.
	PWM_SM1DISMAP1_DIS1B_Msk = 0xf0
	// Position of DIS1X field.
	PWM_SM1DISMAP1_DIS1X_Pos = 0x8
	// Bit mask of DIS1X field.
	PWM_SM1DISMAP1_DIS1X_Msk = 0xf00

	// SM1DTCNT0: Deadtime Count Register 0
	// Position of DTCNT0 field.
	PWM_SM1DTCNT0_DTCNT0_Pos = 0x0
	// Bit mask of DTCNT0 field.
	PWM_SM1DTCNT0_DTCNT0_Msk = 0xffff

	// SM1DTCNT1: Deadtime Count Register 1
	// Position of DTCNT1 field.
	PWM_SM1DTCNT1_DTCNT1_Pos = 0x0
	// Bit mask of DTCNT1 field.
	PWM_SM1DTCNT1_DTCNT1_Msk = 0xffff

	// SM1CAPTCTRLA: Capture Control A Register
	// Position of ARMA field.
	PWM_SM1CAPTCTRLA_ARMA_Pos = 0x0
	// Bit mask of ARMA field.
	PWM_SM1CAPTCTRLA_ARMA_Msk = 0x1
	// Bit ARMA.
	PWM_SM1CAPTCTRLA_ARMA = 0x1
	// Input capture operation is disabled.
	PWM_SM1CAPTCTRLA_ARMA_ARMA_0 = 0x0
	// Input capture operation as specified by CAPTCTRLA[EDGAx] is enabled.
	PWM_SM1CAPTCTRLA_ARMA_ARMA_1 = 0x1
	// Position of ONESHOTA field.
	PWM_SM1CAPTCTRLA_ONESHOTA_Pos = 0x1
	// Bit mask of ONESHOTA field.
	PWM_SM1CAPTCTRLA_ONESHOTA_Msk = 0x2
	// Bit ONESHOTA.
	PWM_SM1CAPTCTRLA_ONESHOTA = 0x2
	// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	PWM_SM1CAPTCTRLA_ONESHOTA_ONESHOTA_0 = 0x0
	// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLA[ARMA] is cleared. No further captures will be performed until CAPTCTRLA[ARMA] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLA[ARMA] is then cleared.
	PWM_SM1CAPTCTRLA_ONESHOTA_ONESHOTA_1 = 0x1
	// Position of EDGA0 field.
	PWM_SM1CAPTCTRLA_EDGA0_Pos = 0x2
	// Bit mask of EDGA0 field.
	PWM_SM1CAPTCTRLA_EDGA0_Msk = 0xc
	// Disabled
	PWM_SM1CAPTCTRLA_EDGA0_EDGA0_0 = 0x0
	// Capture falling edges
	PWM_SM1CAPTCTRLA_EDGA0_EDGA0_1 = 0x1
	// Capture rising edges
	PWM_SM1CAPTCTRLA_EDGA0_EDGA0_2 = 0x2
	// Capture any edge
	PWM_SM1CAPTCTRLA_EDGA0_EDGA0_3 = 0x3
	// Position of EDGA1 field.
	PWM_SM1CAPTCTRLA_EDGA1_Pos = 0x4
	// Bit mask of EDGA1 field.
	PWM_SM1CAPTCTRLA_EDGA1_Msk = 0x30
	// Disabled
	PWM_SM1CAPTCTRLA_EDGA1_EDGA1_0 = 0x0
	// Capture falling edges
	PWM_SM1CAPTCTRLA_EDGA1_EDGA1_1 = 0x1
	// Capture rising edges
	PWM_SM1CAPTCTRLA_EDGA1_EDGA1_2 = 0x2
	// Capture any edge
	PWM_SM1CAPTCTRLA_EDGA1_EDGA1_3 = 0x3
	// Position of INP_SELA field.
	PWM_SM1CAPTCTRLA_INP_SELA_Pos = 0x6
	// Bit mask of INP_SELA field.
	PWM_SM1CAPTCTRLA_INP_SELA_Msk = 0x40
	// Bit INP_SELA.
	PWM_SM1CAPTCTRLA_INP_SELA = 0x40
	// Raw PWM_A input signal selected as source.
	PWM_SM1CAPTCTRLA_INP_SELA_INP_SELA_0 = 0x0
	// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLA[EDGA0] and CAPTCTRLA[EDGA1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRA[EDGA0] and/or CAPTCTRLA[EDGA1] fields in order to enable one or both of the capture registers.
	PWM_SM1CAPTCTRLA_INP_SELA_INP_SELA_1 = 0x1
	// Position of EDGCNTA_EN field.
	PWM_SM1CAPTCTRLA_EDGCNTA_EN_Pos = 0x7
	// Bit mask of EDGCNTA_EN field.
	PWM_SM1CAPTCTRLA_EDGCNTA_EN_Msk = 0x80
	// Bit EDGCNTA_EN.
	PWM_SM1CAPTCTRLA_EDGCNTA_EN = 0x80
	// Edge counter disabled and held in reset
	PWM_SM1CAPTCTRLA_EDGCNTA_EN_EDGCNTA_EN_0 = 0x0
	// Edge counter enabled
	PWM_SM1CAPTCTRLA_EDGCNTA_EN_EDGCNTA_EN_1 = 0x1
	// Position of CFAWM field.
	PWM_SM1CAPTCTRLA_CFAWM_Pos = 0x8
	// Bit mask of CFAWM field.
	PWM_SM1CAPTCTRLA_CFAWM_Msk = 0x300
	// Position of CA0CNT field.
	PWM_SM1CAPTCTRLA_CA0CNT_Pos = 0xa
	// Bit mask of CA0CNT field.
	PWM_SM1CAPTCTRLA_CA0CNT_Msk = 0x1c00
	// Position of CA1CNT field.
	PWM_SM1CAPTCTRLA_CA1CNT_Pos = 0xd
	// Bit mask of CA1CNT field.
	PWM_SM1CAPTCTRLA_CA1CNT_Msk = 0xe000

	// SM1CAPTCOMPA: Capture Compare A Register
	// Position of EDGCMPA field.
	PWM_SM1CAPTCOMPA_EDGCMPA_Pos = 0x0
	// Bit mask of EDGCMPA field.
	PWM_SM1CAPTCOMPA_EDGCMPA_Msk = 0xff
	// Position of EDGCNTA field.
	PWM_SM1CAPTCOMPA_EDGCNTA_Pos = 0x8
	// Bit mask of EDGCNTA field.
	PWM_SM1CAPTCOMPA_EDGCNTA_Msk = 0xff00

	// SM1CAPTCTRLB: Capture Control B Register
	// Position of ARMB field.
	PWM_SM1CAPTCTRLB_ARMB_Pos = 0x0
	// Bit mask of ARMB field.
	PWM_SM1CAPTCTRLB_ARMB_Msk = 0x1
	// Bit ARMB.
	PWM_SM1CAPTCTRLB_ARMB = 0x1
	// Input capture operation is disabled.
	PWM_SM1CAPTCTRLB_ARMB_ARMB_0 = 0x0
	// Input capture operation as specified by CAPTCTRLB[EDGBx] is enabled.
	PWM_SM1CAPTCTRLB_ARMB_ARMB_1 = 0x1
	// Position of ONESHOTB field.
	PWM_SM1CAPTCTRLB_ONESHOTB_Pos = 0x1
	// Bit mask of ONESHOTB field.
	PWM_SM1CAPTCTRLB_ONESHOTB_Msk = 0x2
	// Bit ONESHOTB.
	PWM_SM1CAPTCTRLB_ONESHOTB = 0x2
	// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	PWM_SM1CAPTCTRLB_ONESHOTB_ONESHOTB_0 = 0x0
	// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLB[ARMB] is cleared. No further captures will be performed until CAPTCTRLB[ARMB] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLB[ARMB] is then cleared.
	PWM_SM1CAPTCTRLB_ONESHOTB_ONESHOTB_1 = 0x1
	// Position of EDGB0 field.
	PWM_SM1CAPTCTRLB_EDGB0_Pos = 0x2
	// Bit mask of EDGB0 field.
	PWM_SM1CAPTCTRLB_EDGB0_Msk = 0xc
	// Disabled
	PWM_SM1CAPTCTRLB_EDGB0_EDGB0_0 = 0x0
	// Capture falling edges
	PWM_SM1CAPTCTRLB_EDGB0_EDGB0_1 = 0x1
	// Capture rising edges
	PWM_SM1CAPTCTRLB_EDGB0_EDGB0_2 = 0x2
	// Capture any edge
	PWM_SM1CAPTCTRLB_EDGB0_EDGB0_3 = 0x3
	// Position of EDGB1 field.
	PWM_SM1CAPTCTRLB_EDGB1_Pos = 0x4
	// Bit mask of EDGB1 field.
	PWM_SM1CAPTCTRLB_EDGB1_Msk = 0x30
	// Disabled
	PWM_SM1CAPTCTRLB_EDGB1_EDGB1_0 = 0x0
	// Capture falling edges
	PWM_SM1CAPTCTRLB_EDGB1_EDGB1_1 = 0x1
	// Capture rising edges
	PWM_SM1CAPTCTRLB_EDGB1_EDGB1_2 = 0x2
	// Capture any edge
	PWM_SM1CAPTCTRLB_EDGB1_EDGB1_3 = 0x3
	// Position of INP_SELB field.
	PWM_SM1CAPTCTRLB_INP_SELB_Pos = 0x6
	// Bit mask of INP_SELB field.
	PWM_SM1CAPTCTRLB_INP_SELB_Msk = 0x40
	// Bit INP_SELB.
	PWM_SM1CAPTCTRLB_INP_SELB = 0x40
	// Raw PWM_B input signal selected as source.
	PWM_SM1CAPTCTRLB_INP_SELB_INP_SELB_0 = 0x0
	// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLB[EDGB0] and CAPTCTRLB[EDGB1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRB[EDGB0] and/or CAPTCTRLB[EDGB1] fields in order to enable one or both of the capture registers.
	PWM_SM1CAPTCTRLB_INP_SELB_INP_SELB_1 = 0x1
	// Position of EDGCNTB_EN field.
	PWM_SM1CAPTCTRLB_EDGCNTB_EN_Pos = 0x7
	// Bit mask of EDGCNTB_EN field.
	PWM_SM1CAPTCTRLB_EDGCNTB_EN_Msk = 0x80
	// Bit EDGCNTB_EN.
	PWM_SM1CAPTCTRLB_EDGCNTB_EN = 0x80
	// Edge counter disabled and held in reset
	PWM_SM1CAPTCTRLB_EDGCNTB_EN_EDGCNTB_EN_0 = 0x0
	// Edge counter enabled
	PWM_SM1CAPTCTRLB_EDGCNTB_EN_EDGCNTB_EN_1 = 0x1
	// Position of CFBWM field.
	PWM_SM1CAPTCTRLB_CFBWM_Pos = 0x8
	// Bit mask of CFBWM field.
	PWM_SM1CAPTCTRLB_CFBWM_Msk = 0x300
	// Position of CB0CNT field.
	PWM_SM1CAPTCTRLB_CB0CNT_Pos = 0xa
	// Bit mask of CB0CNT field.
	PWM_SM1CAPTCTRLB_CB0CNT_Msk = 0x1c00
	// Position of CB1CNT field.
	PWM_SM1CAPTCTRLB_CB1CNT_Pos = 0xd
	// Bit mask of CB1CNT field.
	PWM_SM1CAPTCTRLB_CB1CNT_Msk = 0xe000

	// SM1CAPTCOMPB: Capture Compare B Register
	// Position of EDGCMPB field.
	PWM_SM1CAPTCOMPB_EDGCMPB_Pos = 0x0
	// Bit mask of EDGCMPB field.
	PWM_SM1CAPTCOMPB_EDGCMPB_Msk = 0xff
	// Position of EDGCNTB field.
	PWM_SM1CAPTCOMPB_EDGCNTB_Pos = 0x8
	// Bit mask of EDGCNTB field.
	PWM_SM1CAPTCOMPB_EDGCNTB_Msk = 0xff00

	// SM1CAPTCTRLX: Capture Control X Register
	// Position of ARMX field.
	PWM_SM1CAPTCTRLX_ARMX_Pos = 0x0
	// Bit mask of ARMX field.
	PWM_SM1CAPTCTRLX_ARMX_Msk = 0x1
	// Bit ARMX.
	PWM_SM1CAPTCTRLX_ARMX = 0x1
	// Input capture operation is disabled.
	PWM_SM1CAPTCTRLX_ARMX_ARMX_0 = 0x0
	// Input capture operation as specified by CAPTCTRLX[EDGXx] is enabled.
	PWM_SM1CAPTCTRLX_ARMX_ARMX_1 = 0x1
	// Position of ONESHOTX field.
	PWM_SM1CAPTCTRLX_ONESHOTX_Pos = 0x1
	// Bit mask of ONESHOTX field.
	PWM_SM1CAPTCTRLX_ONESHOTX_Msk = 0x2
	// Bit ONESHOTX.
	PWM_SM1CAPTCTRLX_ONESHOTX = 0x2
	// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	PWM_SM1CAPTCTRLX_ONESHOTX_ONESHOTX_0 = 0x0
	// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and the ARMX bit is cleared. No further captures will be performed until the ARMX bit is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and the ARMX bit is then cleared.
	PWM_SM1CAPTCTRLX_ONESHOTX_ONESHOTX_1 = 0x1
	// Position of EDGX0 field.
	PWM_SM1CAPTCTRLX_EDGX0_Pos = 0x2
	// Bit mask of EDGX0 field.
	PWM_SM1CAPTCTRLX_EDGX0_Msk = 0xc
	// Disabled
	PWM_SM1CAPTCTRLX_EDGX0_EDGX0_0 = 0x0
	// Capture falling edges
	PWM_SM1CAPTCTRLX_EDGX0_EDGX0_1 = 0x1
	// Capture rising edges
	PWM_SM1CAPTCTRLX_EDGX0_EDGX0_2 = 0x2
	// Capture any edge
	PWM_SM1CAPTCTRLX_EDGX0_EDGX0_3 = 0x3
	// Position of EDGX1 field.
	PWM_SM1CAPTCTRLX_EDGX1_Pos = 0x4
	// Bit mask of EDGX1 field.
	PWM_SM1CAPTCTRLX_EDGX1_Msk = 0x30
	// Disabled
	PWM_SM1CAPTCTRLX_EDGX1_EDGX1_0 = 0x0
	// Capture falling edges
	PWM_SM1CAPTCTRLX_EDGX1_EDGX1_1 = 0x1
	// Capture rising edges
	PWM_SM1CAPTCTRLX_EDGX1_EDGX1_2 = 0x2
	// Capture any edge
	PWM_SM1CAPTCTRLX_EDGX1_EDGX1_3 = 0x3
	// Position of INP_SELX field.
	PWM_SM1CAPTCTRLX_INP_SELX_Pos = 0x6
	// Bit mask of INP_SELX field.
	PWM_SM1CAPTCTRLX_INP_SELX_Msk = 0x40
	// Bit INP_SELX.
	PWM_SM1CAPTCTRLX_INP_SELX = 0x40
	// Raw PWM_X input signal selected as source.
	PWM_SM1CAPTCTRLX_INP_SELX_INP_SELX_0 = 0x0
	// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLX[EDGX0] and CAPTCTRLX[EDGX1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRX[EDGX0] and/or CAPTCTRLX[EDGX1] fields in order to enable one or both of the capture registers.
	PWM_SM1CAPTCTRLX_INP_SELX_INP_SELX_1 = 0x1
	// Position of EDGCNTX_EN field.
	PWM_SM1CAPTCTRLX_EDGCNTX_EN_Pos = 0x7
	// Bit mask of EDGCNTX_EN field.
	PWM_SM1CAPTCTRLX_EDGCNTX_EN_Msk = 0x80
	// Bit EDGCNTX_EN.
	PWM_SM1CAPTCTRLX_EDGCNTX_EN = 0x80
	// Edge counter disabled and held in reset
	PWM_SM1CAPTCTRLX_EDGCNTX_EN_EDGCNTX_EN_0 = 0x0
	// Edge counter enabled
	PWM_SM1CAPTCTRLX_EDGCNTX_EN_EDGCNTX_EN_1 = 0x1
	// Position of CFXWM field.
	PWM_SM1CAPTCTRLX_CFXWM_Pos = 0x8
	// Bit mask of CFXWM field.
	PWM_SM1CAPTCTRLX_CFXWM_Msk = 0x300
	// Position of CX0CNT field.
	PWM_SM1CAPTCTRLX_CX0CNT_Pos = 0xa
	// Bit mask of CX0CNT field.
	PWM_SM1CAPTCTRLX_CX0CNT_Msk = 0x1c00
	// Position of CX1CNT field.
	PWM_SM1CAPTCTRLX_CX1CNT_Pos = 0xd
	// Bit mask of CX1CNT field.
	PWM_SM1CAPTCTRLX_CX1CNT_Msk = 0xe000

	// SM1CAPTCOMPX: Capture Compare X Register
	// Position of EDGCMPX field.
	PWM_SM1CAPTCOMPX_EDGCMPX_Pos = 0x0
	// Bit mask of EDGCMPX field.
	PWM_SM1CAPTCOMPX_EDGCMPX_Msk = 0xff
	// Position of EDGCNTX field.
	PWM_SM1CAPTCOMPX_EDGCNTX_Pos = 0x8
	// Bit mask of EDGCNTX field.
	PWM_SM1CAPTCOMPX_EDGCNTX_Msk = 0xff00

	// SM1CVAL0: Capture Value 0 Register
	// Position of CAPTVAL0 field.
	PWM_SM1CVAL0_CAPTVAL0_Pos = 0x0
	// Bit mask of CAPTVAL0 field.
	PWM_SM1CVAL0_CAPTVAL0_Msk = 0xffff

	// SM1CVAL0CYC: Capture Value 0 Cycle Register
	// Position of CVAL0CYC field.
	PWM_SM1CVAL0CYC_CVAL0CYC_Pos = 0x0
	// Bit mask of CVAL0CYC field.
	PWM_SM1CVAL0CYC_CVAL0CYC_Msk = 0xf

	// SM1CVAL1: Capture Value 1 Register
	// Position of CAPTVAL1 field.
	PWM_SM1CVAL1_CAPTVAL1_Pos = 0x0
	// Bit mask of CAPTVAL1 field.
	PWM_SM1CVAL1_CAPTVAL1_Msk = 0xffff

	// SM1CVAL1CYC: Capture Value 1 Cycle Register
	// Position of CVAL1CYC field.
	PWM_SM1CVAL1CYC_CVAL1CYC_Pos = 0x0
	// Bit mask of CVAL1CYC field.
	PWM_SM1CVAL1CYC_CVAL1CYC_Msk = 0xf

	// SM1CVAL2: Capture Value 2 Register
	// Position of CAPTVAL2 field.
	PWM_SM1CVAL2_CAPTVAL2_Pos = 0x0
	// Bit mask of CAPTVAL2 field.
	PWM_SM1CVAL2_CAPTVAL2_Msk = 0xffff

	// SM1CVAL2CYC: Capture Value 2 Cycle Register
	// Position of CVAL2CYC field.
	PWM_SM1CVAL2CYC_CVAL2CYC_Pos = 0x0
	// Bit mask of CVAL2CYC field.
	PWM_SM1CVAL2CYC_CVAL2CYC_Msk = 0xf

	// SM1CVAL3: Capture Value 3 Register
	// Position of CAPTVAL3 field.
	PWM_SM1CVAL3_CAPTVAL3_Pos = 0x0
	// Bit mask of CAPTVAL3 field.
	PWM_SM1CVAL3_CAPTVAL3_Msk = 0xffff

	// SM1CVAL3CYC: Capture Value 3 Cycle Register
	// Position of CVAL3CYC field.
	PWM_SM1CVAL3CYC_CVAL3CYC_Pos = 0x0
	// Bit mask of CVAL3CYC field.
	PWM_SM1CVAL3CYC_CVAL3CYC_Msk = 0xf

	// SM1CVAL4: Capture Value 4 Register
	// Position of CAPTVAL4 field.
	PWM_SM1CVAL4_CAPTVAL4_Pos = 0x0
	// Bit mask of CAPTVAL4 field.
	PWM_SM1CVAL4_CAPTVAL4_Msk = 0xffff

	// SM1CVAL4CYC: Capture Value 4 Cycle Register
	// Position of CVAL4CYC field.
	PWM_SM1CVAL4CYC_CVAL4CYC_Pos = 0x0
	// Bit mask of CVAL4CYC field.
	PWM_SM1CVAL4CYC_CVAL4CYC_Msk = 0xf

	// SM1CVAL5: Capture Value 5 Register
	// Position of CAPTVAL5 field.
	PWM_SM1CVAL5_CAPTVAL5_Pos = 0x0
	// Bit mask of CAPTVAL5 field.
	PWM_SM1CVAL5_CAPTVAL5_Msk = 0xffff

	// SM1CVAL5CYC: Capture Value 5 Cycle Register
	// Position of CVAL5CYC field.
	PWM_SM1CVAL5CYC_CVAL5CYC_Pos = 0x0
	// Bit mask of CVAL5CYC field.
	PWM_SM1CVAL5CYC_CVAL5CYC_Msk = 0xf

	// SM1PHASEDLY: Phase Delay Register
	// Position of PHASEDLY field.
	PWM_SM1PHASEDLY_PHASEDLY_Pos = 0x0
	// Bit mask of PHASEDLY field.
	PWM_SM1PHASEDLY_PHASEDLY_Msk = 0xffff

	// SM2CNT: Counter Register
	// Position of CNT field.
	PWM_SM2CNT_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PWM_SM2CNT_CNT_Msk = 0xffff

	// SM2INIT: Initial Count Register
	// Position of INIT field.
	PWM_SM2INIT_INIT_Pos = 0x0
	// Bit mask of INIT field.
	PWM_SM2INIT_INIT_Msk = 0xffff

	// SM2CTRL2: Control 2 Register
	// Position of CLK_SEL field.
	PWM_SM2CTRL2_CLK_SEL_Pos = 0x0
	// Bit mask of CLK_SEL field.
	PWM_SM2CTRL2_CLK_SEL_Msk = 0x3
	// The IPBus clock is used as the clock for the local prescaler and counter.
	PWM_SM2CTRL2_CLK_SEL_CLK_SEL_0 = 0x0
	// EXT_CLK is used as the clock for the local prescaler and counter.
	PWM_SM2CTRL2_CLK_SEL_CLK_SEL_1 = 0x1
	// Submodule 0's clock (AUX_CLK) is used as the source clock for the local prescaler and counter. This setting should not be used in submodule 0 as it will force the clock to logic 0.
	PWM_SM2CTRL2_CLK_SEL_CLK_SEL_2 = 0x2
	// Position of RELOAD_SEL field.
	PWM_SM2CTRL2_RELOAD_SEL_Pos = 0x2
	// Bit mask of RELOAD_SEL field.
	PWM_SM2CTRL2_RELOAD_SEL_Msk = 0x4
	// Bit RELOAD_SEL.
	PWM_SM2CTRL2_RELOAD_SEL = 0x4
	// The local RELOAD signal is used to reload registers.
	PWM_SM2CTRL2_RELOAD_SEL_RELOAD_SEL_0 = 0x0
	// The master RELOAD signal (from submodule 0) is used to reload registers. This setting should not be used in submodule 0 as it will force the RELOAD signal to logic 0.
	PWM_SM2CTRL2_RELOAD_SEL_RELOAD_SEL_1 = 0x1
	// Position of FORCE_SEL field.
	PWM_SM2CTRL2_FORCE_SEL_Pos = 0x3
	// Bit mask of FORCE_SEL field.
	PWM_SM2CTRL2_FORCE_SEL_Msk = 0x38
	// The local force signal, CTRL2[FORCE], from this submodule is used to force updates.
	PWM_SM2CTRL2_FORCE_SEL_FORCE_SEL_0 = 0x0
	// The master force signal from submodule 0 is used to force updates. This setting should not be used in submodule 0 as it will hold the FORCE OUTPUT signal to logic 0.
	PWM_SM2CTRL2_FORCE_SEL_FORCE_SEL_1 = 0x1
	// The local reload signal from this submodule is used to force updates without regard to the state of LDOK.
	PWM_SM2CTRL2_FORCE_SEL_FORCE_SEL_2 = 0x2
	// The master reload signal from submodule0 is used to force updates if LDOK is set. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	PWM_SM2CTRL2_FORCE_SEL_FORCE_SEL_3 = 0x3
	// The local sync signal from this submodule is used to force updates.
	PWM_SM2CTRL2_FORCE_SEL_FORCE_SEL_4 = 0x4
	// The master sync signal from submodule0 is used to force updates. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	PWM_SM2CTRL2_FORCE_SEL_FORCE_SEL_5 = 0x5
	// The external force signal, EXT_FORCE, from outside the PWM module causes updates.
	PWM_SM2CTRL2_FORCE_SEL_FORCE_SEL_6 = 0x6
	// The external sync signal, EXT_SYNC, from outside the PWM module causes updates.
	PWM_SM2CTRL2_FORCE_SEL_FORCE_SEL_7 = 0x7
	// Position of FORCE field.
	PWM_SM2CTRL2_FORCE_Pos = 0x6
	// Bit mask of FORCE field.
	PWM_SM2CTRL2_FORCE_Msk = 0x40
	// Bit FORCE.
	PWM_SM2CTRL2_FORCE = 0x40
	// Position of FRCEN field.
	PWM_SM2CTRL2_FRCEN_Pos = 0x7
	// Bit mask of FRCEN field.
	PWM_SM2CTRL2_FRCEN_Msk = 0x80
	// Bit FRCEN.
	PWM_SM2CTRL2_FRCEN = 0x80
	// Initialization from a FORCE_OUT is disabled.
	PWM_SM2CTRL2_FRCEN_FRCEN_0 = 0x0
	// Initialization from a FORCE_OUT is enabled.
	PWM_SM2CTRL2_FRCEN_FRCEN_1 = 0x1
	// Position of INIT_SEL field.
	PWM_SM2CTRL2_INIT_SEL_Pos = 0x8
	// Bit mask of INIT_SEL field.
	PWM_SM2CTRL2_INIT_SEL_Msk = 0x300
	// Local sync (PWM_X) causes initialization.
	PWM_SM2CTRL2_INIT_SEL_INIT_SEL_0 = 0x0
	// Master reload from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0. The submodule counter will only reinitialize when a master reload occurs.
	PWM_SM2CTRL2_INIT_SEL_INIT_SEL_1 = 0x1
	// Master sync from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0.
	PWM_SM2CTRL2_INIT_SEL_INIT_SEL_2 = 0x2
	// EXT_SYNC causes initialization.
	PWM_SM2CTRL2_INIT_SEL_INIT_SEL_3 = 0x3
	// Position of PWMX_INIT field.
	PWM_SM2CTRL2_PWMX_INIT_Pos = 0xa
	// Bit mask of PWMX_INIT field.
	PWM_SM2CTRL2_PWMX_INIT_Msk = 0x400
	// Bit PWMX_INIT.
	PWM_SM2CTRL2_PWMX_INIT = 0x400
	// Position of PWM45_INIT field.
	PWM_SM2CTRL2_PWM45_INIT_Pos = 0xb
	// Bit mask of PWM45_INIT field.
	PWM_SM2CTRL2_PWM45_INIT_Msk = 0x800
	// Bit PWM45_INIT.
	PWM_SM2CTRL2_PWM45_INIT = 0x800
	// Position of PWM23_INIT field.
	PWM_SM2CTRL2_PWM23_INIT_Pos = 0xc
	// Bit mask of PWM23_INIT field.
	PWM_SM2CTRL2_PWM23_INIT_Msk = 0x1000
	// Bit PWM23_INIT.
	PWM_SM2CTRL2_PWM23_INIT = 0x1000
	// Position of INDEP field.
	PWM_SM2CTRL2_INDEP_Pos = 0xd
	// Bit mask of INDEP field.
	PWM_SM2CTRL2_INDEP_Msk = 0x2000
	// Bit INDEP.
	PWM_SM2CTRL2_INDEP = 0x2000
	// PWM_A and PWM_B form a complementary PWM pair.
	PWM_SM2CTRL2_INDEP_INDEP_0 = 0x0
	// PWM_A and PWM_B outputs are independent PWMs.
	PWM_SM2CTRL2_INDEP_INDEP_1 = 0x1
	// Position of WAITEN field.
	PWM_SM2CTRL2_WAITEN_Pos = 0xe
	// Bit mask of WAITEN field.
	PWM_SM2CTRL2_WAITEN_Msk = 0x4000
	// Bit WAITEN.
	PWM_SM2CTRL2_WAITEN = 0x4000
	// Position of DBGEN field.
	PWM_SM2CTRL2_DBGEN_Pos = 0xf
	// Bit mask of DBGEN field.
	PWM_SM2CTRL2_DBGEN_Msk = 0x8000
	// Bit DBGEN.
	PWM_SM2CTRL2_DBGEN = 0x8000

	// SM2CTRL: Control Register
	// Position of DBLEN field.
	PWM_SM2CTRL_DBLEN_Pos = 0x0
	// Bit mask of DBLEN field.
	PWM_SM2CTRL_DBLEN_Msk = 0x1
	// Bit DBLEN.
	PWM_SM2CTRL_DBLEN = 0x1
	// Double switching disabled.
	PWM_SM2CTRL_DBLEN_DBLEN_0 = 0x0
	// Double switching enabled.
	PWM_SM2CTRL_DBLEN_DBLEN_1 = 0x1
	// Position of DBLX field.
	PWM_SM2CTRL_DBLX_Pos = 0x1
	// Bit mask of DBLX field.
	PWM_SM2CTRL_DBLX_Msk = 0x2
	// Bit DBLX.
	PWM_SM2CTRL_DBLX = 0x2
	// PWMX double pulse disabled.
	PWM_SM2CTRL_DBLX_DBLX_0 = 0x0
	// PWMX double pulse enabled.
	PWM_SM2CTRL_DBLX_DBLX_1 = 0x1
	// Position of LDMOD field.
	PWM_SM2CTRL_LDMOD_Pos = 0x2
	// Bit mask of LDMOD field.
	PWM_SM2CTRL_LDMOD_Msk = 0x4
	// Bit LDMOD.
	PWM_SM2CTRL_LDMOD = 0x4
	// Buffered registers of this submodule are loaded and take effect at the next PWM reload if MCTRL[LDOK] is set.
	PWM_SM2CTRL_LDMOD_LDMOD_0 = 0x0
	// Buffered registers of this submodule are loaded and take effect immediately upon MCTRL[LDOK] being set. In this case it is not necessary to set CTRL[FULL] or CTRL[HALF].
	PWM_SM2CTRL_LDMOD_LDMOD_1 = 0x1
	// Position of SPLIT field.
	PWM_SM2CTRL_SPLIT_Pos = 0x3
	// Bit mask of SPLIT field.
	PWM_SM2CTRL_SPLIT_Msk = 0x8
	// Bit SPLIT.
	PWM_SM2CTRL_SPLIT = 0x8
	// DBLPWM is not split. PWMA and PWMB each have double pulses.
	PWM_SM2CTRL_SPLIT_SPLIT_0 = 0x0
	// DBLPWM is split to PWMA and PWMB.
	PWM_SM2CTRL_SPLIT_SPLIT_1 = 0x1
	// Position of PRSC field.
	PWM_SM2CTRL_PRSC_Pos = 0x4
	// Bit mask of PRSC field.
	PWM_SM2CTRL_PRSC_Msk = 0x70
	// PWM clock frequency = fclk
	PWM_SM2CTRL_PRSC_PRSC_0 = 0x0
	// PWM clock frequency = fclk/2
	PWM_SM2CTRL_PRSC_PRSC_1 = 0x1
	// PWM clock frequency = fclk/4
	PWM_SM2CTRL_PRSC_PRSC_2 = 0x2
	// PWM clock frequency = fclk/8
	PWM_SM2CTRL_PRSC_PRSC_3 = 0x3
	// PWM clock frequency = fclk/16
	PWM_SM2CTRL_PRSC_PRSC_4 = 0x4
	// PWM clock frequency = fclk/32
	PWM_SM2CTRL_PRSC_PRSC_5 = 0x5
	// PWM clock frequency = fclk/64
	PWM_SM2CTRL_PRSC_PRSC_6 = 0x6
	// PWM clock frequency = fclk/128
	PWM_SM2CTRL_PRSC_PRSC_7 = 0x7
	// Position of COMPMODE field.
	PWM_SM2CTRL_COMPMODE_Pos = 0x7
	// Bit mask of COMPMODE field.
	PWM_SM2CTRL_COMPMODE_Msk = 0x80
	// Bit COMPMODE.
	PWM_SM2CTRL_COMPMODE = 0x80
	// The VAL* registers and the PWM counter are compared using an "equal to" method. This means that PWM edges are only produced when the counter is equal to one of the VAL* register values. This implies that a PWMA output that is high at the end of a period will maintain this state until a match with VAL3 clears the output in the following period.
	PWM_SM2CTRL_COMPMODE_COMPMODE_0 = 0x0
	// The VAL* registers and the PWM counter are compared using an "equal to or greater than" method. This means that PWM edges are produced when the counter is equal to or greater than one of the VAL* register values. This implies that a PWMA output that is high at the end of a period could go low at the start of the next period if the starting counter value is greater than (but not necessarily equal to) the new VAL3 value.
	PWM_SM2CTRL_COMPMODE_COMPMODE_1 = 0x1
	// Position of DT field.
	PWM_SM2CTRL_DT_Pos = 0x8
	// Bit mask of DT field.
	PWM_SM2CTRL_DT_Msk = 0x300
	// Position of FULL field.
	PWM_SM2CTRL_FULL_Pos = 0xa
	// Bit mask of FULL field.
	PWM_SM2CTRL_FULL_Msk = 0x400
	// Bit FULL.
	PWM_SM2CTRL_FULL = 0x400
	// Full-cycle reloads disabled.
	PWM_SM2CTRL_FULL_FULL_0 = 0x0
	// Full-cycle reloads enabled.
	PWM_SM2CTRL_FULL_FULL_1 = 0x1
	// Position of HALF field.
	PWM_SM2CTRL_HALF_Pos = 0xb
	// Bit mask of HALF field.
	PWM_SM2CTRL_HALF_Msk = 0x800
	// Bit HALF.
	PWM_SM2CTRL_HALF = 0x800
	// Half-cycle reloads disabled.
	PWM_SM2CTRL_HALF_HALF_0 = 0x0
	// Half-cycle reloads enabled.
	PWM_SM2CTRL_HALF_HALF_1 = 0x1
	// Position of LDFQ field.
	PWM_SM2CTRL_LDFQ_Pos = 0xc
	// Bit mask of LDFQ field.
	PWM_SM2CTRL_LDFQ_Msk = 0xf000
	// Every PWM opportunity
	PWM_SM2CTRL_LDFQ_LDFQ_0 = 0x0
	// Every 2 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_1 = 0x1
	// Every 3 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_2 = 0x2
	// Every 4 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_3 = 0x3
	// Every 5 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_4 = 0x4
	// Every 6 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_5 = 0x5
	// Every 7 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_6 = 0x6
	// Every 8 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_7 = 0x7
	// Every 9 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_8 = 0x8
	// Every 10 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_9 = 0x9
	// Every 11 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_10 = 0xa
	// Every 12 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_11 = 0xb
	// Every 13 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_12 = 0xc
	// Every 14 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_13 = 0xd
	// Every 15 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_14 = 0xe
	// Every 16 PWM opportunities
	PWM_SM2CTRL_LDFQ_LDFQ_15 = 0xf

	// SM2VAL0: Value Register 0
	// Position of VAL0 field.
	PWM_SM2VAL0_VAL0_Pos = 0x0
	// Bit mask of VAL0 field.
	PWM_SM2VAL0_VAL0_Msk = 0xffff

	// SM2FRACVAL1: Fractional Value Register 1
	// Position of FRACVAL1 field.
	PWM_SM2FRACVAL1_FRACVAL1_Pos = 0xb
	// Bit mask of FRACVAL1 field.
	PWM_SM2FRACVAL1_FRACVAL1_Msk = 0xf800

	// SM2VAL1: Value Register 1
	// Position of VAL1 field.
	PWM_SM2VAL1_VAL1_Pos = 0x0
	// Bit mask of VAL1 field.
	PWM_SM2VAL1_VAL1_Msk = 0xffff

	// SM2FRACVAL2: Fractional Value Register 2
	// Position of FRACVAL2 field.
	PWM_SM2FRACVAL2_FRACVAL2_Pos = 0xb
	// Bit mask of FRACVAL2 field.
	PWM_SM2FRACVAL2_FRACVAL2_Msk = 0xf800

	// SM2VAL2: Value Register 2
	// Position of VAL2 field.
	PWM_SM2VAL2_VAL2_Pos = 0x0
	// Bit mask of VAL2 field.
	PWM_SM2VAL2_VAL2_Msk = 0xffff

	// SM2FRACVAL3: Fractional Value Register 3
	// Position of FRACVAL3 field.
	PWM_SM2FRACVAL3_FRACVAL3_Pos = 0xb
	// Bit mask of FRACVAL3 field.
	PWM_SM2FRACVAL3_FRACVAL3_Msk = 0xf800

	// SM2VAL3: Value Register 3
	// Position of VAL3 field.
	PWM_SM2VAL3_VAL3_Pos = 0x0
	// Bit mask of VAL3 field.
	PWM_SM2VAL3_VAL3_Msk = 0xffff

	// SM2FRACVAL4: Fractional Value Register 4
	// Position of FRACVAL4 field.
	PWM_SM2FRACVAL4_FRACVAL4_Pos = 0xb
	// Bit mask of FRACVAL4 field.
	PWM_SM2FRACVAL4_FRACVAL4_Msk = 0xf800

	// SM2VAL4: Value Register 4
	// Position of VAL4 field.
	PWM_SM2VAL4_VAL4_Pos = 0x0
	// Bit mask of VAL4 field.
	PWM_SM2VAL4_VAL4_Msk = 0xffff

	// SM2FRACVAL5: Fractional Value Register 5
	// Position of FRACVAL5 field.
	PWM_SM2FRACVAL5_FRACVAL5_Pos = 0xb
	// Bit mask of FRACVAL5 field.
	PWM_SM2FRACVAL5_FRACVAL5_Msk = 0xf800

	// SM2VAL5: Value Register 5
	// Position of VAL5 field.
	PWM_SM2VAL5_VAL5_Pos = 0x0
	// Bit mask of VAL5 field.
	PWM_SM2VAL5_VAL5_Msk = 0xffff

	// SM2FRCTRL: Fractional Control Register
	// Position of FRAC1_EN field.
	PWM_SM2FRCTRL_FRAC1_EN_Pos = 0x1
	// Bit mask of FRAC1_EN field.
	PWM_SM2FRCTRL_FRAC1_EN_Msk = 0x2
	// Bit FRAC1_EN.
	PWM_SM2FRCTRL_FRAC1_EN = 0x2
	// Disable fractional cycle length for the PWM period.
	PWM_SM2FRCTRL_FRAC1_EN_FRAC1_EN_0 = 0x0
	// Enable fractional cycle length for the PWM period.
	PWM_SM2FRCTRL_FRAC1_EN_FRAC1_EN_1 = 0x1
	// Position of FRAC23_EN field.
	PWM_SM2FRCTRL_FRAC23_EN_Pos = 0x2
	// Bit mask of FRAC23_EN field.
	PWM_SM2FRCTRL_FRAC23_EN_Msk = 0x4
	// Bit FRAC23_EN.
	PWM_SM2FRCTRL_FRAC23_EN = 0x4
	// Disable fractional cycle placement for PWM_A.
	PWM_SM2FRCTRL_FRAC23_EN_FRAC23_EN_0 = 0x0
	// Enable fractional cycle placement for PWM_A.
	PWM_SM2FRCTRL_FRAC23_EN_FRAC23_EN_1 = 0x1
	// Position of FRAC45_EN field.
	PWM_SM2FRCTRL_FRAC45_EN_Pos = 0x4
	// Bit mask of FRAC45_EN field.
	PWM_SM2FRCTRL_FRAC45_EN_Msk = 0x10
	// Bit FRAC45_EN.
	PWM_SM2FRCTRL_FRAC45_EN = 0x10
	// Disable fractional cycle placement for PWM_B.
	PWM_SM2FRCTRL_FRAC45_EN_FRAC45_EN_0 = 0x0
	// Enable fractional cycle placement for PWM_B.
	PWM_SM2FRCTRL_FRAC45_EN_FRAC45_EN_1 = 0x1
	// Position of FRAC_PU field.
	PWM_SM2FRCTRL_FRAC_PU_Pos = 0x8
	// Bit mask of FRAC_PU field.
	PWM_SM2FRCTRL_FRAC_PU_Msk = 0x100
	// Bit FRAC_PU.
	PWM_SM2FRCTRL_FRAC_PU = 0x100
	// Turn off fractional delay logic.
	PWM_SM2FRCTRL_FRAC_PU_FRAC_PU_0 = 0x0
	// Power up fractional delay logic.
	PWM_SM2FRCTRL_FRAC_PU_FRAC_PU_1 = 0x1
	// Position of TEST field.
	PWM_SM2FRCTRL_TEST_Pos = 0xf
	// Bit mask of TEST field.
	PWM_SM2FRCTRL_TEST_Msk = 0x8000
	// Bit TEST.
	PWM_SM2FRCTRL_TEST = 0x8000

	// SM2OCTRL: Output Control Register
	// Position of PWMXFS field.
	PWM_SM2OCTRL_PWMXFS_Pos = 0x0
	// Bit mask of PWMXFS field.
	PWM_SM2OCTRL_PWMXFS_Msk = 0x3
	// Output is forced to logic 0 state prior to consideration of output polarity control.
	PWM_SM2OCTRL_PWMXFS_PWMXFS_0 = 0x0
	// Output is forced to logic 1 state prior to consideration of output polarity control.
	PWM_SM2OCTRL_PWMXFS_PWMXFS_1 = 0x1
	// Output is tristated.
	PWM_SM2OCTRL_PWMXFS_PWMXFS_2 = 0x2
	// Output is tristated.
	PWM_SM2OCTRL_PWMXFS_PWMXFS_3 = 0x3
	// Position of PWMBFS field.
	PWM_SM2OCTRL_PWMBFS_Pos = 0x2
	// Bit mask of PWMBFS field.
	PWM_SM2OCTRL_PWMBFS_Msk = 0xc
	// Output is forced to logic 0 state prior to consideration of output polarity control.
	PWM_SM2OCTRL_PWMBFS_PWMBFS_0 = 0x0
	// Output is forced to logic 1 state prior to consideration of output polarity control.
	PWM_SM2OCTRL_PWMBFS_PWMBFS_1 = 0x1
	// Output is tristated.
	PWM_SM2OCTRL_PWMBFS_PWMBFS_2 = 0x2
	// Output is tristated.
	PWM_SM2OCTRL_PWMBFS_PWMBFS_3 = 0x3
	// Position of PWMAFS field.
	PWM_SM2OCTRL_PWMAFS_Pos = 0x4
	// Bit mask of PWMAFS field.
	PWM_SM2OCTRL_PWMAFS_Msk = 0x30
	// Output is forced to logic 0 state prior to consideration of output polarity control.
	PWM_SM2OCTRL_PWMAFS_PWMAFS_0 = 0x0
	// Output is forced to logic 1 state prior to consideration of output polarity control.
	PWM_SM2OCTRL_PWMAFS_PWMAFS_1 = 0x1
	// Output is tristated.
	PWM_SM2OCTRL_PWMAFS_PWMAFS_2 = 0x2
	// Output is tristated.
	PWM_SM2OCTRL_PWMAFS_PWMAFS_3 = 0x3
	// Position of POLX field.
	PWM_SM2OCTRL_POLX_Pos = 0x8
	// Bit mask of POLX field.
	PWM_SM2OCTRL_POLX_Msk = 0x100
	// Bit POLX.
	PWM_SM2OCTRL_POLX = 0x100
	// PWM_X output not inverted. A high level on the PWM_X pin represents the "on" or "active" state.
	PWM_SM2OCTRL_POLX_POLX_0 = 0x0
	// PWM_X output inverted. A low level on the PWM_X pin represents the "on" or "active" state.
	PWM_SM2OCTRL_POLX_POLX_1 = 0x1
	// Position of POLB field.
	PWM_SM2OCTRL_POLB_Pos = 0x9
	// Bit mask of POLB field.
	PWM_SM2OCTRL_POLB_Msk = 0x200
	// Bit POLB.
	PWM_SM2OCTRL_POLB = 0x200
	// PWM_B output not inverted. A high level on the PWM_B pin represents the "on" or "active" state.
	PWM_SM2OCTRL_POLB_POLB_0 = 0x0
	// PWM_B output inverted. A low level on the PWM_B pin represents the "on" or "active" state.
	PWM_SM2OCTRL_POLB_POLB_1 = 0x1
	// Position of POLA field.
	PWM_SM2OCTRL_POLA_Pos = 0xa
	// Bit mask of POLA field.
	PWM_SM2OCTRL_POLA_Msk = 0x400
	// Bit POLA.
	PWM_SM2OCTRL_POLA = 0x400
	// PWM_A output not inverted. A high level on the PWM_A pin represents the "on" or "active" state.
	PWM_SM2OCTRL_POLA_POLA_0 = 0x0
	// PWM_A output inverted. A low level on the PWM_A pin represents the "on" or "active" state.
	PWM_SM2OCTRL_POLA_POLA_1 = 0x1
	// Position of PWMX_IN field.
	PWM_SM2OCTRL_PWMX_IN_Pos = 0xd
	// Bit mask of PWMX_IN field.
	PWM_SM2OCTRL_PWMX_IN_Msk = 0x2000
	// Bit PWMX_IN.
	PWM_SM2OCTRL_PWMX_IN = 0x2000
	// Position of PWMB_IN field.
	PWM_SM2OCTRL_PWMB_IN_Pos = 0xe
	// Bit mask of PWMB_IN field.
	PWM_SM2OCTRL_PWMB_IN_Msk = 0x4000
	// Bit PWMB_IN.
	PWM_SM2OCTRL_PWMB_IN = 0x4000
	// Position of PWMA_IN field.
	PWM_SM2OCTRL_PWMA_IN_Pos = 0xf
	// Bit mask of PWMA_IN field.
	PWM_SM2OCTRL_PWMA_IN_Msk = 0x8000
	// Bit PWMA_IN.
	PWM_SM2OCTRL_PWMA_IN = 0x8000

	// SM2STS: Status Register
	// Position of CMPF field.
	PWM_SM2STS_CMPF_Pos = 0x0
	// Bit mask of CMPF field.
	PWM_SM2STS_CMPF_Msk = 0x3f
	// No compare event has occurred for a particular VALx value.
	PWM_SM2STS_CMPF_CMPF_0 = 0x0
	// A compare event has occurred for a particular VALx value.
	PWM_SM2STS_CMPF_CMPF_1 = 0x1
	// Position of CFX0 field.
	PWM_SM2STS_CFX0_Pos = 0x6
	// Bit mask of CFX0 field.
	PWM_SM2STS_CFX0_Msk = 0x40
	// Bit CFX0.
	PWM_SM2STS_CFX0 = 0x40
	// Position of CFX1 field.
	PWM_SM2STS_CFX1_Pos = 0x7
	// Bit mask of CFX1 field.
	PWM_SM2STS_CFX1_Msk = 0x80
	// Bit CFX1.
	PWM_SM2STS_CFX1 = 0x80
	// Position of CFB0 field.
	PWM_SM2STS_CFB0_Pos = 0x8
	// Bit mask of CFB0 field.
	PWM_SM2STS_CFB0_Msk = 0x100
	// Bit CFB0.
	PWM_SM2STS_CFB0 = 0x100
	// Position of CFB1 field.
	PWM_SM2STS_CFB1_Pos = 0x9
	// Bit mask of CFB1 field.
	PWM_SM2STS_CFB1_Msk = 0x200
	// Bit CFB1.
	PWM_SM2STS_CFB1 = 0x200
	// Position of CFA0 field.
	PWM_SM2STS_CFA0_Pos = 0xa
	// Bit mask of CFA0 field.
	PWM_SM2STS_CFA0_Msk = 0x400
	// Bit CFA0.
	PWM_SM2STS_CFA0 = 0x400
	// Position of CFA1 field.
	PWM_SM2STS_CFA1_Pos = 0xb
	// Bit mask of CFA1 field.
	PWM_SM2STS_CFA1_Msk = 0x800
	// Bit CFA1.
	PWM_SM2STS_CFA1 = 0x800
	// Position of RF field.
	PWM_SM2STS_RF_Pos = 0xc
	// Bit mask of RF field.
	PWM_SM2STS_RF_Msk = 0x1000
	// Bit RF.
	PWM_SM2STS_RF = 0x1000
	// No new reload cycle since last STS[RF] clearing
	PWM_SM2STS_RF_RF_0 = 0x0
	// New reload cycle since last STS[RF] clearing
	PWM_SM2STS_RF_RF_1 = 0x1
	// Position of REF field.
	PWM_SM2STS_REF_Pos = 0xd
	// Bit mask of REF field.
	PWM_SM2STS_REF_Msk = 0x2000
	// Bit REF.
	PWM_SM2STS_REF = 0x2000
	// No reload error occurred.
	PWM_SM2STS_REF_REF_0 = 0x0
	// Reload signal occurred with non-coherent data and MCTRL[LDOK] = 0.
	PWM_SM2STS_REF_REF_1 = 0x1
	// Position of RUF field.
	PWM_SM2STS_RUF_Pos = 0xe
	// Bit mask of RUF field.
	PWM_SM2STS_RUF_Msk = 0x4000
	// Bit RUF.
	PWM_SM2STS_RUF = 0x4000
	// No register update has occurred since last reload.
	PWM_SM2STS_RUF_RUF_0 = 0x0
	// At least one of the double buffered registers has been updated since the last reload.
	PWM_SM2STS_RUF_RUF_1 = 0x1

	// SM2INTEN: Interrupt Enable Register
	// Position of CMPIE field.
	PWM_SM2INTEN_CMPIE_Pos = 0x0
	// Bit mask of CMPIE field.
	PWM_SM2INTEN_CMPIE_Msk = 0x3f
	// The corresponding STS[CMPF] bit will not cause an interrupt request.
	PWM_SM2INTEN_CMPIE_CMPIE_0 = 0x0
	// The corresponding STS[CMPF] bit will cause an interrupt request.
	PWM_SM2INTEN_CMPIE_CMPIE_1 = 0x1
	// Position of CX0IE field.
	PWM_SM2INTEN_CX0IE_Pos = 0x6
	// Bit mask of CX0IE field.
	PWM_SM2INTEN_CX0IE_Msk = 0x40
	// Bit CX0IE.
	PWM_SM2INTEN_CX0IE = 0x40
	// Interrupt request disabled for STS[CFX0].
	PWM_SM2INTEN_CX0IE_CX0IE_0 = 0x0
	// Interrupt request enabled for STS[CFX0].
	PWM_SM2INTEN_CX0IE_CX0IE_1 = 0x1
	// Position of CX1IE field.
	PWM_SM2INTEN_CX1IE_Pos = 0x7
	// Bit mask of CX1IE field.
	PWM_SM2INTEN_CX1IE_Msk = 0x80
	// Bit CX1IE.
	PWM_SM2INTEN_CX1IE = 0x80
	// Interrupt request disabled for STS[CFX1].
	PWM_SM2INTEN_CX1IE_CX1IE_0 = 0x0
	// Interrupt request enabled for STS[CFX1].
	PWM_SM2INTEN_CX1IE_CX1IE_1 = 0x1
	// Position of CB0IE field.
	PWM_SM2INTEN_CB0IE_Pos = 0x8
	// Bit mask of CB0IE field.
	PWM_SM2INTEN_CB0IE_Msk = 0x100
	// Bit CB0IE.
	PWM_SM2INTEN_CB0IE = 0x100
	// Interrupt request disabled for STS[CFB0].
	PWM_SM2INTEN_CB0IE_CB0IE_0 = 0x0
	// Interrupt request enabled for STS[CFB0].
	PWM_SM2INTEN_CB0IE_CB0IE_1 = 0x1
	// Position of CB1IE field.
	PWM_SM2INTEN_CB1IE_Pos = 0x9
	// Bit mask of CB1IE field.
	PWM_SM2INTEN_CB1IE_Msk = 0x200
	// Bit CB1IE.
	PWM_SM2INTEN_CB1IE = 0x200
	// Interrupt request disabled for STS[CFB1].
	PWM_SM2INTEN_CB1IE_CB1IE_0 = 0x0
	// Interrupt request enabled for STS[CFB1].
	PWM_SM2INTEN_CB1IE_CB1IE_1 = 0x1
	// Position of CA0IE field.
	PWM_SM2INTEN_CA0IE_Pos = 0xa
	// Bit mask of CA0IE field.
	PWM_SM2INTEN_CA0IE_Msk = 0x400
	// Bit CA0IE.
	PWM_SM2INTEN_CA0IE = 0x400
	// Interrupt request disabled for STS[CFA0].
	PWM_SM2INTEN_CA0IE_CA0IE_0 = 0x0
	// Interrupt request enabled for STS[CFA0].
	PWM_SM2INTEN_CA0IE_CA0IE_1 = 0x1
	// Position of CA1IE field.
	PWM_SM2INTEN_CA1IE_Pos = 0xb
	// Bit mask of CA1IE field.
	PWM_SM2INTEN_CA1IE_Msk = 0x800
	// Bit CA1IE.
	PWM_SM2INTEN_CA1IE = 0x800
	// Interrupt request disabled for STS[CFA1].
	PWM_SM2INTEN_CA1IE_CA1IE_0 = 0x0
	// Interrupt request enabled for STS[CFA1].
	PWM_SM2INTEN_CA1IE_CA1IE_1 = 0x1
	// Position of RIE field.
	PWM_SM2INTEN_RIE_Pos = 0xc
	// Bit mask of RIE field.
	PWM_SM2INTEN_RIE_Msk = 0x1000
	// Bit RIE.
	PWM_SM2INTEN_RIE = 0x1000
	// STS[RF] CPU interrupt requests disabled
	PWM_SM2INTEN_RIE_RIE_0 = 0x0
	// STS[RF] CPU interrupt requests enabled
	PWM_SM2INTEN_RIE_RIE_1 = 0x1
	// Position of REIE field.
	PWM_SM2INTEN_REIE_Pos = 0xd
	// Bit mask of REIE field.
	PWM_SM2INTEN_REIE_Msk = 0x2000
	// Bit REIE.
	PWM_SM2INTEN_REIE = 0x2000
	// STS[REF] CPU interrupt requests disabled
	PWM_SM2INTEN_REIE_REIE_0 = 0x0
	// STS[REF] CPU interrupt requests enabled
	PWM_SM2INTEN_REIE_REIE_1 = 0x1

	// SM2DMAEN: DMA Enable Register
	// Position of CX0DE field.
	PWM_SM2DMAEN_CX0DE_Pos = 0x0
	// Bit mask of CX0DE field.
	PWM_SM2DMAEN_CX0DE_Msk = 0x1
	// Bit CX0DE.
	PWM_SM2DMAEN_CX0DE = 0x1
	// Position of CX1DE field.
	PWM_SM2DMAEN_CX1DE_Pos = 0x1
	// Bit mask of CX1DE field.
	PWM_SM2DMAEN_CX1DE_Msk = 0x2
	// Bit CX1DE.
	PWM_SM2DMAEN_CX1DE = 0x2
	// Position of CB0DE field.
	PWM_SM2DMAEN_CB0DE_Pos = 0x2
	// Bit mask of CB0DE field.
	PWM_SM2DMAEN_CB0DE_Msk = 0x4
	// Bit CB0DE.
	PWM_SM2DMAEN_CB0DE = 0x4
	// Position of CB1DE field.
	PWM_SM2DMAEN_CB1DE_Pos = 0x3
	// Bit mask of CB1DE field.
	PWM_SM2DMAEN_CB1DE_Msk = 0x8
	// Bit CB1DE.
	PWM_SM2DMAEN_CB1DE = 0x8
	// Position of CA0DE field.
	PWM_SM2DMAEN_CA0DE_Pos = 0x4
	// Bit mask of CA0DE field.
	PWM_SM2DMAEN_CA0DE_Msk = 0x10
	// Bit CA0DE.
	PWM_SM2DMAEN_CA0DE = 0x10
	// Position of CA1DE field.
	PWM_SM2DMAEN_CA1DE_Pos = 0x5
	// Bit mask of CA1DE field.
	PWM_SM2DMAEN_CA1DE_Msk = 0x20
	// Bit CA1DE.
	PWM_SM2DMAEN_CA1DE = 0x20
	// Position of CAPTDE field.
	PWM_SM2DMAEN_CAPTDE_Pos = 0x6
	// Bit mask of CAPTDE field.
	PWM_SM2DMAEN_CAPTDE_Msk = 0xc0
	// Read DMA requests disabled.
	PWM_SM2DMAEN_CAPTDE_CAPTDE_0 = 0x0
	// Exceeding a FIFO watermark sets the DMA read request. This requires at least one of DMAEN[CA1DE], DMAEN[CA0DE], DMAEN[CB1DE], DMAEN[CB0DE], DMAEN[CX1DE], or DMAEN[CX0DE] to also be set in order to determine to which watermark(s) the DMA request is sensitive.
	PWM_SM2DMAEN_CAPTDE_CAPTDE_1 = 0x1
	// A local sync (VAL1 matches counter) sets the read DMA request.
	PWM_SM2DMAEN_CAPTDE_CAPTDE_2 = 0x2
	// A local reload (STS[RF] being set) sets the read DMA request.
	PWM_SM2DMAEN_CAPTDE_CAPTDE_3 = 0x3
	// Position of FAND field.
	PWM_SM2DMAEN_FAND_Pos = 0x8
	// Bit mask of FAND field.
	PWM_SM2DMAEN_FAND_Msk = 0x100
	// Bit FAND.
	PWM_SM2DMAEN_FAND = 0x100
	// Selected FIFO watermarks are OR'ed together.
	PWM_SM2DMAEN_FAND_FAND_0 = 0x0
	// Selected FIFO watermarks are AND'ed together.
	PWM_SM2DMAEN_FAND_FAND_1 = 0x1
	// Position of VALDE field.
	PWM_SM2DMAEN_VALDE_Pos = 0x9
	// Bit mask of VALDE field.
	PWM_SM2DMAEN_VALDE_Msk = 0x200
	// Bit VALDE.
	PWM_SM2DMAEN_VALDE = 0x200
	// DMA write requests disabled
	PWM_SM2DMAEN_VALDE_VALDE_0 = 0x0
	// DMA write requests for the VALx and FRACVALx registers enabled
	PWM_SM2DMAEN_VALDE_VALDE_1 = 0x1

	// SM2TCTRL: Output Trigger Control Register
	// Position of OUT_TRIG_EN field.
	PWM_SM2TCTRL_OUT_TRIG_EN_Pos = 0x0
	// Bit mask of OUT_TRIG_EN field.
	PWM_SM2TCTRL_OUT_TRIG_EN_Msk = 0x3f
	// PWM_OUT_TRIGx will not set when the counter value matches the VALx value.
	PWM_SM2TCTRL_OUT_TRIG_EN_OUT_TRIG_EN_0 = 0x0
	// PWM_OUT_TRIGx will set when the counter value matches the VALx value.
	PWM_SM2TCTRL_OUT_TRIG_EN_OUT_TRIG_EN_1 = 0x1
	// Position of TRGFRQ field.
	PWM_SM2TCTRL_TRGFRQ_Pos = 0xc
	// Bit mask of TRGFRQ field.
	PWM_SM2TCTRL_TRGFRQ_Msk = 0x1000
	// Bit TRGFRQ.
	PWM_SM2TCTRL_TRGFRQ = 0x1000
	// Trigger outputs are generated during every PWM period even if the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
	PWM_SM2TCTRL_TRGFRQ_TRGFRQ_0 = 0x0
	// Trigger outputs are generated only during the final PWM period prior to a reload opportunity when the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
	PWM_SM2TCTRL_TRGFRQ_TRGFRQ_1 = 0x1
	// Position of PWBOT1 field.
	PWM_SM2TCTRL_PWBOT1_Pos = 0xe
	// Bit mask of PWBOT1 field.
	PWM_SM2TCTRL_PWBOT1_Msk = 0x4000
	// Bit PWBOT1.
	PWM_SM2TCTRL_PWBOT1 = 0x4000
	// Route the PWM_OUT_TRIG1 signal to PWM_OUT_TRIG1 port.
	PWM_SM2TCTRL_PWBOT1_PWBOT1_0 = 0x0
	// Route the PWMB output to the PWM_OUT_TRIG1 port.
	PWM_SM2TCTRL_PWBOT1_PWBOT1_1 = 0x1
	// Position of PWAOT0 field.
	PWM_SM2TCTRL_PWAOT0_Pos = 0xf
	// Bit mask of PWAOT0 field.
	PWM_SM2TCTRL_PWAOT0_Msk = 0x8000
	// Bit PWAOT0.
	PWM_SM2TCTRL_PWAOT0 = 0x8000
	// Route the PWM_OUT_TRIG0 signal to PWM_OUT_TRIG0 port.
	PWM_SM2TCTRL_PWAOT0_PWAOT0_0 = 0x0
	// Route the PWMA output to the PWM_OUT_TRIG0 port.
	PWM_SM2TCTRL_PWAOT0_PWAOT0_1 = 0x1

	// SM2DISMAP0: Fault Disable Mapping Register 0
	// Position of DIS0A field.
	PWM_SM2DISMAP0_DIS0A_Pos = 0x0
	// Bit mask of DIS0A field.
	PWM_SM2DISMAP0_DIS0A_Msk = 0xf
	// Position of DIS0B field.
	PWM_SM2DISMAP0_DIS0B_Pos = 0x4
	// Bit mask of DIS0B field.
	PWM_SM2DISMAP0_DIS0B_Msk = 0xf0
	// Position of DIS0X field.
	PWM_SM2DISMAP0_DIS0X_Pos = 0x8
	// Bit mask of DIS0X field.
	PWM_SM2DISMAP0_DIS0X_Msk = 0xf00

	// SM2DISMAP1: Fault Disable Mapping Register 1
	// Position of DIS1A field.
	PWM_SM2DISMAP1_DIS1A_Pos = 0x0
	// Bit mask of DIS1A field.
	PWM_SM2DISMAP1_DIS1A_Msk = 0xf
	// Position of DIS1B field.
	PWM_SM2DISMAP1_DIS1B_Pos = 0x4
	// Bit mask of DIS1B field.
	PWM_SM2DISMAP1_DIS1B_Msk = 0xf0
	// Position of DIS1X field.
	PWM_SM2DISMAP1_DIS1X_Pos = 0x8
	// Bit mask of DIS1X field.
	PWM_SM2DISMAP1_DIS1X_Msk = 0xf00

	// SM2DTCNT0: Deadtime Count Register 0
	// Position of DTCNT0 field.
	PWM_SM2DTCNT0_DTCNT0_Pos = 0x0
	// Bit mask of DTCNT0 field.
	PWM_SM2DTCNT0_DTCNT0_Msk = 0xffff

	// SM2DTCNT1: Deadtime Count Register 1
	// Position of DTCNT1 field.
	PWM_SM2DTCNT1_DTCNT1_Pos = 0x0
	// Bit mask of DTCNT1 field.
	PWM_SM2DTCNT1_DTCNT1_Msk = 0xffff

	// SM2CAPTCTRLA: Capture Control A Register
	// Position of ARMA field.
	PWM_SM2CAPTCTRLA_ARMA_Pos = 0x0
	// Bit mask of ARMA field.
	PWM_SM2CAPTCTRLA_ARMA_Msk = 0x1
	// Bit ARMA.
	PWM_SM2CAPTCTRLA_ARMA = 0x1
	// Input capture operation is disabled.
	PWM_SM2CAPTCTRLA_ARMA_ARMA_0 = 0x0
	// Input capture operation as specified by CAPTCTRLA[EDGAx] is enabled.
	PWM_SM2CAPTCTRLA_ARMA_ARMA_1 = 0x1
	// Position of ONESHOTA field.
	PWM_SM2CAPTCTRLA_ONESHOTA_Pos = 0x1
	// Bit mask of ONESHOTA field.
	PWM_SM2CAPTCTRLA_ONESHOTA_Msk = 0x2
	// Bit ONESHOTA.
	PWM_SM2CAPTCTRLA_ONESHOTA = 0x2
	// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	PWM_SM2CAPTCTRLA_ONESHOTA_ONESHOTA_0 = 0x0
	// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLA[ARMA] is cleared. No further captures will be performed until CAPTCTRLA[ARMA] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLA[ARMA] is then cleared.
	PWM_SM2CAPTCTRLA_ONESHOTA_ONESHOTA_1 = 0x1
	// Position of EDGA0 field.
	PWM_SM2CAPTCTRLA_EDGA0_Pos = 0x2
	// Bit mask of EDGA0 field.
	PWM_SM2CAPTCTRLA_EDGA0_Msk = 0xc
	// Disabled
	PWM_SM2CAPTCTRLA_EDGA0_EDGA0_0 = 0x0
	// Capture falling edges
	PWM_SM2CAPTCTRLA_EDGA0_EDGA0_1 = 0x1
	// Capture rising edges
	PWM_SM2CAPTCTRLA_EDGA0_EDGA0_2 = 0x2
	// Capture any edge
	PWM_SM2CAPTCTRLA_EDGA0_EDGA0_3 = 0x3
	// Position of EDGA1 field.
	PWM_SM2CAPTCTRLA_EDGA1_Pos = 0x4
	// Bit mask of EDGA1 field.
	PWM_SM2CAPTCTRLA_EDGA1_Msk = 0x30
	// Disabled
	PWM_SM2CAPTCTRLA_EDGA1_EDGA1_0 = 0x0
	// Capture falling edges
	PWM_SM2CAPTCTRLA_EDGA1_EDGA1_1 = 0x1
	// Capture rising edges
	PWM_SM2CAPTCTRLA_EDGA1_EDGA1_2 = 0x2
	// Capture any edge
	PWM_SM2CAPTCTRLA_EDGA1_EDGA1_3 = 0x3
	// Position of INP_SELA field.
	PWM_SM2CAPTCTRLA_INP_SELA_Pos = 0x6
	// Bit mask of INP_SELA field.
	PWM_SM2CAPTCTRLA_INP_SELA_Msk = 0x40
	// Bit INP_SELA.
	PWM_SM2CAPTCTRLA_INP_SELA = 0x40
	// Raw PWM_A input signal selected as source.
	PWM_SM2CAPTCTRLA_INP_SELA_INP_SELA_0 = 0x0
	// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLA[EDGA0] and CAPTCTRLA[EDGA1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRA[EDGA0] and/or CAPTCTRLA[EDGA1] fields in order to enable one or both of the capture registers.
	PWM_SM2CAPTCTRLA_INP_SELA_INP_SELA_1 = 0x1
	// Position of EDGCNTA_EN field.
	PWM_SM2CAPTCTRLA_EDGCNTA_EN_Pos = 0x7
	// Bit mask of EDGCNTA_EN field.
	PWM_SM2CAPTCTRLA_EDGCNTA_EN_Msk = 0x80
	// Bit EDGCNTA_EN.
	PWM_SM2CAPTCTRLA_EDGCNTA_EN = 0x80
	// Edge counter disabled and held in reset
	PWM_SM2CAPTCTRLA_EDGCNTA_EN_EDGCNTA_EN_0 = 0x0
	// Edge counter enabled
	PWM_SM2CAPTCTRLA_EDGCNTA_EN_EDGCNTA_EN_1 = 0x1
	// Position of CFAWM field.
	PWM_SM2CAPTCTRLA_CFAWM_Pos = 0x8
	// Bit mask of CFAWM field.
	PWM_SM2CAPTCTRLA_CFAWM_Msk = 0x300
	// Position of CA0CNT field.
	PWM_SM2CAPTCTRLA_CA0CNT_Pos = 0xa
	// Bit mask of CA0CNT field.
	PWM_SM2CAPTCTRLA_CA0CNT_Msk = 0x1c00
	// Position of CA1CNT field.
	PWM_SM2CAPTCTRLA_CA1CNT_Pos = 0xd
	// Bit mask of CA1CNT field.
	PWM_SM2CAPTCTRLA_CA1CNT_Msk = 0xe000

	// SM2CAPTCOMPA: Capture Compare A Register
	// Position of EDGCMPA field.
	PWM_SM2CAPTCOMPA_EDGCMPA_Pos = 0x0
	// Bit mask of EDGCMPA field.
	PWM_SM2CAPTCOMPA_EDGCMPA_Msk = 0xff
	// Position of EDGCNTA field.
	PWM_SM2CAPTCOMPA_EDGCNTA_Pos = 0x8
	// Bit mask of EDGCNTA field.
	PWM_SM2CAPTCOMPA_EDGCNTA_Msk = 0xff00

	// SM2CAPTCTRLB: Capture Control B Register
	// Position of ARMB field.
	PWM_SM2CAPTCTRLB_ARMB_Pos = 0x0
	// Bit mask of ARMB field.
	PWM_SM2CAPTCTRLB_ARMB_Msk = 0x1
	// Bit ARMB.
	PWM_SM2CAPTCTRLB_ARMB = 0x1
	// Input capture operation is disabled.
	PWM_SM2CAPTCTRLB_ARMB_ARMB_0 = 0x0
	// Input capture operation as specified by CAPTCTRLB[EDGBx] is enabled.
	PWM_SM2CAPTCTRLB_ARMB_ARMB_1 = 0x1
	// Position of ONESHOTB field.
	PWM_SM2CAPTCTRLB_ONESHOTB_Pos = 0x1
	// Bit mask of ONESHOTB field.
	PWM_SM2CAPTCTRLB_ONESHOTB_Msk = 0x2
	// Bit ONESHOTB.
	PWM_SM2CAPTCTRLB_ONESHOTB = 0x2
	// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	PWM_SM2CAPTCTRLB_ONESHOTB_ONESHOTB_0 = 0x0
	// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLB[ARMB] is cleared. No further captures will be performed until CAPTCTRLB[ARMB] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLB[ARMB] is then cleared.
	PWM_SM2CAPTCTRLB_ONESHOTB_ONESHOTB_1 = 0x1
	// Position of EDGB0 field.
	PWM_SM2CAPTCTRLB_EDGB0_Pos = 0x2
	// Bit mask of EDGB0 field.
	PWM_SM2CAPTCTRLB_EDGB0_Msk = 0xc
	// Disabled
	PWM_SM2CAPTCTRLB_EDGB0_EDGB0_0 = 0x0
	// Capture falling edges
	PWM_SM2CAPTCTRLB_EDGB0_EDGB0_1 = 0x1
	// Capture rising edges
	PWM_SM2CAPTCTRLB_EDGB0_EDGB0_2 = 0x2
	// Capture any edge
	PWM_SM2CAPTCTRLB_EDGB0_EDGB0_3 = 0x3
	// Position of EDGB1 field.
	PWM_SM2CAPTCTRLB_EDGB1_Pos = 0x4
	// Bit mask of EDGB1 field.
	PWM_SM2CAPTCTRLB_EDGB1_Msk = 0x30
	// Disabled
	PWM_SM2CAPTCTRLB_EDGB1_EDGB1_0 = 0x0
	// Capture falling edges
	PWM_SM2CAPTCTRLB_EDGB1_EDGB1_1 = 0x1
	// Capture rising edges
	PWM_SM2CAPTCTRLB_EDGB1_EDGB1_2 = 0x2
	// Capture any edge
	PWM_SM2CAPTCTRLB_EDGB1_EDGB1_3 = 0x3
	// Position of INP_SELB field.
	PWM_SM2CAPTCTRLB_INP_SELB_Pos = 0x6
	// Bit mask of INP_SELB field.
	PWM_SM2CAPTCTRLB_INP_SELB_Msk = 0x40
	// Bit INP_SELB.
	PWM_SM2CAPTCTRLB_INP_SELB = 0x40
	// Raw PWM_B input signal selected as source.
	PWM_SM2CAPTCTRLB_INP_SELB_INP_SELB_0 = 0x0
	// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLB[EDGB0] and CAPTCTRLB[EDGB1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRB[EDGB0] and/or CAPTCTRLB[EDGB1] fields in order to enable one or both of the capture registers.
	PWM_SM2CAPTCTRLB_INP_SELB_INP_SELB_1 = 0x1
	// Position of EDGCNTB_EN field.
	PWM_SM2CAPTCTRLB_EDGCNTB_EN_Pos = 0x7
	// Bit mask of EDGCNTB_EN field.
	PWM_SM2CAPTCTRLB_EDGCNTB_EN_Msk = 0x80
	// Bit EDGCNTB_EN.
	PWM_SM2CAPTCTRLB_EDGCNTB_EN = 0x80
	// Edge counter disabled and held in reset
	PWM_SM2CAPTCTRLB_EDGCNTB_EN_EDGCNTB_EN_0 = 0x0
	// Edge counter enabled
	PWM_SM2CAPTCTRLB_EDGCNTB_EN_EDGCNTB_EN_1 = 0x1
	// Position of CFBWM field.
	PWM_SM2CAPTCTRLB_CFBWM_Pos = 0x8
	// Bit mask of CFBWM field.
	PWM_SM2CAPTCTRLB_CFBWM_Msk = 0x300
	// Position of CB0CNT field.
	PWM_SM2CAPTCTRLB_CB0CNT_Pos = 0xa
	// Bit mask of CB0CNT field.
	PWM_SM2CAPTCTRLB_CB0CNT_Msk = 0x1c00
	// Position of CB1CNT field.
	PWM_SM2CAPTCTRLB_CB1CNT_Pos = 0xd
	// Bit mask of CB1CNT field.
	PWM_SM2CAPTCTRLB_CB1CNT_Msk = 0xe000

	// SM2CAPTCOMPB: Capture Compare B Register
	// Position of EDGCMPB field.
	PWM_SM2CAPTCOMPB_EDGCMPB_Pos = 0x0
	// Bit mask of EDGCMPB field.
	PWM_SM2CAPTCOMPB_EDGCMPB_Msk = 0xff
	// Position of EDGCNTB field.
	PWM_SM2CAPTCOMPB_EDGCNTB_Pos = 0x8
	// Bit mask of EDGCNTB field.
	PWM_SM2CAPTCOMPB_EDGCNTB_Msk = 0xff00

	// SM2CAPTCTRLX: Capture Control X Register
	// Position of ARMX field.
	PWM_SM2CAPTCTRLX_ARMX_Pos = 0x0
	// Bit mask of ARMX field.
	PWM_SM2CAPTCTRLX_ARMX_Msk = 0x1
	// Bit ARMX.
	PWM_SM2CAPTCTRLX_ARMX = 0x1
	// Input capture operation is disabled.
	PWM_SM2CAPTCTRLX_ARMX_ARMX_0 = 0x0
	// Input capture operation as specified by CAPTCTRLX[EDGXx] is enabled.
	PWM_SM2CAPTCTRLX_ARMX_ARMX_1 = 0x1
	// Position of ONESHOTX field.
	PWM_SM2CAPTCTRLX_ONESHOTX_Pos = 0x1
	// Bit mask of ONESHOTX field.
	PWM_SM2CAPTCTRLX_ONESHOTX_Msk = 0x2
	// Bit ONESHOTX.
	PWM_SM2CAPTCTRLX_ONESHOTX = 0x2
	// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	PWM_SM2CAPTCTRLX_ONESHOTX_ONESHOTX_0 = 0x0
	// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and the ARMX bit is cleared. No further captures will be performed until the ARMX bit is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and the ARMX bit is then cleared.
	PWM_SM2CAPTCTRLX_ONESHOTX_ONESHOTX_1 = 0x1
	// Position of EDGX0 field.
	PWM_SM2CAPTCTRLX_EDGX0_Pos = 0x2
	// Bit mask of EDGX0 field.
	PWM_SM2CAPTCTRLX_EDGX0_Msk = 0xc
	// Disabled
	PWM_SM2CAPTCTRLX_EDGX0_EDGX0_0 = 0x0
	// Capture falling edges
	PWM_SM2CAPTCTRLX_EDGX0_EDGX0_1 = 0x1
	// Capture rising edges
	PWM_SM2CAPTCTRLX_EDGX0_EDGX0_2 = 0x2
	// Capture any edge
	PWM_SM2CAPTCTRLX_EDGX0_EDGX0_3 = 0x3
	// Position of EDGX1 field.
	PWM_SM2CAPTCTRLX_EDGX1_Pos = 0x4
	// Bit mask of EDGX1 field.
	PWM_SM2CAPTCTRLX_EDGX1_Msk = 0x30
	// Disabled
	PWM_SM2CAPTCTRLX_EDGX1_EDGX1_0 = 0x0
	// Capture falling edges
	PWM_SM2CAPTCTRLX_EDGX1_EDGX1_1 = 0x1
	// Capture rising edges
	PWM_SM2CAPTCTRLX_EDGX1_EDGX1_2 = 0x2
	// Capture any edge
	PWM_SM2CAPTCTRLX_EDGX1_EDGX1_3 = 0x3
	// Position of INP_SELX field.
	PWM_SM2CAPTCTRLX_INP_SELX_Pos = 0x6
	// Bit mask of INP_SELX field.
	PWM_SM2CAPTCTRLX_INP_SELX_Msk = 0x40
	// Bit INP_SELX.
	PWM_SM2CAPTCTRLX_INP_SELX = 0x40
	// Raw PWM_X input signal selected as source.
	PWM_SM2CAPTCTRLX_INP_SELX_INP_SELX_0 = 0x0
	// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLX[EDGX0] and CAPTCTRLX[EDGX1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRX[EDGX0] and/or CAPTCTRLX[EDGX1] fields in order to enable one or both of the capture registers.
	PWM_SM2CAPTCTRLX_INP_SELX_INP_SELX_1 = 0x1
	// Position of EDGCNTX_EN field.
	PWM_SM2CAPTCTRLX_EDGCNTX_EN_Pos = 0x7
	// Bit mask of EDGCNTX_EN field.
	PWM_SM2CAPTCTRLX_EDGCNTX_EN_Msk = 0x80
	// Bit EDGCNTX_EN.
	PWM_SM2CAPTCTRLX_EDGCNTX_EN = 0x80
	// Edge counter disabled and held in reset
	PWM_SM2CAPTCTRLX_EDGCNTX_EN_EDGCNTX_EN_0 = 0x0
	// Edge counter enabled
	PWM_SM2CAPTCTRLX_EDGCNTX_EN_EDGCNTX_EN_1 = 0x1
	// Position of CFXWM field.
	PWM_SM2CAPTCTRLX_CFXWM_Pos = 0x8
	// Bit mask of CFXWM field.
	PWM_SM2CAPTCTRLX_CFXWM_Msk = 0x300
	// Position of CX0CNT field.
	PWM_SM2CAPTCTRLX_CX0CNT_Pos = 0xa
	// Bit mask of CX0CNT field.
	PWM_SM2CAPTCTRLX_CX0CNT_Msk = 0x1c00
	// Position of CX1CNT field.
	PWM_SM2CAPTCTRLX_CX1CNT_Pos = 0xd
	// Bit mask of CX1CNT field.
	PWM_SM2CAPTCTRLX_CX1CNT_Msk = 0xe000

	// SM2CAPTCOMPX: Capture Compare X Register
	// Position of EDGCMPX field.
	PWM_SM2CAPTCOMPX_EDGCMPX_Pos = 0x0
	// Bit mask of EDGCMPX field.
	PWM_SM2CAPTCOMPX_EDGCMPX_Msk = 0xff
	// Position of EDGCNTX field.
	PWM_SM2CAPTCOMPX_EDGCNTX_Pos = 0x8
	// Bit mask of EDGCNTX field.
	PWM_SM2CAPTCOMPX_EDGCNTX_Msk = 0xff00

	// SM2CVAL0: Capture Value 0 Register
	// Position of CAPTVAL0 field.
	PWM_SM2CVAL0_CAPTVAL0_Pos = 0x0
	// Bit mask of CAPTVAL0 field.
	PWM_SM2CVAL0_CAPTVAL0_Msk = 0xffff

	// SM2CVAL0CYC: Capture Value 0 Cycle Register
	// Position of CVAL0CYC field.
	PWM_SM2CVAL0CYC_CVAL0CYC_Pos = 0x0
	// Bit mask of CVAL0CYC field.
	PWM_SM2CVAL0CYC_CVAL0CYC_Msk = 0xf

	// SM2CVAL1: Capture Value 1 Register
	// Position of CAPTVAL1 field.
	PWM_SM2CVAL1_CAPTVAL1_Pos = 0x0
	// Bit mask of CAPTVAL1 field.
	PWM_SM2CVAL1_CAPTVAL1_Msk = 0xffff

	// SM2CVAL1CYC: Capture Value 1 Cycle Register
	// Position of CVAL1CYC field.
	PWM_SM2CVAL1CYC_CVAL1CYC_Pos = 0x0
	// Bit mask of CVAL1CYC field.
	PWM_SM2CVAL1CYC_CVAL1CYC_Msk = 0xf

	// SM2CVAL2: Capture Value 2 Register
	// Position of CAPTVAL2 field.
	PWM_SM2CVAL2_CAPTVAL2_Pos = 0x0
	// Bit mask of CAPTVAL2 field.
	PWM_SM2CVAL2_CAPTVAL2_Msk = 0xffff

	// SM2CVAL2CYC: Capture Value 2 Cycle Register
	// Position of CVAL2CYC field.
	PWM_SM2CVAL2CYC_CVAL2CYC_Pos = 0x0
	// Bit mask of CVAL2CYC field.
	PWM_SM2CVAL2CYC_CVAL2CYC_Msk = 0xf

	// SM2CVAL3: Capture Value 3 Register
	// Position of CAPTVAL3 field.
	PWM_SM2CVAL3_CAPTVAL3_Pos = 0x0
	// Bit mask of CAPTVAL3 field.
	PWM_SM2CVAL3_CAPTVAL3_Msk = 0xffff

	// SM2CVAL3CYC: Capture Value 3 Cycle Register
	// Position of CVAL3CYC field.
	PWM_SM2CVAL3CYC_CVAL3CYC_Pos = 0x0
	// Bit mask of CVAL3CYC field.
	PWM_SM2CVAL3CYC_CVAL3CYC_Msk = 0xf

	// SM2CVAL4: Capture Value 4 Register
	// Position of CAPTVAL4 field.
	PWM_SM2CVAL4_CAPTVAL4_Pos = 0x0
	// Bit mask of CAPTVAL4 field.
	PWM_SM2CVAL4_CAPTVAL4_Msk = 0xffff

	// SM2CVAL4CYC: Capture Value 4 Cycle Register
	// Position of CVAL4CYC field.
	PWM_SM2CVAL4CYC_CVAL4CYC_Pos = 0x0
	// Bit mask of CVAL4CYC field.
	PWM_SM2CVAL4CYC_CVAL4CYC_Msk = 0xf

	// SM2CVAL5: Capture Value 5 Register
	// Position of CAPTVAL5 field.
	PWM_SM2CVAL5_CAPTVAL5_Pos = 0x0
	// Bit mask of CAPTVAL5 field.
	PWM_SM2CVAL5_CAPTVAL5_Msk = 0xffff

	// SM2CVAL5CYC: Capture Value 5 Cycle Register
	// Position of CVAL5CYC field.
	PWM_SM2CVAL5CYC_CVAL5CYC_Pos = 0x0
	// Bit mask of CVAL5CYC field.
	PWM_SM2CVAL5CYC_CVAL5CYC_Msk = 0xf

	// SM2PHASEDLY: Phase Delay Register
	// Position of PHASEDLY field.
	PWM_SM2PHASEDLY_PHASEDLY_Pos = 0x0
	// Bit mask of PHASEDLY field.
	PWM_SM2PHASEDLY_PHASEDLY_Msk = 0xffff

	// SM3CNT: Counter Register
	// Position of CNT field.
	PWM_SM3CNT_CNT_Pos = 0x0
	// Bit mask of CNT field.
	PWM_SM3CNT_CNT_Msk = 0xffff

	// SM3INIT: Initial Count Register
	// Position of INIT field.
	PWM_SM3INIT_INIT_Pos = 0x0
	// Bit mask of INIT field.
	PWM_SM3INIT_INIT_Msk = 0xffff

	// SM3CTRL2: Control 2 Register
	// Position of CLK_SEL field.
	PWM_SM3CTRL2_CLK_SEL_Pos = 0x0
	// Bit mask of CLK_SEL field.
	PWM_SM3CTRL2_CLK_SEL_Msk = 0x3
	// The IPBus clock is used as the clock for the local prescaler and counter.
	PWM_SM3CTRL2_CLK_SEL_CLK_SEL_0 = 0x0
	// EXT_CLK is used as the clock for the local prescaler and counter.
	PWM_SM3CTRL2_CLK_SEL_CLK_SEL_1 = 0x1
	// Submodule 0's clock (AUX_CLK) is used as the source clock for the local prescaler and counter. This setting should not be used in submodule 0 as it will force the clock to logic 0.
	PWM_SM3CTRL2_CLK_SEL_CLK_SEL_2 = 0x2
	// Position of RELOAD_SEL field.
	PWM_SM3CTRL2_RELOAD_SEL_Pos = 0x2
	// Bit mask of RELOAD_SEL field.
	PWM_SM3CTRL2_RELOAD_SEL_Msk = 0x4
	// Bit RELOAD_SEL.
	PWM_SM3CTRL2_RELOAD_SEL = 0x4
	// The local RELOAD signal is used to reload registers.
	PWM_SM3CTRL2_RELOAD_SEL_RELOAD_SEL_0 = 0x0
	// The master RELOAD signal (from submodule 0) is used to reload registers. This setting should not be used in submodule 0 as it will force the RELOAD signal to logic 0.
	PWM_SM3CTRL2_RELOAD_SEL_RELOAD_SEL_1 = 0x1
	// Position of FORCE_SEL field.
	PWM_SM3CTRL2_FORCE_SEL_Pos = 0x3
	// Bit mask of FORCE_SEL field.
	PWM_SM3CTRL2_FORCE_SEL_Msk = 0x38
	// The local force signal, CTRL2[FORCE], from this submodule is used to force updates.
	PWM_SM3CTRL2_FORCE_SEL_FORCE_SEL_0 = 0x0
	// The master force signal from submodule 0 is used to force updates. This setting should not be used in submodule 0 as it will hold the FORCE OUTPUT signal to logic 0.
	PWM_SM3CTRL2_FORCE_SEL_FORCE_SEL_1 = 0x1
	// The local reload signal from this submodule is used to force updates without regard to the state of LDOK.
	PWM_SM3CTRL2_FORCE_SEL_FORCE_SEL_2 = 0x2
	// The master reload signal from submodule0 is used to force updates if LDOK is set. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	PWM_SM3CTRL2_FORCE_SEL_FORCE_SEL_3 = 0x3
	// The local sync signal from this submodule is used to force updates.
	PWM_SM3CTRL2_FORCE_SEL_FORCE_SEL_4 = 0x4
	// The master sync signal from submodule0 is used to force updates. This setting should not be used in submodule0 as it will hold the FORCE OUTPUT signal to logic 0.
	PWM_SM3CTRL2_FORCE_SEL_FORCE_SEL_5 = 0x5
	// The external force signal, EXT_FORCE, from outside the PWM module causes updates.
	PWM_SM3CTRL2_FORCE_SEL_FORCE_SEL_6 = 0x6
	// The external sync signal, EXT_SYNC, from outside the PWM module causes updates.
	PWM_SM3CTRL2_FORCE_SEL_FORCE_SEL_7 = 0x7
	// Position of FORCE field.
	PWM_SM3CTRL2_FORCE_Pos = 0x6
	// Bit mask of FORCE field.
	PWM_SM3CTRL2_FORCE_Msk = 0x40
	// Bit FORCE.
	PWM_SM3CTRL2_FORCE = 0x40
	// Position of FRCEN field.
	PWM_SM3CTRL2_FRCEN_Pos = 0x7
	// Bit mask of FRCEN field.
	PWM_SM3CTRL2_FRCEN_Msk = 0x80
	// Bit FRCEN.
	PWM_SM3CTRL2_FRCEN = 0x80
	// Initialization from a FORCE_OUT is disabled.
	PWM_SM3CTRL2_FRCEN_FRCEN_0 = 0x0
	// Initialization from a FORCE_OUT is enabled.
	PWM_SM3CTRL2_FRCEN_FRCEN_1 = 0x1
	// Position of INIT_SEL field.
	PWM_SM3CTRL2_INIT_SEL_Pos = 0x8
	// Bit mask of INIT_SEL field.
	PWM_SM3CTRL2_INIT_SEL_Msk = 0x300
	// Local sync (PWM_X) causes initialization.
	PWM_SM3CTRL2_INIT_SEL_INIT_SEL_0 = 0x0
	// Master reload from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0. The submodule counter will only reinitialize when a master reload occurs.
	PWM_SM3CTRL2_INIT_SEL_INIT_SEL_1 = 0x1
	// Master sync from submodule 0 causes initialization. This setting should not be used in submodule 0 as it will force the INIT signal to logic 0.
	PWM_SM3CTRL2_INIT_SEL_INIT_SEL_2 = 0x2
	// EXT_SYNC causes initialization.
	PWM_SM3CTRL2_INIT_SEL_INIT_SEL_3 = 0x3
	// Position of PWMX_INIT field.
	PWM_SM3CTRL2_PWMX_INIT_Pos = 0xa
	// Bit mask of PWMX_INIT field.
	PWM_SM3CTRL2_PWMX_INIT_Msk = 0x400
	// Bit PWMX_INIT.
	PWM_SM3CTRL2_PWMX_INIT = 0x400
	// Position of PWM45_INIT field.
	PWM_SM3CTRL2_PWM45_INIT_Pos = 0xb
	// Bit mask of PWM45_INIT field.
	PWM_SM3CTRL2_PWM45_INIT_Msk = 0x800
	// Bit PWM45_INIT.
	PWM_SM3CTRL2_PWM45_INIT = 0x800
	// Position of PWM23_INIT field.
	PWM_SM3CTRL2_PWM23_INIT_Pos = 0xc
	// Bit mask of PWM23_INIT field.
	PWM_SM3CTRL2_PWM23_INIT_Msk = 0x1000
	// Bit PWM23_INIT.
	PWM_SM3CTRL2_PWM23_INIT = 0x1000
	// Position of INDEP field.
	PWM_SM3CTRL2_INDEP_Pos = 0xd
	// Bit mask of INDEP field.
	PWM_SM3CTRL2_INDEP_Msk = 0x2000
	// Bit INDEP.
	PWM_SM3CTRL2_INDEP = 0x2000
	// PWM_A and PWM_B form a complementary PWM pair.
	PWM_SM3CTRL2_INDEP_INDEP_0 = 0x0
	// PWM_A and PWM_B outputs are independent PWMs.
	PWM_SM3CTRL2_INDEP_INDEP_1 = 0x1
	// Position of WAITEN field.
	PWM_SM3CTRL2_WAITEN_Pos = 0xe
	// Bit mask of WAITEN field.
	PWM_SM3CTRL2_WAITEN_Msk = 0x4000
	// Bit WAITEN.
	PWM_SM3CTRL2_WAITEN = 0x4000
	// Position of DBGEN field.
	PWM_SM3CTRL2_DBGEN_Pos = 0xf
	// Bit mask of DBGEN field.
	PWM_SM3CTRL2_DBGEN_Msk = 0x8000
	// Bit DBGEN.
	PWM_SM3CTRL2_DBGEN = 0x8000

	// SM3CTRL: Control Register
	// Position of DBLEN field.
	PWM_SM3CTRL_DBLEN_Pos = 0x0
	// Bit mask of DBLEN field.
	PWM_SM3CTRL_DBLEN_Msk = 0x1
	// Bit DBLEN.
	PWM_SM3CTRL_DBLEN = 0x1
	// Double switching disabled.
	PWM_SM3CTRL_DBLEN_DBLEN_0 = 0x0
	// Double switching enabled.
	PWM_SM3CTRL_DBLEN_DBLEN_1 = 0x1
	// Position of DBLX field.
	PWM_SM3CTRL_DBLX_Pos = 0x1
	// Bit mask of DBLX field.
	PWM_SM3CTRL_DBLX_Msk = 0x2
	// Bit DBLX.
	PWM_SM3CTRL_DBLX = 0x2
	// PWMX double pulse disabled.
	PWM_SM3CTRL_DBLX_DBLX_0 = 0x0
	// PWMX double pulse enabled.
	PWM_SM3CTRL_DBLX_DBLX_1 = 0x1
	// Position of LDMOD field.
	PWM_SM3CTRL_LDMOD_Pos = 0x2
	// Bit mask of LDMOD field.
	PWM_SM3CTRL_LDMOD_Msk = 0x4
	// Bit LDMOD.
	PWM_SM3CTRL_LDMOD = 0x4
	// Buffered registers of this submodule are loaded and take effect at the next PWM reload if MCTRL[LDOK] is set.
	PWM_SM3CTRL_LDMOD_LDMOD_0 = 0x0
	// Buffered registers of this submodule are loaded and take effect immediately upon MCTRL[LDOK] being set. In this case it is not necessary to set CTRL[FULL] or CTRL[HALF].
	PWM_SM3CTRL_LDMOD_LDMOD_1 = 0x1
	// Position of SPLIT field.
	PWM_SM3CTRL_SPLIT_Pos = 0x3
	// Bit mask of SPLIT field.
	PWM_SM3CTRL_SPLIT_Msk = 0x8
	// Bit SPLIT.
	PWM_SM3CTRL_SPLIT = 0x8
	// DBLPWM is not split. PWMA and PWMB each have double pulses.
	PWM_SM3CTRL_SPLIT_SPLIT_0 = 0x0
	// DBLPWM is split to PWMA and PWMB.
	PWM_SM3CTRL_SPLIT_SPLIT_1 = 0x1
	// Position of PRSC field.
	PWM_SM3CTRL_PRSC_Pos = 0x4
	// Bit mask of PRSC field.
	PWM_SM3CTRL_PRSC_Msk = 0x70
	// PWM clock frequency = fclk
	PWM_SM3CTRL_PRSC_PRSC_0 = 0x0
	// PWM clock frequency = fclk/2
	PWM_SM3CTRL_PRSC_PRSC_1 = 0x1
	// PWM clock frequency = fclk/4
	PWM_SM3CTRL_PRSC_PRSC_2 = 0x2
	// PWM clock frequency = fclk/8
	PWM_SM3CTRL_PRSC_PRSC_3 = 0x3
	// PWM clock frequency = fclk/16
	PWM_SM3CTRL_PRSC_PRSC_4 = 0x4
	// PWM clock frequency = fclk/32
	PWM_SM3CTRL_PRSC_PRSC_5 = 0x5
	// PWM clock frequency = fclk/64
	PWM_SM3CTRL_PRSC_PRSC_6 = 0x6
	// PWM clock frequency = fclk/128
	PWM_SM3CTRL_PRSC_PRSC_7 = 0x7
	// Position of COMPMODE field.
	PWM_SM3CTRL_COMPMODE_Pos = 0x7
	// Bit mask of COMPMODE field.
	PWM_SM3CTRL_COMPMODE_Msk = 0x80
	// Bit COMPMODE.
	PWM_SM3CTRL_COMPMODE = 0x80
	// The VAL* registers and the PWM counter are compared using an "equal to" method. This means that PWM edges are only produced when the counter is equal to one of the VAL* register values. This implies that a PWMA output that is high at the end of a period will maintain this state until a match with VAL3 clears the output in the following period.
	PWM_SM3CTRL_COMPMODE_COMPMODE_0 = 0x0
	// The VAL* registers and the PWM counter are compared using an "equal to or greater than" method. This means that PWM edges are produced when the counter is equal to or greater than one of the VAL* register values. This implies that a PWMA output that is high at the end of a period could go low at the start of the next period if the starting counter value is greater than (but not necessarily equal to) the new VAL3 value.
	PWM_SM3CTRL_COMPMODE_COMPMODE_1 = 0x1
	// Position of DT field.
	PWM_SM3CTRL_DT_Pos = 0x8
	// Bit mask of DT field.
	PWM_SM3CTRL_DT_Msk = 0x300
	// Position of FULL field.
	PWM_SM3CTRL_FULL_Pos = 0xa
	// Bit mask of FULL field.
	PWM_SM3CTRL_FULL_Msk = 0x400
	// Bit FULL.
	PWM_SM3CTRL_FULL = 0x400
	// Full-cycle reloads disabled.
	PWM_SM3CTRL_FULL_FULL_0 = 0x0
	// Full-cycle reloads enabled.
	PWM_SM3CTRL_FULL_FULL_1 = 0x1
	// Position of HALF field.
	PWM_SM3CTRL_HALF_Pos = 0xb
	// Bit mask of HALF field.
	PWM_SM3CTRL_HALF_Msk = 0x800
	// Bit HALF.
	PWM_SM3CTRL_HALF = 0x800
	// Half-cycle reloads disabled.
	PWM_SM3CTRL_HALF_HALF_0 = 0x0
	// Half-cycle reloads enabled.
	PWM_SM3CTRL_HALF_HALF_1 = 0x1
	// Position of LDFQ field.
	PWM_SM3CTRL_LDFQ_Pos = 0xc
	// Bit mask of LDFQ field.
	PWM_SM3CTRL_LDFQ_Msk = 0xf000
	// Every PWM opportunity
	PWM_SM3CTRL_LDFQ_LDFQ_0 = 0x0
	// Every 2 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_1 = 0x1
	// Every 3 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_2 = 0x2
	// Every 4 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_3 = 0x3
	// Every 5 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_4 = 0x4
	// Every 6 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_5 = 0x5
	// Every 7 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_6 = 0x6
	// Every 8 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_7 = 0x7
	// Every 9 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_8 = 0x8
	// Every 10 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_9 = 0x9
	// Every 11 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_10 = 0xa
	// Every 12 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_11 = 0xb
	// Every 13 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_12 = 0xc
	// Every 14 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_13 = 0xd
	// Every 15 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_14 = 0xe
	// Every 16 PWM opportunities
	PWM_SM3CTRL_LDFQ_LDFQ_15 = 0xf

	// SM3VAL0: Value Register 0
	// Position of VAL0 field.
	PWM_SM3VAL0_VAL0_Pos = 0x0
	// Bit mask of VAL0 field.
	PWM_SM3VAL0_VAL0_Msk = 0xffff

	// SM3FRACVAL1: Fractional Value Register 1
	// Position of FRACVAL1 field.
	PWM_SM3FRACVAL1_FRACVAL1_Pos = 0xb
	// Bit mask of FRACVAL1 field.
	PWM_SM3FRACVAL1_FRACVAL1_Msk = 0xf800

	// SM3VAL1: Value Register 1
	// Position of VAL1 field.
	PWM_SM3VAL1_VAL1_Pos = 0x0
	// Bit mask of VAL1 field.
	PWM_SM3VAL1_VAL1_Msk = 0xffff

	// SM3FRACVAL2: Fractional Value Register 2
	// Position of FRACVAL2 field.
	PWM_SM3FRACVAL2_FRACVAL2_Pos = 0xb
	// Bit mask of FRACVAL2 field.
	PWM_SM3FRACVAL2_FRACVAL2_Msk = 0xf800

	// SM3VAL2: Value Register 2
	// Position of VAL2 field.
	PWM_SM3VAL2_VAL2_Pos = 0x0
	// Bit mask of VAL2 field.
	PWM_SM3VAL2_VAL2_Msk = 0xffff

	// SM3FRACVAL3: Fractional Value Register 3
	// Position of FRACVAL3 field.
	PWM_SM3FRACVAL3_FRACVAL3_Pos = 0xb
	// Bit mask of FRACVAL3 field.
	PWM_SM3FRACVAL3_FRACVAL3_Msk = 0xf800

	// SM3VAL3: Value Register 3
	// Position of VAL3 field.
	PWM_SM3VAL3_VAL3_Pos = 0x0
	// Bit mask of VAL3 field.
	PWM_SM3VAL3_VAL3_Msk = 0xffff

	// SM3FRACVAL4: Fractional Value Register 4
	// Position of FRACVAL4 field.
	PWM_SM3FRACVAL4_FRACVAL4_Pos = 0xb
	// Bit mask of FRACVAL4 field.
	PWM_SM3FRACVAL4_FRACVAL4_Msk = 0xf800

	// SM3VAL4: Value Register 4
	// Position of VAL4 field.
	PWM_SM3VAL4_VAL4_Pos = 0x0
	// Bit mask of VAL4 field.
	PWM_SM3VAL4_VAL4_Msk = 0xffff

	// SM3FRACVAL5: Fractional Value Register 5
	// Position of FRACVAL5 field.
	PWM_SM3FRACVAL5_FRACVAL5_Pos = 0xb
	// Bit mask of FRACVAL5 field.
	PWM_SM3FRACVAL5_FRACVAL5_Msk = 0xf800

	// SM3VAL5: Value Register 5
	// Position of VAL5 field.
	PWM_SM3VAL5_VAL5_Pos = 0x0
	// Bit mask of VAL5 field.
	PWM_SM3VAL5_VAL5_Msk = 0xffff

	// SM3FRCTRL: Fractional Control Register
	// Position of FRAC1_EN field.
	PWM_SM3FRCTRL_FRAC1_EN_Pos = 0x1
	// Bit mask of FRAC1_EN field.
	PWM_SM3FRCTRL_FRAC1_EN_Msk = 0x2
	// Bit FRAC1_EN.
	PWM_SM3FRCTRL_FRAC1_EN = 0x2
	// Disable fractional cycle length for the PWM period.
	PWM_SM3FRCTRL_FRAC1_EN_FRAC1_EN_0 = 0x0
	// Enable fractional cycle length for the PWM period.
	PWM_SM3FRCTRL_FRAC1_EN_FRAC1_EN_1 = 0x1
	// Position of FRAC23_EN field.
	PWM_SM3FRCTRL_FRAC23_EN_Pos = 0x2
	// Bit mask of FRAC23_EN field.
	PWM_SM3FRCTRL_FRAC23_EN_Msk = 0x4
	// Bit FRAC23_EN.
	PWM_SM3FRCTRL_FRAC23_EN = 0x4
	// Disable fractional cycle placement for PWM_A.
	PWM_SM3FRCTRL_FRAC23_EN_FRAC23_EN_0 = 0x0
	// Enable fractional cycle placement for PWM_A.
	PWM_SM3FRCTRL_FRAC23_EN_FRAC23_EN_1 = 0x1
	// Position of FRAC45_EN field.
	PWM_SM3FRCTRL_FRAC45_EN_Pos = 0x4
	// Bit mask of FRAC45_EN field.
	PWM_SM3FRCTRL_FRAC45_EN_Msk = 0x10
	// Bit FRAC45_EN.
	PWM_SM3FRCTRL_FRAC45_EN = 0x10
	// Disable fractional cycle placement for PWM_B.
	PWM_SM3FRCTRL_FRAC45_EN_FRAC45_EN_0 = 0x0
	// Enable fractional cycle placement for PWM_B.
	PWM_SM3FRCTRL_FRAC45_EN_FRAC45_EN_1 = 0x1
	// Position of FRAC_PU field.
	PWM_SM3FRCTRL_FRAC_PU_Pos = 0x8
	// Bit mask of FRAC_PU field.
	PWM_SM3FRCTRL_FRAC_PU_Msk = 0x100
	// Bit FRAC_PU.
	PWM_SM3FRCTRL_FRAC_PU = 0x100
	// Turn off fractional delay logic.
	PWM_SM3FRCTRL_FRAC_PU_FRAC_PU_0 = 0x0
	// Power up fractional delay logic.
	PWM_SM3FRCTRL_FRAC_PU_FRAC_PU_1 = 0x1
	// Position of TEST field.
	PWM_SM3FRCTRL_TEST_Pos = 0xf
	// Bit mask of TEST field.
	PWM_SM3FRCTRL_TEST_Msk = 0x8000
	// Bit TEST.
	PWM_SM3FRCTRL_TEST = 0x8000

	// SM3OCTRL: Output Control Register
	// Position of PWMXFS field.
	PWM_SM3OCTRL_PWMXFS_Pos = 0x0
	// Bit mask of PWMXFS field.
	PWM_SM3OCTRL_PWMXFS_Msk = 0x3
	// Output is forced to logic 0 state prior to consideration of output polarity control.
	PWM_SM3OCTRL_PWMXFS_PWMXFS_0 = 0x0
	// Output is forced to logic 1 state prior to consideration of output polarity control.
	PWM_SM3OCTRL_PWMXFS_PWMXFS_1 = 0x1
	// Output is tristated.
	PWM_SM3OCTRL_PWMXFS_PWMXFS_2 = 0x2
	// Output is tristated.
	PWM_SM3OCTRL_PWMXFS_PWMXFS_3 = 0x3
	// Position of PWMBFS field.
	PWM_SM3OCTRL_PWMBFS_Pos = 0x2
	// Bit mask of PWMBFS field.
	PWM_SM3OCTRL_PWMBFS_Msk = 0xc
	// Output is forced to logic 0 state prior to consideration of output polarity control.
	PWM_SM3OCTRL_PWMBFS_PWMBFS_0 = 0x0
	// Output is forced to logic 1 state prior to consideration of output polarity control.
	PWM_SM3OCTRL_PWMBFS_PWMBFS_1 = 0x1
	// Output is tristated.
	PWM_SM3OCTRL_PWMBFS_PWMBFS_2 = 0x2
	// Output is tristated.
	PWM_SM3OCTRL_PWMBFS_PWMBFS_3 = 0x3
	// Position of PWMAFS field.
	PWM_SM3OCTRL_PWMAFS_Pos = 0x4
	// Bit mask of PWMAFS field.
	PWM_SM3OCTRL_PWMAFS_Msk = 0x30
	// Output is forced to logic 0 state prior to consideration of output polarity control.
	PWM_SM3OCTRL_PWMAFS_PWMAFS_0 = 0x0
	// Output is forced to logic 1 state prior to consideration of output polarity control.
	PWM_SM3OCTRL_PWMAFS_PWMAFS_1 = 0x1
	// Output is tristated.
	PWM_SM3OCTRL_PWMAFS_PWMAFS_2 = 0x2
	// Output is tristated.
	PWM_SM3OCTRL_PWMAFS_PWMAFS_3 = 0x3
	// Position of POLX field.
	PWM_SM3OCTRL_POLX_Pos = 0x8
	// Bit mask of POLX field.
	PWM_SM3OCTRL_POLX_Msk = 0x100
	// Bit POLX.
	PWM_SM3OCTRL_POLX = 0x100
	// PWM_X output not inverted. A high level on the PWM_X pin represents the "on" or "active" state.
	PWM_SM3OCTRL_POLX_POLX_0 = 0x0
	// PWM_X output inverted. A low level on the PWM_X pin represents the "on" or "active" state.
	PWM_SM3OCTRL_POLX_POLX_1 = 0x1
	// Position of POLB field.
	PWM_SM3OCTRL_POLB_Pos = 0x9
	// Bit mask of POLB field.
	PWM_SM3OCTRL_POLB_Msk = 0x200
	// Bit POLB.
	PWM_SM3OCTRL_POLB = 0x200
	// PWM_B output not inverted. A high level on the PWM_B pin represents the "on" or "active" state.
	PWM_SM3OCTRL_POLB_POLB_0 = 0x0
	// PWM_B output inverted. A low level on the PWM_B pin represents the "on" or "active" state.
	PWM_SM3OCTRL_POLB_POLB_1 = 0x1
	// Position of POLA field.
	PWM_SM3OCTRL_POLA_Pos = 0xa
	// Bit mask of POLA field.
	PWM_SM3OCTRL_POLA_Msk = 0x400
	// Bit POLA.
	PWM_SM3OCTRL_POLA = 0x400
	// PWM_A output not inverted. A high level on the PWM_A pin represents the "on" or "active" state.
	PWM_SM3OCTRL_POLA_POLA_0 = 0x0
	// PWM_A output inverted. A low level on the PWM_A pin represents the "on" or "active" state.
	PWM_SM3OCTRL_POLA_POLA_1 = 0x1
	// Position of PWMX_IN field.
	PWM_SM3OCTRL_PWMX_IN_Pos = 0xd
	// Bit mask of PWMX_IN field.
	PWM_SM3OCTRL_PWMX_IN_Msk = 0x2000
	// Bit PWMX_IN.
	PWM_SM3OCTRL_PWMX_IN = 0x2000
	// Position of PWMB_IN field.
	PWM_SM3OCTRL_PWMB_IN_Pos = 0xe
	// Bit mask of PWMB_IN field.
	PWM_SM3OCTRL_PWMB_IN_Msk = 0x4000
	// Bit PWMB_IN.
	PWM_SM3OCTRL_PWMB_IN = 0x4000
	// Position of PWMA_IN field.
	PWM_SM3OCTRL_PWMA_IN_Pos = 0xf
	// Bit mask of PWMA_IN field.
	PWM_SM3OCTRL_PWMA_IN_Msk = 0x8000
	// Bit PWMA_IN.
	PWM_SM3OCTRL_PWMA_IN = 0x8000

	// SM3STS: Status Register
	// Position of CMPF field.
	PWM_SM3STS_CMPF_Pos = 0x0
	// Bit mask of CMPF field.
	PWM_SM3STS_CMPF_Msk = 0x3f
	// No compare event has occurred for a particular VALx value.
	PWM_SM3STS_CMPF_CMPF_0 = 0x0
	// A compare event has occurred for a particular VALx value.
	PWM_SM3STS_CMPF_CMPF_1 = 0x1
	// Position of CFX0 field.
	PWM_SM3STS_CFX0_Pos = 0x6
	// Bit mask of CFX0 field.
	PWM_SM3STS_CFX0_Msk = 0x40
	// Bit CFX0.
	PWM_SM3STS_CFX0 = 0x40
	// Position of CFX1 field.
	PWM_SM3STS_CFX1_Pos = 0x7
	// Bit mask of CFX1 field.
	PWM_SM3STS_CFX1_Msk = 0x80
	// Bit CFX1.
	PWM_SM3STS_CFX1 = 0x80
	// Position of CFB0 field.
	PWM_SM3STS_CFB0_Pos = 0x8
	// Bit mask of CFB0 field.
	PWM_SM3STS_CFB0_Msk = 0x100
	// Bit CFB0.
	PWM_SM3STS_CFB0 = 0x100
	// Position of CFB1 field.
	PWM_SM3STS_CFB1_Pos = 0x9
	// Bit mask of CFB1 field.
	PWM_SM3STS_CFB1_Msk = 0x200
	// Bit CFB1.
	PWM_SM3STS_CFB1 = 0x200
	// Position of CFA0 field.
	PWM_SM3STS_CFA0_Pos = 0xa
	// Bit mask of CFA0 field.
	PWM_SM3STS_CFA0_Msk = 0x400
	// Bit CFA0.
	PWM_SM3STS_CFA0 = 0x400
	// Position of CFA1 field.
	PWM_SM3STS_CFA1_Pos = 0xb
	// Bit mask of CFA1 field.
	PWM_SM3STS_CFA1_Msk = 0x800
	// Bit CFA1.
	PWM_SM3STS_CFA1 = 0x800
	// Position of RF field.
	PWM_SM3STS_RF_Pos = 0xc
	// Bit mask of RF field.
	PWM_SM3STS_RF_Msk = 0x1000
	// Bit RF.
	PWM_SM3STS_RF = 0x1000
	// No new reload cycle since last STS[RF] clearing
	PWM_SM3STS_RF_RF_0 = 0x0
	// New reload cycle since last STS[RF] clearing
	PWM_SM3STS_RF_RF_1 = 0x1
	// Position of REF field.
	PWM_SM3STS_REF_Pos = 0xd
	// Bit mask of REF field.
	PWM_SM3STS_REF_Msk = 0x2000
	// Bit REF.
	PWM_SM3STS_REF = 0x2000
	// No reload error occurred.
	PWM_SM3STS_REF_REF_0 = 0x0
	// Reload signal occurred with non-coherent data and MCTRL[LDOK] = 0.
	PWM_SM3STS_REF_REF_1 = 0x1
	// Position of RUF field.
	PWM_SM3STS_RUF_Pos = 0xe
	// Bit mask of RUF field.
	PWM_SM3STS_RUF_Msk = 0x4000
	// Bit RUF.
	PWM_SM3STS_RUF = 0x4000
	// No register update has occurred since last reload.
	PWM_SM3STS_RUF_RUF_0 = 0x0
	// At least one of the double buffered registers has been updated since the last reload.
	PWM_SM3STS_RUF_RUF_1 = 0x1

	// SM3INTEN: Interrupt Enable Register
	// Position of CMPIE field.
	PWM_SM3INTEN_CMPIE_Pos = 0x0
	// Bit mask of CMPIE field.
	PWM_SM3INTEN_CMPIE_Msk = 0x3f
	// The corresponding STS[CMPF] bit will not cause an interrupt request.
	PWM_SM3INTEN_CMPIE_CMPIE_0 = 0x0
	// The corresponding STS[CMPF] bit will cause an interrupt request.
	PWM_SM3INTEN_CMPIE_CMPIE_1 = 0x1
	// Position of CX0IE field.
	PWM_SM3INTEN_CX0IE_Pos = 0x6
	// Bit mask of CX0IE field.
	PWM_SM3INTEN_CX0IE_Msk = 0x40
	// Bit CX0IE.
	PWM_SM3INTEN_CX0IE = 0x40
	// Interrupt request disabled for STS[CFX0].
	PWM_SM3INTEN_CX0IE_CX0IE_0 = 0x0
	// Interrupt request enabled for STS[CFX0].
	PWM_SM3INTEN_CX0IE_CX0IE_1 = 0x1
	// Position of CX1IE field.
	PWM_SM3INTEN_CX1IE_Pos = 0x7
	// Bit mask of CX1IE field.
	PWM_SM3INTEN_CX1IE_Msk = 0x80
	// Bit CX1IE.
	PWM_SM3INTEN_CX1IE = 0x80
	// Interrupt request disabled for STS[CFX1].
	PWM_SM3INTEN_CX1IE_CX1IE_0 = 0x0
	// Interrupt request enabled for STS[CFX1].
	PWM_SM3INTEN_CX1IE_CX1IE_1 = 0x1
	// Position of CB0IE field.
	PWM_SM3INTEN_CB0IE_Pos = 0x8
	// Bit mask of CB0IE field.
	PWM_SM3INTEN_CB0IE_Msk = 0x100
	// Bit CB0IE.
	PWM_SM3INTEN_CB0IE = 0x100
	// Interrupt request disabled for STS[CFB0].
	PWM_SM3INTEN_CB0IE_CB0IE_0 = 0x0
	// Interrupt request enabled for STS[CFB0].
	PWM_SM3INTEN_CB0IE_CB0IE_1 = 0x1
	// Position of CB1IE field.
	PWM_SM3INTEN_CB1IE_Pos = 0x9
	// Bit mask of CB1IE field.
	PWM_SM3INTEN_CB1IE_Msk = 0x200
	// Bit CB1IE.
	PWM_SM3INTEN_CB1IE = 0x200
	// Interrupt request disabled for STS[CFB1].
	PWM_SM3INTEN_CB1IE_CB1IE_0 = 0x0
	// Interrupt request enabled for STS[CFB1].
	PWM_SM3INTEN_CB1IE_CB1IE_1 = 0x1
	// Position of CA0IE field.
	PWM_SM3INTEN_CA0IE_Pos = 0xa
	// Bit mask of CA0IE field.
	PWM_SM3INTEN_CA0IE_Msk = 0x400
	// Bit CA0IE.
	PWM_SM3INTEN_CA0IE = 0x400
	// Interrupt request disabled for STS[CFA0].
	PWM_SM3INTEN_CA0IE_CA0IE_0 = 0x0
	// Interrupt request enabled for STS[CFA0].
	PWM_SM3INTEN_CA0IE_CA0IE_1 = 0x1
	// Position of CA1IE field.
	PWM_SM3INTEN_CA1IE_Pos = 0xb
	// Bit mask of CA1IE field.
	PWM_SM3INTEN_CA1IE_Msk = 0x800
	// Bit CA1IE.
	PWM_SM3INTEN_CA1IE = 0x800
	// Interrupt request disabled for STS[CFA1].
	PWM_SM3INTEN_CA1IE_CA1IE_0 = 0x0
	// Interrupt request enabled for STS[CFA1].
	PWM_SM3INTEN_CA1IE_CA1IE_1 = 0x1
	// Position of RIE field.
	PWM_SM3INTEN_RIE_Pos = 0xc
	// Bit mask of RIE field.
	PWM_SM3INTEN_RIE_Msk = 0x1000
	// Bit RIE.
	PWM_SM3INTEN_RIE = 0x1000
	// STS[RF] CPU interrupt requests disabled
	PWM_SM3INTEN_RIE_RIE_0 = 0x0
	// STS[RF] CPU interrupt requests enabled
	PWM_SM3INTEN_RIE_RIE_1 = 0x1
	// Position of REIE field.
	PWM_SM3INTEN_REIE_Pos = 0xd
	// Bit mask of REIE field.
	PWM_SM3INTEN_REIE_Msk = 0x2000
	// Bit REIE.
	PWM_SM3INTEN_REIE = 0x2000
	// STS[REF] CPU interrupt requests disabled
	PWM_SM3INTEN_REIE_REIE_0 = 0x0
	// STS[REF] CPU interrupt requests enabled
	PWM_SM3INTEN_REIE_REIE_1 = 0x1

	// SM3DMAEN: DMA Enable Register
	// Position of CX0DE field.
	PWM_SM3DMAEN_CX0DE_Pos = 0x0
	// Bit mask of CX0DE field.
	PWM_SM3DMAEN_CX0DE_Msk = 0x1
	// Bit CX0DE.
	PWM_SM3DMAEN_CX0DE = 0x1
	// Position of CX1DE field.
	PWM_SM3DMAEN_CX1DE_Pos = 0x1
	// Bit mask of CX1DE field.
	PWM_SM3DMAEN_CX1DE_Msk = 0x2
	// Bit CX1DE.
	PWM_SM3DMAEN_CX1DE = 0x2
	// Position of CB0DE field.
	PWM_SM3DMAEN_CB0DE_Pos = 0x2
	// Bit mask of CB0DE field.
	PWM_SM3DMAEN_CB0DE_Msk = 0x4
	// Bit CB0DE.
	PWM_SM3DMAEN_CB0DE = 0x4
	// Position of CB1DE field.
	PWM_SM3DMAEN_CB1DE_Pos = 0x3
	// Bit mask of CB1DE field.
	PWM_SM3DMAEN_CB1DE_Msk = 0x8
	// Bit CB1DE.
	PWM_SM3DMAEN_CB1DE = 0x8
	// Position of CA0DE field.
	PWM_SM3DMAEN_CA0DE_Pos = 0x4
	// Bit mask of CA0DE field.
	PWM_SM3DMAEN_CA0DE_Msk = 0x10
	// Bit CA0DE.
	PWM_SM3DMAEN_CA0DE = 0x10
	// Position of CA1DE field.
	PWM_SM3DMAEN_CA1DE_Pos = 0x5
	// Bit mask of CA1DE field.
	PWM_SM3DMAEN_CA1DE_Msk = 0x20
	// Bit CA1DE.
	PWM_SM3DMAEN_CA1DE = 0x20
	// Position of CAPTDE field.
	PWM_SM3DMAEN_CAPTDE_Pos = 0x6
	// Bit mask of CAPTDE field.
	PWM_SM3DMAEN_CAPTDE_Msk = 0xc0
	// Read DMA requests disabled.
	PWM_SM3DMAEN_CAPTDE_CAPTDE_0 = 0x0
	// Exceeding a FIFO watermark sets the DMA read request. This requires at least one of DMAEN[CA1DE], DMAEN[CA0DE], DMAEN[CB1DE], DMAEN[CB0DE], DMAEN[CX1DE], or DMAEN[CX0DE] to also be set in order to determine to which watermark(s) the DMA request is sensitive.
	PWM_SM3DMAEN_CAPTDE_CAPTDE_1 = 0x1
	// A local sync (VAL1 matches counter) sets the read DMA request.
	PWM_SM3DMAEN_CAPTDE_CAPTDE_2 = 0x2
	// A local reload (STS[RF] being set) sets the read DMA request.
	PWM_SM3DMAEN_CAPTDE_CAPTDE_3 = 0x3
	// Position of FAND field.
	PWM_SM3DMAEN_FAND_Pos = 0x8
	// Bit mask of FAND field.
	PWM_SM3DMAEN_FAND_Msk = 0x100
	// Bit FAND.
	PWM_SM3DMAEN_FAND = 0x100
	// Selected FIFO watermarks are OR'ed together.
	PWM_SM3DMAEN_FAND_FAND_0 = 0x0
	// Selected FIFO watermarks are AND'ed together.
	PWM_SM3DMAEN_FAND_FAND_1 = 0x1
	// Position of VALDE field.
	PWM_SM3DMAEN_VALDE_Pos = 0x9
	// Bit mask of VALDE field.
	PWM_SM3DMAEN_VALDE_Msk = 0x200
	// Bit VALDE.
	PWM_SM3DMAEN_VALDE = 0x200
	// DMA write requests disabled
	PWM_SM3DMAEN_VALDE_VALDE_0 = 0x0
	// DMA write requests for the VALx and FRACVALx registers enabled
	PWM_SM3DMAEN_VALDE_VALDE_1 = 0x1

	// SM3TCTRL: Output Trigger Control Register
	// Position of OUT_TRIG_EN field.
	PWM_SM3TCTRL_OUT_TRIG_EN_Pos = 0x0
	// Bit mask of OUT_TRIG_EN field.
	PWM_SM3TCTRL_OUT_TRIG_EN_Msk = 0x3f
	// PWM_OUT_TRIGx will not set when the counter value matches the VALx value.
	PWM_SM3TCTRL_OUT_TRIG_EN_OUT_TRIG_EN_0 = 0x0
	// PWM_OUT_TRIGx will set when the counter value matches the VALx value.
	PWM_SM3TCTRL_OUT_TRIG_EN_OUT_TRIG_EN_1 = 0x1
	// Position of TRGFRQ field.
	PWM_SM3TCTRL_TRGFRQ_Pos = 0xc
	// Bit mask of TRGFRQ field.
	PWM_SM3TCTRL_TRGFRQ_Msk = 0x1000
	// Bit TRGFRQ.
	PWM_SM3TCTRL_TRGFRQ = 0x1000
	// Trigger outputs are generated during every PWM period even if the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
	PWM_SM3TCTRL_TRGFRQ_TRGFRQ_0 = 0x0
	// Trigger outputs are generated only during the final PWM period prior to a reload opportunity when the PWM is not reloaded every period due to CTRL[LDFQ] being non-zero.
	PWM_SM3TCTRL_TRGFRQ_TRGFRQ_1 = 0x1
	// Position of PWBOT1 field.
	PWM_SM3TCTRL_PWBOT1_Pos = 0xe
	// Bit mask of PWBOT1 field.
	PWM_SM3TCTRL_PWBOT1_Msk = 0x4000
	// Bit PWBOT1.
	PWM_SM3TCTRL_PWBOT1 = 0x4000
	// Route the PWM_OUT_TRIG1 signal to PWM_OUT_TRIG1 port.
	PWM_SM3TCTRL_PWBOT1_PWBOT1_0 = 0x0
	// Route the PWMB output to the PWM_OUT_TRIG1 port.
	PWM_SM3TCTRL_PWBOT1_PWBOT1_1 = 0x1
	// Position of PWAOT0 field.
	PWM_SM3TCTRL_PWAOT0_Pos = 0xf
	// Bit mask of PWAOT0 field.
	PWM_SM3TCTRL_PWAOT0_Msk = 0x8000
	// Bit PWAOT0.
	PWM_SM3TCTRL_PWAOT0 = 0x8000
	// Route the PWM_OUT_TRIG0 signal to PWM_OUT_TRIG0 port.
	PWM_SM3TCTRL_PWAOT0_PWAOT0_0 = 0x0
	// Route the PWMA output to the PWM_OUT_TRIG0 port.
	PWM_SM3TCTRL_PWAOT0_PWAOT0_1 = 0x1

	// SM3DISMAP0: Fault Disable Mapping Register 0
	// Position of DIS0A field.
	PWM_SM3DISMAP0_DIS0A_Pos = 0x0
	// Bit mask of DIS0A field.
	PWM_SM3DISMAP0_DIS0A_Msk = 0xf
	// Position of DIS0B field.
	PWM_SM3DISMAP0_DIS0B_Pos = 0x4
	// Bit mask of DIS0B field.
	PWM_SM3DISMAP0_DIS0B_Msk = 0xf0
	// Position of DIS0X field.
	PWM_SM3DISMAP0_DIS0X_Pos = 0x8
	// Bit mask of DIS0X field.
	PWM_SM3DISMAP0_DIS0X_Msk = 0xf00

	// SM3DISMAP1: Fault Disable Mapping Register 1
	// Position of DIS1A field.
	PWM_SM3DISMAP1_DIS1A_Pos = 0x0
	// Bit mask of DIS1A field.
	PWM_SM3DISMAP1_DIS1A_Msk = 0xf
	// Position of DIS1B field.
	PWM_SM3DISMAP1_DIS1B_Pos = 0x4
	// Bit mask of DIS1B field.
	PWM_SM3DISMAP1_DIS1B_Msk = 0xf0
	// Position of DIS1X field.
	PWM_SM3DISMAP1_DIS1X_Pos = 0x8
	// Bit mask of DIS1X field.
	PWM_SM3DISMAP1_DIS1X_Msk = 0xf00

	// SM3DTCNT0: Deadtime Count Register 0
	// Position of DTCNT0 field.
	PWM_SM3DTCNT0_DTCNT0_Pos = 0x0
	// Bit mask of DTCNT0 field.
	PWM_SM3DTCNT0_DTCNT0_Msk = 0xffff

	// SM3DTCNT1: Deadtime Count Register 1
	// Position of DTCNT1 field.
	PWM_SM3DTCNT1_DTCNT1_Pos = 0x0
	// Bit mask of DTCNT1 field.
	PWM_SM3DTCNT1_DTCNT1_Msk = 0xffff

	// SM3CAPTCTRLA: Capture Control A Register
	// Position of ARMA field.
	PWM_SM3CAPTCTRLA_ARMA_Pos = 0x0
	// Bit mask of ARMA field.
	PWM_SM3CAPTCTRLA_ARMA_Msk = 0x1
	// Bit ARMA.
	PWM_SM3CAPTCTRLA_ARMA = 0x1
	// Input capture operation is disabled.
	PWM_SM3CAPTCTRLA_ARMA_ARMA_0 = 0x0
	// Input capture operation as specified by CAPTCTRLA[EDGAx] is enabled.
	PWM_SM3CAPTCTRLA_ARMA_ARMA_1 = 0x1
	// Position of ONESHOTA field.
	PWM_SM3CAPTCTRLA_ONESHOTA_Pos = 0x1
	// Bit mask of ONESHOTA field.
	PWM_SM3CAPTCTRLA_ONESHOTA_Msk = 0x2
	// Bit ONESHOTA.
	PWM_SM3CAPTCTRLA_ONESHOTA = 0x2
	// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	PWM_SM3CAPTCTRLA_ONESHOTA_ONESHOTA_0 = 0x0
	// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLA[ARMA] is cleared. No further captures will be performed until CAPTCTRLA[ARMA] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLA[ARMA] is then cleared.
	PWM_SM3CAPTCTRLA_ONESHOTA_ONESHOTA_1 = 0x1
	// Position of EDGA0 field.
	PWM_SM3CAPTCTRLA_EDGA0_Pos = 0x2
	// Bit mask of EDGA0 field.
	PWM_SM3CAPTCTRLA_EDGA0_Msk = 0xc
	// Disabled
	PWM_SM3CAPTCTRLA_EDGA0_EDGA0_0 = 0x0
	// Capture falling edges
	PWM_SM3CAPTCTRLA_EDGA0_EDGA0_1 = 0x1
	// Capture rising edges
	PWM_SM3CAPTCTRLA_EDGA0_EDGA0_2 = 0x2
	// Capture any edge
	PWM_SM3CAPTCTRLA_EDGA0_EDGA0_3 = 0x3
	// Position of EDGA1 field.
	PWM_SM3CAPTCTRLA_EDGA1_Pos = 0x4
	// Bit mask of EDGA1 field.
	PWM_SM3CAPTCTRLA_EDGA1_Msk = 0x30
	// Disabled
	PWM_SM3CAPTCTRLA_EDGA1_EDGA1_0 = 0x0
	// Capture falling edges
	PWM_SM3CAPTCTRLA_EDGA1_EDGA1_1 = 0x1
	// Capture rising edges
	PWM_SM3CAPTCTRLA_EDGA1_EDGA1_2 = 0x2
	// Capture any edge
	PWM_SM3CAPTCTRLA_EDGA1_EDGA1_3 = 0x3
	// Position of INP_SELA field.
	PWM_SM3CAPTCTRLA_INP_SELA_Pos = 0x6
	// Bit mask of INP_SELA field.
	PWM_SM3CAPTCTRLA_INP_SELA_Msk = 0x40
	// Bit INP_SELA.
	PWM_SM3CAPTCTRLA_INP_SELA = 0x40
	// Raw PWM_A input signal selected as source.
	PWM_SM3CAPTCTRLA_INP_SELA_INP_SELA_0 = 0x0
	// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLA[EDGA0] and CAPTCTRLA[EDGA1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRA[EDGA0] and/or CAPTCTRLA[EDGA1] fields in order to enable one or both of the capture registers.
	PWM_SM3CAPTCTRLA_INP_SELA_INP_SELA_1 = 0x1
	// Position of EDGCNTA_EN field.
	PWM_SM3CAPTCTRLA_EDGCNTA_EN_Pos = 0x7
	// Bit mask of EDGCNTA_EN field.
	PWM_SM3CAPTCTRLA_EDGCNTA_EN_Msk = 0x80
	// Bit EDGCNTA_EN.
	PWM_SM3CAPTCTRLA_EDGCNTA_EN = 0x80
	// Edge counter disabled and held in reset
	PWM_SM3CAPTCTRLA_EDGCNTA_EN_EDGCNTA_EN_0 = 0x0
	// Edge counter enabled
	PWM_SM3CAPTCTRLA_EDGCNTA_EN_EDGCNTA_EN_1 = 0x1
	// Position of CFAWM field.
	PWM_SM3CAPTCTRLA_CFAWM_Pos = 0x8
	// Bit mask of CFAWM field.
	PWM_SM3CAPTCTRLA_CFAWM_Msk = 0x300
	// Position of CA0CNT field.
	PWM_SM3CAPTCTRLA_CA0CNT_Pos = 0xa
	// Bit mask of CA0CNT field.
	PWM_SM3CAPTCTRLA_CA0CNT_Msk = 0x1c00
	// Position of CA1CNT field.
	PWM_SM3CAPTCTRLA_CA1CNT_Pos = 0xd
	// Bit mask of CA1CNT field.
	PWM_SM3CAPTCTRLA_CA1CNT_Msk = 0xe000

	// SM3CAPTCOMPA: Capture Compare A Register
	// Position of EDGCMPA field.
	PWM_SM3CAPTCOMPA_EDGCMPA_Pos = 0x0
	// Bit mask of EDGCMPA field.
	PWM_SM3CAPTCOMPA_EDGCMPA_Msk = 0xff
	// Position of EDGCNTA field.
	PWM_SM3CAPTCOMPA_EDGCNTA_Pos = 0x8
	// Bit mask of EDGCNTA field.
	PWM_SM3CAPTCOMPA_EDGCNTA_Msk = 0xff00

	// SM3CAPTCTRLB: Capture Control B Register
	// Position of ARMB field.
	PWM_SM3CAPTCTRLB_ARMB_Pos = 0x0
	// Bit mask of ARMB field.
	PWM_SM3CAPTCTRLB_ARMB_Msk = 0x1
	// Bit ARMB.
	PWM_SM3CAPTCTRLB_ARMB = 0x1
	// Input capture operation is disabled.
	PWM_SM3CAPTCTRLB_ARMB_ARMB_0 = 0x0
	// Input capture operation as specified by CAPTCTRLB[EDGBx] is enabled.
	PWM_SM3CAPTCTRLB_ARMB_ARMB_1 = 0x1
	// Position of ONESHOTB field.
	PWM_SM3CAPTCTRLB_ONESHOTB_Pos = 0x1
	// Bit mask of ONESHOTB field.
	PWM_SM3CAPTCTRLB_ONESHOTB_Msk = 0x2
	// Bit ONESHOTB.
	PWM_SM3CAPTCTRLB_ONESHOTB = 0x2
	// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	PWM_SM3CAPTCTRLB_ONESHOTB_ONESHOTB_0 = 0x0
	// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and CAPTCTRLB[ARMB] is cleared. No further captures will be performed until CAPTCTRLB[ARMB] is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and CAPTCTRLB[ARMB] is then cleared.
	PWM_SM3CAPTCTRLB_ONESHOTB_ONESHOTB_1 = 0x1
	// Position of EDGB0 field.
	PWM_SM3CAPTCTRLB_EDGB0_Pos = 0x2
	// Bit mask of EDGB0 field.
	PWM_SM3CAPTCTRLB_EDGB0_Msk = 0xc
	// Disabled
	PWM_SM3CAPTCTRLB_EDGB0_EDGB0_0 = 0x0
	// Capture falling edges
	PWM_SM3CAPTCTRLB_EDGB0_EDGB0_1 = 0x1
	// Capture rising edges
	PWM_SM3CAPTCTRLB_EDGB0_EDGB0_2 = 0x2
	// Capture any edge
	PWM_SM3CAPTCTRLB_EDGB0_EDGB0_3 = 0x3
	// Position of EDGB1 field.
	PWM_SM3CAPTCTRLB_EDGB1_Pos = 0x4
	// Bit mask of EDGB1 field.
	PWM_SM3CAPTCTRLB_EDGB1_Msk = 0x30
	// Disabled
	PWM_SM3CAPTCTRLB_EDGB1_EDGB1_0 = 0x0
	// Capture falling edges
	PWM_SM3CAPTCTRLB_EDGB1_EDGB1_1 = 0x1
	// Capture rising edges
	PWM_SM3CAPTCTRLB_EDGB1_EDGB1_2 = 0x2
	// Capture any edge
	PWM_SM3CAPTCTRLB_EDGB1_EDGB1_3 = 0x3
	// Position of INP_SELB field.
	PWM_SM3CAPTCTRLB_INP_SELB_Pos = 0x6
	// Bit mask of INP_SELB field.
	PWM_SM3CAPTCTRLB_INP_SELB_Msk = 0x40
	// Bit INP_SELB.
	PWM_SM3CAPTCTRLB_INP_SELB = 0x40
	// Raw PWM_B input signal selected as source.
	PWM_SM3CAPTCTRLB_INP_SELB_INP_SELB_0 = 0x0
	// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLB[EDGB0] and CAPTCTRLB[EDGB1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRB[EDGB0] and/or CAPTCTRLB[EDGB1] fields in order to enable one or both of the capture registers.
	PWM_SM3CAPTCTRLB_INP_SELB_INP_SELB_1 = 0x1
	// Position of EDGCNTB_EN field.
	PWM_SM3CAPTCTRLB_EDGCNTB_EN_Pos = 0x7
	// Bit mask of EDGCNTB_EN field.
	PWM_SM3CAPTCTRLB_EDGCNTB_EN_Msk = 0x80
	// Bit EDGCNTB_EN.
	PWM_SM3CAPTCTRLB_EDGCNTB_EN = 0x80
	// Edge counter disabled and held in reset
	PWM_SM3CAPTCTRLB_EDGCNTB_EN_EDGCNTB_EN_0 = 0x0
	// Edge counter enabled
	PWM_SM3CAPTCTRLB_EDGCNTB_EN_EDGCNTB_EN_1 = 0x1
	// Position of CFBWM field.
	PWM_SM3CAPTCTRLB_CFBWM_Pos = 0x8
	// Bit mask of CFBWM field.
	PWM_SM3CAPTCTRLB_CFBWM_Msk = 0x300
	// Position of CB0CNT field.
	PWM_SM3CAPTCTRLB_CB0CNT_Pos = 0xa
	// Bit mask of CB0CNT field.
	PWM_SM3CAPTCTRLB_CB0CNT_Msk = 0x1c00
	// Position of CB1CNT field.
	PWM_SM3CAPTCTRLB_CB1CNT_Pos = 0xd
	// Bit mask of CB1CNT field.
	PWM_SM3CAPTCTRLB_CB1CNT_Msk = 0xe000

	// SM3CAPTCOMPB: Capture Compare B Register
	// Position of EDGCMPB field.
	PWM_SM3CAPTCOMPB_EDGCMPB_Pos = 0x0
	// Bit mask of EDGCMPB field.
	PWM_SM3CAPTCOMPB_EDGCMPB_Msk = 0xff
	// Position of EDGCNTB field.
	PWM_SM3CAPTCOMPB_EDGCNTB_Pos = 0x8
	// Bit mask of EDGCNTB field.
	PWM_SM3CAPTCOMPB_EDGCNTB_Msk = 0xff00

	// SM3CAPTCTRLX: Capture Control X Register
	// Position of ARMX field.
	PWM_SM3CAPTCTRLX_ARMX_Pos = 0x0
	// Bit mask of ARMX field.
	PWM_SM3CAPTCTRLX_ARMX_Msk = 0x1
	// Bit ARMX.
	PWM_SM3CAPTCTRLX_ARMX = 0x1
	// Input capture operation is disabled.
	PWM_SM3CAPTCTRLX_ARMX_ARMX_0 = 0x0
	// Input capture operation as specified by CAPTCTRLX[EDGXx] is enabled.
	PWM_SM3CAPTCTRLX_ARMX_ARMX_1 = 0x1
	// Position of ONESHOTX field.
	PWM_SM3CAPTCTRLX_ONESHOTX_Pos = 0x1
	// Bit mask of ONESHOTX field.
	PWM_SM3CAPTCTRLX_ONESHOTX_Msk = 0x2
	// Bit ONESHOTX.
	PWM_SM3CAPTCTRLX_ONESHOTX = 0x2
	// Free running mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and capture circuit 0 is re-armed. The process continues indefinitely.If only one of the capture circuits is enabled, then captures continue indefinitely on the enabled capture circuit.
	PWM_SM3CAPTCTRLX_ONESHOTX_ONESHOTX_0 = 0x0
	// One shot mode is selected. If both capture circuits are enabled, then capture circuit 0 is armed first after the ARMX bit is set. Once a capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed. After capture circuit 1 performs a capture, it is disarmed and the ARMX bit is cleared. No further captures will be performed until the ARMX bit is set again.If only one of the capture circuits is enabled, then a single capture will occur on the enabled capture circuit and the ARMX bit is then cleared.
	PWM_SM3CAPTCTRLX_ONESHOTX_ONESHOTX_1 = 0x1
	// Position of EDGX0 field.
	PWM_SM3CAPTCTRLX_EDGX0_Pos = 0x2
	// Bit mask of EDGX0 field.
	PWM_SM3CAPTCTRLX_EDGX0_Msk = 0xc
	// Disabled
	PWM_SM3CAPTCTRLX_EDGX0_EDGX0_0 = 0x0
	// Capture falling edges
	PWM_SM3CAPTCTRLX_EDGX0_EDGX0_1 = 0x1
	// Capture rising edges
	PWM_SM3CAPTCTRLX_EDGX0_EDGX0_2 = 0x2
	// Capture any edge
	PWM_SM3CAPTCTRLX_EDGX0_EDGX0_3 = 0x3
	// Position of EDGX1 field.
	PWM_SM3CAPTCTRLX_EDGX1_Pos = 0x4
	// Bit mask of EDGX1 field.
	PWM_SM3CAPTCTRLX_EDGX1_Msk = 0x30
	// Disabled
	PWM_SM3CAPTCTRLX_EDGX1_EDGX1_0 = 0x0
	// Capture falling edges
	PWM_SM3CAPTCTRLX_EDGX1_EDGX1_1 = 0x1
	// Capture rising edges
	PWM_SM3CAPTCTRLX_EDGX1_EDGX1_2 = 0x2
	// Capture any edge
	PWM_SM3CAPTCTRLX_EDGX1_EDGX1_3 = 0x3
	// Position of INP_SELX field.
	PWM_SM3CAPTCTRLX_INP_SELX_Pos = 0x6
	// Bit mask of INP_SELX field.
	PWM_SM3CAPTCTRLX_INP_SELX_Msk = 0x40
	// Bit INP_SELX.
	PWM_SM3CAPTCTRLX_INP_SELX = 0x40
	// Raw PWM_X input signal selected as source.
	PWM_SM3CAPTCTRLX_INP_SELX_INP_SELX_0 = 0x0
	// Output of edge counter/compare selected as source. Note that when this bitfield is set to 1, the internal edge counter is enabled and the rising and/or falling edges specified by the CAPTCTRLX[EDGX0] and CAPTCTRLX[EDGX1] fields are ignored. The software must still place a value other than 00 in either or both of the CAPTCTLRX[EDGX0] and/or CAPTCTRLX[EDGX1] fields in order to enable one or both of the capture registers.
	PWM_SM3CAPTCTRLX_INP_SELX_INP_SELX_1 = 0x1
	// Position of EDGCNTX_EN field.
	PWM_SM3CAPTCTRLX_EDGCNTX_EN_Pos = 0x7
	// Bit mask of EDGCNTX_EN field.
	PWM_SM3CAPTCTRLX_EDGCNTX_EN_Msk = 0x80
	// Bit EDGCNTX_EN.
	PWM_SM3CAPTCTRLX_EDGCNTX_EN = 0x80
	// Edge counter disabled and held in reset
	PWM_SM3CAPTCTRLX_EDGCNTX_EN_EDGCNTX_EN_0 = 0x0
	// Edge counter enabled
	PWM_SM3CAPTCTRLX_EDGCNTX_EN_EDGCNTX_EN_1 = 0x1
	// Position of CFXWM field.
	PWM_SM3CAPTCTRLX_CFXWM_Pos = 0x8
	// Bit mask of CFXWM field.
	PWM_SM3CAPTCTRLX_CFXWM_Msk = 0x300
	// Position of CX0CNT field.
	PWM_SM3CAPTCTRLX_CX0CNT_Pos = 0xa
	// Bit mask of CX0CNT field.
	PWM_SM3CAPTCTRLX_CX0CNT_Msk = 0x1c00
	// Position of CX1CNT field.
	PWM_SM3CAPTCTRLX_CX1CNT_Pos = 0xd
	// Bit mask of CX1CNT field.
	PWM_SM3CAPTCTRLX_CX1CNT_Msk = 0xe000

	// SM3CAPTCOMPX: Capture Compare X Register
	// Position of EDGCMPX field.
	PWM_SM3CAPTCOMPX_EDGCMPX_Pos = 0x0
	// Bit mask of EDGCMPX field.
	PWM_SM3CAPTCOMPX_EDGCMPX_Msk = 0xff
	// Position of EDGCNTX field.
	PWM_SM3CAPTCOMPX_EDGCNTX_Pos = 0x8
	// Bit mask of EDGCNTX field.
	PWM_SM3CAPTCOMPX_EDGCNTX_Msk = 0xff00

	// SM3CVAL0: Capture Value 0 Register
	// Position of CAPTVAL0 field.
	PWM_SM3CVAL0_CAPTVAL0_Pos = 0x0
	// Bit mask of CAPTVAL0 field.
	PWM_SM3CVAL0_CAPTVAL0_Msk = 0xffff

	// SM3CVAL0CYC: Capture Value 0 Cycle Register
	// Position of CVAL0CYC field.
	PWM_SM3CVAL0CYC_CVAL0CYC_Pos = 0x0
	// Bit mask of CVAL0CYC field.
	PWM_SM3CVAL0CYC_CVAL0CYC_Msk = 0xf

	// SM3CVAL1: Capture Value 1 Register
	// Position of CAPTVAL1 field.
	PWM_SM3CVAL1_CAPTVAL1_Pos = 0x0
	// Bit mask of CAPTVAL1 field.
	PWM_SM3CVAL1_CAPTVAL1_Msk = 0xffff

	// SM3CVAL1CYC: Capture Value 1 Cycle Register
	// Position of CVAL1CYC field.
	PWM_SM3CVAL1CYC_CVAL1CYC_Pos = 0x0
	// Bit mask of CVAL1CYC field.
	PWM_SM3CVAL1CYC_CVAL1CYC_Msk = 0xf

	// SM3CVAL2: Capture Value 2 Register
	// Position of CAPTVAL2 field.
	PWM_SM3CVAL2_CAPTVAL2_Pos = 0x0
	// Bit mask of CAPTVAL2 field.
	PWM_SM3CVAL2_CAPTVAL2_Msk = 0xffff

	// SM3CVAL2CYC: Capture Value 2 Cycle Register
	// Position of CVAL2CYC field.
	PWM_SM3CVAL2CYC_CVAL2CYC_Pos = 0x0
	// Bit mask of CVAL2CYC field.
	PWM_SM3CVAL2CYC_CVAL2CYC_Msk = 0xf

	// SM3CVAL3: Capture Value 3 Register
	// Position of CAPTVAL3 field.
	PWM_SM3CVAL3_CAPTVAL3_Pos = 0x0
	// Bit mask of CAPTVAL3 field.
	PWM_SM3CVAL3_CAPTVAL3_Msk = 0xffff

	// SM3CVAL3CYC: Capture Value 3 Cycle Register
	// Position of CVAL3CYC field.
	PWM_SM3CVAL3CYC_CVAL3CYC_Pos = 0x0
	// Bit mask of CVAL3CYC field.
	PWM_SM3CVAL3CYC_CVAL3CYC_Msk = 0xf

	// SM3CVAL4: Capture Value 4 Register
	// Position of CAPTVAL4 field.
	PWM_SM3CVAL4_CAPTVAL4_Pos = 0x0
	// Bit mask of CAPTVAL4 field.
	PWM_SM3CVAL4_CAPTVAL4_Msk = 0xffff

	// SM3CVAL4CYC: Capture Value 4 Cycle Register
	// Position of CVAL4CYC field.
	PWM_SM3CVAL4CYC_CVAL4CYC_Pos = 0x0
	// Bit mask of CVAL4CYC field.
	PWM_SM3CVAL4CYC_CVAL4CYC_Msk = 0xf

	// SM3CVAL5: Capture Value 5 Register
	// Position of CAPTVAL5 field.
	PWM_SM3CVAL5_CAPTVAL5_Pos = 0x0
	// Bit mask of CAPTVAL5 field.
	PWM_SM3CVAL5_CAPTVAL5_Msk = 0xffff

	// SM3CVAL5CYC: Capture Value 5 Cycle Register
	// Position of CVAL5CYC field.
	PWM_SM3CVAL5CYC_CVAL5CYC_Pos = 0x0
	// Bit mask of CVAL5CYC field.
	PWM_SM3CVAL5CYC_CVAL5CYC_Msk = 0xf

	// SM3PHASEDLY: Phase Delay Register
	// Position of PHASEDLY field.
	PWM_SM3PHASEDLY_PHASEDLY_Pos = 0x0
	// Bit mask of PHASEDLY field.
	PWM_SM3PHASEDLY_PHASEDLY_Msk = 0xffff

	// OUTEN: Output Enable Register
	// Position of PWMX_EN field.
	PWM_OUTEN_PWMX_EN_Pos = 0x0
	// Bit mask of PWMX_EN field.
	PWM_OUTEN_PWMX_EN_Msk = 0xf
	// PWM_X output disabled.
	PWM_OUTEN_PWMX_EN_PWMX_EN_0 = 0x0
	// PWM_X output enabled.
	PWM_OUTEN_PWMX_EN_PWMX_EN_1 = 0x1
	// Position of PWMB_EN field.
	PWM_OUTEN_PWMB_EN_Pos = 0x4
	// Bit mask of PWMB_EN field.
	PWM_OUTEN_PWMB_EN_Msk = 0xf0
	// PWM_B output disabled.
	PWM_OUTEN_PWMB_EN_PWMB_EN_0 = 0x0
	// PWM_B output enabled.
	PWM_OUTEN_PWMB_EN_PWMB_EN_1 = 0x1
	// Position of PWMA_EN field.
	PWM_OUTEN_PWMA_EN_Pos = 0x8
	// Bit mask of PWMA_EN field.
	PWM_OUTEN_PWMA_EN_Msk = 0xf00
	// PWM_A output disabled.
	PWM_OUTEN_PWMA_EN_PWMA_EN_0 = 0x0
	// PWM_A output enabled.
	PWM_OUTEN_PWMA_EN_PWMA_EN_1 = 0x1

	// MASK: Mask Register
	// Position of MASKX field.
	PWM_MASK_MASKX_Pos = 0x0
	// Bit mask of MASKX field.
	PWM_MASK_MASKX_Msk = 0xf
	// PWM_X output normal.
	PWM_MASK_MASKX_MASKX_0 = 0x0
	// PWM_X output masked.
	PWM_MASK_MASKX_MASKX_1 = 0x1
	// Position of MASKB field.
	PWM_MASK_MASKB_Pos = 0x4
	// Bit mask of MASKB field.
	PWM_MASK_MASKB_Msk = 0xf0
	// PWM_B output normal.
	PWM_MASK_MASKB_MASKB_0 = 0x0
	// PWM_B output masked.
	PWM_MASK_MASKB_MASKB_1 = 0x1
	// Position of MASKA field.
	PWM_MASK_MASKA_Pos = 0x8
	// Bit mask of MASKA field.
	PWM_MASK_MASKA_Msk = 0xf00
	// PWM_A output normal.
	PWM_MASK_MASKA_MASKA_0 = 0x0
	// PWM_A output masked.
	PWM_MASK_MASKA_MASKA_1 = 0x1
	// Position of UPDATE_MASK field.
	PWM_MASK_UPDATE_MASK_Pos = 0xc
	// Bit mask of UPDATE_MASK field.
	PWM_MASK_UPDATE_MASK_Msk = 0xf000
	// Normal operation. MASK* bits within the corresponding submodule are not updated until a FORCE_OUT event occurs within the submodule.
	PWM_MASK_UPDATE_MASK_UPDATE_MASK_0 = 0x0
	// Immediate operation. MASK* bits within the corresponding submodule are updated on the following clock edge after setting this bit.
	PWM_MASK_UPDATE_MASK_UPDATE_MASK_1 = 0x1

	// SWCOUT: Software Controlled Output Register
	// Position of SM0OUT45 field.
	PWM_SWCOUT_SM0OUT45_Pos = 0x0
	// Bit mask of SM0OUT45 field.
	PWM_SWCOUT_SM0OUT45_Msk = 0x1
	// Bit SM0OUT45.
	PWM_SWCOUT_SM0OUT45 = 0x1
	// A logic 0 is supplied to the deadtime generator of submodule 0 instead of PWM45.
	PWM_SWCOUT_SM0OUT45_SM0OUT45_0 = 0x0
	// A logic 1 is supplied to the deadtime generator of submodule 0 instead of PWM45.
	PWM_SWCOUT_SM0OUT45_SM0OUT45_1 = 0x1
	// Position of SM0OUT23 field.
	PWM_SWCOUT_SM0OUT23_Pos = 0x1
	// Bit mask of SM0OUT23 field.
	PWM_SWCOUT_SM0OUT23_Msk = 0x2
	// Bit SM0OUT23.
	PWM_SWCOUT_SM0OUT23 = 0x2
	// A logic 0 is supplied to the deadtime generator of submodule 0 instead of PWM23.
	PWM_SWCOUT_SM0OUT23_SM0OUT23_0 = 0x0
	// A logic 1 is supplied to the deadtime generator of submodule 0 instead of PWM23.
	PWM_SWCOUT_SM0OUT23_SM0OUT23_1 = 0x1
	// Position of SM1OUT45 field.
	PWM_SWCOUT_SM1OUT45_Pos = 0x2
	// Bit mask of SM1OUT45 field.
	PWM_SWCOUT_SM1OUT45_Msk = 0x4
	// Bit SM1OUT45.
	PWM_SWCOUT_SM1OUT45 = 0x4
	// A logic 0 is supplied to the deadtime generator of submodule 1 instead of PWM45.
	PWM_SWCOUT_SM1OUT45_SM1OUT45_0 = 0x0
	// A logic 1 is supplied to the deadtime generator of submodule 1 instead of PWM45.
	PWM_SWCOUT_SM1OUT45_SM1OUT45_1 = 0x1
	// Position of SM1OUT23 field.
	PWM_SWCOUT_SM1OUT23_Pos = 0x3
	// Bit mask of SM1OUT23 field.
	PWM_SWCOUT_SM1OUT23_Msk = 0x8
	// Bit SM1OUT23.
	PWM_SWCOUT_SM1OUT23 = 0x8
	// A logic 0 is supplied to the deadtime generator of submodule 1 instead of PWM23.
	PWM_SWCOUT_SM1OUT23_SM1OUT23_0 = 0x0
	// A logic 1 is supplied to the deadtime generator of submodule 1 instead of PWM23.
	PWM_SWCOUT_SM1OUT23_SM1OUT23_1 = 0x1
	// Position of SM2OUT45 field.
	PWM_SWCOUT_SM2OUT45_Pos = 0x4
	// Bit mask of SM2OUT45 field.
	PWM_SWCOUT_SM2OUT45_Msk = 0x10
	// Bit SM2OUT45.
	PWM_SWCOUT_SM2OUT45 = 0x10
	// A logic 0 is supplied to the deadtime generator of submodule 2 instead of PWM45.
	PWM_SWCOUT_SM2OUT45_SM2OUT45_0 = 0x0
	// A logic 1 is supplied to the deadtime generator of submodule 2 instead of PWM45.
	PWM_SWCOUT_SM2OUT45_SM2OUT45_1 = 0x1
	// Position of SM2OUT23 field.
	PWM_SWCOUT_SM2OUT23_Pos = 0x5
	// Bit mask of SM2OUT23 field.
	PWM_SWCOUT_SM2OUT23_Msk = 0x20
	// Bit SM2OUT23.
	PWM_SWCOUT_SM2OUT23 = 0x20
	// A logic 0 is supplied to the deadtime generator of submodule 2 instead of PWM23.
	PWM_SWCOUT_SM2OUT23_SM2OUT23_0 = 0x0
	// A logic 1 is supplied to the deadtime generator of submodule 2 instead of PWM23.
	PWM_SWCOUT_SM2OUT23_SM2OUT23_1 = 0x1
	// Position of SM3OUT45 field.
	PWM_SWCOUT_SM3OUT45_Pos = 0x6
	// Bit mask of SM3OUT45 field.
	PWM_SWCOUT_SM3OUT45_Msk = 0x40
	// Bit SM3OUT45.
	PWM_SWCOUT_SM3OUT45 = 0x40
	// A logic 0 is supplied to the deadtime generator of submodule 3 instead of PWM45.
	PWM_SWCOUT_SM3OUT45_SM3OUT45_0 = 0x0
	// A logic 1 is supplied to the deadtime generator of submodule 3 instead of PWM45.
	PWM_SWCOUT_SM3OUT45_SM3OUT45_1 = 0x1
	// Position of SM3OUT23 field.
	PWM_SWCOUT_SM3OUT23_Pos = 0x7
	// Bit mask of SM3OUT23 field.
	PWM_SWCOUT_SM3OUT23_Msk = 0x80
	// Bit SM3OUT23.
	PWM_SWCOUT_SM3OUT23 = 0x80
	// A logic 0 is supplied to the deadtime generator of submodule 3 instead of PWM23.
	PWM_SWCOUT_SM3OUT23_SM3OUT23_0 = 0x0
	// A logic 1 is supplied to the deadtime generator of submodule 3 instead of PWM23.
	PWM_SWCOUT_SM3OUT23_SM3OUT23_1 = 0x1

	// DTSRCSEL: PWM Source Select Register
	// Position of SM0SEL45 field.
	PWM_DTSRCSEL_SM0SEL45_Pos = 0x0
	// Bit mask of SM0SEL45 field.
	PWM_DTSRCSEL_SM0SEL45_Msk = 0x3
	// Generated SM0PWM45 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM0SEL45_SM0SEL45_0 = 0x0
	// Inverted generated SM0PWM45 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM0SEL45_SM0SEL45_1 = 0x1
	// SWCOUT[SM0OUT45] is used by the deadtime logic.
	PWM_DTSRCSEL_SM0SEL45_SM0SEL45_2 = 0x2
	// PWM0_EXTB signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM0SEL45_SM0SEL45_3 = 0x3
	// Position of SM0SEL23 field.
	PWM_DTSRCSEL_SM0SEL23_Pos = 0x2
	// Bit mask of SM0SEL23 field.
	PWM_DTSRCSEL_SM0SEL23_Msk = 0xc
	// Generated SM0PWM23 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM0SEL23_SM0SEL23_0 = 0x0
	// Inverted generated SM0PWM23 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM0SEL23_SM0SEL23_1 = 0x1
	// SWCOUT[SM0OUT23] is used by the deadtime logic.
	PWM_DTSRCSEL_SM0SEL23_SM0SEL23_2 = 0x2
	// PWM0_EXTA signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM0SEL23_SM0SEL23_3 = 0x3
	// Position of SM1SEL45 field.
	PWM_DTSRCSEL_SM1SEL45_Pos = 0x4
	// Bit mask of SM1SEL45 field.
	PWM_DTSRCSEL_SM1SEL45_Msk = 0x30
	// Generated SM1PWM45 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM1SEL45_SM1SEL45_0 = 0x0
	// Inverted generated SM1PWM45 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM1SEL45_SM1SEL45_1 = 0x1
	// SWCOUT[SM1OUT45] is used by the deadtime logic.
	PWM_DTSRCSEL_SM1SEL45_SM1SEL45_2 = 0x2
	// PWM1_EXTB signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM1SEL45_SM1SEL45_3 = 0x3
	// Position of SM1SEL23 field.
	PWM_DTSRCSEL_SM1SEL23_Pos = 0x6
	// Bit mask of SM1SEL23 field.
	PWM_DTSRCSEL_SM1SEL23_Msk = 0xc0
	// Generated SM1PWM23 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM1SEL23_SM1SEL23_0 = 0x0
	// Inverted generated SM1PWM23 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM1SEL23_SM1SEL23_1 = 0x1
	// SWCOUT[SM1OUT23] is used by the deadtime logic.
	PWM_DTSRCSEL_SM1SEL23_SM1SEL23_2 = 0x2
	// PWM1_EXTA signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM1SEL23_SM1SEL23_3 = 0x3
	// Position of SM2SEL45 field.
	PWM_DTSRCSEL_SM2SEL45_Pos = 0x8
	// Bit mask of SM2SEL45 field.
	PWM_DTSRCSEL_SM2SEL45_Msk = 0x300
	// Generated SM2PWM45 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM2SEL45_SM2SEL45_0 = 0x0
	// Inverted generated SM2PWM45 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM2SEL45_SM2SEL45_1 = 0x1
	// SWCOUT[SM2OUT45] is used by the deadtime logic.
	PWM_DTSRCSEL_SM2SEL45_SM2SEL45_2 = 0x2
	// PWM2_EXTB signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM2SEL45_SM2SEL45_3 = 0x3
	// Position of SM2SEL23 field.
	PWM_DTSRCSEL_SM2SEL23_Pos = 0xa
	// Bit mask of SM2SEL23 field.
	PWM_DTSRCSEL_SM2SEL23_Msk = 0xc00
	// Generated SM2PWM23 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM2SEL23_SM2SEL23_0 = 0x0
	// Inverted generated SM2PWM23 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM2SEL23_SM2SEL23_1 = 0x1
	// SWCOUT[SM2OUT23] is used by the deadtime logic.
	PWM_DTSRCSEL_SM2SEL23_SM2SEL23_2 = 0x2
	// PWM2_EXTA signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM2SEL23_SM2SEL23_3 = 0x3
	// Position of SM3SEL45 field.
	PWM_DTSRCSEL_SM3SEL45_Pos = 0xc
	// Bit mask of SM3SEL45 field.
	PWM_DTSRCSEL_SM3SEL45_Msk = 0x3000
	// Generated SM3PWM45 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM3SEL45_SM3SEL45_0 = 0x0
	// Inverted generated SM3PWM45 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM3SEL45_SM3SEL45_1 = 0x1
	// SWCOUT[SM3OUT45] is used by the deadtime logic.
	PWM_DTSRCSEL_SM3SEL45_SM3SEL45_2 = 0x2
	// PWM3_EXTB signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM3SEL45_SM3SEL45_3 = 0x3
	// Position of SM3SEL23 field.
	PWM_DTSRCSEL_SM3SEL23_Pos = 0xe
	// Bit mask of SM3SEL23 field.
	PWM_DTSRCSEL_SM3SEL23_Msk = 0xc000
	// Generated SM3PWM23 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM3SEL23_SM3SEL23_0 = 0x0
	// Inverted generated SM3PWM23 signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM3SEL23_SM3SEL23_1 = 0x1
	// SWCOUT[SM3OUT23] is used by the deadtime logic.
	PWM_DTSRCSEL_SM3SEL23_SM3SEL23_2 = 0x2
	// PWM3_EXTA signal is used by the deadtime logic.
	PWM_DTSRCSEL_SM3SEL23_SM3SEL23_3 = 0x3

	// MCTRL: Master Control Register
	// Position of LDOK field.
	PWM_MCTRL_LDOK_Pos = 0x0
	// Bit mask of LDOK field.
	PWM_MCTRL_LDOK_Msk = 0xf
	// Do not load new values.
	PWM_MCTRL_LDOK_LDOK_0 = 0x0
	// Load prescaler, modulus, and PWM values of the corresponding submodule.
	PWM_MCTRL_LDOK_LDOK_1 = 0x1
	// Position of CLDOK field.
	PWM_MCTRL_CLDOK_Pos = 0x4
	// Bit mask of CLDOK field.
	PWM_MCTRL_CLDOK_Msk = 0xf0
	// Position of RUN field.
	PWM_MCTRL_RUN_Pos = 0x8
	// Bit mask of RUN field.
	PWM_MCTRL_RUN_Msk = 0xf00
	// PWM generator is disabled in the corresponding submodule.
	PWM_MCTRL_RUN_RUN_0 = 0x0
	// PWM generator is enabled in the corresponding submodule.
	PWM_MCTRL_RUN_RUN_1 = 0x1
	// Position of IPOL field.
	PWM_MCTRL_IPOL_Pos = 0xc
	// Bit mask of IPOL field.
	PWM_MCTRL_IPOL_Msk = 0xf000
	// PWM23 is used to generate complementary PWM pair in the corresponding submodule.
	PWM_MCTRL_IPOL_IPOL_0 = 0x0
	// PWM45 is used to generate complementary PWM pair in the corresponding submodule.
	PWM_MCTRL_IPOL_IPOL_1 = 0x1

	// MCTRL2: Master Control 2 Register
	// Position of MONPLL field.
	PWM_MCTRL2_MONPLL_Pos = 0x0
	// Bit mask of MONPLL field.
	PWM_MCTRL2_MONPLL_Msk = 0x3
	// Not locked. Do not monitor PLL operation. Resetting of the fractional delay block in case of PLL losing lock will be controlled by software.
	PWM_MCTRL2_MONPLL_MONPLL_0 = 0x0
	// Not locked. Monitor PLL operation to automatically disable the fractional delay block when the PLL encounters problems.
	PWM_MCTRL2_MONPLL_MONPLL_1 = 0x1
	// Locked. Do not monitor PLL operation. Resetting of the fractional delay block in case of PLL losing lock will be controlled by software. These bits are write protected until the next reset.
	PWM_MCTRL2_MONPLL_MONPLL_2 = 0x2
	// Locked. Monitor PLL operation to automatically disable the fractional delay block when the PLL encounters problems. These bits are write protected until the next reset.
	PWM_MCTRL2_MONPLL_MONPLL_3 = 0x3

	// FCTRL0: Fault Control Register
	// Position of FIE field.
	PWM_FCTRL0_FIE_Pos = 0x0
	// Bit mask of FIE field.
	PWM_FCTRL0_FIE_Msk = 0xf
	// FAULTx CPU interrupt requests disabled.
	PWM_FCTRL0_FIE_FIE_0 = 0x0
	// FAULTx CPU interrupt requests enabled.
	PWM_FCTRL0_FIE_FIE_1 = 0x1
	// Position of FSAFE field.
	PWM_FCTRL0_FSAFE_Pos = 0x4
	// Bit mask of FSAFE field.
	PWM_FCTRL0_FSAFE_Msk = 0xf0
	// Normal mode. PWM outputs disabled by this fault are not enabled until FSTS[FFLAGx] is clear at the start of a half cycle or full cycle depending on the states of FSTS[FHALF] and FSTS[FFULL] without regard to the state of FSTS[FFPINx]. If neither FHALF nor FFULL is setm then the fault condition cannot be cleared. The PWM outputs disabled by this fault input will not be re-enabled until the actual FAULTx input signal de-asserts since the fault input will combinationally disable the PWM outputs (as programmed in DISMAPn).
	PWM_FCTRL0_FSAFE_FSAFE_0 = 0x0
	// Safe mode. PWM outputs disabled by this fault are not enabled until FSTS[FFLAGx] is clear and FSTS[FFPINx] is clear at the start of a half cycle or full cycle depending on the states of FSTS[FHALF] and FSTS[FFULL]. If neither FHLAF nor FFULL is set, then the fault condition cannot be cleared.
	PWM_FCTRL0_FSAFE_FSAFE_1 = 0x1
	// Position of FAUTO field.
	PWM_FCTRL0_FAUTO_Pos = 0x8
	// Bit mask of FAUTO field.
	PWM_FCTRL0_FAUTO_Msk = 0xf00
	// Manual fault clearing. PWM outputs disabled by this fault are not enabled until FSTS[FFLAGx] is clear at the start of a half cycle or full cycle depending the states of FSTS[FHALF] and FSTS[FFULL]. If neither FFULL nor FHALF is set, then the fault condition cannot be cleared. This is further controlled by FCTRL[FSAFE].
	PWM_FCTRL0_FAUTO_FAUTO_0 = 0x0
	// Automatic fault clearing. PWM outputs disabled by this fault are enabled when FSTS[FFPINx] is clear at the start of a half cycle or full cycle depending on the states of FSTS[FHALF] and FSTS[FFULL] without regard to the state of FSTS[FFLAGx]. If neither FFULL nor FHALF is set, then the fault condition cannot be cleared.
	PWM_FCTRL0_FAUTO_FAUTO_1 = 0x1
	// Position of FLVL field.
	PWM_FCTRL0_FLVL_Pos = 0xc
	// Bit mask of FLVL field.
	PWM_FCTRL0_FLVL_Msk = 0xf000
	// A logic 0 on the fault input indicates a fault condition.
	PWM_FCTRL0_FLVL_FLVL_0 = 0x0
	// A logic 1 on the fault input indicates a fault condition.
	PWM_FCTRL0_FLVL_FLVL_1 = 0x1

	// FSTS0: Fault Status Register
	// Position of FFLAG field.
	PWM_FSTS0_FFLAG_Pos = 0x0
	// Bit mask of FFLAG field.
	PWM_FSTS0_FFLAG_Msk = 0xf
	// No fault on the FAULTx pin.
	PWM_FSTS0_FFLAG_FFLAG_0 = 0x0
	// Fault on the FAULTx pin.
	PWM_FSTS0_FFLAG_FFLAG_1 = 0x1
	// Position of FFULL field.
	PWM_FSTS0_FFULL_Pos = 0x4
	// Bit mask of FFULL field.
	PWM_FSTS0_FFULL_Msk = 0xf0
	// PWM outputs are not re-enabled at the start of a full cycle
	PWM_FSTS0_FFULL_FFULL_0 = 0x0
	// PWM outputs are re-enabled at the start of a full cycle
	PWM_FSTS0_FFULL_FFULL_1 = 0x1
	// Position of FFPIN field.
	PWM_FSTS0_FFPIN_Pos = 0x8
	// Bit mask of FFPIN field.
	PWM_FSTS0_FFPIN_Msk = 0xf00
	// Position of FHALF field.
	PWM_FSTS0_FHALF_Pos = 0xc
	// Bit mask of FHALF field.
	PWM_FSTS0_FHALF_Msk = 0xf000
	// PWM outputs are not re-enabled at the start of a half cycle.
	PWM_FSTS0_FHALF_FHALF_0 = 0x0
	// PWM outputs are re-enabled at the start of a half cycle (as defined by VAL0).
	PWM_FSTS0_FHALF_FHALF_1 = 0x1

	// FFILT0: Fault Filter Register
	// Position of FILT_PER field.
	PWM_FFILT0_FILT_PER_Pos = 0x0
	// Bit mask of FILT_PER field.
	PWM_FFILT0_FILT_PER_Msk = 0xff
	// Position of FILT_CNT field.
	PWM_FFILT0_FILT_CNT_Pos = 0x8
	// Bit mask of FILT_CNT field.
	PWM_FFILT0_FILT_CNT_Msk = 0x700
	// Position of GSTR field.
	PWM_FFILT0_GSTR_Pos = 0xf
	// Bit mask of GSTR field.
	PWM_FFILT0_GSTR_Msk = 0x8000
	// Bit GSTR.
	PWM_FFILT0_GSTR = 0x8000
	// Fault input glitch stretching is disabled.
	PWM_FFILT0_GSTR_GSTR_0 = 0x0
	// Input fault signals will be stretched to at least 2 IPBus clock cycles.
	PWM_FFILT0_GSTR_GSTR_1 = 0x1

	// FTST0: Fault Test Register
	// Position of FTEST field.
	PWM_FTST0_FTEST_Pos = 0x0
	// Bit mask of FTEST field.
	PWM_FTST0_FTEST_Msk = 0x1
	// Bit FTEST.
	PWM_FTST0_FTEST = 0x1
	// No fault
	PWM_FTST0_FTEST_FTEST_0 = 0x0
	// Cause a simulated fault
	PWM_FTST0_FTEST_FTEST_1 = 0x1

	// FCTRL20: Fault Control 2 Register
	// Position of NOCOMB field.
	PWM_FCTRL20_NOCOMB_Pos = 0x0
	// Bit mask of NOCOMB field.
	PWM_FCTRL20_NOCOMB_Msk = 0xf
	// There is a combinational link from the fault inputs to the PWM outputs. The fault inputs are combined with the filtered and latched fault signals to disable the PWM outputs.
	PWM_FCTRL20_NOCOMB_NOCOMB_0 = 0x0
	// The direct combinational path from the fault inputs to the PWM outputs is disabled and the filtered and latched fault signals are used to disable the PWM outputs.
	PWM_FCTRL20_NOCOMB_NOCOMB_1 = 0x1
)

// Constants for SPDIF: SPDIF
const (
	// SCR: SPDIF Configuration Register
	// Position of USrc_Sel field.
	SPDIF_SCR_USrc_Sel_Pos = 0x0
	// Bit mask of USrc_Sel field.
	SPDIF_SCR_USrc_Sel_Msk = 0x3
	// No embedded U channel
	SPDIF_SCR_USrc_Sel_USrc_Sel_0 = 0x0
	// U channel from SPDIF receive block (CD mode)
	SPDIF_SCR_USrc_Sel_USrc_Sel_1 = 0x1
	// U channel from on chip transmitter
	SPDIF_SCR_USrc_Sel_USrc_Sel_3 = 0x3
	// Position of TxSel field.
	SPDIF_SCR_TxSel_Pos = 0x2
	// Bit mask of TxSel field.
	SPDIF_SCR_TxSel_Msk = 0x1c
	// Off and output 0
	SPDIF_SCR_TxSel_TxSel_0 = 0x0
	// Feed-through SPDIFIN
	SPDIF_SCR_TxSel_TxSel_1 = 0x1
	// Tx Normal operation
	SPDIF_SCR_TxSel_TxSel_5 = 0x5
	// Position of ValCtrl field.
	SPDIF_SCR_ValCtrl_Pos = 0x5
	// Bit mask of ValCtrl field.
	SPDIF_SCR_ValCtrl_Msk = 0x20
	// Bit ValCtrl.
	SPDIF_SCR_ValCtrl = 0x20
	// Outgoing Validity always set
	SPDIF_SCR_ValCtrl_ValCtrl_0 = 0x0
	// Outgoing Validity always clear
	SPDIF_SCR_ValCtrl_ValCtrl_1 = 0x1
	// Position of DMA_TX_En field.
	SPDIF_SCR_DMA_TX_En_Pos = 0x8
	// Bit mask of DMA_TX_En field.
	SPDIF_SCR_DMA_TX_En_Msk = 0x100
	// Bit DMA_TX_En.
	SPDIF_SCR_DMA_TX_En = 0x100
	// Position of DMA_Rx_En field.
	SPDIF_SCR_DMA_Rx_En_Pos = 0x9
	// Bit mask of DMA_Rx_En field.
	SPDIF_SCR_DMA_Rx_En_Msk = 0x200
	// Bit DMA_Rx_En.
	SPDIF_SCR_DMA_Rx_En = 0x200
	// Position of TxFIFO_Ctrl field.
	SPDIF_SCR_TxFIFO_Ctrl_Pos = 0xa
	// Bit mask of TxFIFO_Ctrl field.
	SPDIF_SCR_TxFIFO_Ctrl_Msk = 0xc00
	// Send out digital zero on SPDIF Tx
	SPDIF_SCR_TxFIFO_Ctrl_TxFIFO_Ctrl_0 = 0x0
	// Tx Normal operation
	SPDIF_SCR_TxFIFO_Ctrl_TxFIFO_Ctrl_1 = 0x1
	// Reset to 1 sample remaining
	SPDIF_SCR_TxFIFO_Ctrl_TxFIFO_Ctrl_2 = 0x2
	// Position of SOFT_RESET field.
	SPDIF_SCR_SOFT_RESET_Pos = 0xc
	// Bit mask of SOFT_RESET field.
	SPDIF_SCR_SOFT_RESET_Msk = 0x1000
	// Bit SOFT_RESET.
	SPDIF_SCR_SOFT_RESET = 0x1000
	// Position of LOW_POWER field.
	SPDIF_SCR_LOW_POWER_Pos = 0xd
	// Bit mask of LOW_POWER field.
	SPDIF_SCR_LOW_POWER_Msk = 0x2000
	// Bit LOW_POWER.
	SPDIF_SCR_LOW_POWER = 0x2000
	// Position of TxFIFOEmpty_Sel field.
	SPDIF_SCR_TxFIFOEmpty_Sel_Pos = 0xf
	// Bit mask of TxFIFOEmpty_Sel field.
	SPDIF_SCR_TxFIFOEmpty_Sel_Msk = 0x18000
	// Empty interrupt if 0 sample in Tx left and right FIFOs
	SPDIF_SCR_TxFIFOEmpty_Sel_TxFIFOEmpty_Sel_0 = 0x0
	// Empty interrupt if at most 4 sample in Tx left and right FIFOs
	SPDIF_SCR_TxFIFOEmpty_Sel_TxFIFOEmpty_Sel_1 = 0x1
	// Empty interrupt if at most 8 sample in Tx left and right FIFOs
	SPDIF_SCR_TxFIFOEmpty_Sel_TxFIFOEmpty_Sel_2 = 0x2
	// Empty interrupt if at most 12 sample in Tx left and right FIFOs
	SPDIF_SCR_TxFIFOEmpty_Sel_TxFIFOEmpty_Sel_3 = 0x3
	// Position of TxAutoSync field.
	SPDIF_SCR_TxAutoSync_Pos = 0x11
	// Bit mask of TxAutoSync field.
	SPDIF_SCR_TxAutoSync_Msk = 0x20000
	// Bit TxAutoSync.
	SPDIF_SCR_TxAutoSync = 0x20000
	// Tx FIFO auto sync off
	SPDIF_SCR_TxAutoSync_TxAutoSync_0 = 0x0
	// Tx FIFO auto sync on
	SPDIF_SCR_TxAutoSync_TxAutoSync_1 = 0x1
	// Position of RxAutoSync field.
	SPDIF_SCR_RxAutoSync_Pos = 0x12
	// Bit mask of RxAutoSync field.
	SPDIF_SCR_RxAutoSync_Msk = 0x40000
	// Bit RxAutoSync.
	SPDIF_SCR_RxAutoSync = 0x40000
	// Rx FIFO auto sync off
	SPDIF_SCR_RxAutoSync_RxAutoSync_0 = 0x0
	// RxFIFO auto sync on
	SPDIF_SCR_RxAutoSync_RxAutoSync_1 = 0x1
	// Position of RxFIFOFull_Sel field.
	SPDIF_SCR_RxFIFOFull_Sel_Pos = 0x13
	// Bit mask of RxFIFOFull_Sel field.
	SPDIF_SCR_RxFIFOFull_Sel_Msk = 0x180000
	// Full interrupt if at least 1 sample in Rx left and right FIFOs
	SPDIF_SCR_RxFIFOFull_Sel_RxFIFOFull_Sel_0 = 0x0
	// Full interrupt if at least 4 sample in Rx left and right FIFOs
	SPDIF_SCR_RxFIFOFull_Sel_RxFIFOFull_Sel_1 = 0x1
	// Full interrupt if at least 8 sample in Rx left and right FIFOs
	SPDIF_SCR_RxFIFOFull_Sel_RxFIFOFull_Sel_2 = 0x2
	// Full interrupt if at least 16 sample in Rx left and right FIFO
	SPDIF_SCR_RxFIFOFull_Sel_RxFIFOFull_Sel_3 = 0x3
	// Position of RxFIFO_Rst field.
	SPDIF_SCR_RxFIFO_Rst_Pos = 0x15
	// Bit mask of RxFIFO_Rst field.
	SPDIF_SCR_RxFIFO_Rst_Msk = 0x200000
	// Bit RxFIFO_Rst.
	SPDIF_SCR_RxFIFO_Rst = 0x200000
	// Normal operation
	SPDIF_SCR_RxFIFO_Rst_RxFIFO_Rst_0 = 0x0
	// Reset register to 1 sample remaining
	SPDIF_SCR_RxFIFO_Rst_RxFIFO_Rst_1 = 0x1
	// Position of RxFIFO_Off_On field.
	SPDIF_SCR_RxFIFO_Off_On_Pos = 0x16
	// Bit mask of RxFIFO_Off_On field.
	SPDIF_SCR_RxFIFO_Off_On_Msk = 0x400000
	// Bit RxFIFO_Off_On.
	SPDIF_SCR_RxFIFO_Off_On = 0x400000
	// SPDIF Rx FIFO is on
	SPDIF_SCR_RxFIFO_Off_On_RxFIFO_Off_On_0 = 0x0
	// SPDIF Rx FIFO is off. Does not accept data from interface
	SPDIF_SCR_RxFIFO_Off_On_RxFIFO_Off_On_1 = 0x1
	// Position of RxFIFO_Ctrl field.
	SPDIF_SCR_RxFIFO_Ctrl_Pos = 0x17
	// Bit mask of RxFIFO_Ctrl field.
	SPDIF_SCR_RxFIFO_Ctrl_Msk = 0x800000
	// Bit RxFIFO_Ctrl.
	SPDIF_SCR_RxFIFO_Ctrl = 0x800000
	// Normal operation
	SPDIF_SCR_RxFIFO_Ctrl_RxFIFO_Ctrl_0 = 0x0
	// Always read zero from Rx data register
	SPDIF_SCR_RxFIFO_Ctrl_RxFIFO_Ctrl_1 = 0x1

	// SRCD: CDText Control Register
	// Position of USyncMode field.
	SPDIF_SRCD_USyncMode_Pos = 0x1
	// Bit mask of USyncMode field.
	SPDIF_SRCD_USyncMode_Msk = 0x2
	// Bit USyncMode.
	SPDIF_SRCD_USyncMode = 0x2
	// Non-CD data
	SPDIF_SRCD_USyncMode_USyncMode_0 = 0x0
	// CD user channel subcode
	SPDIF_SRCD_USyncMode_USyncMode_1 = 0x1

	// SRPC: PhaseConfig Register
	// Position of GainSel field.
	SPDIF_SRPC_GainSel_Pos = 0x3
	// Bit mask of GainSel field.
	SPDIF_SRPC_GainSel_Msk = 0x38
	// 24*(2**10)
	SPDIF_SRPC_GainSel_GainSel_0 = 0x0
	// 16*(2**10)
	SPDIF_SRPC_GainSel_GainSel_1 = 0x1
	// 12*(2**10)
	SPDIF_SRPC_GainSel_GainSel_2 = 0x2
	// 8*(2**10)
	SPDIF_SRPC_GainSel_GainSel_3 = 0x3
	// 6*(2**10)
	SPDIF_SRPC_GainSel_GainSel_4 = 0x4
	// 4*(2**10)
	SPDIF_SRPC_GainSel_GainSel_5 = 0x5
	// 3*(2**10)
	SPDIF_SRPC_GainSel_GainSel_6 = 0x6
	// Position of LOCK field.
	SPDIF_SRPC_LOCK_Pos = 0x6
	// Bit mask of LOCK field.
	SPDIF_SRPC_LOCK_Msk = 0x40
	// Bit LOCK.
	SPDIF_SRPC_LOCK = 0x40
	// Position of ClkSrc_Sel field.
	SPDIF_SRPC_ClkSrc_Sel_Pos = 0x7
	// Bit mask of ClkSrc_Sel field.
	SPDIF_SRPC_ClkSrc_Sel_Msk = 0x780
	// if (DPLL Locked) SPDIF_RxClk else REF_CLK_32K (XTALOSC)
	SPDIF_SRPC_ClkSrc_Sel_ClkSrc_Sel_0 = 0x0
	// if (DPLL Locked) SPDIF_RxClk else tx_clk (SPDIF0_CLK_ROOT)
	SPDIF_SRPC_ClkSrc_Sel_ClkSrc_Sel_1 = 0x1
	// if (DPLL Locked) SPDIF_RxClk else SPDIF_EXT_CLK
	SPDIF_SRPC_ClkSrc_Sel_ClkSrc_Sel_3 = 0x3
	// REF_CLK_32K (XTALOSC)
	SPDIF_SRPC_ClkSrc_Sel_ClkSrc_Sel_5 = 0x5
	// tx_clk (SPDIF0_CLK_ROOT)
	SPDIF_SRPC_ClkSrc_Sel_ClkSrc_Sel_6 = 0x6
	// SPDIF_EXT_CLK
	SPDIF_SRPC_ClkSrc_Sel_ClkSrc_Sel_8 = 0x8

	// SIE: InterruptEn Register
	// Position of RxFIFOFul field.
	SPDIF_SIE_RxFIFOFul_Pos = 0x0
	// Bit mask of RxFIFOFul field.
	SPDIF_SIE_RxFIFOFul_Msk = 0x1
	// Bit RxFIFOFul.
	SPDIF_SIE_RxFIFOFul = 0x1
	// Position of TxEm field.
	SPDIF_SIE_TxEm_Pos = 0x1
	// Bit mask of TxEm field.
	SPDIF_SIE_TxEm_Msk = 0x2
	// Bit TxEm.
	SPDIF_SIE_TxEm = 0x2
	// Position of LockLoss field.
	SPDIF_SIE_LockLoss_Pos = 0x2
	// Bit mask of LockLoss field.
	SPDIF_SIE_LockLoss_Msk = 0x4
	// Bit LockLoss.
	SPDIF_SIE_LockLoss = 0x4
	// Position of RxFIFOResyn field.
	SPDIF_SIE_RxFIFOResyn_Pos = 0x3
	// Bit mask of RxFIFOResyn field.
	SPDIF_SIE_RxFIFOResyn_Msk = 0x8
	// Bit RxFIFOResyn.
	SPDIF_SIE_RxFIFOResyn = 0x8
	// Position of RxFIFOUnOv field.
	SPDIF_SIE_RxFIFOUnOv_Pos = 0x4
	// Bit mask of RxFIFOUnOv field.
	SPDIF_SIE_RxFIFOUnOv_Msk = 0x10
	// Bit RxFIFOUnOv.
	SPDIF_SIE_RxFIFOUnOv = 0x10
	// Position of UQErr field.
	SPDIF_SIE_UQErr_Pos = 0x5
	// Bit mask of UQErr field.
	SPDIF_SIE_UQErr_Msk = 0x20
	// Bit UQErr.
	SPDIF_SIE_UQErr = 0x20
	// Position of UQSync field.
	SPDIF_SIE_UQSync_Pos = 0x6
	// Bit mask of UQSync field.
	SPDIF_SIE_UQSync_Msk = 0x40
	// Bit UQSync.
	SPDIF_SIE_UQSync = 0x40
	// Position of QRxOv field.
	SPDIF_SIE_QRxOv_Pos = 0x7
	// Bit mask of QRxOv field.
	SPDIF_SIE_QRxOv_Msk = 0x80
	// Bit QRxOv.
	SPDIF_SIE_QRxOv = 0x80
	// Position of QRxFul field.
	SPDIF_SIE_QRxFul_Pos = 0x8
	// Bit mask of QRxFul field.
	SPDIF_SIE_QRxFul_Msk = 0x100
	// Bit QRxFul.
	SPDIF_SIE_QRxFul = 0x100
	// Position of URxOv field.
	SPDIF_SIE_URxOv_Pos = 0x9
	// Bit mask of URxOv field.
	SPDIF_SIE_URxOv_Msk = 0x200
	// Bit URxOv.
	SPDIF_SIE_URxOv = 0x200
	// Position of URxFul field.
	SPDIF_SIE_URxFul_Pos = 0xa
	// Bit mask of URxFul field.
	SPDIF_SIE_URxFul_Msk = 0x400
	// Bit URxFul.
	SPDIF_SIE_URxFul = 0x400
	// Position of BitErr field.
	SPDIF_SIE_BitErr_Pos = 0xe
	// Bit mask of BitErr field.
	SPDIF_SIE_BitErr_Msk = 0x4000
	// Bit BitErr.
	SPDIF_SIE_BitErr = 0x4000
	// Position of SymErr field.
	SPDIF_SIE_SymErr_Pos = 0xf
	// Bit mask of SymErr field.
	SPDIF_SIE_SymErr_Msk = 0x8000
	// Bit SymErr.
	SPDIF_SIE_SymErr = 0x8000
	// Position of ValNoGood field.
	SPDIF_SIE_ValNoGood_Pos = 0x10
	// Bit mask of ValNoGood field.
	SPDIF_SIE_ValNoGood_Msk = 0x10000
	// Bit ValNoGood.
	SPDIF_SIE_ValNoGood = 0x10000
	// Position of CNew field.
	SPDIF_SIE_CNew_Pos = 0x11
	// Bit mask of CNew field.
	SPDIF_SIE_CNew_Msk = 0x20000
	// Bit CNew.
	SPDIF_SIE_CNew = 0x20000
	// Position of TxResyn field.
	SPDIF_SIE_TxResyn_Pos = 0x12
	// Bit mask of TxResyn field.
	SPDIF_SIE_TxResyn_Msk = 0x40000
	// Bit TxResyn.
	SPDIF_SIE_TxResyn = 0x40000
	// Position of TxUnOv field.
	SPDIF_SIE_TxUnOv_Pos = 0x13
	// Bit mask of TxUnOv field.
	SPDIF_SIE_TxUnOv_Msk = 0x80000
	// Bit TxUnOv.
	SPDIF_SIE_TxUnOv = 0x80000
	// Position of Lock field.
	SPDIF_SIE_Lock_Pos = 0x14
	// Bit mask of Lock field.
	SPDIF_SIE_Lock_Msk = 0x100000
	// Bit Lock.
	SPDIF_SIE_Lock = 0x100000

	// SIC: InterruptClear Register
	// Position of LockLoss field.
	SPDIF_SIC_LockLoss_Pos = 0x2
	// Bit mask of LockLoss field.
	SPDIF_SIC_LockLoss_Msk = 0x4
	// Bit LockLoss.
	SPDIF_SIC_LockLoss = 0x4
	// Position of RxFIFOResyn field.
	SPDIF_SIC_RxFIFOResyn_Pos = 0x3
	// Bit mask of RxFIFOResyn field.
	SPDIF_SIC_RxFIFOResyn_Msk = 0x8
	// Bit RxFIFOResyn.
	SPDIF_SIC_RxFIFOResyn = 0x8
	// Position of RxFIFOUnOv field.
	SPDIF_SIC_RxFIFOUnOv_Pos = 0x4
	// Bit mask of RxFIFOUnOv field.
	SPDIF_SIC_RxFIFOUnOv_Msk = 0x10
	// Bit RxFIFOUnOv.
	SPDIF_SIC_RxFIFOUnOv = 0x10
	// Position of UQErr field.
	SPDIF_SIC_UQErr_Pos = 0x5
	// Bit mask of UQErr field.
	SPDIF_SIC_UQErr_Msk = 0x20
	// Bit UQErr.
	SPDIF_SIC_UQErr = 0x20
	// Position of UQSync field.
	SPDIF_SIC_UQSync_Pos = 0x6
	// Bit mask of UQSync field.
	SPDIF_SIC_UQSync_Msk = 0x40
	// Bit UQSync.
	SPDIF_SIC_UQSync = 0x40
	// Position of QRxOv field.
	SPDIF_SIC_QRxOv_Pos = 0x7
	// Bit mask of QRxOv field.
	SPDIF_SIC_QRxOv_Msk = 0x80
	// Bit QRxOv.
	SPDIF_SIC_QRxOv = 0x80
	// Position of URxOv field.
	SPDIF_SIC_URxOv_Pos = 0x9
	// Bit mask of URxOv field.
	SPDIF_SIC_URxOv_Msk = 0x200
	// Bit URxOv.
	SPDIF_SIC_URxOv = 0x200
	// Position of BitErr field.
	SPDIF_SIC_BitErr_Pos = 0xe
	// Bit mask of BitErr field.
	SPDIF_SIC_BitErr_Msk = 0x4000
	// Bit BitErr.
	SPDIF_SIC_BitErr = 0x4000
	// Position of SymErr field.
	SPDIF_SIC_SymErr_Pos = 0xf
	// Bit mask of SymErr field.
	SPDIF_SIC_SymErr_Msk = 0x8000
	// Bit SymErr.
	SPDIF_SIC_SymErr = 0x8000
	// Position of ValNoGood field.
	SPDIF_SIC_ValNoGood_Pos = 0x10
	// Bit mask of ValNoGood field.
	SPDIF_SIC_ValNoGood_Msk = 0x10000
	// Bit ValNoGood.
	SPDIF_SIC_ValNoGood = 0x10000
	// Position of CNew field.
	SPDIF_SIC_CNew_Pos = 0x11
	// Bit mask of CNew field.
	SPDIF_SIC_CNew_Msk = 0x20000
	// Bit CNew.
	SPDIF_SIC_CNew = 0x20000
	// Position of TxResyn field.
	SPDIF_SIC_TxResyn_Pos = 0x12
	// Bit mask of TxResyn field.
	SPDIF_SIC_TxResyn_Msk = 0x40000
	// Bit TxResyn.
	SPDIF_SIC_TxResyn = 0x40000
	// Position of TxUnOv field.
	SPDIF_SIC_TxUnOv_Pos = 0x13
	// Bit mask of TxUnOv field.
	SPDIF_SIC_TxUnOv_Msk = 0x80000
	// Bit TxUnOv.
	SPDIF_SIC_TxUnOv = 0x80000
	// Position of Lock field.
	SPDIF_SIC_Lock_Pos = 0x14
	// Bit mask of Lock field.
	SPDIF_SIC_Lock_Msk = 0x100000
	// Bit Lock.
	SPDIF_SIC_Lock = 0x100000

	// SIS: InterruptStat Register
	// Position of RxFIFOFul field.
	SPDIF_SIS_RxFIFOFul_Pos = 0x0
	// Bit mask of RxFIFOFul field.
	SPDIF_SIS_RxFIFOFul_Msk = 0x1
	// Bit RxFIFOFul.
	SPDIF_SIS_RxFIFOFul = 0x1
	// Position of TxEm field.
	SPDIF_SIS_TxEm_Pos = 0x1
	// Bit mask of TxEm field.
	SPDIF_SIS_TxEm_Msk = 0x2
	// Bit TxEm.
	SPDIF_SIS_TxEm = 0x2
	// Position of LockLoss field.
	SPDIF_SIS_LockLoss_Pos = 0x2
	// Bit mask of LockLoss field.
	SPDIF_SIS_LockLoss_Msk = 0x4
	// Bit LockLoss.
	SPDIF_SIS_LockLoss = 0x4
	// Position of RxFIFOResyn field.
	SPDIF_SIS_RxFIFOResyn_Pos = 0x3
	// Bit mask of RxFIFOResyn field.
	SPDIF_SIS_RxFIFOResyn_Msk = 0x8
	// Bit RxFIFOResyn.
	SPDIF_SIS_RxFIFOResyn = 0x8
	// Position of RxFIFOUnOv field.
	SPDIF_SIS_RxFIFOUnOv_Pos = 0x4
	// Bit mask of RxFIFOUnOv field.
	SPDIF_SIS_RxFIFOUnOv_Msk = 0x10
	// Bit RxFIFOUnOv.
	SPDIF_SIS_RxFIFOUnOv = 0x10
	// Position of UQErr field.
	SPDIF_SIS_UQErr_Pos = 0x5
	// Bit mask of UQErr field.
	SPDIF_SIS_UQErr_Msk = 0x20
	// Bit UQErr.
	SPDIF_SIS_UQErr = 0x20
	// Position of UQSync field.
	SPDIF_SIS_UQSync_Pos = 0x6
	// Bit mask of UQSync field.
	SPDIF_SIS_UQSync_Msk = 0x40
	// Bit UQSync.
	SPDIF_SIS_UQSync = 0x40
	// Position of QRxOv field.
	SPDIF_SIS_QRxOv_Pos = 0x7
	// Bit mask of QRxOv field.
	SPDIF_SIS_QRxOv_Msk = 0x80
	// Bit QRxOv.
	SPDIF_SIS_QRxOv = 0x80
	// Position of QRxFul field.
	SPDIF_SIS_QRxFul_Pos = 0x8
	// Bit mask of QRxFul field.
	SPDIF_SIS_QRxFul_Msk = 0x100
	// Bit QRxFul.
	SPDIF_SIS_QRxFul = 0x100
	// Position of URxOv field.
	SPDIF_SIS_URxOv_Pos = 0x9
	// Bit mask of URxOv field.
	SPDIF_SIS_URxOv_Msk = 0x200
	// Bit URxOv.
	SPDIF_SIS_URxOv = 0x200
	// Position of URxFul field.
	SPDIF_SIS_URxFul_Pos = 0xa
	// Bit mask of URxFul field.
	SPDIF_SIS_URxFul_Msk = 0x400
	// Bit URxFul.
	SPDIF_SIS_URxFul = 0x400
	// Position of BitErr field.
	SPDIF_SIS_BitErr_Pos = 0xe
	// Bit mask of BitErr field.
	SPDIF_SIS_BitErr_Msk = 0x4000
	// Bit BitErr.
	SPDIF_SIS_BitErr = 0x4000
	// Position of SymErr field.
	SPDIF_SIS_SymErr_Pos = 0xf
	// Bit mask of SymErr field.
	SPDIF_SIS_SymErr_Msk = 0x8000
	// Bit SymErr.
	SPDIF_SIS_SymErr = 0x8000
	// Position of ValNoGood field.
	SPDIF_SIS_ValNoGood_Pos = 0x10
	// Bit mask of ValNoGood field.
	SPDIF_SIS_ValNoGood_Msk = 0x10000
	// Bit ValNoGood.
	SPDIF_SIS_ValNoGood = 0x10000
	// Position of CNew field.
	SPDIF_SIS_CNew_Pos = 0x11
	// Bit mask of CNew field.
	SPDIF_SIS_CNew_Msk = 0x20000
	// Bit CNew.
	SPDIF_SIS_CNew = 0x20000
	// Position of TxResyn field.
	SPDIF_SIS_TxResyn_Pos = 0x12
	// Bit mask of TxResyn field.
	SPDIF_SIS_TxResyn_Msk = 0x40000
	// Bit TxResyn.
	SPDIF_SIS_TxResyn = 0x40000
	// Position of TxUnOv field.
	SPDIF_SIS_TxUnOv_Pos = 0x13
	// Bit mask of TxUnOv field.
	SPDIF_SIS_TxUnOv_Msk = 0x80000
	// Bit TxUnOv.
	SPDIF_SIS_TxUnOv = 0x80000
	// Position of Lock field.
	SPDIF_SIS_Lock_Pos = 0x14
	// Bit mask of Lock field.
	SPDIF_SIS_Lock_Msk = 0x100000
	// Bit Lock.
	SPDIF_SIS_Lock = 0x100000

	// SRL: SPDIFRxLeft Register
	// Position of RxDataLeft field.
	SPDIF_SRL_RxDataLeft_Pos = 0x0
	// Bit mask of RxDataLeft field.
	SPDIF_SRL_RxDataLeft_Msk = 0xffffff

	// SRR: SPDIFRxRight Register
	// Position of RxDataRight field.
	SPDIF_SRR_RxDataRight_Pos = 0x0
	// Bit mask of RxDataRight field.
	SPDIF_SRR_RxDataRight_Msk = 0xffffff

	// SRCSH: SPDIFRxCChannel_h Register
	// Position of RxCChannel_h field.
	SPDIF_SRCSH_RxCChannel_h_Pos = 0x0
	// Bit mask of RxCChannel_h field.
	SPDIF_SRCSH_RxCChannel_h_Msk = 0xffffff

	// SRCSL: SPDIFRxCChannel_l Register
	// Position of RxCChannel_l field.
	SPDIF_SRCSL_RxCChannel_l_Pos = 0x0
	// Bit mask of RxCChannel_l field.
	SPDIF_SRCSL_RxCChannel_l_Msk = 0xffffff

	// SRU: UchannelRx Register
	// Position of RxUChannel field.
	SPDIF_SRU_RxUChannel_Pos = 0x0
	// Bit mask of RxUChannel field.
	SPDIF_SRU_RxUChannel_Msk = 0xffffff

	// SRQ: QchannelRx Register
	// Position of RxQChannel field.
	SPDIF_SRQ_RxQChannel_Pos = 0x0
	// Bit mask of RxQChannel field.
	SPDIF_SRQ_RxQChannel_Msk = 0xffffff

	// STL: SPDIFTxLeft Register
	// Position of TxDataLeft field.
	SPDIF_STL_TxDataLeft_Pos = 0x0
	// Bit mask of TxDataLeft field.
	SPDIF_STL_TxDataLeft_Msk = 0xffffff

	// STR: SPDIFTxRight Register
	// Position of TxDataRight field.
	SPDIF_STR_TxDataRight_Pos = 0x0
	// Bit mask of TxDataRight field.
	SPDIF_STR_TxDataRight_Msk = 0xffffff

	// STCSCH: SPDIFTxCChannelCons_h Register
	// Position of TxCChannelCons_h field.
	SPDIF_STCSCH_TxCChannelCons_h_Pos = 0x0
	// Bit mask of TxCChannelCons_h field.
	SPDIF_STCSCH_TxCChannelCons_h_Msk = 0xffffff

	// STCSCL: SPDIFTxCChannelCons_l Register
	// Position of TxCChannelCons_l field.
	SPDIF_STCSCL_TxCChannelCons_l_Pos = 0x0
	// Bit mask of TxCChannelCons_l field.
	SPDIF_STCSCL_TxCChannelCons_l_Msk = 0xffffff

	// SRFM: FreqMeas Register
	// Position of FreqMeas field.
	SPDIF_SRFM_FreqMeas_Pos = 0x0
	// Bit mask of FreqMeas field.
	SPDIF_SRFM_FreqMeas_Msk = 0xffffff

	// STC: SPDIFTxClk Register
	// Position of TxClk_DF field.
	SPDIF_STC_TxClk_DF_Pos = 0x0
	// Bit mask of TxClk_DF field.
	SPDIF_STC_TxClk_DF_Msk = 0x7f
	// divider factor is 1
	SPDIF_STC_TxClk_DF_TxClk_DF_0 = 0x0
	// divider factor is 2
	SPDIF_STC_TxClk_DF_TxClk_DF_1 = 0x1
	// divider factor is 128
	SPDIF_STC_TxClk_DF_TxClk_DF_127 = 0x7f
	// Position of TX_ALL_CLK_EN field.
	SPDIF_STC_TX_ALL_CLK_EN_Pos = 0x7
	// Bit mask of TX_ALL_CLK_EN field.
	SPDIF_STC_TX_ALL_CLK_EN_Msk = 0x80
	// Bit TX_ALL_CLK_EN.
	SPDIF_STC_TX_ALL_CLK_EN = 0x80
	// disable transfer clock.
	SPDIF_STC_TX_ALL_CLK_EN_TX_ALL_CLK_EN_0 = 0x0
	// enable transfer clock.
	SPDIF_STC_TX_ALL_CLK_EN_TX_ALL_CLK_EN_1 = 0x1
	// Position of TxClk_Source field.
	SPDIF_STC_TxClk_Source_Pos = 0x8
	// Bit mask of TxClk_Source field.
	SPDIF_STC_TxClk_Source_Msk = 0x700
	// XTALOSC input (XTALOSC clock)
	SPDIF_STC_TxClk_Source_TxClk_Source_0 = 0x0
	// tx_clk input (from SPDIF0_CLK_ROOT. See CCM.)
	SPDIF_STC_TxClk_Source_TxClk_Source_1 = 0x1
	// tx_clk1 (from SAI1)
	SPDIF_STC_TxClk_Source_TxClk_Source_2 = 0x2
	// tx_clk2 SPDIF_EXT_CLK, from pads
	SPDIF_STC_TxClk_Source_TxClk_Source_3 = 0x3
	// tx_clk3 (from SAI2)
	SPDIF_STC_TxClk_Source_TxClk_Source_4 = 0x4
	// ipg_clk input (frequency divided)
	SPDIF_STC_TxClk_Source_TxClk_Source_5 = 0x5
	// tx_clk4 (from SAI3)
	SPDIF_STC_TxClk_Source_TxClk_Source_6 = 0x6
	// Position of SYSCLK_DF field.
	SPDIF_STC_SYSCLK_DF_Pos = 0xb
	// Bit mask of SYSCLK_DF field.
	SPDIF_STC_SYSCLK_DF_Msk = 0xff800
	// no clock signal
	SPDIF_STC_SYSCLK_DF_SYSCLK_DF_0 = 0x0
	// divider factor is 2
	SPDIF_STC_SYSCLK_DF_SYSCLK_DF_1 = 0x1
	// divider factor is 512
	SPDIF_STC_SYSCLK_DF_SYSCLK_DF_511 = 0x1ff
)

// Constants for SAI1: I2S
const (
	// VERID: Version ID Register
	// Position of FEATURE field.
	I2S_VERID_FEATURE_Pos = 0x0
	// Bit mask of FEATURE field.
	I2S_VERID_FEATURE_Msk = 0xffff
	// Standard feature set.
	I2S_VERID_FEATURE_FEATURE_0 = 0x0
	// Position of MINOR field.
	I2S_VERID_MINOR_Pos = 0x10
	// Bit mask of MINOR field.
	I2S_VERID_MINOR_Msk = 0xff0000
	// Position of MAJOR field.
	I2S_VERID_MAJOR_Pos = 0x18
	// Bit mask of MAJOR field.
	I2S_VERID_MAJOR_Msk = 0xff000000

	// PARAM: Parameter Register
	// Position of DATALINE field.
	I2S_PARAM_DATALINE_Pos = 0x0
	// Bit mask of DATALINE field.
	I2S_PARAM_DATALINE_Msk = 0xf
	// Position of FIFO field.
	I2S_PARAM_FIFO_Pos = 0x8
	// Bit mask of FIFO field.
	I2S_PARAM_FIFO_Msk = 0xf00
	// Position of FRAME field.
	I2S_PARAM_FRAME_Pos = 0x10
	// Bit mask of FRAME field.
	I2S_PARAM_FRAME_Msk = 0xf0000

	// TCSR: SAI Transmit Control Register
	// Position of FRDE field.
	I2S_TCSR_FRDE_Pos = 0x0
	// Bit mask of FRDE field.
	I2S_TCSR_FRDE_Msk = 0x1
	// Bit FRDE.
	I2S_TCSR_FRDE = 0x1
	// Disables the DMA request.
	I2S_TCSR_FRDE_FRDE_0 = 0x0
	// Enables the DMA request.
	I2S_TCSR_FRDE_FRDE_1 = 0x1
	// Position of FWDE field.
	I2S_TCSR_FWDE_Pos = 0x1
	// Bit mask of FWDE field.
	I2S_TCSR_FWDE_Msk = 0x2
	// Bit FWDE.
	I2S_TCSR_FWDE = 0x2
	// Disables the DMA request.
	I2S_TCSR_FWDE_FWDE_0 = 0x0
	// Enables the DMA request.
	I2S_TCSR_FWDE_FWDE_1 = 0x1
	// Position of FRIE field.
	I2S_TCSR_FRIE_Pos = 0x8
	// Bit mask of FRIE field.
	I2S_TCSR_FRIE_Msk = 0x100
	// Bit FRIE.
	I2S_TCSR_FRIE = 0x100
	// Disables the interrupt.
	I2S_TCSR_FRIE_FRIE_0 = 0x0
	// Enables the interrupt.
	I2S_TCSR_FRIE_FRIE_1 = 0x1
	// Position of FWIE field.
	I2S_TCSR_FWIE_Pos = 0x9
	// Bit mask of FWIE field.
	I2S_TCSR_FWIE_Msk = 0x200
	// Bit FWIE.
	I2S_TCSR_FWIE = 0x200
	// Disables the interrupt.
	I2S_TCSR_FWIE_FWIE_0 = 0x0
	// Enables the interrupt.
	I2S_TCSR_FWIE_FWIE_1 = 0x1
	// Position of FEIE field.
	I2S_TCSR_FEIE_Pos = 0xa
	// Bit mask of FEIE field.
	I2S_TCSR_FEIE_Msk = 0x400
	// Bit FEIE.
	I2S_TCSR_FEIE = 0x400
	// Disables the interrupt.
	I2S_TCSR_FEIE_FEIE_0 = 0x0
	// Enables the interrupt.
	I2S_TCSR_FEIE_FEIE_1 = 0x1
	// Position of SEIE field.
	I2S_TCSR_SEIE_Pos = 0xb
	// Bit mask of SEIE field.
	I2S_TCSR_SEIE_Msk = 0x800
	// Bit SEIE.
	I2S_TCSR_SEIE = 0x800
	// Disables interrupt.
	I2S_TCSR_SEIE_SEIE_0 = 0x0
	// Enables interrupt.
	I2S_TCSR_SEIE_SEIE_1 = 0x1
	// Position of WSIE field.
	I2S_TCSR_WSIE_Pos = 0xc
	// Bit mask of WSIE field.
	I2S_TCSR_WSIE_Msk = 0x1000
	// Bit WSIE.
	I2S_TCSR_WSIE = 0x1000
	// Disables interrupt.
	I2S_TCSR_WSIE_WSIE_0 = 0x0
	// Enables interrupt.
	I2S_TCSR_WSIE_WSIE_1 = 0x1
	// Position of FRF field.
	I2S_TCSR_FRF_Pos = 0x10
	// Bit mask of FRF field.
	I2S_TCSR_FRF_Msk = 0x10000
	// Bit FRF.
	I2S_TCSR_FRF = 0x10000
	// Transmit FIFO watermark has not been reached.
	I2S_TCSR_FRF_FRF_0 = 0x0
	// Transmit FIFO watermark has been reached.
	I2S_TCSR_FRF_FRF_1 = 0x1
	// Position of FWF field.
	I2S_TCSR_FWF_Pos = 0x11
	// Bit mask of FWF field.
	I2S_TCSR_FWF_Msk = 0x20000
	// Bit FWF.
	I2S_TCSR_FWF = 0x20000
	// No enabled transmit FIFO is empty.
	I2S_TCSR_FWF_FWF_0 = 0x0
	// Enabled transmit FIFO is empty.
	I2S_TCSR_FWF_FWF_1 = 0x1
	// Position of FEF field.
	I2S_TCSR_FEF_Pos = 0x12
	// Bit mask of FEF field.
	I2S_TCSR_FEF_Msk = 0x40000
	// Bit FEF.
	I2S_TCSR_FEF = 0x40000
	// Transmit underrun not detected.
	I2S_TCSR_FEF_FEF_0 = 0x0
	// Transmit underrun detected.
	I2S_TCSR_FEF_FEF_1 = 0x1
	// Position of SEF field.
	I2S_TCSR_SEF_Pos = 0x13
	// Bit mask of SEF field.
	I2S_TCSR_SEF_Msk = 0x80000
	// Bit SEF.
	I2S_TCSR_SEF = 0x80000
	// Sync error not detected.
	I2S_TCSR_SEF_SEF_0 = 0x0
	// Frame sync error detected.
	I2S_TCSR_SEF_SEF_1 = 0x1
	// Position of WSF field.
	I2S_TCSR_WSF_Pos = 0x14
	// Bit mask of WSF field.
	I2S_TCSR_WSF_Msk = 0x100000
	// Bit WSF.
	I2S_TCSR_WSF = 0x100000
	// Start of word not detected.
	I2S_TCSR_WSF_WSF_0 = 0x0
	// Start of word detected.
	I2S_TCSR_WSF_WSF_1 = 0x1
	// Position of SR field.
	I2S_TCSR_SR_Pos = 0x18
	// Bit mask of SR field.
	I2S_TCSR_SR_Msk = 0x1000000
	// Bit SR.
	I2S_TCSR_SR = 0x1000000
	// No effect.
	I2S_TCSR_SR_SR_0 = 0x0
	// Software reset.
	I2S_TCSR_SR_SR_1 = 0x1
	// Position of FR field.
	I2S_TCSR_FR_Pos = 0x19
	// Bit mask of FR field.
	I2S_TCSR_FR_Msk = 0x2000000
	// Bit FR.
	I2S_TCSR_FR = 0x2000000
	// No effect.
	I2S_TCSR_FR_FR_0 = 0x0
	// FIFO reset.
	I2S_TCSR_FR_FR_1 = 0x1
	// Position of BCE field.
	I2S_TCSR_BCE_Pos = 0x1c
	// Bit mask of BCE field.
	I2S_TCSR_BCE_Msk = 0x10000000
	// Bit BCE.
	I2S_TCSR_BCE = 0x10000000
	// Transmit bit clock is disabled.
	I2S_TCSR_BCE_BCE_0 = 0x0
	// Transmit bit clock is enabled.
	I2S_TCSR_BCE_BCE_1 = 0x1
	// Position of DBGE field.
	I2S_TCSR_DBGE_Pos = 0x1d
	// Bit mask of DBGE field.
	I2S_TCSR_DBGE_Msk = 0x20000000
	// Bit DBGE.
	I2S_TCSR_DBGE = 0x20000000
	// Transmitter is disabled in Debug mode, after completing the current frame.
	I2S_TCSR_DBGE_DBGE_0 = 0x0
	// Transmitter is enabled in Debug mode.
	I2S_TCSR_DBGE_DBGE_1 = 0x1
	// Position of STOPE field.
	I2S_TCSR_STOPE_Pos = 0x1e
	// Bit mask of STOPE field.
	I2S_TCSR_STOPE_Msk = 0x40000000
	// Bit STOPE.
	I2S_TCSR_STOPE = 0x40000000
	// Transmitter disabled in Stop mode.
	I2S_TCSR_STOPE_STOPE_0 = 0x0
	// Transmitter enabled in Stop mode.
	I2S_TCSR_STOPE_STOPE_1 = 0x1
	// Position of TE field.
	I2S_TCSR_TE_Pos = 0x1f
	// Bit mask of TE field.
	I2S_TCSR_TE_Msk = 0x80000000
	// Bit TE.
	I2S_TCSR_TE = 0x80000000
	// Transmitter is disabled.
	I2S_TCSR_TE_TE_0 = 0x0
	// Transmitter is enabled, or transmitter has been disabled and has not yet reached end of frame.
	I2S_TCSR_TE_TE_1 = 0x1

	// TCR1: SAI Transmit Configuration 1 Register
	// Position of TFW field.
	I2S_TCR1_TFW_Pos = 0x0
	// Bit mask of TFW field.
	I2S_TCR1_TFW_Msk = 0x1f

	// TCR2: SAI Transmit Configuration 2 Register
	// Position of DIV field.
	I2S_TCR2_DIV_Pos = 0x0
	// Bit mask of DIV field.
	I2S_TCR2_DIV_Msk = 0xff
	// Position of BCD field.
	I2S_TCR2_BCD_Pos = 0x18
	// Bit mask of BCD field.
	I2S_TCR2_BCD_Msk = 0x1000000
	// Bit BCD.
	I2S_TCR2_BCD = 0x1000000
	// Bit clock is generated externally in Slave mode.
	I2S_TCR2_BCD_BCD_0 = 0x0
	// Bit clock is generated internally in Master mode.
	I2S_TCR2_BCD_BCD_1 = 0x1
	// Position of BCP field.
	I2S_TCR2_BCP_Pos = 0x19
	// Bit mask of BCP field.
	I2S_TCR2_BCP_Msk = 0x2000000
	// Bit BCP.
	I2S_TCR2_BCP = 0x2000000
	// Bit clock is active high with drive outputs on rising edge and sample inputs on falling edge.
	I2S_TCR2_BCP_BCP_0 = 0x0
	// Bit clock is active low with drive outputs on falling edge and sample inputs on rising edge.
	I2S_TCR2_BCP_BCP_1 = 0x1
	// Position of MSEL field.
	I2S_TCR2_MSEL_Pos = 0x1a
	// Bit mask of MSEL field.
	I2S_TCR2_MSEL_Msk = 0xc000000
	// Bus Clock selected.
	I2S_TCR2_MSEL_MSEL_0 = 0x0
	// Master Clock (MCLK) 1 option selected.
	I2S_TCR2_MSEL_MSEL_1 = 0x1
	// Master Clock (MCLK) 2 option selected.
	I2S_TCR2_MSEL_MSEL_2 = 0x2
	// Master Clock (MCLK) 3 option selected.
	I2S_TCR2_MSEL_MSEL_3 = 0x3
	// Position of BCI field.
	I2S_TCR2_BCI_Pos = 0x1c
	// Bit mask of BCI field.
	I2S_TCR2_BCI_Msk = 0x10000000
	// Bit BCI.
	I2S_TCR2_BCI = 0x10000000
	// No effect.
	I2S_TCR2_BCI_BCI_0 = 0x0
	// Internal logic is clocked as if bit clock was externally generated.
	I2S_TCR2_BCI_BCI_1 = 0x1
	// Position of BCS field.
	I2S_TCR2_BCS_Pos = 0x1d
	// Bit mask of BCS field.
	I2S_TCR2_BCS_Msk = 0x20000000
	// Bit BCS.
	I2S_TCR2_BCS = 0x20000000
	// Use the normal bit clock source.
	I2S_TCR2_BCS_BCS_0 = 0x0
	// Swap the bit clock source.
	I2S_TCR2_BCS_BCS_1 = 0x1
	// Position of SYNC field.
	I2S_TCR2_SYNC_Pos = 0x1e
	// Bit mask of SYNC field.
	I2S_TCR2_SYNC_Msk = 0xc0000000
	// Asynchronous mode.
	I2S_TCR2_SYNC_SYNC_0 = 0x0
	// Synchronous with receiver.
	I2S_TCR2_SYNC_SYNC_1 = 0x1

	// TCR3: SAI Transmit Configuration 3 Register
	// Position of WDFL field.
	I2S_TCR3_WDFL_Pos = 0x0
	// Bit mask of WDFL field.
	I2S_TCR3_WDFL_Msk = 0x1f
	// Position of TCE field.
	I2S_TCR3_TCE_Pos = 0x10
	// Bit mask of TCE field.
	I2S_TCR3_TCE_Msk = 0x30000
	// Position of CFR field.
	I2S_TCR3_CFR_Pos = 0x18
	// Bit mask of CFR field.
	I2S_TCR3_CFR_Msk = 0x3000000

	// TCR4: SAI Transmit Configuration 4 Register
	// Position of FSD field.
	I2S_TCR4_FSD_Pos = 0x0
	// Bit mask of FSD field.
	I2S_TCR4_FSD_Msk = 0x1
	// Bit FSD.
	I2S_TCR4_FSD = 0x1
	// Frame sync is generated externally in Slave mode.
	I2S_TCR4_FSD_FSD_0 = 0x0
	// Frame sync is generated internally in Master mode.
	I2S_TCR4_FSD_FSD_1 = 0x1
	// Position of FSP field.
	I2S_TCR4_FSP_Pos = 0x1
	// Bit mask of FSP field.
	I2S_TCR4_FSP_Msk = 0x2
	// Bit FSP.
	I2S_TCR4_FSP = 0x2
	// Frame sync is active high.
	I2S_TCR4_FSP_FSP_0 = 0x0
	// Frame sync is active low.
	I2S_TCR4_FSP_FSP_1 = 0x1
	// Position of ONDEM field.
	I2S_TCR4_ONDEM_Pos = 0x2
	// Bit mask of ONDEM field.
	I2S_TCR4_ONDEM_Msk = 0x4
	// Bit ONDEM.
	I2S_TCR4_ONDEM = 0x4
	// Internal frame sync is generated continuously.
	I2S_TCR4_ONDEM_ONDEM_0 = 0x0
	// Internal frame sync is generated when the FIFO warning flag is clear.
	I2S_TCR4_ONDEM_ONDEM_1 = 0x1
	// Position of FSE field.
	I2S_TCR4_FSE_Pos = 0x3
	// Bit mask of FSE field.
	I2S_TCR4_FSE_Msk = 0x8
	// Bit FSE.
	I2S_TCR4_FSE = 0x8
	// Frame sync asserts with the first bit of the frame.
	I2S_TCR4_FSE_FSE_0 = 0x0
	// Frame sync asserts one bit before the first bit of the frame.
	I2S_TCR4_FSE_FSE_1 = 0x1
	// Position of MF field.
	I2S_TCR4_MF_Pos = 0x4
	// Bit mask of MF field.
	I2S_TCR4_MF_Msk = 0x10
	// Bit MF.
	I2S_TCR4_MF = 0x10
	// LSB is transmitted first.
	I2S_TCR4_MF_MF_0 = 0x0
	// MSB is transmitted first.
	I2S_TCR4_MF_MF_1 = 0x1
	// Position of CHMOD field.
	I2S_TCR4_CHMOD_Pos = 0x5
	// Bit mask of CHMOD field.
	I2S_TCR4_CHMOD_Msk = 0x20
	// Bit CHMOD.
	I2S_TCR4_CHMOD = 0x20
	// TDM mode, transmit data pins are tri-stated when slots are masked or channels are disabled.
	I2S_TCR4_CHMOD_CHMOD_0 = 0x0
	// Output mode, transmit data pins are never tri-stated and will output zero when slots are masked or channels are disabled.
	I2S_TCR4_CHMOD_CHMOD_1 = 0x1
	// Position of SYWD field.
	I2S_TCR4_SYWD_Pos = 0x8
	// Bit mask of SYWD field.
	I2S_TCR4_SYWD_Msk = 0x1f00
	// Position of FRSZ field.
	I2S_TCR4_FRSZ_Pos = 0x10
	// Bit mask of FRSZ field.
	I2S_TCR4_FRSZ_Msk = 0x1f0000
	// Position of FPACK field.
	I2S_TCR4_FPACK_Pos = 0x18
	// Bit mask of FPACK field.
	I2S_TCR4_FPACK_Msk = 0x3000000
	// FIFO packing is disabled
	I2S_TCR4_FPACK_FPACK_0 = 0x0
	// 8-bit FIFO packing is enabled
	I2S_TCR4_FPACK_FPACK_2 = 0x2
	// 16-bit FIFO packing is enabled
	I2S_TCR4_FPACK_FPACK_3 = 0x3
	// Position of FCOMB field.
	I2S_TCR4_FCOMB_Pos = 0x1a
	// Bit mask of FCOMB field.
	I2S_TCR4_FCOMB_Msk = 0xc000000
	// FIFO combine mode disabled.
	I2S_TCR4_FCOMB_FCOMB_0 = 0x0
	// FIFO combine mode enabled on FIFO reads (from transmit shift registers).
	I2S_TCR4_FCOMB_FCOMB_1 = 0x1
	// FIFO combine mode enabled on FIFO writes (by software).
	I2S_TCR4_FCOMB_FCOMB_2 = 0x2
	// FIFO combine mode enabled on FIFO reads (from transmit shift registers) and writes (by software).
	I2S_TCR4_FCOMB_FCOMB_3 = 0x3
	// Position of FCONT field.
	I2S_TCR4_FCONT_Pos = 0x1c
	// Bit mask of FCONT field.
	I2S_TCR4_FCONT_Msk = 0x10000000
	// Bit FCONT.
	I2S_TCR4_FCONT = 0x10000000
	// On FIFO error, the SAI will continue from the start of the next frame after the FIFO error flag has been cleared.
	I2S_TCR4_FCONT_FCONT_0 = 0x0
	// On FIFO error, the SAI will continue from the same word that caused the FIFO error to set after the FIFO warning flag has been cleared.
	I2S_TCR4_FCONT_FCONT_1 = 0x1

	// TCR5: SAI Transmit Configuration 5 Register
	// Position of FBT field.
	I2S_TCR5_FBT_Pos = 0x8
	// Bit mask of FBT field.
	I2S_TCR5_FBT_Msk = 0x1f00
	// Position of W0W field.
	I2S_TCR5_W0W_Pos = 0x10
	// Bit mask of W0W field.
	I2S_TCR5_W0W_Msk = 0x1f0000
	// Position of WNW field.
	I2S_TCR5_WNW_Pos = 0x18
	// Bit mask of WNW field.
	I2S_TCR5_WNW_Msk = 0x1f000000

	// TDR: SAI Transmit Data Register
	// Position of TDR field.
	I2S_TDR_TDR_Pos = 0x0
	// Bit mask of TDR field.
	I2S_TDR_TDR_Msk = 0xffffffff

	// TFR: SAI Transmit FIFO Register
	// Position of RFP field.
	I2S_TFR_RFP_Pos = 0x0
	// Bit mask of RFP field.
	I2S_TFR_RFP_Msk = 0x3f
	// Position of WFP field.
	I2S_TFR_WFP_Pos = 0x10
	// Bit mask of WFP field.
	I2S_TFR_WFP_Msk = 0x3f0000
	// Position of WCP field.
	I2S_TFR_WCP_Pos = 0x1f
	// Bit mask of WCP field.
	I2S_TFR_WCP_Msk = 0x80000000
	// Bit WCP.
	I2S_TFR_WCP = 0x80000000
	// No effect.
	I2S_TFR_WCP_WCP_0 = 0x0
	// FIFO combine is enabled for FIFO writes and this FIFO will be written on the next FIFO write.
	I2S_TFR_WCP_WCP_1 = 0x1

	// TMR: SAI Transmit Mask Register
	// Position of TWM field.
	I2S_TMR_TWM_Pos = 0x0
	// Bit mask of TWM field.
	I2S_TMR_TWM_Msk = 0xffffffff
	// Word N is enabled.
	I2S_TMR_TWM_TWM_0 = 0x0
	// Word N is masked. The transmit data pins are tri-stated or drive zero when masked.
	I2S_TMR_TWM_TWM_1 = 0x1

	// RCSR: SAI Receive Control Register
	// Position of FRDE field.
	I2S_RCSR_FRDE_Pos = 0x0
	// Bit mask of FRDE field.
	I2S_RCSR_FRDE_Msk = 0x1
	// Bit FRDE.
	I2S_RCSR_FRDE = 0x1
	// Disables the DMA request.
	I2S_RCSR_FRDE_FRDE_0 = 0x0
	// Enables the DMA request.
	I2S_RCSR_FRDE_FRDE_1 = 0x1
	// Position of FWDE field.
	I2S_RCSR_FWDE_Pos = 0x1
	// Bit mask of FWDE field.
	I2S_RCSR_FWDE_Msk = 0x2
	// Bit FWDE.
	I2S_RCSR_FWDE = 0x2
	// Disables the DMA request.
	I2S_RCSR_FWDE_FWDE_0 = 0x0
	// Enables the DMA request.
	I2S_RCSR_FWDE_FWDE_1 = 0x1
	// Position of FRIE field.
	I2S_RCSR_FRIE_Pos = 0x8
	// Bit mask of FRIE field.
	I2S_RCSR_FRIE_Msk = 0x100
	// Bit FRIE.
	I2S_RCSR_FRIE = 0x100
	// Disables the interrupt.
	I2S_RCSR_FRIE_FRIE_0 = 0x0
	// Enables the interrupt.
	I2S_RCSR_FRIE_FRIE_1 = 0x1
	// Position of FWIE field.
	I2S_RCSR_FWIE_Pos = 0x9
	// Bit mask of FWIE field.
	I2S_RCSR_FWIE_Msk = 0x200
	// Bit FWIE.
	I2S_RCSR_FWIE = 0x200
	// Disables the interrupt.
	I2S_RCSR_FWIE_FWIE_0 = 0x0
	// Enables the interrupt.
	I2S_RCSR_FWIE_FWIE_1 = 0x1
	// Position of FEIE field.
	I2S_RCSR_FEIE_Pos = 0xa
	// Bit mask of FEIE field.
	I2S_RCSR_FEIE_Msk = 0x400
	// Bit FEIE.
	I2S_RCSR_FEIE = 0x400
	// Disables the interrupt.
	I2S_RCSR_FEIE_FEIE_0 = 0x0
	// Enables the interrupt.
	I2S_RCSR_FEIE_FEIE_1 = 0x1
	// Position of SEIE field.
	I2S_RCSR_SEIE_Pos = 0xb
	// Bit mask of SEIE field.
	I2S_RCSR_SEIE_Msk = 0x800
	// Bit SEIE.
	I2S_RCSR_SEIE = 0x800
	// Disables interrupt.
	I2S_RCSR_SEIE_SEIE_0 = 0x0
	// Enables interrupt.
	I2S_RCSR_SEIE_SEIE_1 = 0x1
	// Position of WSIE field.
	I2S_RCSR_WSIE_Pos = 0xc
	// Bit mask of WSIE field.
	I2S_RCSR_WSIE_Msk = 0x1000
	// Bit WSIE.
	I2S_RCSR_WSIE = 0x1000
	// Disables interrupt.
	I2S_RCSR_WSIE_WSIE_0 = 0x0
	// Enables interrupt.
	I2S_RCSR_WSIE_WSIE_1 = 0x1
	// Position of FRF field.
	I2S_RCSR_FRF_Pos = 0x10
	// Bit mask of FRF field.
	I2S_RCSR_FRF_Msk = 0x10000
	// Bit FRF.
	I2S_RCSR_FRF = 0x10000
	// Receive FIFO watermark not reached.
	I2S_RCSR_FRF_FRF_0 = 0x0
	// Receive FIFO watermark has been reached.
	I2S_RCSR_FRF_FRF_1 = 0x1
	// Position of FWF field.
	I2S_RCSR_FWF_Pos = 0x11
	// Bit mask of FWF field.
	I2S_RCSR_FWF_Msk = 0x20000
	// Bit FWF.
	I2S_RCSR_FWF = 0x20000
	// No enabled receive FIFO is full.
	I2S_RCSR_FWF_FWF_0 = 0x0
	// Enabled receive FIFO is full.
	I2S_RCSR_FWF_FWF_1 = 0x1
	// Position of FEF field.
	I2S_RCSR_FEF_Pos = 0x12
	// Bit mask of FEF field.
	I2S_RCSR_FEF_Msk = 0x40000
	// Bit FEF.
	I2S_RCSR_FEF = 0x40000
	// Receive overflow not detected.
	I2S_RCSR_FEF_FEF_0 = 0x0
	// Receive overflow detected.
	I2S_RCSR_FEF_FEF_1 = 0x1
	// Position of SEF field.
	I2S_RCSR_SEF_Pos = 0x13
	// Bit mask of SEF field.
	I2S_RCSR_SEF_Msk = 0x80000
	// Bit SEF.
	I2S_RCSR_SEF = 0x80000
	// Sync error not detected.
	I2S_RCSR_SEF_SEF_0 = 0x0
	// Frame sync error detected.
	I2S_RCSR_SEF_SEF_1 = 0x1
	// Position of WSF field.
	I2S_RCSR_WSF_Pos = 0x14
	// Bit mask of WSF field.
	I2S_RCSR_WSF_Msk = 0x100000
	// Bit WSF.
	I2S_RCSR_WSF = 0x100000
	// Start of word not detected.
	I2S_RCSR_WSF_WSF_0 = 0x0
	// Start of word detected.
	I2S_RCSR_WSF_WSF_1 = 0x1
	// Position of SR field.
	I2S_RCSR_SR_Pos = 0x18
	// Bit mask of SR field.
	I2S_RCSR_SR_Msk = 0x1000000
	// Bit SR.
	I2S_RCSR_SR = 0x1000000
	// No effect.
	I2S_RCSR_SR_SR_0 = 0x0
	// Software reset.
	I2S_RCSR_SR_SR_1 = 0x1
	// Position of FR field.
	I2S_RCSR_FR_Pos = 0x19
	// Bit mask of FR field.
	I2S_RCSR_FR_Msk = 0x2000000
	// Bit FR.
	I2S_RCSR_FR = 0x2000000
	// No effect.
	I2S_RCSR_FR_FR_0 = 0x0
	// FIFO reset.
	I2S_RCSR_FR_FR_1 = 0x1
	// Position of BCE field.
	I2S_RCSR_BCE_Pos = 0x1c
	// Bit mask of BCE field.
	I2S_RCSR_BCE_Msk = 0x10000000
	// Bit BCE.
	I2S_RCSR_BCE = 0x10000000
	// Receive bit clock is disabled.
	I2S_RCSR_BCE_BCE_0 = 0x0
	// Receive bit clock is enabled.
	I2S_RCSR_BCE_BCE_1 = 0x1
	// Position of DBGE field.
	I2S_RCSR_DBGE_Pos = 0x1d
	// Bit mask of DBGE field.
	I2S_RCSR_DBGE_Msk = 0x20000000
	// Bit DBGE.
	I2S_RCSR_DBGE = 0x20000000
	// Receiver is disabled in Debug mode, after completing the current frame.
	I2S_RCSR_DBGE_DBGE_0 = 0x0
	// Receiver is enabled in Debug mode.
	I2S_RCSR_DBGE_DBGE_1 = 0x1
	// Position of STOPE field.
	I2S_RCSR_STOPE_Pos = 0x1e
	// Bit mask of STOPE field.
	I2S_RCSR_STOPE_Msk = 0x40000000
	// Bit STOPE.
	I2S_RCSR_STOPE = 0x40000000
	// Receiver disabled in Stop mode.
	I2S_RCSR_STOPE_STOPE_0 = 0x0
	// Receiver enabled in Stop mode.
	I2S_RCSR_STOPE_STOPE_1 = 0x1
	// Position of RE field.
	I2S_RCSR_RE_Pos = 0x1f
	// Bit mask of RE field.
	I2S_RCSR_RE_Msk = 0x80000000
	// Bit RE.
	I2S_RCSR_RE = 0x80000000
	// Receiver is disabled.
	I2S_RCSR_RE_RE_0 = 0x0
	// Receiver is enabled, or receiver has been disabled and has not yet reached end of frame.
	I2S_RCSR_RE_RE_1 = 0x1

	// RCR1: SAI Receive Configuration 1 Register
	// Position of RFW field.
	I2S_RCR1_RFW_Pos = 0x0
	// Bit mask of RFW field.
	I2S_RCR1_RFW_Msk = 0x1f

	// RCR2: SAI Receive Configuration 2 Register
	// Position of DIV field.
	I2S_RCR2_DIV_Pos = 0x0
	// Bit mask of DIV field.
	I2S_RCR2_DIV_Msk = 0xff
	// Position of BCD field.
	I2S_RCR2_BCD_Pos = 0x18
	// Bit mask of BCD field.
	I2S_RCR2_BCD_Msk = 0x1000000
	// Bit BCD.
	I2S_RCR2_BCD = 0x1000000
	// Bit clock is generated externally in Slave mode.
	I2S_RCR2_BCD_BCD_0 = 0x0
	// Bit clock is generated internally in Master mode.
	I2S_RCR2_BCD_BCD_1 = 0x1
	// Position of BCP field.
	I2S_RCR2_BCP_Pos = 0x19
	// Bit mask of BCP field.
	I2S_RCR2_BCP_Msk = 0x2000000
	// Bit BCP.
	I2S_RCR2_BCP = 0x2000000
	// Bit Clock is active high with drive outputs on rising edge and sample inputs on falling edge.
	I2S_RCR2_BCP_BCP_0 = 0x0
	// Bit Clock is active low with drive outputs on falling edge and sample inputs on rising edge.
	I2S_RCR2_BCP_BCP_1 = 0x1
	// Position of MSEL field.
	I2S_RCR2_MSEL_Pos = 0x1a
	// Bit mask of MSEL field.
	I2S_RCR2_MSEL_Msk = 0xc000000
	// Bus Clock selected.
	I2S_RCR2_MSEL_MSEL_0 = 0x0
	// Master Clock (MCLK) 1 option selected.
	I2S_RCR2_MSEL_MSEL_1 = 0x1
	// Master Clock (MCLK) 2 option selected.
	I2S_RCR2_MSEL_MSEL_2 = 0x2
	// Master Clock (MCLK) 3 option selected.
	I2S_RCR2_MSEL_MSEL_3 = 0x3
	// Position of BCI field.
	I2S_RCR2_BCI_Pos = 0x1c
	// Bit mask of BCI field.
	I2S_RCR2_BCI_Msk = 0x10000000
	// Bit BCI.
	I2S_RCR2_BCI = 0x10000000
	// No effect.
	I2S_RCR2_BCI_BCI_0 = 0x0
	// Internal logic is clocked as if bit clock was externally generated.
	I2S_RCR2_BCI_BCI_1 = 0x1
	// Position of BCS field.
	I2S_RCR2_BCS_Pos = 0x1d
	// Bit mask of BCS field.
	I2S_RCR2_BCS_Msk = 0x20000000
	// Bit BCS.
	I2S_RCR2_BCS = 0x20000000
	// Use the normal bit clock source.
	I2S_RCR2_BCS_BCS_0 = 0x0
	// Swap the bit clock source.
	I2S_RCR2_BCS_BCS_1 = 0x1
	// Position of SYNC field.
	I2S_RCR2_SYNC_Pos = 0x1e
	// Bit mask of SYNC field.
	I2S_RCR2_SYNC_Msk = 0xc0000000
	// Asynchronous mode.
	I2S_RCR2_SYNC_SYNC_0 = 0x0
	// Synchronous with transmitter.
	I2S_RCR2_SYNC_SYNC_1 = 0x1

	// RCR3: SAI Receive Configuration 3 Register
	// Position of WDFL field.
	I2S_RCR3_WDFL_Pos = 0x0
	// Bit mask of WDFL field.
	I2S_RCR3_WDFL_Msk = 0x1f
	// Position of RCE field.
	I2S_RCR3_RCE_Pos = 0x10
	// Bit mask of RCE field.
	I2S_RCR3_RCE_Msk = 0x30000
	// Position of CFR field.
	I2S_RCR3_CFR_Pos = 0x18
	// Bit mask of CFR field.
	I2S_RCR3_CFR_Msk = 0x3000000

	// RCR4: SAI Receive Configuration 4 Register
	// Position of FSD field.
	I2S_RCR4_FSD_Pos = 0x0
	// Bit mask of FSD field.
	I2S_RCR4_FSD_Msk = 0x1
	// Bit FSD.
	I2S_RCR4_FSD = 0x1
	// Frame Sync is generated externally in Slave mode.
	I2S_RCR4_FSD_FSD_0 = 0x0
	// Frame Sync is generated internally in Master mode.
	I2S_RCR4_FSD_FSD_1 = 0x1
	// Position of FSP field.
	I2S_RCR4_FSP_Pos = 0x1
	// Bit mask of FSP field.
	I2S_RCR4_FSP_Msk = 0x2
	// Bit FSP.
	I2S_RCR4_FSP = 0x2
	// Frame sync is active high.
	I2S_RCR4_FSP_FSP_0 = 0x0
	// Frame sync is active low.
	I2S_RCR4_FSP_FSP_1 = 0x1
	// Position of ONDEM field.
	I2S_RCR4_ONDEM_Pos = 0x2
	// Bit mask of ONDEM field.
	I2S_RCR4_ONDEM_Msk = 0x4
	// Bit ONDEM.
	I2S_RCR4_ONDEM = 0x4
	// Internal frame sync is generated continuously.
	I2S_RCR4_ONDEM_ONDEM_0 = 0x0
	// Internal frame sync is generated when the FIFO warning flag is clear.
	I2S_RCR4_ONDEM_ONDEM_1 = 0x1
	// Position of FSE field.
	I2S_RCR4_FSE_Pos = 0x3
	// Bit mask of FSE field.
	I2S_RCR4_FSE_Msk = 0x8
	// Bit FSE.
	I2S_RCR4_FSE = 0x8
	// Frame sync asserts with the first bit of the frame.
	I2S_RCR4_FSE_FSE_0 = 0x0
	// Frame sync asserts one bit before the first bit of the frame.
	I2S_RCR4_FSE_FSE_1 = 0x1
	// Position of MF field.
	I2S_RCR4_MF_Pos = 0x4
	// Bit mask of MF field.
	I2S_RCR4_MF_Msk = 0x10
	// Bit MF.
	I2S_RCR4_MF = 0x10
	// LSB is received first.
	I2S_RCR4_MF_MF_0 = 0x0
	// MSB is received first.
	I2S_RCR4_MF_MF_1 = 0x1
	// Position of SYWD field.
	I2S_RCR4_SYWD_Pos = 0x8
	// Bit mask of SYWD field.
	I2S_RCR4_SYWD_Msk = 0x1f00
	// Position of FRSZ field.
	I2S_RCR4_FRSZ_Pos = 0x10
	// Bit mask of FRSZ field.
	I2S_RCR4_FRSZ_Msk = 0x1f0000
	// Position of FPACK field.
	I2S_RCR4_FPACK_Pos = 0x18
	// Bit mask of FPACK field.
	I2S_RCR4_FPACK_Msk = 0x3000000
	// FIFO packing is disabled
	I2S_RCR4_FPACK_FPACK_0 = 0x0
	// 8-bit FIFO packing is enabled
	I2S_RCR4_FPACK_FPACK_2 = 0x2
	// 16-bit FIFO packing is enabled
	I2S_RCR4_FPACK_FPACK_3 = 0x3
	// Position of FCOMB field.
	I2S_RCR4_FCOMB_Pos = 0x1a
	// Bit mask of FCOMB field.
	I2S_RCR4_FCOMB_Msk = 0xc000000
	// FIFO combine mode disabled.
	I2S_RCR4_FCOMB_FCOMB_0 = 0x0
	// FIFO combine mode enabled on FIFO writes (from receive shift registers).
	I2S_RCR4_FCOMB_FCOMB_1 = 0x1
	// FIFO combine mode enabled on FIFO reads (by software).
	I2S_RCR4_FCOMB_FCOMB_2 = 0x2
	// FIFO combine mode enabled on FIFO writes (from receive shift registers) and reads (by software).
	I2S_RCR4_FCOMB_FCOMB_3 = 0x3
	// Position of FCONT field.
	I2S_RCR4_FCONT_Pos = 0x1c
	// Bit mask of FCONT field.
	I2S_RCR4_FCONT_Msk = 0x10000000
	// Bit FCONT.
	I2S_RCR4_FCONT = 0x10000000
	// On FIFO error, the SAI will continue from the start of the next frame after the FIFO error flag has been cleared.
	I2S_RCR4_FCONT_FCONT_0 = 0x0
	// On FIFO error, the SAI will continue from the same word that caused the FIFO error to set after the FIFO warning flag has been cleared.
	I2S_RCR4_FCONT_FCONT_1 = 0x1

	// RCR5: SAI Receive Configuration 5 Register
	// Position of FBT field.
	I2S_RCR5_FBT_Pos = 0x8
	// Bit mask of FBT field.
	I2S_RCR5_FBT_Msk = 0x1f00
	// Position of W0W field.
	I2S_RCR5_W0W_Pos = 0x10
	// Bit mask of W0W field.
	I2S_RCR5_W0W_Msk = 0x1f0000
	// Position of WNW field.
	I2S_RCR5_WNW_Pos = 0x18
	// Bit mask of WNW field.
	I2S_RCR5_WNW_Msk = 0x1f000000

	// RDR: SAI Receive Data Register
	// Position of RDR field.
	I2S_RDR_RDR_Pos = 0x0
	// Bit mask of RDR field.
	I2S_RDR_RDR_Msk = 0xffffffff

	// RFR: SAI Receive FIFO Register
	// Position of RFP field.
	I2S_RFR_RFP_Pos = 0x0
	// Bit mask of RFP field.
	I2S_RFR_RFP_Msk = 0x3f
	// Position of RCP field.
	I2S_RFR_RCP_Pos = 0xf
	// Bit mask of RCP field.
	I2S_RFR_RCP_Msk = 0x8000
	// Bit RCP.
	I2S_RFR_RCP = 0x8000
	// No effect.
	I2S_RFR_RCP_RCP_0 = 0x0
	// FIFO combine is enabled for FIFO reads and this FIFO will be read on the next FIFO read.
	I2S_RFR_RCP_RCP_1 = 0x1
	// Position of WFP field.
	I2S_RFR_WFP_Pos = 0x10
	// Bit mask of WFP field.
	I2S_RFR_WFP_Msk = 0x3f0000

	// RMR: SAI Receive Mask Register
	// Position of RWM field.
	I2S_RMR_RWM_Pos = 0x0
	// Bit mask of RWM field.
	I2S_RMR_RWM_Msk = 0xffffffff
	// Word N is enabled.
	I2S_RMR_RWM_RWM_0 = 0x0
	// Word N is masked.
	I2S_RMR_RWM_RWM_1 = 0x1
)

// Constants for GPT1: GPT
const (
	// CR: GPT Control Register
	// Position of EN field.
	GPT_CR_EN_Pos = 0x0
	// Bit mask of EN field.
	GPT_CR_EN_Msk = 0x1
	// Bit EN.
	GPT_CR_EN = 0x1
	// GPT is disabled.
	GPT_CR_EN_EN_0 = 0x0
	// GPT is enabled.
	GPT_CR_EN_EN_1 = 0x1
	// Position of ENMOD field.
	GPT_CR_ENMOD_Pos = 0x1
	// Bit mask of ENMOD field.
	GPT_CR_ENMOD_Msk = 0x2
	// Bit ENMOD.
	GPT_CR_ENMOD = 0x2
	// GPT counter will retain its value when it is disabled.
	GPT_CR_ENMOD_ENMOD_0 = 0x0
	// GPT counter value is reset to 0 when it is disabled.
	GPT_CR_ENMOD_ENMOD_1 = 0x1
	// Position of DBGEN field.
	GPT_CR_DBGEN_Pos = 0x2
	// Bit mask of DBGEN field.
	GPT_CR_DBGEN_Msk = 0x4
	// Bit DBGEN.
	GPT_CR_DBGEN = 0x4
	// GPT is disabled in debug mode.
	GPT_CR_DBGEN_DBGEN_0 = 0x0
	// GPT is enabled in debug mode.
	GPT_CR_DBGEN_DBGEN_1 = 0x1
	// Position of WAITEN field.
	GPT_CR_WAITEN_Pos = 0x3
	// Bit mask of WAITEN field.
	GPT_CR_WAITEN_Msk = 0x8
	// Bit WAITEN.
	GPT_CR_WAITEN = 0x8
	// GPT is disabled in wait mode.
	GPT_CR_WAITEN_WAITEN_0 = 0x0
	// GPT is enabled in wait mode.
	GPT_CR_WAITEN_WAITEN_1 = 0x1
	// Position of DOZEEN field.
	GPT_CR_DOZEEN_Pos = 0x4
	// Bit mask of DOZEEN field.
	GPT_CR_DOZEEN_Msk = 0x10
	// Bit DOZEEN.
	GPT_CR_DOZEEN = 0x10
	// GPT is disabled in doze mode.
	GPT_CR_DOZEEN_DOZEEN_0 = 0x0
	// GPT is enabled in doze mode.
	GPT_CR_DOZEEN_DOZEEN_1 = 0x1
	// Position of STOPEN field.
	GPT_CR_STOPEN_Pos = 0x5
	// Bit mask of STOPEN field.
	GPT_CR_STOPEN_Msk = 0x20
	// Bit STOPEN.
	GPT_CR_STOPEN = 0x20
	// GPT is disabled in Stop mode.
	GPT_CR_STOPEN_STOPEN_0 = 0x0
	// GPT is enabled in Stop mode.
	GPT_CR_STOPEN_STOPEN_1 = 0x1
	// Position of CLKSRC field.
	GPT_CR_CLKSRC_Pos = 0x6
	// Bit mask of CLKSRC field.
	GPT_CR_CLKSRC_Msk = 0x1c0
	// No clock
	GPT_CR_CLKSRC_CLKSRC_0 = 0x0
	// Peripheral Clock (ipg_clk)
	GPT_CR_CLKSRC_CLKSRC_1 = 0x1
	// High Frequency Reference Clock (ipg_clk_highfreq)
	GPT_CR_CLKSRC_CLKSRC_2 = 0x2
	// External Clock
	GPT_CR_CLKSRC_CLKSRC_3 = 0x3
	// Low Frequency Reference Clock (ipg_clk_32k)
	GPT_CR_CLKSRC_CLKSRC_4 = 0x4
	// Crystal oscillator as Reference Clock (ipg_clk_24M)
	GPT_CR_CLKSRC_CLKSRC_5 = 0x5
	// Position of FRR field.
	GPT_CR_FRR_Pos = 0x9
	// Bit mask of FRR field.
	GPT_CR_FRR_Msk = 0x200
	// Bit FRR.
	GPT_CR_FRR = 0x200
	// Restart mode
	GPT_CR_FRR_FRR_0 = 0x0
	// Free-Run mode
	GPT_CR_FRR_FRR_1 = 0x1
	// Position of EN_24M field.
	GPT_CR_EN_24M_Pos = 0xa
	// Bit mask of EN_24M field.
	GPT_CR_EN_24M_Msk = 0x400
	// Bit EN_24M.
	GPT_CR_EN_24M = 0x400
	// 24M clock disabled
	GPT_CR_EN_24M_EN_24M_0 = 0x0
	// 24M clock enabled
	GPT_CR_EN_24M_EN_24M_1 = 0x1
	// Position of SWR field.
	GPT_CR_SWR_Pos = 0xf
	// Bit mask of SWR field.
	GPT_CR_SWR_Msk = 0x8000
	// Bit SWR.
	GPT_CR_SWR = 0x8000
	// GPT is not in reset state
	GPT_CR_SWR_SWR_0 = 0x0
	// GPT is in reset state
	GPT_CR_SWR_SWR_1 = 0x1
	// Position of IM1 field.
	GPT_CR_IM1_Pos = 0x10
	// Bit mask of IM1 field.
	GPT_CR_IM1_Msk = 0x30000
	// Position of IM2 field.
	GPT_CR_IM2_Pos = 0x12
	// Bit mask of IM2 field.
	GPT_CR_IM2_Msk = 0xc0000
	// capture disabled
	GPT_CR_IM2_IM2_0 = 0x0
	// capture on rising edge only
	GPT_CR_IM2_IM2_1 = 0x1
	// capture on falling edge only
	GPT_CR_IM2_IM2_2 = 0x2
	// capture on both edges
	GPT_CR_IM2_IM2_3 = 0x3
	// Position of OM1 field.
	GPT_CR_OM1_Pos = 0x14
	// Bit mask of OM1 field.
	GPT_CR_OM1_Msk = 0x700000
	// Position of OM2 field.
	GPT_CR_OM2_Pos = 0x17
	// Bit mask of OM2 field.
	GPT_CR_OM2_Msk = 0x3800000
	// Position of OM3 field.
	GPT_CR_OM3_Pos = 0x1a
	// Bit mask of OM3 field.
	GPT_CR_OM3_Msk = 0x1c000000
	// Output disconnected. No response on pin.
	GPT_CR_OM3_OM3_0 = 0x0
	// Toggle output pin
	GPT_CR_OM3_OM3_1 = 0x1
	// Clear output pin
	GPT_CR_OM3_OM3_2 = 0x2
	// Set output pin
	GPT_CR_OM3_OM3_3 = 0x3
	// Generate an active low pulse (that is one input clock wide) on the output pin.
	GPT_CR_OM3_OM3_4 = 0x4
	// Position of FO1 field.
	GPT_CR_FO1_Pos = 0x1d
	// Bit mask of FO1 field.
	GPT_CR_FO1_Msk = 0x20000000
	// Bit FO1.
	GPT_CR_FO1 = 0x20000000
	// Position of FO2 field.
	GPT_CR_FO2_Pos = 0x1e
	// Bit mask of FO2 field.
	GPT_CR_FO2_Msk = 0x40000000
	// Bit FO2.
	GPT_CR_FO2 = 0x40000000
	// Position of FO3 field.
	GPT_CR_FO3_Pos = 0x1f
	// Bit mask of FO3 field.
	GPT_CR_FO3_Msk = 0x80000000
	// Bit FO3.
	GPT_CR_FO3 = 0x80000000
	// Writing a 0 has no effect.
	GPT_CR_FO3_FO3_0 = 0x0
	// Causes the programmed pin action on the timer Output Compare n pin; the OFn flag is not set.
	GPT_CR_FO3_FO3_1 = 0x1

	// PR: GPT Prescaler Register
	// Position of PRESCALER field.
	GPT_PR_PRESCALER_Pos = 0x0
	// Bit mask of PRESCALER field.
	GPT_PR_PRESCALER_Msk = 0xfff
	// Divide by 1
	GPT_PR_PRESCALER_PRESCALER_0 = 0x0
	// Divide by 2
	GPT_PR_PRESCALER_PRESCALER_1 = 0x1
	// Divide by 4096
	GPT_PR_PRESCALER_PRESCALER_4095 = 0xfff
	// Position of PRESCALER24M field.
	GPT_PR_PRESCALER24M_Pos = 0xc
	// Bit mask of PRESCALER24M field.
	GPT_PR_PRESCALER24M_Msk = 0xf000
	// Divide by 1
	GPT_PR_PRESCALER24M_PRESCALER24M_0 = 0x0
	// Divide by 2
	GPT_PR_PRESCALER24M_PRESCALER24M_1 = 0x1
	// Divide by 16
	GPT_PR_PRESCALER24M_PRESCALER24M_15 = 0xf

	// SR: GPT Status Register
	// Position of OF1 field.
	GPT_SR_OF1_Pos = 0x0
	// Bit mask of OF1 field.
	GPT_SR_OF1_Msk = 0x1
	// Bit OF1.
	GPT_SR_OF1 = 0x1
	// Position of OF2 field.
	GPT_SR_OF2_Pos = 0x1
	// Bit mask of OF2 field.
	GPT_SR_OF2_Msk = 0x2
	// Bit OF2.
	GPT_SR_OF2 = 0x2
	// Position of OF3 field.
	GPT_SR_OF3_Pos = 0x2
	// Bit mask of OF3 field.
	GPT_SR_OF3_Msk = 0x4
	// Bit OF3.
	GPT_SR_OF3 = 0x4
	// Compare event has not occurred.
	GPT_SR_OF3_OF3_0 = 0x0
	// Compare event has occurred.
	GPT_SR_OF3_OF3_1 = 0x1
	// Position of IF1 field.
	GPT_SR_IF1_Pos = 0x3
	// Bit mask of IF1 field.
	GPT_SR_IF1_Msk = 0x8
	// Bit IF1.
	GPT_SR_IF1 = 0x8
	// Position of IF2 field.
	GPT_SR_IF2_Pos = 0x4
	// Bit mask of IF2 field.
	GPT_SR_IF2_Msk = 0x10
	// Bit IF2.
	GPT_SR_IF2 = 0x10
	// Capture event has not occurred.
	GPT_SR_IF2_IF2_0 = 0x0
	// Capture event has occurred.
	GPT_SR_IF2_IF2_1 = 0x1
	// Position of ROV field.
	GPT_SR_ROV_Pos = 0x5
	// Bit mask of ROV field.
	GPT_SR_ROV_Msk = 0x20
	// Bit ROV.
	GPT_SR_ROV = 0x20
	// Rollover has not occurred.
	GPT_SR_ROV_ROV_0 = 0x0
	// Rollover has occurred.
	GPT_SR_ROV_ROV_1 = 0x1

	// IR: GPT Interrupt Register
	// Position of OF1IE field.
	GPT_IR_OF1IE_Pos = 0x0
	// Bit mask of OF1IE field.
	GPT_IR_OF1IE_Msk = 0x1
	// Bit OF1IE.
	GPT_IR_OF1IE = 0x1
	// Position of OF2IE field.
	GPT_IR_OF2IE_Pos = 0x1
	// Bit mask of OF2IE field.
	GPT_IR_OF2IE_Msk = 0x2
	// Bit OF2IE.
	GPT_IR_OF2IE = 0x2
	// Position of OF3IE field.
	GPT_IR_OF3IE_Pos = 0x2
	// Bit mask of OF3IE field.
	GPT_IR_OF3IE_Msk = 0x4
	// Bit OF3IE.
	GPT_IR_OF3IE = 0x4
	// Output Compare Channel n interrupt is disabled.
	GPT_IR_OF3IE_OF3IE_0 = 0x0
	// Output Compare Channel n interrupt is enabled.
	GPT_IR_OF3IE_OF3IE_1 = 0x1
	// Position of IF1IE field.
	GPT_IR_IF1IE_Pos = 0x3
	// Bit mask of IF1IE field.
	GPT_IR_IF1IE_Msk = 0x8
	// Bit IF1IE.
	GPT_IR_IF1IE = 0x8
	// Position of IF2IE field.
	GPT_IR_IF2IE_Pos = 0x4
	// Bit mask of IF2IE field.
	GPT_IR_IF2IE_Msk = 0x10
	// Bit IF2IE.
	GPT_IR_IF2IE = 0x10
	// IF2IE Input Capture n Interrupt Enable is disabled.
	GPT_IR_IF2IE_IF2IE_0 = 0x0
	// IF2IE Input Capture n Interrupt Enable is enabled.
	GPT_IR_IF2IE_IF2IE_1 = 0x1
	// Position of ROVIE field.
	GPT_IR_ROVIE_Pos = 0x5
	// Bit mask of ROVIE field.
	GPT_IR_ROVIE_Msk = 0x20
	// Bit ROVIE.
	GPT_IR_ROVIE = 0x20
	// Rollover interrupt is disabled.
	GPT_IR_ROVIE_ROVIE_0 = 0x0
	// Rollover interrupt enabled.
	GPT_IR_ROVIE_ROVIE_1 = 0x1

	// OCR1: GPT Output Compare Register 1
	// Position of COMP field.
	GPT_OCR1_COMP_Pos = 0x0
	// Bit mask of COMP field.
	GPT_OCR1_COMP_Msk = 0xffffffff

	// OCR2: GPT Output Compare Register 2
	// Position of COMP field.
	GPT_OCR2_COMP_Pos = 0x0
	// Bit mask of COMP field.
	GPT_OCR2_COMP_Msk = 0xffffffff

	// OCR3: GPT Output Compare Register 3
	// Position of COMP field.
	GPT_OCR3_COMP_Pos = 0x0
	// Bit mask of COMP field.
	GPT_OCR3_COMP_Msk = 0xffffffff

	// ICR1: GPT Input Capture Register 1
	// Position of CAPT field.
	GPT_ICR1_CAPT_Pos = 0x0
	// Bit mask of CAPT field.
	GPT_ICR1_CAPT_Msk = 0xffffffff

	// ICR2: GPT Input Capture Register 2
	// Position of CAPT field.
	GPT_ICR2_CAPT_Pos = 0x0
	// Bit mask of CAPT field.
	GPT_ICR2_CAPT_Msk = 0xffffffff

	// CNT: GPT Counter Register
	// Position of COUNT field.
	GPT_CNT_COUNT_Pos = 0x0
	// Bit mask of COUNT field.
	GPT_CNT_COUNT_Msk = 0xffffffff
)

// Constants for OCOTP: no description available
const (
	// HW_OCOTP_CTRL: OTP Controller Control Register
	// Position of ADDR field.
	OCOTP_HW_OCOTP_CTRL_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	OCOTP_HW_OCOTP_CTRL_ADDR_Msk = 0x3f
	// Position of BUSY field.
	OCOTP_HW_OCOTP_CTRL_BUSY_Pos = 0x8
	// Bit mask of BUSY field.
	OCOTP_HW_OCOTP_CTRL_BUSY_Msk = 0x100
	// Bit BUSY.
	OCOTP_HW_OCOTP_CTRL_BUSY = 0x100
	// Position of ERROR field.
	OCOTP_HW_OCOTP_CTRL_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	OCOTP_HW_OCOTP_CTRL_ERROR_Msk = 0x200
	// Bit ERROR.
	OCOTP_HW_OCOTP_CTRL_ERROR = 0x200
	// Position of RELOAD_SHADOWS field.
	OCOTP_HW_OCOTP_CTRL_RELOAD_SHADOWS_Pos = 0xa
	// Bit mask of RELOAD_SHADOWS field.
	OCOTP_HW_OCOTP_CTRL_RELOAD_SHADOWS_Msk = 0x400
	// Bit RELOAD_SHADOWS.
	OCOTP_HW_OCOTP_CTRL_RELOAD_SHADOWS = 0x400
	// Position of WR_UNLOCK field.
	OCOTP_HW_OCOTP_CTRL_WR_UNLOCK_Pos = 0x10
	// Bit mask of WR_UNLOCK field.
	OCOTP_HW_OCOTP_CTRL_WR_UNLOCK_Msk = 0xffff0000

	// HW_OCOTP_CTRL_SET: OTP Controller Control Register
	// Position of ADDR field.
	OCOTP_HW_OCOTP_CTRL_SET_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	OCOTP_HW_OCOTP_CTRL_SET_ADDR_Msk = 0x3f
	// Position of BUSY field.
	OCOTP_HW_OCOTP_CTRL_SET_BUSY_Pos = 0x8
	// Bit mask of BUSY field.
	OCOTP_HW_OCOTP_CTRL_SET_BUSY_Msk = 0x100
	// Bit BUSY.
	OCOTP_HW_OCOTP_CTRL_SET_BUSY = 0x100
	// Position of ERROR field.
	OCOTP_HW_OCOTP_CTRL_SET_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	OCOTP_HW_OCOTP_CTRL_SET_ERROR_Msk = 0x200
	// Bit ERROR.
	OCOTP_HW_OCOTP_CTRL_SET_ERROR = 0x200
	// Position of RELOAD_SHADOWS field.
	OCOTP_HW_OCOTP_CTRL_SET_RELOAD_SHADOWS_Pos = 0xa
	// Bit mask of RELOAD_SHADOWS field.
	OCOTP_HW_OCOTP_CTRL_SET_RELOAD_SHADOWS_Msk = 0x400
	// Bit RELOAD_SHADOWS.
	OCOTP_HW_OCOTP_CTRL_SET_RELOAD_SHADOWS = 0x400
	// Position of WR_UNLOCK field.
	OCOTP_HW_OCOTP_CTRL_SET_WR_UNLOCK_Pos = 0x10
	// Bit mask of WR_UNLOCK field.
	OCOTP_HW_OCOTP_CTRL_SET_WR_UNLOCK_Msk = 0xffff0000

	// HW_OCOTP_CTRL_CLR: OTP Controller Control Register
	// Position of ADDR field.
	OCOTP_HW_OCOTP_CTRL_CLR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	OCOTP_HW_OCOTP_CTRL_CLR_ADDR_Msk = 0x3f
	// Position of BUSY field.
	OCOTP_HW_OCOTP_CTRL_CLR_BUSY_Pos = 0x8
	// Bit mask of BUSY field.
	OCOTP_HW_OCOTP_CTRL_CLR_BUSY_Msk = 0x100
	// Bit BUSY.
	OCOTP_HW_OCOTP_CTRL_CLR_BUSY = 0x100
	// Position of ERROR field.
	OCOTP_HW_OCOTP_CTRL_CLR_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	OCOTP_HW_OCOTP_CTRL_CLR_ERROR_Msk = 0x200
	// Bit ERROR.
	OCOTP_HW_OCOTP_CTRL_CLR_ERROR = 0x200
	// Position of RELOAD_SHADOWS field.
	OCOTP_HW_OCOTP_CTRL_CLR_RELOAD_SHADOWS_Pos = 0xa
	// Bit mask of RELOAD_SHADOWS field.
	OCOTP_HW_OCOTP_CTRL_CLR_RELOAD_SHADOWS_Msk = 0x400
	// Bit RELOAD_SHADOWS.
	OCOTP_HW_OCOTP_CTRL_CLR_RELOAD_SHADOWS = 0x400
	// Position of WR_UNLOCK field.
	OCOTP_HW_OCOTP_CTRL_CLR_WR_UNLOCK_Pos = 0x10
	// Bit mask of WR_UNLOCK field.
	OCOTP_HW_OCOTP_CTRL_CLR_WR_UNLOCK_Msk = 0xffff0000

	// HW_OCOTP_CTRL_TOG: OTP Controller Control Register
	// Position of ADDR field.
	OCOTP_HW_OCOTP_CTRL_TOG_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	OCOTP_HW_OCOTP_CTRL_TOG_ADDR_Msk = 0x3f
	// Position of BUSY field.
	OCOTP_HW_OCOTP_CTRL_TOG_BUSY_Pos = 0x8
	// Bit mask of BUSY field.
	OCOTP_HW_OCOTP_CTRL_TOG_BUSY_Msk = 0x100
	// Bit BUSY.
	OCOTP_HW_OCOTP_CTRL_TOG_BUSY = 0x100
	// Position of ERROR field.
	OCOTP_HW_OCOTP_CTRL_TOG_ERROR_Pos = 0x9
	// Bit mask of ERROR field.
	OCOTP_HW_OCOTP_CTRL_TOG_ERROR_Msk = 0x200
	// Bit ERROR.
	OCOTP_HW_OCOTP_CTRL_TOG_ERROR = 0x200
	// Position of RELOAD_SHADOWS field.
	OCOTP_HW_OCOTP_CTRL_TOG_RELOAD_SHADOWS_Pos = 0xa
	// Bit mask of RELOAD_SHADOWS field.
	OCOTP_HW_OCOTP_CTRL_TOG_RELOAD_SHADOWS_Msk = 0x400
	// Bit RELOAD_SHADOWS.
	OCOTP_HW_OCOTP_CTRL_TOG_RELOAD_SHADOWS = 0x400
	// Position of WR_UNLOCK field.
	OCOTP_HW_OCOTP_CTRL_TOG_WR_UNLOCK_Pos = 0x10
	// Bit mask of WR_UNLOCK field.
	OCOTP_HW_OCOTP_CTRL_TOG_WR_UNLOCK_Msk = 0xffff0000

	// HW_OCOTP_TIMING: OTP Controller Timing Register
	// Position of STROBE_PROG field.
	OCOTP_HW_OCOTP_TIMING_STROBE_PROG_Pos = 0x0
	// Bit mask of STROBE_PROG field.
	OCOTP_HW_OCOTP_TIMING_STROBE_PROG_Msk = 0xfff
	// Position of RELAX field.
	OCOTP_HW_OCOTP_TIMING_RELAX_Pos = 0xc
	// Bit mask of RELAX field.
	OCOTP_HW_OCOTP_TIMING_RELAX_Msk = 0xf000
	// Position of STROBE_READ field.
	OCOTP_HW_OCOTP_TIMING_STROBE_READ_Pos = 0x10
	// Bit mask of STROBE_READ field.
	OCOTP_HW_OCOTP_TIMING_STROBE_READ_Msk = 0x3f0000
	// Position of WAIT field.
	OCOTP_HW_OCOTP_TIMING_WAIT_Pos = 0x16
	// Bit mask of WAIT field.
	OCOTP_HW_OCOTP_TIMING_WAIT_Msk = 0xfc00000

	// HW_OCOTP_DATA: OTP Controller Write Data Register
	// Position of DATA field.
	OCOTP_HW_OCOTP_DATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	OCOTP_HW_OCOTP_DATA_DATA_Msk = 0xffffffff

	// HW_OCOTP_READ_CTRL: OTP Controller Write Data Register
	// Position of READ_FUSE field.
	OCOTP_HW_OCOTP_READ_CTRL_READ_FUSE_Pos = 0x0
	// Bit mask of READ_FUSE field.
	OCOTP_HW_OCOTP_READ_CTRL_READ_FUSE_Msk = 0x1
	// Bit READ_FUSE.
	OCOTP_HW_OCOTP_READ_CTRL_READ_FUSE = 0x1

	// HW_OCOTP_READ_FUSE_DATA: OTP Controller Read Data Register
	// Position of DATA field.
	OCOTP_HW_OCOTP_READ_FUSE_DATA_DATA_Pos = 0x0
	// Bit mask of DATA field.
	OCOTP_HW_OCOTP_READ_FUSE_DATA_DATA_Msk = 0xffffffff

	// HW_OCOTP_SW_STICKY: Sticky bit Register
	// Position of SRK_REVOKE_LOCK field.
	OCOTP_HW_OCOTP_SW_STICKY_SRK_REVOKE_LOCK_Pos = 0x1
	// Bit mask of SRK_REVOKE_LOCK field.
	OCOTP_HW_OCOTP_SW_STICKY_SRK_REVOKE_LOCK_Msk = 0x2
	// Bit SRK_REVOKE_LOCK.
	OCOTP_HW_OCOTP_SW_STICKY_SRK_REVOKE_LOCK = 0x2
	// Position of FIELD_RETURN_LOCK field.
	OCOTP_HW_OCOTP_SW_STICKY_FIELD_RETURN_LOCK_Pos = 0x2
	// Bit mask of FIELD_RETURN_LOCK field.
	OCOTP_HW_OCOTP_SW_STICKY_FIELD_RETURN_LOCK_Msk = 0x4
	// Bit FIELD_RETURN_LOCK.
	OCOTP_HW_OCOTP_SW_STICKY_FIELD_RETURN_LOCK = 0x4

	// HW_OCOTP_SCS: Software Controllable Signals Register
	// Position of HAB_JDE field.
	OCOTP_HW_OCOTP_SCS_HAB_JDE_Pos = 0x0
	// Bit mask of HAB_JDE field.
	OCOTP_HW_OCOTP_SCS_HAB_JDE_Msk = 0x1
	// Bit HAB_JDE.
	OCOTP_HW_OCOTP_SCS_HAB_JDE = 0x1
	// Position of SPARE field.
	OCOTP_HW_OCOTP_SCS_SPARE_Pos = 0x1
	// Bit mask of SPARE field.
	OCOTP_HW_OCOTP_SCS_SPARE_Msk = 0x7ffffffe
	// Position of LOCK field.
	OCOTP_HW_OCOTP_SCS_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	OCOTP_HW_OCOTP_SCS_LOCK_Msk = 0x80000000
	// Bit LOCK.
	OCOTP_HW_OCOTP_SCS_LOCK = 0x80000000

	// HW_OCOTP_SCS_SET: Software Controllable Signals Register
	// Position of HAB_JDE field.
	OCOTP_HW_OCOTP_SCS_SET_HAB_JDE_Pos = 0x0
	// Bit mask of HAB_JDE field.
	OCOTP_HW_OCOTP_SCS_SET_HAB_JDE_Msk = 0x1
	// Bit HAB_JDE.
	OCOTP_HW_OCOTP_SCS_SET_HAB_JDE = 0x1
	// Position of SPARE field.
	OCOTP_HW_OCOTP_SCS_SET_SPARE_Pos = 0x1
	// Bit mask of SPARE field.
	OCOTP_HW_OCOTP_SCS_SET_SPARE_Msk = 0x7ffffffe
	// Position of LOCK field.
	OCOTP_HW_OCOTP_SCS_SET_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	OCOTP_HW_OCOTP_SCS_SET_LOCK_Msk = 0x80000000
	// Bit LOCK.
	OCOTP_HW_OCOTP_SCS_SET_LOCK = 0x80000000

	// HW_OCOTP_SCS_CLR: Software Controllable Signals Register
	// Position of HAB_JDE field.
	OCOTP_HW_OCOTP_SCS_CLR_HAB_JDE_Pos = 0x0
	// Bit mask of HAB_JDE field.
	OCOTP_HW_OCOTP_SCS_CLR_HAB_JDE_Msk = 0x1
	// Bit HAB_JDE.
	OCOTP_HW_OCOTP_SCS_CLR_HAB_JDE = 0x1
	// Position of SPARE field.
	OCOTP_HW_OCOTP_SCS_CLR_SPARE_Pos = 0x1
	// Bit mask of SPARE field.
	OCOTP_HW_OCOTP_SCS_CLR_SPARE_Msk = 0x7ffffffe
	// Position of LOCK field.
	OCOTP_HW_OCOTP_SCS_CLR_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	OCOTP_HW_OCOTP_SCS_CLR_LOCK_Msk = 0x80000000
	// Bit LOCK.
	OCOTP_HW_OCOTP_SCS_CLR_LOCK = 0x80000000

	// HW_OCOTP_SCS_TOG: Software Controllable Signals Register
	// Position of HAB_JDE field.
	OCOTP_HW_OCOTP_SCS_TOG_HAB_JDE_Pos = 0x0
	// Bit mask of HAB_JDE field.
	OCOTP_HW_OCOTP_SCS_TOG_HAB_JDE_Msk = 0x1
	// Bit HAB_JDE.
	OCOTP_HW_OCOTP_SCS_TOG_HAB_JDE = 0x1
	// Position of SPARE field.
	OCOTP_HW_OCOTP_SCS_TOG_SPARE_Pos = 0x1
	// Bit mask of SPARE field.
	OCOTP_HW_OCOTP_SCS_TOG_SPARE_Msk = 0x7ffffffe
	// Position of LOCK field.
	OCOTP_HW_OCOTP_SCS_TOG_LOCK_Pos = 0x1f
	// Bit mask of LOCK field.
	OCOTP_HW_OCOTP_SCS_TOG_LOCK_Msk = 0x80000000
	// Bit LOCK.
	OCOTP_HW_OCOTP_SCS_TOG_LOCK = 0x80000000

	// HW_OCOTP_VERSION: OTP Controller Version Register
	// Position of STEP field.
	OCOTP_HW_OCOTP_VERSION_STEP_Pos = 0x0
	// Bit mask of STEP field.
	OCOTP_HW_OCOTP_VERSION_STEP_Msk = 0xffff
	// Position of MINOR field.
	OCOTP_HW_OCOTP_VERSION_MINOR_Pos = 0x10
	// Bit mask of MINOR field.
	OCOTP_HW_OCOTP_VERSION_MINOR_Msk = 0xff0000
	// Position of MAJOR field.
	OCOTP_HW_OCOTP_VERSION_MAJOR_Pos = 0x18
	// Bit mask of MAJOR field.
	OCOTP_HW_OCOTP_VERSION_MAJOR_Msk = 0xff000000

	// HW_OCOTP_TIMING2: OTP Controller Timing Register 2
	// Position of RELAX_PROG field.
	OCOTP_HW_OCOTP_TIMING2_RELAX_PROG_Pos = 0x0
	// Bit mask of RELAX_PROG field.
	OCOTP_HW_OCOTP_TIMING2_RELAX_PROG_Msk = 0xfff
	// Position of RELAX_READ field.
	OCOTP_HW_OCOTP_TIMING2_RELAX_READ_Pos = 0x10
	// Bit mask of RELAX_READ field.
	OCOTP_HW_OCOTP_TIMING2_RELAX_READ_Msk = 0x3f0000
	// Position of RELAX1 field.
	OCOTP_HW_OCOTP_TIMING2_RELAX1_Pos = 0x16
	// Bit mask of RELAX1 field.
	OCOTP_HW_OCOTP_TIMING2_RELAX1_Msk = 0x3fc00000

	// HW_OCOTP_LOCK: Value of OTP Bank0 Word0 (Lock controls)
	// Position of TESTER field.
	OCOTP_HW_OCOTP_LOCK_TESTER_Pos = 0x0
	// Bit mask of TESTER field.
	OCOTP_HW_OCOTP_LOCK_TESTER_Msk = 0x3
	// Position of BOOT_CFG field.
	OCOTP_HW_OCOTP_LOCK_BOOT_CFG_Pos = 0x2
	// Bit mask of BOOT_CFG field.
	OCOTP_HW_OCOTP_LOCK_BOOT_CFG_Msk = 0xc
	// Position of MEM_TRIM field.
	OCOTP_HW_OCOTP_LOCK_MEM_TRIM_Pos = 0x4
	// Bit mask of MEM_TRIM field.
	OCOTP_HW_OCOTP_LOCK_MEM_TRIM_Msk = 0x30
	// Position of SJC_RESP field.
	OCOTP_HW_OCOTP_LOCK_SJC_RESP_Pos = 0x6
	// Bit mask of SJC_RESP field.
	OCOTP_HW_OCOTP_LOCK_SJC_RESP_Msk = 0x40
	// Bit SJC_RESP.
	OCOTP_HW_OCOTP_LOCK_SJC_RESP = 0x40
	// Position of MAC_ADDR field.
	OCOTP_HW_OCOTP_LOCK_MAC_ADDR_Pos = 0x8
	// Bit mask of MAC_ADDR field.
	OCOTP_HW_OCOTP_LOCK_MAC_ADDR_Msk = 0x300
	// Position of GP1 field.
	OCOTP_HW_OCOTP_LOCK_GP1_Pos = 0xa
	// Bit mask of GP1 field.
	OCOTP_HW_OCOTP_LOCK_GP1_Msk = 0xc00
	// Position of GP2 field.
	OCOTP_HW_OCOTP_LOCK_GP2_Pos = 0xc
	// Bit mask of GP2 field.
	OCOTP_HW_OCOTP_LOCK_GP2_Msk = 0x3000
	// Position of OTPMK_MSB field.
	OCOTP_HW_OCOTP_LOCK_OTPMK_MSB_Pos = 0xf
	// Bit mask of OTPMK_MSB field.
	OCOTP_HW_OCOTP_LOCK_OTPMK_MSB_Msk = 0x8000
	// Bit OTPMK_MSB.
	OCOTP_HW_OCOTP_LOCK_OTPMK_MSB = 0x8000
	// Position of SW_GP1 field.
	OCOTP_HW_OCOTP_LOCK_SW_GP1_Pos = 0x10
	// Bit mask of SW_GP1 field.
	OCOTP_HW_OCOTP_LOCK_SW_GP1_Msk = 0x10000
	// Bit SW_GP1.
	OCOTP_HW_OCOTP_LOCK_SW_GP1 = 0x10000
	// Position of OTPMK_LSB field.
	OCOTP_HW_OCOTP_LOCK_OTPMK_LSB_Pos = 0x11
	// Bit mask of OTPMK_LSB field.
	OCOTP_HW_OCOTP_LOCK_OTPMK_LSB_Msk = 0x20000
	// Bit OTPMK_LSB.
	OCOTP_HW_OCOTP_LOCK_OTPMK_LSB = 0x20000
	// Position of ANALOG field.
	OCOTP_HW_OCOTP_LOCK_ANALOG_Pos = 0x12
	// Bit mask of ANALOG field.
	OCOTP_HW_OCOTP_LOCK_ANALOG_Msk = 0xc0000
	// Position of OTPMK_CRC field.
	OCOTP_HW_OCOTP_LOCK_OTPMK_CRC_Pos = 0x14
	// Bit mask of OTPMK_CRC field.
	OCOTP_HW_OCOTP_LOCK_OTPMK_CRC_Msk = 0x100000
	// Bit OTPMK_CRC.
	OCOTP_HW_OCOTP_LOCK_OTPMK_CRC = 0x100000
	// Position of SW_GP2_LOCK field.
	OCOTP_HW_OCOTP_LOCK_SW_GP2_LOCK_Pos = 0x15
	// Bit mask of SW_GP2_LOCK field.
	OCOTP_HW_OCOTP_LOCK_SW_GP2_LOCK_Msk = 0x200000
	// Bit SW_GP2_LOCK.
	OCOTP_HW_OCOTP_LOCK_SW_GP2_LOCK = 0x200000
	// Position of MISC_CONF field.
	OCOTP_HW_OCOTP_LOCK_MISC_CONF_Pos = 0x16
	// Bit mask of MISC_CONF field.
	OCOTP_HW_OCOTP_LOCK_MISC_CONF_Msk = 0x400000
	// Bit MISC_CONF.
	OCOTP_HW_OCOTP_LOCK_MISC_CONF = 0x400000
	// Position of SW_GP2_RLOCK field.
	OCOTP_HW_OCOTP_LOCK_SW_GP2_RLOCK_Pos = 0x17
	// Bit mask of SW_GP2_RLOCK field.
	OCOTP_HW_OCOTP_LOCK_SW_GP2_RLOCK_Msk = 0x800000
	// Bit SW_GP2_RLOCK.
	OCOTP_HW_OCOTP_LOCK_SW_GP2_RLOCK = 0x800000
	// Position of GP3 field.
	OCOTP_HW_OCOTP_LOCK_GP3_Pos = 0x1a
	// Bit mask of GP3 field.
	OCOTP_HW_OCOTP_LOCK_GP3_Msk = 0xc000000
	// Position of FIELD_RETURN field.
	OCOTP_HW_OCOTP_LOCK_FIELD_RETURN_Pos = 0x1c
	// Bit mask of FIELD_RETURN field.
	OCOTP_HW_OCOTP_LOCK_FIELD_RETURN_Msk = 0xf0000000

	// HW_OCOTP_CFG0: Value of OTP Bank0 Word1 (Configuration and Manufacturing Info.)
	// Position of BITS field.
	OCOTP_HW_OCOTP_CFG0_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_CFG0_BITS_Msk = 0xffffffff

	// HW_OCOTP_CFG1: Value of OTP Bank0 Word2 (Configuration and Manufacturing Info.)
	// Position of BITS field.
	OCOTP_HW_OCOTP_CFG1_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_CFG1_BITS_Msk = 0xffffffff

	// HW_OCOTP_CFG2: Value of OTP Bank0 Word3 (Configuration and Manufacturing Info.)
	// Position of BITS field.
	OCOTP_HW_OCOTP_CFG2_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_CFG2_BITS_Msk = 0xffffffff

	// HW_OCOTP_CFG3: Value of OTP Bank0 Word4 (Configuration and Manufacturing Info.)
	// Position of BITS field.
	OCOTP_HW_OCOTP_CFG3_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_CFG3_BITS_Msk = 0xffffffff

	// HW_OCOTP_CFG4: Value of OTP Bank0 Word5 (Configuration and Manufacturing Info.)
	// Position of BITS field.
	OCOTP_HW_OCOTP_CFG4_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_CFG4_BITS_Msk = 0xffffffff

	// HW_OCOTP_CFG5: Value of OTP Bank0 Word6 (Configuration and Manufacturing Info.)
	// Position of BITS field.
	OCOTP_HW_OCOTP_CFG5_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_CFG5_BITS_Msk = 0xffffffff

	// HW_OCOTP_CFG6: Value of OTP Bank0 Word7 (Configuration and Manufacturing Info.)
	// Position of BITS field.
	OCOTP_HW_OCOTP_CFG6_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_CFG6_BITS_Msk = 0xffffffff

	// HW_OCOTP_MEM0: Value of OTP Bank1 Word0 (Memory Related Info.)
	// Position of BITS field.
	OCOTP_HW_OCOTP_MEM0_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_MEM0_BITS_Msk = 0xffffffff

	// HW_OCOTP_MEM1: Value of OTP Bank1 Word1 (Memory Related Info.)
	// Position of BITS field.
	OCOTP_HW_OCOTP_MEM1_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_MEM1_BITS_Msk = 0xffffffff

	// HW_OCOTP_MEM2: Value of OTP Bank1 Word2 (Memory Related Info.)
	// Position of BITS field.
	OCOTP_HW_OCOTP_MEM2_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_MEM2_BITS_Msk = 0xffffffff

	// HW_OCOTP_MEM3: Value of OTP Bank1 Word3 (Memory Related Info.)
	// Position of BITS field.
	OCOTP_HW_OCOTP_MEM3_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_MEM3_BITS_Msk = 0xffffffff

	// HW_OCOTP_MEM4: Value of OTP Bank1 Word4 (Memory Related Info.)
	// Position of BITS field.
	OCOTP_HW_OCOTP_MEM4_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_MEM4_BITS_Msk = 0xffffffff

	// HW_OCOTP_ANA0: Value of OTP Bank1 Word5 (Analog Info.)
	// Position of BITS field.
	OCOTP_HW_OCOTP_ANA0_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_ANA0_BITS_Msk = 0xffffffff

	// HW_OCOTP_ANA1: Value of OTP Bank1 Word6 (Analog Info.)
	// Position of BITS field.
	OCOTP_HW_OCOTP_ANA1_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_ANA1_BITS_Msk = 0xffffffff

	// HW_OCOTP_ANA2: Value of OTP Bank1 Word7 (Analog Info.)
	// Position of BITS field.
	OCOTP_HW_OCOTP_ANA2_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_ANA2_BITS_Msk = 0xffffffff

	// HW_OCOTP_SRK0: Shadow Register for OTP Bank3 Word0 (SRK Hash)
	// Position of BITS field.
	OCOTP_HW_OCOTP_SRK0_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_SRK0_BITS_Msk = 0xffffffff

	// HW_OCOTP_SRK1: Shadow Register for OTP Bank3 Word1 (SRK Hash)
	// Position of BITS field.
	OCOTP_HW_OCOTP_SRK1_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_SRK1_BITS_Msk = 0xffffffff

	// HW_OCOTP_SRK2: Shadow Register for OTP Bank3 Word2 (SRK Hash)
	// Position of BITS field.
	OCOTP_HW_OCOTP_SRK2_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_SRK2_BITS_Msk = 0xffffffff

	// HW_OCOTP_SRK3: Shadow Register for OTP Bank3 Word3 (SRK Hash)
	// Position of BITS field.
	OCOTP_HW_OCOTP_SRK3_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_SRK3_BITS_Msk = 0xffffffff

	// HW_OCOTP_SRK4: Shadow Register for OTP Bank3 Word4 (SRK Hash)
	// Position of BITS field.
	OCOTP_HW_OCOTP_SRK4_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_SRK4_BITS_Msk = 0xffffffff

	// HW_OCOTP_SRK5: Shadow Register for OTP Bank3 Word5 (SRK Hash)
	// Position of BITS field.
	OCOTP_HW_OCOTP_SRK5_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_SRK5_BITS_Msk = 0xffffffff

	// HW_OCOTP_SRK6: Shadow Register for OTP Bank3 Word6 (SRK Hash)
	// Position of BITS field.
	OCOTP_HW_OCOTP_SRK6_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_SRK6_BITS_Msk = 0xffffffff

	// HW_OCOTP_SRK7: Shadow Register for OTP Bank3 Word7 (SRK Hash)
	// Position of BITS field.
	OCOTP_HW_OCOTP_SRK7_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_SRK7_BITS_Msk = 0xffffffff

	// HW_OCOTP_SJC_RESP0: Value of OTP Bank4 Word0 (Secure JTAG Response Field)
	// Position of BITS field.
	OCOTP_HW_OCOTP_SJC_RESP0_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_SJC_RESP0_BITS_Msk = 0xffffffff

	// HW_OCOTP_SJC_RESP1: Value of OTP Bank4 Word1 (Secure JTAG Response Field)
	// Position of BITS field.
	OCOTP_HW_OCOTP_SJC_RESP1_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_SJC_RESP1_BITS_Msk = 0xffffffff

	// HW_OCOTP_MAC0: Value of OTP Bank4 Word2 (MAC Address)
	// Position of BITS field.
	OCOTP_HW_OCOTP_MAC0_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_MAC0_BITS_Msk = 0xffffffff

	// HW_OCOTP_MAC1: Value of OTP Bank4 Word3 (MAC Address)
	// Position of BITS field.
	OCOTP_HW_OCOTP_MAC1_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_MAC1_BITS_Msk = 0xffffffff

	// HW_OCOTP_GP3: Value of OTP Bank4 Word4 (MAC Address)
	// Position of BITS field.
	OCOTP_HW_OCOTP_GP3_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_GP3_BITS_Msk = 0xffffffff

	// HW_OCOTP_GP1: Value of OTP Bank4 Word6 (General Purpose Customer Defined Info)
	// Position of BITS field.
	OCOTP_HW_OCOTP_GP1_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_GP1_BITS_Msk = 0xffffffff

	// HW_OCOTP_GP2: Value of OTP Bank4 Word7 (General Purpose Customer Defined Info)
	// Position of BITS field.
	OCOTP_HW_OCOTP_GP2_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_GP2_BITS_Msk = 0xffffffff

	// HW_OCOTP_SW_GP1: Value of OTP Bank5 Word0 (SW GP1)
	// Position of BITS field.
	OCOTP_HW_OCOTP_SW_GP1_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_SW_GP1_BITS_Msk = 0xffffffff

	// HW_OCOTP_SW_GP20: Value of OTP Bank5 Word1 (SW GP2)
	// Position of BITS field.
	OCOTP_HW_OCOTP_SW_GP20_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_SW_GP20_BITS_Msk = 0xffffffff

	// HW_OCOTP_SW_GP21: Value of OTP Bank5 Word2 (SW GP2)
	// Position of BITS field.
	OCOTP_HW_OCOTP_SW_GP21_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_SW_GP21_BITS_Msk = 0xffffffff

	// HW_OCOTP_SW_GP22: Value of OTP Bank5 Word3 (SW GP2)
	// Position of BITS field.
	OCOTP_HW_OCOTP_SW_GP22_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_SW_GP22_BITS_Msk = 0xffffffff

	// HW_OCOTP_SW_GP23: Value of OTP Bank5 Word4 (SW GP2)
	// Position of BITS field.
	OCOTP_HW_OCOTP_SW_GP23_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_SW_GP23_BITS_Msk = 0xffffffff

	// HW_OCOTP_MISC_CONF0: Value of OTP Bank5 Word5 (Misc Conf)
	// Position of BITS field.
	OCOTP_HW_OCOTP_MISC_CONF0_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_MISC_CONF0_BITS_Msk = 0xffffffff

	// HW_OCOTP_MISC_CONF1: Value of OTP Bank5 Word6 (Misc Conf)
	// Position of BITS field.
	OCOTP_HW_OCOTP_MISC_CONF1_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_MISC_CONF1_BITS_Msk = 0xffffffff

	// HW_OCOTP_SRK_REVOKE: Value of OTP Bank5 Word7 (SRK Revoke)
	// Position of BITS field.
	OCOTP_HW_OCOTP_SRK_REVOKE_BITS_Pos = 0x0
	// Bit mask of BITS field.
	OCOTP_HW_OCOTP_SRK_REVOKE_BITS_Msk = 0xffffffff
)

// Constants for IOMUXC: IOMUXC
const (
	// SW_MUX_CTL_PAD_GPIO_AD_14: SW_MUX_CTL_PAD_GPIO_AD_14 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_14_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_14_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: LPI2C1_SCL of instance: LPI2C1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_14_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: LPUART3_CTS_B of instance: LPUART3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_14_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: KPP_COL00 of instance: KPP
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_14_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPUART4_CTS_B of instance: LPUART4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_14_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_IO26 of instance: FLEXIO1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_14_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIOMUX_IO28 of instance: GPIOMUX
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_14_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: REF_CLK_24M of instance: XTAL OSC
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_14_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: XBAR1_INOUT02 of instance: XBAR1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_14_MUX_MODE_ALT7 = 0x7
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_14_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_14_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_14_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_14_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_14
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_14_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_13: SW_MUX_CTL_PAD_GPIO_AD_13 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_13_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_13_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: LPI2C1_SDA of instance: LPI2C1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_13_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: LPUART3_RTS_B of instance: LPUART3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_13_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: KPP_ROW00 of instance: KPP
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_13_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPUART4_RTS_B of instance: LPUART4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_13_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_IO25 of instance: FLEXIO1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_13_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIOMUX_IO27 of instance: GPIOMUX
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_13_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: NMI_GLUE_NMI of instance: NMI_GLUE
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_13_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: JTAG_TMS of instance: JTAG
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_13_MUX_MODE_ALT7 = 0x7
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_13_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_13_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_13_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_13_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_13
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_13_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_12: SW_MUX_CTL_PAD_GPIO_AD_12 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_12_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_12_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: LPSPI2_SCK of instance: LPSPI2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_12_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM1_PWM0_X of instance: FLEXPWM1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_12_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: KPP_COL01 of instance: KPP
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_12_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: PIT_TRIGGER01 of instance: PIT
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_12_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_IO24 of instance: FLEXIO1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_12_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIOMUX_IO26 of instance: GPIOMUX
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_12_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USB_OTG1_PWR of instance: USB
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_12_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: JTAG_TCK of instance: JTAG
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_12_MUX_MODE_ALT7 = 0x7
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_12_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_12_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_12_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_12_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_12
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_12_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_11: SW_MUX_CTL_PAD_GPIO_AD_11 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_11_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_11_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: LPSPI2_PCS0 of instance: LPSPI2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_11_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM1_PWM1_X of instance: FLEXPWM1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_11_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: KPP_ROW01 of instance: KPP
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_11_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: PIT_TRIGGER02 of instance: PIT
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_11_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_IO23 of instance: FLEXIO1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_11_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIOMUX_IO25 of instance: GPIOMUX
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_11_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: WDOG1_B of instance: WDOG1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_11_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: JTAG_MOD of instance: JTAG
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_11_MUX_MODE_ALT7 = 0x7
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_11_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_11_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_11_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_11_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_11
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_11_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_10: SW_MUX_CTL_PAD_GPIO_AD_10 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_10_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_10_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: LPSPI2_SDO of instance: LPSPI2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_10_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM1_PWM2_X of instance: FLEXPWM1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_10_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: KPP_COL02 of instance: KPP
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_10_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: PIT_TRIGGER03 of instance: PIT
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_10_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_IO22 of instance: FLEXIO1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_10_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIOMUX_IO24 of instance: GPIOMUX
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_10_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: OTG1_ID of instance: anatop
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_10_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: JTAG_TDI of instance: JTAG
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_10_MUX_MODE_ALT7 = 0x7
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_10_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_10_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_10_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_10_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_10
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_10_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_09: SW_MUX_CTL_PAD_GPIO_AD_09 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_09_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_09_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: LPSPI2_SDI of instance: LPSPI2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_09_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXPWM1_PWM3_X of instance: FLEXPWM1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_09_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: KPP_ROW02 of instance: KPP
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_09_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: ARM_TRACE_SWO of instance: cm7_mxrt
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_09_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_IO21 of instance: FLEXIO1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_09_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIOMUX_IO23 of instance: GPIOMUX
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_09_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: REF_32K_OUT of instance: anatop
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_09_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: JTAG_TDO of instance: JTAG
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_09_MUX_MODE_ALT7 = 0x7
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_09_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_09_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_09_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_09_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_09
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_09_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_08: SW_MUX_CTL_PAD_GPIO_AD_08 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_08_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_08_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: LPI2C2_SCL of instance: LPI2C2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_08_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: LPUART3_TXD of instance: LPUART3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_08_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: ARM_CM7_TXEV of instance: cm7_mxrt
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_08_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPUART2_CTS_B of instance: LPUART2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_08_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: GPT2_COMPARE3 of instance: GPT2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_08_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIOMUX_IO22 of instance: GPIOMUX
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_08_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: EWM_OUT_B of instance: EWM
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_08_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: JTAG_TRSTB of instance: JTAG
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_08_MUX_MODE_ALT7 = 0x7
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_08_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_08_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_08_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_08_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_08
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_08_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_07: SW_MUX_CTL_PAD_GPIO_AD_07 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_07_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_07_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: LPI2C2_SDA of instance: LPI2C2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_07_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: LPUART3_RXD of instance: LPUART3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_07_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: ARM_CM7_RXEV of instance: cm7_mxrt
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_07_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPUART2_RTS_B of instance: LPUART2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_07_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: GPT2_CAPTURE2 of instance: GPT2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_07_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIOMUX_IO21 of instance: GPIOMUX
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_07_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: OCOTP_FUSE_LATCHED of instance: OCOTP
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_07_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: XBAR1_INOUT03 of instance: XBAR1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_07_MUX_MODE_ALT7 = 0x7
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_07_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_07_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_07_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_07_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_07
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_07_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_06: SW_MUX_CTL_PAD_GPIO_AD_06 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_06_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_06_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: LPSPI1_SCK of instance: LPSPI1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_06_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: PIT_TRIGGER00 of instance: PIT
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_06_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXPWM1_PWM3_A of instance: FLEXPWM1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_06_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: KPP_COL01 of instance: KPP
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_06_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: GPT2_COMPARE2 of instance: GPT2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_06_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIOMUX_IO20 of instance: GPIOMUX
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_06_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: LPI2C1_HREQ of instance: LPI2C1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_06_MUX_MODE_ALT6 = 0x6
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_06_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_06_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_06_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_06_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_06
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_06_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_05: SW_MUX_CTL_PAD_GPIO_AD_05 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_05_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_05_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: LPSPI1_PCS0 of instance: LPSPI1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_05_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: PIT_TRIGGER01 of instance: PIT
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_05_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXPWM1_PWM3_B of instance: FLEXPWM1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_05_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: KPP_ROW01 of instance: KPP
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_05_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: GPT2_CAPTURE1 of instance: GPT2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_05_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIOMUX_IO19 of instance: GPIOMUX
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_05_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_05_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_05_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_05_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_05_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_05
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_05_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_04: SW_MUX_CTL_PAD_GPIO_AD_04 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_04_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_04_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: LPSPI1_SDO of instance: LPSPI1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_04_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: PIT_TRIGGER02 of instance: PIT
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_04_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXPWM1_PWM2_A of instance: FLEXPWM1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_04_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: KPP_COL02 of instance: KPP
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_04_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: GPT2_COMPARE1 of instance: GPT2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_04_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIOMUX_IO18 of instance: GPIOMUX
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_04_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SNVS_HP_VIO_5_CTL of instance: snvs_hp
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_04_MUX_MODE_ALT6 = 0x6
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_04_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_04_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_04_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_04_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_04
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_04_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_03: SW_MUX_CTL_PAD_GPIO_AD_03 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_03_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_03_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: LPSPI1_SDI of instance: LPSPI1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_03_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: PIT_TRIGGER03 of instance: PIT
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_03_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXPWM1_PWM2_B of instance: FLEXPWM1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_03_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: KPP_ROW02 of instance: KPP
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_03_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: GPT2_CLK of instance: GPT2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_03_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIOMUX_IO17 of instance: GPIOMUX
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_03_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SNVS_HP_VIO_5_B of instance: snvs_hp
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_03_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: JTAG_DE_B of instance: JTAG
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_03_MUX_MODE_ALT7 = 0x7
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_03_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_03_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_03_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_03_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_03
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_03_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_02: SW_MUX_CTL_PAD_GPIO_AD_02 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_02_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_02_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: LPUART4_TXD of instance: LPUART4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_02_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: LPSPI1_PCS1 of instance: LPSPI1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_02_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: WDOG2_B of instance: WDOG2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_02_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPI2C2_SCL of instance: LPI2C2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_02_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: MQS_RIGHT of instance: MQS
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_02_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIOMUX_IO16 of instance: GPIOMUX
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_02_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT7 mux port: ARM_CM7_TRACE_CLK of instance: cm7_mxrt
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_02_MUX_MODE_ALT7 = 0x7
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_02_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_02_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_02_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_02_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_02
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_02_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_01: SW_MUX_CTL_PAD_GPIO_AD_01 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_01_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_01_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: LPUART4_RXD of instance: LPUART4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_01_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: LPSPI2_PCS1 of instance: LPSPI2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_01_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: WDOG1_ANY of instance: WDOG1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_01_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPI2C2_SDA of instance: LPI2C2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_01_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: MQS_LEFT of instance: MQS
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_01_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIOMUX_IO15 of instance: GPIOMUX
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_01_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: USB_OTG1_OC of instance: USB
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_01_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: ARM_CM7_TRACE_SWO of instance: cm7_mxrt
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_01_MUX_MODE_ALT7 = 0x7
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_01_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_01_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_01_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_01_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_01
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_01_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_AD_00: SW_MUX_CTL_PAD_GPIO_AD_00 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_00_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_00_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: LPUART2_TXD of instance: LPUART2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_00_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: LPSPI1_PCS2 of instance: LPSPI1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_00_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: KPP_COL03 of instance: KPP
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_00_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: USB_OTG1_PWR of instance: USB
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_00_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_IO20 of instance: FLEXIO1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_00_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIOMUX_IO14 of instance: GPIOMUX
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_00_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: NMI_GLUE_NMI of instance: NMI_GLUE
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_00_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: ARM_CM7_TRACE00 of instance: cm7_mxrt
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_00_MUX_MODE_ALT7 = 0x7
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_00_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_00_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_00_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_00_SION_DISABLED = 0x0
	// Force input path of pad GPIO_AD_00
	IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_00_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_14: SW_MUX_CTL_PAD_GPIO_SD_14 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_14_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_14_MUX_MODE_Msk = 0x1
	// Bit MUX_MODE.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_14_MUX_MODE = 0x1
	// Select mux mode: ALT0 mux port: FLEXSPI_A_DQS of instance: FLEXSPI
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_14_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: FLEXSPI_B_DQS of instance: FLEXSPI
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_14_MUX_MODE_ALT1 = 0x1
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_14_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_14_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_14_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_14_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_14
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_14_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_13: SW_MUX_CTL_PAD_GPIO_SD_13 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_13_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_13_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI_B_SCLK of instance: FLEXSPI
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_13_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: SAI3_RX_BCLK of instance: SAI3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_13_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: ARM_CM7_TXEV of instance: cm7_mxrt
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_13_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: CCM_PMIC_RDY of instance: CCM
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_13_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_IO19 of instance: FLEXIO1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_13_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO13 of instance: GPIO2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_13_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SRC_BT_CFG03 of instance: SRC
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_13_MUX_MODE_ALT6 = 0x6
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_13_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_13_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_13_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_13_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_13
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_13_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_12: SW_MUX_CTL_PAD_GPIO_SD_12 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_12_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_12_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI_A_DQS of instance: FLEXSPI
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_12_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: LPSPI2_PCS0 of instance: LPSPI2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_12_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART1_TXD of instance: LPUART1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_12_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT4 mux port: FLEXIO1_IO18 of instance: FLEXIO1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_12_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO12 of instance: GPIO2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_12_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: WDOG2_RST_B_DEB of instance: WDOG2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_12_MUX_MODE_ALT6 = 0x6
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_12_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_12_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_12_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_12_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_12
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_12_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_11: SW_MUX_CTL_PAD_GPIO_SD_11 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_11_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_11_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI_A_DATA3 of instance: FLEXSPI
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_11_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: LPSPI2_SCK of instance: LPSPI2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_11_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART1_RXD of instance: LPUART1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_11_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT4 mux port: FLEXIO1_IO17 of instance: FLEXIO1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_11_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO11 of instance: GPIO2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_11_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: WDOG1_RST_B_DEB of instance: WDOG1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_11_MUX_MODE_ALT6 = 0x6
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_11_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_11_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_11_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_11_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_11
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_11_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_10: SW_MUX_CTL_PAD_GPIO_SD_10 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_10_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_10_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI_A_SCLK of instance: FLEXSPI
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_10_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: LPSPI2_SDO of instance: LPSPI2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_10_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART2_TXD of instance: LPUART2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_10_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT4 mux port: FLEXIO1_IO16 of instance: FLEXIO1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_10_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO10 of instance: GPIO2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_10_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_10_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_10_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_10_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_10_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_10
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_10_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_09: SW_MUX_CTL_PAD_GPIO_SD_09 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_09_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_09_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI_A_DATA0 of instance: FLEXSPI
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_09_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: LPSPI2_SDI of instance: LPSPI2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_09_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPUART2_RXD of instance: LPUART2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_09_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT4 mux port: FLEXIO1_IO15 of instance: FLEXIO1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_09_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO09 of instance: GPIO2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_09_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_09_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_09_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_09_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_09_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_09
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_09_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_08: SW_MUX_CTL_PAD_GPIO_SD_08 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_08_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_08_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI_A_DATA2 of instance: FLEXSPI
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_08_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: LPI2C2_SCL of instance: LPI2C2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_08_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPSPI1_SCK of instance: LPSPI1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_08_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT4 mux port: FLEXIO1_IO14 of instance: FLEXIO1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_08_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO08 of instance: GPIO2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_08_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_08_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_08_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_08_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_08_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_08
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_08_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_07: SW_MUX_CTL_PAD_GPIO_SD_07 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_07_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_07_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI_A_DATA1 of instance: FLEXSPI
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_07_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: LPI2C2_SDA of instance: LPI2C2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_07_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPSPI1_PCS0 of instance: LPSPI1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_07_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT4 mux port: FLEXIO1_IO13 of instance: FLEXIO1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_07_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO07 of instance: GPIO2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_07_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_07_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_07_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_07_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_07_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_07
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_07_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_06: SW_MUX_CTL_PAD_GPIO_SD_06 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_06_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_06_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI_A_SS0_B of instance: FLEXSPI
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_06_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: LPI2C1_SCL of instance: LPI2C1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_06_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPSPI1_SDO of instance: LPSPI1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_06_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT4 mux port: FLEXIO1_IO12 of instance: FLEXIO1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_06_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO06 of instance: GPIO2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_06_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_06_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_06_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_06_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_06_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_06
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_06_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_05: SW_MUX_CTL_PAD_GPIO_SD_05 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_05_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_05_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI_A_SS1_B of instance: FLEXSPI
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_05_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: LPI2C1_SDA of instance: LPI2C1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_05_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPSPI1_SDI of instance: LPSPI1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_05_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT4 mux port: FLEXIO1_IO11 of instance: FLEXIO1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_05_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO05 of instance: GPIO2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_05_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_05_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_05_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_05_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_05_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_05
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_05_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_04: SW_MUX_CTL_PAD_GPIO_SD_04 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_04_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_04_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI_B_DATA03 of instance: FLEXSPI
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_04_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: SAI3_RX_SYNC of instance: SAI3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_04_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXPWM1_PWM1_A of instance: FLEXPWM1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_04_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: CCM_WAIT of instance: CCM
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_04_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_IO10 of instance: FLEXIO1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_04_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO04 of instance: GPIO2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_04_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SRC_BOOT_MODE00 of instance: SRC
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_04_MUX_MODE_ALT6 = 0x6
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_04_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_04_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_04_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_04_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_04
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_04_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_03: SW_MUX_CTL_PAD_GPIO_SD_03 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_03_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_03_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI_B_DATA00 of instance: FLEXSPI
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_03_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: SAI3_RX_DATA of instance: SAI3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_03_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXPWM1_PWM1_B of instance: FLEXPWM1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_03_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: CCM_REF_EN_B of instance: CCM
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_03_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_IO09 of instance: FLEXIO1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_03_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO03 of instance: GPIO2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_03_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SRC_BOOT_MODE01 of instance: SRC
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_03_MUX_MODE_ALT6 = 0x6
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_03_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_03_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_03_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_03_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_03
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_03_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_02: SW_MUX_CTL_PAD_GPIO_SD_02 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_02_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_02_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI_B_DATA02 of instance: FLEXSPI
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_02_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: SAI3_TX_DATA of instance: SAI3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_02_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXPWM1_PWM0_A of instance: FLEXPWM1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_02_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: CCM_CLKO1 of instance: CCM
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_02_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_IO08 of instance: FLEXIO1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_02_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO02 of instance: GPIO2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_02_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SRC_BT_CFG00 of instance: SRC
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_02_MUX_MODE_ALT6 = 0x6
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_02_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_02_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_02_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_02_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_02
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_02_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_01: SW_MUX_CTL_PAD_GPIO_SD_01 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_01_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_01_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI_B_DATA01 of instance: FLEXSPI
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_01_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: SAI3_TX_BCLK of instance: SAI3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_01_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXPWM1_PWM0_B of instance: FLEXPWM1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_01_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: CCM_CLKO2 of instance: CCM
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_01_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_IO07 of instance: FLEXIO1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_01_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO01 of instance: GPIO2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_01_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SRC_BT_CFG01 of instance: SRC
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_01_MUX_MODE_ALT6 = 0x6
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_01_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_01_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_01_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_01_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_01
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_01_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_SD_00: SW_MUX_CTL_PAD_GPIO_SD_00 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_00_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_00_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI_B_SS0_B of instance: FLEXSPI
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_00_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: SAI3_TX_SYNC of instance: SAI3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_00_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: ARM_CM7_RXEV of instance: cm7_mxrt
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_00_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: CCM_STOP of instance: CCM
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_00_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_IO06 of instance: FLEXIO1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_00_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIO2_IO00 of instance: GPIO2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_00_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SRC_BT_CFG02 of instance: SRC
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_00_MUX_MODE_ALT6 = 0x6
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_00_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_00_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_00_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_00_SION_DISABLED = 0x0
	// Force input path of pad GPIO_SD_00
	IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_00_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_13: SW_MUX_CTL_PAD_GPIO_13 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_13_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_13_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: LPUART2_RXD of instance: LPUART2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_13_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: LPSPI2_PCS2 of instance: LPSPI2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_13_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: KPP_ROW03 of instance: KPP
	IOMUXC_SW_MUX_CTL_PAD_GPIO_13_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: OTG1_ID of instance: anatop
	IOMUXC_SW_MUX_CTL_PAD_GPIO_13_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_IO05 of instance: FLEXIO1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_13_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIOMUX_IO13 of instance: GPIOMUX
	IOMUXC_SW_MUX_CTL_PAD_GPIO_13_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SPDIF_LOCK of instance: SPDIF
	IOMUXC_SW_MUX_CTL_PAD_GPIO_13_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: ARM_CM7_TRACE01 of instance: cm7_mxrt
	IOMUXC_SW_MUX_CTL_PAD_GPIO_13_MUX_MODE_ALT7 = 0x7
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_13_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_13_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_13_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_13_SION_DISABLED = 0x0
	// Force input path of pad GPIO_13
	IOMUXC_SW_MUX_CTL_PAD_GPIO_13_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_12: SW_MUX_CTL_PAD_GPIO_12 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_12_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_12_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: LPUART3_TXD of instance: LPUART3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_12_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: LPI2C1_SCL of instance: LPI2C1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_12_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: KPP_COL00 of instance: KPP
	IOMUXC_SW_MUX_CTL_PAD_GPIO_12_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: USB_OTG1_OC of instance: USB
	IOMUXC_SW_MUX_CTL_PAD_GPIO_12_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_IO04 of instance: FLEXIO1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_12_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIOMUX_IO12 of instance: GPIOMUX
	IOMUXC_SW_MUX_CTL_PAD_GPIO_12_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SPDIF_EXT_CLK of instance: SPDIF
	IOMUXC_SW_MUX_CTL_PAD_GPIO_12_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: ARM_CM7_TRACE02 of instance: cm7_mxrt
	IOMUXC_SW_MUX_CTL_PAD_GPIO_12_MUX_MODE_ALT7 = 0x7
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_12_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_12_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_12_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_12_SION_DISABLED = 0x0
	// Force input path of pad GPIO_12
	IOMUXC_SW_MUX_CTL_PAD_GPIO_12_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_11: SW_MUX_CTL_PAD_GPIO_11 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_11_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_11_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: LPUART3_RXD of instance: LPUART3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_11_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: LPI2C1_SDA of instance: LPI2C1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_11_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: KPP_ROW00 of instance: KPP
	IOMUXC_SW_MUX_CTL_PAD_GPIO_11_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: FLEXSPI_B_SS1_B of instance: FLEXSPI
	IOMUXC_SW_MUX_CTL_PAD_GPIO_11_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_IO03 of instance: FLEXIO1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_11_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIOMUX_IO11 of instance: GPIOMUX
	IOMUXC_SW_MUX_CTL_PAD_GPIO_11_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SPDIF_OUT of instance: SPDIF
	IOMUXC_SW_MUX_CTL_PAD_GPIO_11_MUX_MODE_ALT6 = 0x6
	// Select mux mode: ALT7 mux port: ARM_CM7_TRACE03 of instance: cm7_mxrt
	IOMUXC_SW_MUX_CTL_PAD_GPIO_11_MUX_MODE_ALT7 = 0x7
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_11_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_11_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_11_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_11_SION_DISABLED = 0x0
	// Force input path of pad GPIO_11
	IOMUXC_SW_MUX_CTL_PAD_GPIO_11_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_10: SW_MUX_CTL_PAD_GPIO_10 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_10_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_10_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: LPUART1_TXD of instance: LPUART1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_10_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: LPI2C1_HREQ of instance: LPI2C1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_10_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: EWM_OUT_B of instance: EWM
	IOMUXC_SW_MUX_CTL_PAD_GPIO_10_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPI2C2_SCL of instance: LPI2C2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_10_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_IO02 of instance: FLEXIO1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_10_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIOMUX_IO10 of instance: GPIOMUX
	IOMUXC_SW_MUX_CTL_PAD_GPIO_10_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SPDIF_IN of instance: SPDIF
	IOMUXC_SW_MUX_CTL_PAD_GPIO_10_MUX_MODE_ALT6 = 0x6
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_10_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_10_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_10_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_10_SION_DISABLED = 0x0
	// Force input path of pad GPIO_10
	IOMUXC_SW_MUX_CTL_PAD_GPIO_10_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_09: SW_MUX_CTL_PAD_GPIO_09 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_09_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_09_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: LPUART1_RXD of instance: LPUART1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_09_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: WDOG1_B of instance: WDOG1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_09_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXSPI_A_SS1_B of instance: FLEXSPI
	IOMUXC_SW_MUX_CTL_PAD_GPIO_09_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPI2C2_SDA of instance: LPI2C2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_09_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_IO01 of instance: FLEXIO1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_09_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIOMUX_IO09 of instance: GPIOMUX
	IOMUXC_SW_MUX_CTL_PAD_GPIO_09_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: SPDIF_SR_CLK of instance: SPDIF
	IOMUXC_SW_MUX_CTL_PAD_GPIO_09_MUX_MODE_ALT6 = 0x6
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_09_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_09_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_09_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_09_SION_DISABLED = 0x0
	// Force input path of pad GPIO_09
	IOMUXC_SW_MUX_CTL_PAD_GPIO_09_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_08: SW_MUX_CTL_PAD_GPIO_08 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_08_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_08_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: SAI1_MCLK of instance: SAI1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_08_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: GPT1_CLK of instance: GPT1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_08_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXPWM1_PWM3_A of instance: FLEXPWM1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_08_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPUART3_TXD of instance: LPUART3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_08_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: FLEXIO1_IO00 of instance: FLEXIO1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_08_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIOMUX_IO08 of instance: GPIOMUX
	IOMUXC_SW_MUX_CTL_PAD_GPIO_08_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: LPUART1_CTS_B of instance: LPUART1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_08_MUX_MODE_ALT6 = 0x6
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_08_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_08_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_08_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_08_SION_DISABLED = 0x0
	// Force input path of pad GPIO_08
	IOMUXC_SW_MUX_CTL_PAD_GPIO_08_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_07: SW_MUX_CTL_PAD_GPIO_07 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_07_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_07_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: SAI1_TX_SYNC of instance: SAI1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_07_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: GPT1_COMPARE1 of instance: GPT1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_07_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXPWM1_PWM3_B of instance: FLEXPWM1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_07_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPUART3_RXD of instance: LPUART3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_07_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: SPDIF_LOCK of instance: SPDIF
	IOMUXC_SW_MUX_CTL_PAD_GPIO_07_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIOMUX_IO07 of instance: GPIOMUX
	IOMUXC_SW_MUX_CTL_PAD_GPIO_07_MUX_MODE_ALT5 = 0x5
	// Select mux mode: ALT6 mux port: LPUART1_RTS_B of instance: LPUART1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_07_MUX_MODE_ALT6 = 0x6
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_07_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_07_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_07_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_07_SION_DISABLED = 0x0
	// Force input path of pad GPIO_07
	IOMUXC_SW_MUX_CTL_PAD_GPIO_07_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_06: SW_MUX_CTL_PAD_GPIO_06 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_06_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_06_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: SAI1_TX_BCLK of instance: SAI1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_06_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: GPT1_CAPTURE1 of instance: GPT1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_06_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXPWM1_PWM2_A of instance: FLEXPWM1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_06_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPUART4_TXD of instance: LPUART4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_06_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: SPDIF_EXT_CLK of instance: SPDIF
	IOMUXC_SW_MUX_CTL_PAD_GPIO_06_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIOMUX_IO06 of instance: GPIOMUX
	IOMUXC_SW_MUX_CTL_PAD_GPIO_06_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_06_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_06_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_06_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_06_SION_DISABLED = 0x0
	// Force input path of pad GPIO_06
	IOMUXC_SW_MUX_CTL_PAD_GPIO_06_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_05: SW_MUX_CTL_PAD_GPIO_05 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_05_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_05_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: SAI1_TX_DATA01 of instance: SAI1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_05_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: GPT1_COMPARE2 of instance: GPT1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_05_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXPWM1_PWM2_B of instance: FLEXPWM1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_05_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPUART4_RXD of instance: LPUART4
	IOMUXC_SW_MUX_CTL_PAD_GPIO_05_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: SPDIF_OUT of instance: SPDIF
	IOMUXC_SW_MUX_CTL_PAD_GPIO_05_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIOMUX_IO05 of instance: GPIOMUX
	IOMUXC_SW_MUX_CTL_PAD_GPIO_05_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_05_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_05_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_05_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_05_SION_DISABLED = 0x0
	// Force input path of pad GPIO_05
	IOMUXC_SW_MUX_CTL_PAD_GPIO_05_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_04: SW_MUX_CTL_PAD_GPIO_04 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_04_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_04_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: SAI1_TX_DATA00 of instance: SAI1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_04_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: GPT1_CAPTURE2 of instance: GPT1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_04_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXPWM1_PWM1_A of instance: FLEXPWM1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_04_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT4 mux port: SPDIF_IN of instance: SPDIF
	IOMUXC_SW_MUX_CTL_PAD_GPIO_04_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIOMUX_IO04 of instance: GPIOMUX
	IOMUXC_SW_MUX_CTL_PAD_GPIO_04_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_04_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_04_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_04_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_04_SION_DISABLED = 0x0
	// Force input path of pad GPIO_04
	IOMUXC_SW_MUX_CTL_PAD_GPIO_04_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_03: SW_MUX_CTL_PAD_GPIO_03 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_03_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_03_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: SAI1_RX_DATA00 of instance: SAI1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_03_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: GPT1_COMPARE3 of instance: GPT1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_03_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXPWM1_PWM1_B of instance: FLEXPWM1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_03_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT4 mux port: SPDIF_SR_CLK of instance: SPDIF
	IOMUXC_SW_MUX_CTL_PAD_GPIO_03_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIOMUX_IO03 of instance: GPIOMUX
	IOMUXC_SW_MUX_CTL_PAD_GPIO_03_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_03_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_03_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_03_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_03_SION_DISABLED = 0x0
	// Force input path of pad GPIO_03
	IOMUXC_SW_MUX_CTL_PAD_GPIO_03_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_02: SW_MUX_CTL_PAD_GPIO_02 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_02_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_02_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: SAI1_RX_SYNC of instance: SAI1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_02_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: WDOG2_B of instance: WDOG2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_02_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXPWM1_PWM0_A of instance: FLEXPWM1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_02_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPI2C1_SCL of instance: LPI2C1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_02_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: KPP_COL03 of instance: KPP
	IOMUXC_SW_MUX_CTL_PAD_GPIO_02_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIOMUX_IO02 of instance: GPIOMUX
	IOMUXC_SW_MUX_CTL_PAD_GPIO_02_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_02_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_02_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_02_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_02_SION_DISABLED = 0x0
	// Force input path of pad GPIO_02
	IOMUXC_SW_MUX_CTL_PAD_GPIO_02_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_01: SW_MUX_CTL_PAD_GPIO_01 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_01_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_01_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: SAI1_RX_BCLK of instance: SAI1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_01_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: WDOG1_ANY of instance: WDOG1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_01_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: FLEXPWM1_PWM0_B of instance: FLEXPWM1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_01_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPI2C1_SDA of instance: LPI2C1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_01_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: KPP_ROW03 of instance: KPP
	IOMUXC_SW_MUX_CTL_PAD_GPIO_01_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIOMUX_IO01 of instance: GPIOMUX
	IOMUXC_SW_MUX_CTL_PAD_GPIO_01_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_01_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_01_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_01_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_01_SION_DISABLED = 0x0
	// Force input path of pad GPIO_01
	IOMUXC_SW_MUX_CTL_PAD_GPIO_01_SION_ENABLED = 0x1

	// SW_MUX_CTL_PAD_GPIO_00: SW_MUX_CTL_PAD_GPIO_00 SW MUX Control Register
	// Position of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_00_MUX_MODE_Pos = 0x0
	// Bit mask of MUX_MODE field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_00_MUX_MODE_Msk = 0x7
	// Select mux mode: ALT0 mux port: FLEXSPI_B_DQS of instance: FLEXSPI
	IOMUXC_SW_MUX_CTL_PAD_GPIO_00_MUX_MODE_ALT0 = 0x0
	// Select mux mode: ALT1 mux port: SAI3_MCLK of instance: SAI3
	IOMUXC_SW_MUX_CTL_PAD_GPIO_00_MUX_MODE_ALT1 = 0x1
	// Select mux mode: ALT2 mux port: LPSPI2_PCS3 of instance: LPSPI2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_00_MUX_MODE_ALT2 = 0x2
	// Select mux mode: ALT3 mux port: LPSPI1_PCS3 of instance: LPSPI1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_00_MUX_MODE_ALT3 = 0x3
	// Select mux mode: ALT4 mux port: PIT_TRIGGER00 of instance: PIT
	IOMUXC_SW_MUX_CTL_PAD_GPIO_00_MUX_MODE_ALT4 = 0x4
	// Select mux mode: ALT5 mux port: GPIOMUX_IO00 of instance: GPIOMUX
	IOMUXC_SW_MUX_CTL_PAD_GPIO_00_MUX_MODE_ALT5 = 0x5
	// Position of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_00_SION_Pos = 0x4
	// Bit mask of SION field.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_00_SION_Msk = 0x10
	// Bit SION.
	IOMUXC_SW_MUX_CTL_PAD_GPIO_00_SION = 0x10
	// Input Path is determined by functionality
	IOMUXC_SW_MUX_CTL_PAD_GPIO_00_SION_DISABLED = 0x0
	// Force input path of pad GPIO_00
	IOMUXC_SW_MUX_CTL_PAD_GPIO_00_SION_ENABLED = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_14: SW_PAD_CTL_PAD_GPIO_AD_14 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_13: SW_PAD_CTL_PAD_GPIO_AD_13 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_12: SW_PAD_CTL_PAD_GPIO_AD_12 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_11: SW_PAD_CTL_PAD_GPIO_AD_11 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_10: SW_PAD_CTL_PAD_GPIO_AD_10 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_09: SW_PAD_CTL_PAD_GPIO_AD_09 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_08: SW_PAD_CTL_PAD_GPIO_AD_08 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_07: SW_PAD_CTL_PAD_GPIO_AD_07 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_06: SW_PAD_CTL_PAD_GPIO_AD_06 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_05: SW_PAD_CTL_PAD_GPIO_AD_05 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_04: SW_PAD_CTL_PAD_GPIO_AD_04 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_03: SW_PAD_CTL_PAD_GPIO_AD_03 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_02: SW_PAD_CTL_PAD_GPIO_AD_02 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_01: SW_PAD_CTL_PAD_GPIO_AD_01 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_AD_00: SW_PAD_CTL_PAD_GPIO_AD_00 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_14: SW_PAD_CTL_PAD_GPIO_SD_14 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_13: SW_PAD_CTL_PAD_GPIO_SD_13 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_12: SW_PAD_CTL_PAD_GPIO_SD_12 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_11: SW_PAD_CTL_PAD_GPIO_SD_11 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_10: SW_PAD_CTL_PAD_GPIO_SD_10 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_09: SW_PAD_CTL_PAD_GPIO_SD_09 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_08: SW_PAD_CTL_PAD_GPIO_SD_08 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_07: SW_PAD_CTL_PAD_GPIO_SD_07 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_06: SW_PAD_CTL_PAD_GPIO_SD_06 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_05: SW_PAD_CTL_PAD_GPIO_SD_05 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_04: SW_PAD_CTL_PAD_GPIO_SD_04 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_03: SW_PAD_CTL_PAD_GPIO_SD_03 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_02: SW_PAD_CTL_PAD_GPIO_SD_02 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_01: SW_PAD_CTL_PAD_GPIO_SD_01 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_SD_00: SW_PAD_CTL_PAD_GPIO_SD_00 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_13: SW_PAD_CTL_PAD_GPIO_13 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_13_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_12: SW_PAD_CTL_PAD_GPIO_12 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_12_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_11: SW_PAD_CTL_PAD_GPIO_11 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_11_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_10: SW_PAD_CTL_PAD_GPIO_10 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_10_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_09: SW_PAD_CTL_PAD_GPIO_09 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_09_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_08: SW_PAD_CTL_PAD_GPIO_08 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_08_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_07: SW_PAD_CTL_PAD_GPIO_07 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_07_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_06: SW_PAD_CTL_PAD_GPIO_06 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_06_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_05: SW_PAD_CTL_PAD_GPIO_05 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_05_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_04: SW_PAD_CTL_PAD_GPIO_04 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_04_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_03: SW_PAD_CTL_PAD_GPIO_03 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_03_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_02: SW_PAD_CTL_PAD_GPIO_02 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_02_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_01: SW_PAD_CTL_PAD_GPIO_01 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_01_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// SW_PAD_CTL_PAD_GPIO_00: SW_PAD_CTL_PAD_GPIO_00 SW PAD Control Register
	// Position of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_SRE_Pos = 0x0
	// Bit mask of SRE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_SRE_Msk = 0x1
	// Bit SRE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_SRE = 0x1
	// Slow Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_SRE_SRE_0_Slow_Slew_Rate = 0x0
	// Fast Slew Rate
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_SRE_SRE_1_Fast_Slew_Rate = 0x1
	// Position of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_DSE_Pos = 0x3
	// Bit mask of DSE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_DSE_Msk = 0x38
	// output driver disabled;
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_DSE_DSE_0_output_driver_disabled_ = 0x0
	// R0(150 Ohm @ 3.3V, 260 Ohm@1.8V, 240 Ohm for DDR)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_DSE_DSE_1_R0_150_Ohm___3_3V__260_Ohm_1_8V__240_Ohm_for_DDR_ = 0x1
	// R0/2
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_DSE_DSE_2_R0_2 = 0x2
	// R0/3
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_DSE_DSE_3_R0_3 = 0x3
	// R0/4
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_DSE_DSE_4_R0_4 = 0x4
	// R0/5
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_DSE_DSE_5_R0_5 = 0x5
	// R0/6
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_DSE_DSE_6_R0_6 = 0x6
	// R0/7
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_DSE_DSE_7_R0_7 = 0x7
	// Position of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_SPEED_Pos = 0x6
	// Bit mask of SPEED field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_SPEED_Msk = 0xc0
	// low(50MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_SPEED_SPEED_0_low_50MHz = 0x0
	// medium(100MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_SPEED_SPEED_1_medium_100MHz = 0x1
	// fast(150MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_SPEED_SPEED_2_fast_150MHz = 0x2
	// max(200MHz)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_SPEED_SPEED_3_max_200MHz = 0x3
	// Position of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_ODE_Pos = 0xb
	// Bit mask of ODE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_ODE_Msk = 0x800
	// Bit ODE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_ODE = 0x800
	// Open Drain Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_ODE_ODE_0_Open_Drain_Disabled = 0x0
	// Open Drain Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_ODE_ODE_1_Open_Drain_Enabled = 0x1
	// Position of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_PKE_Pos = 0xc
	// Bit mask of PKE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_PKE_Msk = 0x1000
	// Bit PKE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_PKE = 0x1000
	// Pull/Keeper Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_PKE_PKE_0_Pull_Keeper_Disabled = 0x0
	// Pull/Keeper Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_PKE_PKE_1_Pull_Keeper_Enabled = 0x1
	// Position of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_PUE_Pos = 0xd
	// Bit mask of PUE field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_PUE_Msk = 0x2000
	// Bit PUE.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_PUE = 0x2000
	// Keeper
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_PUE_PUE_0_Keeper = 0x0
	// Pull
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_PUE_PUE_1_Pull = 0x1
	// Position of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_PUS_Pos = 0xe
	// Bit mask of PUS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_PUS_Msk = 0xc000
	// 100K Ohm Pull Down
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_PUS_PUS_0_100K_Ohm_Pull_Down = 0x0
	// 47K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_PUS_PUS_1_47K_Ohm_Pull_Up = 0x1
	// 100K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_PUS_PUS_2_100K_Ohm_Pull_Up = 0x2
	// 22K Ohm Pull Up
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_PUS_PUS_3_22K_Ohm_Pull_Up = 0x3
	// Position of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_HYS_Pos = 0x10
	// Bit mask of HYS field.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_HYS_Msk = 0x10000
	// Bit HYS.
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_HYS = 0x10000
	// Hysteresis Disabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_HYS_HYS_0_Hysteresis_Disabled = 0x0
	// Hysteresis Enabled
	IOMUXC_SW_PAD_CTL_PAD_GPIO_00_HYS_HYS_1_Hysteresis_Enabled = 0x1

	// USB_OTG_ID_SELECT_INPUT: USB_OTG_ID_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_USB_OTG_ID_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_USB_OTG_ID_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_USB_OTG_ID_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_10 for Mode: ALT6
	IOMUXC_USB_OTG_ID_SELECT_INPUT_DAISY_GPIO_AD_10_ALT6 = 0x0
	// Selecting Pad: GPIO_13 for Mode: ALT3
	IOMUXC_USB_OTG_ID_SELECT_INPUT_DAISY_GPIO_13_ALT3 = 0x1

	// FLEXPWM1_PWMA_SELECT_INPUT_0: FLEXPWM1_PWMA_SELECT_INPUT_0 DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXPWM1_PWMA_SELECT_INPUT_0_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXPWM1_PWMA_SELECT_INPUT_0_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXPWM1_PWMA_SELECT_INPUT_0_DAISY = 0x1
	// Selecting Pad: GPIO_SD_02 for Mode: ALT2
	IOMUXC_FLEXPWM1_PWMA_SELECT_INPUT_0_DAISY_GPIO_SD_02_ALT2 = 0x0
	// Selecting Pad: GPIO_02 for Mode: ALT2
	IOMUXC_FLEXPWM1_PWMA_SELECT_INPUT_0_DAISY_GPIO_02_ALT2 = 0x1

	// FLEXPWM1_PWMA_SELECT_INPUT_1: FLEXPWM1_PWMA_SELECT_INPUT_1 DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXPWM1_PWMA_SELECT_INPUT_1_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXPWM1_PWMA_SELECT_INPUT_1_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXPWM1_PWMA_SELECT_INPUT_1_DAISY = 0x1
	// Selecting Pad: GPIO_SD_04 for Mode: ALT2
	IOMUXC_FLEXPWM1_PWMA_SELECT_INPUT_1_DAISY_GPIO_SD_04_ALT2 = 0x0
	// Selecting Pad: GPIO_04 for Mode: ALT2
	IOMUXC_FLEXPWM1_PWMA_SELECT_INPUT_1_DAISY_GPIO_04_ALT2 = 0x1

	// FLEXPWM1_PWMA_SELECT_INPUT_2: FLEXPWM1_PWMA_SELECT_INPUT_2 DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXPWM1_PWMA_SELECT_INPUT_2_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXPWM1_PWMA_SELECT_INPUT_2_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXPWM1_PWMA_SELECT_INPUT_2_DAISY = 0x1
	// Selecting Pad: GPIO_AD_04 for Mode: ALT2
	IOMUXC_FLEXPWM1_PWMA_SELECT_INPUT_2_DAISY_GPIO_AD_04_ALT2 = 0x0
	// Selecting Pad: GPIO_06 for Mode: ALT2
	IOMUXC_FLEXPWM1_PWMA_SELECT_INPUT_2_DAISY_GPIO_06_ALT2 = 0x1

	// FLEXPWM1_PWMA_SELECT_INPUT_3: FLEXPWM1_PWMA_SELECT_INPUT_3 DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXPWM1_PWMA_SELECT_INPUT_3_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXPWM1_PWMA_SELECT_INPUT_3_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXPWM1_PWMA_SELECT_INPUT_3_DAISY = 0x1
	// Selecting Pad: GPIO_AD_06 for Mode: ALT2
	IOMUXC_FLEXPWM1_PWMA_SELECT_INPUT_3_DAISY_GPIO_AD_06_ALT2 = 0x0
	// Selecting Pad: GPIO_08 for Mode: ALT2
	IOMUXC_FLEXPWM1_PWMA_SELECT_INPUT_3_DAISY_GPIO_08_ALT2 = 0x1

	// FLEXPWM1_PWMB_SELECT_INPUT_0: FLEXPWM1_PWMB_SELECT_INPUT_0 DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXPWM1_PWMB_SELECT_INPUT_0_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXPWM1_PWMB_SELECT_INPUT_0_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXPWM1_PWMB_SELECT_INPUT_0_DAISY = 0x1
	// Selecting Pad: GPIO_SD_01 for Mode: ALT2
	IOMUXC_FLEXPWM1_PWMB_SELECT_INPUT_0_DAISY_GPIO_SD_01_ALT2 = 0x0
	// Selecting Pad: GPIO_01 for Mode: ALT2
	IOMUXC_FLEXPWM1_PWMB_SELECT_INPUT_0_DAISY_GPIO_01_ALT2 = 0x1

	// FLEXPWM1_PWMB_SELECT_INPUT_1: FLEXPWM1_PWMB_SELECT_INPUT_1 DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXPWM1_PWMB_SELECT_INPUT_1_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXPWM1_PWMB_SELECT_INPUT_1_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXPWM1_PWMB_SELECT_INPUT_1_DAISY = 0x1
	// Selecting Pad: GPIO_SD_03 for Mode: ALT2
	IOMUXC_FLEXPWM1_PWMB_SELECT_INPUT_1_DAISY_GPIO_SD_03_ALT2 = 0x0
	// Selecting Pad: GPIO_03 for Mode: ALT2
	IOMUXC_FLEXPWM1_PWMB_SELECT_INPUT_1_DAISY_GPIO_03_ALT2 = 0x1

	// FLEXPWM1_PWMB_SELECT_INPUT_2: FLEXPWM1_PWMB_SELECT_INPUT_2 DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXPWM1_PWMB_SELECT_INPUT_2_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXPWM1_PWMB_SELECT_INPUT_2_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXPWM1_PWMB_SELECT_INPUT_2_DAISY = 0x1
	// Selecting Pad: GPIO_AD_03 for Mode: ALT2
	IOMUXC_FLEXPWM1_PWMB_SELECT_INPUT_2_DAISY_GPIO_AD_03_ALT2 = 0x0
	// Selecting Pad: GPIO_05 for Mode: ALT2
	IOMUXC_FLEXPWM1_PWMB_SELECT_INPUT_2_DAISY_GPIO_05_ALT2 = 0x1

	// FLEXPWM1_PWMB_SELECT_INPUT_3: FLEXPWM1_PWMB_SELECT_INPUT_3 DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXPWM1_PWMB_SELECT_INPUT_3_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXPWM1_PWMB_SELECT_INPUT_3_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXPWM1_PWMB_SELECT_INPUT_3_DAISY = 0x1
	// Selecting Pad: GPIO_AD_05 for Mode: ALT2
	IOMUXC_FLEXPWM1_PWMB_SELECT_INPUT_3_DAISY_GPIO_AD_05_ALT2 = 0x0
	// Selecting Pad: GPIO_07 for Mode: ALT2
	IOMUXC_FLEXPWM1_PWMB_SELECT_INPUT_3_DAISY_GPIO_07_ALT2 = 0x1

	// FLEXSPI_DQS_FA_SELECT_INPUT: FLEXSPI_DQS_FA_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXSPI_DQS_FA_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXSPI_DQS_FA_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXSPI_DQS_FA_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_14 for Mode: ALT0
	IOMUXC_FLEXSPI_DQS_FA_SELECT_INPUT_DAISY_GPIO_SD_14_ALT0 = 0x0
	// Selecting Pad: GPIO_SD_12 for Mode: ALT0
	IOMUXC_FLEXSPI_DQS_FA_SELECT_INPUT_DAISY_GPIO_SD_12_ALT0 = 0x1

	// FLEXSPI_DQS_FB_SELECT_INPUT: FLEXSPI_DQS_FB_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_FLEXSPI_DQS_FB_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_FLEXSPI_DQS_FB_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_FLEXSPI_DQS_FB_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_14 for Mode: ALT1
	IOMUXC_FLEXSPI_DQS_FB_SELECT_INPUT_DAISY_GPIO_SD_14_ALT1 = 0x0
	// Selecting Pad: GPIO_00 for Mode: ALT0
	IOMUXC_FLEXSPI_DQS_FB_SELECT_INPUT_DAISY_GPIO_00_ALT0 = 0x1

	// KPP_COL_SELECT_INPUT_0: KPP_COL_SELECT_INPUT_0 DAISY Register
	// Position of DAISY field.
	IOMUXC_KPP_COL_SELECT_INPUT_0_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_KPP_COL_SELECT_INPUT_0_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_KPP_COL_SELECT_INPUT_0_DAISY = 0x1
	// Selecting Pad: GPIO_AD_14 for Mode: ALT2
	IOMUXC_KPP_COL_SELECT_INPUT_0_DAISY_GPIO_AD_14_ALT2 = 0x0
	// Selecting Pad: GPIO_12 for Mode: ALT2
	IOMUXC_KPP_COL_SELECT_INPUT_0_DAISY_GPIO_12_ALT2 = 0x1

	// KPP_COL_SELECT_INPUT_1: KPP_COL_SELECT_INPUT_1 DAISY Register
	// Position of DAISY field.
	IOMUXC_KPP_COL_SELECT_INPUT_1_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_KPP_COL_SELECT_INPUT_1_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_KPP_COL_SELECT_INPUT_1_DAISY = 0x1
	// Selecting Pad: GPIO_AD_12 for Mode: ALT2
	IOMUXC_KPP_COL_SELECT_INPUT_1_DAISY_GPIO_AD_12_ALT2 = 0x0
	// Selecting Pad: GPIO_AD_06 for Mode: ALT3
	IOMUXC_KPP_COL_SELECT_INPUT_1_DAISY_GPIO_AD_06_ALT3 = 0x1

	// KPP_COL_SELECT_INPUT_2: KPP_COL_SELECT_INPUT_2 DAISY Register
	// Position of DAISY field.
	IOMUXC_KPP_COL_SELECT_INPUT_2_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_KPP_COL_SELECT_INPUT_2_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_KPP_COL_SELECT_INPUT_2_DAISY = 0x1
	// Selecting Pad: GPIO_AD_10 for Mode: ALT2
	IOMUXC_KPP_COL_SELECT_INPUT_2_DAISY_GPIO_AD_10_ALT2 = 0x0
	// Selecting Pad: GPIO_AD_04 for Mode: ALT3
	IOMUXC_KPP_COL_SELECT_INPUT_2_DAISY_GPIO_AD_04_ALT3 = 0x1

	// KPP_COL_SELECT_INPUT_3: KPP_COL_SELECT_INPUT_3 DAISY Register
	// Position of DAISY field.
	IOMUXC_KPP_COL_SELECT_INPUT_3_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_KPP_COL_SELECT_INPUT_3_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_KPP_COL_SELECT_INPUT_3_DAISY = 0x1
	// Selecting Pad: GPIO_AD_00 for Mode: ALT2
	IOMUXC_KPP_COL_SELECT_INPUT_3_DAISY_GPIO_AD_00_ALT2 = 0x0
	// Selecting Pad: GPIO_02 for Mode: ALT4
	IOMUXC_KPP_COL_SELECT_INPUT_3_DAISY_GPIO_02_ALT4 = 0x1

	// KPP_ROW_SELECT_INPUT_0: KPP_ROW_SELECT_INPUT_0 DAISY Register
	// Position of DAISY field.
	IOMUXC_KPP_ROW_SELECT_INPUT_0_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_KPP_ROW_SELECT_INPUT_0_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_KPP_ROW_SELECT_INPUT_0_DAISY = 0x1
	// Selecting Pad: GPIO_AD_13 for Mode: ALT2
	IOMUXC_KPP_ROW_SELECT_INPUT_0_DAISY_GPIO_AD_13_ALT2 = 0x0
	// Selecting Pad: GPIO_11 for Mode: ALT2
	IOMUXC_KPP_ROW_SELECT_INPUT_0_DAISY_GPIO_11_ALT2 = 0x1

	// KPP_ROW_SELECT_INPUT_1: KPP_ROW_SELECT_INPUT_1 DAISY Register
	// Position of DAISY field.
	IOMUXC_KPP_ROW_SELECT_INPUT_1_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_KPP_ROW_SELECT_INPUT_1_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_KPP_ROW_SELECT_INPUT_1_DAISY = 0x1
	// Selecting Pad: GPIO_AD_11 for Mode: ALT2
	IOMUXC_KPP_ROW_SELECT_INPUT_1_DAISY_GPIO_AD_11_ALT2 = 0x0
	// Selecting Pad: GPIO_AD_05 for Mode: ALT3
	IOMUXC_KPP_ROW_SELECT_INPUT_1_DAISY_GPIO_AD_05_ALT3 = 0x1

	// KPP_ROW_SELECT_INPUT_2: KPP_ROW_SELECT_INPUT_2 DAISY Register
	// Position of DAISY field.
	IOMUXC_KPP_ROW_SELECT_INPUT_2_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_KPP_ROW_SELECT_INPUT_2_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_KPP_ROW_SELECT_INPUT_2_DAISY = 0x1
	// Selecting Pad: GPIO_AD_09 for Mode: ALT2
	IOMUXC_KPP_ROW_SELECT_INPUT_2_DAISY_GPIO_AD_09_ALT2 = 0x0
	// Selecting Pad: GPIO_AD_03 for Mode: ALT3
	IOMUXC_KPP_ROW_SELECT_INPUT_2_DAISY_GPIO_AD_03_ALT3 = 0x1

	// KPP_ROW_SELECT_INPUT_3: KPP_ROW_SELECT_INPUT_3 DAISY Register
	// Position of DAISY field.
	IOMUXC_KPP_ROW_SELECT_INPUT_3_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_KPP_ROW_SELECT_INPUT_3_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_KPP_ROW_SELECT_INPUT_3_DAISY = 0x1
	// Selecting Pad: GPIO_13 for Mode: ALT2
	IOMUXC_KPP_ROW_SELECT_INPUT_3_DAISY_GPIO_13_ALT2 = 0x0
	// Selecting Pad: GPIO_01 for Mode: ALT4
	IOMUXC_KPP_ROW_SELECT_INPUT_3_DAISY_GPIO_01_ALT4 = 0x1

	// LPI2C1_HREQ_SELECT_INPUT: LPI2C1_HREQ_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPI2C1_HREQ_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPI2C1_HREQ_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPI2C1_HREQ_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_06 for Mode: ALT6
	IOMUXC_LPI2C1_HREQ_SELECT_INPUT_DAISY_GPIO_AD_06_ALT6 = 0x0
	// Selecting Pad: GPIO_10 for Mode: ALT1
	IOMUXC_LPI2C1_HREQ_SELECT_INPUT_DAISY_GPIO_10_ALT1 = 0x1

	// LPI2C1_SCL_SELECT_INPUT: LPI2C1_SCL_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPI2C1_SCL_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPI2C1_SCL_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_AD_14 for Mode: ALT0
	IOMUXC_LPI2C1_SCL_SELECT_INPUT_DAISY_GPIO_AD_14_ALT0 = 0x0
	// Selecting Pad: GPIO_SD_06 for Mode: ALT1
	IOMUXC_LPI2C1_SCL_SELECT_INPUT_DAISY_GPIO_SD_06_ALT1 = 0x1
	// Selecting Pad: GPIO_12 for Mode: ALT1
	IOMUXC_LPI2C1_SCL_SELECT_INPUT_DAISY_GPIO_12_ALT1 = 0x2
	// Selecting Pad: GPIO_02 for Mode: ALT3
	IOMUXC_LPI2C1_SCL_SELECT_INPUT_DAISY_GPIO_02_ALT3 = 0x3

	// LPI2C1_SDA_SELECT_INPUT: LPI2C1_SDA_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPI2C1_SDA_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPI2C1_SDA_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_AD_13 for Mode: ALT0
	IOMUXC_LPI2C1_SDA_SELECT_INPUT_DAISY_GPIO_AD_13_ALT0 = 0x0
	// Selecting Pad: GPIO_SD_05 for Mode: ALT1
	IOMUXC_LPI2C1_SDA_SELECT_INPUT_DAISY_GPIO_SD_05_ALT1 = 0x1
	// Selecting Pad: GPIO_11 for Mode: ALT1
	IOMUXC_LPI2C1_SDA_SELECT_INPUT_DAISY_GPIO_11_ALT1 = 0x2
	// Selecting Pad: GPIO_01 for Mode: ALT3
	IOMUXC_LPI2C1_SDA_SELECT_INPUT_DAISY_GPIO_01_ALT3 = 0x3

	// LPI2C2_SCL_SELECT_INPUT: LPI2C2_SCL_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPI2C2_SCL_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPI2C2_SCL_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_AD_08 for Mode: ALT0
	IOMUXC_LPI2C2_SCL_SELECT_INPUT_DAISY_GPIO_AD_08_ALT0 = 0x0
	// Selecting Pad: GPIO_AD_02 for Mode: ALT3
	IOMUXC_LPI2C2_SCL_SELECT_INPUT_DAISY_GPIO_AD_02_ALT3 = 0x1
	// Selecting Pad: GPIO_SD_08 for Mode: ALT1
	IOMUXC_LPI2C2_SCL_SELECT_INPUT_DAISY_GPIO_SD_08_ALT1 = 0x2
	// Selecting Pad: GPIO_10 for Mode: ALT3
	IOMUXC_LPI2C2_SCL_SELECT_INPUT_DAISY_GPIO_10_ALT3 = 0x3

	// LPI2C2_SDA_SELECT_INPUT: LPI2C2_SDA_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPI2C2_SDA_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPI2C2_SDA_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_AD_07 for Mode: ALT0
	IOMUXC_LPI2C2_SDA_SELECT_INPUT_DAISY_GPIO_AD_07_ALT0 = 0x0
	// Selecting Pad: GPIO_AD_01 for Mode: ALT3
	IOMUXC_LPI2C2_SDA_SELECT_INPUT_DAISY_GPIO_AD_01_ALT3 = 0x1
	// Selecting Pad: GPIO_SD_07 for Mode: ALT1
	IOMUXC_LPI2C2_SDA_SELECT_INPUT_DAISY_GPIO_SD_07_ALT1 = 0x2
	// Selecting Pad: GPIO_09 for Mode: ALT3
	IOMUXC_LPI2C2_SDA_SELECT_INPUT_DAISY_GPIO_09_ALT3 = 0x3

	// LPSPI1_PCS_SELECT_INPUT_0: LPSPI1_PCS_SELECT_INPUT_0 DAISY Register
	// Position of DAISY field.
	IOMUXC_LPSPI1_PCS_SELECT_INPUT_0_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPSPI1_PCS_SELECT_INPUT_0_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPSPI1_PCS_SELECT_INPUT_0_DAISY = 0x1
	// Selecting Pad: GPIO_AD_05 for Mode: ALT0
	IOMUXC_LPSPI1_PCS_SELECT_INPUT_0_DAISY_GPIO_AD_05_ALT0 = 0x0
	// Selecting Pad: GPIO_SD_07 for Mode: ALT2
	IOMUXC_LPSPI1_PCS_SELECT_INPUT_0_DAISY_GPIO_SD_07_ALT2 = 0x1

	// LPSPI1_SCK_SELECT_INPUT: LPSPI1_SCK_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPSPI1_SCK_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPSPI1_SCK_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPSPI1_SCK_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_06 for Mode: ALT0
	IOMUXC_LPSPI1_SCK_SELECT_INPUT_DAISY_GPIO_AD_06_ALT0 = 0x0
	// Selecting Pad: GPIO_SD_08 for Mode: ALT2
	IOMUXC_LPSPI1_SCK_SELECT_INPUT_DAISY_GPIO_SD_08_ALT2 = 0x1

	// LPSPI1_SDI_SELECT_INPUT: LPSPI1_SDI_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPSPI1_SDI_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPSPI1_SDI_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPSPI1_SDI_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_03 for Mode: ALT0
	IOMUXC_LPSPI1_SDI_SELECT_INPUT_DAISY_GPIO_AD_03_ALT0 = 0x0
	// Selecting Pad: GPIO_SD_05 for Mode: ALT2
	IOMUXC_LPSPI1_SDI_SELECT_INPUT_DAISY_GPIO_SD_05_ALT2 = 0x1

	// LPSPI1_SDO_SELECT_INPUT: LPSPI1_SDO_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPSPI1_SDO_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPSPI1_SDO_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPSPI1_SDO_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_04 for Mode: ALT0
	IOMUXC_LPSPI1_SDO_SELECT_INPUT_DAISY_GPIO_AD_04_ALT0 = 0x0
	// Selecting Pad: GPIO_SD_06 for Mode: ALT2
	IOMUXC_LPSPI1_SDO_SELECT_INPUT_DAISY_GPIO_SD_06_ALT2 = 0x1

	// LPSPI2_PCS_SELECT_INPUT_0: LPSPI2_PCS_SELECT_INPUT_0 DAISY Register
	// Position of DAISY field.
	IOMUXC_LPSPI2_PCS_SELECT_INPUT_0_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPSPI2_PCS_SELECT_INPUT_0_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPSPI2_PCS_SELECT_INPUT_0_DAISY = 0x1
	// Selecting Pad: GPIO_AD_11 for Mode: ALT0
	IOMUXC_LPSPI2_PCS_SELECT_INPUT_0_DAISY_GPIO_AD_11_ALT0 = 0x0
	// Selecting Pad: GPIO_SD_12 for Mode: ALT1
	IOMUXC_LPSPI2_PCS_SELECT_INPUT_0_DAISY_GPIO_SD_12_ALT1 = 0x1

	// LPSPI2_SCK_SELECT_INPUT: LPSPI2_SCK_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPSPI2_SCK_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPSPI2_SCK_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPSPI2_SCK_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_12 for Mode: ALT0
	IOMUXC_LPSPI2_SCK_SELECT_INPUT_DAISY_GPIO_AD_12_ALT0 = 0x0
	// Selecting Pad: GPIO_SD_11 for Mode: ALT1
	IOMUXC_LPSPI2_SCK_SELECT_INPUT_DAISY_GPIO_SD_11_ALT1 = 0x1

	// LPSPI2_SDI_SELECT_INPUT: LPSPI2_SDI_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPSPI2_SDI_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPSPI2_SDI_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPSPI2_SDI_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_09 for Mode: ALT0
	IOMUXC_LPSPI2_SDI_SELECT_INPUT_DAISY_GPIO_AD_09_ALT0 = 0x0
	// Selecting Pad: GPIO_SD_09 for Mode: ALT1
	IOMUXC_LPSPI2_SDI_SELECT_INPUT_DAISY_GPIO_SD_09_ALT1 = 0x1

	// LPSPI2_SDO_SELECT_INPUT: LPSPI2_SDO_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPSPI2_SDO_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPSPI2_SDO_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPSPI2_SDO_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_10 for Mode: ALT0
	IOMUXC_LPSPI2_SDO_SELECT_INPUT_DAISY_GPIO_AD_10_ALT0 = 0x0
	// Selecting Pad: GPIO_SD_10 for Mode: ALT1
	IOMUXC_LPSPI2_SDO_SELECT_INPUT_DAISY_GPIO_SD_10_ALT1 = 0x1

	// LPUART1_RXD_SELECT_INPUT: LPUART1_RXD_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPUART1_RXD_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPUART1_RXD_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPUART1_RXD_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_11 for Mode: ALT2
	IOMUXC_LPUART1_RXD_SELECT_INPUT_DAISY_GPIO_SD_11_ALT2 = 0x0
	// Selecting Pad: GPIO_09 for Mode: ALT0
	IOMUXC_LPUART1_RXD_SELECT_INPUT_DAISY_GPIO_09_ALT0 = 0x1

	// LPUART1_TXD_SELECT_INPUT: LPUART1_TXD_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPUART1_TXD_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPUART1_TXD_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPUART1_TXD_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_12 for Mode: ALT2
	IOMUXC_LPUART1_TXD_SELECT_INPUT_DAISY_GPIO_SD_12_ALT2 = 0x0
	// Selecting Pad: GPIO_10 for Mode: ALT0
	IOMUXC_LPUART1_TXD_SELECT_INPUT_DAISY_GPIO_10_ALT0 = 0x1

	// LPUART2_RXD_SELECT_INPUT: LPUART2_RXD_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPUART2_RXD_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPUART2_RXD_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPUART2_RXD_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_SD_09 for Mode: ALT2
	IOMUXC_LPUART2_RXD_SELECT_INPUT_DAISY_GPIO_SD_09_ALT2 = 0x0
	// Selecting Pad: GPIO_13 for Mode: ALT0
	IOMUXC_LPUART2_RXD_SELECT_INPUT_DAISY_GPIO_13_ALT0 = 0x1

	// LPUART2_TXD_SELECT_INPUT: LPUART2_TXD_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPUART2_TXD_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPUART2_TXD_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPUART2_TXD_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_00 for Mode: ALT0
	IOMUXC_LPUART2_TXD_SELECT_INPUT_DAISY_GPIO_AD_00_ALT0 = 0x0
	// Selecting Pad: GPIO_SD_10 for Mode: ALT2
	IOMUXC_LPUART2_TXD_SELECT_INPUT_DAISY_GPIO_SD_10_ALT2 = 0x1

	// LPUART3_RXD_SELECT_INPUT: LPUART3_RXD_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPUART3_RXD_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPUART3_RXD_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_AD_07 for Mode: ALT1
	IOMUXC_LPUART3_RXD_SELECT_INPUT_DAISY_GPIO_AD_07_ALT1 = 0x0
	// Selecting Pad: GPIO_11 for Mode: ALT0
	IOMUXC_LPUART3_RXD_SELECT_INPUT_DAISY_GPIO_11_ALT0 = 0x1
	// Selecting Pad: GPIO_07 for Mode: ALT3
	IOMUXC_LPUART3_RXD_SELECT_INPUT_DAISY_GPIO_07_ALT3 = 0x2

	// LPUART3_TXD_SELECT_INPUT: LPUART3_TXD_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPUART3_TXD_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPUART3_TXD_SELECT_INPUT_DAISY_Msk = 0x3
	// Selecting Pad: GPIO_AD_08 for Mode: ALT1
	IOMUXC_LPUART3_TXD_SELECT_INPUT_DAISY_GPIO_AD_08_ALT1 = 0x0
	// Selecting Pad: GPIO_12 for Mode: ALT0
	IOMUXC_LPUART3_TXD_SELECT_INPUT_DAISY_GPIO_12_ALT0 = 0x1
	// Selecting Pad: GPIO_08 for Mode: ALT3
	IOMUXC_LPUART3_TXD_SELECT_INPUT_DAISY_GPIO_08_ALT3 = 0x2

	// LPUART4_RXD_SELECT_INPUT: LPUART4_RXD_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPUART4_RXD_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPUART4_RXD_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPUART4_RXD_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_01 for Mode: ALT0
	IOMUXC_LPUART4_RXD_SELECT_INPUT_DAISY_GPIO_AD_01_ALT0 = 0x0
	// Selecting Pad: GPIO_05 for Mode: ALT3
	IOMUXC_LPUART4_RXD_SELECT_INPUT_DAISY_GPIO_05_ALT3 = 0x1

	// LPUART4_TXD_SELECT_INPUT: LPUART4_TXD_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_LPUART4_TXD_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_LPUART4_TXD_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_LPUART4_TXD_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_02 for Mode: ALT0
	IOMUXC_LPUART4_TXD_SELECT_INPUT_DAISY_GPIO_AD_02_ALT0 = 0x0
	// Selecting Pad: GPIO_06 for Mode: ALT3
	IOMUXC_LPUART4_TXD_SELECT_INPUT_DAISY_GPIO_06_ALT3 = 0x1

	// NMI_GLUE_NMI_SELECT_INPUT: NMI_GLUE_NMI_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_NMI_GLUE_NMI_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_NMI_GLUE_NMI_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_NMI_GLUE_NMI_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_13 for Mode: ALT6
	IOMUXC_NMI_GLUE_NMI_SELECT_INPUT_DAISY_GPIO_AD_13_ALT6 = 0x0
	// Selecting Pad: GPIO_AD_00 for Mode: ALT6
	IOMUXC_NMI_GLUE_NMI_SELECT_INPUT_DAISY_GPIO_AD_00_ALT6 = 0x1

	// SPDIF_IN1_SELECT_INPUT: SPDIF_IN1_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_SPDIF_IN1_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_SPDIF_IN1_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_SPDIF_IN1_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_10 for Mode: ALT6
	IOMUXC_SPDIF_IN1_SELECT_INPUT_DAISY_GPIO_10_ALT6 = 0x0
	// Selecting Pad: GPIO_04 for Mode: ALT4
	IOMUXC_SPDIF_IN1_SELECT_INPUT_DAISY_GPIO_04_ALT4 = 0x1

	// SPDIF_TX_CLK2_SELECT_INPUT: SPDIF_TX_CLK2_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_12 for Mode: ALT6
	IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT_DAISY_GPIO_12_ALT6 = 0x0
	// Selecting Pad: GPIO_06 for Mode: ALT4
	IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT_DAISY_GPIO_06_ALT4 = 0x1

	// USB_OTG_OC_SELECT_INPUT: USB_OTG_OC_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_USB_OTG_OC_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_USB_OTG_OC_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_USB_OTG_OC_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_01 for Mode: ALT6
	IOMUXC_USB_OTG_OC_SELECT_INPUT_DAISY_GPIO_AD_01_ALT6 = 0x0
	// Selecting Pad: GPIO_12 for Mode: ALT3
	IOMUXC_USB_OTG_OC_SELECT_INPUT_DAISY_GPIO_12_ALT3 = 0x1

	// XEV_GLUE_RXEV_SELECT_INPUT: XEV_GLUE_RXEV_SELECT_INPUT DAISY Register
	// Position of DAISY field.
	IOMUXC_XEV_GLUE_RXEV_SELECT_INPUT_DAISY_Pos = 0x0
	// Bit mask of DAISY field.
	IOMUXC_XEV_GLUE_RXEV_SELECT_INPUT_DAISY_Msk = 0x1
	// Bit DAISY.
	IOMUXC_XEV_GLUE_RXEV_SELECT_INPUT_DAISY = 0x1
	// Selecting Pad: GPIO_AD_07 for Mode: ALT2
	IOMUXC_XEV_GLUE_RXEV_SELECT_INPUT_DAISY_GPIO_AD_07_ALT2 = 0x0
	// Selecting Pad: GPIO_SD_00 for Mode: ALT2
	IOMUXC_XEV_GLUE_RXEV_SELECT_INPUT_DAISY_GPIO_SD_00_ALT2 = 0x1
)

// Constants for KPP: KPP Registers
const (
	// KPCR: Keypad Control Register
	// Position of KRE field.
	KPP_KPCR_KRE_Pos = 0x0
	// Bit mask of KRE field.
	KPP_KPCR_KRE_Msk = 0xff
	// Row is not included in the keypad key press detect.
	KPP_KPCR_KRE_KRE_0 = 0x0
	// Row is included in the keypad key press detect.
	KPP_KPCR_KRE_KRE_1 = 0x1
	// Position of KCO field.
	KPP_KPCR_KCO_Pos = 0x8
	// Bit mask of KCO field.
	KPP_KPCR_KCO_Msk = 0xff00
	// Column strobe output is totem pole drive.
	KPP_KPCR_KCO_TOTEM_POLE = 0x0
	// Column strobe output is open drain.
	KPP_KPCR_KCO_OPEN_DRAIN = 0x1

	// KPSR: Keypad Status Register
	// Position of KPKD field.
	KPP_KPSR_KPKD_Pos = 0x0
	// Bit mask of KPKD field.
	KPP_KPSR_KPKD_Msk = 0x1
	// Bit KPKD.
	KPP_KPSR_KPKD = 0x1
	// No key presses detected
	KPP_KPSR_KPKD_KPKD_0 = 0x0
	// A key has been depressed
	KPP_KPSR_KPKD_KPKD_1 = 0x1
	// Position of KPKR field.
	KPP_KPSR_KPKR_Pos = 0x1
	// Bit mask of KPKR field.
	KPP_KPSR_KPKR_Msk = 0x2
	// Bit KPKR.
	KPP_KPSR_KPKR = 0x2
	// No key release detected
	KPP_KPSR_KPKR_KPKR_0 = 0x0
	// All keys have been released
	KPP_KPSR_KPKR_KPKR_1 = 0x1
	// Position of KDSC field.
	KPP_KPSR_KDSC_Pos = 0x2
	// Bit mask of KDSC field.
	KPP_KPSR_KDSC_Msk = 0x4
	// Bit KDSC.
	KPP_KPSR_KDSC = 0x4
	// No effect
	KPP_KPSR_KDSC_KDSC_0 = 0x0
	// Set bits that clear the keypad depress synchronizer chain
	KPP_KPSR_KDSC_KDSC_1 = 0x1
	// Position of KRSS field.
	KPP_KPSR_KRSS_Pos = 0x3
	// Bit mask of KRSS field.
	KPP_KPSR_KRSS_Msk = 0x8
	// Bit KRSS.
	KPP_KPSR_KRSS = 0x8
	// No effect
	KPP_KPSR_KRSS_KRSS_0 = 0x0
	// Set bits which sets keypad release synchronizer chain
	KPP_KPSR_KRSS_KRSS_1 = 0x1
	// Position of KDIE field.
	KPP_KPSR_KDIE_Pos = 0x8
	// Bit mask of KDIE field.
	KPP_KPSR_KDIE_Msk = 0x100
	// Bit KDIE.
	KPP_KPSR_KDIE = 0x100
	// No interrupt request is generated when KPKD is set.
	KPP_KPSR_KDIE_KDIE_0 = 0x0
	// An interrupt request is generated when KPKD is set.
	KPP_KPSR_KDIE_KDIE_1 = 0x1
	// Position of KRIE field.
	KPP_KPSR_KRIE_Pos = 0x9
	// Bit mask of KRIE field.
	KPP_KPSR_KRIE_Msk = 0x200
	// Bit KRIE.
	KPP_KPSR_KRIE = 0x200
	// No interrupt request is generated when KPKR is set.
	KPP_KPSR_KRIE_KRIE_0 = 0x0
	// An interrupt request is generated when KPKR is set.
	KPP_KPSR_KRIE_KRIE_1 = 0x1

	// KDDR: Keypad Data Direction Register
	// Position of KRDD field.
	KPP_KDDR_KRDD_Pos = 0x0
	// Bit mask of KRDD field.
	KPP_KDDR_KRDD_Msk = 0xff
	// ROWn pin configured as an input.
	KPP_KDDR_KRDD_INPUT = 0x0
	// ROWn pin configured as an output.
	KPP_KDDR_KRDD_OUTPUT = 0x1
	// Position of KCDD field.
	KPP_KDDR_KCDD_Pos = 0x8
	// Bit mask of KCDD field.
	KPP_KDDR_KCDD_Msk = 0xff00
	// COLn pin is configured as an input.
	KPP_KDDR_KCDD_INPUT = 0x0
	// COLn pin is configured as an output.
	KPP_KDDR_KCDD_OUTPUT = 0x1

	// KPDR: Keypad Data Register
	// Position of KRD field.
	KPP_KPDR_KRD_Pos = 0x0
	// Bit mask of KRD field.
	KPP_KPDR_KRD_Msk = 0xff
	// Position of KCD field.
	KPP_KPDR_KCD_Pos = 0x8
	// Bit mask of KCD field.
	KPP_KPDR_KCD_Msk = 0xff00
)

// Constants for SystemControl: System Control Block
const (
	// ACTLR: Auxiliary Control Register,
	// Position of DISFOLD field.
	SCB_ACTLR_DISFOLD_Pos = 0x2
	// Bit mask of DISFOLD field.
	SCB_ACTLR_DISFOLD_Msk = 0x4
	// Bit DISFOLD.
	SCB_ACTLR_DISFOLD = 0x4
	// Normal operation.
	SCB_ACTLR_DISFOLD_DISFOLD_0 = 0x0
	// Position of FPEXCODIS field.
	SCB_ACTLR_FPEXCODIS_Pos = 0xa
	// Bit mask of FPEXCODIS field.
	SCB_ACTLR_FPEXCODIS_Msk = 0x400
	// Bit FPEXCODIS.
	SCB_ACTLR_FPEXCODIS = 0x400
	// Normal operation.
	SCB_ACTLR_FPEXCODIS_FPEXCODIS_0 = 0x0
	// FPU exception outputs are disabled.
	SCB_ACTLR_FPEXCODIS_FPEXCODIS_1 = 0x1
	// Position of DISRAMODE field.
	SCB_ACTLR_DISRAMODE_Pos = 0xb
	// Bit mask of DISRAMODE field.
	SCB_ACTLR_DISRAMODE_Msk = 0x800
	// Bit DISRAMODE.
	SCB_ACTLR_DISRAMODE = 0x800
	// Normal operation.
	SCB_ACTLR_DISRAMODE_DISRAMODE_0 = 0x0
	// Dynamic disabled.
	SCB_ACTLR_DISRAMODE_DISRAMODE_1 = 0x1
	// Position of DISITMATBFLUSH field.
	SCB_ACTLR_DISITMATBFLUSH_Pos = 0xc
	// Bit mask of DISITMATBFLUSH field.
	SCB_ACTLR_DISITMATBFLUSH_Msk = 0x1000
	// Bit DISITMATBFLUSH.
	SCB_ACTLR_DISITMATBFLUSH = 0x1000
	// ITM and DWT ATB flush disabled, this bit is always 1.
	SCB_ACTLR_DISITMATBFLUSH_DISITMATBFLUSH_1 = 0x1
	// Position of DISBTACREAD field.
	SCB_ACTLR_DISBTACREAD_Pos = 0xd
	// Bit mask of DISBTACREAD field.
	SCB_ACTLR_DISBTACREAD_Msk = 0x2000
	// Bit DISBTACREAD.
	SCB_ACTLR_DISBTACREAD = 0x2000
	// Normal operation.
	SCB_ACTLR_DISBTACREAD_DISBTACREAD_0 = 0x0
	// BTAC is not used and only static branch prediction can occur.
	SCB_ACTLR_DISBTACREAD_DISBTACREAD_1 = 0x1
	// Position of DISBTACALLOC field.
	SCB_ACTLR_DISBTACALLOC_Pos = 0xe
	// Bit mask of DISBTACALLOC field.
	SCB_ACTLR_DISBTACALLOC_Msk = 0x4000
	// Bit DISBTACALLOC.
	SCB_ACTLR_DISBTACALLOC = 0x4000
	// Normal operation.
	SCB_ACTLR_DISBTACALLOC_DISBTACALLOC_0 = 0x0
	// No new entries are allocated in Branch Target Address Cache (BTAC), but existing entries can be updated.
	SCB_ACTLR_DISBTACALLOC_DISBTACALLOC_1 = 0x1
	// Position of DISCRITAXIRUR field.
	SCB_ACTLR_DISCRITAXIRUR_Pos = 0xf
	// Bit mask of DISCRITAXIRUR field.
	SCB_ACTLR_DISCRITAXIRUR_Msk = 0x8000
	// Bit DISCRITAXIRUR.
	SCB_ACTLR_DISCRITAXIRUR = 0x8000
	// Normal operation.
	SCB_ACTLR_DISCRITAXIRUR_DISCRITAXIRUR_0 = 0x0
	// An AXI read to Strongly-Ordered or Device memory, or an LDREX to Shareable memory, is not put on AXI if there are any outstanding reads on AXI. Transactions on AXI cannot be interrupted. This bit might reduce the time that these transactions are in progress and might improve worst case interrupt latency. Performance is decreased when this bit is set.
	SCB_ACTLR_DISCRITAXIRUR_DISCRITAXIRUR_1 = 0x1
	// Position of DISDI field.
	SCB_ACTLR_DISDI_Pos = 0x10
	// Bit mask of DISDI field.
	SCB_ACTLR_DISDI_Msk = 0x1f0000
	// Normal operation.
	SCB_ACTLR_DISDI_DISDI_0 = 0x0
	// Nothing can be dual-issued when this instruction type is in channel 0.
	SCB_ACTLR_DISDI_DISDI_1 = 0x1
	// Position of DISISSCH1 field.
	SCB_ACTLR_DISISSCH1_Pos = 0x15
	// Bit mask of DISISSCH1 field.
	SCB_ACTLR_DISISSCH1_Msk = 0x3e00000
	// Normal operation.
	SCB_ACTLR_DISISSCH1_DISISSCH1_0 = 0x0
	// Nothing can be dual-issued when this instruction type is in channel 1.
	SCB_ACTLR_DISISSCH1_DISISSCH1_1 = 0x1
	// Position of DISDYNADD field.
	SCB_ACTLR_DISDYNADD_Pos = 0x1a
	// Bit mask of DISDYNADD field.
	SCB_ACTLR_DISDYNADD_Msk = 0x4000000
	// Bit DISDYNADD.
	SCB_ACTLR_DISDYNADD = 0x4000000
	// Normal operation. Some ADD and SUB instrctions are resolved in EX1.
	SCB_ACTLR_DISDYNADD_DISDYNADD_0 = 0x0
	// All ADD and SUB instructions are resolved in EX2.
	SCB_ACTLR_DISDYNADD_DISDYNADD_1 = 0x1
	// Position of DISCRITAXIRUW field.
	SCB_ACTLR_DISCRITAXIRUW_Pos = 0x1b
	// Bit mask of DISCRITAXIRUW field.
	SCB_ACTLR_DISCRITAXIRUW_Msk = 0x8000000
	// Bit DISCRITAXIRUW.
	SCB_ACTLR_DISCRITAXIRUW = 0x8000000
	// Normal operation. This is backwards compatible with r0.
	SCB_ACTLR_DISCRITAXIRUW_DISCRITAXIRUW_0 = 0x0
	// AXI reads to DEV/SO memory. Exclusive reads to Shareable memory are not initiated on the AXIM AR channel until all outstanding stores on AXI are complete.
	SCB_ACTLR_DISCRITAXIRUW_DISCRITAXIRUW_1 = 0x1
	// Position of DISFPUISSOPT field.
	SCB_ACTLR_DISFPUISSOPT_Pos = 0x1c
	// Bit mask of DISFPUISSOPT field.
	SCB_ACTLR_DISFPUISSOPT_Msk = 0x10000000
	// Bit DISFPUISSOPT.
	SCB_ACTLR_DISFPUISSOPT = 0x10000000
	// Normal operation.
	SCB_ACTLR_DISFPUISSOPT_DISFPUISSOPT_0 = 0x0

	// CPUID: CPUID Base Register
	// Position of REVISION field.
	SCB_CPUID_REVISION_Pos = 0x0
	// Bit mask of REVISION field.
	SCB_CPUID_REVISION_Msk = 0xf
	// Position of PARTNO field.
	SCB_CPUID_PARTNO_Pos = 0x4
	// Bit mask of PARTNO field.
	SCB_CPUID_PARTNO_Msk = 0xfff0
	// Position of ARCHITECTURE field.
	SCB_CPUID_ARCHITECTURE_Pos = 0x10
	// Bit mask of ARCHITECTURE field.
	SCB_CPUID_ARCHITECTURE_Msk = 0xf0000
	// Position of VARIANT field.
	SCB_CPUID_VARIANT_Pos = 0x14
	// Bit mask of VARIANT field.
	SCB_CPUID_VARIANT_Msk = 0xf00000
	// Position of IMPLEMENTER field.
	SCB_CPUID_IMPLEMENTER_Pos = 0x18
	// Bit mask of IMPLEMENTER field.
	SCB_CPUID_IMPLEMENTER_Msk = 0xff000000

	// ICSR: Interrupt Control and State Register
	// Position of VECTACTIVE field.
	SCB_ICSR_VECTACTIVE_Pos = 0x0
	// Bit mask of VECTACTIVE field.
	SCB_ICSR_VECTACTIVE_Msk = 0x1ff
	// Position of RETTOBASE field.
	SCB_ICSR_RETTOBASE_Pos = 0xb
	// Bit mask of RETTOBASE field.
	SCB_ICSR_RETTOBASE_Msk = 0x800
	// Bit RETTOBASE.
	SCB_ICSR_RETTOBASE = 0x800
	// there are preempted active exceptions to execute
	SCB_ICSR_RETTOBASE_RETTOBASE_0 = 0x0
	// there are no active exceptions, or the currently-executing exception is the only active exception
	SCB_ICSR_RETTOBASE_RETTOBASE_1 = 0x1
	// Position of VECTPENDING field.
	SCB_ICSR_VECTPENDING_Pos = 0xc
	// Bit mask of VECTPENDING field.
	SCB_ICSR_VECTPENDING_Msk = 0x1ff000
	// Position of ISRPENDING field.
	SCB_ICSR_ISRPENDING_Pos = 0x16
	// Bit mask of ISRPENDING field.
	SCB_ICSR_ISRPENDING_Msk = 0x400000
	// Bit ISRPENDING.
	SCB_ICSR_ISRPENDING = 0x400000
	// No external interrupt pending.
	SCB_ICSR_ISRPENDING_ISRPENDING_0 = 0x0
	// External interrupt pending.
	SCB_ICSR_ISRPENDING_ISRPENDING_1 = 0x1
	// Position of PENDSTCLR field.
	SCB_ICSR_PENDSTCLR_Pos = 0x19
	// Bit mask of PENDSTCLR field.
	SCB_ICSR_PENDSTCLR_Msk = 0x2000000
	// Bit PENDSTCLR.
	SCB_ICSR_PENDSTCLR = 0x2000000
	// no effect
	SCB_ICSR_PENDSTCLR_PENDSTCLR_0 = 0x0
	// removes the pending state from the SysTick exception
	SCB_ICSR_PENDSTCLR_PENDSTCLR_1 = 0x1
	// Position of PENDSTSET field.
	SCB_ICSR_PENDSTSET_Pos = 0x1a
	// Bit mask of PENDSTSET field.
	SCB_ICSR_PENDSTSET_Msk = 0x4000000
	// Bit PENDSTSET.
	SCB_ICSR_PENDSTSET = 0x4000000
	// write: no effect; read: SysTick exception is not pending
	SCB_ICSR_PENDSTSET_PENDSTSET_0 = 0x0
	// write: changes SysTick exception state to pending; read: SysTick exception is pending
	SCB_ICSR_PENDSTSET_PENDSTSET_1 = 0x1
	// Position of PENDSVCLR field.
	SCB_ICSR_PENDSVCLR_Pos = 0x1b
	// Bit mask of PENDSVCLR field.
	SCB_ICSR_PENDSVCLR_Msk = 0x8000000
	// Bit PENDSVCLR.
	SCB_ICSR_PENDSVCLR = 0x8000000
	// no effect
	SCB_ICSR_PENDSVCLR_PENDSVCLR_0 = 0x0
	// removes the pending state from the PendSV exception
	SCB_ICSR_PENDSVCLR_PENDSVCLR_1 = 0x1
	// Position of PENDSVSET field.
	SCB_ICSR_PENDSVSET_Pos = 0x1c
	// Bit mask of PENDSVSET field.
	SCB_ICSR_PENDSVSET_Msk = 0x10000000
	// Bit PENDSVSET.
	SCB_ICSR_PENDSVSET = 0x10000000
	// write: no effect; read: PendSV exception is not pending
	SCB_ICSR_PENDSVSET_PENDSVSET_0 = 0x0
	// write: changes PendSV exception state to pending; read: PendSV exception is pending
	SCB_ICSR_PENDSVSET_PENDSVSET_1 = 0x1
	// Position of NMIPENDSET field.
	SCB_ICSR_NMIPENDSET_Pos = 0x1f
	// Bit mask of NMIPENDSET field.
	SCB_ICSR_NMIPENDSET_Msk = 0x80000000
	// Bit NMIPENDSET.
	SCB_ICSR_NMIPENDSET = 0x80000000
	// write: no effect; read: NMI exception is not pending
	SCB_ICSR_NMIPENDSET_NMIPENDSET_0 = 0x0
	// write: changes NMI exception state to pending; read: NMI exception is pending
	SCB_ICSR_NMIPENDSET_NMIPENDSET_1 = 0x1

	// VTOR: Vector Table Offset Register
	// Position of TBLOFF field.
	SCB_VTOR_TBLOFF_Pos = 0x7
	// Bit mask of TBLOFF field.
	SCB_VTOR_TBLOFF_Msk = 0xffffff80

	// AIRCR: Application Interrupt and Reset Control Register
	// Position of VECTRESET field.
	SCB_AIRCR_VECTRESET_Pos = 0x0
	// Bit mask of VECTRESET field.
	SCB_AIRCR_VECTRESET_Msk = 0x1
	// Bit VECTRESET.
	SCB_AIRCR_VECTRESET = 0x1
	// No change
	SCB_AIRCR_VECTRESET_VECTRESET_0 = 0x0
	// Causes a local system reset
	SCB_AIRCR_VECTRESET_VECTRESET_1 = 0x1
	// Position of VECTCLRACTIVE field.
	SCB_AIRCR_VECTCLRACTIVE_Pos = 0x1
	// Bit mask of VECTCLRACTIVE field.
	SCB_AIRCR_VECTCLRACTIVE_Msk = 0x2
	// Bit VECTCLRACTIVE.
	SCB_AIRCR_VECTCLRACTIVE = 0x2
	// No change
	SCB_AIRCR_VECTCLRACTIVE_VECTCLRACTIVE_0 = 0x0
	// Clears all active state information for fixed and configurable exceptions
	SCB_AIRCR_VECTCLRACTIVE_VECTCLRACTIVE_1 = 0x1
	// Position of SYSRESETREQ field.
	SCB_AIRCR_SYSRESETREQ_Pos = 0x2
	// Bit mask of SYSRESETREQ field.
	SCB_AIRCR_SYSRESETREQ_Msk = 0x4
	// Bit SYSRESETREQ.
	SCB_AIRCR_SYSRESETREQ = 0x4
	// no system reset request
	SCB_AIRCR_SYSRESETREQ_SYSRESETREQ_0 = 0x0
	// asserts a signal to the outer system that requests a reset
	SCB_AIRCR_SYSRESETREQ_SYSRESETREQ_1 = 0x1
	// Position of PRIGROUP field.
	SCB_AIRCR_PRIGROUP_Pos = 0x8
	// Bit mask of PRIGROUP field.
	SCB_AIRCR_PRIGROUP_Msk = 0x700
	// Position of ENDIANNESS field.
	SCB_AIRCR_ENDIANNESS_Pos = 0xf
	// Bit mask of ENDIANNESS field.
	SCB_AIRCR_ENDIANNESS_Msk = 0x8000
	// Bit ENDIANNESS.
	SCB_AIRCR_ENDIANNESS = 0x8000
	// Little-endian
	SCB_AIRCR_ENDIANNESS_ENDIANNESS_0 = 0x0
	// Big-endian
	SCB_AIRCR_ENDIANNESS_ENDIANNESS_1 = 0x1
	// Position of VECTKEY field.
	SCB_AIRCR_VECTKEY_Pos = 0x10
	// Bit mask of VECTKEY field.
	SCB_AIRCR_VECTKEY_Msk = 0xffff0000

	// SCR: System Control Register
	// Position of SLEEPONEXIT field.
	SCB_SCR_SLEEPONEXIT_Pos = 0x1
	// Bit mask of SLEEPONEXIT field.
	SCB_SCR_SLEEPONEXIT_Msk = 0x2
	// Bit SLEEPONEXIT.
	SCB_SCR_SLEEPONEXIT = 0x2
	// o not sleep when returning to Thread mode
	SCB_SCR_SLEEPONEXIT_SLEEPONEXIT_0 = 0x0
	// enter sleep, or deep sleep, on return from an ISR
	SCB_SCR_SLEEPONEXIT_SLEEPONEXIT_1 = 0x1
	// Position of SLEEPDEEP field.
	SCB_SCR_SLEEPDEEP_Pos = 0x2
	// Bit mask of SLEEPDEEP field.
	SCB_SCR_SLEEPDEEP_Msk = 0x4
	// Bit SLEEPDEEP.
	SCB_SCR_SLEEPDEEP = 0x4
	// sleep
	SCB_SCR_SLEEPDEEP_SLEEPDEEP_0 = 0x0
	// deep sleep
	SCB_SCR_SLEEPDEEP_SLEEPDEEP_1 = 0x1
	// Position of SEVONPEND field.
	SCB_SCR_SEVONPEND_Pos = 0x4
	// Bit mask of SEVONPEND field.
	SCB_SCR_SEVONPEND_Msk = 0x10
	// Bit SEVONPEND.
	SCB_SCR_SEVONPEND = 0x10
	// only enabled interrupts or events can wakeup the processor, disabled interrupts are excluded
	SCB_SCR_SEVONPEND_SEVONPEND_0 = 0x0
	// enabled events and all interrupts, including disabled interrupts, can wakeup the processor
	SCB_SCR_SEVONPEND_SEVONPEND_1 = 0x1

	// CCR: Configuration and Control Register
	// Position of NONBASETHRDENA field.
	SCB_CCR_NONBASETHRDENA_Pos = 0x0
	// Bit mask of NONBASETHRDENA field.
	SCB_CCR_NONBASETHRDENA_Msk = 0x1
	// Bit NONBASETHRDENA.
	SCB_CCR_NONBASETHRDENA = 0x1
	// processor can enter Thread mode only when no exception is active
	SCB_CCR_NONBASETHRDENA_NONBASETHRDENA_0 = 0x0
	// processor can enter Thread mode from any level under the control of an EXC_RETURN value
	SCB_CCR_NONBASETHRDENA_NONBASETHRDENA_1 = 0x1
	// Position of USERSETMPEND field.
	SCB_CCR_USERSETMPEND_Pos = 0x1
	// Bit mask of USERSETMPEND field.
	SCB_CCR_USERSETMPEND_Msk = 0x2
	// Bit USERSETMPEND.
	SCB_CCR_USERSETMPEND = 0x2
	// disable
	SCB_CCR_USERSETMPEND_USERSETMPEND_0 = 0x0
	// enable
	SCB_CCR_USERSETMPEND_USERSETMPEND_1 = 0x1
	// Position of UNALIGN_TRP field.
	SCB_CCR_UNALIGN_TRP_Pos = 0x3
	// Bit mask of UNALIGN_TRP field.
	SCB_CCR_UNALIGN_TRP_Msk = 0x8
	// Bit UNALIGN_TRP.
	SCB_CCR_UNALIGN_TRP = 0x8
	// do not trap unaligned halfword and word accesses
	SCB_CCR_UNALIGN_TRP_UNALIGN_TRP_0 = 0x0
	// trap unaligned halfword and word accesses
	SCB_CCR_UNALIGN_TRP_UNALIGN_TRP_1 = 0x1
	// Position of DIV_0_TRP field.
	SCB_CCR_DIV_0_TRP_Pos = 0x4
	// Bit mask of DIV_0_TRP field.
	SCB_CCR_DIV_0_TRP_Msk = 0x10
	// Bit DIV_0_TRP.
	SCB_CCR_DIV_0_TRP = 0x10
	// do not trap divide by 0
	SCB_CCR_DIV_0_TRP_DIV_0_TRP_0 = 0x0
	// trap divide by 0
	SCB_CCR_DIV_0_TRP_DIV_0_TRP_1 = 0x1
	// Position of BFHFNMIGN field.
	SCB_CCR_BFHFNMIGN_Pos = 0x8
	// Bit mask of BFHFNMIGN field.
	SCB_CCR_BFHFNMIGN_Msk = 0x100
	// Bit BFHFNMIGN.
	SCB_CCR_BFHFNMIGN = 0x100
	// data bus faults caused by load and store instructions cause a lock-up
	SCB_CCR_BFHFNMIGN_BFHFNMIGN_0 = 0x0
	// handlers running at priority -1 and -2 ignore data bus faults caused by load and store instructions
	SCB_CCR_BFHFNMIGN_BFHFNMIGN_1 = 0x1
	// Position of STKALIGN field.
	SCB_CCR_STKALIGN_Pos = 0x9
	// Bit mask of STKALIGN field.
	SCB_CCR_STKALIGN_Msk = 0x200
	// Bit STKALIGN.
	SCB_CCR_STKALIGN = 0x200
	// 4-byte aligned
	SCB_CCR_STKALIGN_STKALIGN_0 = 0x0
	// 8-byte aligned
	SCB_CCR_STKALIGN_STKALIGN_1 = 0x1
	// Position of DC field.
	SCB_CCR_DC_Pos = 0x10
	// Bit mask of DC field.
	SCB_CCR_DC_Msk = 0x10000
	// Bit DC.
	SCB_CCR_DC = 0x10000
	// L1 data cache disabled
	SCB_CCR_DC_DC_0 = 0x0
	// L1 data cache enabled
	SCB_CCR_DC_DC_1 = 0x1
	// Position of IC field.
	SCB_CCR_IC_Pos = 0x11
	// Bit mask of IC field.
	SCB_CCR_IC_Msk = 0x20000
	// Bit IC.
	SCB_CCR_IC = 0x20000
	// L1 instruction cache disabled
	SCB_CCR_IC_IC_0 = 0x0
	// L1 instruction cache enabled
	SCB_CCR_IC_IC_1 = 0x1
	// Position of BP field.
	SCB_CCR_BP_Pos = 0x12
	// Bit mask of BP field.
	SCB_CCR_BP_Msk = 0x40000
	// Bit BP.
	SCB_CCR_BP = 0x40000

	// SHPR1: System Handler Priority Register 1
	// Position of PRI_4 field.
	SCB_SHPR1_PRI_4_Pos = 0x0
	// Bit mask of PRI_4 field.
	SCB_SHPR1_PRI_4_Msk = 0xff
	// Position of PRI_5 field.
	SCB_SHPR1_PRI_5_Pos = 0x8
	// Bit mask of PRI_5 field.
	SCB_SHPR1_PRI_5_Msk = 0xff00
	// Position of PRI_6 field.
	SCB_SHPR1_PRI_6_Pos = 0x10
	// Bit mask of PRI_6 field.
	SCB_SHPR1_PRI_6_Msk = 0xff0000

	// SHPR2: System Handler Priority Register 2
	// Position of PRI_11 field.
	SCB_SHPR2_PRI_11_Pos = 0x18
	// Bit mask of PRI_11 field.
	SCB_SHPR2_PRI_11_Msk = 0xff000000

	// SHPR3: System Handler Priority Register 3
	// Position of PRI_14 field.
	SCB_SHPR3_PRI_14_Pos = 0x10
	// Bit mask of PRI_14 field.
	SCB_SHPR3_PRI_14_Msk = 0xff0000
	// Position of PRI_15 field.
	SCB_SHPR3_PRI_15_Pos = 0x18
	// Bit mask of PRI_15 field.
	SCB_SHPR3_PRI_15_Msk = 0xff000000

	// SHCSR: System Handler Control and State Register
	// Position of MEMFAULTACT field.
	SCB_SHCSR_MEMFAULTACT_Pos = 0x0
	// Bit mask of MEMFAULTACT field.
	SCB_SHCSR_MEMFAULTACT_Msk = 0x1
	// Bit MEMFAULTACT.
	SCB_SHCSR_MEMFAULTACT = 0x1
	// exception is not active
	SCB_SHCSR_MEMFAULTACT_MEMFAULTACT_0 = 0x0
	// exception is active
	SCB_SHCSR_MEMFAULTACT_MEMFAULTACT_1 = 0x1
	// Position of BUSFAULTACT field.
	SCB_SHCSR_BUSFAULTACT_Pos = 0x1
	// Bit mask of BUSFAULTACT field.
	SCB_SHCSR_BUSFAULTACT_Msk = 0x2
	// Bit BUSFAULTACT.
	SCB_SHCSR_BUSFAULTACT = 0x2
	// exception is not active
	SCB_SHCSR_BUSFAULTACT_BUSFAULTACT_0 = 0x0
	// exception is active
	SCB_SHCSR_BUSFAULTACT_BUSFAULTACT_1 = 0x1
	// Position of USGFAULTACT field.
	SCB_SHCSR_USGFAULTACT_Pos = 0x3
	// Bit mask of USGFAULTACT field.
	SCB_SHCSR_USGFAULTACT_Msk = 0x8
	// Bit USGFAULTACT.
	SCB_SHCSR_USGFAULTACT = 0x8
	// exception is not active
	SCB_SHCSR_USGFAULTACT_USGFAULTACT_0 = 0x0
	// exception is active
	SCB_SHCSR_USGFAULTACT_USGFAULTACT_1 = 0x1
	// Position of SVCALLACT field.
	SCB_SHCSR_SVCALLACT_Pos = 0x7
	// Bit mask of SVCALLACT field.
	SCB_SHCSR_SVCALLACT_Msk = 0x80
	// Bit SVCALLACT.
	SCB_SHCSR_SVCALLACT = 0x80
	// exception is not active
	SCB_SHCSR_SVCALLACT_SVCALLACT_0 = 0x0
	// exception is active
	SCB_SHCSR_SVCALLACT_SVCALLACT_1 = 0x1
	// Position of MONITORACT field.
	SCB_SHCSR_MONITORACT_Pos = 0x8
	// Bit mask of MONITORACT field.
	SCB_SHCSR_MONITORACT_Msk = 0x100
	// Bit MONITORACT.
	SCB_SHCSR_MONITORACT = 0x100
	// exception is not active
	SCB_SHCSR_MONITORACT_MONITORACT_0 = 0x0
	// exception is active
	SCB_SHCSR_MONITORACT_MONITORACT_1 = 0x1
	// Position of PENDSVACT field.
	SCB_SHCSR_PENDSVACT_Pos = 0xa
	// Bit mask of PENDSVACT field.
	SCB_SHCSR_PENDSVACT_Msk = 0x400
	// Bit PENDSVACT.
	SCB_SHCSR_PENDSVACT = 0x400
	// exception is not active
	SCB_SHCSR_PENDSVACT_PENDSVACT_0 = 0x0
	// exception is active
	SCB_SHCSR_PENDSVACT_PENDSVACT_1 = 0x1
	// Position of SYSTICKACT field.
	SCB_SHCSR_SYSTICKACT_Pos = 0xb
	// Bit mask of SYSTICKACT field.
	SCB_SHCSR_SYSTICKACT_Msk = 0x800
	// Bit SYSTICKACT.
	SCB_SHCSR_SYSTICKACT = 0x800
	// exception is not active
	SCB_SHCSR_SYSTICKACT_SYSTICKACT_0 = 0x0
	// exception is active
	SCB_SHCSR_SYSTICKACT_SYSTICKACT_1 = 0x1
	// Position of USGFAULTPENDED field.
	SCB_SHCSR_USGFAULTPENDED_Pos = 0xc
	// Bit mask of USGFAULTPENDED field.
	SCB_SHCSR_USGFAULTPENDED_Msk = 0x1000
	// Bit USGFAULTPENDED.
	SCB_SHCSR_USGFAULTPENDED = 0x1000
	// exception is not pending
	SCB_SHCSR_USGFAULTPENDED_USGFAULTPENDED_0 = 0x0
	// exception is pending
	SCB_SHCSR_USGFAULTPENDED_USGFAULTPENDED_1 = 0x1
	// Position of MEMFAULTPENDED field.
	SCB_SHCSR_MEMFAULTPENDED_Pos = 0xd
	// Bit mask of MEMFAULTPENDED field.
	SCB_SHCSR_MEMFAULTPENDED_Msk = 0x2000
	// Bit MEMFAULTPENDED.
	SCB_SHCSR_MEMFAULTPENDED = 0x2000
	// exception is not pending
	SCB_SHCSR_MEMFAULTPENDED_MEMFAULTPENDED_0 = 0x0
	// exception is pending
	SCB_SHCSR_MEMFAULTPENDED_MEMFAULTPENDED_1 = 0x1
	// Position of BUSFAULTPENDED field.
	SCB_SHCSR_BUSFAULTPENDED_Pos = 0xe
	// Bit mask of BUSFAULTPENDED field.
	SCB_SHCSR_BUSFAULTPENDED_Msk = 0x4000
	// Bit BUSFAULTPENDED.
	SCB_SHCSR_BUSFAULTPENDED = 0x4000
	// exception is not pending
	SCB_SHCSR_BUSFAULTPENDED_BUSFAULTPENDED_0 = 0x0
	// exception is pending
	SCB_SHCSR_BUSFAULTPENDED_BUSFAULTPENDED_1 = 0x1
	// Position of SVCALLPENDED field.
	SCB_SHCSR_SVCALLPENDED_Pos = 0xf
	// Bit mask of SVCALLPENDED field.
	SCB_SHCSR_SVCALLPENDED_Msk = 0x8000
	// Bit SVCALLPENDED.
	SCB_SHCSR_SVCALLPENDED = 0x8000
	// exception is not pending
	SCB_SHCSR_SVCALLPENDED_SVCALLPENDED_0 = 0x0
	// exception is pending
	SCB_SHCSR_SVCALLPENDED_SVCALLPENDED_1 = 0x1
	// Position of MEMFAULTENA field.
	SCB_SHCSR_MEMFAULTENA_Pos = 0x10
	// Bit mask of MEMFAULTENA field.
	SCB_SHCSR_MEMFAULTENA_Msk = 0x10000
	// Bit MEMFAULTENA.
	SCB_SHCSR_MEMFAULTENA = 0x10000
	// disable the exception
	SCB_SHCSR_MEMFAULTENA_MEMFAULTENA_0 = 0x0
	// enable the exception
	SCB_SHCSR_MEMFAULTENA_MEMFAULTENA_1 = 0x1
	// Position of BUSFAULTENA field.
	SCB_SHCSR_BUSFAULTENA_Pos = 0x11
	// Bit mask of BUSFAULTENA field.
	SCB_SHCSR_BUSFAULTENA_Msk = 0x20000
	// Bit BUSFAULTENA.
	SCB_SHCSR_BUSFAULTENA = 0x20000
	// disable the exception
	SCB_SHCSR_BUSFAULTENA_BUSFAULTENA_0 = 0x0
	// enable the exception
	SCB_SHCSR_BUSFAULTENA_BUSFAULTENA_1 = 0x1
	// Position of USGFAULTENA field.
	SCB_SHCSR_USGFAULTENA_Pos = 0x12
	// Bit mask of USGFAULTENA field.
	SCB_SHCSR_USGFAULTENA_Msk = 0x40000
	// Bit USGFAULTENA.
	SCB_SHCSR_USGFAULTENA = 0x40000
	// disable the exception
	SCB_SHCSR_USGFAULTENA_USGFAULTENA_0 = 0x0
	// enable the exception
	SCB_SHCSR_USGFAULTENA_USGFAULTENA_1 = 0x1

	// CFSR: Configurable Fault Status Register
	// Position of IACCVIOL field.
	SCB_CFSR_IACCVIOL_Pos = 0x0
	// Bit mask of IACCVIOL field.
	SCB_CFSR_IACCVIOL_Msk = 0x1
	// Bit IACCVIOL.
	SCB_CFSR_IACCVIOL = 0x1
	// no instruction access violation fault
	SCB_CFSR_IACCVIOL_IACCVIOL_0 = 0x0
	// the processor attempted an instruction fetch from a location that does not permit execution
	SCB_CFSR_IACCVIOL_IACCVIOL_1 = 0x1
	// Position of DACCVIOL field.
	SCB_CFSR_DACCVIOL_Pos = 0x1
	// Bit mask of DACCVIOL field.
	SCB_CFSR_DACCVIOL_Msk = 0x2
	// Bit DACCVIOL.
	SCB_CFSR_DACCVIOL = 0x2
	// no data access violation fault
	SCB_CFSR_DACCVIOL_DACCVIOL_0 = 0x0
	// the processor attempted a load or store at a location that does not permit the operation
	SCB_CFSR_DACCVIOL_DACCVIOL_1 = 0x1
	// Position of MUNSTKERR field.
	SCB_CFSR_MUNSTKERR_Pos = 0x3
	// Bit mask of MUNSTKERR field.
	SCB_CFSR_MUNSTKERR_Msk = 0x8
	// Bit MUNSTKERR.
	SCB_CFSR_MUNSTKERR = 0x8
	// no unstacking fault
	SCB_CFSR_MUNSTKERR_MUNSTKERR_0 = 0x0
	// unstack for an exception return has caused one or more access violations
	SCB_CFSR_MUNSTKERR_MUNSTKERR_1 = 0x1
	// Position of MSTKERR field.
	SCB_CFSR_MSTKERR_Pos = 0x4
	// Bit mask of MSTKERR field.
	SCB_CFSR_MSTKERR_Msk = 0x10
	// Bit MSTKERR.
	SCB_CFSR_MSTKERR = 0x10
	// no stacking fault
	SCB_CFSR_MSTKERR_MSTKERR_0 = 0x0
	// stacking for an exception entry has caused one or more access violations
	SCB_CFSR_MSTKERR_MSTKERR_1 = 0x1
	// Position of MLSPERR field.
	SCB_CFSR_MLSPERR_Pos = 0x5
	// Bit mask of MLSPERR field.
	SCB_CFSR_MLSPERR_Msk = 0x20
	// Bit MLSPERR.
	SCB_CFSR_MLSPERR = 0x20
	// No MemManage fault occurred during floating-point lazy state preservation
	SCB_CFSR_MLSPERR_MLSPERR_0 = 0x0
	// A MemManage fault occurred during floating-point lazy state preservation
	SCB_CFSR_MLSPERR_MLSPERR_1 = 0x1
	// Position of MMARVALID field.
	SCB_CFSR_MMARVALID_Pos = 0x7
	// Bit mask of MMARVALID field.
	SCB_CFSR_MMARVALID_Msk = 0x80
	// Bit MMARVALID.
	SCB_CFSR_MMARVALID = 0x80
	// value in MMAR is not a valid fault address
	SCB_CFSR_MMARVALID_MMARVALID_0 = 0x0
	// MMAR holds a valid fault address
	SCB_CFSR_MMARVALID_MMARVALID_1 = 0x1
	// Position of IBUSERR field.
	SCB_CFSR_IBUSERR_Pos = 0x8
	// Bit mask of IBUSERR field.
	SCB_CFSR_IBUSERR_Msk = 0x100
	// Bit IBUSERR.
	SCB_CFSR_IBUSERR = 0x100
	// no instruction bus error
	SCB_CFSR_IBUSERR_IBUSERR_0 = 0x0
	// instruction bus error
	SCB_CFSR_IBUSERR_IBUSERR_1 = 0x1
	// Position of PRECISERR field.
	SCB_CFSR_PRECISERR_Pos = 0x9
	// Bit mask of PRECISERR field.
	SCB_CFSR_PRECISERR_Msk = 0x200
	// Bit PRECISERR.
	SCB_CFSR_PRECISERR = 0x200
	// no precise data bus error
	SCB_CFSR_PRECISERR_PRECISERR_0 = 0x0
	// a data bus error has occurred, and the PC value stacked for the exception return points to the instruction that caused the fault
	SCB_CFSR_PRECISERR_PRECISERR_1 = 0x1
	// Position of IMPRECISERR field.
	SCB_CFSR_IMPRECISERR_Pos = 0xa
	// Bit mask of IMPRECISERR field.
	SCB_CFSR_IMPRECISERR_Msk = 0x400
	// Bit IMPRECISERR.
	SCB_CFSR_IMPRECISERR = 0x400
	// no imprecise data bus error
	SCB_CFSR_IMPRECISERR_IMPRECISERR_0 = 0x0
	// a data bus error has occurred, but the return address in the stack frame is not related to the instruction that caused the error
	SCB_CFSR_IMPRECISERR_IMPRECISERR_1 = 0x1
	// Position of UNSTKERR field.
	SCB_CFSR_UNSTKERR_Pos = 0xb
	// Bit mask of UNSTKERR field.
	SCB_CFSR_UNSTKERR_Msk = 0x800
	// Bit UNSTKERR.
	SCB_CFSR_UNSTKERR = 0x800
	// no unstacking fault
	SCB_CFSR_UNSTKERR_UNSTKERR_0 = 0x0
	// unstack for an exception return has caused one or more BusFaults
	SCB_CFSR_UNSTKERR_UNSTKERR_1 = 0x1
	// Position of STKERR field.
	SCB_CFSR_STKERR_Pos = 0xc
	// Bit mask of STKERR field.
	SCB_CFSR_STKERR_Msk = 0x1000
	// Bit STKERR.
	SCB_CFSR_STKERR = 0x1000
	// no stacking fault
	SCB_CFSR_STKERR_STKERR_0 = 0x0
	// stacking for an exception entry has caused one or more BusFaults
	SCB_CFSR_STKERR_STKERR_1 = 0x1
	// Position of LSPERR field.
	SCB_CFSR_LSPERR_Pos = 0xd
	// Bit mask of LSPERR field.
	SCB_CFSR_LSPERR_Msk = 0x2000
	// Bit LSPERR.
	SCB_CFSR_LSPERR = 0x2000
	// No bus fault occurred during floating-point lazy state preservation
	SCB_CFSR_LSPERR_LSPERR_0 = 0x0
	// A bus fault occurred during floating-point lazy state preservation
	SCB_CFSR_LSPERR_LSPERR_1 = 0x1
	// Position of BFARVALID field.
	SCB_CFSR_BFARVALID_Pos = 0xf
	// Bit mask of BFARVALID field.
	SCB_CFSR_BFARVALID_Msk = 0x8000
	// Bit BFARVALID.
	SCB_CFSR_BFARVALID = 0x8000
	// value in BFAR is not a valid fault address
	SCB_CFSR_BFARVALID_BFARVALID_0 = 0x0
	// BFAR holds a valid fault address
	SCB_CFSR_BFARVALID_BFARVALID_1 = 0x1
	// Position of UNDEFINSTR field.
	SCB_CFSR_UNDEFINSTR_Pos = 0x10
	// Bit mask of UNDEFINSTR field.
	SCB_CFSR_UNDEFINSTR_Msk = 0x10000
	// Bit UNDEFINSTR.
	SCB_CFSR_UNDEFINSTR = 0x10000
	// no undefined instruction UsageFault
	SCB_CFSR_UNDEFINSTR_UNDEFINSTR_0 = 0x0
	// the processor has attempted to execute an undefined instruction
	SCB_CFSR_UNDEFINSTR_UNDEFINSTR_1 = 0x1
	// Position of INVSTATE field.
	SCB_CFSR_INVSTATE_Pos = 0x11
	// Bit mask of INVSTATE field.
	SCB_CFSR_INVSTATE_Msk = 0x20000
	// Bit INVSTATE.
	SCB_CFSR_INVSTATE = 0x20000
	// no invalid state UsageFault
	SCB_CFSR_INVSTATE_INVSTATE_0 = 0x0
	// the processor has attempted to execute an instruction that makes illegal use of the EPSR
	SCB_CFSR_INVSTATE_INVSTATE_1 = 0x1
	// Position of INVPC field.
	SCB_CFSR_INVPC_Pos = 0x12
	// Bit mask of INVPC field.
	SCB_CFSR_INVPC_Msk = 0x40000
	// Bit INVPC.
	SCB_CFSR_INVPC = 0x40000
	// no invalid PC load UsageFault
	SCB_CFSR_INVPC_INVPC_0 = 0x0
	// the processor has attempted an illegal load of EXC_RETURN to the PC
	SCB_CFSR_INVPC_INVPC_1 = 0x1
	// Position of NOCP field.
	SCB_CFSR_NOCP_Pos = 0x13
	// Bit mask of NOCP field.
	SCB_CFSR_NOCP_Msk = 0x80000
	// Bit NOCP.
	SCB_CFSR_NOCP = 0x80000
	// no UsageFault caused by attempting to access a coprocessor
	SCB_CFSR_NOCP_NOCP_0 = 0x0
	// the processor has attempted to access a coprocessor
	SCB_CFSR_NOCP_NOCP_1 = 0x1
	// Position of UNALIGNED field.
	SCB_CFSR_UNALIGNED_Pos = 0x18
	// Bit mask of UNALIGNED field.
	SCB_CFSR_UNALIGNED_Msk = 0x1000000
	// Bit UNALIGNED.
	SCB_CFSR_UNALIGNED = 0x1000000
	// no unaligned access fault, or unaligned access trapping not enabled
	SCB_CFSR_UNALIGNED_UNALIGNED_0 = 0x0
	// the processor has made an unaligned memory access
	SCB_CFSR_UNALIGNED_UNALIGNED_1 = 0x1
	// Position of DIVBYZERO field.
	SCB_CFSR_DIVBYZERO_Pos = 0x19
	// Bit mask of DIVBYZERO field.
	SCB_CFSR_DIVBYZERO_Msk = 0x2000000
	// Bit DIVBYZERO.
	SCB_CFSR_DIVBYZERO = 0x2000000
	// no divide by zero fault, or divide by zero trapping not enabled
	SCB_CFSR_DIVBYZERO_DIVBYZERO_0 = 0x0
	// the processor has executed an SDIV or UDIV instruction with a divisor of 0
	SCB_CFSR_DIVBYZERO_DIVBYZERO_1 = 0x1

	// HFSR: HardFault Status register
	// Position of VECTTBL field.
	SCB_HFSR_VECTTBL_Pos = 0x1
	// Bit mask of VECTTBL field.
	SCB_HFSR_VECTTBL_Msk = 0x2
	// Bit VECTTBL.
	SCB_HFSR_VECTTBL = 0x2
	// no BusFault on vector table read
	SCB_HFSR_VECTTBL_VECTTBL_0 = 0x0
	// BusFault on vector table read
	SCB_HFSR_VECTTBL_VECTTBL_1 = 0x1
	// Position of FORCED field.
	SCB_HFSR_FORCED_Pos = 0x1e
	// Bit mask of FORCED field.
	SCB_HFSR_FORCED_Msk = 0x40000000
	// Bit FORCED.
	SCB_HFSR_FORCED = 0x40000000
	// no forced HardFault
	SCB_HFSR_FORCED_FORCED_0 = 0x0
	// forced HardFault
	SCB_HFSR_FORCED_FORCED_1 = 0x1
	// Position of DEBUGEVT field.
	SCB_HFSR_DEBUGEVT_Pos = 0x1f
	// Bit mask of DEBUGEVT field.
	SCB_HFSR_DEBUGEVT_Msk = 0x80000000
	// Bit DEBUGEVT.
	SCB_HFSR_DEBUGEVT = 0x80000000
	// No Debug event has occurred.
	SCB_HFSR_DEBUGEVT_DEBUGEVT_0 = 0x0
	// Debug event has occurred. The Debug Fault Status Register has been updated.
	SCB_HFSR_DEBUGEVT_DEBUGEVT_1 = 0x1

	// DFSR: Debug Fault Status Register
	// Position of HALTED field.
	SCB_DFSR_HALTED_Pos = 0x0
	// Bit mask of HALTED field.
	SCB_DFSR_HALTED_Msk = 0x1
	// Bit HALTED.
	SCB_DFSR_HALTED = 0x1
	// No active halt request debug event
	SCB_DFSR_HALTED_HALTED_0 = 0x0
	// Halt request debug event active
	SCB_DFSR_HALTED_HALTED_1 = 0x1
	// Position of BKPT field.
	SCB_DFSR_BKPT_Pos = 0x1
	// Bit mask of BKPT field.
	SCB_DFSR_BKPT_Msk = 0x2
	// Bit BKPT.
	SCB_DFSR_BKPT = 0x2
	// No current breakpoint debug event
	SCB_DFSR_BKPT_BKPT_0 = 0x0
	// At least one current breakpoint debug event
	SCB_DFSR_BKPT_BKPT_1 = 0x1
	// Position of DWTTRAP field.
	SCB_DFSR_DWTTRAP_Pos = 0x2
	// Bit mask of DWTTRAP field.
	SCB_DFSR_DWTTRAP_Msk = 0x4
	// Bit DWTTRAP.
	SCB_DFSR_DWTTRAP = 0x4
	// No current debug events generated by the DWT
	SCB_DFSR_DWTTRAP_DWTTRAP_0 = 0x0
	// At least one current debug event generated by the DWT
	SCB_DFSR_DWTTRAP_DWTTRAP_1 = 0x1
	// Position of VCATCH field.
	SCB_DFSR_VCATCH_Pos = 0x3
	// Bit mask of VCATCH field.
	SCB_DFSR_VCATCH_Msk = 0x8
	// Bit VCATCH.
	SCB_DFSR_VCATCH = 0x8
	// No Vector catch triggered
	SCB_DFSR_VCATCH_VCATCH_0 = 0x0
	// Vector catch triggered
	SCB_DFSR_VCATCH_VCATCH_1 = 0x1
	// Position of EXTERNAL field.
	SCB_DFSR_EXTERNAL_Pos = 0x4
	// Bit mask of EXTERNAL field.
	SCB_DFSR_EXTERNAL_Msk = 0x10
	// Bit EXTERNAL.
	SCB_DFSR_EXTERNAL = 0x10
	// No external debug request debug event
	SCB_DFSR_EXTERNAL_EXTERNAL_0 = 0x0
	// External debug request debug event
	SCB_DFSR_EXTERNAL_EXTERNAL_1 = 0x1

	// MMFAR: MemManage Fault Address Register
	// Position of ADDRESS field.
	SCB_MMFAR_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	SCB_MMFAR_ADDRESS_Msk = 0xffffffff

	// BFAR: BusFault Address Register
	// Position of ADDRESS field.
	SCB_BFAR_ADDRESS_Pos = 0x0
	// Bit mask of ADDRESS field.
	SCB_BFAR_ADDRESS_Msk = 0xffffffff

	// ID_PFR0: Processor Feature Register 0
	// Position of STATE0 field.
	SCB_ID_PFR0_STATE0_Pos = 0x0
	// Bit mask of STATE0 field.
	SCB_ID_PFR0_STATE0_Msk = 0xf
	// ARMv7-M unused
	SCB_ID_PFR0_STATE0_STATE0_0 = 0x0
	// ARMv7-M unused
	SCB_ID_PFR0_STATE0_STATE0_1 = 0x1
	// ARMv7-M unused
	SCB_ID_PFR0_STATE0_STATE0_2 = 0x2
	// Support for Thumb encoding including Thumb-2 technology, with all basic 16-bit and 32-bit instructions.
	SCB_ID_PFR0_STATE0_STATE0_3 = 0x3
	// Position of STATE1 field.
	SCB_ID_PFR0_STATE1_Pos = 0x4
	// Bit mask of STATE1 field.
	SCB_ID_PFR0_STATE1_Msk = 0xf0
	// The processor does not support the ARM instruction set.
	SCB_ID_PFR0_STATE1_STATE1_0 = 0x0
	// ARMv7-M unused
	SCB_ID_PFR0_STATE1_STATE1_1 = 0x1
	// Position of STATE2 field.
	SCB_ID_PFR0_STATE2_Pos = 0x8
	// Bit mask of STATE2 field.
	SCB_ID_PFR0_STATE2_Msk = 0xf00
	// Position of STATE3 field.
	SCB_ID_PFR0_STATE3_Pos = 0xc
	// Bit mask of STATE3 field.
	SCB_ID_PFR0_STATE3_Msk = 0xf000

	// ID_PFR1: Processor Feature Register 1
	// Position of PROGMODEL field.
	SCB_ID_PFR1_PROGMODEL_Pos = 0x8
	// Bit mask of PROGMODEL field.
	SCB_ID_PFR1_PROGMODEL_Msk = 0xf00
	// ARMv7-M unused
	SCB_ID_PFR1_PROGMODEL_PROGMODEL_0 = 0x0
	// Two-stack programmers' model supported
	SCB_ID_PFR1_PROGMODEL_PROGMODEL_2 = 0x2

	// ID_DFR0: Debug Feature Register
	// Position of DEBUGMODEL field.
	SCB_ID_DFR0_DEBUGMODEL_Pos = 0x14
	// Bit mask of DEBUGMODEL field.
	SCB_ID_DFR0_DEBUGMODEL_Msk = 0xf00000
	// Not supported
	SCB_ID_DFR0_DEBUGMODEL_DEBUGMODEL_0 = 0x0
	// Support for M profile Debug architecture, with memory-mapped access.
	SCB_ID_DFR0_DEBUGMODEL_DEBUGMODEL_1 = 0x1

	// ID_AFR0: Auxiliary Feature Register
	// Position of IMPLEMENTATION_DEFINED0 field.
	SCB_ID_AFR0_IMPLEMENTATION_DEFINED0_Pos = 0x0
	// Bit mask of IMPLEMENTATION_DEFINED0 field.
	SCB_ID_AFR0_IMPLEMENTATION_DEFINED0_Msk = 0xf
	// Position of IMPLEMENTATION_DEFINED1 field.
	SCB_ID_AFR0_IMPLEMENTATION_DEFINED1_Pos = 0x4
	// Bit mask of IMPLEMENTATION_DEFINED1 field.
	SCB_ID_AFR0_IMPLEMENTATION_DEFINED1_Msk = 0xf0
	// Position of IMPLEMENTATION_DEFINED2 field.
	SCB_ID_AFR0_IMPLEMENTATION_DEFINED2_Pos = 0x8
	// Bit mask of IMPLEMENTATION_DEFINED2 field.
	SCB_ID_AFR0_IMPLEMENTATION_DEFINED2_Msk = 0xf00
	// Position of IMPLEMENTATION_DEFINED3 field.
	SCB_ID_AFR0_IMPLEMENTATION_DEFINED3_Pos = 0xc
	// Bit mask of IMPLEMENTATION_DEFINED3 field.
	SCB_ID_AFR0_IMPLEMENTATION_DEFINED3_Msk = 0xf000

	// ID_MMFR0: Memory Model Feature Register 0
	// Position of PMSASUPPORT field.
	SCB_ID_MMFR0_PMSASUPPORT_Pos = 0x4
	// Bit mask of PMSASUPPORT field.
	SCB_ID_MMFR0_PMSASUPPORT_Msk = 0xf0
	// Not supported
	SCB_ID_MMFR0_PMSASUPPORT_PMSASUPPORT_0 = 0x0
	// ARMv7-M unused
	SCB_ID_MMFR0_PMSASUPPORT_PMSASUPPORT_1 = 0x1
	// ARMv7-M unused
	SCB_ID_MMFR0_PMSASUPPORT_PMSASUPPORT_2 = 0x2
	// PMSAv7, providing support for a base region and subregions.
	SCB_ID_MMFR0_PMSASUPPORT_PMSASUPPORT_3 = 0x3
	// Position of OUTERMOST_SHAREABILITY field.
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_Pos = 0x8
	// Bit mask of OUTERMOST_SHAREABILITY field.
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_Msk = 0xf00
	// Implemented as Non-cacheable
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_0 = 0x0
	// ARMv7-M unused
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_1 = 0x1
	// ARMv7-M unused
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_2 = 0x2
	// ARMv7-M unused
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_3 = 0x3
	// ARMv7-M unused
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_4 = 0x4
	// ARMv7-M unused
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_5 = 0x5
	// ARMv7-M unused
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_6 = 0x6
	// ARMv7-M unused
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_7 = 0x7
	// ARMv7-M unused
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_8 = 0x8
	// ARMv7-M unused
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_9 = 0x9
	// ARMv7-M unused
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_10 = 0xa
	// ARMv7-M unused
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_11 = 0xb
	// ARMv7-M unused
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_12 = 0xc
	// ARMv7-M unused
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_13 = 0xd
	// ARMv7-M unused
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_14 = 0xe
	// Shareability ignored.
	SCB_ID_MMFR0_OUTERMOST_SHAREABILITY_OUTERMOST_SHAREABILITY_15 = 0xf
	// Position of SHAREABILITY_LEVELS field.
	SCB_ID_MMFR0_SHAREABILITY_LEVELS_Pos = 0xc
	// Bit mask of SHAREABILITY_LEVELS field.
	SCB_ID_MMFR0_SHAREABILITY_LEVELS_Msk = 0xf000
	// One level of shareability implemented
	SCB_ID_MMFR0_SHAREABILITY_LEVELS_SHAREABILITY_LEVELS_0 = 0x0
	// ARMv7-M unused
	SCB_ID_MMFR0_SHAREABILITY_LEVELS_SHAREABILITY_LEVELS_1 = 0x1
	// Position of TCM_SUPPORT field.
	SCB_ID_MMFR0_TCM_SUPPORT_Pos = 0x10
	// Bit mask of TCM_SUPPORT field.
	SCB_ID_MMFR0_TCM_SUPPORT_Msk = 0xf0000
	// No tightly coupled memories implemented.
	SCB_ID_MMFR0_TCM_SUPPORT_TCM_SUPPORT_0 = 0x0
	// Tightly coupled memories implemented with IMPLEMENTATION DEFINED control.
	SCB_ID_MMFR0_TCM_SUPPORT_TCM_SUPPORT_1 = 0x1
	// ARMv7-M unused
	SCB_ID_MMFR0_TCM_SUPPORT_TCM_SUPPORT_2 = 0x2
	// Position of AUXILIARY_REGISTERS field.
	SCB_ID_MMFR0_AUXILIARY_REGISTERS_Pos = 0x14
	// Bit mask of AUXILIARY_REGISTERS field.
	SCB_ID_MMFR0_AUXILIARY_REGISTERS_Msk = 0xf00000
	// Not supported
	SCB_ID_MMFR0_AUXILIARY_REGISTERS_AUXILIARY_REGISTERS_0 = 0x0
	// Support for Auxiliary Control Register only.
	SCB_ID_MMFR0_AUXILIARY_REGISTERS_AUXILIARY_REGISTERS_1 = 0x1
	// ARMv7-M unused
	SCB_ID_MMFR0_AUXILIARY_REGISTERS_AUXILIARY_REGISTERS_2 = 0x2

	// ID_MMFR1: Memory Model Feature Register 1
	// Position of ID_MMFR1 field.
	SCB_ID_MMFR1_ID_MMFR1_Pos = 0x0
	// Bit mask of ID_MMFR1 field.
	SCB_ID_MMFR1_ID_MMFR1_Msk = 0xffffffff

	// ID_MMFR2: Memory Model Feature Register 2
	// Position of WFI_STALL field.
	SCB_ID_MMFR2_WFI_STALL_Pos = 0x18
	// Bit mask of WFI_STALL field.
	SCB_ID_MMFR2_WFI_STALL_Msk = 0xf000000
	// Not supported
	SCB_ID_MMFR2_WFI_STALL_WFI_STALL_0 = 0x0
	// Support for WFI stalling
	SCB_ID_MMFR2_WFI_STALL_WFI_STALL_1 = 0x1

	// ID_MMFR3: Memory Model Feature Register 3
	// Position of ID_MMFR3 field.
	SCB_ID_MMFR3_ID_MMFR3_Pos = 0x0
	// Bit mask of ID_MMFR3 field.
	SCB_ID_MMFR3_ID_MMFR3_Msk = 0xffffffff

	// ID_ISAR0: Instruction Set Attributes Register 0
	// Position of BITCOUNT_INSTRS field.
	SCB_ID_ISAR0_BITCOUNT_INSTRS_Pos = 0x4
	// Bit mask of BITCOUNT_INSTRS field.
	SCB_ID_ISAR0_BITCOUNT_INSTRS_Msk = 0xf0
	// None supported, ARMv7-M unused
	SCB_ID_ISAR0_BITCOUNT_INSTRS_BITCOUNT_INSTRS_0 = 0x0
	// Adds support for the CLZ instruction
	SCB_ID_ISAR0_BITCOUNT_INSTRS_BITCOUNT_INSTRS_1 = 0x1
	// Position of BITFIELD_INSTRS field.
	SCB_ID_ISAR0_BITFIELD_INSTRS_Pos = 0x8
	// Bit mask of BITFIELD_INSTRS field.
	SCB_ID_ISAR0_BITFIELD_INSTRS_Msk = 0xf00
	// None supported, ARMv7-M unused
	SCB_ID_ISAR0_BITFIELD_INSTRS_BITFIELD_INSTRS_0 = 0x0
	// Adds support for the BFC, BFI, SBFX, and UBFX instructions
	SCB_ID_ISAR0_BITFIELD_INSTRS_BITFIELD_INSTRS_1 = 0x1
	// Position of CMPBRANCH_INSTRS field.
	SCB_ID_ISAR0_CMPBRANCH_INSTRS_Pos = 0xc
	// Bit mask of CMPBRANCH_INSTRS field.
	SCB_ID_ISAR0_CMPBRANCH_INSTRS_Msk = 0xf000
	// None supported, ARMv7-M unused
	SCB_ID_ISAR0_CMPBRANCH_INSTRS_CMPBRANCH_INSTRS_0 = 0x0
	// Adds support for the CBNZ and CBZ instructions
	SCB_ID_ISAR0_CMPBRANCH_INSTRS_CMPBRANCH_INSTRS_1 = 0x1
	// Position of COPROC_INSTRS field.
	SCB_ID_ISAR0_COPROC_INSTRS_Pos = 0x10
	// Bit mask of COPROC_INSTRS field.
	SCB_ID_ISAR0_COPROC_INSTRS_Msk = 0xf0000
	// None supported, except for separately attributed architectures, for example the Floating-point extension
	SCB_ID_ISAR0_COPROC_INSTRS_COPROC_INSTRS_0 = 0x0
	// Adds support for generic CDP, LDC, MCR, MRC, and STC instructions
	SCB_ID_ISAR0_COPROC_INSTRS_COPROC_INSTRS_1 = 0x1
	// As for 1, and adds support for generic CDP2, LDC2, MCR2, MRC2, and STC2 instructions
	SCB_ID_ISAR0_COPROC_INSTRS_COPROC_INSTRS_2 = 0x2
	// As for 2, and adds support for generic MCRR and MRRC instructions
	SCB_ID_ISAR0_COPROC_INSTRS_COPROC_INSTRS_3 = 0x3
	// As for 3, and adds support for generic MCRR2 and MRRC2 instructions
	SCB_ID_ISAR0_COPROC_INSTRS_COPROC_INSTRS_4 = 0x4
	// Position of DEBUG_INSTRS field.
	SCB_ID_ISAR0_DEBUG_INSTRS_Pos = 0x14
	// Bit mask of DEBUG_INSTRS field.
	SCB_ID_ISAR0_DEBUG_INSTRS_Msk = 0xf00000
	// None supported, ARMv7-M unused
	SCB_ID_ISAR0_DEBUG_INSTRS_DEBUG_INSTRS_0 = 0x0
	// Adds support for the BKPT instruction
	SCB_ID_ISAR0_DEBUG_INSTRS_DEBUG_INSTRS_1 = 0x1
	// Position of DIVIDE_INSTRS field.
	SCB_ID_ISAR0_DIVIDE_INSTRS_Pos = 0x18
	// Bit mask of DIVIDE_INSTRS field.
	SCB_ID_ISAR0_DIVIDE_INSTRS_Msk = 0xf000000
	// None supported, ARMv7-M unused
	SCB_ID_ISAR0_DIVIDE_INSTRS_DIVIDE_INSTRS_0 = 0x0
	// Adds support for the SDIV and UDIV instructions
	SCB_ID_ISAR0_DIVIDE_INSTRS_DIVIDE_INSTRS_1 = 0x1

	// ID_ISAR1: Instruction Set Attributes Register 1
	// Position of EXTEND_INSTRS field.
	SCB_ID_ISAR1_EXTEND_INSTRS_Pos = 0xc
	// Bit mask of EXTEND_INSTRS field.
	SCB_ID_ISAR1_EXTEND_INSTRS_Msk = 0xf000
	// None supported, ARMv7-M unused
	SCB_ID_ISAR1_EXTEND_INSTRS_EXTEND_INSTRS_0 = 0x0
	// Adds support for the SXTB, SXTH, UXTB, and UXTH instructions
	SCB_ID_ISAR1_EXTEND_INSTRS_EXTEND_INSTRS_1 = 0x1
	// As for 1, and adds support for the SXTAB, SXTAB16, SXTAH, SXTB16, UXTAB, UXTAB16, UXTAH, and UXTB16 instructions
	SCB_ID_ISAR1_EXTEND_INSTRS_EXTEND_INSTRS_2 = 0x2
	// Position of IFTHEN_INSTRS field.
	SCB_ID_ISAR1_IFTHEN_INSTRS_Pos = 0x10
	// Bit mask of IFTHEN_INSTRS field.
	SCB_ID_ISAR1_IFTHEN_INSTRS_Msk = 0xf0000
	// None supported, ARMv7-M unused
	SCB_ID_ISAR1_IFTHEN_INSTRS_IFTHEN_INSTRS_0 = 0x0
	// Adds support for the IT instructions, and for the IT bits in the PSRs
	SCB_ID_ISAR1_IFTHEN_INSTRS_IFTHEN_INSTRS_1 = 0x1
	// Position of IMMEDIATE_INSTRS field.
	SCB_ID_ISAR1_IMMEDIATE_INSTRS_Pos = 0x14
	// Bit mask of IMMEDIATE_INSTRS field.
	SCB_ID_ISAR1_IMMEDIATE_INSTRS_Msk = 0xf00000
	// None supported, ARMv7-M unused
	SCB_ID_ISAR1_IMMEDIATE_INSTRS_IMMEDIATE_INSTRS_0 = 0x0
	// Adds support for the ADDW, MOVW, MOVT, and SUBW instructions
	SCB_ID_ISAR1_IMMEDIATE_INSTRS_IMMEDIATE_INSTRS_1 = 0x1
	// Position of INTERWORK_INSTRS field.
	SCB_ID_ISAR1_INTERWORK_INSTRS_Pos = 0x18
	// Bit mask of INTERWORK_INSTRS field.
	SCB_ID_ISAR1_INTERWORK_INSTRS_Msk = 0xf000000
	// None supported, ARMv7-M unused
	SCB_ID_ISAR1_INTERWORK_INSTRS_INTERWORK_INSTRS_0 = 0x0
	// Adds support for the BX instruction, and the T bit in the PSR
	SCB_ID_ISAR1_INTERWORK_INSTRS_INTERWORK_INSTRS_1 = 0x1
	// As for 1, and adds support for the BLX instruction, and PC loads have BX-like behavior
	SCB_ID_ISAR1_INTERWORK_INSTRS_INTERWORK_INSTRS_2 = 0x2
	// ARMv7-M unused
	SCB_ID_ISAR1_INTERWORK_INSTRS_INTERWORK_INSTRS_3 = 0x3

	// ID_ISAR2: Instruction Set Attributes Register 2
	// Position of LOADSTORE_INSTRS field.
	SCB_ID_ISAR2_LOADSTORE_INSTRS_Pos = 0x0
	// Bit mask of LOADSTORE_INSTRS field.
	SCB_ID_ISAR2_LOADSTORE_INSTRS_Msk = 0xf
	// None supported, ARMv7-M unused
	SCB_ID_ISAR2_LOADSTORE_INSTRS_LOADSTORE_INSTRS_0 = 0x0
	// Adds support for the LDRD and STRD instructions
	SCB_ID_ISAR2_LOADSTORE_INSTRS_LOADSTORE_INSTRS_1 = 0x1
	// Position of MEMHINT_INSTRS field.
	SCB_ID_ISAR2_MEMHINT_INSTRS_Pos = 0x4
	// Bit mask of MEMHINT_INSTRS field.
	SCB_ID_ISAR2_MEMHINT_INSTRS_Msk = 0xf0
	// None supported, ARMv7-M unused.
	SCB_ID_ISAR2_MEMHINT_INSTRS_MEMHINT_INSTRS_0 = 0x0
	// Adds support for the PLD instruction, ARMv7-M unused.
	SCB_ID_ISAR2_MEMHINT_INSTRS_MEMHINT_INSTRS_1 = 0x1
	// As for 1, ARMv7-M unused.
	SCB_ID_ISAR2_MEMHINT_INSTRS_MEMHINT_INSTRS_2 = 0x2
	// As for 1 or 2, and adds support for the PLI instruction.
	SCB_ID_ISAR2_MEMHINT_INSTRS_MEMHINT_INSTRS_3 = 0x3
	// Position of MULTIACCESSINT_INSTRS field.
	SCB_ID_ISAR2_MULTIACCESSINT_INSTRS_Pos = 0x8
	// Bit mask of MULTIACCESSINT_INSTRS field.
	SCB_ID_ISAR2_MULTIACCESSINT_INSTRS_Msk = 0xf00
	// None supported. This means the LDM and STM instructions are not interruptible. ARMv7-M unused.
	SCB_ID_ISAR2_MULTIACCESSINT_INSTRS_MULTIACCESSINT_INSTRS_0 = 0x0
	// LDM and STM instructions are restartable.
	SCB_ID_ISAR2_MULTIACCESSINT_INSTRS_MULTIACCESSINT_INSTRS_1 = 0x1
	// LDM and STM instructions are continuable.
	SCB_ID_ISAR2_MULTIACCESSINT_INSTRS_MULTIACCESSINT_INSTRS_2 = 0x2
	// Position of MULT_INSTRS field.
	SCB_ID_ISAR2_MULT_INSTRS_Pos = 0xc
	// Bit mask of MULT_INSTRS field.
	SCB_ID_ISAR2_MULT_INSTRS_Msk = 0xf000
	// None supported. This means only MUL is supported. ARMv7-M unused.
	SCB_ID_ISAR2_MULT_INSTRS_MULT_INSTRS_0 = 0x0
	// Adds support for the MLA instruction, ARMv7-M unused.
	SCB_ID_ISAR2_MULT_INSTRS_MULT_INSTRS_1 = 0x1
	// As for 1, and adds support for the MLS instruction.
	SCB_ID_ISAR2_MULT_INSTRS_MULT_INSTRS_2 = 0x2
	// Position of MULTS_INSTRS field.
	SCB_ID_ISAR2_MULTS_INSTRS_Pos = 0x10
	// Bit mask of MULTS_INSTRS field.
	SCB_ID_ISAR2_MULTS_INSTRS_Msk = 0xf0000
	// None supported, ARMv7-M unused
	SCB_ID_ISAR2_MULTS_INSTRS_MULTS_INSTRS_0 = 0x0
	// Adds support for the SMULL and SMLAL instructions
	SCB_ID_ISAR2_MULTS_INSTRS_MULTS_INSTRS_1 = 0x1
	// As for 1, and adds support for the SMLABB, SMLABT, SMLALBB, SMLALBT, SMLALTB, SMLALTT, SMLATB, SMLATT, SMLAWB, SMLAWT, SMULBB, SMULBT, SMULTB, SMULTT, SMULWB, and SMULWT instructions.
	SCB_ID_ISAR2_MULTS_INSTRS_MULTS_INSTRS_2 = 0x2
	// As for 2, and adds support for the SMLAD, SMLADX, SMLALD, SMLALDX, SMLSD, SMLSDX, SMLSLD, SMLSLDX, SMMLA, SMMLAR, SMMLS, SMMLSR, SMMUL, SMMULR, SMUAD, SMUADX, SMUSD, and SMUSDX instructions.
	SCB_ID_ISAR2_MULTS_INSTRS_MULTS_INSTRS_3 = 0x3
	// Position of MULTU_INSTRS field.
	SCB_ID_ISAR2_MULTU_INSTRS_Pos = 0x14
	// Bit mask of MULTU_INSTRS field.
	SCB_ID_ISAR2_MULTU_INSTRS_Msk = 0xf00000
	// None supported, ARMv7-M unused
	SCB_ID_ISAR2_MULTU_INSTRS_MULTU_INSTRS_0 = 0x0
	// Adds support for the UMULL and UMLAL instructions.
	SCB_ID_ISAR2_MULTU_INSTRS_MULTU_INSTRS_1 = 0x1
	// As for 1, and adds support for the UMAAL instruction.
	SCB_ID_ISAR2_MULTU_INSTRS_MULTU_INSTRS_2 = 0x2
	// Position of REVERSAL_INSTRS field.
	SCB_ID_ISAR2_REVERSAL_INSTRS_Pos = 0x1c
	// Bit mask of REVERSAL_INSTRS field.
	SCB_ID_ISAR2_REVERSAL_INSTRS_Msk = 0xf0000000
	// None supported, ARMv7-M unused
	SCB_ID_ISAR2_REVERSAL_INSTRS_REVERSAL_INSTRS_0 = 0x0
	// Adds support for the REV, REV16, and REVSH instructions, ARMv7-M unused.
	SCB_ID_ISAR2_REVERSAL_INSTRS_REVERSAL_INSTRS_1 = 0x1
	// As for 1, and adds support for the RBIT instruction.
	SCB_ID_ISAR2_REVERSAL_INSTRS_REVERSAL_INSTRS_2 = 0x2

	// ID_ISAR3: Instruction Set Attributes Register 3
	// Position of SATURATE_INSTRS field.
	SCB_ID_ISAR3_SATURATE_INSTRS_Pos = 0x0
	// Bit mask of SATURATE_INSTRS field.
	SCB_ID_ISAR3_SATURATE_INSTRS_Msk = 0xf
	// None supported
	SCB_ID_ISAR3_SATURATE_INSTRS_SATURATE_INSTRS_0 = 0x0
	// Adds support for the QADD, QDADD, QDSUB, and QSUB instructions, and for the Q bit in the PSRs.
	SCB_ID_ISAR3_SATURATE_INSTRS_SATURATE_INSTRS_1 = 0x1
	// Position of SIMD_INSTRS field.
	SCB_ID_ISAR3_SIMD_INSTRS_Pos = 0x4
	// Bit mask of SIMD_INSTRS field.
	SCB_ID_ISAR3_SIMD_INSTRS_Msk = 0xf0
	// None supported, ARMv7-M unused.
	SCB_ID_ISAR3_SIMD_INSTRS_SIMD_INSTRS_0 = 0x0
	// Adds support for the SSAT and USAT instructions, and for the Q bit in the PSRs.
	SCB_ID_ISAR3_SIMD_INSTRS_SIMD_INSTRS_1 = 0x1
	// As for 1, and adds support for the PKHBT, PKHTB, QADD16, QADD8, QASX, QSUB16, QSUB8, QSAX, SADD16, SADD8, SASX, SEL, SHADD16, SHADD8, SHASX, SHSUB16, SHSUB8, SHSAX, SSAT16, SSUB16, SSUB8, SSAX, SXTAB16, SXTB16, UADD16, UADD8, UASX, UHADD16, UHADD8, UHASX, UHSUB16, UHSUB8, UHSAX, UQADD16, UQADD8, UQASX, UQSUB16, UQSUB8, UQSAX, USAD8, USADA8, USAT16, USUB16, USUB8, USAX, UXTAB16, and UXTB16 instructions. Also adds support for the GE[3:0] bits in the PSRs.
	SCB_ID_ISAR3_SIMD_INSTRS_SIMD_INSTRS_3 = 0x3
	// Position of SVC_INSTRS field.
	SCB_ID_ISAR3_SVC_INSTRS_Pos = 0x8
	// Bit mask of SVC_INSTRS field.
	SCB_ID_ISAR3_SVC_INSTRS_Msk = 0xf00
	// None supported, ARMv7-M unused.
	SCB_ID_ISAR3_SVC_INSTRS_SVC_INSTRS_0 = 0x0
	// Adds support for the SVC instruction.
	SCB_ID_ISAR3_SVC_INSTRS_SVC_INSTRS_1 = 0x1
	// Position of SYNCHPRIM_INSTRS field.
	SCB_ID_ISAR3_SYNCHPRIM_INSTRS_Pos = 0xc
	// Bit mask of SYNCHPRIM_INSTRS field.
	SCB_ID_ISAR3_SYNCHPRIM_INSTRS_Msk = 0xf000
	// Position of TABBRANCH_INSTRS field.
	SCB_ID_ISAR3_TABBRANCH_INSTRS_Pos = 0x10
	// Bit mask of TABBRANCH_INSTRS field.
	SCB_ID_ISAR3_TABBRANCH_INSTRS_Msk = 0xf0000
	// None supported, ARMv7-M unused.
	SCB_ID_ISAR3_TABBRANCH_INSTRS_TABBRANCH_INSTRS_0 = 0x0
	// Adds support for the TBB and TBH instructions.
	SCB_ID_ISAR3_TABBRANCH_INSTRS_TABBRANCH_INSTRS_1 = 0x1
	// Position of THUMBCOPY_INSTRS field.
	SCB_ID_ISAR3_THUMBCOPY_INSTRS_Pos = 0x14
	// Bit mask of THUMBCOPY_INSTRS field.
	SCB_ID_ISAR3_THUMBCOPY_INSTRS_Msk = 0xf00000
	// None supported, ARMv7-M unused.
	SCB_ID_ISAR3_THUMBCOPY_INSTRS_THUMBCOPY_INSTRS_0 = 0x0
	// Adds support for encoding T1 of the MOV (register) instruction copying from a low register to a low register.
	SCB_ID_ISAR3_THUMBCOPY_INSTRS_THUMBCOPY_INSTRS_1 = 0x1
	// Position of TRUENOP_INSTRS field.
	SCB_ID_ISAR3_TRUENOP_INSTRS_Pos = 0x18
	// Bit mask of TRUENOP_INSTRS field.
	SCB_ID_ISAR3_TRUENOP_INSTRS_Msk = 0xf000000
	// None supported, ARMv7-M unused.
	SCB_ID_ISAR3_TRUENOP_INSTRS_TRUENOP_INSTRS_0 = 0x0
	// Adds support for encoding T1 of the MOV (register) instruction copying from a low register to a low register.
	SCB_ID_ISAR3_TRUENOP_INSTRS_TRUENOP_INSTRS_1 = 0x1

	// ID_ISAR4: Instruction Set Attributes Register 4
	// Position of UNPRIV_INSTRS field.
	SCB_ID_ISAR4_UNPRIV_INSTRS_Pos = 0x0
	// Bit mask of UNPRIV_INSTRS field.
	SCB_ID_ISAR4_UNPRIV_INSTRS_Msk = 0xf
	// None supported, ARMv7-M unused.
	SCB_ID_ISAR4_UNPRIV_INSTRS_UNPRIV_INSTRS_0 = 0x0
	// Adds support for the LDRBT, LDRT, STRBT, and STRT instructions.
	SCB_ID_ISAR4_UNPRIV_INSTRS_UNPRIV_INSTRS_1 = 0x1
	// As for 1, and adds support for the LDRHT, LDRSBT, LDRSHT, and STRHT instructions.
	SCB_ID_ISAR4_UNPRIV_INSTRS_UNPRIV_INSTRS_2 = 0x2
	// Position of WITHSHIFTS_INSTRS field.
	SCB_ID_ISAR4_WITHSHIFTS_INSTRS_Pos = 0x4
	// Bit mask of WITHSHIFTS_INSTRS field.
	SCB_ID_ISAR4_WITHSHIFTS_INSTRS_Msk = 0xf0
	// Nonzero shifts supported only in MOV and shift instructions.
	SCB_ID_ISAR4_WITHSHIFTS_INSTRS_WITHSHIFTS_INSTRS_0 = 0x0
	// Adds support for shifts of loads and stores over the range LSL 0-3.
	SCB_ID_ISAR4_WITHSHIFTS_INSTRS_WITHSHIFTS_INSTRS_1 = 0x1
	// As for 1, and adds support for other constant shift options, on loads, stores, and other instructions.
	SCB_ID_ISAR4_WITHSHIFTS_INSTRS_WITHSHIFTS_INSTRS_3 = 0x3
	// ARMv7-M unused.
	SCB_ID_ISAR4_WITHSHIFTS_INSTRS_WITHSHIFTS_INSTRS_4 = 0x4
	// Position of WRITEBACK_INSTRS field.
	SCB_ID_ISAR4_WRITEBACK_INSTRS_Pos = 0x8
	// Bit mask of WRITEBACK_INSTRS field.
	SCB_ID_ISAR4_WRITEBACK_INSTRS_Msk = 0xf00
	// Basic support. Only the LDM, STM, PUSH, and POP instructions support writeback addressing modes. ARMv7-M unused.
	SCB_ID_ISAR4_WRITEBACK_INSTRS_WRITEBACK_INSTRS_0 = 0x0
	// Adds support for all of the writeback addressing modes defined in the ARMv7-M architecture.
	SCB_ID_ISAR4_WRITEBACK_INSTRS_WRITEBACK_INSTRS_1 = 0x1
	// Position of BARRIER_INSTRS field.
	SCB_ID_ISAR4_BARRIER_INSTRS_Pos = 0x10
	// Bit mask of BARRIER_INSTRS field.
	SCB_ID_ISAR4_BARRIER_INSTRS_Msk = 0xf0000
	// None supported, ARMv7-M unused.
	SCB_ID_ISAR4_BARRIER_INSTRS_BARRIER_INSTRS_0 = 0x0
	// Adds support for the DMB, DSB, and ISB barrier instructions.
	SCB_ID_ISAR4_BARRIER_INSTRS_BARRIER_INSTRS_1 = 0x1
	// Position of SYNCHPRIM_INSTRS_FRAC field.
	SCB_ID_ISAR4_SYNCHPRIM_INSTRS_FRAC_Pos = 0x14
	// Bit mask of SYNCHPRIM_INSTRS_FRAC field.
	SCB_ID_ISAR4_SYNCHPRIM_INSTRS_FRAC_Msk = 0xf00000
	// Position of PSR_M_INSTRS field.
	SCB_ID_ISAR4_PSR_M_INSTRS_Pos = 0x18
	// Bit mask of PSR_M_INSTRS field.
	SCB_ID_ISAR4_PSR_M_INSTRS_Msk = 0xf000000
	// None supported, ARMv7-M unused.
	SCB_ID_ISAR4_PSR_M_INSTRS_PSR_M_INSTRS_0 = 0x0
	// Adds support for the M-profile forms of the CPS, MRS, and MSR instructions, to access the PSRs.
	SCB_ID_ISAR4_PSR_M_INSTRS_PSR_M_INSTRS_1 = 0x1

	// CLIDR: Cache Level ID register
	// Position of CL1 field.
	SCB_CLIDR_CL1_Pos = 0x0
	// Bit mask of CL1 field.
	SCB_CLIDR_CL1_Msk = 0x7
	// No cache
	SCB_CLIDR_CL1_CL1_0 = 0x0
	// Instruction cache only
	SCB_CLIDR_CL1_CL1_1 = 0x1
	// Data cache only
	SCB_CLIDR_CL1_CL1_2 = 0x2
	// Separate instruction and data caches
	SCB_CLIDR_CL1_CL1_3 = 0x3
	// Unified cache
	SCB_CLIDR_CL1_CL1_4 = 0x4
	// Position of CL2 field.
	SCB_CLIDR_CL2_Pos = 0x3
	// Bit mask of CL2 field.
	SCB_CLIDR_CL2_Msk = 0x38
	// No cache
	SCB_CLIDR_CL2_CL2_0 = 0x0
	// Instruction cache only
	SCB_CLIDR_CL2_CL2_1 = 0x1
	// Data cache only
	SCB_CLIDR_CL2_CL2_2 = 0x2
	// Separate instruction and data caches
	SCB_CLIDR_CL2_CL2_3 = 0x3
	// Unified cache
	SCB_CLIDR_CL2_CL2_4 = 0x4
	// Position of CL3 field.
	SCB_CLIDR_CL3_Pos = 0x6
	// Bit mask of CL3 field.
	SCB_CLIDR_CL3_Msk = 0x1c0
	// No cache
	SCB_CLIDR_CL3_CL3_0 = 0x0
	// Instruction cache only
	SCB_CLIDR_CL3_CL3_1 = 0x1
	// Data cache only
	SCB_CLIDR_CL3_CL3_2 = 0x2
	// Separate instruction and data caches
	SCB_CLIDR_CL3_CL3_3 = 0x3
	// Unified cache
	SCB_CLIDR_CL3_CL3_4 = 0x4
	// Position of CL4 field.
	SCB_CLIDR_CL4_Pos = 0x9
	// Bit mask of CL4 field.
	SCB_CLIDR_CL4_Msk = 0xe00
	// No cache
	SCB_CLIDR_CL4_CL4_0 = 0x0
	// Instruction cache only
	SCB_CLIDR_CL4_CL4_1 = 0x1
	// Data cache only
	SCB_CLIDR_CL4_CL4_2 = 0x2
	// Separate instruction and data caches
	SCB_CLIDR_CL4_CL4_3 = 0x3
	// Unified cache
	SCB_CLIDR_CL4_CL4_4 = 0x4
	// Position of CL5 field.
	SCB_CLIDR_CL5_Pos = 0xc
	// Bit mask of CL5 field.
	SCB_CLIDR_CL5_Msk = 0x7000
	// No cache
	SCB_CLIDR_CL5_CL5_0 = 0x0
	// Instruction cache only
	SCB_CLIDR_CL5_CL5_1 = 0x1
	// Data cache only
	SCB_CLIDR_CL5_CL5_2 = 0x2
	// Separate instruction and data caches
	SCB_CLIDR_CL5_CL5_3 = 0x3
	// Unified cache
	SCB_CLIDR_CL5_CL5_4 = 0x4
	// Position of CL6 field.
	SCB_CLIDR_CL6_Pos = 0xf
	// Bit mask of CL6 field.
	SCB_CLIDR_CL6_Msk = 0x38000
	// No cache
	SCB_CLIDR_CL6_CL6_0 = 0x0
	// Instruction cache only
	SCB_CLIDR_CL6_CL6_1 = 0x1
	// Data cache only
	SCB_CLIDR_CL6_CL6_2 = 0x2
	// Separate instruction and data caches
	SCB_CLIDR_CL6_CL6_3 = 0x3
	// Unified cache
	SCB_CLIDR_CL6_CL6_4 = 0x4
	// Position of CL7 field.
	SCB_CLIDR_CL7_Pos = 0x12
	// Bit mask of CL7 field.
	SCB_CLIDR_CL7_Msk = 0x1c0000
	// No cache
	SCB_CLIDR_CL7_CL7_0 = 0x0
	// Instruction cache only
	SCB_CLIDR_CL7_CL7_1 = 0x1
	// Data cache only
	SCB_CLIDR_CL7_CL7_2 = 0x2
	// Separate instruction and data caches
	SCB_CLIDR_CL7_CL7_3 = 0x3
	// Unified cache
	SCB_CLIDR_CL7_CL7_4 = 0x4
	// Position of LOUIS field.
	SCB_CLIDR_LOUIS_Pos = 0x15
	// Bit mask of LOUIS field.
	SCB_CLIDR_LOUIS_Msk = 0xe00000
	// 0
	SCB_CLIDR_LOUIS_LOUIS_0 = 0x0
	// 1
	SCB_CLIDR_LOUIS_LOUIS_1 = 0x1
	// 2
	SCB_CLIDR_LOUIS_LOUIS_2 = 0x2
	// 3
	SCB_CLIDR_LOUIS_LOUIS_3 = 0x3
	// 4
	SCB_CLIDR_LOUIS_LOUIS_4 = 0x4
	// 5
	SCB_CLIDR_LOUIS_LOUIS_5 = 0x5
	// 6
	SCB_CLIDR_LOUIS_LOUIS_6 = 0x6
	// 7
	SCB_CLIDR_LOUIS_LOUIS_7 = 0x7
	// Position of LOC field.
	SCB_CLIDR_LOC_Pos = 0x18
	// Bit mask of LOC field.
	SCB_CLIDR_LOC_Msk = 0x7000000
	// 0
	SCB_CLIDR_LOC_LOC_0 = 0x0
	// 1
	SCB_CLIDR_LOC_LOC_1 = 0x1
	// 2
	SCB_CLIDR_LOC_LOC_2 = 0x2
	// 3
	SCB_CLIDR_LOC_LOC_3 = 0x3
	// 4
	SCB_CLIDR_LOC_LOC_4 = 0x4
	// 5
	SCB_CLIDR_LOC_LOC_5 = 0x5
	// 6
	SCB_CLIDR_LOC_LOC_6 = 0x6
	// 7
	SCB_CLIDR_LOC_LOC_7 = 0x7
	// Position of LOU field.
	SCB_CLIDR_LOU_Pos = 0x1b
	// Bit mask of LOU field.
	SCB_CLIDR_LOU_Msk = 0x38000000
	// 0
	SCB_CLIDR_LOU_LOU_0 = 0x0
	// 1
	SCB_CLIDR_LOU_LOU_1 = 0x1
	// 2
	SCB_CLIDR_LOU_LOU_2 = 0x2
	// 3
	SCB_CLIDR_LOU_LOU_3 = 0x3
	// 4
	SCB_CLIDR_LOU_LOU_4 = 0x4
	// 5
	SCB_CLIDR_LOU_LOU_5 = 0x5
	// 6
	SCB_CLIDR_LOU_LOU_6 = 0x6
	// 7
	SCB_CLIDR_LOU_LOU_7 = 0x7

	// CTR: Cache Type register
	// Position of IMINLINE field.
	SCB_CTR_IMINLINE_Pos = 0x0
	// Bit mask of IMINLINE field.
	SCB_CTR_IMINLINE_Msk = 0xf
	// Position of DMINLINE field.
	SCB_CTR_DMINLINE_Pos = 0x10
	// Bit mask of DMINLINE field.
	SCB_CTR_DMINLINE_Msk = 0xf0000
	// Position of ERG field.
	SCB_CTR_ERG_Pos = 0x14
	// Bit mask of ERG field.
	SCB_CTR_ERG_Msk = 0xf00000
	// Position of CWG field.
	SCB_CTR_CWG_Pos = 0x18
	// Bit mask of CWG field.
	SCB_CTR_CWG_Msk = 0xf000000
	// Position of FORMAT field.
	SCB_CTR_FORMAT_Pos = 0x1d
	// Bit mask of FORMAT field.
	SCB_CTR_FORMAT_Msk = 0xe0000000
	// ARMv7 format.
	SCB_CTR_FORMAT_FORMAT_4 = 0x4

	// CCSIDR: Cache Size ID Register
	// Position of LINESIZE field.
	SCB_CCSIDR_LINESIZE_Pos = 0x0
	// Bit mask of LINESIZE field.
	SCB_CCSIDR_LINESIZE_Msk = 0x7
	// The line length of 4 words.
	SCB_CCSIDR_LINESIZE_LINESIZE_0 = 0x0
	// The line length of 8 words.
	SCB_CCSIDR_LINESIZE_LINESIZE_1 = 0x1
	// The line length of 16 words.
	SCB_CCSIDR_LINESIZE_LINESIZE_2 = 0x2
	// The line length of 32 words.
	SCB_CCSIDR_LINESIZE_LINESIZE_3 = 0x3
	// The line length of 64 words.
	SCB_CCSIDR_LINESIZE_LINESIZE_4 = 0x4
	// The line length of 128 words.
	SCB_CCSIDR_LINESIZE_LINESIZE_5 = 0x5
	// The line length of 256 words.
	SCB_CCSIDR_LINESIZE_LINESIZE_6 = 0x6
	// The line length of 512 words.
	SCB_CCSIDR_LINESIZE_LINESIZE_7 = 0x7
	// Position of ASSOCIATIVITY field.
	SCB_CCSIDR_ASSOCIATIVITY_Pos = 0x3
	// Bit mask of ASSOCIATIVITY field.
	SCB_CCSIDR_ASSOCIATIVITY_Msk = 0x1ff8
	// Position of NUMSETS field.
	SCB_CCSIDR_NUMSETS_Pos = 0xd
	// Bit mask of NUMSETS field.
	SCB_CCSIDR_NUMSETS_Msk = 0xfffe000
	// Position of WA field.
	SCB_CCSIDR_WA_Pos = 0x1c
	// Bit mask of WA field.
	SCB_CCSIDR_WA_Msk = 0x10000000
	// Bit WA.
	SCB_CCSIDR_WA = 0x10000000
	// Feature not supported
	SCB_CCSIDR_WA_WA_0 = 0x0
	// Feature supported
	SCB_CCSIDR_WA_WA_1 = 0x1
	// Position of RA field.
	SCB_CCSIDR_RA_Pos = 0x1d
	// Bit mask of RA field.
	SCB_CCSIDR_RA_Msk = 0x20000000
	// Bit RA.
	SCB_CCSIDR_RA = 0x20000000
	// Feature not supported
	SCB_CCSIDR_RA_RA_0 = 0x0
	// Feature supported
	SCB_CCSIDR_RA_RA_1 = 0x1
	// Position of WB field.
	SCB_CCSIDR_WB_Pos = 0x1e
	// Bit mask of WB field.
	SCB_CCSIDR_WB_Msk = 0x40000000
	// Bit WB.
	SCB_CCSIDR_WB = 0x40000000
	// Feature not supported
	SCB_CCSIDR_WB_WB_0 = 0x0
	// Feature supported
	SCB_CCSIDR_WB_WB_1 = 0x1
	// Position of WT field.
	SCB_CCSIDR_WT_Pos = 0x1f
	// Bit mask of WT field.
	SCB_CCSIDR_WT_Msk = 0x80000000
	// Bit WT.
	SCB_CCSIDR_WT = 0x80000000
	// Feature not supported
	SCB_CCSIDR_WT_WT_0 = 0x0
	// Feature supported
	SCB_CCSIDR_WT_WT_1 = 0x1

	// CSSELR: Cache Size Selection Register
	// Position of IND field.
	SCB_CSSELR_IND_Pos = 0x0
	// Bit mask of IND field.
	SCB_CSSELR_IND_Msk = 0x1
	// Bit IND.
	SCB_CSSELR_IND = 0x1
	// Data or unified cache.
	SCB_CSSELR_IND_IND_0 = 0x0
	// Instruction cache.
	SCB_CSSELR_IND_IND_1 = 0x1
	// Position of LEVEL field.
	SCB_CSSELR_LEVEL_Pos = 0x1
	// Bit mask of LEVEL field.
	SCB_CSSELR_LEVEL_Msk = 0xe
	// Level 1 cache.
	SCB_CSSELR_LEVEL_LEVEL_0 = 0x0
	// Level 2 cache.
	SCB_CSSELR_LEVEL_LEVEL_1 = 0x1
	// Level 3 cache.
	SCB_CSSELR_LEVEL_LEVEL_2 = 0x2
	// Level 4 cache.
	SCB_CSSELR_LEVEL_LEVEL_3 = 0x3
	// Level 5 cache.
	SCB_CSSELR_LEVEL_LEVEL_4 = 0x4
	// Level 6 cache.
	SCB_CSSELR_LEVEL_LEVEL_5 = 0x5
	// Level 7 cache.
	SCB_CSSELR_LEVEL_LEVEL_6 = 0x6

	// CPACR: Coprocessor Access Control Register
	// Position of CP0 field.
	SCB_CPACR_CP0_Pos = 0x0
	// Bit mask of CP0 field.
	SCB_CPACR_CP0_Msk = 0x3
	// Access denied. Any attempted access generates a NOCP UsageFault.
	SCB_CPACR_CP0_CP0_0 = 0x0
	// Privileged access only. An unprivileged access generates a NOCP UsageFault.
	SCB_CPACR_CP0_CP0_1 = 0x1
	// Full access.
	SCB_CPACR_CP0_CP0_3 = 0x3
	// Position of CP1 field.
	SCB_CPACR_CP1_Pos = 0x2
	// Bit mask of CP1 field.
	SCB_CPACR_CP1_Msk = 0xc
	// Access denied. Any attempted access generates a NOCP UsageFault.
	SCB_CPACR_CP1_CP1_0 = 0x0
	// Privileged access only. An unprivileged access generates a NOCP UsageFault.
	SCB_CPACR_CP1_CP1_1 = 0x1
	// Full access.
	SCB_CPACR_CP1_CP1_3 = 0x3
	// Position of CP2 field.
	SCB_CPACR_CP2_Pos = 0x4
	// Bit mask of CP2 field.
	SCB_CPACR_CP2_Msk = 0x30
	// Access denied. Any attempted access generates a NOCP UsageFault.
	SCB_CPACR_CP2_CP2_0 = 0x0
	// Privileged access only. An unprivileged access generates a NOCP UsageFault.
	SCB_CPACR_CP2_CP2_1 = 0x1
	// Full access.
	SCB_CPACR_CP2_CP2_3 = 0x3
	// Position of CP3 field.
	SCB_CPACR_CP3_Pos = 0x6
	// Bit mask of CP3 field.
	SCB_CPACR_CP3_Msk = 0xc0
	// Access denied. Any attempted access generates a NOCP UsageFault.
	SCB_CPACR_CP3_CP3_0 = 0x0
	// Privileged access only. An unprivileged access generates a NOCP UsageFault.
	SCB_CPACR_CP3_CP3_1 = 0x1
	// Full access.
	SCB_CPACR_CP3_CP3_3 = 0x3
	// Position of CP4 field.
	SCB_CPACR_CP4_Pos = 0x8
	// Bit mask of CP4 field.
	SCB_CPACR_CP4_Msk = 0x300
	// Access denied. Any attempted access generates a NOCP UsageFault.
	SCB_CPACR_CP4_CP4_0 = 0x0
	// Privileged access only. An unprivileged access generates a NOCP UsageFault.
	SCB_CPACR_CP4_CP4_1 = 0x1
	// Full access.
	SCB_CPACR_CP4_CP4_3 = 0x3
	// Position of CP5 field.
	SCB_CPACR_CP5_Pos = 0xa
	// Bit mask of CP5 field.
	SCB_CPACR_CP5_Msk = 0xc00
	// Access denied. Any attempted access generates a NOCP UsageFault.
	SCB_CPACR_CP5_CP5_0 = 0x0
	// Privileged access only. An unprivileged access generates a NOCP UsageFault.
	SCB_CPACR_CP5_CP5_1 = 0x1
	// Full access.
	SCB_CPACR_CP5_CP5_3 = 0x3
	// Position of CP6 field.
	SCB_CPACR_CP6_Pos = 0xc
	// Bit mask of CP6 field.
	SCB_CPACR_CP6_Msk = 0x3000
	// Access denied. Any attempted access generates a NOCP UsageFault.
	SCB_CPACR_CP6_CP6_0 = 0x0
	// Privileged access only. An unprivileged access generates a NOCP UsageFault.
	SCB_CPACR_CP6_CP6_1 = 0x1
	// Full access.
	SCB_CPACR_CP6_CP6_3 = 0x3
	// Position of CP7 field.
	SCB_CPACR_CP7_Pos = 0xe
	// Bit mask of CP7 field.
	SCB_CPACR_CP7_Msk = 0xc000
	// Access denied. Any attempted access generates a NOCP UsageFault.
	SCB_CPACR_CP7_CP7_0 = 0x0
	// Privileged access only. An unprivileged access generates a NOCP UsageFault.
	SCB_CPACR_CP7_CP7_1 = 0x1
	// Full access.
	SCB_CPACR_CP7_CP7_3 = 0x3
	// Position of CP10 field.
	SCB_CPACR_CP10_Pos = 0x14
	// Bit mask of CP10 field.
	SCB_CPACR_CP10_Msk = 0x300000
	// Access denied. Any attempted access generates a NOCP UsageFault.
	SCB_CPACR_CP10_CP10_0 = 0x0
	// Privileged access only. An unprivileged access generates a NOCP UsageFault.
	SCB_CPACR_CP10_CP10_1 = 0x1
	// Full access.
	SCB_CPACR_CP10_CP10_3 = 0x3
	// Position of CP11 field.
	SCB_CPACR_CP11_Pos = 0x16
	// Bit mask of CP11 field.
	SCB_CPACR_CP11_Msk = 0xc00000
	// Access denied. Any attempted access generates a NOCP UsageFault.
	SCB_CPACR_CP11_CP11_0 = 0x0
	// Privileged access only. An unprivileged access generates a NOCP UsageFault.
	SCB_CPACR_CP11_CP11_1 = 0x1
	// Full access.
	SCB_CPACR_CP11_CP11_3 = 0x3

	// STIR: Instruction cache invalidate all to Point of Unification (PoU)
	// Position of INTID field.
	SCB_STIR_INTID_Pos = 0x0
	// Bit mask of INTID field.
	SCB_STIR_INTID_Msk = 0x1ff

	// ICIALLU: Instruction cache invalidate all to Point of Unification (PoU)
	// Position of ICIALLU field.
	SCB_ICIALLU_ICIALLU_Pos = 0x0
	// Bit mask of ICIALLU field.
	SCB_ICIALLU_ICIALLU_Msk = 0xffffffff

	// ICIMVAU: Instruction cache invalidate by address to PoU
	// Position of ICIMVAU field.
	SCB_ICIMVAU_ICIMVAU_Pos = 0x0
	// Bit mask of ICIMVAU field.
	SCB_ICIMVAU_ICIMVAU_Msk = 0xffffffff

	// DCIMVAC: Data cache invalidate by address to Point of Coherency (PoC)
	// Position of DCIMVAC field.
	SCB_DCIMVAC_DCIMVAC_Pos = 0x0
	// Bit mask of DCIMVAC field.
	SCB_DCIMVAC_DCIMVAC_Msk = 0xffffffff

	// DCISW: Data cache invalidate by set/way
	// Position of DCISW field.
	SCB_DCISW_DCISW_Pos = 0x0
	// Bit mask of DCISW field.
	SCB_DCISW_DCISW_Msk = 0xffffffff

	// DCCMVAU: Data cache by address to PoU
	// Position of DCCMVAU field.
	SCB_DCCMVAU_DCCMVAU_Pos = 0x0
	// Bit mask of DCCMVAU field.
	SCB_DCCMVAU_DCCMVAU_Msk = 0xffffffff

	// DCCMVAC: Data cache clean by address to PoC
	// Position of DCCMVAC field.
	SCB_DCCMVAC_DCCMVAC_Pos = 0x0
	// Bit mask of DCCMVAC field.
	SCB_DCCMVAC_DCCMVAC_Msk = 0xffffffff

	// DCCSW: Data cache clean by set/way
	// Position of DCCSW field.
	SCB_DCCSW_DCCSW_Pos = 0x0
	// Bit mask of DCCSW field.
	SCB_DCCSW_DCCSW_Msk = 0xffffffff

	// DCCIMVAC: Data cache clean and invalidate by address to PoC
	// Position of DCCIMVAC field.
	SCB_DCCIMVAC_DCCIMVAC_Pos = 0x0
	// Bit mask of DCCIMVAC field.
	SCB_DCCIMVAC_DCCIMVAC_Msk = 0xffffffff

	// DCCISW: Data cache clean and invalidate by set/way
	// Position of DCCISW field.
	SCB_DCCISW_DCCISW_Pos = 0x0
	// Bit mask of DCCISW field.
	SCB_DCCISW_DCCISW_Msk = 0xffffffff

	// CM7_ITCMCR: Instruction Tightly-Coupled Memory Control Register
	// Position of EN field.
	SCB_CM7_ITCMCR_EN_Pos = 0x0
	// Bit mask of EN field.
	SCB_CM7_ITCMCR_EN_Msk = 0x1
	// Bit EN.
	SCB_CM7_ITCMCR_EN = 0x1
	// TCM disabled.
	SCB_CM7_ITCMCR_EN_EN_0 = 0x0
	// TCM enabled.
	SCB_CM7_ITCMCR_EN_EN_1 = 0x1
	// Position of RMW field.
	SCB_CM7_ITCMCR_RMW_Pos = 0x1
	// Bit mask of RMW field.
	SCB_CM7_ITCMCR_RMW_Msk = 0x2
	// Bit RMW.
	SCB_CM7_ITCMCR_RMW = 0x2
	// RMW disabled.
	SCB_CM7_ITCMCR_RMW_RMW_0 = 0x0
	// RMW enabled.
	SCB_CM7_ITCMCR_RMW_RMW_1 = 0x1
	// Position of RETEN field.
	SCB_CM7_ITCMCR_RETEN_Pos = 0x2
	// Bit mask of RETEN field.
	SCB_CM7_ITCMCR_RETEN_Msk = 0x4
	// Bit RETEN.
	SCB_CM7_ITCMCR_RETEN = 0x4
	// Retry phase disabled.
	SCB_CM7_ITCMCR_RETEN_RETEN_0 = 0x0
	// Retry phase enabled.
	SCB_CM7_ITCMCR_RETEN_RETEN_1 = 0x1
	// Position of SZ field.
	SCB_CM7_ITCMCR_SZ_Pos = 0x3
	// Bit mask of SZ field.
	SCB_CM7_ITCMCR_SZ_Msk = 0x78
	// No TCM implemented.
	SCB_CM7_ITCMCR_SZ_SZ_0 = 0x0
	// 4KB.
	SCB_CM7_ITCMCR_SZ_SZ_3 = 0x3
	// 8KB.
	SCB_CM7_ITCMCR_SZ_SZ_4 = 0x4
	// 16KB.
	SCB_CM7_ITCMCR_SZ_SZ_5 = 0x5
	// 32KB.
	SCB_CM7_ITCMCR_SZ_SZ_6 = 0x6
	// 64KB.
	SCB_CM7_ITCMCR_SZ_SZ_7 = 0x7
	// 128KB.
	SCB_CM7_ITCMCR_SZ_SZ_8 = 0x8
	// 256KB.
	SCB_CM7_ITCMCR_SZ_SZ_9 = 0x9
	// 512KB.
	SCB_CM7_ITCMCR_SZ_SZ_10 = 0xa
	// 1MB.
	SCB_CM7_ITCMCR_SZ_SZ_11 = 0xb
	// 2MB.
	SCB_CM7_ITCMCR_SZ_SZ_12 = 0xc
	// 4MB.
	SCB_CM7_ITCMCR_SZ_SZ_13 = 0xd
	// 8MB.
	SCB_CM7_ITCMCR_SZ_SZ_14 = 0xe
	// 16MB.
	SCB_CM7_ITCMCR_SZ_SZ_15 = 0xf

	// CM7_DTCMCR: Data Tightly-Coupled Memory Control Register
	// Position of EN field.
	SCB_CM7_DTCMCR_EN_Pos = 0x0
	// Bit mask of EN field.
	SCB_CM7_DTCMCR_EN_Msk = 0x1
	// Bit EN.
	SCB_CM7_DTCMCR_EN = 0x1
	// TCM disabled.
	SCB_CM7_DTCMCR_EN_EN_0 = 0x0
	// TCM enabled.
	SCB_CM7_DTCMCR_EN_EN_1 = 0x1
	// Position of RMW field.
	SCB_CM7_DTCMCR_RMW_Pos = 0x1
	// Bit mask of RMW field.
	SCB_CM7_DTCMCR_RMW_Msk = 0x2
	// Bit RMW.
	SCB_CM7_DTCMCR_RMW = 0x2
	// RMW disabled.
	SCB_CM7_DTCMCR_RMW_RMW_0 = 0x0
	// RMW enabled.
	SCB_CM7_DTCMCR_RMW_RMW_1 = 0x1
	// Position of RETEN field.
	SCB_CM7_DTCMCR_RETEN_Pos = 0x2
	// Bit mask of RETEN field.
	SCB_CM7_DTCMCR_RETEN_Msk = 0x4
	// Bit RETEN.
	SCB_CM7_DTCMCR_RETEN = 0x4
	// Retry phase disabled.
	SCB_CM7_DTCMCR_RETEN_RETEN_0 = 0x0
	// Retry phase enabled.
	SCB_CM7_DTCMCR_RETEN_RETEN_1 = 0x1
	// Position of SZ field.
	SCB_CM7_DTCMCR_SZ_Pos = 0x3
	// Bit mask of SZ field.
	SCB_CM7_DTCMCR_SZ_Msk = 0x78
	// No TCM implemented.
	SCB_CM7_DTCMCR_SZ_SZ_0 = 0x0
	// 4KB.
	SCB_CM7_DTCMCR_SZ_SZ_3 = 0x3
	// 8KB.
	SCB_CM7_DTCMCR_SZ_SZ_4 = 0x4
	// 16KB.
	SCB_CM7_DTCMCR_SZ_SZ_5 = 0x5
	// 32KB.
	SCB_CM7_DTCMCR_SZ_SZ_6 = 0x6
	// 64KB.
	SCB_CM7_DTCMCR_SZ_SZ_7 = 0x7
	// 128KB.
	SCB_CM7_DTCMCR_SZ_SZ_8 = 0x8
	// 256KB.
	SCB_CM7_DTCMCR_SZ_SZ_9 = 0x9
	// 512KB.
	SCB_CM7_DTCMCR_SZ_SZ_10 = 0xa
	// 1MB.
	SCB_CM7_DTCMCR_SZ_SZ_11 = 0xb
	// 2MB.
	SCB_CM7_DTCMCR_SZ_SZ_12 = 0xc
	// 4MB.
	SCB_CM7_DTCMCR_SZ_SZ_13 = 0xd
	// 8MB.
	SCB_CM7_DTCMCR_SZ_SZ_14 = 0xe
	// 16MB.
	SCB_CM7_DTCMCR_SZ_SZ_15 = 0xf

	// CM7_AHBPCR: AHBP Control Register
	// Position of EN field.
	SCB_CM7_AHBPCR_EN_Pos = 0x0
	// Bit mask of EN field.
	SCB_CM7_AHBPCR_EN_Msk = 0x1
	// Bit EN.
	SCB_CM7_AHBPCR_EN = 0x1
	// AHBP disabled. When disabled all accesses are made to the AXIM interface.
	SCB_CM7_AHBPCR_EN_EN_0 = 0x0
	// AHBP enabled.
	SCB_CM7_AHBPCR_EN_EN_1 = 0x1
	// Position of SZ field.
	SCB_CM7_AHBPCR_SZ_Pos = 0x1
	// Bit mask of SZ field.
	SCB_CM7_AHBPCR_SZ_Msk = 0xe
	// 0MB. AHBP disabled.
	SCB_CM7_AHBPCR_SZ_SZ_0 = 0x0
	// 64MB.
	SCB_CM7_AHBPCR_SZ_SZ_1 = 0x1
	// 128MB.
	SCB_CM7_AHBPCR_SZ_SZ_2 = 0x2
	// 256MB.
	SCB_CM7_AHBPCR_SZ_SZ_3 = 0x3
	// 512MB.
	SCB_CM7_AHBPCR_SZ_SZ_4 = 0x4

	// CM7_CACR: L1 Cache Control Register
	// Position of SIWT field.
	SCB_CM7_CACR_SIWT_Pos = 0x0
	// Bit mask of SIWT field.
	SCB_CM7_CACR_SIWT_Msk = 0x1
	// Bit SIWT.
	SCB_CM7_CACR_SIWT = 0x1
	// Normal Cacheable Shared locations are treated as being Non-cacheable. Default mode of operation for Shared memory.
	SCB_CM7_CACR_SIWT_SIWT_0 = 0x0
	// Normal Cacheable shared locations are treated as Write-Through.
	SCB_CM7_CACR_SIWT_SIWT_1 = 0x1
	// Position of ECCDIS field.
	SCB_CM7_CACR_ECCDIS_Pos = 0x1
	// Bit mask of ECCDIS field.
	SCB_CM7_CACR_ECCDIS_Msk = 0x2
	// Bit ECCDIS.
	SCB_CM7_CACR_ECCDIS = 0x2
	// Enables ECC in the instruction and data cache.
	SCB_CM7_CACR_ECCDIS_ECCDIS_0 = 0x0
	// Disables ECC in the instruction and data cache.
	SCB_CM7_CACR_ECCDIS_ECCDIS_1 = 0x1
	// Position of FORCEWT field.
	SCB_CM7_CACR_FORCEWT_Pos = 0x2
	// Bit mask of FORCEWT field.
	SCB_CM7_CACR_FORCEWT_Msk = 0x4
	// Bit FORCEWT.
	SCB_CM7_CACR_FORCEWT = 0x4
	// Disables Force Write-Through.
	SCB_CM7_CACR_FORCEWT_FORCEWT_0 = 0x0
	// Enables Force Write-Through. All Cacheable memory regions are treated as Write-Through.
	SCB_CM7_CACR_FORCEWT_FORCEWT_1 = 0x1

	// CM7_AHBSCR: AHB Slave Control Register
	// Position of CTL field.
	SCB_CM7_AHBSCR_CTL_Pos = 0x0
	// Bit mask of CTL field.
	SCB_CM7_AHBSCR_CTL_Msk = 0x3
	// AHBS access priority demoted. This is the reset value.
	SCB_CM7_AHBSCR_CTL_CTL_0 = 0x0
	// Software access priority demoted.
	SCB_CM7_AHBSCR_CTL_CTL_1 = 0x1
	// AHBS access priority demoted by initializing the fairness counter to the CM7_AHBSCR[INITCOUNT] value when the software execution priority is higher than or equal to the threshold level programed in CM7_AHBSCR[TPRI].
	SCB_CM7_AHBSCR_CTL_CTL_2 = 0x2
	// AHBSPRI signal has control of access priority.
	SCB_CM7_AHBSCR_CTL_CTL_3 = 0x3
	// Position of TPRI field.
	SCB_CM7_AHBSCR_TPRI_Pos = 0x2
	// Bit mask of TPRI field.
	SCB_CM7_AHBSCR_TPRI_Msk = 0x7fc
	// Position of INITCOUNT field.
	SCB_CM7_AHBSCR_INITCOUNT_Pos = 0xb
	// Bit mask of INITCOUNT field.
	SCB_CM7_AHBSCR_INITCOUNT_Msk = 0xf800

	// CM7_ABFSR: Auxiliary Bus Fault Status Register
	// Position of ITCM field.
	SCB_CM7_ABFSR_ITCM_Pos = 0x0
	// Bit mask of ITCM field.
	SCB_CM7_ABFSR_ITCM_Msk = 0x1
	// Bit ITCM.
	SCB_CM7_ABFSR_ITCM = 0x1
	// Position of DTCM field.
	SCB_CM7_ABFSR_DTCM_Pos = 0x1
	// Bit mask of DTCM field.
	SCB_CM7_ABFSR_DTCM_Msk = 0x2
	// Bit DTCM.
	SCB_CM7_ABFSR_DTCM = 0x2
	// Position of AHBP field.
	SCB_CM7_ABFSR_AHBP_Pos = 0x2
	// Bit mask of AHBP field.
	SCB_CM7_ABFSR_AHBP_Msk = 0x4
	// Bit AHBP.
	SCB_CM7_ABFSR_AHBP = 0x4
	// Position of AXIM field.
	SCB_CM7_ABFSR_AXIM_Pos = 0x3
	// Bit mask of AXIM field.
	SCB_CM7_ABFSR_AXIM_Msk = 0x8
	// Bit AXIM.
	SCB_CM7_ABFSR_AXIM = 0x8
	// Position of EPPB field.
	SCB_CM7_ABFSR_EPPB_Pos = 0x4
	// Bit mask of EPPB field.
	SCB_CM7_ABFSR_EPPB_Msk = 0x10
	// Bit EPPB.
	SCB_CM7_ABFSR_EPPB = 0x10
	// Position of AXIMTYPE field.
	SCB_CM7_ABFSR_AXIMTYPE_Pos = 0x8
	// Bit mask of AXIMTYPE field.
	SCB_CM7_ABFSR_AXIMTYPE_Msk = 0x300
	// OKAY.
	SCB_CM7_ABFSR_AXIMTYPE_AXIMTYPE_0 = 0x0
	// EXOKAY.
	SCB_CM7_ABFSR_AXIMTYPE_AXIMTYPE_1 = 0x1
	// SLVERR.
	SCB_CM7_ABFSR_AXIMTYPE_AXIMTYPE_2 = 0x2
	// DECERR.
	SCB_CM7_ABFSR_AXIMTYPE_AXIMTYPE_3 = 0x3
)

// Constants for NVIC: Nested Vectored Interrupt Controller
const (
	// NVICISER0: Interrupt Set Enable Register n
	// Position of SETENA field.
	NVIC_NVICISER0_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_NVICISER0_SETENA_Msk = 0xffffffff

	// NVICISER1: Interrupt Set Enable Register n
	// Position of SETENA field.
	NVIC_NVICISER1_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_NVICISER1_SETENA_Msk = 0xffffffff

	// NVICISER2: Interrupt Set Enable Register n
	// Position of SETENA field.
	NVIC_NVICISER2_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_NVICISER2_SETENA_Msk = 0xffffffff

	// NVICISER3: Interrupt Set Enable Register n
	// Position of SETENA field.
	NVIC_NVICISER3_SETENA_Pos = 0x0
	// Bit mask of SETENA field.
	NVIC_NVICISER3_SETENA_Msk = 0xffffffff

	// NVICICER0: Interrupt Clear Enable Register n
	// Position of CLRENA field.
	NVIC_NVICICER0_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_NVICICER0_CLRENA_Msk = 0xffffffff

	// NVICICER1: Interrupt Clear Enable Register n
	// Position of CLRENA field.
	NVIC_NVICICER1_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_NVICICER1_CLRENA_Msk = 0xffffffff

	// NVICICER2: Interrupt Clear Enable Register n
	// Position of CLRENA field.
	NVIC_NVICICER2_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_NVICICER2_CLRENA_Msk = 0xffffffff

	// NVICICER3: Interrupt Clear Enable Register n
	// Position of CLRENA field.
	NVIC_NVICICER3_CLRENA_Pos = 0x0
	// Bit mask of CLRENA field.
	NVIC_NVICICER3_CLRENA_Msk = 0xffffffff

	// NVICISPR0: Interrupt Set Pending Register n
	// Position of SETPEND field.
	NVIC_NVICISPR0_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_NVICISPR0_SETPEND_Msk = 0xffffffff

	// NVICISPR1: Interrupt Set Pending Register n
	// Position of SETPEND field.
	NVIC_NVICISPR1_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_NVICISPR1_SETPEND_Msk = 0xffffffff

	// NVICISPR2: Interrupt Set Pending Register n
	// Position of SETPEND field.
	NVIC_NVICISPR2_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_NVICISPR2_SETPEND_Msk = 0xffffffff

	// NVICISPR3: Interrupt Set Pending Register n
	// Position of SETPEND field.
	NVIC_NVICISPR3_SETPEND_Pos = 0x0
	// Bit mask of SETPEND field.
	NVIC_NVICISPR3_SETPEND_Msk = 0xffffffff

	// NVICICPR0: Interrupt Clear Pending Register n
	// Position of CLRPEND field.
	NVIC_NVICICPR0_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_NVICICPR0_CLRPEND_Msk = 0xffffffff

	// NVICICPR1: Interrupt Clear Pending Register n
	// Position of CLRPEND field.
	NVIC_NVICICPR1_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_NVICICPR1_CLRPEND_Msk = 0xffffffff

	// NVICICPR2: Interrupt Clear Pending Register n
	// Position of CLRPEND field.
	NVIC_NVICICPR2_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_NVICICPR2_CLRPEND_Msk = 0xffffffff

	// NVICICPR3: Interrupt Clear Pending Register n
	// Position of CLRPEND field.
	NVIC_NVICICPR3_CLRPEND_Pos = 0x0
	// Bit mask of CLRPEND field.
	NVIC_NVICICPR3_CLRPEND_Msk = 0xffffffff

	// NVICIABR0: Interrupt Active bit Register n
	// Position of ACTIVE field.
	NVIC_NVICIABR0_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_NVICIABR0_ACTIVE_Msk = 0xffffffff

	// NVICIABR1: Interrupt Active bit Register n
	// Position of ACTIVE field.
	NVIC_NVICIABR1_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_NVICIABR1_ACTIVE_Msk = 0xffffffff

	// NVICIABR2: Interrupt Active bit Register n
	// Position of ACTIVE field.
	NVIC_NVICIABR2_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_NVICIABR2_ACTIVE_Msk = 0xffffffff

	// NVICIABR3: Interrupt Active bit Register n
	// Position of ACTIVE field.
	NVIC_NVICIABR3_ACTIVE_Pos = 0x0
	// Bit mask of ACTIVE field.
	NVIC_NVICIABR3_ACTIVE_Msk = 0xffffffff

	// NVICIP0: Interrupt Priority Register 0
	// Position of PRI0 field.
	NVIC_NVICIP0_PRI0_Pos = 0x4
	// Bit mask of PRI0 field.
	NVIC_NVICIP0_PRI0_Msk = 0xf0

	// NVICIP1: Interrupt Priority Register 1
	// Position of PRI1 field.
	NVIC_NVICIP1_PRI1_Pos = 0x4
	// Bit mask of PRI1 field.
	NVIC_NVICIP1_PRI1_Msk = 0xf0

	// NVICIP2: Interrupt Priority Register 2
	// Position of PRI2 field.
	NVIC_NVICIP2_PRI2_Pos = 0x4
	// Bit mask of PRI2 field.
	NVIC_NVICIP2_PRI2_Msk = 0xf0

	// NVICIP3: Interrupt Priority Register 3
	// Position of PRI3 field.
	NVIC_NVICIP3_PRI3_Pos = 0x4
	// Bit mask of PRI3 field.
	NVIC_NVICIP3_PRI3_Msk = 0xf0

	// NVICIP4: Interrupt Priority Register 4
	// Position of PRI4 field.
	NVIC_NVICIP4_PRI4_Pos = 0x4
	// Bit mask of PRI4 field.
	NVIC_NVICIP4_PRI4_Msk = 0xf0

	// NVICIP5: Interrupt Priority Register 5
	// Position of PRI5 field.
	NVIC_NVICIP5_PRI5_Pos = 0x4
	// Bit mask of PRI5 field.
	NVIC_NVICIP5_PRI5_Msk = 0xf0

	// NVICIP6: Interrupt Priority Register 6
	// Position of PRI6 field.
	NVIC_NVICIP6_PRI6_Pos = 0x4
	// Bit mask of PRI6 field.
	NVIC_NVICIP6_PRI6_Msk = 0xf0

	// NVICIP7: Interrupt Priority Register 7
	// Position of PRI7 field.
	NVIC_NVICIP7_PRI7_Pos = 0x4
	// Bit mask of PRI7 field.
	NVIC_NVICIP7_PRI7_Msk = 0xf0

	// NVICIP8: Interrupt Priority Register 8
	// Position of PRI8 field.
	NVIC_NVICIP8_PRI8_Pos = 0x4
	// Bit mask of PRI8 field.
	NVIC_NVICIP8_PRI8_Msk = 0xf0

	// NVICIP9: Interrupt Priority Register 9
	// Position of PRI9 field.
	NVIC_NVICIP9_PRI9_Pos = 0x4
	// Bit mask of PRI9 field.
	NVIC_NVICIP9_PRI9_Msk = 0xf0

	// NVICIP10: Interrupt Priority Register 10
	// Position of PRI10 field.
	NVIC_NVICIP10_PRI10_Pos = 0x4
	// Bit mask of PRI10 field.
	NVIC_NVICIP10_PRI10_Msk = 0xf0

	// NVICIP11: Interrupt Priority Register 11
	// Position of PRI11 field.
	NVIC_NVICIP11_PRI11_Pos = 0x4
	// Bit mask of PRI11 field.
	NVIC_NVICIP11_PRI11_Msk = 0xf0

	// NVICIP12: Interrupt Priority Register 12
	// Position of PRI12 field.
	NVIC_NVICIP12_PRI12_Pos = 0x4
	// Bit mask of PRI12 field.
	NVIC_NVICIP12_PRI12_Msk = 0xf0

	// NVICIP13: Interrupt Priority Register 13
	// Position of PRI13 field.
	NVIC_NVICIP13_PRI13_Pos = 0x4
	// Bit mask of PRI13 field.
	NVIC_NVICIP13_PRI13_Msk = 0xf0

	// NVICIP14: Interrupt Priority Register 14
	// Position of PRI14 field.
	NVIC_NVICIP14_PRI14_Pos = 0x4
	// Bit mask of PRI14 field.
	NVIC_NVICIP14_PRI14_Msk = 0xf0

	// NVICIP15: Interrupt Priority Register 15
	// Position of PRI15 field.
	NVIC_NVICIP15_PRI15_Pos = 0x4
	// Bit mask of PRI15 field.
	NVIC_NVICIP15_PRI15_Msk = 0xf0

	// NVICIP16: Interrupt Priority Register 16
	// Position of PRI16 field.
	NVIC_NVICIP16_PRI16_Pos = 0x4
	// Bit mask of PRI16 field.
	NVIC_NVICIP16_PRI16_Msk = 0xf0

	// NVICIP17: Interrupt Priority Register 17
	// Position of PRI17 field.
	NVIC_NVICIP17_PRI17_Pos = 0x4
	// Bit mask of PRI17 field.
	NVIC_NVICIP17_PRI17_Msk = 0xf0

	// NVICIP18: Interrupt Priority Register 18
	// Position of PRI18 field.
	NVIC_NVICIP18_PRI18_Pos = 0x4
	// Bit mask of PRI18 field.
	NVIC_NVICIP18_PRI18_Msk = 0xf0

	// NVICIP19: Interrupt Priority Register 19
	// Position of PRI19 field.
	NVIC_NVICIP19_PRI19_Pos = 0x4
	// Bit mask of PRI19 field.
	NVIC_NVICIP19_PRI19_Msk = 0xf0

	// NVICIP20: Interrupt Priority Register 20
	// Position of PRI20 field.
	NVIC_NVICIP20_PRI20_Pos = 0x4
	// Bit mask of PRI20 field.
	NVIC_NVICIP20_PRI20_Msk = 0xf0

	// NVICIP21: Interrupt Priority Register 21
	// Position of PRI21 field.
	NVIC_NVICIP21_PRI21_Pos = 0x4
	// Bit mask of PRI21 field.
	NVIC_NVICIP21_PRI21_Msk = 0xf0

	// NVICIP22: Interrupt Priority Register 22
	// Position of PRI22 field.
	NVIC_NVICIP22_PRI22_Pos = 0x4
	// Bit mask of PRI22 field.
	NVIC_NVICIP22_PRI22_Msk = 0xf0

	// NVICIP23: Interrupt Priority Register 23
	// Position of PRI23 field.
	NVIC_NVICIP23_PRI23_Pos = 0x4
	// Bit mask of PRI23 field.
	NVIC_NVICIP23_PRI23_Msk = 0xf0

	// NVICIP24: Interrupt Priority Register 24
	// Position of PRI24 field.
	NVIC_NVICIP24_PRI24_Pos = 0x4
	// Bit mask of PRI24 field.
	NVIC_NVICIP24_PRI24_Msk = 0xf0

	// NVICIP25: Interrupt Priority Register 25
	// Position of PRI25 field.
	NVIC_NVICIP25_PRI25_Pos = 0x4
	// Bit mask of PRI25 field.
	NVIC_NVICIP25_PRI25_Msk = 0xf0

	// NVICIP26: Interrupt Priority Register 26
	// Position of PRI26 field.
	NVIC_NVICIP26_PRI26_Pos = 0x4
	// Bit mask of PRI26 field.
	NVIC_NVICIP26_PRI26_Msk = 0xf0

	// NVICIP27: Interrupt Priority Register 27
	// Position of PRI27 field.
	NVIC_NVICIP27_PRI27_Pos = 0x4
	// Bit mask of PRI27 field.
	NVIC_NVICIP27_PRI27_Msk = 0xf0

	// NVICIP28: Interrupt Priority Register 28
	// Position of PRI28 field.
	NVIC_NVICIP28_PRI28_Pos = 0x4
	// Bit mask of PRI28 field.
	NVIC_NVICIP28_PRI28_Msk = 0xf0

	// NVICIP29: Interrupt Priority Register 29
	// Position of PRI29 field.
	NVIC_NVICIP29_PRI29_Pos = 0x4
	// Bit mask of PRI29 field.
	NVIC_NVICIP29_PRI29_Msk = 0xf0

	// NVICIP30: Interrupt Priority Register 30
	// Position of PRI30 field.
	NVIC_NVICIP30_PRI30_Pos = 0x4
	// Bit mask of PRI30 field.
	NVIC_NVICIP30_PRI30_Msk = 0xf0

	// NVICIP31: Interrupt Priority Register 31
	// Position of PRI31 field.
	NVIC_NVICIP31_PRI31_Pos = 0x4
	// Bit mask of PRI31 field.
	NVIC_NVICIP31_PRI31_Msk = 0xf0

	// NVICIP32: Interrupt Priority Register 32
	// Position of PRI32 field.
	NVIC_NVICIP32_PRI32_Pos = 0x4
	// Bit mask of PRI32 field.
	NVIC_NVICIP32_PRI32_Msk = 0xf0

	// NVICIP33: Interrupt Priority Register 33
	// Position of PRI33 field.
	NVIC_NVICIP33_PRI33_Pos = 0x4
	// Bit mask of PRI33 field.
	NVIC_NVICIP33_PRI33_Msk = 0xf0

	// NVICIP34: Interrupt Priority Register 34
	// Position of PRI34 field.
	NVIC_NVICIP34_PRI34_Pos = 0x4
	// Bit mask of PRI34 field.
	NVIC_NVICIP34_PRI34_Msk = 0xf0

	// NVICIP35: Interrupt Priority Register 35
	// Position of PRI35 field.
	NVIC_NVICIP35_PRI35_Pos = 0x4
	// Bit mask of PRI35 field.
	NVIC_NVICIP35_PRI35_Msk = 0xf0

	// NVICIP36: Interrupt Priority Register 36
	// Position of PRI36 field.
	NVIC_NVICIP36_PRI36_Pos = 0x4
	// Bit mask of PRI36 field.
	NVIC_NVICIP36_PRI36_Msk = 0xf0

	// NVICIP37: Interrupt Priority Register 37
	// Position of PRI37 field.
	NVIC_NVICIP37_PRI37_Pos = 0x4
	// Bit mask of PRI37 field.
	NVIC_NVICIP37_PRI37_Msk = 0xf0

	// NVICIP38: Interrupt Priority Register 38
	// Position of PRI38 field.
	NVIC_NVICIP38_PRI38_Pos = 0x4
	// Bit mask of PRI38 field.
	NVIC_NVICIP38_PRI38_Msk = 0xf0

	// NVICIP39: Interrupt Priority Register 39
	// Position of PRI39 field.
	NVIC_NVICIP39_PRI39_Pos = 0x4
	// Bit mask of PRI39 field.
	NVIC_NVICIP39_PRI39_Msk = 0xf0

	// NVICIP40: Interrupt Priority Register 40
	// Position of PRI40 field.
	NVIC_NVICIP40_PRI40_Pos = 0x4
	// Bit mask of PRI40 field.
	NVIC_NVICIP40_PRI40_Msk = 0xf0

	// NVICIP41: Interrupt Priority Register 41
	// Position of PRI41 field.
	NVIC_NVICIP41_PRI41_Pos = 0x4
	// Bit mask of PRI41 field.
	NVIC_NVICIP41_PRI41_Msk = 0xf0

	// NVICIP42: Interrupt Priority Register 42
	// Position of PRI42 field.
	NVIC_NVICIP42_PRI42_Pos = 0x4
	// Bit mask of PRI42 field.
	NVIC_NVICIP42_PRI42_Msk = 0xf0

	// NVICIP43: Interrupt Priority Register 43
	// Position of PRI43 field.
	NVIC_NVICIP43_PRI43_Pos = 0x4
	// Bit mask of PRI43 field.
	NVIC_NVICIP43_PRI43_Msk = 0xf0

	// NVICIP44: Interrupt Priority Register 44
	// Position of PRI44 field.
	NVIC_NVICIP44_PRI44_Pos = 0x4
	// Bit mask of PRI44 field.
	NVIC_NVICIP44_PRI44_Msk = 0xf0

	// NVICIP45: Interrupt Priority Register 45
	// Position of PRI45 field.
	NVIC_NVICIP45_PRI45_Pos = 0x4
	// Bit mask of PRI45 field.
	NVIC_NVICIP45_PRI45_Msk = 0xf0

	// NVICIP46: Interrupt Priority Register 46
	// Position of PRI46 field.
	NVIC_NVICIP46_PRI46_Pos = 0x4
	// Bit mask of PRI46 field.
	NVIC_NVICIP46_PRI46_Msk = 0xf0

	// NVICIP47: Interrupt Priority Register 47
	// Position of PRI47 field.
	NVIC_NVICIP47_PRI47_Pos = 0x4
	// Bit mask of PRI47 field.
	NVIC_NVICIP47_PRI47_Msk = 0xf0

	// NVICIP48: Interrupt Priority Register 48
	// Position of PRI48 field.
	NVIC_NVICIP48_PRI48_Pos = 0x4
	// Bit mask of PRI48 field.
	NVIC_NVICIP48_PRI48_Msk = 0xf0

	// NVICIP49: Interrupt Priority Register 49
	// Position of PRI49 field.
	NVIC_NVICIP49_PRI49_Pos = 0x4
	// Bit mask of PRI49 field.
	NVIC_NVICIP49_PRI49_Msk = 0xf0

	// NVICIP50: Interrupt Priority Register 50
	// Position of PRI50 field.
	NVIC_NVICIP50_PRI50_Pos = 0x4
	// Bit mask of PRI50 field.
	NVIC_NVICIP50_PRI50_Msk = 0xf0

	// NVICIP51: Interrupt Priority Register 51
	// Position of PRI51 field.
	NVIC_NVICIP51_PRI51_Pos = 0x4
	// Bit mask of PRI51 field.
	NVIC_NVICIP51_PRI51_Msk = 0xf0

	// NVICIP52: Interrupt Priority Register 52
	// Position of PRI52 field.
	NVIC_NVICIP52_PRI52_Pos = 0x4
	// Bit mask of PRI52 field.
	NVIC_NVICIP52_PRI52_Msk = 0xf0

	// NVICIP53: Interrupt Priority Register 53
	// Position of PRI53 field.
	NVIC_NVICIP53_PRI53_Pos = 0x4
	// Bit mask of PRI53 field.
	NVIC_NVICIP53_PRI53_Msk = 0xf0

	// NVICIP54: Interrupt Priority Register 54
	// Position of PRI54 field.
	NVIC_NVICIP54_PRI54_Pos = 0x4
	// Bit mask of PRI54 field.
	NVIC_NVICIP54_PRI54_Msk = 0xf0

	// NVICIP55: Interrupt Priority Register 55
	// Position of PRI55 field.
	NVIC_NVICIP55_PRI55_Pos = 0x4
	// Bit mask of PRI55 field.
	NVIC_NVICIP55_PRI55_Msk = 0xf0

	// NVICIP56: Interrupt Priority Register 56
	// Position of PRI56 field.
	NVIC_NVICIP56_PRI56_Pos = 0x4
	// Bit mask of PRI56 field.
	NVIC_NVICIP56_PRI56_Msk = 0xf0

	// NVICIP57: Interrupt Priority Register 57
	// Position of PRI57 field.
	NVIC_NVICIP57_PRI57_Pos = 0x4
	// Bit mask of PRI57 field.
	NVIC_NVICIP57_PRI57_Msk = 0xf0

	// NVICIP58: Interrupt Priority Register 58
	// Position of PRI58 field.
	NVIC_NVICIP58_PRI58_Pos = 0x4
	// Bit mask of PRI58 field.
	NVIC_NVICIP58_PRI58_Msk = 0xf0

	// NVICIP59: Interrupt Priority Register 59
	// Position of PRI59 field.
	NVIC_NVICIP59_PRI59_Pos = 0x4
	// Bit mask of PRI59 field.
	NVIC_NVICIP59_PRI59_Msk = 0xf0

	// NVICIP60: Interrupt Priority Register 60
	// Position of PRI60 field.
	NVIC_NVICIP60_PRI60_Pos = 0x4
	// Bit mask of PRI60 field.
	NVIC_NVICIP60_PRI60_Msk = 0xf0

	// NVICIP61: Interrupt Priority Register 61
	// Position of PRI61 field.
	NVIC_NVICIP61_PRI61_Pos = 0x4
	// Bit mask of PRI61 field.
	NVIC_NVICIP61_PRI61_Msk = 0xf0

	// NVICIP62: Interrupt Priority Register 62
	// Position of PRI62 field.
	NVIC_NVICIP62_PRI62_Pos = 0x4
	// Bit mask of PRI62 field.
	NVIC_NVICIP62_PRI62_Msk = 0xf0

	// NVICIP63: Interrupt Priority Register 63
	// Position of PRI63 field.
	NVIC_NVICIP63_PRI63_Pos = 0x4
	// Bit mask of PRI63 field.
	NVIC_NVICIP63_PRI63_Msk = 0xf0

	// NVICIP64: Interrupt Priority Register 64
	// Position of PRI64 field.
	NVIC_NVICIP64_PRI64_Pos = 0x4
	// Bit mask of PRI64 field.
	NVIC_NVICIP64_PRI64_Msk = 0xf0

	// NVICIP65: Interrupt Priority Register 65
	// Position of PRI65 field.
	NVIC_NVICIP65_PRI65_Pos = 0x4
	// Bit mask of PRI65 field.
	NVIC_NVICIP65_PRI65_Msk = 0xf0

	// NVICIP66: Interrupt Priority Register 66
	// Position of PRI66 field.
	NVIC_NVICIP66_PRI66_Pos = 0x4
	// Bit mask of PRI66 field.
	NVIC_NVICIP66_PRI66_Msk = 0xf0

	// NVICIP67: Interrupt Priority Register 67
	// Position of PRI67 field.
	NVIC_NVICIP67_PRI67_Pos = 0x4
	// Bit mask of PRI67 field.
	NVIC_NVICIP67_PRI67_Msk = 0xf0

	// NVICIP68: Interrupt Priority Register 68
	// Position of PRI68 field.
	NVIC_NVICIP68_PRI68_Pos = 0x4
	// Bit mask of PRI68 field.
	NVIC_NVICIP68_PRI68_Msk = 0xf0

	// NVICIP69: Interrupt Priority Register 69
	// Position of PRI69 field.
	NVIC_NVICIP69_PRI69_Pos = 0x4
	// Bit mask of PRI69 field.
	NVIC_NVICIP69_PRI69_Msk = 0xf0

	// NVICIP70: Interrupt Priority Register 70
	// Position of PRI70 field.
	NVIC_NVICIP70_PRI70_Pos = 0x4
	// Bit mask of PRI70 field.
	NVIC_NVICIP70_PRI70_Msk = 0xf0

	// NVICIP71: Interrupt Priority Register 71
	// Position of PRI71 field.
	NVIC_NVICIP71_PRI71_Pos = 0x4
	// Bit mask of PRI71 field.
	NVIC_NVICIP71_PRI71_Msk = 0xf0

	// NVICIP72: Interrupt Priority Register 72
	// Position of PRI72 field.
	NVIC_NVICIP72_PRI72_Pos = 0x4
	// Bit mask of PRI72 field.
	NVIC_NVICIP72_PRI72_Msk = 0xf0

	// NVICIP73: Interrupt Priority Register 73
	// Position of PRI73 field.
	NVIC_NVICIP73_PRI73_Pos = 0x4
	// Bit mask of PRI73 field.
	NVIC_NVICIP73_PRI73_Msk = 0xf0

	// NVICIP74: Interrupt Priority Register 74
	// Position of PRI74 field.
	NVIC_NVICIP74_PRI74_Pos = 0x4
	// Bit mask of PRI74 field.
	NVIC_NVICIP74_PRI74_Msk = 0xf0

	// NVICIP75: Interrupt Priority Register 75
	// Position of PRI75 field.
	NVIC_NVICIP75_PRI75_Pos = 0x4
	// Bit mask of PRI75 field.
	NVIC_NVICIP75_PRI75_Msk = 0xf0

	// NVICIP76: Interrupt Priority Register 76
	// Position of PRI76 field.
	NVIC_NVICIP76_PRI76_Pos = 0x4
	// Bit mask of PRI76 field.
	NVIC_NVICIP76_PRI76_Msk = 0xf0

	// NVICIP77: Interrupt Priority Register 77
	// Position of PRI77 field.
	NVIC_NVICIP77_PRI77_Pos = 0x4
	// Bit mask of PRI77 field.
	NVIC_NVICIP77_PRI77_Msk = 0xf0

	// NVICIP78: Interrupt Priority Register 78
	// Position of PRI78 field.
	NVIC_NVICIP78_PRI78_Pos = 0x4
	// Bit mask of PRI78 field.
	NVIC_NVICIP78_PRI78_Msk = 0xf0

	// NVICIP79: Interrupt Priority Register 79
	// Position of PRI79 field.
	NVIC_NVICIP79_PRI79_Pos = 0x4
	// Bit mask of PRI79 field.
	NVIC_NVICIP79_PRI79_Msk = 0xf0

	// NVICSTIR: Software Trigger Interrupt Register
	// Position of INTID field.
	NVIC_NVICSTIR_INTID_Pos = 0x0
	// Bit mask of INTID field.
	NVIC_NVICSTIR_INTID_Msk = 0x1ff
)
