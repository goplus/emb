// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from LPC11xx_v6a.svd, see https://github.com/posborne/cmsis-svd/tree/master/data/NXP

//go:build nxp && lpc111x_lpc11cxx

/*
// LPC11xx, LPC11Cxx, LPC11xxL, LPC11xxXL
*/

package nxp

import (
	"github.com/goplus/emb/runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device       = "LPC111x_LPC11Cxx"
	CPU          = "CM0"
	FPUPresent   = false
	NVICPrioBits = 2
)

// Interrupt numbers.
const (
	// Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx System configuration (SYSCON) Modification date=2/22/2012 Major revision=8 Minor revision=not available
	IRQ_PIO0_0 = 0

	// Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx System configuration (SYSCON) Modification date=2/22/2012 Major revision=8 Minor revision=not available
	IRQ_PIO0_1 = 1

	// Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx System configuration (SYSCON) Modification date=2/22/2012 Major revision=8 Minor revision=not available
	IRQ_PIO0_2 = 2

	// Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx System configuration (SYSCON) Modification date=2/22/2012 Major revision=8 Minor revision=not available
	IRQ_PIO0_3 = 3

	// Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx System configuration (SYSCON) Modification date=2/22/2012 Major revision=8 Minor revision=not available
	IRQ_PIO0_4 = 4

	// Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx System configuration (SYSCON) Modification date=2/22/2012 Major revision=8 Minor revision=not available
	IRQ_PIO0_5 = 5

	// Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx System configuration (SYSCON) Modification date=2/22/2012 Major revision=8 Minor revision=not available
	IRQ_PIO0_6 = 6

	// Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx System configuration (SYSCON) Modification date=2/22/2012 Major revision=8 Minor revision=not available
	IRQ_PIO0_7 = 7

	// Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx System configuration (SYSCON) Modification date=2/22/2012 Major revision=8 Minor revision=not available
	IRQ_PIO0_8 = 8

	// Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx System configuration (SYSCON) Modification date=2/22/2012 Major revision=8 Minor revision=not available
	IRQ_PIO0_9 = 9

	// Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx System configuration (SYSCON) Modification date=2/22/2012 Major revision=8 Minor revision=not available
	IRQ_PIO0_10 = 10

	// Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx System configuration (SYSCON) Modification date=2/22/2012 Major revision=8 Minor revision=not available
	IRQ_PIO0_11 = 11

	// Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx System configuration (SYSCON) Modification date=2/22/2012 Major revision=8 Minor revision=not available
	IRQ_PIO1_0 = 12

	// Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx C_CAN controller Modification date=9/19/2011 Major revision=7 Minor revision=not available
	IRQ_C_CAN = 13

	IRQ_SPI1 = 14

	// I2C
	IRQ_I2C = 15

	// Product name title=UM10398 Chapter title=LPC1100XL series: 16-bit counter/timer CT16B0/1 Modification date=2/22/2012 Major revision=8 Minor revision=not available
	IRQ_CT16B0 = 16

	IRQ_CT16B1 = 17

	// Product name title=UM10398 Chapter title=LPC1100XL series: 32-bit counter/timer CT32B0/1 Modification date=2/22/2012 Major revision=8 Minor revision=not available
	IRQ_CT32B0 = 18

	IRQ_CT32B1 = 19

	// SPI0
	IRQ_SPI0 = 20

	// Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx UART Modification date=9/19/2011 Major revision=7 Minor revision=not available
	IRQ_UART = 21

	// 10-bit ADC
	IRQ_ADC = 24

	// Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx Windowed WatchDog Timer (WDT) Modification date=9/19/2011 Major revision=6 Minor revision=not available
	IRQ_WDT = 25

	// Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx System configuration (SYSCON) Modification date=2/22/2012 Major revision=8 Minor revision=not available
	IRQ_BOD = 26

	// Product name title=UM10462 Chapter title=LPC11U1x Flash programming firmware Modification date=3/17/2011 Major revision=0 Minor revision=3
	IRQ_FMC = 27

	IRQ_GPIO3 = 28

	IRQ_GPIO2 = 29

	IRQ_GPIO1 = 30

	// GPIO0
	IRQ_GPIO0 = 31

	// Highest interrupt number on this device.
	IRQ_max = 31
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//
// NOTE(zzy): runtime/interrupt.callHandlers is not yet implemented in LLGO
// Original linkname: //go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int) {
	// TODO: implement interrupt handler dispatch mechanism
}

//export PIO0_0_IRQHandler
func interruptPIO0_0() {
	callHandlers(IRQ_PIO0_0)
}

//export PIO0_1_IRQHandler
func interruptPIO0_1() {
	callHandlers(IRQ_PIO0_1)
}

//export PIO0_2_IRQHandler
func interruptPIO0_2() {
	callHandlers(IRQ_PIO0_2)
}

//export PIO0_3_IRQHandler
func interruptPIO0_3() {
	callHandlers(IRQ_PIO0_3)
}

//export PIO0_4_IRQHandler
func interruptPIO0_4() {
	callHandlers(IRQ_PIO0_4)
}

//export PIO0_5_IRQHandler
func interruptPIO0_5() {
	callHandlers(IRQ_PIO0_5)
}

//export PIO0_6_IRQHandler
func interruptPIO0_6() {
	callHandlers(IRQ_PIO0_6)
}

//export PIO0_7_IRQHandler
func interruptPIO0_7() {
	callHandlers(IRQ_PIO0_7)
}

//export PIO0_8_IRQHandler
func interruptPIO0_8() {
	callHandlers(IRQ_PIO0_8)
}

//export PIO0_9_IRQHandler
func interruptPIO0_9() {
	callHandlers(IRQ_PIO0_9)
}

//export PIO0_10_IRQHandler
func interruptPIO0_10() {
	callHandlers(IRQ_PIO0_10)
}

//export PIO0_11_IRQHandler
func interruptPIO0_11() {
	callHandlers(IRQ_PIO0_11)
}

//export PIO1_0_IRQHandler
func interruptPIO1_0() {
	callHandlers(IRQ_PIO1_0)
}

//export C_CAN_IRQHandler
func interruptC_CAN() {
	callHandlers(IRQ_C_CAN)
}

//export SPI1_IRQHandler
func interruptSPI1() {
	callHandlers(IRQ_SPI1)
}

//export I2C_IRQHandler
func interruptI2C() {
	callHandlers(IRQ_I2C)
}

//export CT16B0_IRQHandler
func interruptCT16B0() {
	callHandlers(IRQ_CT16B0)
}

//export CT16B1_IRQHandler
func interruptCT16B1() {
	callHandlers(IRQ_CT16B1)
}

//export CT32B0_IRQHandler
func interruptCT32B0() {
	callHandlers(IRQ_CT32B0)
}

//export CT32B1_IRQHandler
func interruptCT32B1() {
	callHandlers(IRQ_CT32B1)
}

//export SPI0_IRQHandler
func interruptSPI0() {
	callHandlers(IRQ_SPI0)
}

//export UART_IRQHandler
func interruptUART() {
	callHandlers(IRQ_UART)
}

//export ADC_IRQHandler
func interruptADC() {
	callHandlers(IRQ_ADC)
}

//export WDT_IRQHandler
func interruptWDT() {
	callHandlers(IRQ_WDT)
}

//export BOD_IRQHandler
func interruptBOD() {
	callHandlers(IRQ_BOD)
}

//export FMC_IRQHandler
func interruptFMC() {
	callHandlers(IRQ_FMC)
}

//export GPIO3_IRQHandler
func interruptGPIO3() {
	callHandlers(IRQ_GPIO3)
}

//export GPIO2_IRQHandler
func interruptGPIO2() {
	callHandlers(IRQ_GPIO2)
}

//export GPIO1_IRQHandler
func interruptGPIO1() {
	callHandlers(IRQ_GPIO1)
}

//export GPIO0_IRQHandler
func interruptGPIO0() {
	callHandlers(IRQ_GPIO0)
}

// Peripherals.
var (
	// I2C
	I2C = (*I2C_Type)(unsafe.Pointer(uintptr(0x40000000)))

	// Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx Windowed WatchDog Timer (WDT) Modification date=9/19/2011 Major revision=6 Minor revision=not available
	WWDT = (*WWDT_Type)(unsafe.Pointer(uintptr(0x40004000)))

	// Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx UART Modification date=9/19/2011 Major revision=7 Minor revision=not available
	UART = (*UART_Type)(unsafe.Pointer(uintptr(0x40008000)))

	// Product name title=UM10398 Chapter title=LPC1100XL series: 16-bit counter/timer CT16B0/1 Modification date=2/22/2012 Major revision=8 Minor revision=not available
	CT16B0 = (*CT16B0_Type)(unsafe.Pointer(uintptr(0x4000c000)))

	// Product name title=UM10398 Chapter title=LPC1100XL series: 16-bit counter/timer CT16B0/1 Modification date=2/22/2012 Major revision=8 Minor revision=not available
	CT16B1 = (*CT16B0_Type)(unsafe.Pointer(uintptr(0x40010000)))

	// Product name title=UM10398 Chapter title=LPC1100XL series: 32-bit counter/timer CT32B0/1 Modification date=2/22/2012 Major revision=8 Minor revision=not available
	CT32B0 = (*CT32B0_Type)(unsafe.Pointer(uintptr(0x40014000)))

	// Product name title=UM10398 Chapter title=LPC1100XL series: 32-bit counter/timer CT32B0/1 Modification date=2/22/2012 Major revision=8 Minor revision=not available
	CT32B1 = (*CT32B0_Type)(unsafe.Pointer(uintptr(0x40018000)))

	// 10-bit ADC
	ADC = (*ADC_Type)(unsafe.Pointer(uintptr(0x4001c000)))

	// power management unit
	PMU = (*PMU_Type)(unsafe.Pointer(uintptr(0x40038000)))

	// Product name title=UM10462 Chapter title=LPC11U1x Flash programming firmware Modification date=3/17/2011 Major revision=0 Minor revision=3
	FLASHCTRL = (*FLASHCTRL_Type)(unsafe.Pointer(uintptr(0x4003c000)))

	// SPI0
	SPI0 = (*SPI_Type)(unsafe.Pointer(uintptr(0x40040000)))

	// Product name title=UM10398 Chapter title=LPC1100XL series: I/O configuration (IOCONFIG) Modification date=2/22/2012 Major revision=8 Minor revision=not available
	IOCON = (*IOCON_Type)(unsafe.Pointer(uintptr(0x40044000)))

	// Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx System configuration (SYSCON) Modification date=2/22/2012 Major revision=8 Minor revision=not available
	SYSCON = (*SYSCON_Type)(unsafe.Pointer(uintptr(0x40048000)))

	// Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx C_CAN controller Modification date=9/19/2011 Major revision=7 Minor revision=not available
	C_CAN = (*C_CAN_Type)(unsafe.Pointer(uintptr(0x40050000)))

	// GPIO0
	GPIO0 = (*GPIO_Type)(unsafe.Pointer(uintptr(0x50000000)))

	// SPI0
	SPI1 = (*SPI_Type)(unsafe.Pointer(uintptr(0x40058000)))

	// GPIO0
	GPIO1 = (*GPIO_Type)(unsafe.Pointer(uintptr(0x50010000)))

	// GPIO0
	GPIO2 = (*GPIO_Type)(unsafe.Pointer(uintptr(0x50020000)))

	// GPIO0
	GPIO3 = (*GPIO_Type)(unsafe.Pointer(uintptr(0x50030000)))
)

// I2C
type I2C_Type struct {
	CONSET      volatile.Register32 // 0x0
	STAT        volatile.Register32 // 0x4
	DAT         volatile.Register32 // 0x8
	ADR0        volatile.Register32 // 0xC
	SCLH        volatile.Register32 // 0x10
	SCLL        volatile.Register32 // 0x14
	CONCLR      volatile.Register32 // 0x18
	MMCTRL      volatile.Register32 // 0x1C
	ADR1        volatile.Register32 // 0x20
	ADR2        volatile.Register32 // 0x24
	ADR3        volatile.Register32 // 0x28
	DATA_BUFFER volatile.Register32 // 0x2C
	MASK0       volatile.Register32 // 0x30
	MASK1       volatile.Register32 // 0x34
	MASK2       volatile.Register32 // 0x38
	MASK3       volatile.Register32 // 0x3C
}

// I2C.CONSET: I2C Control Set Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is set. Writing a zero has no effect on the corresponding bit in the I2C control register.
func (o *I2C_Type) SetCONSET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONSET.Reg, volatile.LoadUint32(&o.CONSET.Reg)&^(0x3)|value)
}
func (o *I2C_Type) GetCONSET_RESERVED() uint32 {
	return volatile.LoadUint32(&o.CONSET.Reg) & 0x3
}
func (o *I2C_Type) SetCONSET_AA(value uint32) {
	volatile.StoreUint32(&o.CONSET.Reg, volatile.LoadUint32(&o.CONSET.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetCONSET_AA() uint32 {
	return (volatile.LoadUint32(&o.CONSET.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetCONSET_SI(value uint32) {
	volatile.StoreUint32(&o.CONSET.Reg, volatile.LoadUint32(&o.CONSET.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetCONSET_SI() uint32 {
	return (volatile.LoadUint32(&o.CONSET.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetCONSET_STO(value uint32) {
	volatile.StoreUint32(&o.CONSET.Reg, volatile.LoadUint32(&o.CONSET.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetCONSET_STO() uint32 {
	return (volatile.LoadUint32(&o.CONSET.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetCONSET_STA(value uint32) {
	volatile.StoreUint32(&o.CONSET.Reg, volatile.LoadUint32(&o.CONSET.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetCONSET_STA() uint32 {
	return (volatile.LoadUint32(&o.CONSET.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetCONSET_I2EN(value uint32) {
	volatile.StoreUint32(&o.CONSET.Reg, volatile.LoadUint32(&o.CONSET.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetCONSET_I2EN() uint32 {
	return (volatile.LoadUint32(&o.CONSET.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetCONSET_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONSET.Reg, volatile.LoadUint32(&o.CONSET.Reg)&^(0xffffff80)|value<<7)
}
func (o *I2C_Type) GetCONSET_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONSET.Reg) & 0xffffff80) >> 7
}

// I2C.STAT: I2C Status Register. During I2C operation, this register provides detailed status codes that allow software to determine the next action needed.
func (o *I2C_Type) SetSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x7)|value)
}
func (o *I2C_Type) GetSTAT_RESERVED() uint32 {
	return volatile.LoadUint32(&o.STAT.Reg) & 0x7
}
func (o *I2C_Type) SetSTAT_Status(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0xf8)|value<<3)
}
func (o *I2C_Type) GetSTAT_Status() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0xf8) >> 3
}
func (o *I2C_Type) SetSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0xffffff00) >> 8
}

// I2C.DAT: I2C Data Register. During master or slave transmit mode, data to be transmitted is written to this register. During master or slave receive mode, data that has been received may be read from this register.
func (o *I2C_Type) SetDAT_Data(value uint32) {
	volatile.StoreUint32(&o.DAT.Reg, volatile.LoadUint32(&o.DAT.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetDAT_Data() uint32 {
	return volatile.LoadUint32(&o.DAT.Reg) & 0xff
}
func (o *I2C_Type) SetDAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DAT.Reg, volatile.LoadUint32(&o.DAT.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetDAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DAT.Reg) & 0xffffff00) >> 8
}

// I2C.ADR0: I2C Slave Address Register 0. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
func (o *I2C_Type) SetADR0_GC(value uint32) {
	volatile.StoreUint32(&o.ADR0.Reg, volatile.LoadUint32(&o.ADR0.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetADR0_GC() uint32 {
	return volatile.LoadUint32(&o.ADR0.Reg) & 0x1
}
func (o *I2C_Type) SetADR0_Address(value uint32) {
	volatile.StoreUint32(&o.ADR0.Reg, volatile.LoadUint32(&o.ADR0.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetADR0_Address() uint32 {
	return (volatile.LoadUint32(&o.ADR0.Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetADR0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ADR0.Reg, volatile.LoadUint32(&o.ADR0.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetADR0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ADR0.Reg) & 0xffffff00) >> 8
}

// I2C.SCLH: SCH Duty Cycle Register High Half Word. Determines the high time of the I2C clock.
func (o *I2C_Type) SetSCLH(value uint32) {
	volatile.StoreUint32(&o.SCLH.Reg, volatile.LoadUint32(&o.SCLH.Reg)&^(0xffff)|value)
}
func (o *I2C_Type) GetSCLH() uint32 {
	return volatile.LoadUint32(&o.SCLH.Reg) & 0xffff
}
func (o *I2C_Type) SetSCLH_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SCLH.Reg, volatile.LoadUint32(&o.SCLH.Reg)&^(0xffff0000)|value<<16)
}
func (o *I2C_Type) GetSCLH_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SCLH.Reg) & 0xffff0000) >> 16
}

// I2C.SCLL: SCL Duty Cycle Register Low Half Word. Determines the low time of the I2C clock. I2nSCLL and I2nSCLH together determine the clock frequency generated by an I2C master and certain times used in slave mode.
func (o *I2C_Type) SetSCLL(value uint32) {
	volatile.StoreUint32(&o.SCLL.Reg, volatile.LoadUint32(&o.SCLL.Reg)&^(0xffff)|value)
}
func (o *I2C_Type) GetSCLL() uint32 {
	return volatile.LoadUint32(&o.SCLL.Reg) & 0xffff
}
func (o *I2C_Type) SetSCLL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SCLL.Reg, volatile.LoadUint32(&o.SCLL.Reg)&^(0xffff0000)|value<<16)
}
func (o *I2C_Type) GetSCLL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SCLL.Reg) & 0xffff0000) >> 16
}

// I2C.CONCLR: I2C Control Clear Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is cleared. Writing a zero has no effect on the corresponding bit in the I2C control register.
func (o *I2C_Type) SetCONCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONCLR.Reg, volatile.LoadUint32(&o.CONCLR.Reg)&^(0x3)|value)
}
func (o *I2C_Type) GetCONCLR_RESERVED() uint32 {
	return volatile.LoadUint32(&o.CONCLR.Reg) & 0x3
}
func (o *I2C_Type) SetCONCLR_AAC(value uint32) {
	volatile.StoreUint32(&o.CONCLR.Reg, volatile.LoadUint32(&o.CONCLR.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetCONCLR_AAC() uint32 {
	return (volatile.LoadUint32(&o.CONCLR.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetCONCLR_SIC(value uint32) {
	volatile.StoreUint32(&o.CONCLR.Reg, volatile.LoadUint32(&o.CONCLR.Reg)&^(0x8)|value<<3)
}
func (o *I2C_Type) GetCONCLR_SIC() uint32 {
	return (volatile.LoadUint32(&o.CONCLR.Reg) & 0x8) >> 3
}
func (o *I2C_Type) SetCONCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONCLR.Reg, volatile.LoadUint32(&o.CONCLR.Reg)&^(0x10)|value<<4)
}
func (o *I2C_Type) GetCONCLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONCLR.Reg) & 0x10) >> 4
}
func (o *I2C_Type) SetCONCLR_STAC(value uint32) {
	volatile.StoreUint32(&o.CONCLR.Reg, volatile.LoadUint32(&o.CONCLR.Reg)&^(0x20)|value<<5)
}
func (o *I2C_Type) GetCONCLR_STAC() uint32 {
	return (volatile.LoadUint32(&o.CONCLR.Reg) & 0x20) >> 5
}
func (o *I2C_Type) SetCONCLR_I2ENC(value uint32) {
	volatile.StoreUint32(&o.CONCLR.Reg, volatile.LoadUint32(&o.CONCLR.Reg)&^(0x40)|value<<6)
}
func (o *I2C_Type) GetCONCLR_I2ENC() uint32 {
	return (volatile.LoadUint32(&o.CONCLR.Reg) & 0x40) >> 6
}
func (o *I2C_Type) SetCONCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONCLR.Reg, volatile.LoadUint32(&o.CONCLR.Reg)&^(0x80)|value<<7)
}
func (o *I2C_Type) GetCONCLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONCLR.Reg) & 0x80) >> 7
}
func (o *I2C_Type) SetCONCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CONCLR.Reg, volatile.LoadUint32(&o.CONCLR.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetCONCLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CONCLR.Reg) & 0xffffff00) >> 8
}

// I2C.MMCTRL: Monitor mode control register.
func (o *I2C_Type) SetMMCTRL_MM_ENA(value uint32) {
	volatile.StoreUint32(&o.MMCTRL.Reg, volatile.LoadUint32(&o.MMCTRL.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetMMCTRL_MM_ENA() uint32 {
	return volatile.LoadUint32(&o.MMCTRL.Reg) & 0x1
}
func (o *I2C_Type) SetMMCTRL_ENA_SCL(value uint32) {
	volatile.StoreUint32(&o.MMCTRL.Reg, volatile.LoadUint32(&o.MMCTRL.Reg)&^(0x2)|value<<1)
}
func (o *I2C_Type) GetMMCTRL_ENA_SCL() uint32 {
	return (volatile.LoadUint32(&o.MMCTRL.Reg) & 0x2) >> 1
}
func (o *I2C_Type) SetMMCTRL_MATCH_ALL(value uint32) {
	volatile.StoreUint32(&o.MMCTRL.Reg, volatile.LoadUint32(&o.MMCTRL.Reg)&^(0x4)|value<<2)
}
func (o *I2C_Type) GetMMCTRL_MATCH_ALL() uint32 {
	return (volatile.LoadUint32(&o.MMCTRL.Reg) & 0x4) >> 2
}
func (o *I2C_Type) SetMMCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MMCTRL.Reg, volatile.LoadUint32(&o.MMCTRL.Reg)&^(0xfffffff8)|value<<3)
}
func (o *I2C_Type) GetMMCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MMCTRL.Reg) & 0xfffffff8) >> 3
}

// I2C.ADR1: I2C Slave Address Register 1. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
func (o *I2C_Type) SetADR1_GC(value uint32) {
	volatile.StoreUint32(&o.ADR1.Reg, volatile.LoadUint32(&o.ADR1.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetADR1_GC() uint32 {
	return volatile.LoadUint32(&o.ADR1.Reg) & 0x1
}
func (o *I2C_Type) SetADR1_Address(value uint32) {
	volatile.StoreUint32(&o.ADR1.Reg, volatile.LoadUint32(&o.ADR1.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetADR1_Address() uint32 {
	return (volatile.LoadUint32(&o.ADR1.Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetADR1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ADR1.Reg, volatile.LoadUint32(&o.ADR1.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetADR1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ADR1.Reg) & 0xffffff00) >> 8
}

// I2C.ADR2: I2C Slave Address Register 1. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
func (o *I2C_Type) SetADR2_GC(value uint32) {
	volatile.StoreUint32(&o.ADR2.Reg, volatile.LoadUint32(&o.ADR2.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetADR2_GC() uint32 {
	return volatile.LoadUint32(&o.ADR2.Reg) & 0x1
}
func (o *I2C_Type) SetADR2_Address(value uint32) {
	volatile.StoreUint32(&o.ADR2.Reg, volatile.LoadUint32(&o.ADR2.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetADR2_Address() uint32 {
	return (volatile.LoadUint32(&o.ADR2.Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetADR2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ADR2.Reg, volatile.LoadUint32(&o.ADR2.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetADR2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ADR2.Reg) & 0xffffff00) >> 8
}

// I2C.ADR3: I2C Slave Address Register 1. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
func (o *I2C_Type) SetADR3_GC(value uint32) {
	volatile.StoreUint32(&o.ADR3.Reg, volatile.LoadUint32(&o.ADR3.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetADR3_GC() uint32 {
	return volatile.LoadUint32(&o.ADR3.Reg) & 0x1
}
func (o *I2C_Type) SetADR3_Address(value uint32) {
	volatile.StoreUint32(&o.ADR3.Reg, volatile.LoadUint32(&o.ADR3.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetADR3_Address() uint32 {
	return (volatile.LoadUint32(&o.ADR3.Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetADR3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ADR3.Reg, volatile.LoadUint32(&o.ADR3.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetADR3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ADR3.Reg) & 0xffffff00) >> 8
}

// I2C.DATA_BUFFER: Data buffer register. The contents of the 8 MSBs of the I2DAT shift register will be transferred to the DATA_BUFFER automatically after every nine bits (8 bits of data plus ACK or NACK) has been received on the bus.
func (o *I2C_Type) SetDATA_BUFFER_Data(value uint32) {
	volatile.StoreUint32(&o.DATA_BUFFER.Reg, volatile.LoadUint32(&o.DATA_BUFFER.Reg)&^(0xff)|value)
}
func (o *I2C_Type) GetDATA_BUFFER_Data() uint32 {
	return volatile.LoadUint32(&o.DATA_BUFFER.Reg) & 0xff
}
func (o *I2C_Type) SetDATA_BUFFER_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DATA_BUFFER.Reg, volatile.LoadUint32(&o.DATA_BUFFER.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetDATA_BUFFER_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DATA_BUFFER.Reg) & 0xffffff00) >> 8
}

// I2C.MASK0: I2C Slave address mask register 0. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000).
func (o *I2C_Type) SetMASK0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetMASK0_RESERVED() uint32 {
	return volatile.LoadUint32(&o.MASK0.Reg) & 0x1
}
func (o *I2C_Type) SetMASK0_MASK(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetMASK0_MASK() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetMASK0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MASK0.Reg, volatile.LoadUint32(&o.MASK0.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetMASK0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MASK0.Reg) & 0xffffff00) >> 8
}

// I2C.MASK1: I2C Slave address mask register 0. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000).
func (o *I2C_Type) SetMASK1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetMASK1_RESERVED() uint32 {
	return volatile.LoadUint32(&o.MASK1.Reg) & 0x1
}
func (o *I2C_Type) SetMASK1_MASK(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetMASK1_MASK() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetMASK1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MASK1.Reg, volatile.LoadUint32(&o.MASK1.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetMASK1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MASK1.Reg) & 0xffffff00) >> 8
}

// I2C.MASK2: I2C Slave address mask register 0. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000).
func (o *I2C_Type) SetMASK2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetMASK2_RESERVED() uint32 {
	return volatile.LoadUint32(&o.MASK2.Reg) & 0x1
}
func (o *I2C_Type) SetMASK2_MASK(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetMASK2_MASK() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetMASK2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MASK2.Reg, volatile.LoadUint32(&o.MASK2.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetMASK2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MASK2.Reg) & 0xffffff00) >> 8
}

// I2C.MASK3: I2C Slave address mask register 0. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000).
func (o *I2C_Type) SetMASK3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0x1)|value)
}
func (o *I2C_Type) GetMASK3_RESERVED() uint32 {
	return volatile.LoadUint32(&o.MASK3.Reg) & 0x1
}
func (o *I2C_Type) SetMASK3_MASK(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0xfe)|value<<1)
}
func (o *I2C_Type) GetMASK3_MASK() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0xfe) >> 1
}
func (o *I2C_Type) SetMASK3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MASK3.Reg, volatile.LoadUint32(&o.MASK3.Reg)&^(0xffffff00)|value<<8)
}
func (o *I2C_Type) GetMASK3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MASK3.Reg) & 0xffffff00) >> 8
}

// Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx Windowed WatchDog Timer (WDT) Modification date=9/19/2011 Major revision=6 Minor revision=not available
type WWDT_Type struct {
	WDMOD     volatile.Register32 // 0x0
	WDTC      volatile.Register32 // 0x4
	WDFEED    volatile.Register32 // 0x8
	WDTV      volatile.Register32 // 0xC
	_         [4]byte
	WDWARNINT volatile.Register32 // 0x14
	WDWINDOW  volatile.Register32 // 0x18
}

// WWDT.WDMOD: Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer.
func (o *WWDT_Type) SetWDMOD_WDEN(value uint32) {
	volatile.StoreUint32(&o.WDMOD.Reg, volatile.LoadUint32(&o.WDMOD.Reg)&^(0x1)|value)
}
func (o *WWDT_Type) GetWDMOD_WDEN() uint32 {
	return volatile.LoadUint32(&o.WDMOD.Reg) & 0x1
}
func (o *WWDT_Type) SetWDMOD_WDRESET(value uint32) {
	volatile.StoreUint32(&o.WDMOD.Reg, volatile.LoadUint32(&o.WDMOD.Reg)&^(0x2)|value<<1)
}
func (o *WWDT_Type) GetWDMOD_WDRESET() uint32 {
	return (volatile.LoadUint32(&o.WDMOD.Reg) & 0x2) >> 1
}
func (o *WWDT_Type) SetWDMOD_WDTOF(value uint32) {
	volatile.StoreUint32(&o.WDMOD.Reg, volatile.LoadUint32(&o.WDMOD.Reg)&^(0x4)|value<<2)
}
func (o *WWDT_Type) GetWDMOD_WDTOF() uint32 {
	return (volatile.LoadUint32(&o.WDMOD.Reg) & 0x4) >> 2
}
func (o *WWDT_Type) SetWDMOD_WDINT(value uint32) {
	volatile.StoreUint32(&o.WDMOD.Reg, volatile.LoadUint32(&o.WDMOD.Reg)&^(0x8)|value<<3)
}
func (o *WWDT_Type) GetWDMOD_WDINT() uint32 {
	return (volatile.LoadUint32(&o.WDMOD.Reg) & 0x8) >> 3
}
func (o *WWDT_Type) SetWDMOD_WDPROTECT(value uint32) {
	volatile.StoreUint32(&o.WDMOD.Reg, volatile.LoadUint32(&o.WDMOD.Reg)&^(0x10)|value<<4)
}
func (o *WWDT_Type) GetWDMOD_WDPROTECT() uint32 {
	return (volatile.LoadUint32(&o.WDMOD.Reg) & 0x10) >> 4
}
func (o *WWDT_Type) SetWDMOD_RESERVED(value uint32) {
	volatile.StoreUint32(&o.WDMOD.Reg, volatile.LoadUint32(&o.WDMOD.Reg)&^(0xffffffe0)|value<<5)
}
func (o *WWDT_Type) GetWDMOD_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.WDMOD.Reg) & 0xffffffe0) >> 5
}

// WWDT.WDTC: Watchdog timer constant register. This register determines the time-out value.
func (o *WWDT_Type) SetWDTC_Count(value uint32) {
	volatile.StoreUint32(&o.WDTC.Reg, volatile.LoadUint32(&o.WDTC.Reg)&^(0xffffff)|value)
}
func (o *WWDT_Type) GetWDTC_Count() uint32 {
	return volatile.LoadUint32(&o.WDTC.Reg) & 0xffffff
}
func (o *WWDT_Type) SetWDTC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.WDTC.Reg, volatile.LoadUint32(&o.WDTC.Reg)&^(0xff000000)|value<<24)
}
func (o *WWDT_Type) GetWDTC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.WDTC.Reg) & 0xff000000) >> 24
}

// WWDT.WDFEED: Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in WDTC.
func (o *WWDT_Type) SetWDFEED_Feed(value uint32) {
	volatile.StoreUint32(&o.WDFEED.Reg, volatile.LoadUint32(&o.WDFEED.Reg)&^(0xff)|value)
}
func (o *WWDT_Type) GetWDFEED_Feed() uint32 {
	return volatile.LoadUint32(&o.WDFEED.Reg) & 0xff
}
func (o *WWDT_Type) SetWDFEED_RESERVED(value uint32) {
	volatile.StoreUint32(&o.WDFEED.Reg, volatile.LoadUint32(&o.WDFEED.Reg)&^(0xffffff00)|value<<8)
}
func (o *WWDT_Type) GetWDFEED_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.WDFEED.Reg) & 0xffffff00) >> 8
}

// WWDT.WDTV: Watchdog timer value register. This register reads out the current value of the Watchdog timer.
func (o *WWDT_Type) SetWDTV_Count(value uint32) {
	volatile.StoreUint32(&o.WDTV.Reg, volatile.LoadUint32(&o.WDTV.Reg)&^(0xffffff)|value)
}
func (o *WWDT_Type) GetWDTV_Count() uint32 {
	return volatile.LoadUint32(&o.WDTV.Reg) & 0xffffff
}
func (o *WWDT_Type) SetWDTV_RESERVED(value uint32) {
	volatile.StoreUint32(&o.WDTV.Reg, volatile.LoadUint32(&o.WDTV.Reg)&^(0xff000000)|value<<24)
}
func (o *WWDT_Type) GetWDTV_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.WDTV.Reg) & 0xff000000) >> 24
}

// WWDT.WDWARNINT: Watchdog Warning Interrupt compare value.
func (o *WWDT_Type) SetWDWARNINT_WARNINT(value uint32) {
	volatile.StoreUint32(&o.WDWARNINT.Reg, volatile.LoadUint32(&o.WDWARNINT.Reg)&^(0x3ff)|value)
}
func (o *WWDT_Type) GetWDWARNINT_WARNINT() uint32 {
	return volatile.LoadUint32(&o.WDWARNINT.Reg) & 0x3ff
}
func (o *WWDT_Type) SetWDWARNINT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.WDWARNINT.Reg, volatile.LoadUint32(&o.WDWARNINT.Reg)&^(0xfffffc00)|value<<10)
}
func (o *WWDT_Type) GetWDWARNINT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.WDWARNINT.Reg) & 0xfffffc00) >> 10
}

// WWDT.WDWINDOW: Watchdog Window compare value.
func (o *WWDT_Type) SetWDWINDOW_WINDOW(value uint32) {
	volatile.StoreUint32(&o.WDWINDOW.Reg, volatile.LoadUint32(&o.WDWINDOW.Reg)&^(0xffffff)|value)
}
func (o *WWDT_Type) GetWDWINDOW_WINDOW() uint32 {
	return volatile.LoadUint32(&o.WDWINDOW.Reg) & 0xffffff
}
func (o *WWDT_Type) SetWDWINDOW_RESERVED(value uint32) {
	volatile.StoreUint32(&o.WDWINDOW.Reg, volatile.LoadUint32(&o.WDWINDOW.Reg)&^(0xff000000)|value<<24)
}
func (o *WWDT_Type) GetWDWINDOW_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.WDWINDOW.Reg) & 0xff000000) >> 24
}

// Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx UART Modification date=9/19/2011 Major revision=7 Minor revision=not available
type UART_Type struct {
	RBR           volatile.Register32 // 0x0
	DLM           volatile.Register32 // 0x4
	IIR           volatile.Register32 // 0x8
	LCR           volatile.Register32 // 0xC
	MCR           volatile.Register32 // 0x10
	LSR           volatile.Register32 // 0x14
	MSR           volatile.Register32 // 0x18
	SCR           volatile.Register32 // 0x1C
	ACR           volatile.Register32 // 0x20
	_             [4]byte
	FDR           volatile.Register32 // 0x28
	_             [4]byte
	TER           volatile.Register32 // 0x30
	_             [24]byte
	RS485CTRL     volatile.Register32 // 0x4C
	RS485ADRMATCH volatile.Register32 // 0x50
	RS485DLY      volatile.Register32 // 0x54
}

// UART.RBR: Receiver Buffer Register. Contains the next received character to be read. (DLAB=0)
func (o *UART_Type) SetRBR(value uint32) {
	volatile.StoreUint32(&o.RBR.Reg, volatile.LoadUint32(&o.RBR.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetRBR() uint32 {
	return volatile.LoadUint32(&o.RBR.Reg) & 0xff
}
func (o *UART_Type) SetRBR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RBR.Reg, volatile.LoadUint32(&o.RBR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART_Type) GetRBR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RBR.Reg) & 0xffffff00) >> 8
}

// UART.DLM: Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider. (DLAB=1)
func (o *UART_Type) SetDLM_DLMSB(value uint32) {
	volatile.StoreUint32(&o.DLM.Reg, volatile.LoadUint32(&o.DLM.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetDLM_DLMSB() uint32 {
	return volatile.LoadUint32(&o.DLM.Reg) & 0xff
}
func (o *UART_Type) SetDLM_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DLM.Reg, volatile.LoadUint32(&o.DLM.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART_Type) GetDLM_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DLM.Reg) & 0xffffff00) >> 8
}

// UART.IIR: Interrupt ID Register. Identifies which interrupt(s) are pending.
func (o *UART_Type) SetIIR_INTSTATUS(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetIIR_INTSTATUS() uint32 {
	return volatile.LoadUint32(&o.IIR.Reg) & 0x1
}
func (o *UART_Type) SetIIR_INTID(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0xe)|value<<1)
}
func (o *UART_Type) GetIIR_INTID() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0xe) >> 1
}
func (o *UART_Type) SetIIR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0x30)|value<<4)
}
func (o *UART_Type) GetIIR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0x30) >> 4
}
func (o *UART_Type) SetIIR_FIFOENABLE(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0xc0)|value<<6)
}
func (o *UART_Type) GetIIR_FIFOENABLE() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0xc0) >> 6
}
func (o *UART_Type) SetIIR_ABEOINT(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0x100)|value<<8)
}
func (o *UART_Type) GetIIR_ABEOINT() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0x100) >> 8
}
func (o *UART_Type) SetIIR_ABTOINT(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0x200)|value<<9)
}
func (o *UART_Type) GetIIR_ABTOINT() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0x200) >> 9
}
func (o *UART_Type) SetIIR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IIR.Reg, volatile.LoadUint32(&o.IIR.Reg)&^(0xfffffc00)|value<<10)
}
func (o *UART_Type) GetIIR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IIR.Reg) & 0xfffffc00) >> 10
}

// UART.LCR: Line Control Register. Contains controls for frame formatting and break generation.
func (o *UART_Type) SetLCR_WLS(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x3)|value)
}
func (o *UART_Type) GetLCR_WLS() uint32 {
	return volatile.LoadUint32(&o.LCR.Reg) & 0x3
}
func (o *UART_Type) SetLCR_SBS(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetLCR_SBS() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetLCR_PE(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetLCR_PE() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetLCR_PS(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x30)|value<<4)
}
func (o *UART_Type) GetLCR_PS() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x30) >> 4
}
func (o *UART_Type) SetLCR_BC(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetLCR_BC() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetLCR_DLAB(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetLCR_DLAB() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetLCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LCR.Reg, volatile.LoadUint32(&o.LCR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART_Type) GetLCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.LCR.Reg) & 0xffffff00) >> 8
}

// UART.MCR: Modem control register
func (o *UART_Type) SetMCR_DTRC(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetMCR_DTRC() uint32 {
	return volatile.LoadUint32(&o.MCR.Reg) & 0x1
}
func (o *UART_Type) SetMCR_RTSC(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetMCR_RTSC() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetMCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0xc)|value<<2)
}
func (o *UART_Type) GetMCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0xc) >> 2
}
func (o *UART_Type) SetMCR_LMS(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetMCR_LMS() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetMCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetMCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetMCR_RTSEN(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetMCR_RTSEN() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetMCR_CTSEN(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetMCR_CTSEN() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetMCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART_Type) GetMCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0xffffff00) >> 8
}

// UART.LSR: Line Status Register. Contains flags for transmit and receive status, including line errors.
func (o *UART_Type) SetLSR_RDR(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetLSR_RDR() uint32 {
	return volatile.LoadUint32(&o.LSR.Reg) & 0x1
}
func (o *UART_Type) SetLSR_OE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetLSR_OE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetLSR_PE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetLSR_PE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetLSR_FE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetLSR_FE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetLSR_BI(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetLSR_BI() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetLSR_THRE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetLSR_THRE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetLSR_TEMT(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetLSR_TEMT() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetLSR_RXFE(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetLSR_RXFE() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetLSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.LSR.Reg, volatile.LoadUint32(&o.LSR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART_Type) GetLSR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.LSR.Reg) & 0xffffff00) >> 8
}

// UART.MSR: Modem status register
func (o *UART_Type) SetMSR_DCTS(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetMSR_DCTS() uint32 {
	return volatile.LoadUint32(&o.MSR.Reg) & 0x1
}
func (o *UART_Type) SetMSR_DDSR(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetMSR_DDSR() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetMSR_TERI(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetMSR_TERI() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetMSR_DDCD(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetMSR_DDCD() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetMSR_CTS(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetMSR_CTS() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetMSR_DSR(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetMSR_DSR() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetMSR_RI(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x40)|value<<6)
}
func (o *UART_Type) GetMSR_RI() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x40) >> 6
}
func (o *UART_Type) SetMSR_DCD(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetMSR_DCD() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetMSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MSR.Reg, volatile.LoadUint32(&o.MSR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART_Type) GetMSR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MSR.Reg) & 0xffffff00) >> 8
}

// UART.SCR: Scratch Pad Register. Eight-bit temporary storage for software.
func (o *UART_Type) SetSCR_PAD(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetSCR_PAD() uint32 {
	return volatile.LoadUint32(&o.SCR.Reg) & 0xff
}
func (o *UART_Type) SetSCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SCR.Reg, volatile.LoadUint32(&o.SCR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART_Type) GetSCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SCR.Reg) & 0xffffff00) >> 8
}

// UART.ACR: Auto-baud Control Register. Contains controls for the auto-baud feature.
func (o *UART_Type) SetACR_START(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetACR_START() uint32 {
	return volatile.LoadUint32(&o.ACR.Reg) & 0x1
}
func (o *UART_Type) SetACR_MODE(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetACR_MODE() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetACR_AUTORESTART(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetACR_AUTORESTART() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetACR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0xf8)|value<<3)
}
func (o *UART_Type) GetACR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0xf8) >> 3
}
func (o *UART_Type) SetACR_ABEOINTCLR(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x100)|value<<8)
}
func (o *UART_Type) GetACR_ABEOINTCLR() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x100) >> 8
}
func (o *UART_Type) SetACR_ABTOINTCLR(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0x200)|value<<9)
}
func (o *UART_Type) GetACR_ABTOINTCLR() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0x200) >> 9
}
func (o *UART_Type) SetACR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ACR.Reg, volatile.LoadUint32(&o.ACR.Reg)&^(0xfffffc00)|value<<10)
}
func (o *UART_Type) GetACR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ACR.Reg) & 0xfffffc00) >> 10
}

// UART.FDR: Fractional Divider Register. Generates a clock input for the baud rate divider.
func (o *UART_Type) SetFDR_DIVADDVAL(value uint32) {
	volatile.StoreUint32(&o.FDR.Reg, volatile.LoadUint32(&o.FDR.Reg)&^(0xf)|value)
}
func (o *UART_Type) GetFDR_DIVADDVAL() uint32 {
	return volatile.LoadUint32(&o.FDR.Reg) & 0xf
}
func (o *UART_Type) SetFDR_MULVAL(value uint32) {
	volatile.StoreUint32(&o.FDR.Reg, volatile.LoadUint32(&o.FDR.Reg)&^(0xf0)|value<<4)
}
func (o *UART_Type) GetFDR_MULVAL() uint32 {
	return (volatile.LoadUint32(&o.FDR.Reg) & 0xf0) >> 4
}
func (o *UART_Type) SetFDR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FDR.Reg, volatile.LoadUint32(&o.FDR.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART_Type) GetFDR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FDR.Reg) & 0xffffff00) >> 8
}

// UART.TER: Transmit Enable Register. Turns off UART transmitter for use with software flow control.
func (o *UART_Type) SetTER_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TER.Reg, volatile.LoadUint32(&o.TER.Reg)&^(0x7f)|value)
}
func (o *UART_Type) GetTER_RESERVED() uint32 {
	return volatile.LoadUint32(&o.TER.Reg) & 0x7f
}
func (o *UART_Type) SetTER_TXEN(value uint32) {
	volatile.StoreUint32(&o.TER.Reg, volatile.LoadUint32(&o.TER.Reg)&^(0x80)|value<<7)
}
func (o *UART_Type) GetTER_TXEN() uint32 {
	return (volatile.LoadUint32(&o.TER.Reg) & 0x80) >> 7
}
func (o *UART_Type) SetTER_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TER.Reg, volatile.LoadUint32(&o.TER.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART_Type) GetTER_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TER.Reg) & 0xffffff00) >> 8
}

// UART.RS485CTRL: RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes.
func (o *UART_Type) SetRS485CTRL_NMMEN(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x1)|value)
}
func (o *UART_Type) GetRS485CTRL_NMMEN() uint32 {
	return volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x1
}
func (o *UART_Type) SetRS485CTRL_RXDIS(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x2)|value<<1)
}
func (o *UART_Type) GetRS485CTRL_RXDIS() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x2) >> 1
}
func (o *UART_Type) SetRS485CTRL_AADEN(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x4)|value<<2)
}
func (o *UART_Type) GetRS485CTRL_AADEN() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x4) >> 2
}
func (o *UART_Type) SetRS485CTRL_SEL(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x8)|value<<3)
}
func (o *UART_Type) GetRS485CTRL_SEL() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x8) >> 3
}
func (o *UART_Type) SetRS485CTRL_DCTRL(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x10)|value<<4)
}
func (o *UART_Type) GetRS485CTRL_DCTRL() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x10) >> 4
}
func (o *UART_Type) SetRS485CTRL_OINV(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0x20)|value<<5)
}
func (o *UART_Type) GetRS485CTRL_OINV() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0x20) >> 5
}
func (o *UART_Type) SetRS485CTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RS485CTRL.Reg, volatile.LoadUint32(&o.RS485CTRL.Reg)&^(0xffffffc0)|value<<6)
}
func (o *UART_Type) GetRS485CTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RS485CTRL.Reg) & 0xffffffc0) >> 6
}

// UART.RS485ADRMATCH: RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode.
func (o *UART_Type) SetRS485ADRMATCH_ADRMATCH(value uint32) {
	volatile.StoreUint32(&o.RS485ADRMATCH.Reg, volatile.LoadUint32(&o.RS485ADRMATCH.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetRS485ADRMATCH_ADRMATCH() uint32 {
	return volatile.LoadUint32(&o.RS485ADRMATCH.Reg) & 0xff
}
func (o *UART_Type) SetRS485ADRMATCH_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RS485ADRMATCH.Reg, volatile.LoadUint32(&o.RS485ADRMATCH.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART_Type) GetRS485ADRMATCH_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RS485ADRMATCH.Reg) & 0xffffff00) >> 8
}

// UART.RS485DLY: RS-485/EIA-485 direction control delay.
func (o *UART_Type) SetRS485DLY_DLY(value uint32) {
	volatile.StoreUint32(&o.RS485DLY.Reg, volatile.LoadUint32(&o.RS485DLY.Reg)&^(0xff)|value)
}
func (o *UART_Type) GetRS485DLY_DLY() uint32 {
	return volatile.LoadUint32(&o.RS485DLY.Reg) & 0xff
}
func (o *UART_Type) SetRS485DLY_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RS485DLY.Reg, volatile.LoadUint32(&o.RS485DLY.Reg)&^(0xffffff00)|value<<8)
}
func (o *UART_Type) GetRS485DLY_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RS485DLY.Reg) & 0xffffff00) >> 8
}

// Product name title=UM10398 Chapter title=LPC1100XL series: 16-bit counter/timer CT16B0/1 Modification date=2/22/2012 Major revision=8 Minor revision=not available
type CT16B0_Type struct {
	IR   volatile.Register32 // 0x0
	TCR  volatile.Register32 // 0x4
	TC   volatile.Register32 // 0x8
	PR   volatile.Register32 // 0xC
	PC   volatile.Register32 // 0x10
	MCR  volatile.Register32 // 0x14
	MR0  volatile.Register32 // 0x18
	MR1  volatile.Register32 // 0x1C
	MR2  volatile.Register32 // 0x20
	MR3  volatile.Register32 // 0x24
	CCR  volatile.Register32 // 0x28
	CR0  volatile.Register32 // 0x2C
	CR1  volatile.Register32 // 0x30
	_    [8]byte
	EMR  volatile.Register32 // 0x3C
	_    [48]byte
	CTCR volatile.Register32 // 0x70
	PWMC volatile.Register32 // 0x74
}

// CT16B0.IR: Interrupt Register (IR). The IR can be written to clear interrupts. The IR can be read to identify which of five possible interrupt sources are pending.
func (o *CT16B0_Type) SetIR_MR0INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x1)|value)
}
func (o *CT16B0_Type) GetIR_MR0INT() uint32 {
	return volatile.LoadUint32(&o.IR.Reg) & 0x1
}
func (o *CT16B0_Type) SetIR_MR1INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x2)|value<<1)
}
func (o *CT16B0_Type) GetIR_MR1INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x2) >> 1
}
func (o *CT16B0_Type) SetIR_MR2INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x4)|value<<2)
}
func (o *CT16B0_Type) GetIR_MR2INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x4) >> 2
}
func (o *CT16B0_Type) SetIR_MR3INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x8)|value<<3)
}
func (o *CT16B0_Type) GetIR_MR3INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x8) >> 3
}
func (o *CT16B0_Type) SetIR_CR0INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x10)|value<<4)
}
func (o *CT16B0_Type) GetIR_CR0INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x10) >> 4
}
func (o *CT16B0_Type) SetIR_CR1INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x20)|value<<5)
}
func (o *CT16B0_Type) GetIR_CR1INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x20) >> 5
}
func (o *CT16B0_Type) SetIR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0xffffffc0)|value<<6)
}
func (o *CT16B0_Type) GetIR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0xffffffc0) >> 6
}

// CT16B0.TCR: Timer Control Register (TCR). The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR.
func (o *CT16B0_Type) SetTCR_CEN(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x1)|value)
}
func (o *CT16B0_Type) GetTCR_CEN() uint32 {
	return volatile.LoadUint32(&o.TCR.Reg) & 0x1
}
func (o *CT16B0_Type) SetTCR_CRST(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x2)|value<<1)
}
func (o *CT16B0_Type) GetTCR_CRST() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x2) >> 1
}
func (o *CT16B0_Type) SetTCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *CT16B0_Type) GetTCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0xfffffffc) >> 2
}

// CT16B0.TC: Timer Counter (TC). The 16-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR.
func (o *CT16B0_Type) SetTC(value uint32) {
	volatile.StoreUint32(&o.TC.Reg, volatile.LoadUint32(&o.TC.Reg)&^(0xffff)|value)
}
func (o *CT16B0_Type) GetTC() uint32 {
	return volatile.LoadUint32(&o.TC.Reg) & 0xffff
}
func (o *CT16B0_Type) SetTC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TC.Reg, volatile.LoadUint32(&o.TC.Reg)&^(0xffff0000)|value<<16)
}
func (o *CT16B0_Type) GetTC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TC.Reg) & 0xffff0000) >> 16
}

// CT16B0.PR: Prescale Register (PR). When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC.
func (o *CT16B0_Type) SetPR(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0xffff)|value)
}
func (o *CT16B0_Type) GetPR() uint32 {
	return volatile.LoadUint32(&o.PR.Reg) & 0xffff
}
func (o *CT16B0_Type) SetPR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, volatile.LoadUint32(&o.PR.Reg)&^(0xffff0000)|value<<16)
}
func (o *CT16B0_Type) GetPR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PR.Reg) & 0xffff0000) >> 16
}

// CT16B0.PC: Prescale Counter (PC). The 16-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface.
func (o *CT16B0_Type) SetPC(value uint32) {
	volatile.StoreUint32(&o.PC.Reg, volatile.LoadUint32(&o.PC.Reg)&^(0xffff)|value)
}
func (o *CT16B0_Type) GetPC() uint32 {
	return volatile.LoadUint32(&o.PC.Reg) & 0xffff
}
func (o *CT16B0_Type) SetPC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PC.Reg, volatile.LoadUint32(&o.PC.Reg)&^(0xffff0000)|value<<16)
}
func (o *CT16B0_Type) GetPC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PC.Reg) & 0xffff0000) >> 16
}

// CT16B0.MCR: Match Control Register (MCR). The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs.
func (o *CT16B0_Type) SetMCR_MR0I(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x1)|value)
}
func (o *CT16B0_Type) GetMCR_MR0I() uint32 {
	return volatile.LoadUint32(&o.MCR.Reg) & 0x1
}
func (o *CT16B0_Type) SetMCR_MR0R(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x2)|value<<1)
}
func (o *CT16B0_Type) GetMCR_MR0R() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x2) >> 1
}
func (o *CT16B0_Type) SetMCR_MR0S(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x4)|value<<2)
}
func (o *CT16B0_Type) GetMCR_MR0S() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x4) >> 2
}
func (o *CT16B0_Type) SetMCR_MR1I(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x8)|value<<3)
}
func (o *CT16B0_Type) GetMCR_MR1I() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x8) >> 3
}
func (o *CT16B0_Type) SetMCR_MR1R(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x10)|value<<4)
}
func (o *CT16B0_Type) GetMCR_MR1R() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x10) >> 4
}
func (o *CT16B0_Type) SetMCR_MR1S(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x20)|value<<5)
}
func (o *CT16B0_Type) GetMCR_MR1S() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x20) >> 5
}
func (o *CT16B0_Type) SetMCR_MR2I(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x40)|value<<6)
}
func (o *CT16B0_Type) GetMCR_MR2I() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x40) >> 6
}
func (o *CT16B0_Type) SetMCR_MR2R(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x80)|value<<7)
}
func (o *CT16B0_Type) GetMCR_MR2R() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x80) >> 7
}
func (o *CT16B0_Type) SetMCR_MR2S(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x100)|value<<8)
}
func (o *CT16B0_Type) GetMCR_MR2S() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x100) >> 8
}
func (o *CT16B0_Type) SetMCR_MR3I(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x200)|value<<9)
}
func (o *CT16B0_Type) GetMCR_MR3I() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x200) >> 9
}
func (o *CT16B0_Type) SetMCR_MR3R(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x400)|value<<10)
}
func (o *CT16B0_Type) GetMCR_MR3R() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x400) >> 10
}
func (o *CT16B0_Type) SetMCR_MR3S(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x800)|value<<11)
}
func (o *CT16B0_Type) GetMCR_MR3S() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x800) >> 11
}
func (o *CT16B0_Type) SetMCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0xfffff000)|value<<12)
}
func (o *CT16B0_Type) GetMCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0xfffff000) >> 12
}

// CT16B0.MR0: Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
func (o *CT16B0_Type) SetMR0_MATCH(value uint32) {
	volatile.StoreUint32(&o.MR0.Reg, volatile.LoadUint32(&o.MR0.Reg)&^(0xffff)|value)
}
func (o *CT16B0_Type) GetMR0_MATCH() uint32 {
	return volatile.LoadUint32(&o.MR0.Reg) & 0xffff
}
func (o *CT16B0_Type) SetMR0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MR0.Reg, volatile.LoadUint32(&o.MR0.Reg)&^(0xffff0000)|value<<16)
}
func (o *CT16B0_Type) GetMR0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MR0.Reg) & 0xffff0000) >> 16
}

// CT16B0.MR1: Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
func (o *CT16B0_Type) SetMR1_MATCH(value uint32) {
	volatile.StoreUint32(&o.MR1.Reg, volatile.LoadUint32(&o.MR1.Reg)&^(0xffff)|value)
}
func (o *CT16B0_Type) GetMR1_MATCH() uint32 {
	return volatile.LoadUint32(&o.MR1.Reg) & 0xffff
}
func (o *CT16B0_Type) SetMR1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MR1.Reg, volatile.LoadUint32(&o.MR1.Reg)&^(0xffff0000)|value<<16)
}
func (o *CT16B0_Type) GetMR1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MR1.Reg) & 0xffff0000) >> 16
}

// CT16B0.MR2: Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
func (o *CT16B0_Type) SetMR2_MATCH(value uint32) {
	volatile.StoreUint32(&o.MR2.Reg, volatile.LoadUint32(&o.MR2.Reg)&^(0xffff)|value)
}
func (o *CT16B0_Type) GetMR2_MATCH() uint32 {
	return volatile.LoadUint32(&o.MR2.Reg) & 0xffff
}
func (o *CT16B0_Type) SetMR2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MR2.Reg, volatile.LoadUint32(&o.MR2.Reg)&^(0xffff0000)|value<<16)
}
func (o *CT16B0_Type) GetMR2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MR2.Reg) & 0xffff0000) >> 16
}

// CT16B0.MR3: Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
func (o *CT16B0_Type) SetMR3_MATCH(value uint32) {
	volatile.StoreUint32(&o.MR3.Reg, volatile.LoadUint32(&o.MR3.Reg)&^(0xffff)|value)
}
func (o *CT16B0_Type) GetMR3_MATCH() uint32 {
	return volatile.LoadUint32(&o.MR3.Reg) & 0xffff
}
func (o *CT16B0_Type) SetMR3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MR3.Reg, volatile.LoadUint32(&o.MR3.Reg)&^(0xffff0000)|value<<16)
}
func (o *CT16B0_Type) GetMR3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MR3.Reg) & 0xffff0000) >> 16
}

// CT16B0.CCR: Capture Control Register (CCR). The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place.
func (o *CT16B0_Type) SetCCR_CAP0RE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x1)|value)
}
func (o *CT16B0_Type) GetCCR_CAP0RE() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0x1
}
func (o *CT16B0_Type) SetCCR_CAP0FE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x2)|value<<1)
}
func (o *CT16B0_Type) GetCCR_CAP0FE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x2) >> 1
}
func (o *CT16B0_Type) SetCCR_CAP0I(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x4)|value<<2)
}
func (o *CT16B0_Type) GetCCR_CAP0I() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x4) >> 2
}
func (o *CT16B0_Type) SetCCR_CAP1RE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x8)|value<<3)
}
func (o *CT16B0_Type) GetCCR_CAP1RE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x8) >> 3
}
func (o *CT16B0_Type) SetCCR_CAP1FE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x10)|value<<4)
}
func (o *CT16B0_Type) GetCCR_CAP1FE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x10) >> 4
}
func (o *CT16B0_Type) SetCCR_CAP1I(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x20)|value<<5)
}
func (o *CT16B0_Type) GetCCR_CAP1I() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x20) >> 5
}
func (o *CT16B0_Type) SetCCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0xffffffc0)|value<<6)
}
func (o *CT16B0_Type) GetCCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0xffffffc0) >> 6
}

// CT16B0.CR0: Capture Register (CR). CR is loaded with the value of TC when there is an event on the CT16Bn_CAPm input.
func (o *CT16B0_Type) SetCR0_CAP(value uint32) {
	volatile.StoreUint32(&o.CR0.Reg, volatile.LoadUint32(&o.CR0.Reg)&^(0xffff)|value)
}
func (o *CT16B0_Type) GetCR0_CAP() uint32 {
	return volatile.LoadUint32(&o.CR0.Reg) & 0xffff
}
func (o *CT16B0_Type) SetCR0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CR0.Reg, volatile.LoadUint32(&o.CR0.Reg)&^(0xffff0000)|value<<16)
}
func (o *CT16B0_Type) GetCR0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CR0.Reg) & 0xffff0000) >> 16
}

// CT16B0.CR1: Capture Register (CR). CR is loaded with the value of TC when there is an event on the CT16Bn_CAPm input.
func (o *CT16B0_Type) SetCR1_CAP(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0xffff)|value)
}
func (o *CT16B0_Type) GetCR1_CAP() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0xffff
}
func (o *CT16B0_Type) SetCR1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0xffff0000)|value<<16)
}
func (o *CT16B0_Type) GetCR1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0xffff0000) >> 16
}

// CT16B0.EMR: External Match Register (EMR). The EMR controls the match function and the external match pins CT16B0_MAT[2:0].
func (o *CT16B0_Type) SetEMR_EM0(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x1)|value)
}
func (o *CT16B0_Type) GetEMR_EM0() uint32 {
	return volatile.LoadUint32(&o.EMR.Reg) & 0x1
}
func (o *CT16B0_Type) SetEMR_EM1(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x2)|value<<1)
}
func (o *CT16B0_Type) GetEMR_EM1() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x2) >> 1
}
func (o *CT16B0_Type) SetEMR_EM2(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x4)|value<<2)
}
func (o *CT16B0_Type) GetEMR_EM2() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x4) >> 2
}
func (o *CT16B0_Type) SetEMR_EM3(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x8)|value<<3)
}
func (o *CT16B0_Type) GetEMR_EM3() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x8) >> 3
}
func (o *CT16B0_Type) SetEMR_EMC0(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x30)|value<<4)
}
func (o *CT16B0_Type) GetEMR_EMC0() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x30) >> 4
}
func (o *CT16B0_Type) SetEMR_EMC1(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0xc0)|value<<6)
}
func (o *CT16B0_Type) GetEMR_EMC1() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0xc0) >> 6
}
func (o *CT16B0_Type) SetEMR_EMC2(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x300)|value<<8)
}
func (o *CT16B0_Type) GetEMR_EMC2() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x300) >> 8
}
func (o *CT16B0_Type) SetEMR_EMC3(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0xc00)|value<<10)
}
func (o *CT16B0_Type) GetEMR_EMC3() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0xc00) >> 10
}
func (o *CT16B0_Type) SetEMR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0xfffff000)|value<<12)
}
func (o *CT16B0_Type) GetEMR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0xfffff000) >> 12
}

// CT16B0.CTCR: Count Control Register (CTCR). The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.
func (o *CT16B0_Type) SetCTCR_CTM(value uint32) {
	volatile.StoreUint32(&o.CTCR.Reg, volatile.LoadUint32(&o.CTCR.Reg)&^(0x3)|value)
}
func (o *CT16B0_Type) GetCTCR_CTM() uint32 {
	return volatile.LoadUint32(&o.CTCR.Reg) & 0x3
}
func (o *CT16B0_Type) SetCTCR_CIS(value uint32) {
	volatile.StoreUint32(&o.CTCR.Reg, volatile.LoadUint32(&o.CTCR.Reg)&^(0xc)|value<<2)
}
func (o *CT16B0_Type) GetCTCR_CIS() uint32 {
	return (volatile.LoadUint32(&o.CTCR.Reg) & 0xc) >> 2
}
func (o *CT16B0_Type) SetCTCR_ENCC(value uint32) {
	volatile.StoreUint32(&o.CTCR.Reg, volatile.LoadUint32(&o.CTCR.Reg)&^(0x10)|value<<4)
}
func (o *CT16B0_Type) GetCTCR_ENCC() uint32 {
	return (volatile.LoadUint32(&o.CTCR.Reg) & 0x10) >> 4
}
func (o *CT16B0_Type) SetCTCR_SELCC(value uint32) {
	volatile.StoreUint32(&o.CTCR.Reg, volatile.LoadUint32(&o.CTCR.Reg)&^(0xe0)|value<<5)
}
func (o *CT16B0_Type) GetCTCR_SELCC() uint32 {
	return (volatile.LoadUint32(&o.CTCR.Reg) & 0xe0) >> 5
}
func (o *CT16B0_Type) SetCTCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTCR.Reg, volatile.LoadUint32(&o.CTCR.Reg)&^(0xffffff00)|value<<8)
}
func (o *CT16B0_Type) GetCTCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTCR.Reg) & 0xffffff00) >> 8
}

// CT16B0.PWMC: PWM Control Register (PWMCON). The PWMCON enables PWM mode for the external match pins CT16B0_MAT[2:0].
func (o *CT16B0_Type) SetPWMC_PWMEN0(value uint32) {
	volatile.StoreUint32(&o.PWMC.Reg, volatile.LoadUint32(&o.PWMC.Reg)&^(0x1)|value)
}
func (o *CT16B0_Type) GetPWMC_PWMEN0() uint32 {
	return volatile.LoadUint32(&o.PWMC.Reg) & 0x1
}
func (o *CT16B0_Type) SetPWMC_PWMEN1(value uint32) {
	volatile.StoreUint32(&o.PWMC.Reg, volatile.LoadUint32(&o.PWMC.Reg)&^(0x2)|value<<1)
}
func (o *CT16B0_Type) GetPWMC_PWMEN1() uint32 {
	return (volatile.LoadUint32(&o.PWMC.Reg) & 0x2) >> 1
}
func (o *CT16B0_Type) SetPWMC_PWMEN2(value uint32) {
	volatile.StoreUint32(&o.PWMC.Reg, volatile.LoadUint32(&o.PWMC.Reg)&^(0x4)|value<<2)
}
func (o *CT16B0_Type) GetPWMC_PWMEN2() uint32 {
	return (volatile.LoadUint32(&o.PWMC.Reg) & 0x4) >> 2
}
func (o *CT16B0_Type) SetPWMC_PWMEN3(value uint32) {
	volatile.StoreUint32(&o.PWMC.Reg, volatile.LoadUint32(&o.PWMC.Reg)&^(0x8)|value<<3)
}
func (o *CT16B0_Type) GetPWMC_PWMEN3() uint32 {
	return (volatile.LoadUint32(&o.PWMC.Reg) & 0x8) >> 3
}
func (o *CT16B0_Type) SetPWMC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PWMC.Reg, volatile.LoadUint32(&o.PWMC.Reg)&^(0xfffffff0)|value<<4)
}
func (o *CT16B0_Type) GetPWMC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PWMC.Reg) & 0xfffffff0) >> 4
}

// Product name title=UM10398 Chapter title=LPC1100XL series: 32-bit counter/timer CT32B0/1 Modification date=2/22/2012 Major revision=8 Minor revision=not available
type CT32B0_Type struct {
	IR   volatile.Register32 // 0x0
	TCR  volatile.Register32 // 0x4
	TC   volatile.Register32 // 0x8
	PR   volatile.Register32 // 0xC
	PC   volatile.Register32 // 0x10
	MCR  volatile.Register32 // 0x14
	MR0  volatile.Register32 // 0x18
	MR1  volatile.Register32 // 0x1C
	MR2  volatile.Register32 // 0x20
	MR3  volatile.Register32 // 0x24
	CCR  volatile.Register32 // 0x28
	CR0  volatile.Register32 // 0x2C
	CR1  volatile.Register32 // 0x30
	_    [8]byte
	EMR  volatile.Register32 // 0x3C
	_    [48]byte
	CTCR volatile.Register32 // 0x70
	PWMC volatile.Register32 // 0x74
}

// CT32B0.IR: Interrupt Register (IR). The IR can be written to clear interrupts. The IR can be read to identify which of five possible interrupt sources are pending.
func (o *CT32B0_Type) SetIR_MR0INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x1)|value)
}
func (o *CT32B0_Type) GetIR_MR0INT() uint32 {
	return volatile.LoadUint32(&o.IR.Reg) & 0x1
}
func (o *CT32B0_Type) SetIR_MR1INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x2)|value<<1)
}
func (o *CT32B0_Type) GetIR_MR1INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x2) >> 1
}
func (o *CT32B0_Type) SetIR_MR2INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x4)|value<<2)
}
func (o *CT32B0_Type) GetIR_MR2INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x4) >> 2
}
func (o *CT32B0_Type) SetIR_MR3INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x8)|value<<3)
}
func (o *CT32B0_Type) GetIR_MR3INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x8) >> 3
}
func (o *CT32B0_Type) SetIR_CR0INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x10)|value<<4)
}
func (o *CT32B0_Type) GetIR_CR0INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x10) >> 4
}
func (o *CT32B0_Type) SetIR_CR1INT(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0x20)|value<<5)
}
func (o *CT32B0_Type) GetIR_CR1INT() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0x20) >> 5
}
func (o *CT32B0_Type) SetIR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IR.Reg, volatile.LoadUint32(&o.IR.Reg)&^(0xffffffc0)|value<<6)
}
func (o *CT32B0_Type) GetIR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IR.Reg) & 0xffffffc0) >> 6
}

// CT32B0.TCR: Timer Control Register (TCR). The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR.
func (o *CT32B0_Type) SetTCR_CEN(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x1)|value)
}
func (o *CT32B0_Type) GetTCR_CEN() uint32 {
	return volatile.LoadUint32(&o.TCR.Reg) & 0x1
}
func (o *CT32B0_Type) SetTCR_CRST(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0x2)|value<<1)
}
func (o *CT32B0_Type) GetTCR_CRST() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0x2) >> 1
}
func (o *CT32B0_Type) SetTCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.TCR.Reg, volatile.LoadUint32(&o.TCR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *CT32B0_Type) GetTCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.TCR.Reg) & 0xfffffffc) >> 2
}

// CT32B0.TC: Timer Counter (TC). The 32-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR.
func (o *CT32B0_Type) SetTC(value uint32) {
	volatile.StoreUint32(&o.TC.Reg, value)
}
func (o *CT32B0_Type) GetTC() uint32 {
	return volatile.LoadUint32(&o.TC.Reg)
}

// CT32B0.PR: Prescale Register (PR). When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC.
func (o *CT32B0_Type) SetPR(value uint32) {
	volatile.StoreUint32(&o.PR.Reg, value)
}
func (o *CT32B0_Type) GetPR() uint32 {
	return volatile.LoadUint32(&o.PR.Reg)
}

// CT32B0.PC: Prescale Counter (PC). The 32-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface.
func (o *CT32B0_Type) SetPC(value uint32) {
	volatile.StoreUint32(&o.PC.Reg, value)
}
func (o *CT32B0_Type) GetPC() uint32 {
	return volatile.LoadUint32(&o.PC.Reg)
}

// CT32B0.MCR: Match Control Register (MCR). The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs.
func (o *CT32B0_Type) SetMCR_MR0I(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x1)|value)
}
func (o *CT32B0_Type) GetMCR_MR0I() uint32 {
	return volatile.LoadUint32(&o.MCR.Reg) & 0x1
}
func (o *CT32B0_Type) SetMCR_MR0R(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x2)|value<<1)
}
func (o *CT32B0_Type) GetMCR_MR0R() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x2) >> 1
}
func (o *CT32B0_Type) SetMCR_MR0S(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x4)|value<<2)
}
func (o *CT32B0_Type) GetMCR_MR0S() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x4) >> 2
}
func (o *CT32B0_Type) SetMCR_MR1I(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x8)|value<<3)
}
func (o *CT32B0_Type) GetMCR_MR1I() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x8) >> 3
}
func (o *CT32B0_Type) SetMCR_MR1R(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x10)|value<<4)
}
func (o *CT32B0_Type) GetMCR_MR1R() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x10) >> 4
}
func (o *CT32B0_Type) SetMCR_MR1S(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x20)|value<<5)
}
func (o *CT32B0_Type) GetMCR_MR1S() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x20) >> 5
}
func (o *CT32B0_Type) SetMCR_MR2I(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x40)|value<<6)
}
func (o *CT32B0_Type) GetMCR_MR2I() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x40) >> 6
}
func (o *CT32B0_Type) SetMCR_MR2R(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x80)|value<<7)
}
func (o *CT32B0_Type) GetMCR_MR2R() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x80) >> 7
}
func (o *CT32B0_Type) SetMCR_MR2S(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x100)|value<<8)
}
func (o *CT32B0_Type) GetMCR_MR2S() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x100) >> 8
}
func (o *CT32B0_Type) SetMCR_MR3I(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x200)|value<<9)
}
func (o *CT32B0_Type) GetMCR_MR3I() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x200) >> 9
}
func (o *CT32B0_Type) SetMCR_MR3R(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x400)|value<<10)
}
func (o *CT32B0_Type) GetMCR_MR3R() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x400) >> 10
}
func (o *CT32B0_Type) SetMCR_MR3S(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0x800)|value<<11)
}
func (o *CT32B0_Type) GetMCR_MR3S() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0x800) >> 11
}
func (o *CT32B0_Type) SetMCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MCR.Reg, volatile.LoadUint32(&o.MCR.Reg)&^(0xfffff000)|value<<12)
}
func (o *CT32B0_Type) GetMCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MCR.Reg) & 0xfffff000) >> 12
}

// CT32B0.MR0: Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
func (o *CT32B0_Type) SetMR0(value uint32) {
	volatile.StoreUint32(&o.MR0.Reg, value)
}
func (o *CT32B0_Type) GetMR0() uint32 {
	return volatile.LoadUint32(&o.MR0.Reg)
}

// CT32B0.MR1: Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
func (o *CT32B0_Type) SetMR1(value uint32) {
	volatile.StoreUint32(&o.MR1.Reg, value)
}
func (o *CT32B0_Type) GetMR1() uint32 {
	return volatile.LoadUint32(&o.MR1.Reg)
}

// CT32B0.MR2: Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
func (o *CT32B0_Type) SetMR2(value uint32) {
	volatile.StoreUint32(&o.MR2.Reg, value)
}
func (o *CT32B0_Type) GetMR2() uint32 {
	return volatile.LoadUint32(&o.MR2.Reg)
}

// CT32B0.MR3: Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
func (o *CT32B0_Type) SetMR3(value uint32) {
	volatile.StoreUint32(&o.MR3.Reg, value)
}
func (o *CT32B0_Type) GetMR3() uint32 {
	return volatile.LoadUint32(&o.MR3.Reg)
}

// CT32B0.CCR: Capture Control Register (CCR). The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place.
func (o *CT32B0_Type) SetCCR_CAP0RE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x1)|value)
}
func (o *CT32B0_Type) GetCCR_CAP0RE() uint32 {
	return volatile.LoadUint32(&o.CCR.Reg) & 0x1
}
func (o *CT32B0_Type) SetCCR_CAP0FE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x2)|value<<1)
}
func (o *CT32B0_Type) GetCCR_CAP0FE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x2) >> 1
}
func (o *CT32B0_Type) SetCCR_CAP0I(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x4)|value<<2)
}
func (o *CT32B0_Type) GetCCR_CAP0I() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x4) >> 2
}
func (o *CT32B0_Type) SetCCR_CAP1RE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x8)|value<<3)
}
func (o *CT32B0_Type) GetCCR_CAP1RE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x8) >> 3
}
func (o *CT32B0_Type) SetCCR_CAP1FE(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x10)|value<<4)
}
func (o *CT32B0_Type) GetCCR_CAP1FE() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x10) >> 4
}
func (o *CT32B0_Type) SetCCR_CAP1I(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0x20)|value<<5)
}
func (o *CT32B0_Type) GetCCR_CAP1I() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0x20) >> 5
}
func (o *CT32B0_Type) SetCCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CCR.Reg, volatile.LoadUint32(&o.CCR.Reg)&^(0xffffffc0)|value<<6)
}
func (o *CT32B0_Type) GetCCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CCR.Reg) & 0xffffffc0) >> 6
}

// CT32B0.CR0: Capture Register (CR). CR is loaded with the value of TC when there is an event on the CT16Bn_CAPm input.
func (o *CT32B0_Type) SetCR0(value uint32) {
	volatile.StoreUint32(&o.CR0.Reg, value)
}
func (o *CT32B0_Type) GetCR0() uint32 {
	return volatile.LoadUint32(&o.CR0.Reg)
}

// CT32B0.CR1: Capture Register (CR). CR is loaded with the value of TC when there is an event on the CT16Bn_CAPm input.
func (o *CT32B0_Type) SetCR1(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, value)
}
func (o *CT32B0_Type) GetCR1() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg)
}

// CT32B0.EMR: External Match Register (EMR). The EMR controls the match function and the external match pins CT32B0_MAT[3:0].
func (o *CT32B0_Type) SetEMR_EM0(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x1)|value)
}
func (o *CT32B0_Type) GetEMR_EM0() uint32 {
	return volatile.LoadUint32(&o.EMR.Reg) & 0x1
}
func (o *CT32B0_Type) SetEMR_EM1(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x2)|value<<1)
}
func (o *CT32B0_Type) GetEMR_EM1() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x2) >> 1
}
func (o *CT32B0_Type) SetEMR_EM2(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x4)|value<<2)
}
func (o *CT32B0_Type) GetEMR_EM2() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x4) >> 2
}
func (o *CT32B0_Type) SetEMR_EM3(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x8)|value<<3)
}
func (o *CT32B0_Type) GetEMR_EM3() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x8) >> 3
}
func (o *CT32B0_Type) SetEMR_EMC0(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x30)|value<<4)
}
func (o *CT32B0_Type) GetEMR_EMC0() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x30) >> 4
}
func (o *CT32B0_Type) SetEMR_EMC1(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0xc0)|value<<6)
}
func (o *CT32B0_Type) GetEMR_EMC1() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0xc0) >> 6
}
func (o *CT32B0_Type) SetEMR_EMC2(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0x300)|value<<8)
}
func (o *CT32B0_Type) GetEMR_EMC2() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0x300) >> 8
}
func (o *CT32B0_Type) SetEMR_EMC3(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0xc00)|value<<10)
}
func (o *CT32B0_Type) GetEMR_EMC3() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0xc00) >> 10
}
func (o *CT32B0_Type) SetEMR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.EMR.Reg, volatile.LoadUint32(&o.EMR.Reg)&^(0xfffff000)|value<<12)
}
func (o *CT32B0_Type) GetEMR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.EMR.Reg) & 0xfffff000) >> 12
}

// CT32B0.CTCR: Count Control Register (CTCR). The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.
func (o *CT32B0_Type) SetCTCR_CTM(value uint32) {
	volatile.StoreUint32(&o.CTCR.Reg, volatile.LoadUint32(&o.CTCR.Reg)&^(0x3)|value)
}
func (o *CT32B0_Type) GetCTCR_CTM() uint32 {
	return volatile.LoadUint32(&o.CTCR.Reg) & 0x3
}
func (o *CT32B0_Type) SetCTCR_CIS(value uint32) {
	volatile.StoreUint32(&o.CTCR.Reg, volatile.LoadUint32(&o.CTCR.Reg)&^(0xc)|value<<2)
}
func (o *CT32B0_Type) GetCTCR_CIS() uint32 {
	return (volatile.LoadUint32(&o.CTCR.Reg) & 0xc) >> 2
}
func (o *CT32B0_Type) SetCTCR_ENCC(value uint32) {
	volatile.StoreUint32(&o.CTCR.Reg, volatile.LoadUint32(&o.CTCR.Reg)&^(0x10)|value<<4)
}
func (o *CT32B0_Type) GetCTCR_ENCC() uint32 {
	return (volatile.LoadUint32(&o.CTCR.Reg) & 0x10) >> 4
}
func (o *CT32B0_Type) SetCTCR_SELCC(value uint32) {
	volatile.StoreUint32(&o.CTCR.Reg, volatile.LoadUint32(&o.CTCR.Reg)&^(0xe0)|value<<5)
}
func (o *CT32B0_Type) GetCTCR_SELCC() uint32 {
	return (volatile.LoadUint32(&o.CTCR.Reg) & 0xe0) >> 5
}
func (o *CT32B0_Type) SetCTCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CTCR.Reg, volatile.LoadUint32(&o.CTCR.Reg)&^(0xffffff00)|value<<8)
}
func (o *CT32B0_Type) GetCTCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CTCR.Reg) & 0xffffff00) >> 8
}

// CT32B0.PWMC: PWM Control Register (PWMCON). The PWMCON enables PWM mode for the external match pins CT32B0_MAT[3:0].
func (o *CT32B0_Type) SetPWMC_PWMEN0(value uint32) {
	volatile.StoreUint32(&o.PWMC.Reg, volatile.LoadUint32(&o.PWMC.Reg)&^(0x1)|value)
}
func (o *CT32B0_Type) GetPWMC_PWMEN0() uint32 {
	return volatile.LoadUint32(&o.PWMC.Reg) & 0x1
}
func (o *CT32B0_Type) SetPWMC_PWMEN1(value uint32) {
	volatile.StoreUint32(&o.PWMC.Reg, volatile.LoadUint32(&o.PWMC.Reg)&^(0x2)|value<<1)
}
func (o *CT32B0_Type) GetPWMC_PWMEN1() uint32 {
	return (volatile.LoadUint32(&o.PWMC.Reg) & 0x2) >> 1
}
func (o *CT32B0_Type) SetPWMC_PWMEN2(value uint32) {
	volatile.StoreUint32(&o.PWMC.Reg, volatile.LoadUint32(&o.PWMC.Reg)&^(0x4)|value<<2)
}
func (o *CT32B0_Type) GetPWMC_PWMEN2() uint32 {
	return (volatile.LoadUint32(&o.PWMC.Reg) & 0x4) >> 2
}
func (o *CT32B0_Type) SetPWMC_PWMEN3(value uint32) {
	volatile.StoreUint32(&o.PWMC.Reg, volatile.LoadUint32(&o.PWMC.Reg)&^(0x8)|value<<3)
}
func (o *CT32B0_Type) GetPWMC_PWMEN3() uint32 {
	return (volatile.LoadUint32(&o.PWMC.Reg) & 0x8) >> 3
}
func (o *CT32B0_Type) SetPWMC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PWMC.Reg, volatile.LoadUint32(&o.PWMC.Reg)&^(0xfffffff0)|value<<4)
}
func (o *CT32B0_Type) GetPWMC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PWMC.Reg) & 0xfffffff0) >> 4
}

// 10-bit ADC
type ADC_Type struct {
	CR    volatile.Register32 // 0x0
	GDR   volatile.Register32 // 0x4
	_     [4]byte
	INTEN volatile.Register32 // 0xC
	DR0   volatile.Register32 // 0x10
	DR1   volatile.Register32 // 0x14
	DR2   volatile.Register32 // 0x18
	DR3   volatile.Register32 // 0x1C
	DR4   volatile.Register32 // 0x20
	DR5   volatile.Register32 // 0x24
	DR6   volatile.Register32 // 0x28
	DR7   volatile.Register32 // 0x2C
	STAT  volatile.Register32 // 0x30
}

// ADC.CR: A/D Control Register. The ADCR register must be written to select the operating mode before A/D conversion can occur.
func (o *ADC_Type) SetCR_SEL(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xff)|value)
}
func (o *ADC_Type) GetCR_SEL() uint32 {
	return volatile.LoadUint32(&o.CR.Reg) & 0xff
}
func (o *ADC_Type) SetCR_CLKDIV(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xff00)|value<<8)
}
func (o *ADC_Type) GetCR_CLKDIV() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xff00) >> 8
}
func (o *ADC_Type) SetCR_BURST(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x10000)|value<<16)
}
func (o *ADC_Type) GetCR_BURST() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x10000) >> 16
}
func (o *ADC_Type) SetCR_CLKS(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xe0000)|value<<17)
}
func (o *ADC_Type) GetCR_CLKS() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xe0000) >> 17
}
func (o *ADC_Type) SetCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xf00000)|value<<20)
}
func (o *ADC_Type) GetCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xf00000) >> 20
}
func (o *ADC_Type) SetCR_START(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x7000000)|value<<24)
}
func (o *ADC_Type) GetCR_START() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x7000000) >> 24
}
func (o *ADC_Type) SetCR_EDGE(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0x8000000)|value<<27)
}
func (o *ADC_Type) GetCR_EDGE() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0x8000000) >> 27
}
func (o *ADC_Type) SetCR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CR.Reg, volatile.LoadUint32(&o.CR.Reg)&^(0xf0000000)|value<<28)
}
func (o *ADC_Type) GetCR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CR.Reg) & 0xf0000000) >> 28
}

// ADC.GDR: A/D Global Data Register. Contains the result of the most recent A/D conversion.
func (o *ADC_Type) SetGDR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.GDR.Reg, volatile.LoadUint32(&o.GDR.Reg)&^(0x3f)|value)
}
func (o *ADC_Type) GetGDR_RESERVED() uint32 {
	return volatile.LoadUint32(&o.GDR.Reg) & 0x3f
}
func (o *ADC_Type) SetGDR_V_VREF(value uint32) {
	volatile.StoreUint32(&o.GDR.Reg, volatile.LoadUint32(&o.GDR.Reg)&^(0xffc0)|value<<6)
}
func (o *ADC_Type) GetGDR_V_VREF() uint32 {
	return (volatile.LoadUint32(&o.GDR.Reg) & 0xffc0) >> 6
}
func (o *ADC_Type) SetGDR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.GDR.Reg, volatile.LoadUint32(&o.GDR.Reg)&^(0xff0000)|value<<16)
}
func (o *ADC_Type) GetGDR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.GDR.Reg) & 0xff0000) >> 16
}
func (o *ADC_Type) SetGDR_CHN(value uint32) {
	volatile.StoreUint32(&o.GDR.Reg, volatile.LoadUint32(&o.GDR.Reg)&^(0x7000000)|value<<24)
}
func (o *ADC_Type) GetGDR_CHN() uint32 {
	return (volatile.LoadUint32(&o.GDR.Reg) & 0x7000000) >> 24
}
func (o *ADC_Type) SetGDR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.GDR.Reg, volatile.LoadUint32(&o.GDR.Reg)&^(0x38000000)|value<<27)
}
func (o *ADC_Type) GetGDR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.GDR.Reg) & 0x38000000) >> 27
}
func (o *ADC_Type) SetGDR_OVERRUN(value uint32) {
	volatile.StoreUint32(&o.GDR.Reg, volatile.LoadUint32(&o.GDR.Reg)&^(0x40000000)|value<<30)
}
func (o *ADC_Type) GetGDR_OVERRUN() uint32 {
	return (volatile.LoadUint32(&o.GDR.Reg) & 0x40000000) >> 30
}
func (o *ADC_Type) SetGDR_DONE(value uint32) {
	volatile.StoreUint32(&o.GDR.Reg, volatile.LoadUint32(&o.GDR.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetGDR_DONE() uint32 {
	return (volatile.LoadUint32(&o.GDR.Reg) & 0x80000000) >> 31
}

// ADC.INTEN: A/D Interrupt Enable Register. This register contains enable bits that allow the DONE flag of each A/D channel to be included or excluded from contributing to the generation of an A/D interrupt.
func (o *ADC_Type) SetINTEN_ADINTENn(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0xff)|value)
}
func (o *ADC_Type) GetINTEN_ADINTENn() uint32 {
	return volatile.LoadUint32(&o.INTEN.Reg) & 0xff
}
func (o *ADC_Type) SetINTEN_ADGINTEN(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0x100)|value<<8)
}
func (o *ADC_Type) GetINTEN_ADGINTEN() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0x100) >> 8
}
func (o *ADC_Type) SetINTEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.INTEN.Reg, volatile.LoadUint32(&o.INTEN.Reg)&^(0xfffffe00)|value<<9)
}
func (o *ADC_Type) GetINTEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.INTEN.Reg) & 0xfffffe00) >> 9
}

// ADC.DR0: A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
func (o *ADC_Type) SetDR0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DR0.Reg, volatile.LoadUint32(&o.DR0.Reg)&^(0x3f)|value)
}
func (o *ADC_Type) GetDR0_RESERVED() uint32 {
	return volatile.LoadUint32(&o.DR0.Reg) & 0x3f
}
func (o *ADC_Type) SetDR0_V_VREF(value uint32) {
	volatile.StoreUint32(&o.DR0.Reg, volatile.LoadUint32(&o.DR0.Reg)&^(0xffc0)|value<<6)
}
func (o *ADC_Type) GetDR0_V_VREF() uint32 {
	return (volatile.LoadUint32(&o.DR0.Reg) & 0xffc0) >> 6
}
func (o *ADC_Type) SetDR0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DR0.Reg, volatile.LoadUint32(&o.DR0.Reg)&^(0x3fff0000)|value<<16)
}
func (o *ADC_Type) GetDR0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DR0.Reg) & 0x3fff0000) >> 16
}
func (o *ADC_Type) SetDR0_OVERRUN(value uint32) {
	volatile.StoreUint32(&o.DR0.Reg, volatile.LoadUint32(&o.DR0.Reg)&^(0x40000000)|value<<30)
}
func (o *ADC_Type) GetDR0_OVERRUN() uint32 {
	return (volatile.LoadUint32(&o.DR0.Reg) & 0x40000000) >> 30
}
func (o *ADC_Type) SetDR0_DONE(value uint32) {
	volatile.StoreUint32(&o.DR0.Reg, volatile.LoadUint32(&o.DR0.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetDR0_DONE() uint32 {
	return (volatile.LoadUint32(&o.DR0.Reg) & 0x80000000) >> 31
}

// ADC.DR1: A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
func (o *ADC_Type) SetDR1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DR1.Reg, volatile.LoadUint32(&o.DR1.Reg)&^(0x3f)|value)
}
func (o *ADC_Type) GetDR1_RESERVED() uint32 {
	return volatile.LoadUint32(&o.DR1.Reg) & 0x3f
}
func (o *ADC_Type) SetDR1_V_VREF(value uint32) {
	volatile.StoreUint32(&o.DR1.Reg, volatile.LoadUint32(&o.DR1.Reg)&^(0xffc0)|value<<6)
}
func (o *ADC_Type) GetDR1_V_VREF() uint32 {
	return (volatile.LoadUint32(&o.DR1.Reg) & 0xffc0) >> 6
}
func (o *ADC_Type) SetDR1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DR1.Reg, volatile.LoadUint32(&o.DR1.Reg)&^(0x3fff0000)|value<<16)
}
func (o *ADC_Type) GetDR1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DR1.Reg) & 0x3fff0000) >> 16
}
func (o *ADC_Type) SetDR1_OVERRUN(value uint32) {
	volatile.StoreUint32(&o.DR1.Reg, volatile.LoadUint32(&o.DR1.Reg)&^(0x40000000)|value<<30)
}
func (o *ADC_Type) GetDR1_OVERRUN() uint32 {
	return (volatile.LoadUint32(&o.DR1.Reg) & 0x40000000) >> 30
}
func (o *ADC_Type) SetDR1_DONE(value uint32) {
	volatile.StoreUint32(&o.DR1.Reg, volatile.LoadUint32(&o.DR1.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetDR1_DONE() uint32 {
	return (volatile.LoadUint32(&o.DR1.Reg) & 0x80000000) >> 31
}

// ADC.DR2: A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
func (o *ADC_Type) SetDR2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DR2.Reg, volatile.LoadUint32(&o.DR2.Reg)&^(0x3f)|value)
}
func (o *ADC_Type) GetDR2_RESERVED() uint32 {
	return volatile.LoadUint32(&o.DR2.Reg) & 0x3f
}
func (o *ADC_Type) SetDR2_V_VREF(value uint32) {
	volatile.StoreUint32(&o.DR2.Reg, volatile.LoadUint32(&o.DR2.Reg)&^(0xffc0)|value<<6)
}
func (o *ADC_Type) GetDR2_V_VREF() uint32 {
	return (volatile.LoadUint32(&o.DR2.Reg) & 0xffc0) >> 6
}
func (o *ADC_Type) SetDR2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DR2.Reg, volatile.LoadUint32(&o.DR2.Reg)&^(0x3fff0000)|value<<16)
}
func (o *ADC_Type) GetDR2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DR2.Reg) & 0x3fff0000) >> 16
}
func (o *ADC_Type) SetDR2_OVERRUN(value uint32) {
	volatile.StoreUint32(&o.DR2.Reg, volatile.LoadUint32(&o.DR2.Reg)&^(0x40000000)|value<<30)
}
func (o *ADC_Type) GetDR2_OVERRUN() uint32 {
	return (volatile.LoadUint32(&o.DR2.Reg) & 0x40000000) >> 30
}
func (o *ADC_Type) SetDR2_DONE(value uint32) {
	volatile.StoreUint32(&o.DR2.Reg, volatile.LoadUint32(&o.DR2.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetDR2_DONE() uint32 {
	return (volatile.LoadUint32(&o.DR2.Reg) & 0x80000000) >> 31
}

// ADC.DR3: A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
func (o *ADC_Type) SetDR3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DR3.Reg, volatile.LoadUint32(&o.DR3.Reg)&^(0x3f)|value)
}
func (o *ADC_Type) GetDR3_RESERVED() uint32 {
	return volatile.LoadUint32(&o.DR3.Reg) & 0x3f
}
func (o *ADC_Type) SetDR3_V_VREF(value uint32) {
	volatile.StoreUint32(&o.DR3.Reg, volatile.LoadUint32(&o.DR3.Reg)&^(0xffc0)|value<<6)
}
func (o *ADC_Type) GetDR3_V_VREF() uint32 {
	return (volatile.LoadUint32(&o.DR3.Reg) & 0xffc0) >> 6
}
func (o *ADC_Type) SetDR3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DR3.Reg, volatile.LoadUint32(&o.DR3.Reg)&^(0x3fff0000)|value<<16)
}
func (o *ADC_Type) GetDR3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DR3.Reg) & 0x3fff0000) >> 16
}
func (o *ADC_Type) SetDR3_OVERRUN(value uint32) {
	volatile.StoreUint32(&o.DR3.Reg, volatile.LoadUint32(&o.DR3.Reg)&^(0x40000000)|value<<30)
}
func (o *ADC_Type) GetDR3_OVERRUN() uint32 {
	return (volatile.LoadUint32(&o.DR3.Reg) & 0x40000000) >> 30
}
func (o *ADC_Type) SetDR3_DONE(value uint32) {
	volatile.StoreUint32(&o.DR3.Reg, volatile.LoadUint32(&o.DR3.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetDR3_DONE() uint32 {
	return (volatile.LoadUint32(&o.DR3.Reg) & 0x80000000) >> 31
}

// ADC.DR4: A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
func (o *ADC_Type) SetDR4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DR4.Reg, volatile.LoadUint32(&o.DR4.Reg)&^(0x3f)|value)
}
func (o *ADC_Type) GetDR4_RESERVED() uint32 {
	return volatile.LoadUint32(&o.DR4.Reg) & 0x3f
}
func (o *ADC_Type) SetDR4_V_VREF(value uint32) {
	volatile.StoreUint32(&o.DR4.Reg, volatile.LoadUint32(&o.DR4.Reg)&^(0xffc0)|value<<6)
}
func (o *ADC_Type) GetDR4_V_VREF() uint32 {
	return (volatile.LoadUint32(&o.DR4.Reg) & 0xffc0) >> 6
}
func (o *ADC_Type) SetDR4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DR4.Reg, volatile.LoadUint32(&o.DR4.Reg)&^(0x3fff0000)|value<<16)
}
func (o *ADC_Type) GetDR4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DR4.Reg) & 0x3fff0000) >> 16
}
func (o *ADC_Type) SetDR4_OVERRUN(value uint32) {
	volatile.StoreUint32(&o.DR4.Reg, volatile.LoadUint32(&o.DR4.Reg)&^(0x40000000)|value<<30)
}
func (o *ADC_Type) GetDR4_OVERRUN() uint32 {
	return (volatile.LoadUint32(&o.DR4.Reg) & 0x40000000) >> 30
}
func (o *ADC_Type) SetDR4_DONE(value uint32) {
	volatile.StoreUint32(&o.DR4.Reg, volatile.LoadUint32(&o.DR4.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetDR4_DONE() uint32 {
	return (volatile.LoadUint32(&o.DR4.Reg) & 0x80000000) >> 31
}

// ADC.DR5: A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
func (o *ADC_Type) SetDR5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DR5.Reg, volatile.LoadUint32(&o.DR5.Reg)&^(0x3f)|value)
}
func (o *ADC_Type) GetDR5_RESERVED() uint32 {
	return volatile.LoadUint32(&o.DR5.Reg) & 0x3f
}
func (o *ADC_Type) SetDR5_V_VREF(value uint32) {
	volatile.StoreUint32(&o.DR5.Reg, volatile.LoadUint32(&o.DR5.Reg)&^(0xffc0)|value<<6)
}
func (o *ADC_Type) GetDR5_V_VREF() uint32 {
	return (volatile.LoadUint32(&o.DR5.Reg) & 0xffc0) >> 6
}
func (o *ADC_Type) SetDR5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DR5.Reg, volatile.LoadUint32(&o.DR5.Reg)&^(0x3fff0000)|value<<16)
}
func (o *ADC_Type) GetDR5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DR5.Reg) & 0x3fff0000) >> 16
}
func (o *ADC_Type) SetDR5_OVERRUN(value uint32) {
	volatile.StoreUint32(&o.DR5.Reg, volatile.LoadUint32(&o.DR5.Reg)&^(0x40000000)|value<<30)
}
func (o *ADC_Type) GetDR5_OVERRUN() uint32 {
	return (volatile.LoadUint32(&o.DR5.Reg) & 0x40000000) >> 30
}
func (o *ADC_Type) SetDR5_DONE(value uint32) {
	volatile.StoreUint32(&o.DR5.Reg, volatile.LoadUint32(&o.DR5.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetDR5_DONE() uint32 {
	return (volatile.LoadUint32(&o.DR5.Reg) & 0x80000000) >> 31
}

// ADC.DR6: A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
func (o *ADC_Type) SetDR6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DR6.Reg, volatile.LoadUint32(&o.DR6.Reg)&^(0x3f)|value)
}
func (o *ADC_Type) GetDR6_RESERVED() uint32 {
	return volatile.LoadUint32(&o.DR6.Reg) & 0x3f
}
func (o *ADC_Type) SetDR6_V_VREF(value uint32) {
	volatile.StoreUint32(&o.DR6.Reg, volatile.LoadUint32(&o.DR6.Reg)&^(0xffc0)|value<<6)
}
func (o *ADC_Type) GetDR6_V_VREF() uint32 {
	return (volatile.LoadUint32(&o.DR6.Reg) & 0xffc0) >> 6
}
func (o *ADC_Type) SetDR6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DR6.Reg, volatile.LoadUint32(&o.DR6.Reg)&^(0x3fff0000)|value<<16)
}
func (o *ADC_Type) GetDR6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DR6.Reg) & 0x3fff0000) >> 16
}
func (o *ADC_Type) SetDR6_OVERRUN(value uint32) {
	volatile.StoreUint32(&o.DR6.Reg, volatile.LoadUint32(&o.DR6.Reg)&^(0x40000000)|value<<30)
}
func (o *ADC_Type) GetDR6_OVERRUN() uint32 {
	return (volatile.LoadUint32(&o.DR6.Reg) & 0x40000000) >> 30
}
func (o *ADC_Type) SetDR6_DONE(value uint32) {
	volatile.StoreUint32(&o.DR6.Reg, volatile.LoadUint32(&o.DR6.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetDR6_DONE() uint32 {
	return (volatile.LoadUint32(&o.DR6.Reg) & 0x80000000) >> 31
}

// ADC.DR7: A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
func (o *ADC_Type) SetDR7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DR7.Reg, volatile.LoadUint32(&o.DR7.Reg)&^(0x3f)|value)
}
func (o *ADC_Type) GetDR7_RESERVED() uint32 {
	return volatile.LoadUint32(&o.DR7.Reg) & 0x3f
}
func (o *ADC_Type) SetDR7_V_VREF(value uint32) {
	volatile.StoreUint32(&o.DR7.Reg, volatile.LoadUint32(&o.DR7.Reg)&^(0xffc0)|value<<6)
}
func (o *ADC_Type) GetDR7_V_VREF() uint32 {
	return (volatile.LoadUint32(&o.DR7.Reg) & 0xffc0) >> 6
}
func (o *ADC_Type) SetDR7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DR7.Reg, volatile.LoadUint32(&o.DR7.Reg)&^(0x3fff0000)|value<<16)
}
func (o *ADC_Type) GetDR7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DR7.Reg) & 0x3fff0000) >> 16
}
func (o *ADC_Type) SetDR7_OVERRUN(value uint32) {
	volatile.StoreUint32(&o.DR7.Reg, volatile.LoadUint32(&o.DR7.Reg)&^(0x40000000)|value<<30)
}
func (o *ADC_Type) GetDR7_OVERRUN() uint32 {
	return (volatile.LoadUint32(&o.DR7.Reg) & 0x40000000) >> 30
}
func (o *ADC_Type) SetDR7_DONE(value uint32) {
	volatile.StoreUint32(&o.DR7.Reg, volatile.LoadUint32(&o.DR7.Reg)&^(0x80000000)|value<<31)
}
func (o *ADC_Type) GetDR7_DONE() uint32 {
	return (volatile.LoadUint32(&o.DR7.Reg) & 0x80000000) >> 31
}

// ADC.STAT: A/D Status Register. This register contains DONE and OVERRUN flags for all of the A/D channels, as well as the A/D interrupt flag.
func (o *ADC_Type) SetSTAT_DONE(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0xff)|value)
}
func (o *ADC_Type) GetSTAT_DONE() uint32 {
	return volatile.LoadUint32(&o.STAT.Reg) & 0xff
}
func (o *ADC_Type) SetSTAT_OVERRUN(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0xff00)|value<<8)
}
func (o *ADC_Type) GetSTAT_OVERRUN() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0xff00) >> 8
}
func (o *ADC_Type) SetSTAT_ADINT(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0x10000)|value<<16)
}
func (o *ADC_Type) GetSTAT_ADINT() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0x10000) >> 16
}
func (o *ADC_Type) SetSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STAT.Reg, volatile.LoadUint32(&o.STAT.Reg)&^(0xfffe0000)|value<<17)
}
func (o *ADC_Type) GetSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STAT.Reg) & 0xfffe0000) >> 17
}

// power management unit
type PMU_Type struct {
	PCON   volatile.Register32 // 0x0
	GPREG0 volatile.Register32 // 0x4
	GPREG1 volatile.Register32 // 0x8
	GPREG2 volatile.Register32 // 0xC
	GPREG3 volatile.Register32 // 0x10
	GPREG4 volatile.Register32 // 0x14
}

// PMU.PCON: Power control register
func (o *PMU_Type) SetPCON_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PCON.Reg, volatile.LoadUint32(&o.PCON.Reg)&^(0x1)|value)
}
func (o *PMU_Type) GetPCON_RESERVED() uint32 {
	return volatile.LoadUint32(&o.PCON.Reg) & 0x1
}
func (o *PMU_Type) SetPCON_DPDEN(value uint32) {
	volatile.StoreUint32(&o.PCON.Reg, volatile.LoadUint32(&o.PCON.Reg)&^(0x2)|value<<1)
}
func (o *PMU_Type) GetPCON_DPDEN() uint32 {
	return (volatile.LoadUint32(&o.PCON.Reg) & 0x2) >> 1
}
func (o *PMU_Type) SetPCON_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PCON.Reg, volatile.LoadUint32(&o.PCON.Reg)&^(0xfc)|value<<2)
}
func (o *PMU_Type) GetPCON_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PCON.Reg) & 0xfc) >> 2
}
func (o *PMU_Type) SetPCON_SLEEPFLAG(value uint32) {
	volatile.StoreUint32(&o.PCON.Reg, volatile.LoadUint32(&o.PCON.Reg)&^(0x100)|value<<8)
}
func (o *PMU_Type) GetPCON_SLEEPFLAG() uint32 {
	return (volatile.LoadUint32(&o.PCON.Reg) & 0x100) >> 8
}
func (o *PMU_Type) SetPCON_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PCON.Reg, volatile.LoadUint32(&o.PCON.Reg)&^(0x600)|value<<9)
}
func (o *PMU_Type) GetPCON_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PCON.Reg) & 0x600) >> 9
}
func (o *PMU_Type) SetPCON_DPDFLAG(value uint32) {
	volatile.StoreUint32(&o.PCON.Reg, volatile.LoadUint32(&o.PCON.Reg)&^(0x800)|value<<11)
}
func (o *PMU_Type) GetPCON_DPDFLAG() uint32 {
	return (volatile.LoadUint32(&o.PCON.Reg) & 0x800) >> 11
}
func (o *PMU_Type) SetPCON_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PCON.Reg, volatile.LoadUint32(&o.PCON.Reg)&^(0xfffff000)|value<<12)
}
func (o *PMU_Type) GetPCON_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PCON.Reg) & 0xfffff000) >> 12
}

// PMU.GPREG0: General purpose register
func (o *PMU_Type) SetGPREG0(value uint32) {
	volatile.StoreUint32(&o.GPREG0.Reg, value)
}
func (o *PMU_Type) GetGPREG0() uint32 {
	return volatile.LoadUint32(&o.GPREG0.Reg)
}

// PMU.GPREG1: General purpose register
func (o *PMU_Type) SetGPREG1(value uint32) {
	volatile.StoreUint32(&o.GPREG1.Reg, value)
}
func (o *PMU_Type) GetGPREG1() uint32 {
	return volatile.LoadUint32(&o.GPREG1.Reg)
}

// PMU.GPREG2: General purpose register
func (o *PMU_Type) SetGPREG2(value uint32) {
	volatile.StoreUint32(&o.GPREG2.Reg, value)
}
func (o *PMU_Type) GetGPREG2() uint32 {
	return volatile.LoadUint32(&o.GPREG2.Reg)
}

// PMU.GPREG3: General purpose register
func (o *PMU_Type) SetGPREG3(value uint32) {
	volatile.StoreUint32(&o.GPREG3.Reg, value)
}
func (o *PMU_Type) GetGPREG3() uint32 {
	return volatile.LoadUint32(&o.GPREG3.Reg)
}

// PMU.GPREG4: General purpose register 4
func (o *PMU_Type) SetGPREG4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.GPREG4.Reg, volatile.LoadUint32(&o.GPREG4.Reg)&^(0x3ff)|value)
}
func (o *PMU_Type) GetGPREG4_RESERVED() uint32 {
	return volatile.LoadUint32(&o.GPREG4.Reg) & 0x3ff
}
func (o *PMU_Type) SetGPREG4_WAKEUPHYS(value uint32) {
	volatile.StoreUint32(&o.GPREG4.Reg, volatile.LoadUint32(&o.GPREG4.Reg)&^(0x400)|value<<10)
}
func (o *PMU_Type) GetGPREG4_WAKEUPHYS() uint32 {
	return (volatile.LoadUint32(&o.GPREG4.Reg) & 0x400) >> 10
}
func (o *PMU_Type) SetGPREG4_GPDATA(value uint32) {
	volatile.StoreUint32(&o.GPREG4.Reg, volatile.LoadUint32(&o.GPREG4.Reg)&^(0xfffff800)|value<<11)
}
func (o *PMU_Type) GetGPREG4_GPDATA() uint32 {
	return (volatile.LoadUint32(&o.GPREG4.Reg) & 0xfffff800) >> 11
}

// Product name title=UM10462 Chapter title=LPC11U1x Flash programming firmware Modification date=3/17/2011 Major revision=0 Minor revision=3
type FLASHCTRL_Type struct {
	_         [16]byte
	FLASHCFG  volatile.Register32 // 0x10
	_         [12]byte
	FMSSTART  volatile.Register32 // 0x20
	FMSSTOP   volatile.Register32 // 0x24
	_         [4]byte
	FMSW0     volatile.Register32 // 0x2C
	FMSW1     volatile.Register32 // 0x30
	FMSW2     volatile.Register32 // 0x34
	FMSW3     volatile.Register32 // 0x38
	_         [4004]byte
	FMSTAT    volatile.Register32 // 0xFE0
	_         [4]byte
	FMSTATCLR volatile.Register32 // 0xFE8
}

// FLASHCTRL.FLASHCFG: Flash memory access time configuration register
func (o *FLASHCTRL_Type) SetFLASHCFG_FLASHTIM(value uint32) {
	volatile.StoreUint32(&o.FLASHCFG.Reg, volatile.LoadUint32(&o.FLASHCFG.Reg)&^(0x3)|value)
}
func (o *FLASHCTRL_Type) GetFLASHCFG_FLASHTIM() uint32 {
	return volatile.LoadUint32(&o.FLASHCFG.Reg) & 0x3
}
func (o *FLASHCTRL_Type) SetFLASHCFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FLASHCFG.Reg, volatile.LoadUint32(&o.FLASHCFG.Reg)&^(0xfffffffc)|value<<2)
}
func (o *FLASHCTRL_Type) GetFLASHCFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FLASHCFG.Reg) & 0xfffffffc) >> 2
}

// FLASHCTRL.FMSSTART: Signature start address register
func (o *FLASHCTRL_Type) SetFMSSTART_START(value uint32) {
	volatile.StoreUint32(&o.FMSSTART.Reg, volatile.LoadUint32(&o.FMSSTART.Reg)&^(0x1ffff)|value)
}
func (o *FLASHCTRL_Type) GetFMSSTART_START() uint32 {
	return volatile.LoadUint32(&o.FMSSTART.Reg) & 0x1ffff
}
func (o *FLASHCTRL_Type) SetFMSSTART_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FMSSTART.Reg, volatile.LoadUint32(&o.FMSSTART.Reg)&^(0xfffe0000)|value<<17)
}
func (o *FLASHCTRL_Type) GetFMSSTART_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FMSSTART.Reg) & 0xfffe0000) >> 17
}

// FLASHCTRL.FMSSTOP: Signature stop-address register
func (o *FLASHCTRL_Type) SetFMSSTOP_STOP(value uint32) {
	volatile.StoreUint32(&o.FMSSTOP.Reg, volatile.LoadUint32(&o.FMSSTOP.Reg)&^(0x1ffff)|value)
}
func (o *FLASHCTRL_Type) GetFMSSTOP_STOP() uint32 {
	return volatile.LoadUint32(&o.FMSSTOP.Reg) & 0x1ffff
}
func (o *FLASHCTRL_Type) SetFMSSTOP_SIG_START(value uint32) {
	volatile.StoreUint32(&o.FMSSTOP.Reg, volatile.LoadUint32(&o.FMSSTOP.Reg)&^(0x20000)|value<<17)
}
func (o *FLASHCTRL_Type) GetFMSSTOP_SIG_START() uint32 {
	return (volatile.LoadUint32(&o.FMSSTOP.Reg) & 0x20000) >> 17
}
func (o *FLASHCTRL_Type) SetFMSSTOP_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FMSSTOP.Reg, volatile.LoadUint32(&o.FMSSTOP.Reg)&^(0xfffc0000)|value<<18)
}
func (o *FLASHCTRL_Type) GetFMSSTOP_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FMSSTOP.Reg) & 0xfffc0000) >> 18
}

// FLASHCTRL.FMSW0: Word 0 [31:0]
func (o *FLASHCTRL_Type) SetFMSW0(value uint32) {
	volatile.StoreUint32(&o.FMSW0.Reg, value)
}
func (o *FLASHCTRL_Type) GetFMSW0() uint32 {
	return volatile.LoadUint32(&o.FMSW0.Reg)
}

// FLASHCTRL.FMSW1: Word 1 [63:32]
func (o *FLASHCTRL_Type) SetFMSW1(value uint32) {
	volatile.StoreUint32(&o.FMSW1.Reg, value)
}
func (o *FLASHCTRL_Type) GetFMSW1() uint32 {
	return volatile.LoadUint32(&o.FMSW1.Reg)
}

// FLASHCTRL.FMSW2: Word 2 [95:64]
func (o *FLASHCTRL_Type) SetFMSW2(value uint32) {
	volatile.StoreUint32(&o.FMSW2.Reg, value)
}
func (o *FLASHCTRL_Type) GetFMSW2() uint32 {
	return volatile.LoadUint32(&o.FMSW2.Reg)
}

// FLASHCTRL.FMSW3: Word 3 [127:96]
func (o *FLASHCTRL_Type) SetFMSW3(value uint32) {
	volatile.StoreUint32(&o.FMSW3.Reg, value)
}
func (o *FLASHCTRL_Type) GetFMSW3() uint32 {
	return volatile.LoadUint32(&o.FMSW3.Reg)
}

// FLASHCTRL.FMSTAT: Signature generation status register
func (o *FLASHCTRL_Type) SetFMSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FMSTAT.Reg, volatile.LoadUint32(&o.FMSTAT.Reg)&^(0x3)|value)
}
func (o *FLASHCTRL_Type) GetFMSTAT_RESERVED() uint32 {
	return volatile.LoadUint32(&o.FMSTAT.Reg) & 0x3
}
func (o *FLASHCTRL_Type) SetFMSTAT_SIG_DONE(value uint32) {
	volatile.StoreUint32(&o.FMSTAT.Reg, volatile.LoadUint32(&o.FMSTAT.Reg)&^(0x4)|value<<2)
}
func (o *FLASHCTRL_Type) GetFMSTAT_SIG_DONE() uint32 {
	return (volatile.LoadUint32(&o.FMSTAT.Reg) & 0x4) >> 2
}
func (o *FLASHCTRL_Type) SetFMSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FMSTAT.Reg, volatile.LoadUint32(&o.FMSTAT.Reg)&^(0xfffffff8)|value<<3)
}
func (o *FLASHCTRL_Type) GetFMSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FMSTAT.Reg) & 0xfffffff8) >> 3
}

// FLASHCTRL.FMSTATCLR: Signature generation status clear register
func (o *FLASHCTRL_Type) SetFMSTATCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FMSTATCLR.Reg, volatile.LoadUint32(&o.FMSTATCLR.Reg)&^(0x3)|value)
}
func (o *FLASHCTRL_Type) GetFMSTATCLR_RESERVED() uint32 {
	return volatile.LoadUint32(&o.FMSTATCLR.Reg) & 0x3
}
func (o *FLASHCTRL_Type) SetFMSTATCLR_SIG_DONE_CLR(value uint32) {
	volatile.StoreUint32(&o.FMSTATCLR.Reg, volatile.LoadUint32(&o.FMSTATCLR.Reg)&^(0x4)|value<<2)
}
func (o *FLASHCTRL_Type) GetFMSTATCLR_SIG_DONE_CLR() uint32 {
	return (volatile.LoadUint32(&o.FMSTATCLR.Reg) & 0x4) >> 2
}
func (o *FLASHCTRL_Type) SetFMSTATCLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.FMSTATCLR.Reg, volatile.LoadUint32(&o.FMSTATCLR.Reg)&^(0xfffffff8)|value<<3)
}
func (o *FLASHCTRL_Type) GetFMSTATCLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.FMSTATCLR.Reg) & 0xfffffff8) >> 3
}

// SPI0
type SPI_Type struct {
	CR0  volatile.Register32 // 0x0
	CR1  volatile.Register32 // 0x4
	DR   volatile.Register32 // 0x8
	SR   volatile.Register32 // 0xC
	CPSR volatile.Register32 // 0x10
	IMSC volatile.Register32 // 0x14
	RIS  volatile.Register32 // 0x18
	MIS  volatile.Register32 // 0x1C
	ICR  volatile.Register32 // 0x20
}

// SPI.CR0: Control Register 0. Selects the serial clock rate, bus type, and data size.
func (o *SPI_Type) SetCR0_DSS(value uint32) {
	volatile.StoreUint32(&o.CR0.Reg, volatile.LoadUint32(&o.CR0.Reg)&^(0xf)|value)
}
func (o *SPI_Type) GetCR0_DSS() uint32 {
	return volatile.LoadUint32(&o.CR0.Reg) & 0xf
}
func (o *SPI_Type) SetCR0_FRF(value uint32) {
	volatile.StoreUint32(&o.CR0.Reg, volatile.LoadUint32(&o.CR0.Reg)&^(0x30)|value<<4)
}
func (o *SPI_Type) GetCR0_FRF() uint32 {
	return (volatile.LoadUint32(&o.CR0.Reg) & 0x30) >> 4
}
func (o *SPI_Type) SetCR0_CPOL(value uint32) {
	volatile.StoreUint32(&o.CR0.Reg, volatile.LoadUint32(&o.CR0.Reg)&^(0x40)|value<<6)
}
func (o *SPI_Type) GetCR0_CPOL() uint32 {
	return (volatile.LoadUint32(&o.CR0.Reg) & 0x40) >> 6
}
func (o *SPI_Type) SetCR0_CPHA(value uint32) {
	volatile.StoreUint32(&o.CR0.Reg, volatile.LoadUint32(&o.CR0.Reg)&^(0x80)|value<<7)
}
func (o *SPI_Type) GetCR0_CPHA() uint32 {
	return (volatile.LoadUint32(&o.CR0.Reg) & 0x80) >> 7
}
func (o *SPI_Type) SetCR0_SCR(value uint32) {
	volatile.StoreUint32(&o.CR0.Reg, volatile.LoadUint32(&o.CR0.Reg)&^(0xff00)|value<<8)
}
func (o *SPI_Type) GetCR0_SCR() uint32 {
	return (volatile.LoadUint32(&o.CR0.Reg) & 0xff00) >> 8
}
func (o *SPI_Type) SetCR0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CR0.Reg, volatile.LoadUint32(&o.CR0.Reg)&^(0xffff0000)|value<<16)
}
func (o *SPI_Type) GetCR0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CR0.Reg) & 0xffff0000) >> 16
}

// SPI.CR1: Control Register 1. Selects master/slave and other modes.
func (o *SPI_Type) SetCR1_LBM(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetCR1_LBM() uint32 {
	return volatile.LoadUint32(&o.CR1.Reg) & 0x1
}
func (o *SPI_Type) SetCR1_SSE(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetCR1_SSE() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetCR1_MS(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetCR1_MS() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetCR1_SOD(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetCR1_SOD() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetCR1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CR1.Reg, volatile.LoadUint32(&o.CR1.Reg)&^(0xfffffff0)|value<<4)
}
func (o *SPI_Type) GetCR1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CR1.Reg) & 0xfffffff0) >> 4
}

// SPI.DR: Data Register. Writes fill the transmit FIFO, and reads empty the receive FIFO.
func (o *SPI_Type) SetDR_DATA(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xffff)|value)
}
func (o *SPI_Type) GetDR_DATA() uint32 {
	return volatile.LoadUint32(&o.DR.Reg) & 0xffff
}
func (o *SPI_Type) SetDR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DR.Reg, volatile.LoadUint32(&o.DR.Reg)&^(0xffff0000)|value<<16)
}
func (o *SPI_Type) GetDR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DR.Reg) & 0xffff0000) >> 16
}

// SPI.SR: Status Register
func (o *SPI_Type) SetSR_TFE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetSR_TFE() uint32 {
	return volatile.LoadUint32(&o.SR.Reg) & 0x1
}
func (o *SPI_Type) SetSR_TNF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetSR_TNF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetSR_RNE(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetSR_RNE() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetSR_RFF(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetSR_RFF() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetSR_BSY(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0x10)|value<<4)
}
func (o *SPI_Type) GetSR_BSY() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0x10) >> 4
}
func (o *SPI_Type) SetSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SR.Reg, volatile.LoadUint32(&o.SR.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SPI_Type) GetSR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SR.Reg) & 0xffffffe0) >> 5
}

// SPI.CPSR: Clock Prescale Register
func (o *SPI_Type) SetCPSR_CPSDVSR(value uint32) {
	volatile.StoreUint32(&o.CPSR.Reg, volatile.LoadUint32(&o.CPSR.Reg)&^(0xff)|value)
}
func (o *SPI_Type) GetCPSR_CPSDVSR() uint32 {
	return volatile.LoadUint32(&o.CPSR.Reg) & 0xff
}
func (o *SPI_Type) SetCPSR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CPSR.Reg, volatile.LoadUint32(&o.CPSR.Reg)&^(0xffffff00)|value<<8)
}
func (o *SPI_Type) GetCPSR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CPSR.Reg) & 0xffffff00) >> 8
}

// SPI.IMSC: Interrupt Mask Set and Clear Register
func (o *SPI_Type) SetIMSC_RORIM(value uint32) {
	volatile.StoreUint32(&o.IMSC.Reg, volatile.LoadUint32(&o.IMSC.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetIMSC_RORIM() uint32 {
	return volatile.LoadUint32(&o.IMSC.Reg) & 0x1
}
func (o *SPI_Type) SetIMSC_RTIM(value uint32) {
	volatile.StoreUint32(&o.IMSC.Reg, volatile.LoadUint32(&o.IMSC.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetIMSC_RTIM() uint32 {
	return (volatile.LoadUint32(&o.IMSC.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetIMSC_RXIM(value uint32) {
	volatile.StoreUint32(&o.IMSC.Reg, volatile.LoadUint32(&o.IMSC.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetIMSC_RXIM() uint32 {
	return (volatile.LoadUint32(&o.IMSC.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetIMSC_TXIM(value uint32) {
	volatile.StoreUint32(&o.IMSC.Reg, volatile.LoadUint32(&o.IMSC.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetIMSC_TXIM() uint32 {
	return (volatile.LoadUint32(&o.IMSC.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetIMSC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IMSC.Reg, volatile.LoadUint32(&o.IMSC.Reg)&^(0xfffffff0)|value<<4)
}
func (o *SPI_Type) GetIMSC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IMSC.Reg) & 0xfffffff0) >> 4
}

// SPI.RIS: Raw Interrupt Status Register
func (o *SPI_Type) SetRIS_RORRIS(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetRIS_RORRIS() uint32 {
	return volatile.LoadUint32(&o.RIS.Reg) & 0x1
}
func (o *SPI_Type) SetRIS_RTRIS(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetRIS_RTRIS() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetRIS_RXRIS(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetRIS_RXRIS() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetRIS_TXRIS(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetRIS_TXRIS() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetRIS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0xfffffff0)|value<<4)
}
func (o *SPI_Type) GetRIS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0xfffffff0) >> 4
}

// SPI.MIS: Masked Interrupt Status Register
func (o *SPI_Type) SetMIS_RORMIS(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetMIS_RORMIS() uint32 {
	return volatile.LoadUint32(&o.MIS.Reg) & 0x1
}
func (o *SPI_Type) SetMIS_RTMIS(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetMIS_RTMIS() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetMIS_RXMIS(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x4)|value<<2)
}
func (o *SPI_Type) GetMIS_RXMIS() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x4) >> 2
}
func (o *SPI_Type) SetMIS_TXMIS(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x8)|value<<3)
}
func (o *SPI_Type) GetMIS_TXMIS() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x8) >> 3
}
func (o *SPI_Type) SetMIS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0xfffffff0)|value<<4)
}
func (o *SPI_Type) GetMIS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0xfffffff0) >> 4
}

// SPI.ICR: SSPICR Interrupt Clear Register
func (o *SPI_Type) SetICR_RORIC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x1)|value)
}
func (o *SPI_Type) GetICR_RORIC() uint32 {
	return volatile.LoadUint32(&o.ICR.Reg) & 0x1
}
func (o *SPI_Type) SetICR_RTIC(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0x2)|value<<1)
}
func (o *SPI_Type) GetICR_RTIC() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0x2) >> 1
}
func (o *SPI_Type) SetICR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.ICR.Reg, volatile.LoadUint32(&o.ICR.Reg)&^(0xfffffffc)|value<<2)
}
func (o *SPI_Type) GetICR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.ICR.Reg) & 0xfffffffc) >> 2
}

// Product name title=UM10398 Chapter title=LPC1100XL series: I/O configuration (IOCONFIG) Modification date=2/22/2012 Major revision=8 Minor revision=not available
type IOCON_Type struct {
	IOCON_PIO2_6          volatile.Register32 // 0x0
	_                     [4]byte
	IOCON_PIO2_0          volatile.Register32 // 0x8
	IOCON_RESET_PIO0_0    volatile.Register32 // 0xC
	IOCON_PIO0_1          volatile.Register32 // 0x10
	IOCON_PIO1_8          volatile.Register32 // 0x14
	IOCON_SSEL1_LOC       volatile.Register32 // 0x18
	IOCON_PIO0_2          volatile.Register32 // 0x1C
	IOCON_PIO2_7          volatile.Register32 // 0x20
	IOCON_PIO2_8          volatile.Register32 // 0x24
	IOCON_PIO2_1          volatile.Register32 // 0x28
	IOCON_PIO0_3          volatile.Register32 // 0x2C
	IOCON_PIO0_4          volatile.Register32 // 0x30
	IOCON_PIO0_5          volatile.Register32 // 0x34
	IOCON_PIO1_9          volatile.Register32 // 0x38
	IOCON_PIO3_4          volatile.Register32 // 0x3C
	IOCON_PIO2_4          volatile.Register32 // 0x40
	IOCON_PIO2_5          volatile.Register32 // 0x44
	IOCON_PIO3_5          volatile.Register32 // 0x48
	IOCON_PIO0_6          volatile.Register32 // 0x4C
	IOCON_PIO0_7          volatile.Register32 // 0x50
	IOCON_PIO2_9          volatile.Register32 // 0x54
	IOCON_PIO2_10         volatile.Register32 // 0x58
	IOCON_PIO2_2          volatile.Register32 // 0x5C
	IOCON_PIO0_8          volatile.Register32 // 0x60
	IOCON_PIO0_9          volatile.Register32 // 0x64
	IOCON_SWCLK_PIO0_10   volatile.Register32 // 0x68
	IOCON_PIO1_10         volatile.Register32 // 0x6C
	IOCON_PIO2_11         volatile.Register32 // 0x70
	IOCON_R_PIO0_11       volatile.Register32 // 0x74
	IOCON_R_PIO1_0        volatile.Register32 // 0x78
	IOCON_R_PIO1_1        volatile.Register32 // 0x7C
	IOCON_R_PIO1_2        volatile.Register32 // 0x80
	IOCON_PIO3_0          volatile.Register32 // 0x84
	IOCON_PIO3_1          volatile.Register32 // 0x88
	IOCON_PIO2_3          volatile.Register32 // 0x8C
	IOCON_SWDIO_PIO1_3    volatile.Register32 // 0x90
	IOCON_PIO1_4          volatile.Register32 // 0x94
	IOCON_PIO1_11         volatile.Register32 // 0x98
	IOCON_PIO3_2          volatile.Register32 // 0x9C
	IOCON_PIO1_5          volatile.Register32 // 0xA0
	IOCON_PIO1_6          volatile.Register32 // 0xA4
	IOCON_PIO1_7          volatile.Register32 // 0xA8
	IOCON_PIO3_3          volatile.Register32 // 0xAC
	IOCON_SCK0_LOC        volatile.Register32 // 0xB0
	IOCON_DSR_LOC         volatile.Register32 // 0xB4
	IOCON_DCD_LOC         volatile.Register32 // 0xB8
	IOCON_RI_LOC          volatile.Register32 // 0xBC
	IOCON_CT16B0_CAP0_LOC volatile.Register32 // 0xC0
	IOCON_SCK1_LOC        volatile.Register32 // 0xC4
	IOCON_MISO1_LOC       volatile.Register32 // 0xC8
	IOCON_MOSI1_LOC       volatile.Register32 // 0xCC
	IOCON_CT32B0_CAP0_LOC volatile.Register32 // 0xD0
	IOCON_RXD_LOC         volatile.Register32 // 0xD4
}

// IOCON.IOCON_PIO2_6: I/O configuration for pin PIO2_6/ CT32B0_MAT1
func (o *IOCON_Type) SetIOCON_PIO2_6_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_6.Reg, volatile.LoadUint32(&o.IOCON_PIO2_6.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO2_6_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO2_6.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO2_6_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_6.Reg, volatile.LoadUint32(&o.IOCON_PIO2_6.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO2_6_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_6.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO2_6_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_6.Reg, volatile.LoadUint32(&o.IOCON_PIO2_6.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO2_6_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_6.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO2_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_6.Reg, volatile.LoadUint32(&o.IOCON_PIO2_6.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO2_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_6.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO2_6_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_6.Reg, volatile.LoadUint32(&o.IOCON_PIO2_6.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO2_6_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_6.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO2_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_6.Reg, volatile.LoadUint32(&o.IOCON_PIO2_6.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO2_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_6.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO2_0: I/O configuration for pin PIO2_0/DTR/SSEL1
func (o *IOCON_Type) SetIOCON_PIO2_0_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_0.Reg, volatile.LoadUint32(&o.IOCON_PIO2_0.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO2_0_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO2_0.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO2_0_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_0.Reg, volatile.LoadUint32(&o.IOCON_PIO2_0.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO2_0_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_0.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO2_0_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_0.Reg, volatile.LoadUint32(&o.IOCON_PIO2_0.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO2_0_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_0.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO2_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_0.Reg, volatile.LoadUint32(&o.IOCON_PIO2_0.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO2_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_0.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO2_0_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_0.Reg, volatile.LoadUint32(&o.IOCON_PIO2_0.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO2_0_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_0.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO2_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_0.Reg, volatile.LoadUint32(&o.IOCON_PIO2_0.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO2_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_0.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_RESET_PIO0_0: I/O configuration for pin RESET/PIO0_0
func (o *IOCON_Type) SetIOCON_RESET_PIO0_0_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_RESET_PIO0_0.Reg, volatile.LoadUint32(&o.IOCON_RESET_PIO0_0.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_RESET_PIO0_0_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_RESET_PIO0_0.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_RESET_PIO0_0_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_RESET_PIO0_0.Reg, volatile.LoadUint32(&o.IOCON_RESET_PIO0_0.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_RESET_PIO0_0_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_RESET_PIO0_0.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_RESET_PIO0_0_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_RESET_PIO0_0.Reg, volatile.LoadUint32(&o.IOCON_RESET_PIO0_0.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_RESET_PIO0_0_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_RESET_PIO0_0.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_RESET_PIO0_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_RESET_PIO0_0.Reg, volatile.LoadUint32(&o.IOCON_RESET_PIO0_0.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_RESET_PIO0_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_RESET_PIO0_0.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_RESET_PIO0_0_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_RESET_PIO0_0.Reg, volatile.LoadUint32(&o.IOCON_RESET_PIO0_0.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_RESET_PIO0_0_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_RESET_PIO0_0.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_RESET_PIO0_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_RESET_PIO0_0.Reg, volatile.LoadUint32(&o.IOCON_RESET_PIO0_0.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_RESET_PIO0_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_RESET_PIO0_0.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO0_1: I/O configuration for pin PIO0_1/CLKOUT/CT32B0_MAT2
func (o *IOCON_Type) SetIOCON_PIO0_1_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_1.Reg, volatile.LoadUint32(&o.IOCON_PIO0_1.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO0_1_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO0_1.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO0_1_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_1.Reg, volatile.LoadUint32(&o.IOCON_PIO0_1.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO0_1_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_1.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO0_1_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_1.Reg, volatile.LoadUint32(&o.IOCON_PIO0_1.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO0_1_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_1.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO0_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_1.Reg, volatile.LoadUint32(&o.IOCON_PIO0_1.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO0_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_1.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO0_1_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_1.Reg, volatile.LoadUint32(&o.IOCON_PIO0_1.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO0_1_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_1.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO0_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_1.Reg, volatile.LoadUint32(&o.IOCON_PIO0_1.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO0_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_1.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO1_8: I/O configuration for pin PIO1_8/CT16B1_CAP0
func (o *IOCON_Type) SetIOCON_PIO1_8_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_8.Reg, volatile.LoadUint32(&o.IOCON_PIO1_8.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO1_8_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO1_8.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO1_8_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_8.Reg, volatile.LoadUint32(&o.IOCON_PIO1_8.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO1_8_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_8.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO1_8_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_8.Reg, volatile.LoadUint32(&o.IOCON_PIO1_8.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO1_8_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_8.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO1_8_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_8.Reg, volatile.LoadUint32(&o.IOCON_PIO1_8.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO1_8_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_8.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO1_8_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_8.Reg, volatile.LoadUint32(&o.IOCON_PIO1_8.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO1_8_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_8.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO1_8_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_8.Reg, volatile.LoadUint32(&o.IOCON_PIO1_8.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO1_8_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_8.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_SSEL1_LOC: SSEL1 pin location select register
func (o *IOCON_Type) SetIOCON_SSEL1_LOC_SSEL1LOC(value uint32) {
	volatile.StoreUint32(&o.IOCON_SSEL1_LOC.Reg, volatile.LoadUint32(&o.IOCON_SSEL1_LOC.Reg)&^(0x3)|value)
}
func (o *IOCON_Type) GetIOCON_SSEL1_LOC_SSEL1LOC() uint32 {
	return volatile.LoadUint32(&o.IOCON_SSEL1_LOC.Reg) & 0x3
}
func (o *IOCON_Type) SetIOCON_SSEL1_LOC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_SSEL1_LOC.Reg, volatile.LoadUint32(&o.IOCON_SSEL1_LOC.Reg)&^(0xfffffffc)|value<<2)
}
func (o *IOCON_Type) GetIOCON_SSEL1_LOC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_SSEL1_LOC.Reg) & 0xfffffffc) >> 2
}

// IOCON.IOCON_PIO0_2: I/O configuration for pin PIO0_2/SSEL0/CT16B0_CAP0
func (o *IOCON_Type) SetIOCON_PIO0_2_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_2.Reg, volatile.LoadUint32(&o.IOCON_PIO0_2.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO0_2_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO0_2.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO0_2_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_2.Reg, volatile.LoadUint32(&o.IOCON_PIO0_2.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO0_2_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_2.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO0_2_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_2.Reg, volatile.LoadUint32(&o.IOCON_PIO0_2.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO0_2_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_2.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO0_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_2.Reg, volatile.LoadUint32(&o.IOCON_PIO0_2.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO0_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_2.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO0_2_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_2.Reg, volatile.LoadUint32(&o.IOCON_PIO0_2.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO0_2_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_2.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO0_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_2.Reg, volatile.LoadUint32(&o.IOCON_PIO0_2.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO0_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_2.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO2_7: I/O configuration for pin PIO2_7/ CT32B0_MAT2/RXD
func (o *IOCON_Type) SetIOCON_PIO2_7_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_7.Reg, volatile.LoadUint32(&o.IOCON_PIO2_7.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO2_7_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO2_7.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO2_7_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_7.Reg, volatile.LoadUint32(&o.IOCON_PIO2_7.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO2_7_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_7.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO2_7_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_7.Reg, volatile.LoadUint32(&o.IOCON_PIO2_7.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO2_7_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_7.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO2_7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_7.Reg, volatile.LoadUint32(&o.IOCON_PIO2_7.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO2_7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_7.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO2_7_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_7.Reg, volatile.LoadUint32(&o.IOCON_PIO2_7.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO2_7_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_7.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO2_7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_7.Reg, volatile.LoadUint32(&o.IOCON_PIO2_7.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO2_7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_7.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO2_8: I/O configuration for pin PIO2_8/ CT32B0_MAT3/TXD
func (o *IOCON_Type) SetIOCON_PIO2_8_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_8.Reg, volatile.LoadUint32(&o.IOCON_PIO2_8.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO2_8_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO2_8.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO2_8_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_8.Reg, volatile.LoadUint32(&o.IOCON_PIO2_8.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO2_8_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_8.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO2_8_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_8.Reg, volatile.LoadUint32(&o.IOCON_PIO2_8.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO2_8_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_8.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO2_8_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_8.Reg, volatile.LoadUint32(&o.IOCON_PIO2_8.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO2_8_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_8.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO2_8_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_8.Reg, volatile.LoadUint32(&o.IOCON_PIO2_8.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO2_8_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_8.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO2_8_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_8.Reg, volatile.LoadUint32(&o.IOCON_PIO2_8.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO2_8_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_8.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO2_1: I/O configuration for pin PIO2_1/DSR/SCK1
func (o *IOCON_Type) SetIOCON_PIO2_1_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_1.Reg, volatile.LoadUint32(&o.IOCON_PIO2_1.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO2_1_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO2_1.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO2_1_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_1.Reg, volatile.LoadUint32(&o.IOCON_PIO2_1.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO2_1_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_1.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO2_1_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_1.Reg, volatile.LoadUint32(&o.IOCON_PIO2_1.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO2_1_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_1.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO2_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_1.Reg, volatile.LoadUint32(&o.IOCON_PIO2_1.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO2_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_1.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO2_1_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_1.Reg, volatile.LoadUint32(&o.IOCON_PIO2_1.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO2_1_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_1.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO2_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_1.Reg, volatile.LoadUint32(&o.IOCON_PIO2_1.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO2_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_1.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO0_3: I/O configuration for pin PIO0_3
func (o *IOCON_Type) SetIOCON_PIO0_3_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_3.Reg, volatile.LoadUint32(&o.IOCON_PIO0_3.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO0_3_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO0_3.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO0_3_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_3.Reg, volatile.LoadUint32(&o.IOCON_PIO0_3.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO0_3_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_3.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO0_3_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_3.Reg, volatile.LoadUint32(&o.IOCON_PIO0_3.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO0_3_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_3.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO0_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_3.Reg, volatile.LoadUint32(&o.IOCON_PIO0_3.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO0_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_3.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO0_3_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_3.Reg, volatile.LoadUint32(&o.IOCON_PIO0_3.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO0_3_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_3.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO0_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_3.Reg, volatile.LoadUint32(&o.IOCON_PIO0_3.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO0_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_3.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO0_4: I/O configuration for pin PIO0_4/SCL
func (o *IOCON_Type) SetIOCON_PIO0_4_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_4.Reg, volatile.LoadUint32(&o.IOCON_PIO0_4.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO0_4_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO0_4.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO0_4_I2CMODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_4.Reg, volatile.LoadUint32(&o.IOCON_PIO0_4.Reg)&^(0x300)|value<<8)
}
func (o *IOCON_Type) GetIOCON_PIO0_4_I2CMODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_4.Reg) & 0x300) >> 8
}
func (o *IOCON_Type) SetIOCON_PIO0_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_4.Reg, volatile.LoadUint32(&o.IOCON_PIO0_4.Reg)&^(0xfffffc00)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO0_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_4.Reg) & 0xfffffc00) >> 10
}

// IOCON.IOCON_PIO0_5: I/O configuration for pin PIO0_5/SDA
func (o *IOCON_Type) SetIOCON_PIO0_5_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_5.Reg, volatile.LoadUint32(&o.IOCON_PIO0_5.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO0_5_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO0_5.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO0_5_I2CMODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_5.Reg, volatile.LoadUint32(&o.IOCON_PIO0_5.Reg)&^(0x300)|value<<8)
}
func (o *IOCON_Type) GetIOCON_PIO0_5_I2CMODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_5.Reg) & 0x300) >> 8
}
func (o *IOCON_Type) SetIOCON_PIO0_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_5.Reg, volatile.LoadUint32(&o.IOCON_PIO0_5.Reg)&^(0xfffffc00)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO0_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_5.Reg) & 0xfffffc00) >> 10
}

// IOCON.IOCON_PIO1_9: I/O configuration for pin PIO1_9/CT16B1_MAT0/ MOSI1
func (o *IOCON_Type) SetIOCON_PIO1_9_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_9.Reg, volatile.LoadUint32(&o.IOCON_PIO1_9.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO1_9_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO1_9.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO1_9_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_9.Reg, volatile.LoadUint32(&o.IOCON_PIO1_9.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO1_9_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_9.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO1_9_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_9.Reg, volatile.LoadUint32(&o.IOCON_PIO1_9.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO1_9_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_9.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO1_9_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_9.Reg, volatile.LoadUint32(&o.IOCON_PIO1_9.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO1_9_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_9.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO1_9_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_9.Reg, volatile.LoadUint32(&o.IOCON_PIO1_9.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO1_9_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_9.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO1_9_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_9.Reg, volatile.LoadUint32(&o.IOCON_PIO1_9.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO1_9_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_9.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO3_4: I/O configuration for pin PIO3_4/ CT16B0_CAP1/RXD
func (o *IOCON_Type) SetIOCON_PIO3_4_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_4.Reg, volatile.LoadUint32(&o.IOCON_PIO3_4.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO3_4_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO3_4.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO3_4_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_4.Reg, volatile.LoadUint32(&o.IOCON_PIO3_4.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO3_4_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_4.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO3_4_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_4.Reg, volatile.LoadUint32(&o.IOCON_PIO3_4.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO3_4_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_4.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO3_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_4.Reg, volatile.LoadUint32(&o.IOCON_PIO3_4.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO3_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_4.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO3_4_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_4.Reg, volatile.LoadUint32(&o.IOCON_PIO3_4.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO3_4_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_4.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO3_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_4.Reg, volatile.LoadUint32(&o.IOCON_PIO3_4.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO3_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_4.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO2_4: I/O configuration for pin PIO2_4/ CT16B1_MAT1/ SSEL1
func (o *IOCON_Type) SetIOCON_PIO2_4_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_4.Reg, volatile.LoadUint32(&o.IOCON_PIO2_4.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO2_4_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO2_4.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO2_4_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_4.Reg, volatile.LoadUint32(&o.IOCON_PIO2_4.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO2_4_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_4.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO2_4_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_4.Reg, volatile.LoadUint32(&o.IOCON_PIO2_4.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO2_4_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_4.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO2_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_4.Reg, volatile.LoadUint32(&o.IOCON_PIO2_4.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO2_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_4.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO2_4_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_4.Reg, volatile.LoadUint32(&o.IOCON_PIO2_4.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO2_4_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_4.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO2_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_4.Reg, volatile.LoadUint32(&o.IOCON_PIO2_4.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO2_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_4.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO2_5: I/O configuration for pin PIO2_5/ CT32B0_MAT0
func (o *IOCON_Type) SetIOCON_PIO2_5_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_5.Reg, volatile.LoadUint32(&o.IOCON_PIO2_5.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO2_5_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO2_5.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO2_5_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_5.Reg, volatile.LoadUint32(&o.IOCON_PIO2_5.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO2_5_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_5.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO2_5_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_5.Reg, volatile.LoadUint32(&o.IOCON_PIO2_5.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO2_5_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_5.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO2_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_5.Reg, volatile.LoadUint32(&o.IOCON_PIO2_5.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO2_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_5.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO2_5_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_5.Reg, volatile.LoadUint32(&o.IOCON_PIO2_5.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO2_5_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_5.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO2_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_5.Reg, volatile.LoadUint32(&o.IOCON_PIO2_5.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO2_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_5.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO3_5: I/O configuration for pin PIO3_5/ CT16B1_CAP1/TXD
func (o *IOCON_Type) SetIOCON_PIO3_5_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_5.Reg, volatile.LoadUint32(&o.IOCON_PIO3_5.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO3_5_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO3_5.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO3_5_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_5.Reg, volatile.LoadUint32(&o.IOCON_PIO3_5.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO3_5_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_5.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO3_5_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_5.Reg, volatile.LoadUint32(&o.IOCON_PIO3_5.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO3_5_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_5.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO3_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_5.Reg, volatile.LoadUint32(&o.IOCON_PIO3_5.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO3_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_5.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO3_5_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_5.Reg, volatile.LoadUint32(&o.IOCON_PIO3_5.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO3_5_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_5.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO3_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_5.Reg, volatile.LoadUint32(&o.IOCON_PIO3_5.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO3_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_5.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO0_6: I/O configuration for pin PIO0_6/SCK0
func (o *IOCON_Type) SetIOCON_PIO0_6_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_6.Reg, volatile.LoadUint32(&o.IOCON_PIO0_6.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO0_6_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO0_6.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO0_6_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_6.Reg, volatile.LoadUint32(&o.IOCON_PIO0_6.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO0_6_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_6.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO0_6_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_6.Reg, volatile.LoadUint32(&o.IOCON_PIO0_6.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO0_6_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_6.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO0_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_6.Reg, volatile.LoadUint32(&o.IOCON_PIO0_6.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO0_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_6.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO0_6_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_6.Reg, volatile.LoadUint32(&o.IOCON_PIO0_6.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO0_6_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_6.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO0_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_6.Reg, volatile.LoadUint32(&o.IOCON_PIO0_6.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO0_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_6.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO0_7: I/O configuration for pin PIO0_7/CTS
func (o *IOCON_Type) SetIOCON_PIO0_7_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_7.Reg, volatile.LoadUint32(&o.IOCON_PIO0_7.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO0_7_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO0_7.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO0_7_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_7.Reg, volatile.LoadUint32(&o.IOCON_PIO0_7.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO0_7_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_7.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO0_7_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_7.Reg, volatile.LoadUint32(&o.IOCON_PIO0_7.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO0_7_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_7.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO0_7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_7.Reg, volatile.LoadUint32(&o.IOCON_PIO0_7.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO0_7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_7.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO0_7_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_7.Reg, volatile.LoadUint32(&o.IOCON_PIO0_7.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO0_7_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_7.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO0_7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_7.Reg, volatile.LoadUint32(&o.IOCON_PIO0_7.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO0_7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_7.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO2_9: I/O configuration for pin PIO2_9/ CT32B0_CAP0
func (o *IOCON_Type) SetIOCON_PIO2_9_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_9.Reg, volatile.LoadUint32(&o.IOCON_PIO2_9.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO2_9_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO2_9.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO2_9_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_9.Reg, volatile.LoadUint32(&o.IOCON_PIO2_9.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO2_9_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_9.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO2_9_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_9.Reg, volatile.LoadUint32(&o.IOCON_PIO2_9.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO2_9_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_9.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO2_9_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_9.Reg, volatile.LoadUint32(&o.IOCON_PIO2_9.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO2_9_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_9.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO2_9_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_9.Reg, volatile.LoadUint32(&o.IOCON_PIO2_9.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO2_9_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_9.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO2_9_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_9.Reg, volatile.LoadUint32(&o.IOCON_PIO2_9.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO2_9_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_9.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO2_10: I/O configuration for pin PIO2_10
func (o *IOCON_Type) SetIOCON_PIO2_10_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_10.Reg, volatile.LoadUint32(&o.IOCON_PIO2_10.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO2_10_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO2_10.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO2_10_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_10.Reg, volatile.LoadUint32(&o.IOCON_PIO2_10.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO2_10_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_10.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO2_10_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_10.Reg, volatile.LoadUint32(&o.IOCON_PIO2_10.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO2_10_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_10.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO2_10_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_10.Reg, volatile.LoadUint32(&o.IOCON_PIO2_10.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO2_10_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_10.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO2_10_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_10.Reg, volatile.LoadUint32(&o.IOCON_PIO2_10.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO2_10_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_10.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO2_10_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_10.Reg, volatile.LoadUint32(&o.IOCON_PIO2_10.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO2_10_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_10.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO2_2: I/O configuration for pin PIO2_2/DCD/MISO1
func (o *IOCON_Type) SetIOCON_PIO2_2_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_2.Reg, volatile.LoadUint32(&o.IOCON_PIO2_2.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO2_2_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO2_2.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO2_2_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_2.Reg, volatile.LoadUint32(&o.IOCON_PIO2_2.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO2_2_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_2.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO2_2_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_2.Reg, volatile.LoadUint32(&o.IOCON_PIO2_2.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO2_2_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_2.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO2_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_2.Reg, volatile.LoadUint32(&o.IOCON_PIO2_2.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO2_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_2.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO2_2_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_2.Reg, volatile.LoadUint32(&o.IOCON_PIO2_2.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO2_2_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_2.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO2_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_2.Reg, volatile.LoadUint32(&o.IOCON_PIO2_2.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO2_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_2.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO0_8: I/O configuration for pin PIO0_8/MISO0/CT16B0_MAT0
func (o *IOCON_Type) SetIOCON_PIO0_8_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_8.Reg, volatile.LoadUint32(&o.IOCON_PIO0_8.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO0_8_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO0_8.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO0_8_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_8.Reg, volatile.LoadUint32(&o.IOCON_PIO0_8.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO0_8_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_8.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO0_8_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_8.Reg, volatile.LoadUint32(&o.IOCON_PIO0_8.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO0_8_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_8.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO0_8_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_8.Reg, volatile.LoadUint32(&o.IOCON_PIO0_8.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO0_8_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_8.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO0_8_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_8.Reg, volatile.LoadUint32(&o.IOCON_PIO0_8.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO0_8_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_8.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO0_8_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_8.Reg, volatile.LoadUint32(&o.IOCON_PIO0_8.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO0_8_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_8.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO0_9: I/O configuration for pin PIO0_9/MOSI0/CT16B0_MAT1
func (o *IOCON_Type) SetIOCON_PIO0_9_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_9.Reg, volatile.LoadUint32(&o.IOCON_PIO0_9.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO0_9_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO0_9.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO0_9_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_9.Reg, volatile.LoadUint32(&o.IOCON_PIO0_9.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO0_9_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_9.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO0_9_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_9.Reg, volatile.LoadUint32(&o.IOCON_PIO0_9.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO0_9_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_9.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO0_9_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_9.Reg, volatile.LoadUint32(&o.IOCON_PIO0_9.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO0_9_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_9.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO0_9_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_9.Reg, volatile.LoadUint32(&o.IOCON_PIO0_9.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO0_9_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_9.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO0_9_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO0_9.Reg, volatile.LoadUint32(&o.IOCON_PIO0_9.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO0_9_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO0_9.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_SWCLK_PIO0_10: I/O configuration for pin SWCLK/PIO0_10/ SCK0/CT16B0_MAT2
func (o *IOCON_Type) SetIOCON_SWCLK_PIO0_10_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_SWCLK_PIO0_10.Reg, volatile.LoadUint32(&o.IOCON_SWCLK_PIO0_10.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_SWCLK_PIO0_10_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_SWCLK_PIO0_10.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_SWCLK_PIO0_10_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_SWCLK_PIO0_10.Reg, volatile.LoadUint32(&o.IOCON_SWCLK_PIO0_10.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_SWCLK_PIO0_10_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_SWCLK_PIO0_10.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_SWCLK_PIO0_10_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_SWCLK_PIO0_10.Reg, volatile.LoadUint32(&o.IOCON_SWCLK_PIO0_10.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_SWCLK_PIO0_10_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_SWCLK_PIO0_10.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_SWCLK_PIO0_10_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_SWCLK_PIO0_10.Reg, volatile.LoadUint32(&o.IOCON_SWCLK_PIO0_10.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_SWCLK_PIO0_10_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_SWCLK_PIO0_10.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_SWCLK_PIO0_10_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_SWCLK_PIO0_10.Reg, volatile.LoadUint32(&o.IOCON_SWCLK_PIO0_10.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_SWCLK_PIO0_10_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_SWCLK_PIO0_10.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_SWCLK_PIO0_10_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_SWCLK_PIO0_10.Reg, volatile.LoadUint32(&o.IOCON_SWCLK_PIO0_10.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_SWCLK_PIO0_10_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_SWCLK_PIO0_10.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO1_10: I/O configuration for pin PIO1_10/AD6/CT16B1_MAT1/ MISO1
func (o *IOCON_Type) SetIOCON_PIO1_10_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_10.Reg, volatile.LoadUint32(&o.IOCON_PIO1_10.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO1_10_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO1_10.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO1_10_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_10.Reg, volatile.LoadUint32(&o.IOCON_PIO1_10.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO1_10_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_10.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO1_10_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_10.Reg, volatile.LoadUint32(&o.IOCON_PIO1_10.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO1_10_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_10.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO1_10_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_10.Reg, volatile.LoadUint32(&o.IOCON_PIO1_10.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO1_10_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_10.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO1_10_ADMODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_10.Reg, volatile.LoadUint32(&o.IOCON_PIO1_10.Reg)&^(0x80)|value<<7)
}
func (o *IOCON_Type) GetIOCON_PIO1_10_ADMODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_10.Reg) & 0x80) >> 7
}
func (o *IOCON_Type) SetIOCON_PIO1_10_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_10.Reg, volatile.LoadUint32(&o.IOCON_PIO1_10.Reg)&^(0x300)|value<<8)
}
func (o *IOCON_Type) GetIOCON_PIO1_10_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_10.Reg) & 0x300) >> 8
}
func (o *IOCON_Type) SetIOCON_PIO1_10_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_10.Reg, volatile.LoadUint32(&o.IOCON_PIO1_10.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO1_10_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_10.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO1_10_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_10.Reg, volatile.LoadUint32(&o.IOCON_PIO1_10.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO1_10_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_10.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO2_11: I/O configuration for pin PIO2_11/SCK0/ CT32B0_CAP1
func (o *IOCON_Type) SetIOCON_PIO2_11_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_11.Reg, volatile.LoadUint32(&o.IOCON_PIO2_11.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO2_11_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO2_11.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO2_11_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_11.Reg, volatile.LoadUint32(&o.IOCON_PIO2_11.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO2_11_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_11.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO2_11_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_11.Reg, volatile.LoadUint32(&o.IOCON_PIO2_11.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO2_11_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_11.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO2_11_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_11.Reg, volatile.LoadUint32(&o.IOCON_PIO2_11.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO2_11_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_11.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO2_11_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_11.Reg, volatile.LoadUint32(&o.IOCON_PIO2_11.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO2_11_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_11.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO2_11_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_11.Reg, volatile.LoadUint32(&o.IOCON_PIO2_11.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO2_11_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_11.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_R_PIO0_11: I/O configuration for pin R/PIO0_11/AD0/CT32B0_MAT3
func (o *IOCON_Type) SetIOCON_R_PIO0_11_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO0_11.Reg, volatile.LoadUint32(&o.IOCON_R_PIO0_11.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_R_PIO0_11_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_R_PIO0_11.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_R_PIO0_11_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO0_11.Reg, volatile.LoadUint32(&o.IOCON_R_PIO0_11.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_R_PIO0_11_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_R_PIO0_11.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_R_PIO0_11_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO0_11.Reg, volatile.LoadUint32(&o.IOCON_R_PIO0_11.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_R_PIO0_11_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_R_PIO0_11.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_R_PIO0_11_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO0_11.Reg, volatile.LoadUint32(&o.IOCON_R_PIO0_11.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetIOCON_R_PIO0_11_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_R_PIO0_11.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetIOCON_R_PIO0_11_ADMODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO0_11.Reg, volatile.LoadUint32(&o.IOCON_R_PIO0_11.Reg)&^(0x80)|value<<7)
}
func (o *IOCON_Type) GetIOCON_R_PIO0_11_ADMODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_R_PIO0_11.Reg) & 0x80) >> 7
}
func (o *IOCON_Type) SetIOCON_R_PIO0_11_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO0_11.Reg, volatile.LoadUint32(&o.IOCON_R_PIO0_11.Reg)&^(0x300)|value<<8)
}
func (o *IOCON_Type) GetIOCON_R_PIO0_11_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_R_PIO0_11.Reg) & 0x300) >> 8
}
func (o *IOCON_Type) SetIOCON_R_PIO0_11_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO0_11.Reg, volatile.LoadUint32(&o.IOCON_R_PIO0_11.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_R_PIO0_11_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_R_PIO0_11.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_R_PIO0_11_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO0_11.Reg, volatile.LoadUint32(&o.IOCON_R_PIO0_11.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_R_PIO0_11_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_R_PIO0_11.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_R_PIO1_0: I/O configuration for pin R/PIO1_0/AD1/CT32B1_CAP0
func (o *IOCON_Type) SetIOCON_R_PIO1_0_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO1_0.Reg, volatile.LoadUint32(&o.IOCON_R_PIO1_0.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_R_PIO1_0_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_R_PIO1_0.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_R_PIO1_0_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO1_0.Reg, volatile.LoadUint32(&o.IOCON_R_PIO1_0.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_R_PIO1_0_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_R_PIO1_0.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_R_PIO1_0_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO1_0.Reg, volatile.LoadUint32(&o.IOCON_R_PIO1_0.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_R_PIO1_0_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_R_PIO1_0.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_R_PIO1_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO1_0.Reg, volatile.LoadUint32(&o.IOCON_R_PIO1_0.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetIOCON_R_PIO1_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_R_PIO1_0.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetIOCON_R_PIO1_0_ADMODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO1_0.Reg, volatile.LoadUint32(&o.IOCON_R_PIO1_0.Reg)&^(0x80)|value<<7)
}
func (o *IOCON_Type) GetIOCON_R_PIO1_0_ADMODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_R_PIO1_0.Reg) & 0x80) >> 7
}
func (o *IOCON_Type) SetIOCON_R_PIO1_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO1_0.Reg, volatile.LoadUint32(&o.IOCON_R_PIO1_0.Reg)&^(0x300)|value<<8)
}
func (o *IOCON_Type) GetIOCON_R_PIO1_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_R_PIO1_0.Reg) & 0x300) >> 8
}
func (o *IOCON_Type) SetIOCON_R_PIO1_0_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO1_0.Reg, volatile.LoadUint32(&o.IOCON_R_PIO1_0.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_R_PIO1_0_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_R_PIO1_0.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_R_PIO1_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO1_0.Reg, volatile.LoadUint32(&o.IOCON_R_PIO1_0.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_R_PIO1_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_R_PIO1_0.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_R_PIO1_1: I/O configuration for pin R/PIO1_1/AD2/CT32B1_MAT0
func (o *IOCON_Type) SetIOCON_R_PIO1_1_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO1_1.Reg, volatile.LoadUint32(&o.IOCON_R_PIO1_1.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_R_PIO1_1_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_R_PIO1_1.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_R_PIO1_1_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO1_1.Reg, volatile.LoadUint32(&o.IOCON_R_PIO1_1.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_R_PIO1_1_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_R_PIO1_1.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_R_PIO1_1_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO1_1.Reg, volatile.LoadUint32(&o.IOCON_R_PIO1_1.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_R_PIO1_1_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_R_PIO1_1.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_R_PIO1_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO1_1.Reg, volatile.LoadUint32(&o.IOCON_R_PIO1_1.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetIOCON_R_PIO1_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_R_PIO1_1.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetIOCON_R_PIO1_1_ADMODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO1_1.Reg, volatile.LoadUint32(&o.IOCON_R_PIO1_1.Reg)&^(0x80)|value<<7)
}
func (o *IOCON_Type) GetIOCON_R_PIO1_1_ADMODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_R_PIO1_1.Reg) & 0x80) >> 7
}
func (o *IOCON_Type) SetIOCON_R_PIO1_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO1_1.Reg, volatile.LoadUint32(&o.IOCON_R_PIO1_1.Reg)&^(0x300)|value<<8)
}
func (o *IOCON_Type) GetIOCON_R_PIO1_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_R_PIO1_1.Reg) & 0x300) >> 8
}
func (o *IOCON_Type) SetIOCON_R_PIO1_1_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO1_1.Reg, volatile.LoadUint32(&o.IOCON_R_PIO1_1.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_R_PIO1_1_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_R_PIO1_1.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_R_PIO1_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO1_1.Reg, volatile.LoadUint32(&o.IOCON_R_PIO1_1.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_R_PIO1_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_R_PIO1_1.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_R_PIO1_2: I/O configuration for pin R/PIO1_2/AD3/CT32B1_MAT1
func (o *IOCON_Type) SetIOCON_R_PIO1_2_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO1_2.Reg, volatile.LoadUint32(&o.IOCON_R_PIO1_2.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_R_PIO1_2_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_R_PIO1_2.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_R_PIO1_2_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO1_2.Reg, volatile.LoadUint32(&o.IOCON_R_PIO1_2.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_R_PIO1_2_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_R_PIO1_2.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_R_PIO1_2_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO1_2.Reg, volatile.LoadUint32(&o.IOCON_R_PIO1_2.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_R_PIO1_2_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_R_PIO1_2.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_R_PIO1_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO1_2.Reg, volatile.LoadUint32(&o.IOCON_R_PIO1_2.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetIOCON_R_PIO1_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_R_PIO1_2.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetIOCON_R_PIO1_2_ADMODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO1_2.Reg, volatile.LoadUint32(&o.IOCON_R_PIO1_2.Reg)&^(0x80)|value<<7)
}
func (o *IOCON_Type) GetIOCON_R_PIO1_2_ADMODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_R_PIO1_2.Reg) & 0x80) >> 7
}
func (o *IOCON_Type) SetIOCON_R_PIO1_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO1_2.Reg, volatile.LoadUint32(&o.IOCON_R_PIO1_2.Reg)&^(0x300)|value<<8)
}
func (o *IOCON_Type) GetIOCON_R_PIO1_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_R_PIO1_2.Reg) & 0x300) >> 8
}
func (o *IOCON_Type) SetIOCON_R_PIO1_2_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO1_2.Reg, volatile.LoadUint32(&o.IOCON_R_PIO1_2.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_R_PIO1_2_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_R_PIO1_2.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_R_PIO1_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_R_PIO1_2.Reg, volatile.LoadUint32(&o.IOCON_R_PIO1_2.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_R_PIO1_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_R_PIO1_2.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO3_0: I/O configuration for pin PIO3_0/DTR/CT16B0_MAT0/TXD
func (o *IOCON_Type) SetIOCON_PIO3_0_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_0.Reg, volatile.LoadUint32(&o.IOCON_PIO3_0.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO3_0_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO3_0.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO3_0_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_0.Reg, volatile.LoadUint32(&o.IOCON_PIO3_0.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO3_0_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_0.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO3_0_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_0.Reg, volatile.LoadUint32(&o.IOCON_PIO3_0.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO3_0_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_0.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO3_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_0.Reg, volatile.LoadUint32(&o.IOCON_PIO3_0.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO3_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_0.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO3_0_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_0.Reg, volatile.LoadUint32(&o.IOCON_PIO3_0.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO3_0_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_0.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO3_0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_0.Reg, volatile.LoadUint32(&o.IOCON_PIO3_0.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO3_0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_0.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO3_1: I/O configuration for pin PIO3_1/DSR/CT16B0_MAT1/RXD
func (o *IOCON_Type) SetIOCON_PIO3_1_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_1.Reg, volatile.LoadUint32(&o.IOCON_PIO3_1.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO3_1_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO3_1.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO3_1_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_1.Reg, volatile.LoadUint32(&o.IOCON_PIO3_1.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO3_1_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_1.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO3_1_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_1.Reg, volatile.LoadUint32(&o.IOCON_PIO3_1.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO3_1_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_1.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO3_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_1.Reg, volatile.LoadUint32(&o.IOCON_PIO3_1.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO3_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_1.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO3_1_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_1.Reg, volatile.LoadUint32(&o.IOCON_PIO3_1.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO3_1_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_1.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO3_1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_1.Reg, volatile.LoadUint32(&o.IOCON_PIO3_1.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO3_1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_1.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO2_3: I/O configuration for pin PIO2_3/RI/MOSI1
func (o *IOCON_Type) SetIOCON_PIO2_3_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_3.Reg, volatile.LoadUint32(&o.IOCON_PIO2_3.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO2_3_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO2_3.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO2_3_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_3.Reg, volatile.LoadUint32(&o.IOCON_PIO2_3.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO2_3_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_3.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO2_3_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_3.Reg, volatile.LoadUint32(&o.IOCON_PIO2_3.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO2_3_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_3.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO2_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_3.Reg, volatile.LoadUint32(&o.IOCON_PIO2_3.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO2_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_3.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO2_3_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_3.Reg, volatile.LoadUint32(&o.IOCON_PIO2_3.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO2_3_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_3.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO2_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO2_3.Reg, volatile.LoadUint32(&o.IOCON_PIO2_3.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO2_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO2_3.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_SWDIO_PIO1_3: I/O configuration for pin SWDIO/PIO1_3/AD4/CT32B1_MAT2
func (o *IOCON_Type) SetIOCON_SWDIO_PIO1_3_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_SWDIO_PIO1_3.Reg, volatile.LoadUint32(&o.IOCON_SWDIO_PIO1_3.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_SWDIO_PIO1_3_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_SWDIO_PIO1_3.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_SWDIO_PIO1_3_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_SWDIO_PIO1_3.Reg, volatile.LoadUint32(&o.IOCON_SWDIO_PIO1_3.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_SWDIO_PIO1_3_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_SWDIO_PIO1_3.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_SWDIO_PIO1_3_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_SWDIO_PIO1_3.Reg, volatile.LoadUint32(&o.IOCON_SWDIO_PIO1_3.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_SWDIO_PIO1_3_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_SWDIO_PIO1_3.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_SWDIO_PIO1_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_SWDIO_PIO1_3.Reg, volatile.LoadUint32(&o.IOCON_SWDIO_PIO1_3.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetIOCON_SWDIO_PIO1_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_SWDIO_PIO1_3.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetIOCON_SWDIO_PIO1_3_ADMODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_SWDIO_PIO1_3.Reg, volatile.LoadUint32(&o.IOCON_SWDIO_PIO1_3.Reg)&^(0x80)|value<<7)
}
func (o *IOCON_Type) GetIOCON_SWDIO_PIO1_3_ADMODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_SWDIO_PIO1_3.Reg) & 0x80) >> 7
}
func (o *IOCON_Type) SetIOCON_SWDIO_PIO1_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_SWDIO_PIO1_3.Reg, volatile.LoadUint32(&o.IOCON_SWDIO_PIO1_3.Reg)&^(0x300)|value<<8)
}
func (o *IOCON_Type) GetIOCON_SWDIO_PIO1_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_SWDIO_PIO1_3.Reg) & 0x300) >> 8
}
func (o *IOCON_Type) SetIOCON_SWDIO_PIO1_3_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_SWDIO_PIO1_3.Reg, volatile.LoadUint32(&o.IOCON_SWDIO_PIO1_3.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_SWDIO_PIO1_3_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_SWDIO_PIO1_3.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_SWDIO_PIO1_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_SWDIO_PIO1_3.Reg, volatile.LoadUint32(&o.IOCON_SWDIO_PIO1_3.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_SWDIO_PIO1_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_SWDIO_PIO1_3.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO1_4: I/O configuration for pin PIO1_4/AD5/CT32B1_MAT3
func (o *IOCON_Type) SetIOCON_PIO1_4_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_4.Reg, volatile.LoadUint32(&o.IOCON_PIO1_4.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO1_4_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO1_4.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO1_4_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_4.Reg, volatile.LoadUint32(&o.IOCON_PIO1_4.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO1_4_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_4.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO1_4_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_4.Reg, volatile.LoadUint32(&o.IOCON_PIO1_4.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO1_4_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_4.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO1_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_4.Reg, volatile.LoadUint32(&o.IOCON_PIO1_4.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO1_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_4.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO1_4_ADMODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_4.Reg, volatile.LoadUint32(&o.IOCON_PIO1_4.Reg)&^(0x80)|value<<7)
}
func (o *IOCON_Type) GetIOCON_PIO1_4_ADMODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_4.Reg) & 0x80) >> 7
}
func (o *IOCON_Type) SetIOCON_PIO1_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_4.Reg, volatile.LoadUint32(&o.IOCON_PIO1_4.Reg)&^(0x300)|value<<8)
}
func (o *IOCON_Type) GetIOCON_PIO1_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_4.Reg) & 0x300) >> 8
}
func (o *IOCON_Type) SetIOCON_PIO1_4_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_4.Reg, volatile.LoadUint32(&o.IOCON_PIO1_4.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO1_4_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_4.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO1_4_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_4.Reg, volatile.LoadUint32(&o.IOCON_PIO1_4.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO1_4_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_4.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO1_11: I/O configuration for pin PIO1_11/AD7/CT32B1_CAP1
func (o *IOCON_Type) SetIOCON_PIO1_11_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_11.Reg, volatile.LoadUint32(&o.IOCON_PIO1_11.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO1_11_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO1_11.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO1_11_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_11.Reg, volatile.LoadUint32(&o.IOCON_PIO1_11.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO1_11_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_11.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO1_11_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_11.Reg, volatile.LoadUint32(&o.IOCON_PIO1_11.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO1_11_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_11.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO1_11_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_11.Reg, volatile.LoadUint32(&o.IOCON_PIO1_11.Reg)&^(0x40)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO1_11_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_11.Reg) & 0x40) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO1_11_ADMODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_11.Reg, volatile.LoadUint32(&o.IOCON_PIO1_11.Reg)&^(0x80)|value<<7)
}
func (o *IOCON_Type) GetIOCON_PIO1_11_ADMODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_11.Reg) & 0x80) >> 7
}
func (o *IOCON_Type) SetIOCON_PIO1_11_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_11.Reg, volatile.LoadUint32(&o.IOCON_PIO1_11.Reg)&^(0x300)|value<<8)
}
func (o *IOCON_Type) GetIOCON_PIO1_11_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_11.Reg) & 0x300) >> 8
}
func (o *IOCON_Type) SetIOCON_PIO1_11_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_11.Reg, volatile.LoadUint32(&o.IOCON_PIO1_11.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO1_11_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_11.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO1_11_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_11.Reg, volatile.LoadUint32(&o.IOCON_PIO1_11.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO1_11_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_11.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO3_2: I/O configuration for pin PIO3_2/DCD/ CT16B0_MAT2/SCK1
func (o *IOCON_Type) SetIOCON_PIO3_2_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_2.Reg, volatile.LoadUint32(&o.IOCON_PIO3_2.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO3_2_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO3_2.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO3_2_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_2.Reg, volatile.LoadUint32(&o.IOCON_PIO3_2.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO3_2_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_2.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO3_2_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_2.Reg, volatile.LoadUint32(&o.IOCON_PIO3_2.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO3_2_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_2.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO3_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_2.Reg, volatile.LoadUint32(&o.IOCON_PIO3_2.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO3_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_2.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO3_2_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_2.Reg, volatile.LoadUint32(&o.IOCON_PIO3_2.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO3_2_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_2.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO3_2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_2.Reg, volatile.LoadUint32(&o.IOCON_PIO3_2.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO3_2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_2.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO1_5: I/O configuration for pin PIO1_5/RTS/CT32B0_CAP0
func (o *IOCON_Type) SetIOCON_PIO1_5_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_5.Reg, volatile.LoadUint32(&o.IOCON_PIO1_5.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO1_5_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO1_5.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO1_5_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_5.Reg, volatile.LoadUint32(&o.IOCON_PIO1_5.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO1_5_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_5.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO1_5_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_5.Reg, volatile.LoadUint32(&o.IOCON_PIO1_5.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO1_5_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_5.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO1_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_5.Reg, volatile.LoadUint32(&o.IOCON_PIO1_5.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO1_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_5.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO1_5_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_5.Reg, volatile.LoadUint32(&o.IOCON_PIO1_5.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO1_5_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_5.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO1_5_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_5.Reg, volatile.LoadUint32(&o.IOCON_PIO1_5.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO1_5_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_5.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO1_6: I/O configuration for pin PIO1_6/RXD/CT32B0_MAT0
func (o *IOCON_Type) SetIOCON_PIO1_6_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_6.Reg, volatile.LoadUint32(&o.IOCON_PIO1_6.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO1_6_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO1_6.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO1_6_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_6.Reg, volatile.LoadUint32(&o.IOCON_PIO1_6.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO1_6_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_6.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO1_6_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_6.Reg, volatile.LoadUint32(&o.IOCON_PIO1_6.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO1_6_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_6.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO1_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_6.Reg, volatile.LoadUint32(&o.IOCON_PIO1_6.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO1_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_6.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO1_6_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_6.Reg, volatile.LoadUint32(&o.IOCON_PIO1_6.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO1_6_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_6.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO1_6_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_6.Reg, volatile.LoadUint32(&o.IOCON_PIO1_6.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO1_6_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_6.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO1_7: I/O configuration for pin PIO1_7/TXD/CT32B0_MAT1
func (o *IOCON_Type) SetIOCON_PIO1_7_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_7.Reg, volatile.LoadUint32(&o.IOCON_PIO1_7.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO1_7_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO1_7.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO1_7_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_7.Reg, volatile.LoadUint32(&o.IOCON_PIO1_7.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO1_7_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_7.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO1_7_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_7.Reg, volatile.LoadUint32(&o.IOCON_PIO1_7.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO1_7_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_7.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO1_7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_7.Reg, volatile.LoadUint32(&o.IOCON_PIO1_7.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO1_7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_7.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO1_7_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_7.Reg, volatile.LoadUint32(&o.IOCON_PIO1_7.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO1_7_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_7.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO1_7_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO1_7.Reg, volatile.LoadUint32(&o.IOCON_PIO1_7.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO1_7_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO1_7.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_PIO3_3: I/O configuration for pin PIO3_3/RI/ CT16B0_CAP0
func (o *IOCON_Type) SetIOCON_PIO3_3_FUNC(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_3.Reg, volatile.LoadUint32(&o.IOCON_PIO3_3.Reg)&^(0x7)|value)
}
func (o *IOCON_Type) GetIOCON_PIO3_3_FUNC() uint32 {
	return volatile.LoadUint32(&o.IOCON_PIO3_3.Reg) & 0x7
}
func (o *IOCON_Type) SetIOCON_PIO3_3_MODE(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_3.Reg, volatile.LoadUint32(&o.IOCON_PIO3_3.Reg)&^(0x18)|value<<3)
}
func (o *IOCON_Type) GetIOCON_PIO3_3_MODE() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_3.Reg) & 0x18) >> 3
}
func (o *IOCON_Type) SetIOCON_PIO3_3_HYS(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_3.Reg, volatile.LoadUint32(&o.IOCON_PIO3_3.Reg)&^(0x20)|value<<5)
}
func (o *IOCON_Type) GetIOCON_PIO3_3_HYS() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_3.Reg) & 0x20) >> 5
}
func (o *IOCON_Type) SetIOCON_PIO3_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_3.Reg, volatile.LoadUint32(&o.IOCON_PIO3_3.Reg)&^(0x3c0)|value<<6)
}
func (o *IOCON_Type) GetIOCON_PIO3_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_3.Reg) & 0x3c0) >> 6
}
func (o *IOCON_Type) SetIOCON_PIO3_3_OD(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_3.Reg, volatile.LoadUint32(&o.IOCON_PIO3_3.Reg)&^(0x400)|value<<10)
}
func (o *IOCON_Type) GetIOCON_PIO3_3_OD() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_3.Reg) & 0x400) >> 10
}
func (o *IOCON_Type) SetIOCON_PIO3_3_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_PIO3_3.Reg, volatile.LoadUint32(&o.IOCON_PIO3_3.Reg)&^(0xfffff800)|value<<11)
}
func (o *IOCON_Type) GetIOCON_PIO3_3_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_PIO3_3.Reg) & 0xfffff800) >> 11
}

// IOCON.IOCON_SCK0_LOC: SCK0 pin location select register
func (o *IOCON_Type) SetIOCON_SCK0_LOC_SCKLOC(value uint32) {
	volatile.StoreUint32(&o.IOCON_SCK0_LOC.Reg, volatile.LoadUint32(&o.IOCON_SCK0_LOC.Reg)&^(0x3)|value)
}
func (o *IOCON_Type) GetIOCON_SCK0_LOC_SCKLOC() uint32 {
	return volatile.LoadUint32(&o.IOCON_SCK0_LOC.Reg) & 0x3
}
func (o *IOCON_Type) SetIOCON_SCK0_LOC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_SCK0_LOC.Reg, volatile.LoadUint32(&o.IOCON_SCK0_LOC.Reg)&^(0xfffffffc)|value<<2)
}
func (o *IOCON_Type) GetIOCON_SCK0_LOC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_SCK0_LOC.Reg) & 0xfffffffc) >> 2
}

// IOCON.IOCON_DSR_LOC: DSR pin location select register
func (o *IOCON_Type) SetIOCON_DSR_LOC_DSRLOC(value uint32) {
	volatile.StoreUint32(&o.IOCON_DSR_LOC.Reg, volatile.LoadUint32(&o.IOCON_DSR_LOC.Reg)&^(0x3)|value)
}
func (o *IOCON_Type) GetIOCON_DSR_LOC_DSRLOC() uint32 {
	return volatile.LoadUint32(&o.IOCON_DSR_LOC.Reg) & 0x3
}
func (o *IOCON_Type) SetIOCON_DSR_LOC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_DSR_LOC.Reg, volatile.LoadUint32(&o.IOCON_DSR_LOC.Reg)&^(0xfffffffc)|value<<2)
}
func (o *IOCON_Type) GetIOCON_DSR_LOC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_DSR_LOC.Reg) & 0xfffffffc) >> 2
}

// IOCON.IOCON_DCD_LOC: DCD pin location select register
func (o *IOCON_Type) SetIOCON_DCD_LOC_DCDLOC(value uint32) {
	volatile.StoreUint32(&o.IOCON_DCD_LOC.Reg, volatile.LoadUint32(&o.IOCON_DCD_LOC.Reg)&^(0x3)|value)
}
func (o *IOCON_Type) GetIOCON_DCD_LOC_DCDLOC() uint32 {
	return volatile.LoadUint32(&o.IOCON_DCD_LOC.Reg) & 0x3
}
func (o *IOCON_Type) SetIOCON_DCD_LOC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_DCD_LOC.Reg, volatile.LoadUint32(&o.IOCON_DCD_LOC.Reg)&^(0xfffffffc)|value<<2)
}
func (o *IOCON_Type) GetIOCON_DCD_LOC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_DCD_LOC.Reg) & 0xfffffffc) >> 2
}

// IOCON.IOCON_RI_LOC: RI pin location select register
func (o *IOCON_Type) SetIOCON_RI_LOC_RILOC(value uint32) {
	volatile.StoreUint32(&o.IOCON_RI_LOC.Reg, volatile.LoadUint32(&o.IOCON_RI_LOC.Reg)&^(0x3)|value)
}
func (o *IOCON_Type) GetIOCON_RI_LOC_RILOC() uint32 {
	return volatile.LoadUint32(&o.IOCON_RI_LOC.Reg) & 0x3
}
func (o *IOCON_Type) SetIOCON_RI_LOC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_RI_LOC.Reg, volatile.LoadUint32(&o.IOCON_RI_LOC.Reg)&^(0xfffffffc)|value<<2)
}
func (o *IOCON_Type) GetIOCON_RI_LOC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_RI_LOC.Reg) & 0xfffffffc) >> 2
}

// IOCON.IOCON_CT16B0_CAP0_LOC: CT16B0_CAP0 pin location select register
func (o *IOCON_Type) SetIOCON_CT16B0_CAP0_LOC_CT16B0_CAP0LOC(value uint32) {
	volatile.StoreUint32(&o.IOCON_CT16B0_CAP0_LOC.Reg, volatile.LoadUint32(&o.IOCON_CT16B0_CAP0_LOC.Reg)&^(0x3)|value)
}
func (o *IOCON_Type) GetIOCON_CT16B0_CAP0_LOC_CT16B0_CAP0LOC() uint32 {
	return volatile.LoadUint32(&o.IOCON_CT16B0_CAP0_LOC.Reg) & 0x3
}
func (o *IOCON_Type) SetIOCON_CT16B0_CAP0_LOC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_CT16B0_CAP0_LOC.Reg, volatile.LoadUint32(&o.IOCON_CT16B0_CAP0_LOC.Reg)&^(0xfffffffc)|value<<2)
}
func (o *IOCON_Type) GetIOCON_CT16B0_CAP0_LOC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_CT16B0_CAP0_LOC.Reg) & 0xfffffffc) >> 2
}

// IOCON.IOCON_SCK1_LOC: SCK1 pin location select register
func (o *IOCON_Type) SetIOCON_SCK1_LOC_SCK1LOC(value uint32) {
	volatile.StoreUint32(&o.IOCON_SCK1_LOC.Reg, volatile.LoadUint32(&o.IOCON_SCK1_LOC.Reg)&^(0x3)|value)
}
func (o *IOCON_Type) GetIOCON_SCK1_LOC_SCK1LOC() uint32 {
	return volatile.LoadUint32(&o.IOCON_SCK1_LOC.Reg) & 0x3
}
func (o *IOCON_Type) SetIOCON_SCK1_LOC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_SCK1_LOC.Reg, volatile.LoadUint32(&o.IOCON_SCK1_LOC.Reg)&^(0xfffffffc)|value<<2)
}
func (o *IOCON_Type) GetIOCON_SCK1_LOC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_SCK1_LOC.Reg) & 0xfffffffc) >> 2
}

// IOCON.IOCON_MISO1_LOC: MISO1 pin location select register
func (o *IOCON_Type) SetIOCON_MISO1_LOC_MISO1LOC(value uint32) {
	volatile.StoreUint32(&o.IOCON_MISO1_LOC.Reg, volatile.LoadUint32(&o.IOCON_MISO1_LOC.Reg)&^(0x3)|value)
}
func (o *IOCON_Type) GetIOCON_MISO1_LOC_MISO1LOC() uint32 {
	return volatile.LoadUint32(&o.IOCON_MISO1_LOC.Reg) & 0x3
}
func (o *IOCON_Type) SetIOCON_MISO1_LOC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_MISO1_LOC.Reg, volatile.LoadUint32(&o.IOCON_MISO1_LOC.Reg)&^(0xfffffffc)|value<<2)
}
func (o *IOCON_Type) GetIOCON_MISO1_LOC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_MISO1_LOC.Reg) & 0xfffffffc) >> 2
}

// IOCON.IOCON_MOSI1_LOC: MOSI1 pin location select register
func (o *IOCON_Type) SetIOCON_MOSI1_LOC_MOSI1LOC(value uint32) {
	volatile.StoreUint32(&o.IOCON_MOSI1_LOC.Reg, volatile.LoadUint32(&o.IOCON_MOSI1_LOC.Reg)&^(0x3)|value)
}
func (o *IOCON_Type) GetIOCON_MOSI1_LOC_MOSI1LOC() uint32 {
	return volatile.LoadUint32(&o.IOCON_MOSI1_LOC.Reg) & 0x3
}
func (o *IOCON_Type) SetIOCON_MOSI1_LOC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_MOSI1_LOC.Reg, volatile.LoadUint32(&o.IOCON_MOSI1_LOC.Reg)&^(0xfffffffc)|value<<2)
}
func (o *IOCON_Type) GetIOCON_MOSI1_LOC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_MOSI1_LOC.Reg) & 0xfffffffc) >> 2
}

// IOCON.IOCON_CT32B0_CAP0_LOC: CT32B0_CAP0 pin location select register
func (o *IOCON_Type) SetIOCON_CT32B0_CAP0_LOC_CT32B0_CAP0LOC(value uint32) {
	volatile.StoreUint32(&o.IOCON_CT32B0_CAP0_LOC.Reg, volatile.LoadUint32(&o.IOCON_CT32B0_CAP0_LOC.Reg)&^(0x3)|value)
}
func (o *IOCON_Type) GetIOCON_CT32B0_CAP0_LOC_CT32B0_CAP0LOC() uint32 {
	return volatile.LoadUint32(&o.IOCON_CT32B0_CAP0_LOC.Reg) & 0x3
}
func (o *IOCON_Type) SetIOCON_CT32B0_CAP0_LOC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_CT32B0_CAP0_LOC.Reg, volatile.LoadUint32(&o.IOCON_CT32B0_CAP0_LOC.Reg)&^(0xfffffffc)|value<<2)
}
func (o *IOCON_Type) GetIOCON_CT32B0_CAP0_LOC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_CT32B0_CAP0_LOC.Reg) & 0xfffffffc) >> 2
}

// IOCON.IOCON_RXD_LOC: RXD pin location select register
func (o *IOCON_Type) SetIOCON_RXD_LOC_RXDLOC(value uint32) {
	volatile.StoreUint32(&o.IOCON_RXD_LOC.Reg, volatile.LoadUint32(&o.IOCON_RXD_LOC.Reg)&^(0x3)|value)
}
func (o *IOCON_Type) GetIOCON_RXD_LOC_RXDLOC() uint32 {
	return volatile.LoadUint32(&o.IOCON_RXD_LOC.Reg) & 0x3
}
func (o *IOCON_Type) SetIOCON_RXD_LOC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IOCON_RXD_LOC.Reg, volatile.LoadUint32(&o.IOCON_RXD_LOC.Reg)&^(0xfffffffc)|value<<2)
}
func (o *IOCON_Type) GetIOCON_RXD_LOC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IOCON_RXD_LOC.Reg) & 0xfffffffc) >> 2
}

// Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx System configuration (SYSCON) Modification date=2/22/2012 Major revision=8 Minor revision=not available
type SYSCON_Type struct {
	SYSMEMREMAP   volatile.Register32 // 0x0
	PRESETCTRL    volatile.Register32 // 0x4
	SYSPLLCTRL    volatile.Register32 // 0x8
	SYSPLLSTAT    volatile.Register32 // 0xC
	_             [16]byte
	SYSOSCCTRL    volatile.Register32 // 0x20
	WDTOSCCTRL    volatile.Register32 // 0x24
	IRCCTRL       volatile.Register32 // 0x28
	_             [4]byte
	SYSRSTSTAT    volatile.Register32 // 0x30
	_             [12]byte
	SYSPLLCLKSEL  volatile.Register32 // 0x40
	SYSPLLCLKUEN  volatile.Register32 // 0x44
	_             [40]byte
	MAINCLKSEL    volatile.Register32 // 0x70
	MAINCLKUEN    volatile.Register32 // 0x74
	SYSAHBCLKDIV  volatile.Register32 // 0x78
	_             [4]byte
	SYSAHBCLKCTRL volatile.Register32 // 0x80
	_             [16]byte
	SSP0CLKDIV    volatile.Register32 // 0x94
	UARTCLKDIV    volatile.Register32 // 0x98
	SSP1CLKDIV    volatile.Register32 // 0x9C
	_             [48]byte
	WDTCLKSEL     volatile.Register32 // 0xD0
	WDTCLKUEN     volatile.Register32 // 0xD4
	WDTCLKDIV     volatile.Register32 // 0xD8
	_             [4]byte
	CLKOUTCLKSEL  volatile.Register32 // 0xE0
	CLKOUTUEN     volatile.Register32 // 0xE4
	CLKOUTCLKDIV  volatile.Register32 // 0xE8
	_             [20]byte
	PIOPORCAP0    volatile.Register32 // 0x100
	PIOPORCAP1    volatile.Register32 // 0x104
	_             [72]byte
	BODCTRL       volatile.Register32 // 0x150
	SYSTCKCAL     volatile.Register32 // 0x154
	_             [28]byte
	NMISRC        volatile.Register32 // 0x174
	_             [136]byte
	STARTAPRP0    volatile.Register32 // 0x200
	STARTERP0     volatile.Register32 // 0x204
	STARTRSRP0CLR volatile.Register32 // 0x208
	STARTSRP0     volatile.Register32 // 0x20C
	_             [32]byte
	PDSLEEPCFG    volatile.Register32 // 0x230
	PDAWAKECFG    volatile.Register32 // 0x234
	PDRUNCFG      volatile.Register32 // 0x238
	_             [440]byte
	DEVICE_ID     volatile.Register32 // 0x3F4
}

// SYSCON.SYSMEMREMAP: System memory remap
func (o *SYSCON_Type) SetSYSMEMREMAP_MAP(value uint32) {
	volatile.StoreUint32(&o.SYSMEMREMAP.Reg, volatile.LoadUint32(&o.SYSMEMREMAP.Reg)&^(0x3)|value)
}
func (o *SYSCON_Type) GetSYSMEMREMAP_MAP() uint32 {
	return volatile.LoadUint32(&o.SYSMEMREMAP.Reg) & 0x3
}
func (o *SYSCON_Type) SetSYSMEMREMAP_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SYSMEMREMAP.Reg, volatile.LoadUint32(&o.SYSMEMREMAP.Reg)&^(0xfffffffc)|value<<2)
}
func (o *SYSCON_Type) GetSYSMEMREMAP_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SYSMEMREMAP.Reg) & 0xfffffffc) >> 2
}

// SYSCON.PRESETCTRL: Peripheral reset control
func (o *SYSCON_Type) SetPRESETCTRL_SSP0_RST_N(value uint32) {
	volatile.StoreUint32(&o.PRESETCTRL.Reg, volatile.LoadUint32(&o.PRESETCTRL.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetPRESETCTRL_SSP0_RST_N() uint32 {
	return volatile.LoadUint32(&o.PRESETCTRL.Reg) & 0x1
}
func (o *SYSCON_Type) SetPRESETCTRL_I2C_RST_N(value uint32) {
	volatile.StoreUint32(&o.PRESETCTRL.Reg, volatile.LoadUint32(&o.PRESETCTRL.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetPRESETCTRL_I2C_RST_N() uint32 {
	return (volatile.LoadUint32(&o.PRESETCTRL.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetPRESETCTRL_SSP1_RST_N(value uint32) {
	volatile.StoreUint32(&o.PRESETCTRL.Reg, volatile.LoadUint32(&o.PRESETCTRL.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetPRESETCTRL_SSP1_RST_N() uint32 {
	return (volatile.LoadUint32(&o.PRESETCTRL.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetPRESETCTRL_CAN_RST_N(value uint32) {
	volatile.StoreUint32(&o.PRESETCTRL.Reg, volatile.LoadUint32(&o.PRESETCTRL.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetPRESETCTRL_CAN_RST_N() uint32 {
	return (volatile.LoadUint32(&o.PRESETCTRL.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetPRESETCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PRESETCTRL.Reg, volatile.LoadUint32(&o.PRESETCTRL.Reg)&^(0xfffffff0)|value<<4)
}
func (o *SYSCON_Type) GetPRESETCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PRESETCTRL.Reg) & 0xfffffff0) >> 4
}

// SYSCON.SYSPLLCTRL: System PLL control
func (o *SYSCON_Type) SetSYSPLLCTRL_MSEL(value uint32) {
	volatile.StoreUint32(&o.SYSPLLCTRL.Reg, volatile.LoadUint32(&o.SYSPLLCTRL.Reg)&^(0x1f)|value)
}
func (o *SYSCON_Type) GetSYSPLLCTRL_MSEL() uint32 {
	return volatile.LoadUint32(&o.SYSPLLCTRL.Reg) & 0x1f
}
func (o *SYSCON_Type) SetSYSPLLCTRL_PSEL(value uint32) {
	volatile.StoreUint32(&o.SYSPLLCTRL.Reg, volatile.LoadUint32(&o.SYSPLLCTRL.Reg)&^(0x60)|value<<5)
}
func (o *SYSCON_Type) GetSYSPLLCTRL_PSEL() uint32 {
	return (volatile.LoadUint32(&o.SYSPLLCTRL.Reg) & 0x60) >> 5
}
func (o *SYSCON_Type) SetSYSPLLCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SYSPLLCTRL.Reg, volatile.LoadUint32(&o.SYSPLLCTRL.Reg)&^(0xffffff80)|value<<7)
}
func (o *SYSCON_Type) GetSYSPLLCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SYSPLLCTRL.Reg) & 0xffffff80) >> 7
}

// SYSCON.SYSPLLSTAT: System PLL status
func (o *SYSCON_Type) SetSYSPLLSTAT_LOCK(value uint32) {
	volatile.StoreUint32(&o.SYSPLLSTAT.Reg, volatile.LoadUint32(&o.SYSPLLSTAT.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetSYSPLLSTAT_LOCK() uint32 {
	return volatile.LoadUint32(&o.SYSPLLSTAT.Reg) & 0x1
}
func (o *SYSCON_Type) SetSYSPLLSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SYSPLLSTAT.Reg, volatile.LoadUint32(&o.SYSPLLSTAT.Reg)&^(0xfffffffe)|value<<1)
}
func (o *SYSCON_Type) GetSYSPLLSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SYSPLLSTAT.Reg) & 0xfffffffe) >> 1
}

// SYSCON.SYSOSCCTRL: System oscillator control
func (o *SYSCON_Type) SetSYSOSCCTRL_BYPASS(value uint32) {
	volatile.StoreUint32(&o.SYSOSCCTRL.Reg, volatile.LoadUint32(&o.SYSOSCCTRL.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetSYSOSCCTRL_BYPASS() uint32 {
	return volatile.LoadUint32(&o.SYSOSCCTRL.Reg) & 0x1
}
func (o *SYSCON_Type) SetSYSOSCCTRL_FREQRANGE(value uint32) {
	volatile.StoreUint32(&o.SYSOSCCTRL.Reg, volatile.LoadUint32(&o.SYSOSCCTRL.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetSYSOSCCTRL_FREQRANGE() uint32 {
	return (volatile.LoadUint32(&o.SYSOSCCTRL.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetSYSOSCCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SYSOSCCTRL.Reg, volatile.LoadUint32(&o.SYSOSCCTRL.Reg)&^(0xfffffffc)|value<<2)
}
func (o *SYSCON_Type) GetSYSOSCCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SYSOSCCTRL.Reg) & 0xfffffffc) >> 2
}

// SYSCON.WDTOSCCTRL: Watchdog oscillator control
func (o *SYSCON_Type) SetWDTOSCCTRL_DIVSEL(value uint32) {
	volatile.StoreUint32(&o.WDTOSCCTRL.Reg, volatile.LoadUint32(&o.WDTOSCCTRL.Reg)&^(0x1f)|value)
}
func (o *SYSCON_Type) GetWDTOSCCTRL_DIVSEL() uint32 {
	return volatile.LoadUint32(&o.WDTOSCCTRL.Reg) & 0x1f
}
func (o *SYSCON_Type) SetWDTOSCCTRL_FREQSEL(value uint32) {
	volatile.StoreUint32(&o.WDTOSCCTRL.Reg, volatile.LoadUint32(&o.WDTOSCCTRL.Reg)&^(0x1e0)|value<<5)
}
func (o *SYSCON_Type) GetWDTOSCCTRL_FREQSEL() uint32 {
	return (volatile.LoadUint32(&o.WDTOSCCTRL.Reg) & 0x1e0) >> 5
}
func (o *SYSCON_Type) SetWDTOSCCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.WDTOSCCTRL.Reg, volatile.LoadUint32(&o.WDTOSCCTRL.Reg)&^(0xfffffe00)|value<<9)
}
func (o *SYSCON_Type) GetWDTOSCCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.WDTOSCCTRL.Reg) & 0xfffffe00) >> 9
}

// SYSCON.IRCCTRL: IRC control
func (o *SYSCON_Type) SetIRCCTRL_TRIM(value uint32) {
	volatile.StoreUint32(&o.IRCCTRL.Reg, volatile.LoadUint32(&o.IRCCTRL.Reg)&^(0xff)|value)
}
func (o *SYSCON_Type) GetIRCCTRL_TRIM() uint32 {
	return volatile.LoadUint32(&o.IRCCTRL.Reg) & 0xff
}
func (o *SYSCON_Type) SetIRCCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IRCCTRL.Reg, volatile.LoadUint32(&o.IRCCTRL.Reg)&^(0xffffff00)|value<<8)
}
func (o *SYSCON_Type) GetIRCCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IRCCTRL.Reg) & 0xffffff00) >> 8
}

// SYSCON.SYSRSTSTAT: System reset status register
func (o *SYSCON_Type) SetSYSRSTSTAT_POR(value uint32) {
	volatile.StoreUint32(&o.SYSRSTSTAT.Reg, volatile.LoadUint32(&o.SYSRSTSTAT.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetSYSRSTSTAT_POR() uint32 {
	return volatile.LoadUint32(&o.SYSRSTSTAT.Reg) & 0x1
}
func (o *SYSCON_Type) SetSYSRSTSTAT_EXTRST(value uint32) {
	volatile.StoreUint32(&o.SYSRSTSTAT.Reg, volatile.LoadUint32(&o.SYSRSTSTAT.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetSYSRSTSTAT_EXTRST() uint32 {
	return (volatile.LoadUint32(&o.SYSRSTSTAT.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetSYSRSTSTAT_WDT(value uint32) {
	volatile.StoreUint32(&o.SYSRSTSTAT.Reg, volatile.LoadUint32(&o.SYSRSTSTAT.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetSYSRSTSTAT_WDT() uint32 {
	return (volatile.LoadUint32(&o.SYSRSTSTAT.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetSYSRSTSTAT_BOD(value uint32) {
	volatile.StoreUint32(&o.SYSRSTSTAT.Reg, volatile.LoadUint32(&o.SYSRSTSTAT.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetSYSRSTSTAT_BOD() uint32 {
	return (volatile.LoadUint32(&o.SYSRSTSTAT.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetSYSRSTSTAT_SYSRST(value uint32) {
	volatile.StoreUint32(&o.SYSRSTSTAT.Reg, volatile.LoadUint32(&o.SYSRSTSTAT.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetSYSRSTSTAT_SYSRST() uint32 {
	return (volatile.LoadUint32(&o.SYSRSTSTAT.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetSYSRSTSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SYSRSTSTAT.Reg, volatile.LoadUint32(&o.SYSRSTSTAT.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSCON_Type) GetSYSRSTSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SYSRSTSTAT.Reg) & 0xffffffe0) >> 5
}

// SYSCON.SYSPLLCLKSEL: System PLL clock source select
func (o *SYSCON_Type) SetSYSPLLCLKSEL_SEL(value uint32) {
	volatile.StoreUint32(&o.SYSPLLCLKSEL.Reg, volatile.LoadUint32(&o.SYSPLLCLKSEL.Reg)&^(0x3)|value)
}
func (o *SYSCON_Type) GetSYSPLLCLKSEL_SEL() uint32 {
	return volatile.LoadUint32(&o.SYSPLLCLKSEL.Reg) & 0x3
}
func (o *SYSCON_Type) SetSYSPLLCLKSEL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SYSPLLCLKSEL.Reg, volatile.LoadUint32(&o.SYSPLLCLKSEL.Reg)&^(0xfffffffc)|value<<2)
}
func (o *SYSCON_Type) GetSYSPLLCLKSEL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SYSPLLCLKSEL.Reg) & 0xfffffffc) >> 2
}

// SYSCON.SYSPLLCLKUEN: System PLL clock source update enable
func (o *SYSCON_Type) SetSYSPLLCLKUEN_ENA(value uint32) {
	volatile.StoreUint32(&o.SYSPLLCLKUEN.Reg, volatile.LoadUint32(&o.SYSPLLCLKUEN.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetSYSPLLCLKUEN_ENA() uint32 {
	return volatile.LoadUint32(&o.SYSPLLCLKUEN.Reg) & 0x1
}
func (o *SYSCON_Type) SetSYSPLLCLKUEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SYSPLLCLKUEN.Reg, volatile.LoadUint32(&o.SYSPLLCLKUEN.Reg)&^(0xfffffffe)|value<<1)
}
func (o *SYSCON_Type) GetSYSPLLCLKUEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SYSPLLCLKUEN.Reg) & 0xfffffffe) >> 1
}

// SYSCON.MAINCLKSEL: Main clock source select
func (o *SYSCON_Type) SetMAINCLKSEL_SEL(value uint32) {
	volatile.StoreUint32(&o.MAINCLKSEL.Reg, volatile.LoadUint32(&o.MAINCLKSEL.Reg)&^(0x3)|value)
}
func (o *SYSCON_Type) GetMAINCLKSEL_SEL() uint32 {
	return volatile.LoadUint32(&o.MAINCLKSEL.Reg) & 0x3
}
func (o *SYSCON_Type) SetMAINCLKSEL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAINCLKSEL.Reg, volatile.LoadUint32(&o.MAINCLKSEL.Reg)&^(0xfffffffc)|value<<2)
}
func (o *SYSCON_Type) GetMAINCLKSEL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAINCLKSEL.Reg) & 0xfffffffc) >> 2
}

// SYSCON.MAINCLKUEN: Main clock source update enable
func (o *SYSCON_Type) SetMAINCLKUEN_ENA(value uint32) {
	volatile.StoreUint32(&o.MAINCLKUEN.Reg, volatile.LoadUint32(&o.MAINCLKUEN.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetMAINCLKUEN_ENA() uint32 {
	return volatile.LoadUint32(&o.MAINCLKUEN.Reg) & 0x1
}
func (o *SYSCON_Type) SetMAINCLKUEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MAINCLKUEN.Reg, volatile.LoadUint32(&o.MAINCLKUEN.Reg)&^(0xfffffffe)|value<<1)
}
func (o *SYSCON_Type) GetMAINCLKUEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MAINCLKUEN.Reg) & 0xfffffffe) >> 1
}

// SYSCON.SYSAHBCLKDIV: System AHB clock divider
func (o *SYSCON_Type) SetSYSAHBCLKDIV_DIV(value uint32) {
	volatile.StoreUint32(&o.SYSAHBCLKDIV.Reg, volatile.LoadUint32(&o.SYSAHBCLKDIV.Reg)&^(0xff)|value)
}
func (o *SYSCON_Type) GetSYSAHBCLKDIV_DIV() uint32 {
	return volatile.LoadUint32(&o.SYSAHBCLKDIV.Reg) & 0xff
}
func (o *SYSCON_Type) SetSYSAHBCLKDIV_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SYSAHBCLKDIV.Reg, volatile.LoadUint32(&o.SYSAHBCLKDIV.Reg)&^(0xffffff00)|value<<8)
}
func (o *SYSCON_Type) GetSYSAHBCLKDIV_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SYSAHBCLKDIV.Reg) & 0xffffff00) >> 8
}

// SYSCON.SYSAHBCLKCTRL: System AHB clock control
func (o *SYSCON_Type) SetSYSAHBCLKCTRL_SYS(value uint32) {
	volatile.StoreUint32(&o.SYSAHBCLKCTRL.Reg, volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetSYSAHBCLKCTRL_SYS() uint32 {
	return volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg) & 0x1
}
func (o *SYSCON_Type) SetSYSAHBCLKCTRL_ROM(value uint32) {
	volatile.StoreUint32(&o.SYSAHBCLKCTRL.Reg, volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetSYSAHBCLKCTRL_ROM() uint32 {
	return (volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetSYSAHBCLKCTRL_RAM(value uint32) {
	volatile.StoreUint32(&o.SYSAHBCLKCTRL.Reg, volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetSYSAHBCLKCTRL_RAM() uint32 {
	return (volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetSYSAHBCLKCTRL_FLASHREG(value uint32) {
	volatile.StoreUint32(&o.SYSAHBCLKCTRL.Reg, volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetSYSAHBCLKCTRL_FLASHREG() uint32 {
	return (volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetSYSAHBCLKCTRL_FLASHARRAY(value uint32) {
	volatile.StoreUint32(&o.SYSAHBCLKCTRL.Reg, volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetSYSAHBCLKCTRL_FLASHARRAY() uint32 {
	return (volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetSYSAHBCLKCTRL_I2C(value uint32) {
	volatile.StoreUint32(&o.SYSAHBCLKCTRL.Reg, volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetSYSAHBCLKCTRL_I2C() uint32 {
	return (volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetSYSAHBCLKCTRL_GPIO(value uint32) {
	volatile.StoreUint32(&o.SYSAHBCLKCTRL.Reg, volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetSYSAHBCLKCTRL_GPIO() uint32 {
	return (volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetSYSAHBCLKCTRL_CT16B0(value uint32) {
	volatile.StoreUint32(&o.SYSAHBCLKCTRL.Reg, volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetSYSAHBCLKCTRL_CT16B0() uint32 {
	return (volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetSYSAHBCLKCTRL_CT16B1(value uint32) {
	volatile.StoreUint32(&o.SYSAHBCLKCTRL.Reg, volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetSYSAHBCLKCTRL_CT16B1() uint32 {
	return (volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetSYSAHBCLKCTRL_CT32B0(value uint32) {
	volatile.StoreUint32(&o.SYSAHBCLKCTRL.Reg, volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetSYSAHBCLKCTRL_CT32B0() uint32 {
	return (volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetSYSAHBCLKCTRL_CT32B1(value uint32) {
	volatile.StoreUint32(&o.SYSAHBCLKCTRL.Reg, volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetSYSAHBCLKCTRL_CT32B1() uint32 {
	return (volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetSYSAHBCLKCTRL_SSP0(value uint32) {
	volatile.StoreUint32(&o.SYSAHBCLKCTRL.Reg, volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg)&^(0x800)|value<<11)
}
func (o *SYSCON_Type) GetSYSAHBCLKCTRL_SSP0() uint32 {
	return (volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg) & 0x800) >> 11
}
func (o *SYSCON_Type) SetSYSAHBCLKCTRL_UART(value uint32) {
	volatile.StoreUint32(&o.SYSAHBCLKCTRL.Reg, volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg)&^(0x1000)|value<<12)
}
func (o *SYSCON_Type) GetSYSAHBCLKCTRL_UART() uint32 {
	return (volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg) & 0x1000) >> 12
}
func (o *SYSCON_Type) SetSYSAHBCLKCTRL_ADC(value uint32) {
	volatile.StoreUint32(&o.SYSAHBCLKCTRL.Reg, volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg)&^(0x2000)|value<<13)
}
func (o *SYSCON_Type) GetSYSAHBCLKCTRL_ADC() uint32 {
	return (volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg) & 0x2000) >> 13
}
func (o *SYSCON_Type) SetSYSAHBCLKCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SYSAHBCLKCTRL.Reg, volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg)&^(0x4000)|value<<14)
}
func (o *SYSCON_Type) GetSYSAHBCLKCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg) & 0x4000) >> 14
}
func (o *SYSCON_Type) SetSYSAHBCLKCTRL_WDT(value uint32) {
	volatile.StoreUint32(&o.SYSAHBCLKCTRL.Reg, volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *SYSCON_Type) GetSYSAHBCLKCTRL_WDT() uint32 {
	return (volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg) & 0x8000) >> 15
}
func (o *SYSCON_Type) SetSYSAHBCLKCTRL_IOCON(value uint32) {
	volatile.StoreUint32(&o.SYSAHBCLKCTRL.Reg, volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg)&^(0x10000)|value<<16)
}
func (o *SYSCON_Type) GetSYSAHBCLKCTRL_IOCON() uint32 {
	return (volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg) & 0x10000) >> 16
}
func (o *SYSCON_Type) SetSYSAHBCLKCTRL_CAN(value uint32) {
	volatile.StoreUint32(&o.SYSAHBCLKCTRL.Reg, volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg)&^(0x20000)|value<<17)
}
func (o *SYSCON_Type) GetSYSAHBCLKCTRL_CAN() uint32 {
	return (volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg) & 0x20000) >> 17
}
func (o *SYSCON_Type) SetSYSAHBCLKCTRL_SSP1(value uint32) {
	volatile.StoreUint32(&o.SYSAHBCLKCTRL.Reg, volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg)&^(0x40000)|value<<18)
}
func (o *SYSCON_Type) GetSYSAHBCLKCTRL_SSP1() uint32 {
	return (volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg) & 0x40000) >> 18
}
func (o *SYSCON_Type) SetSYSAHBCLKCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SYSAHBCLKCTRL.Reg, volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg)&^(0xfff80000)|value<<19)
}
func (o *SYSCON_Type) GetSYSAHBCLKCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SYSAHBCLKCTRL.Reg) & 0xfff80000) >> 19
}

// SYSCON.SSP0CLKDIV: SPI0 clock divider
func (o *SYSCON_Type) SetSSP0CLKDIV_DIV(value uint32) {
	volatile.StoreUint32(&o.SSP0CLKDIV.Reg, volatile.LoadUint32(&o.SSP0CLKDIV.Reg)&^(0xff)|value)
}
func (o *SYSCON_Type) GetSSP0CLKDIV_DIV() uint32 {
	return volatile.LoadUint32(&o.SSP0CLKDIV.Reg) & 0xff
}
func (o *SYSCON_Type) SetSSP0CLKDIV_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SSP0CLKDIV.Reg, volatile.LoadUint32(&o.SSP0CLKDIV.Reg)&^(0xffffff00)|value<<8)
}
func (o *SYSCON_Type) GetSSP0CLKDIV_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SSP0CLKDIV.Reg) & 0xffffff00) >> 8
}

// SYSCON.UARTCLKDIV: UART clock divder
func (o *SYSCON_Type) SetUARTCLKDIV_DIV(value uint32) {
	volatile.StoreUint32(&o.UARTCLKDIV.Reg, volatile.LoadUint32(&o.UARTCLKDIV.Reg)&^(0xff)|value)
}
func (o *SYSCON_Type) GetUARTCLKDIV_DIV() uint32 {
	return volatile.LoadUint32(&o.UARTCLKDIV.Reg) & 0xff
}
func (o *SYSCON_Type) SetUARTCLKDIV_RESERVED(value uint32) {
	volatile.StoreUint32(&o.UARTCLKDIV.Reg, volatile.LoadUint32(&o.UARTCLKDIV.Reg)&^(0xffffff00)|value<<8)
}
func (o *SYSCON_Type) GetUARTCLKDIV_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.UARTCLKDIV.Reg) & 0xffffff00) >> 8
}

// SYSCON.SSP1CLKDIV: SPI1 clock divder
func (o *SYSCON_Type) SetSSP1CLKDIV_DIV(value uint32) {
	volatile.StoreUint32(&o.SSP1CLKDIV.Reg, volatile.LoadUint32(&o.SSP1CLKDIV.Reg)&^(0xff)|value)
}
func (o *SYSCON_Type) GetSSP1CLKDIV_DIV() uint32 {
	return volatile.LoadUint32(&o.SSP1CLKDIV.Reg) & 0xff
}
func (o *SYSCON_Type) SetSSP1CLKDIV_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SSP1CLKDIV.Reg, volatile.LoadUint32(&o.SSP1CLKDIV.Reg)&^(0xffffff00)|value<<8)
}
func (o *SYSCON_Type) GetSSP1CLKDIV_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SSP1CLKDIV.Reg) & 0xffffff00) >> 8
}

// SYSCON.WDTCLKSEL: WDT clock source select
func (o *SYSCON_Type) SetWDTCLKSEL_SEL(value uint32) {
	volatile.StoreUint32(&o.WDTCLKSEL.Reg, volatile.LoadUint32(&o.WDTCLKSEL.Reg)&^(0x3)|value)
}
func (o *SYSCON_Type) GetWDTCLKSEL_SEL() uint32 {
	return volatile.LoadUint32(&o.WDTCLKSEL.Reg) & 0x3
}
func (o *SYSCON_Type) SetWDTCLKSEL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.WDTCLKSEL.Reg, volatile.LoadUint32(&o.WDTCLKSEL.Reg)&^(0xfffffffc)|value<<2)
}
func (o *SYSCON_Type) GetWDTCLKSEL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.WDTCLKSEL.Reg) & 0xfffffffc) >> 2
}

// SYSCON.WDTCLKUEN: WDT clock source update enable
func (o *SYSCON_Type) SetWDTCLKUEN_ENA(value uint32) {
	volatile.StoreUint32(&o.WDTCLKUEN.Reg, volatile.LoadUint32(&o.WDTCLKUEN.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetWDTCLKUEN_ENA() uint32 {
	return volatile.LoadUint32(&o.WDTCLKUEN.Reg) & 0x1
}
func (o *SYSCON_Type) SetWDTCLKUEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.WDTCLKUEN.Reg, volatile.LoadUint32(&o.WDTCLKUEN.Reg)&^(0xfffffffe)|value<<1)
}
func (o *SYSCON_Type) GetWDTCLKUEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.WDTCLKUEN.Reg) & 0xfffffffe) >> 1
}

// SYSCON.WDTCLKDIV: WDT clock divider
func (o *SYSCON_Type) SetWDTCLKDIV_DIV(value uint32) {
	volatile.StoreUint32(&o.WDTCLKDIV.Reg, volatile.LoadUint32(&o.WDTCLKDIV.Reg)&^(0xff)|value)
}
func (o *SYSCON_Type) GetWDTCLKDIV_DIV() uint32 {
	return volatile.LoadUint32(&o.WDTCLKDIV.Reg) & 0xff
}
func (o *SYSCON_Type) SetWDTCLKDIV_RESERVED(value uint32) {
	volatile.StoreUint32(&o.WDTCLKDIV.Reg, volatile.LoadUint32(&o.WDTCLKDIV.Reg)&^(0xffffff00)|value<<8)
}
func (o *SYSCON_Type) GetWDTCLKDIV_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.WDTCLKDIV.Reg) & 0xffffff00) >> 8
}

// SYSCON.CLKOUTCLKSEL: CLKOUT clock source select
func (o *SYSCON_Type) SetCLKOUTCLKSEL_SEL(value uint32) {
	volatile.StoreUint32(&o.CLKOUTCLKSEL.Reg, volatile.LoadUint32(&o.CLKOUTCLKSEL.Reg)&^(0x3)|value)
}
func (o *SYSCON_Type) GetCLKOUTCLKSEL_SEL() uint32 {
	return volatile.LoadUint32(&o.CLKOUTCLKSEL.Reg) & 0x3
}
func (o *SYSCON_Type) SetCLKOUTCLKSEL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLKOUTCLKSEL.Reg, volatile.LoadUint32(&o.CLKOUTCLKSEL.Reg)&^(0xfffffffc)|value<<2)
}
func (o *SYSCON_Type) GetCLKOUTCLKSEL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLKOUTCLKSEL.Reg) & 0xfffffffc) >> 2
}

// SYSCON.CLKOUTUEN: CLKOUT clock source update enable
func (o *SYSCON_Type) SetCLKOUTUEN_ENA(value uint32) {
	volatile.StoreUint32(&o.CLKOUTUEN.Reg, volatile.LoadUint32(&o.CLKOUTUEN.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetCLKOUTUEN_ENA() uint32 {
	return volatile.LoadUint32(&o.CLKOUTUEN.Reg) & 0x1
}
func (o *SYSCON_Type) SetCLKOUTUEN_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLKOUTUEN.Reg, volatile.LoadUint32(&o.CLKOUTUEN.Reg)&^(0xfffffffe)|value<<1)
}
func (o *SYSCON_Type) GetCLKOUTUEN_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLKOUTUEN.Reg) & 0xfffffffe) >> 1
}

// SYSCON.CLKOUTCLKDIV: CLKOUT clock divider
func (o *SYSCON_Type) SetCLKOUTCLKDIV_DIV(value uint32) {
	volatile.StoreUint32(&o.CLKOUTCLKDIV.Reg, volatile.LoadUint32(&o.CLKOUTCLKDIV.Reg)&^(0xff)|value)
}
func (o *SYSCON_Type) GetCLKOUTCLKDIV_DIV() uint32 {
	return volatile.LoadUint32(&o.CLKOUTCLKDIV.Reg) & 0xff
}
func (o *SYSCON_Type) SetCLKOUTCLKDIV_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CLKOUTCLKDIV.Reg, volatile.LoadUint32(&o.CLKOUTCLKDIV.Reg)&^(0xffffff00)|value<<8)
}
func (o *SYSCON_Type) GetCLKOUTCLKDIV_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CLKOUTCLKDIV.Reg) & 0xffffff00) >> 8
}

// SYSCON.PIOPORCAP0: POR captured PIO status 0
func (o *SYSCON_Type) SetPIOPORCAP0_CAPPIO0_n(value uint32) {
	volatile.StoreUint32(&o.PIOPORCAP0.Reg, volatile.LoadUint32(&o.PIOPORCAP0.Reg)&^(0xfff)|value)
}
func (o *SYSCON_Type) GetPIOPORCAP0_CAPPIO0_n() uint32 {
	return volatile.LoadUint32(&o.PIOPORCAP0.Reg) & 0xfff
}
func (o *SYSCON_Type) SetPIOPORCAP0_CAPPIO1_n(value uint32) {
	volatile.StoreUint32(&o.PIOPORCAP0.Reg, volatile.LoadUint32(&o.PIOPORCAP0.Reg)&^(0xfff000)|value<<12)
}
func (o *SYSCON_Type) GetPIOPORCAP0_CAPPIO1_n() uint32 {
	return (volatile.LoadUint32(&o.PIOPORCAP0.Reg) & 0xfff000) >> 12
}
func (o *SYSCON_Type) SetPIOPORCAP0_CAPPIO2_n(value uint32) {
	volatile.StoreUint32(&o.PIOPORCAP0.Reg, volatile.LoadUint32(&o.PIOPORCAP0.Reg)&^(0xff000000)|value<<24)
}
func (o *SYSCON_Type) GetPIOPORCAP0_CAPPIO2_n() uint32 {
	return (volatile.LoadUint32(&o.PIOPORCAP0.Reg) & 0xff000000) >> 24
}

// SYSCON.PIOPORCAP1: POR captured PIO status 1
func (o *SYSCON_Type) SetPIOPORCAP1_CAPPIO2_8(value uint32) {
	volatile.StoreUint32(&o.PIOPORCAP1.Reg, volatile.LoadUint32(&o.PIOPORCAP1.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetPIOPORCAP1_CAPPIO2_8() uint32 {
	return volatile.LoadUint32(&o.PIOPORCAP1.Reg) & 0x1
}
func (o *SYSCON_Type) SetPIOPORCAP1_CAPPIO2_9(value uint32) {
	volatile.StoreUint32(&o.PIOPORCAP1.Reg, volatile.LoadUint32(&o.PIOPORCAP1.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetPIOPORCAP1_CAPPIO2_9() uint32 {
	return (volatile.LoadUint32(&o.PIOPORCAP1.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetPIOPORCAP1_CAPPIO2_10(value uint32) {
	volatile.StoreUint32(&o.PIOPORCAP1.Reg, volatile.LoadUint32(&o.PIOPORCAP1.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetPIOPORCAP1_CAPPIO2_10() uint32 {
	return (volatile.LoadUint32(&o.PIOPORCAP1.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetPIOPORCAP1_CAPPIO2_11(value uint32) {
	volatile.StoreUint32(&o.PIOPORCAP1.Reg, volatile.LoadUint32(&o.PIOPORCAP1.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetPIOPORCAP1_CAPPIO2_11() uint32 {
	return (volatile.LoadUint32(&o.PIOPORCAP1.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetPIOPORCAP1_CAPPIO3_0(value uint32) {
	volatile.StoreUint32(&o.PIOPORCAP1.Reg, volatile.LoadUint32(&o.PIOPORCAP1.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetPIOPORCAP1_CAPPIO3_0() uint32 {
	return (volatile.LoadUint32(&o.PIOPORCAP1.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetPIOPORCAP1_CAPPIO3_1(value uint32) {
	volatile.StoreUint32(&o.PIOPORCAP1.Reg, volatile.LoadUint32(&o.PIOPORCAP1.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetPIOPORCAP1_CAPPIO3_1() uint32 {
	return (volatile.LoadUint32(&o.PIOPORCAP1.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetPIOPORCAP1_CAPPIO3_2(value uint32) {
	volatile.StoreUint32(&o.PIOPORCAP1.Reg, volatile.LoadUint32(&o.PIOPORCAP1.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetPIOPORCAP1_CAPPIO3_2() uint32 {
	return (volatile.LoadUint32(&o.PIOPORCAP1.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetPIOPORCAP1_CAPPIO3_3(value uint32) {
	volatile.StoreUint32(&o.PIOPORCAP1.Reg, volatile.LoadUint32(&o.PIOPORCAP1.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetPIOPORCAP1_CAPPIO3_3() uint32 {
	return (volatile.LoadUint32(&o.PIOPORCAP1.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetPIOPORCAP1_CAPPIO3_4(value uint32) {
	volatile.StoreUint32(&o.PIOPORCAP1.Reg, volatile.LoadUint32(&o.PIOPORCAP1.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetPIOPORCAP1_CAPPIO3_4() uint32 {
	return (volatile.LoadUint32(&o.PIOPORCAP1.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetPIOPORCAP1_CAPPIO3_5(value uint32) {
	volatile.StoreUint32(&o.PIOPORCAP1.Reg, volatile.LoadUint32(&o.PIOPORCAP1.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetPIOPORCAP1_CAPPIO3_5() uint32 {
	return (volatile.LoadUint32(&o.PIOPORCAP1.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetPIOPORCAP1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PIOPORCAP1.Reg, volatile.LoadUint32(&o.PIOPORCAP1.Reg)&^(0xfffffc00)|value<<10)
}
func (o *SYSCON_Type) GetPIOPORCAP1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PIOPORCAP1.Reg) & 0xfffffc00) >> 10
}

// SYSCON.BODCTRL: BOD control
func (o *SYSCON_Type) SetBODCTRL_BODRSTLEV(value uint32) {
	volatile.StoreUint32(&o.BODCTRL.Reg, volatile.LoadUint32(&o.BODCTRL.Reg)&^(0x3)|value)
}
func (o *SYSCON_Type) GetBODCTRL_BODRSTLEV() uint32 {
	return volatile.LoadUint32(&o.BODCTRL.Reg) & 0x3
}
func (o *SYSCON_Type) SetBODCTRL_BODINTVAL(value uint32) {
	volatile.StoreUint32(&o.BODCTRL.Reg, volatile.LoadUint32(&o.BODCTRL.Reg)&^(0xc)|value<<2)
}
func (o *SYSCON_Type) GetBODCTRL_BODINTVAL() uint32 {
	return (volatile.LoadUint32(&o.BODCTRL.Reg) & 0xc) >> 2
}
func (o *SYSCON_Type) SetBODCTRL_BODRSTENA(value uint32) {
	volatile.StoreUint32(&o.BODCTRL.Reg, volatile.LoadUint32(&o.BODCTRL.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetBODCTRL_BODRSTENA() uint32 {
	return (volatile.LoadUint32(&o.BODCTRL.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetBODCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.BODCTRL.Reg, volatile.LoadUint32(&o.BODCTRL.Reg)&^(0xffffffe0)|value<<5)
}
func (o *SYSCON_Type) GetBODCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.BODCTRL.Reg) & 0xffffffe0) >> 5
}

// SYSCON.SYSTCKCAL: System tick counter calibration
func (o *SYSCON_Type) SetSYSTCKCAL_CAL(value uint32) {
	volatile.StoreUint32(&o.SYSTCKCAL.Reg, volatile.LoadUint32(&o.SYSTCKCAL.Reg)&^(0x3ffffff)|value)
}
func (o *SYSCON_Type) GetSYSTCKCAL_CAL() uint32 {
	return volatile.LoadUint32(&o.SYSTCKCAL.Reg) & 0x3ffffff
}
func (o *SYSCON_Type) SetSYSTCKCAL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.SYSTCKCAL.Reg, volatile.LoadUint32(&o.SYSTCKCAL.Reg)&^(0xfc000000)|value<<26)
}
func (o *SYSCON_Type) GetSYSTCKCAL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.SYSTCKCAL.Reg) & 0xfc000000) >> 26
}

// SYSCON.NMISRC: NMI source selection
func (o *SYSCON_Type) SetNMISRC_IRQNO(value uint32) {
	volatile.StoreUint32(&o.NMISRC.Reg, volatile.LoadUint32(&o.NMISRC.Reg)&^(0x1f)|value)
}
func (o *SYSCON_Type) GetNMISRC_IRQNO() uint32 {
	return volatile.LoadUint32(&o.NMISRC.Reg) & 0x1f
}
func (o *SYSCON_Type) SetNMISRC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.NMISRC.Reg, volatile.LoadUint32(&o.NMISRC.Reg)&^(0x7fffffe0)|value<<5)
}
func (o *SYSCON_Type) GetNMISRC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.NMISRC.Reg) & 0x7fffffe0) >> 5
}
func (o *SYSCON_Type) SetNMISRC_NMIEN(value uint32) {
	volatile.StoreUint32(&o.NMISRC.Reg, volatile.LoadUint32(&o.NMISRC.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSCON_Type) GetNMISRC_NMIEN() uint32 {
	return (volatile.LoadUint32(&o.NMISRC.Reg) & 0x80000000) >> 31
}

// SYSCON.STARTAPRP0: Start logic edge control register 0
func (o *SYSCON_Type) SetSTARTAPRP0_APRPIO0_0(value uint32) {
	volatile.StoreUint32(&o.STARTAPRP0.Reg, volatile.LoadUint32(&o.STARTAPRP0.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetSTARTAPRP0_APRPIO0_0() uint32 {
	return volatile.LoadUint32(&o.STARTAPRP0.Reg) & 0x1
}
func (o *SYSCON_Type) SetSTARTAPRP0_APRPIO0_1(value uint32) {
	volatile.StoreUint32(&o.STARTAPRP0.Reg, volatile.LoadUint32(&o.STARTAPRP0.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetSTARTAPRP0_APRPIO0_1() uint32 {
	return (volatile.LoadUint32(&o.STARTAPRP0.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetSTARTAPRP0_APRPIO0_2(value uint32) {
	volatile.StoreUint32(&o.STARTAPRP0.Reg, volatile.LoadUint32(&o.STARTAPRP0.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetSTARTAPRP0_APRPIO0_2() uint32 {
	return (volatile.LoadUint32(&o.STARTAPRP0.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetSTARTAPRP0_APRPIO0_3(value uint32) {
	volatile.StoreUint32(&o.STARTAPRP0.Reg, volatile.LoadUint32(&o.STARTAPRP0.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetSTARTAPRP0_APRPIO0_3() uint32 {
	return (volatile.LoadUint32(&o.STARTAPRP0.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetSTARTAPRP0_APRPIO0_4(value uint32) {
	volatile.StoreUint32(&o.STARTAPRP0.Reg, volatile.LoadUint32(&o.STARTAPRP0.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetSTARTAPRP0_APRPIO0_4() uint32 {
	return (volatile.LoadUint32(&o.STARTAPRP0.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetSTARTAPRP0_APRPIO0_5(value uint32) {
	volatile.StoreUint32(&o.STARTAPRP0.Reg, volatile.LoadUint32(&o.STARTAPRP0.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetSTARTAPRP0_APRPIO0_5() uint32 {
	return (volatile.LoadUint32(&o.STARTAPRP0.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetSTARTAPRP0_APRPIO0_6(value uint32) {
	volatile.StoreUint32(&o.STARTAPRP0.Reg, volatile.LoadUint32(&o.STARTAPRP0.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetSTARTAPRP0_APRPIO0_6() uint32 {
	return (volatile.LoadUint32(&o.STARTAPRP0.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetSTARTAPRP0_APRPIO0_7(value uint32) {
	volatile.StoreUint32(&o.STARTAPRP0.Reg, volatile.LoadUint32(&o.STARTAPRP0.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetSTARTAPRP0_APRPIO0_7() uint32 {
	return (volatile.LoadUint32(&o.STARTAPRP0.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetSTARTAPRP0_APRPIO0_8(value uint32) {
	volatile.StoreUint32(&o.STARTAPRP0.Reg, volatile.LoadUint32(&o.STARTAPRP0.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetSTARTAPRP0_APRPIO0_8() uint32 {
	return (volatile.LoadUint32(&o.STARTAPRP0.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetSTARTAPRP0_APRPIO0_9(value uint32) {
	volatile.StoreUint32(&o.STARTAPRP0.Reg, volatile.LoadUint32(&o.STARTAPRP0.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetSTARTAPRP0_APRPIO0_9() uint32 {
	return (volatile.LoadUint32(&o.STARTAPRP0.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetSTARTAPRP0_APRPIO0_10(value uint32) {
	volatile.StoreUint32(&o.STARTAPRP0.Reg, volatile.LoadUint32(&o.STARTAPRP0.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetSTARTAPRP0_APRPIO0_10() uint32 {
	return (volatile.LoadUint32(&o.STARTAPRP0.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetSTARTAPRP0_APRPIO0_11(value uint32) {
	volatile.StoreUint32(&o.STARTAPRP0.Reg, volatile.LoadUint32(&o.STARTAPRP0.Reg)&^(0x800)|value<<11)
}
func (o *SYSCON_Type) GetSTARTAPRP0_APRPIO0_11() uint32 {
	return (volatile.LoadUint32(&o.STARTAPRP0.Reg) & 0x800) >> 11
}
func (o *SYSCON_Type) SetSTARTAPRP0_APRPIO1_0(value uint32) {
	volatile.StoreUint32(&o.STARTAPRP0.Reg, volatile.LoadUint32(&o.STARTAPRP0.Reg)&^(0x1000)|value<<12)
}
func (o *SYSCON_Type) GetSTARTAPRP0_APRPIO1_0() uint32 {
	return (volatile.LoadUint32(&o.STARTAPRP0.Reg) & 0x1000) >> 12
}
func (o *SYSCON_Type) SetSTARTAPRP0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STARTAPRP0.Reg, volatile.LoadUint32(&o.STARTAPRP0.Reg)&^(0xffffe000)|value<<13)
}
func (o *SYSCON_Type) GetSTARTAPRP0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STARTAPRP0.Reg) & 0xffffe000) >> 13
}

// SYSCON.STARTERP0: Start logic signal enable register 0
func (o *SYSCON_Type) SetSTARTERP0_ERPIO0_0(value uint32) {
	volatile.StoreUint32(&o.STARTERP0.Reg, volatile.LoadUint32(&o.STARTERP0.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetSTARTERP0_ERPIO0_0() uint32 {
	return volatile.LoadUint32(&o.STARTERP0.Reg) & 0x1
}
func (o *SYSCON_Type) SetSTARTERP0_ERPIO0_1(value uint32) {
	volatile.StoreUint32(&o.STARTERP0.Reg, volatile.LoadUint32(&o.STARTERP0.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetSTARTERP0_ERPIO0_1() uint32 {
	return (volatile.LoadUint32(&o.STARTERP0.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetSTARTERP0_ERPIO0_2(value uint32) {
	volatile.StoreUint32(&o.STARTERP0.Reg, volatile.LoadUint32(&o.STARTERP0.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetSTARTERP0_ERPIO0_2() uint32 {
	return (volatile.LoadUint32(&o.STARTERP0.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetSTARTERP0_ERPIO0_3(value uint32) {
	volatile.StoreUint32(&o.STARTERP0.Reg, volatile.LoadUint32(&o.STARTERP0.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetSTARTERP0_ERPIO0_3() uint32 {
	return (volatile.LoadUint32(&o.STARTERP0.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetSTARTERP0_ERPIO0_4(value uint32) {
	volatile.StoreUint32(&o.STARTERP0.Reg, volatile.LoadUint32(&o.STARTERP0.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetSTARTERP0_ERPIO0_4() uint32 {
	return (volatile.LoadUint32(&o.STARTERP0.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetSTARTERP0_ERPIO0_5(value uint32) {
	volatile.StoreUint32(&o.STARTERP0.Reg, volatile.LoadUint32(&o.STARTERP0.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetSTARTERP0_ERPIO0_5() uint32 {
	return (volatile.LoadUint32(&o.STARTERP0.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetSTARTERP0_ERPIO0_6(value uint32) {
	volatile.StoreUint32(&o.STARTERP0.Reg, volatile.LoadUint32(&o.STARTERP0.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetSTARTERP0_ERPIO0_6() uint32 {
	return (volatile.LoadUint32(&o.STARTERP0.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetSTARTERP0_ERPIO0_7(value uint32) {
	volatile.StoreUint32(&o.STARTERP0.Reg, volatile.LoadUint32(&o.STARTERP0.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetSTARTERP0_ERPIO0_7() uint32 {
	return (volatile.LoadUint32(&o.STARTERP0.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetSTARTERP0_ERPIO0_8(value uint32) {
	volatile.StoreUint32(&o.STARTERP0.Reg, volatile.LoadUint32(&o.STARTERP0.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetSTARTERP0_ERPIO0_8() uint32 {
	return (volatile.LoadUint32(&o.STARTERP0.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetSTARTERP0_ERPIO0_9(value uint32) {
	volatile.StoreUint32(&o.STARTERP0.Reg, volatile.LoadUint32(&o.STARTERP0.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetSTARTERP0_ERPIO0_9() uint32 {
	return (volatile.LoadUint32(&o.STARTERP0.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetSTARTERP0_ERPIO0_10(value uint32) {
	volatile.StoreUint32(&o.STARTERP0.Reg, volatile.LoadUint32(&o.STARTERP0.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetSTARTERP0_ERPIO0_10() uint32 {
	return (volatile.LoadUint32(&o.STARTERP0.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetSTARTERP0_ERPIO0_11(value uint32) {
	volatile.StoreUint32(&o.STARTERP0.Reg, volatile.LoadUint32(&o.STARTERP0.Reg)&^(0x800)|value<<11)
}
func (o *SYSCON_Type) GetSTARTERP0_ERPIO0_11() uint32 {
	return (volatile.LoadUint32(&o.STARTERP0.Reg) & 0x800) >> 11
}
func (o *SYSCON_Type) SetSTARTERP0_ERPIO1_0(value uint32) {
	volatile.StoreUint32(&o.STARTERP0.Reg, volatile.LoadUint32(&o.STARTERP0.Reg)&^(0x1000)|value<<12)
}
func (o *SYSCON_Type) GetSTARTERP0_ERPIO1_0() uint32 {
	return (volatile.LoadUint32(&o.STARTERP0.Reg) & 0x1000) >> 12
}
func (o *SYSCON_Type) SetSTARTERP0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STARTERP0.Reg, volatile.LoadUint32(&o.STARTERP0.Reg)&^(0xffffe000)|value<<13)
}
func (o *SYSCON_Type) GetSTARTERP0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STARTERP0.Reg) & 0xffffe000) >> 13
}

// SYSCON.STARTRSRP0CLR: Start logic reset register 0
func (o *SYSCON_Type) SetSTARTRSRP0CLR_RSRPIO0_0(value uint32) {
	volatile.StoreUint32(&o.STARTRSRP0CLR.Reg, volatile.LoadUint32(&o.STARTRSRP0CLR.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetSTARTRSRP0CLR_RSRPIO0_0() uint32 {
	return volatile.LoadUint32(&o.STARTRSRP0CLR.Reg) & 0x1
}
func (o *SYSCON_Type) SetSTARTRSRP0CLR_RSRPIO0_1(value uint32) {
	volatile.StoreUint32(&o.STARTRSRP0CLR.Reg, volatile.LoadUint32(&o.STARTRSRP0CLR.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetSTARTRSRP0CLR_RSRPIO0_1() uint32 {
	return (volatile.LoadUint32(&o.STARTRSRP0CLR.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetSTARTRSRP0CLR_RSRPIO0_2(value uint32) {
	volatile.StoreUint32(&o.STARTRSRP0CLR.Reg, volatile.LoadUint32(&o.STARTRSRP0CLR.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetSTARTRSRP0CLR_RSRPIO0_2() uint32 {
	return (volatile.LoadUint32(&o.STARTRSRP0CLR.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetSTARTRSRP0CLR_RSRPIO0_3(value uint32) {
	volatile.StoreUint32(&o.STARTRSRP0CLR.Reg, volatile.LoadUint32(&o.STARTRSRP0CLR.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetSTARTRSRP0CLR_RSRPIO0_3() uint32 {
	return (volatile.LoadUint32(&o.STARTRSRP0CLR.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetSTARTRSRP0CLR_RSRPIO0_4(value uint32) {
	volatile.StoreUint32(&o.STARTRSRP0CLR.Reg, volatile.LoadUint32(&o.STARTRSRP0CLR.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetSTARTRSRP0CLR_RSRPIO0_4() uint32 {
	return (volatile.LoadUint32(&o.STARTRSRP0CLR.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetSTARTRSRP0CLR_RSRPIO0_5(value uint32) {
	volatile.StoreUint32(&o.STARTRSRP0CLR.Reg, volatile.LoadUint32(&o.STARTRSRP0CLR.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetSTARTRSRP0CLR_RSRPIO0_5() uint32 {
	return (volatile.LoadUint32(&o.STARTRSRP0CLR.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetSTARTRSRP0CLR_RSRPIO0_6(value uint32) {
	volatile.StoreUint32(&o.STARTRSRP0CLR.Reg, volatile.LoadUint32(&o.STARTRSRP0CLR.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetSTARTRSRP0CLR_RSRPIO0_6() uint32 {
	return (volatile.LoadUint32(&o.STARTRSRP0CLR.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetSTARTRSRP0CLR_RSRPIO0_7(value uint32) {
	volatile.StoreUint32(&o.STARTRSRP0CLR.Reg, volatile.LoadUint32(&o.STARTRSRP0CLR.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetSTARTRSRP0CLR_RSRPIO0_7() uint32 {
	return (volatile.LoadUint32(&o.STARTRSRP0CLR.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetSTARTRSRP0CLR_RSRPIO0_8(value uint32) {
	volatile.StoreUint32(&o.STARTRSRP0CLR.Reg, volatile.LoadUint32(&o.STARTRSRP0CLR.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetSTARTRSRP0CLR_RSRPIO0_8() uint32 {
	return (volatile.LoadUint32(&o.STARTRSRP0CLR.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetSTARTRSRP0CLR_RSRPIO0_9(value uint32) {
	volatile.StoreUint32(&o.STARTRSRP0CLR.Reg, volatile.LoadUint32(&o.STARTRSRP0CLR.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetSTARTRSRP0CLR_RSRPIO0_9() uint32 {
	return (volatile.LoadUint32(&o.STARTRSRP0CLR.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetSTARTRSRP0CLR_RSRPIO0_10(value uint32) {
	volatile.StoreUint32(&o.STARTRSRP0CLR.Reg, volatile.LoadUint32(&o.STARTRSRP0CLR.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetSTARTRSRP0CLR_RSRPIO0_10() uint32 {
	return (volatile.LoadUint32(&o.STARTRSRP0CLR.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetSTARTRSRP0CLR_RSRPIO0_11(value uint32) {
	volatile.StoreUint32(&o.STARTRSRP0CLR.Reg, volatile.LoadUint32(&o.STARTRSRP0CLR.Reg)&^(0x800)|value<<11)
}
func (o *SYSCON_Type) GetSTARTRSRP0CLR_RSRPIO0_11() uint32 {
	return (volatile.LoadUint32(&o.STARTRSRP0CLR.Reg) & 0x800) >> 11
}
func (o *SYSCON_Type) SetSTARTRSRP0CLR_RSRPIO1_0(value uint32) {
	volatile.StoreUint32(&o.STARTRSRP0CLR.Reg, volatile.LoadUint32(&o.STARTRSRP0CLR.Reg)&^(0x1000)|value<<12)
}
func (o *SYSCON_Type) GetSTARTRSRP0CLR_RSRPIO1_0() uint32 {
	return (volatile.LoadUint32(&o.STARTRSRP0CLR.Reg) & 0x1000) >> 12
}
func (o *SYSCON_Type) SetSTARTRSRP0CLR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STARTRSRP0CLR.Reg, volatile.LoadUint32(&o.STARTRSRP0CLR.Reg)&^(0xffffe000)|value<<13)
}
func (o *SYSCON_Type) GetSTARTRSRP0CLR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STARTRSRP0CLR.Reg) & 0xffffe000) >> 13
}

// SYSCON.STARTSRP0: Start logic status register 0
func (o *SYSCON_Type) SetSTARTSRP0_SRPIO0_0(value uint32) {
	volatile.StoreUint32(&o.STARTSRP0.Reg, volatile.LoadUint32(&o.STARTSRP0.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetSTARTSRP0_SRPIO0_0() uint32 {
	return volatile.LoadUint32(&o.STARTSRP0.Reg) & 0x1
}
func (o *SYSCON_Type) SetSTARTSRP0_SRPIO0_1(value uint32) {
	volatile.StoreUint32(&o.STARTSRP0.Reg, volatile.LoadUint32(&o.STARTSRP0.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetSTARTSRP0_SRPIO0_1() uint32 {
	return (volatile.LoadUint32(&o.STARTSRP0.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetSTARTSRP0_SRPIO0_2(value uint32) {
	volatile.StoreUint32(&o.STARTSRP0.Reg, volatile.LoadUint32(&o.STARTSRP0.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetSTARTSRP0_SRPIO0_2() uint32 {
	return (volatile.LoadUint32(&o.STARTSRP0.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetSTARTSRP0_SRPIO0_3(value uint32) {
	volatile.StoreUint32(&o.STARTSRP0.Reg, volatile.LoadUint32(&o.STARTSRP0.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetSTARTSRP0_SRPIO0_3() uint32 {
	return (volatile.LoadUint32(&o.STARTSRP0.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetSTARTSRP0_SRPIO0_4(value uint32) {
	volatile.StoreUint32(&o.STARTSRP0.Reg, volatile.LoadUint32(&o.STARTSRP0.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetSTARTSRP0_SRPIO0_4() uint32 {
	return (volatile.LoadUint32(&o.STARTSRP0.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetSTARTSRP0_SRPIO0_5(value uint32) {
	volatile.StoreUint32(&o.STARTSRP0.Reg, volatile.LoadUint32(&o.STARTSRP0.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetSTARTSRP0_SRPIO0_5() uint32 {
	return (volatile.LoadUint32(&o.STARTSRP0.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetSTARTSRP0_SRPIO0_6(value uint32) {
	volatile.StoreUint32(&o.STARTSRP0.Reg, volatile.LoadUint32(&o.STARTSRP0.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetSTARTSRP0_SRPIO0_6() uint32 {
	return (volatile.LoadUint32(&o.STARTSRP0.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetSTARTSRP0_SRPIO0_7(value uint32) {
	volatile.StoreUint32(&o.STARTSRP0.Reg, volatile.LoadUint32(&o.STARTSRP0.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetSTARTSRP0_SRPIO0_7() uint32 {
	return (volatile.LoadUint32(&o.STARTSRP0.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetSTARTSRP0_SRPIO0_8(value uint32) {
	volatile.StoreUint32(&o.STARTSRP0.Reg, volatile.LoadUint32(&o.STARTSRP0.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetSTARTSRP0_SRPIO0_8() uint32 {
	return (volatile.LoadUint32(&o.STARTSRP0.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetSTARTSRP0_SRPIO0_9(value uint32) {
	volatile.StoreUint32(&o.STARTSRP0.Reg, volatile.LoadUint32(&o.STARTSRP0.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetSTARTSRP0_SRPIO0_9() uint32 {
	return (volatile.LoadUint32(&o.STARTSRP0.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetSTARTSRP0_SRPIO0_10(value uint32) {
	volatile.StoreUint32(&o.STARTSRP0.Reg, volatile.LoadUint32(&o.STARTSRP0.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetSTARTSRP0_SRPIO0_10() uint32 {
	return (volatile.LoadUint32(&o.STARTSRP0.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetSTARTSRP0_SRPIO0_11(value uint32) {
	volatile.StoreUint32(&o.STARTSRP0.Reg, volatile.LoadUint32(&o.STARTSRP0.Reg)&^(0x800)|value<<11)
}
func (o *SYSCON_Type) GetSTARTSRP0_SRPIO0_11() uint32 {
	return (volatile.LoadUint32(&o.STARTSRP0.Reg) & 0x800) >> 11
}
func (o *SYSCON_Type) SetSTARTSRP0_SRPIO1_0(value uint32) {
	volatile.StoreUint32(&o.STARTSRP0.Reg, volatile.LoadUint32(&o.STARTSRP0.Reg)&^(0x1000)|value<<12)
}
func (o *SYSCON_Type) GetSTARTSRP0_SRPIO1_0() uint32 {
	return (volatile.LoadUint32(&o.STARTSRP0.Reg) & 0x1000) >> 12
}
func (o *SYSCON_Type) SetSTARTSRP0_RESERVED(value uint32) {
	volatile.StoreUint32(&o.STARTSRP0.Reg, volatile.LoadUint32(&o.STARTSRP0.Reg)&^(0xffffe000)|value<<13)
}
func (o *SYSCON_Type) GetSTARTSRP0_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.STARTSRP0.Reg) & 0xffffe000) >> 13
}

// SYSCON.PDSLEEPCFG: Power-down states in Deep-sleep mode
func (o *SYSCON_Type) SetPDSLEEPCFG_NOTUSED0(value uint32) {
	volatile.StoreUint32(&o.PDSLEEPCFG.Reg, volatile.LoadUint32(&o.PDSLEEPCFG.Reg)&^(0x7)|value)
}
func (o *SYSCON_Type) GetPDSLEEPCFG_NOTUSED0() uint32 {
	return volatile.LoadUint32(&o.PDSLEEPCFG.Reg) & 0x7
}
func (o *SYSCON_Type) SetPDSLEEPCFG_BOD_PD(value uint32) {
	volatile.StoreUint32(&o.PDSLEEPCFG.Reg, volatile.LoadUint32(&o.PDSLEEPCFG.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetPDSLEEPCFG_BOD_PD() uint32 {
	return (volatile.LoadUint32(&o.PDSLEEPCFG.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetPDSLEEPCFG_NOTUSED1(value uint32) {
	volatile.StoreUint32(&o.PDSLEEPCFG.Reg, volatile.LoadUint32(&o.PDSLEEPCFG.Reg)&^(0x30)|value<<4)
}
func (o *SYSCON_Type) GetPDSLEEPCFG_NOTUSED1() uint32 {
	return (volatile.LoadUint32(&o.PDSLEEPCFG.Reg) & 0x30) >> 4
}
func (o *SYSCON_Type) SetPDSLEEPCFG_WDTOSC_PD(value uint32) {
	volatile.StoreUint32(&o.PDSLEEPCFG.Reg, volatile.LoadUint32(&o.PDSLEEPCFG.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetPDSLEEPCFG_WDTOSC_PD() uint32 {
	return (volatile.LoadUint32(&o.PDSLEEPCFG.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetPDSLEEPCFG_NOTUSED2(value uint32) {
	volatile.StoreUint32(&o.PDSLEEPCFG.Reg, volatile.LoadUint32(&o.PDSLEEPCFG.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetPDSLEEPCFG_NOTUSED2() uint32 {
	return (volatile.LoadUint32(&o.PDSLEEPCFG.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetPDSLEEPCFG_NOTUSED3(value uint32) {
	volatile.StoreUint32(&o.PDSLEEPCFG.Reg, volatile.LoadUint32(&o.PDSLEEPCFG.Reg)&^(0x700)|value<<8)
}
func (o *SYSCON_Type) GetPDSLEEPCFG_NOTUSED3() uint32 {
	return (volatile.LoadUint32(&o.PDSLEEPCFG.Reg) & 0x700) >> 8
}
func (o *SYSCON_Type) SetPDSLEEPCFG_NOTUSED4(value uint32) {
	volatile.StoreUint32(&o.PDSLEEPCFG.Reg, volatile.LoadUint32(&o.PDSLEEPCFG.Reg)&^(0x1800)|value<<11)
}
func (o *SYSCON_Type) GetPDSLEEPCFG_NOTUSED4() uint32 {
	return (volatile.LoadUint32(&o.PDSLEEPCFG.Reg) & 0x1800) >> 11
}
func (o *SYSCON_Type) SetPDSLEEPCFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PDSLEEPCFG.Reg, volatile.LoadUint32(&o.PDSLEEPCFG.Reg)&^(0xffffe000)|value<<13)
}
func (o *SYSCON_Type) GetPDSLEEPCFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PDSLEEPCFG.Reg) & 0xffffe000) >> 13
}

// SYSCON.PDAWAKECFG: Power-down states after wake-up from Deep-sleep mode
func (o *SYSCON_Type) SetPDAWAKECFG_IRCOUT_PD(value uint32) {
	volatile.StoreUint32(&o.PDAWAKECFG.Reg, volatile.LoadUint32(&o.PDAWAKECFG.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetPDAWAKECFG_IRCOUT_PD() uint32 {
	return volatile.LoadUint32(&o.PDAWAKECFG.Reg) & 0x1
}
func (o *SYSCON_Type) SetPDAWAKECFG_IRC_PD(value uint32) {
	volatile.StoreUint32(&o.PDAWAKECFG.Reg, volatile.LoadUint32(&o.PDAWAKECFG.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetPDAWAKECFG_IRC_PD() uint32 {
	return (volatile.LoadUint32(&o.PDAWAKECFG.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetPDAWAKECFG_FLASH_PD(value uint32) {
	volatile.StoreUint32(&o.PDAWAKECFG.Reg, volatile.LoadUint32(&o.PDAWAKECFG.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetPDAWAKECFG_FLASH_PD() uint32 {
	return (volatile.LoadUint32(&o.PDAWAKECFG.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetPDAWAKECFG_BOD_PD(value uint32) {
	volatile.StoreUint32(&o.PDAWAKECFG.Reg, volatile.LoadUint32(&o.PDAWAKECFG.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetPDAWAKECFG_BOD_PD() uint32 {
	return (volatile.LoadUint32(&o.PDAWAKECFG.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetPDAWAKECFG_ADC_PD(value uint32) {
	volatile.StoreUint32(&o.PDAWAKECFG.Reg, volatile.LoadUint32(&o.PDAWAKECFG.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetPDAWAKECFG_ADC_PD() uint32 {
	return (volatile.LoadUint32(&o.PDAWAKECFG.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetPDAWAKECFG_SYSOSC_PD(value uint32) {
	volatile.StoreUint32(&o.PDAWAKECFG.Reg, volatile.LoadUint32(&o.PDAWAKECFG.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetPDAWAKECFG_SYSOSC_PD() uint32 {
	return (volatile.LoadUint32(&o.PDAWAKECFG.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetPDAWAKECFG_WDTOSC_PD(value uint32) {
	volatile.StoreUint32(&o.PDAWAKECFG.Reg, volatile.LoadUint32(&o.PDAWAKECFG.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetPDAWAKECFG_WDTOSC_PD() uint32 {
	return (volatile.LoadUint32(&o.PDAWAKECFG.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetPDAWAKECFG_SYSPLL_PD(value uint32) {
	volatile.StoreUint32(&o.PDAWAKECFG.Reg, volatile.LoadUint32(&o.PDAWAKECFG.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetPDAWAKECFG_SYSPLL_PD() uint32 {
	return (volatile.LoadUint32(&o.PDAWAKECFG.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetPDAWAKECFG_NOTUSED0(value uint32) {
	volatile.StoreUint32(&o.PDAWAKECFG.Reg, volatile.LoadUint32(&o.PDAWAKECFG.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetPDAWAKECFG_NOTUSED0() uint32 {
	return (volatile.LoadUint32(&o.PDAWAKECFG.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetPDAWAKECFG_NOTUSED1(value uint32) {
	volatile.StoreUint32(&o.PDAWAKECFG.Reg, volatile.LoadUint32(&o.PDAWAKECFG.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetPDAWAKECFG_NOTUSED1() uint32 {
	return (volatile.LoadUint32(&o.PDAWAKECFG.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetPDAWAKECFG_NOTUSED2(value uint32) {
	volatile.StoreUint32(&o.PDAWAKECFG.Reg, volatile.LoadUint32(&o.PDAWAKECFG.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetPDAWAKECFG_NOTUSED2() uint32 {
	return (volatile.LoadUint32(&o.PDAWAKECFG.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetPDAWAKECFG_NOTUSED3(value uint32) {
	volatile.StoreUint32(&o.PDAWAKECFG.Reg, volatile.LoadUint32(&o.PDAWAKECFG.Reg)&^(0x800)|value<<11)
}
func (o *SYSCON_Type) GetPDAWAKECFG_NOTUSED3() uint32 {
	return (volatile.LoadUint32(&o.PDAWAKECFG.Reg) & 0x800) >> 11
}
func (o *SYSCON_Type) SetPDAWAKECFG_NOTUSED4(value uint32) {
	volatile.StoreUint32(&o.PDAWAKECFG.Reg, volatile.LoadUint32(&o.PDAWAKECFG.Reg)&^(0x1000)|value<<12)
}
func (o *SYSCON_Type) GetPDAWAKECFG_NOTUSED4() uint32 {
	return (volatile.LoadUint32(&o.PDAWAKECFG.Reg) & 0x1000) >> 12
}
func (o *SYSCON_Type) SetPDAWAKECFG_NOTUSED5(value uint32) {
	volatile.StoreUint32(&o.PDAWAKECFG.Reg, volatile.LoadUint32(&o.PDAWAKECFG.Reg)&^(0xe000)|value<<13)
}
func (o *SYSCON_Type) GetPDAWAKECFG_NOTUSED5() uint32 {
	return (volatile.LoadUint32(&o.PDAWAKECFG.Reg) & 0xe000) >> 13
}
func (o *SYSCON_Type) SetPDAWAKECFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PDAWAKECFG.Reg, volatile.LoadUint32(&o.PDAWAKECFG.Reg)&^(0xffff0000)|value<<16)
}
func (o *SYSCON_Type) GetPDAWAKECFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PDAWAKECFG.Reg) & 0xffff0000) >> 16
}

// SYSCON.PDRUNCFG: Power-down configuration register
func (o *SYSCON_Type) SetPDRUNCFG_IRCOUT_PD(value uint32) {
	volatile.StoreUint32(&o.PDRUNCFG.Reg, volatile.LoadUint32(&o.PDRUNCFG.Reg)&^(0x1)|value)
}
func (o *SYSCON_Type) GetPDRUNCFG_IRCOUT_PD() uint32 {
	return volatile.LoadUint32(&o.PDRUNCFG.Reg) & 0x1
}
func (o *SYSCON_Type) SetPDRUNCFG_IRC_PD(value uint32) {
	volatile.StoreUint32(&o.PDRUNCFG.Reg, volatile.LoadUint32(&o.PDRUNCFG.Reg)&^(0x2)|value<<1)
}
func (o *SYSCON_Type) GetPDRUNCFG_IRC_PD() uint32 {
	return (volatile.LoadUint32(&o.PDRUNCFG.Reg) & 0x2) >> 1
}
func (o *SYSCON_Type) SetPDRUNCFG_FLASH_PD(value uint32) {
	volatile.StoreUint32(&o.PDRUNCFG.Reg, volatile.LoadUint32(&o.PDRUNCFG.Reg)&^(0x4)|value<<2)
}
func (o *SYSCON_Type) GetPDRUNCFG_FLASH_PD() uint32 {
	return (volatile.LoadUint32(&o.PDRUNCFG.Reg) & 0x4) >> 2
}
func (o *SYSCON_Type) SetPDRUNCFG_BOD_PD(value uint32) {
	volatile.StoreUint32(&o.PDRUNCFG.Reg, volatile.LoadUint32(&o.PDRUNCFG.Reg)&^(0x8)|value<<3)
}
func (o *SYSCON_Type) GetPDRUNCFG_BOD_PD() uint32 {
	return (volatile.LoadUint32(&o.PDRUNCFG.Reg) & 0x8) >> 3
}
func (o *SYSCON_Type) SetPDRUNCFG_ADC_PD(value uint32) {
	volatile.StoreUint32(&o.PDRUNCFG.Reg, volatile.LoadUint32(&o.PDRUNCFG.Reg)&^(0x10)|value<<4)
}
func (o *SYSCON_Type) GetPDRUNCFG_ADC_PD() uint32 {
	return (volatile.LoadUint32(&o.PDRUNCFG.Reg) & 0x10) >> 4
}
func (o *SYSCON_Type) SetPDRUNCFG_SYSOSC_PD(value uint32) {
	volatile.StoreUint32(&o.PDRUNCFG.Reg, volatile.LoadUint32(&o.PDRUNCFG.Reg)&^(0x20)|value<<5)
}
func (o *SYSCON_Type) GetPDRUNCFG_SYSOSC_PD() uint32 {
	return (volatile.LoadUint32(&o.PDRUNCFG.Reg) & 0x20) >> 5
}
func (o *SYSCON_Type) SetPDRUNCFG_WDTOSC_PD(value uint32) {
	volatile.StoreUint32(&o.PDRUNCFG.Reg, volatile.LoadUint32(&o.PDRUNCFG.Reg)&^(0x40)|value<<6)
}
func (o *SYSCON_Type) GetPDRUNCFG_WDTOSC_PD() uint32 {
	return (volatile.LoadUint32(&o.PDRUNCFG.Reg) & 0x40) >> 6
}
func (o *SYSCON_Type) SetPDRUNCFG_SYSPLL_PD(value uint32) {
	volatile.StoreUint32(&o.PDRUNCFG.Reg, volatile.LoadUint32(&o.PDRUNCFG.Reg)&^(0x80)|value<<7)
}
func (o *SYSCON_Type) GetPDRUNCFG_SYSPLL_PD() uint32 {
	return (volatile.LoadUint32(&o.PDRUNCFG.Reg) & 0x80) >> 7
}
func (o *SYSCON_Type) SetPDRUNCFG_NOTUSED0(value uint32) {
	volatile.StoreUint32(&o.PDRUNCFG.Reg, volatile.LoadUint32(&o.PDRUNCFG.Reg)&^(0x100)|value<<8)
}
func (o *SYSCON_Type) GetPDRUNCFG_NOTUSED0() uint32 {
	return (volatile.LoadUint32(&o.PDRUNCFG.Reg) & 0x100) >> 8
}
func (o *SYSCON_Type) SetPDRUNCFG_NOTUSED1(value uint32) {
	volatile.StoreUint32(&o.PDRUNCFG.Reg, volatile.LoadUint32(&o.PDRUNCFG.Reg)&^(0x200)|value<<9)
}
func (o *SYSCON_Type) GetPDRUNCFG_NOTUSED1() uint32 {
	return (volatile.LoadUint32(&o.PDRUNCFG.Reg) & 0x200) >> 9
}
func (o *SYSCON_Type) SetPDRUNCFG_NOTUSED2(value uint32) {
	volatile.StoreUint32(&o.PDRUNCFG.Reg, volatile.LoadUint32(&o.PDRUNCFG.Reg)&^(0x400)|value<<10)
}
func (o *SYSCON_Type) GetPDRUNCFG_NOTUSED2() uint32 {
	return (volatile.LoadUint32(&o.PDRUNCFG.Reg) & 0x400) >> 10
}
func (o *SYSCON_Type) SetPDRUNCFG_NOTUSED3(value uint32) {
	volatile.StoreUint32(&o.PDRUNCFG.Reg, volatile.LoadUint32(&o.PDRUNCFG.Reg)&^(0x800)|value<<11)
}
func (o *SYSCON_Type) GetPDRUNCFG_NOTUSED3() uint32 {
	return (volatile.LoadUint32(&o.PDRUNCFG.Reg) & 0x800) >> 11
}
func (o *SYSCON_Type) SetPDRUNCFG_NOTUSED4(value uint32) {
	volatile.StoreUint32(&o.PDRUNCFG.Reg, volatile.LoadUint32(&o.PDRUNCFG.Reg)&^(0x1000)|value<<12)
}
func (o *SYSCON_Type) GetPDRUNCFG_NOTUSED4() uint32 {
	return (volatile.LoadUint32(&o.PDRUNCFG.Reg) & 0x1000) >> 12
}
func (o *SYSCON_Type) SetPDRUNCFG_NOTUSED5(value uint32) {
	volatile.StoreUint32(&o.PDRUNCFG.Reg, volatile.LoadUint32(&o.PDRUNCFG.Reg)&^(0xe000)|value<<13)
}
func (o *SYSCON_Type) GetPDRUNCFG_NOTUSED5() uint32 {
	return (volatile.LoadUint32(&o.PDRUNCFG.Reg) & 0xe000) >> 13
}
func (o *SYSCON_Type) SetPDRUNCFG_RESERVED(value uint32) {
	volatile.StoreUint32(&o.PDRUNCFG.Reg, volatile.LoadUint32(&o.PDRUNCFG.Reg)&^(0xffff0000)|value<<16)
}
func (o *SYSCON_Type) GetPDRUNCFG_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.PDRUNCFG.Reg) & 0xffff0000) >> 16
}

// SYSCON.DEVICE_ID: Device ID register 0 for parts LPC1100, LPC1100C, LPC1100L.
func (o *SYSCON_Type) SetDEVICE_ID(value uint32) {
	volatile.StoreUint32(&o.DEVICE_ID.Reg, value)
}
func (o *SYSCON_Type) GetDEVICE_ID() uint32 {
	return volatile.LoadUint32(&o.DEVICE_ID.Reg)
}

// Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx C_CAN controller Modification date=9/19/2011 Major revision=7 Minor revision=not available
type C_CAN_Type struct {
	CANCNTL         volatile.Register32 // 0x0
	CANSTAT         volatile.Register32 // 0x4
	CANEC           volatile.Register32 // 0x8
	CANBT           volatile.Register32 // 0xC
	CANINT          volatile.Register32 // 0x10
	CANTEST         volatile.Register32 // 0x14
	CANBRPE         volatile.Register32 // 0x18
	_               [4]byte
	CANIF1_CMDREQ   volatile.Register32 // 0x20
	CANIF1_CMDMSK_W volatile.Register32 // 0x24
	CANIF1_MSK1     volatile.Register32 // 0x28
	CANIF1_MSK2     volatile.Register32 // 0x2C
	CANIF1_ARB1     volatile.Register32 // 0x30
	CANIF1_ARB2     volatile.Register32 // 0x34
	CANIF1_MCTRL    volatile.Register32 // 0x38
	CANIF1_DA1      volatile.Register32 // 0x3C
	CANIF1_DA2      volatile.Register32 // 0x40
	CANIF1_DB1      volatile.Register32 // 0x44
	CANIF1_DB2      volatile.Register32 // 0x48
	_               [52]byte
	CANIF2_CMDREQ   volatile.Register32 // 0x80
	CANIF2_CMDMSK_W volatile.Register32 // 0x84
	CANIF2_MSK1     volatile.Register32 // 0x88
	CANIF2_MSK2     volatile.Register32 // 0x8C
	CANIF2_ARB1     volatile.Register32 // 0x90
	CANIF2_ARB2     volatile.Register32 // 0x94
	CANIF2_MCTRL    volatile.Register32 // 0x98
	CANIF2_DA1      volatile.Register32 // 0x9C
	CANIF2_DA2      volatile.Register32 // 0xA0
	CANIF2_DB1      volatile.Register32 // 0xA4
	CANIF2_DB2      volatile.Register32 // 0xA8
	_               [84]byte
	CANTXREQ1       volatile.Register32 // 0x100
	CANTXREQ2       volatile.Register32 // 0x104
	_               [24]byte
	CANND1          volatile.Register32 // 0x120
	CANND2          volatile.Register32 // 0x124
	_               [24]byte
	CANIR1          volatile.Register32 // 0x140
	CANIR2          volatile.Register32 // 0x144
	_               [24]byte
	CANMSGV1        volatile.Register32 // 0x160
	CANMSGV2        volatile.Register32 // 0x164
	_               [24]byte
	CANCLKDIV       volatile.Register32 // 0x180
}

// C_CAN.CANCNTL: CAN control
func (o *C_CAN_Type) SetCANCNTL_INIT(value uint32) {
	volatile.StoreUint32(&o.CANCNTL.Reg, volatile.LoadUint32(&o.CANCNTL.Reg)&^(0x1)|value)
}
func (o *C_CAN_Type) GetCANCNTL_INIT() uint32 {
	return volatile.LoadUint32(&o.CANCNTL.Reg) & 0x1
}
func (o *C_CAN_Type) SetCANCNTL_IE(value uint32) {
	volatile.StoreUint32(&o.CANCNTL.Reg, volatile.LoadUint32(&o.CANCNTL.Reg)&^(0x2)|value<<1)
}
func (o *C_CAN_Type) GetCANCNTL_IE() uint32 {
	return (volatile.LoadUint32(&o.CANCNTL.Reg) & 0x2) >> 1
}
func (o *C_CAN_Type) SetCANCNTL_SIE(value uint32) {
	volatile.StoreUint32(&o.CANCNTL.Reg, volatile.LoadUint32(&o.CANCNTL.Reg)&^(0x4)|value<<2)
}
func (o *C_CAN_Type) GetCANCNTL_SIE() uint32 {
	return (volatile.LoadUint32(&o.CANCNTL.Reg) & 0x4) >> 2
}
func (o *C_CAN_Type) SetCANCNTL_EIE(value uint32) {
	volatile.StoreUint32(&o.CANCNTL.Reg, volatile.LoadUint32(&o.CANCNTL.Reg)&^(0x8)|value<<3)
}
func (o *C_CAN_Type) GetCANCNTL_EIE() uint32 {
	return (volatile.LoadUint32(&o.CANCNTL.Reg) & 0x8) >> 3
}
func (o *C_CAN_Type) SetCANCNTL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANCNTL.Reg, volatile.LoadUint32(&o.CANCNTL.Reg)&^(0x10)|value<<4)
}
func (o *C_CAN_Type) GetCANCNTL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANCNTL.Reg) & 0x10) >> 4
}
func (o *C_CAN_Type) SetCANCNTL_DAR(value uint32) {
	volatile.StoreUint32(&o.CANCNTL.Reg, volatile.LoadUint32(&o.CANCNTL.Reg)&^(0x20)|value<<5)
}
func (o *C_CAN_Type) GetCANCNTL_DAR() uint32 {
	return (volatile.LoadUint32(&o.CANCNTL.Reg) & 0x20) >> 5
}
func (o *C_CAN_Type) SetCANCNTL_CCE(value uint32) {
	volatile.StoreUint32(&o.CANCNTL.Reg, volatile.LoadUint32(&o.CANCNTL.Reg)&^(0x40)|value<<6)
}
func (o *C_CAN_Type) GetCANCNTL_CCE() uint32 {
	return (volatile.LoadUint32(&o.CANCNTL.Reg) & 0x40) >> 6
}
func (o *C_CAN_Type) SetCANCNTL_TEST(value uint32) {
	volatile.StoreUint32(&o.CANCNTL.Reg, volatile.LoadUint32(&o.CANCNTL.Reg)&^(0x80)|value<<7)
}
func (o *C_CAN_Type) GetCANCNTL_TEST() uint32 {
	return (volatile.LoadUint32(&o.CANCNTL.Reg) & 0x80) >> 7
}
func (o *C_CAN_Type) SetCANCNTL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANCNTL.Reg, volatile.LoadUint32(&o.CANCNTL.Reg)&^(0xffffff00)|value<<8)
}
func (o *C_CAN_Type) GetCANCNTL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANCNTL.Reg) & 0xffffff00) >> 8
}

// C_CAN.CANSTAT: Status register
func (o *C_CAN_Type) SetCANSTAT_LEC(value uint32) {
	volatile.StoreUint32(&o.CANSTAT.Reg, volatile.LoadUint32(&o.CANSTAT.Reg)&^(0x7)|value)
}
func (o *C_CAN_Type) GetCANSTAT_LEC() uint32 {
	return volatile.LoadUint32(&o.CANSTAT.Reg) & 0x7
}
func (o *C_CAN_Type) SetCANSTAT_TXOK(value uint32) {
	volatile.StoreUint32(&o.CANSTAT.Reg, volatile.LoadUint32(&o.CANSTAT.Reg)&^(0x8)|value<<3)
}
func (o *C_CAN_Type) GetCANSTAT_TXOK() uint32 {
	return (volatile.LoadUint32(&o.CANSTAT.Reg) & 0x8) >> 3
}
func (o *C_CAN_Type) SetCANSTAT_RXOK(value uint32) {
	volatile.StoreUint32(&o.CANSTAT.Reg, volatile.LoadUint32(&o.CANSTAT.Reg)&^(0x10)|value<<4)
}
func (o *C_CAN_Type) GetCANSTAT_RXOK() uint32 {
	return (volatile.LoadUint32(&o.CANSTAT.Reg) & 0x10) >> 4
}
func (o *C_CAN_Type) SetCANSTAT_EPASS(value uint32) {
	volatile.StoreUint32(&o.CANSTAT.Reg, volatile.LoadUint32(&o.CANSTAT.Reg)&^(0x20)|value<<5)
}
func (o *C_CAN_Type) GetCANSTAT_EPASS() uint32 {
	return (volatile.LoadUint32(&o.CANSTAT.Reg) & 0x20) >> 5
}
func (o *C_CAN_Type) SetCANSTAT_EWARN(value uint32) {
	volatile.StoreUint32(&o.CANSTAT.Reg, volatile.LoadUint32(&o.CANSTAT.Reg)&^(0x40)|value<<6)
}
func (o *C_CAN_Type) GetCANSTAT_EWARN() uint32 {
	return (volatile.LoadUint32(&o.CANSTAT.Reg) & 0x40) >> 6
}
func (o *C_CAN_Type) SetCANSTAT_BOFF(value uint32) {
	volatile.StoreUint32(&o.CANSTAT.Reg, volatile.LoadUint32(&o.CANSTAT.Reg)&^(0x80)|value<<7)
}
func (o *C_CAN_Type) GetCANSTAT_BOFF() uint32 {
	return (volatile.LoadUint32(&o.CANSTAT.Reg) & 0x80) >> 7
}
func (o *C_CAN_Type) SetCANSTAT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANSTAT.Reg, volatile.LoadUint32(&o.CANSTAT.Reg)&^(0xffffff00)|value<<8)
}
func (o *C_CAN_Type) GetCANSTAT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANSTAT.Reg) & 0xffffff00) >> 8
}

// C_CAN.CANEC: Error counter
func (o *C_CAN_Type) SetCANEC_TEC_7_0(value uint32) {
	volatile.StoreUint32(&o.CANEC.Reg, volatile.LoadUint32(&o.CANEC.Reg)&^(0xff)|value)
}
func (o *C_CAN_Type) GetCANEC_TEC_7_0() uint32 {
	return volatile.LoadUint32(&o.CANEC.Reg) & 0xff
}
func (o *C_CAN_Type) SetCANEC_REC_6_0(value uint32) {
	volatile.StoreUint32(&o.CANEC.Reg, volatile.LoadUint32(&o.CANEC.Reg)&^(0x7f00)|value<<8)
}
func (o *C_CAN_Type) GetCANEC_REC_6_0() uint32 {
	return (volatile.LoadUint32(&o.CANEC.Reg) & 0x7f00) >> 8
}
func (o *C_CAN_Type) SetCANEC_RP(value uint32) {
	volatile.StoreUint32(&o.CANEC.Reg, volatile.LoadUint32(&o.CANEC.Reg)&^(0x8000)|value<<15)
}
func (o *C_CAN_Type) GetCANEC_RP() uint32 {
	return (volatile.LoadUint32(&o.CANEC.Reg) & 0x8000) >> 15
}
func (o *C_CAN_Type) SetCANEC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANEC.Reg, volatile.LoadUint32(&o.CANEC.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANEC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANEC.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANBT: Bit timing register
func (o *C_CAN_Type) SetCANBT_BRP(value uint32) {
	volatile.StoreUint32(&o.CANBT.Reg, volatile.LoadUint32(&o.CANBT.Reg)&^(0x3f)|value)
}
func (o *C_CAN_Type) GetCANBT_BRP() uint32 {
	return volatile.LoadUint32(&o.CANBT.Reg) & 0x3f
}
func (o *C_CAN_Type) SetCANBT_SJW(value uint32) {
	volatile.StoreUint32(&o.CANBT.Reg, volatile.LoadUint32(&o.CANBT.Reg)&^(0xc0)|value<<6)
}
func (o *C_CAN_Type) GetCANBT_SJW() uint32 {
	return (volatile.LoadUint32(&o.CANBT.Reg) & 0xc0) >> 6
}
func (o *C_CAN_Type) SetCANBT_TSEG1(value uint32) {
	volatile.StoreUint32(&o.CANBT.Reg, volatile.LoadUint32(&o.CANBT.Reg)&^(0xf00)|value<<8)
}
func (o *C_CAN_Type) GetCANBT_TSEG1() uint32 {
	return (volatile.LoadUint32(&o.CANBT.Reg) & 0xf00) >> 8
}
func (o *C_CAN_Type) SetCANBT_TSEG2(value uint32) {
	volatile.StoreUint32(&o.CANBT.Reg, volatile.LoadUint32(&o.CANBT.Reg)&^(0x7000)|value<<12)
}
func (o *C_CAN_Type) GetCANBT_TSEG2() uint32 {
	return (volatile.LoadUint32(&o.CANBT.Reg) & 0x7000) >> 12
}
func (o *C_CAN_Type) SetCANBT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANBT.Reg, volatile.LoadUint32(&o.CANBT.Reg)&^(0xffff8000)|value<<15)
}
func (o *C_CAN_Type) GetCANBT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANBT.Reg) & 0xffff8000) >> 15
}

// C_CAN.CANINT: Interrupt register
func (o *C_CAN_Type) SetCANINT_INTID(value uint32) {
	volatile.StoreUint32(&o.CANINT.Reg, volatile.LoadUint32(&o.CANINT.Reg)&^(0xffff)|value)
}
func (o *C_CAN_Type) GetCANINT_INTID() uint32 {
	return volatile.LoadUint32(&o.CANINT.Reg) & 0xffff
}
func (o *C_CAN_Type) SetCANINT_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANINT.Reg, volatile.LoadUint32(&o.CANINT.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANINT_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANINT.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANTEST: Test register
func (o *C_CAN_Type) SetCANTEST_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANTEST.Reg, volatile.LoadUint32(&o.CANTEST.Reg)&^(0x3)|value)
}
func (o *C_CAN_Type) GetCANTEST_RESERVED() uint32 {
	return volatile.LoadUint32(&o.CANTEST.Reg) & 0x3
}
func (o *C_CAN_Type) SetCANTEST_BASIC(value uint32) {
	volatile.StoreUint32(&o.CANTEST.Reg, volatile.LoadUint32(&o.CANTEST.Reg)&^(0x4)|value<<2)
}
func (o *C_CAN_Type) GetCANTEST_BASIC() uint32 {
	return (volatile.LoadUint32(&o.CANTEST.Reg) & 0x4) >> 2
}
func (o *C_CAN_Type) SetCANTEST_SILENT(value uint32) {
	volatile.StoreUint32(&o.CANTEST.Reg, volatile.LoadUint32(&o.CANTEST.Reg)&^(0x8)|value<<3)
}
func (o *C_CAN_Type) GetCANTEST_SILENT() uint32 {
	return (volatile.LoadUint32(&o.CANTEST.Reg) & 0x8) >> 3
}
func (o *C_CAN_Type) SetCANTEST_LBACK(value uint32) {
	volatile.StoreUint32(&o.CANTEST.Reg, volatile.LoadUint32(&o.CANTEST.Reg)&^(0x10)|value<<4)
}
func (o *C_CAN_Type) GetCANTEST_LBACK() uint32 {
	return (volatile.LoadUint32(&o.CANTEST.Reg) & 0x10) >> 4
}
func (o *C_CAN_Type) SetCANTEST_TX(value uint32) {
	volatile.StoreUint32(&o.CANTEST.Reg, volatile.LoadUint32(&o.CANTEST.Reg)&^(0x60)|value<<5)
}
func (o *C_CAN_Type) GetCANTEST_TX() uint32 {
	return (volatile.LoadUint32(&o.CANTEST.Reg) & 0x60) >> 5
}
func (o *C_CAN_Type) SetCANTEST_RX(value uint32) {
	volatile.StoreUint32(&o.CANTEST.Reg, volatile.LoadUint32(&o.CANTEST.Reg)&^(0x80)|value<<7)
}
func (o *C_CAN_Type) GetCANTEST_RX() uint32 {
	return (volatile.LoadUint32(&o.CANTEST.Reg) & 0x80) >> 7
}
func (o *C_CAN_Type) SetCANTEST_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANTEST.Reg, volatile.LoadUint32(&o.CANTEST.Reg)&^(0xffffff00)|value<<8)
}
func (o *C_CAN_Type) GetCANTEST_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANTEST.Reg) & 0xffffff00) >> 8
}

// C_CAN.CANBRPE: Baud rate prescaler extension register
func (o *C_CAN_Type) SetCANBRPE_BRPE(value uint32) {
	volatile.StoreUint32(&o.CANBRPE.Reg, volatile.LoadUint32(&o.CANBRPE.Reg)&^(0xf)|value)
}
func (o *C_CAN_Type) GetCANBRPE_BRPE() uint32 {
	return volatile.LoadUint32(&o.CANBRPE.Reg) & 0xf
}
func (o *C_CAN_Type) SetCANBRPE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANBRPE.Reg, volatile.LoadUint32(&o.CANBRPE.Reg)&^(0xfffffff0)|value<<4)
}
func (o *C_CAN_Type) GetCANBRPE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANBRPE.Reg) & 0xfffffff0) >> 4
}

// C_CAN.CANIF1_CMDREQ: Message interface command request
func (o *C_CAN_Type) SetCANIF1_CMDREQ_MN(value uint32) {
	volatile.StoreUint32(&o.CANIF1_CMDREQ.Reg, volatile.LoadUint32(&o.CANIF1_CMDREQ.Reg)&^(0x3f)|value)
}
func (o *C_CAN_Type) GetCANIF1_CMDREQ_MN() uint32 {
	return volatile.LoadUint32(&o.CANIF1_CMDREQ.Reg) & 0x3f
}
func (o *C_CAN_Type) SetCANIF1_CMDREQ_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIF1_CMDREQ.Reg, volatile.LoadUint32(&o.CANIF1_CMDREQ.Reg)&^(0x7fc0)|value<<6)
}
func (o *C_CAN_Type) GetCANIF1_CMDREQ_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_CMDREQ.Reg) & 0x7fc0) >> 6
}
func (o *C_CAN_Type) SetCANIF1_CMDREQ_BUSY(value uint32) {
	volatile.StoreUint32(&o.CANIF1_CMDREQ.Reg, volatile.LoadUint32(&o.CANIF1_CMDREQ.Reg)&^(0x8000)|value<<15)
}
func (o *C_CAN_Type) GetCANIF1_CMDREQ_BUSY() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_CMDREQ.Reg) & 0x8000) >> 15
}
func (o *C_CAN_Type) SetCANIF1_CMDREQ_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIF1_CMDREQ.Reg, volatile.LoadUint32(&o.CANIF1_CMDREQ.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANIF1_CMDREQ_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_CMDREQ.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANIF1_CMDMSK_W: Message interface command mask - write direction
func (o *C_CAN_Type) SetCANIF1_CMDMSK_W_DATA_B(value uint32) {
	volatile.StoreUint32(&o.CANIF1_CMDMSK_W.Reg, volatile.LoadUint32(&o.CANIF1_CMDMSK_W.Reg)&^(0x1)|value)
}
func (o *C_CAN_Type) GetCANIF1_CMDMSK_W_DATA_B() uint32 {
	return volatile.LoadUint32(&o.CANIF1_CMDMSK_W.Reg) & 0x1
}
func (o *C_CAN_Type) SetCANIF1_CMDMSK_W_DATA_A(value uint32) {
	volatile.StoreUint32(&o.CANIF1_CMDMSK_W.Reg, volatile.LoadUint32(&o.CANIF1_CMDMSK_W.Reg)&^(0x2)|value<<1)
}
func (o *C_CAN_Type) GetCANIF1_CMDMSK_W_DATA_A() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_CMDMSK_W.Reg) & 0x2) >> 1
}
func (o *C_CAN_Type) SetCANIF1_CMDMSK_W_TXRQST(value uint32) {
	volatile.StoreUint32(&o.CANIF1_CMDMSK_W.Reg, volatile.LoadUint32(&o.CANIF1_CMDMSK_W.Reg)&^(0x4)|value<<2)
}
func (o *C_CAN_Type) GetCANIF1_CMDMSK_W_TXRQST() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_CMDMSK_W.Reg) & 0x4) >> 2
}
func (o *C_CAN_Type) SetCANIF1_CMDMSK_W_CLRINTPND(value uint32) {
	volatile.StoreUint32(&o.CANIF1_CMDMSK_W.Reg, volatile.LoadUint32(&o.CANIF1_CMDMSK_W.Reg)&^(0x8)|value<<3)
}
func (o *C_CAN_Type) GetCANIF1_CMDMSK_W_CLRINTPND() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_CMDMSK_W.Reg) & 0x8) >> 3
}
func (o *C_CAN_Type) SetCANIF1_CMDMSK_W_CTRL(value uint32) {
	volatile.StoreUint32(&o.CANIF1_CMDMSK_W.Reg, volatile.LoadUint32(&o.CANIF1_CMDMSK_W.Reg)&^(0x10)|value<<4)
}
func (o *C_CAN_Type) GetCANIF1_CMDMSK_W_CTRL() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_CMDMSK_W.Reg) & 0x10) >> 4
}
func (o *C_CAN_Type) SetCANIF1_CMDMSK_W_ARB(value uint32) {
	volatile.StoreUint32(&o.CANIF1_CMDMSK_W.Reg, volatile.LoadUint32(&o.CANIF1_CMDMSK_W.Reg)&^(0x20)|value<<5)
}
func (o *C_CAN_Type) GetCANIF1_CMDMSK_W_ARB() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_CMDMSK_W.Reg) & 0x20) >> 5
}
func (o *C_CAN_Type) SetCANIF1_CMDMSK_W_MASK(value uint32) {
	volatile.StoreUint32(&o.CANIF1_CMDMSK_W.Reg, volatile.LoadUint32(&o.CANIF1_CMDMSK_W.Reg)&^(0x40)|value<<6)
}
func (o *C_CAN_Type) GetCANIF1_CMDMSK_W_MASK() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_CMDMSK_W.Reg) & 0x40) >> 6
}
func (o *C_CAN_Type) SetCANIF1_CMDMSK_W_WR_RD(value uint32) {
	volatile.StoreUint32(&o.CANIF1_CMDMSK_W.Reg, volatile.LoadUint32(&o.CANIF1_CMDMSK_W.Reg)&^(0x80)|value<<7)
}
func (o *C_CAN_Type) GetCANIF1_CMDMSK_W_WR_RD() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_CMDMSK_W.Reg) & 0x80) >> 7
}
func (o *C_CAN_Type) SetCANIF1_CMDMSK_W_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIF1_CMDMSK_W.Reg, volatile.LoadUint32(&o.CANIF1_CMDMSK_W.Reg)&^(0xffffff00)|value<<8)
}
func (o *C_CAN_Type) GetCANIF1_CMDMSK_W_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_CMDMSK_W.Reg) & 0xffffff00) >> 8
}

// C_CAN.CANIF1_MSK1: Message interface 1 mask 1
func (o *C_CAN_Type) SetCANIF1_MSK1_MSK_15_0(value uint32) {
	volatile.StoreUint32(&o.CANIF1_MSK1.Reg, volatile.LoadUint32(&o.CANIF1_MSK1.Reg)&^(0xffff)|value)
}
func (o *C_CAN_Type) GetCANIF1_MSK1_MSK_15_0() uint32 {
	return volatile.LoadUint32(&o.CANIF1_MSK1.Reg) & 0xffff
}
func (o *C_CAN_Type) SetCANIF1_MSK1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIF1_MSK1.Reg, volatile.LoadUint32(&o.CANIF1_MSK1.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANIF1_MSK1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_MSK1.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANIF1_MSK2: Message interface 1 mask 2
func (o *C_CAN_Type) SetCANIF1_MSK2_MSK_28_16(value uint32) {
	volatile.StoreUint32(&o.CANIF1_MSK2.Reg, volatile.LoadUint32(&o.CANIF1_MSK2.Reg)&^(0x1fff)|value)
}
func (o *C_CAN_Type) GetCANIF1_MSK2_MSK_28_16() uint32 {
	return volatile.LoadUint32(&o.CANIF1_MSK2.Reg) & 0x1fff
}
func (o *C_CAN_Type) SetCANIF1_MSK2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIF1_MSK2.Reg, volatile.LoadUint32(&o.CANIF1_MSK2.Reg)&^(0x2000)|value<<13)
}
func (o *C_CAN_Type) GetCANIF1_MSK2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_MSK2.Reg) & 0x2000) >> 13
}
func (o *C_CAN_Type) SetCANIF1_MSK2_MDIR(value uint32) {
	volatile.StoreUint32(&o.CANIF1_MSK2.Reg, volatile.LoadUint32(&o.CANIF1_MSK2.Reg)&^(0x4000)|value<<14)
}
func (o *C_CAN_Type) GetCANIF1_MSK2_MDIR() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_MSK2.Reg) & 0x4000) >> 14
}
func (o *C_CAN_Type) SetCANIF1_MSK2_MXTD(value uint32) {
	volatile.StoreUint32(&o.CANIF1_MSK2.Reg, volatile.LoadUint32(&o.CANIF1_MSK2.Reg)&^(0x8000)|value<<15)
}
func (o *C_CAN_Type) GetCANIF1_MSK2_MXTD() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_MSK2.Reg) & 0x8000) >> 15
}
func (o *C_CAN_Type) SetCANIF1_MSK2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIF1_MSK2.Reg, volatile.LoadUint32(&o.CANIF1_MSK2.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANIF1_MSK2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_MSK2.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANIF1_ARB1: Message interface 1 arbitration 1
func (o *C_CAN_Type) SetCANIF1_ARB1_ID_15_0(value uint32) {
	volatile.StoreUint32(&o.CANIF1_ARB1.Reg, volatile.LoadUint32(&o.CANIF1_ARB1.Reg)&^(0xffff)|value)
}
func (o *C_CAN_Type) GetCANIF1_ARB1_ID_15_0() uint32 {
	return volatile.LoadUint32(&o.CANIF1_ARB1.Reg) & 0xffff
}
func (o *C_CAN_Type) SetCANIF1_ARB1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIF1_ARB1.Reg, volatile.LoadUint32(&o.CANIF1_ARB1.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANIF1_ARB1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_ARB1.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANIF1_ARB2: Message interface 1 arbitration 2
func (o *C_CAN_Type) SetCANIF1_ARB2_ID_28_16(value uint32) {
	volatile.StoreUint32(&o.CANIF1_ARB2.Reg, volatile.LoadUint32(&o.CANIF1_ARB2.Reg)&^(0x1fff)|value)
}
func (o *C_CAN_Type) GetCANIF1_ARB2_ID_28_16() uint32 {
	return volatile.LoadUint32(&o.CANIF1_ARB2.Reg) & 0x1fff
}
func (o *C_CAN_Type) SetCANIF1_ARB2_DIR(value uint32) {
	volatile.StoreUint32(&o.CANIF1_ARB2.Reg, volatile.LoadUint32(&o.CANIF1_ARB2.Reg)&^(0x2000)|value<<13)
}
func (o *C_CAN_Type) GetCANIF1_ARB2_DIR() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_ARB2.Reg) & 0x2000) >> 13
}
func (o *C_CAN_Type) SetCANIF1_ARB2_XTD(value uint32) {
	volatile.StoreUint32(&o.CANIF1_ARB2.Reg, volatile.LoadUint32(&o.CANIF1_ARB2.Reg)&^(0x4000)|value<<14)
}
func (o *C_CAN_Type) GetCANIF1_ARB2_XTD() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_ARB2.Reg) & 0x4000) >> 14
}
func (o *C_CAN_Type) SetCANIF1_ARB2_MSGVAL(value uint32) {
	volatile.StoreUint32(&o.CANIF1_ARB2.Reg, volatile.LoadUint32(&o.CANIF1_ARB2.Reg)&^(0x8000)|value<<15)
}
func (o *C_CAN_Type) GetCANIF1_ARB2_MSGVAL() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_ARB2.Reg) & 0x8000) >> 15
}
func (o *C_CAN_Type) SetCANIF1_ARB2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIF1_ARB2.Reg, volatile.LoadUint32(&o.CANIF1_ARB2.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANIF1_ARB2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_ARB2.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANIF1_MCTRL: Message interface 1 message control
func (o *C_CAN_Type) SetCANIF1_MCTRL_DLC_3_0(value uint32) {
	volatile.StoreUint32(&o.CANIF1_MCTRL.Reg, volatile.LoadUint32(&o.CANIF1_MCTRL.Reg)&^(0xf)|value)
}
func (o *C_CAN_Type) GetCANIF1_MCTRL_DLC_3_0() uint32 {
	return volatile.LoadUint32(&o.CANIF1_MCTRL.Reg) & 0xf
}
func (o *C_CAN_Type) SetCANIF1_MCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIF1_MCTRL.Reg, volatile.LoadUint32(&o.CANIF1_MCTRL.Reg)&^(0x70)|value<<4)
}
func (o *C_CAN_Type) GetCANIF1_MCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_MCTRL.Reg) & 0x70) >> 4
}
func (o *C_CAN_Type) SetCANIF1_MCTRL_EOB(value uint32) {
	volatile.StoreUint32(&o.CANIF1_MCTRL.Reg, volatile.LoadUint32(&o.CANIF1_MCTRL.Reg)&^(0x80)|value<<7)
}
func (o *C_CAN_Type) GetCANIF1_MCTRL_EOB() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_MCTRL.Reg) & 0x80) >> 7
}
func (o *C_CAN_Type) SetCANIF1_MCTRL_TXRQST(value uint32) {
	volatile.StoreUint32(&o.CANIF1_MCTRL.Reg, volatile.LoadUint32(&o.CANIF1_MCTRL.Reg)&^(0x100)|value<<8)
}
func (o *C_CAN_Type) GetCANIF1_MCTRL_TXRQST() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_MCTRL.Reg) & 0x100) >> 8
}
func (o *C_CAN_Type) SetCANIF1_MCTRL_RMTEN(value uint32) {
	volatile.StoreUint32(&o.CANIF1_MCTRL.Reg, volatile.LoadUint32(&o.CANIF1_MCTRL.Reg)&^(0x200)|value<<9)
}
func (o *C_CAN_Type) GetCANIF1_MCTRL_RMTEN() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_MCTRL.Reg) & 0x200) >> 9
}
func (o *C_CAN_Type) SetCANIF1_MCTRL_RXIE(value uint32) {
	volatile.StoreUint32(&o.CANIF1_MCTRL.Reg, volatile.LoadUint32(&o.CANIF1_MCTRL.Reg)&^(0x400)|value<<10)
}
func (o *C_CAN_Type) GetCANIF1_MCTRL_RXIE() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_MCTRL.Reg) & 0x400) >> 10
}
func (o *C_CAN_Type) SetCANIF1_MCTRL_TXIE(value uint32) {
	volatile.StoreUint32(&o.CANIF1_MCTRL.Reg, volatile.LoadUint32(&o.CANIF1_MCTRL.Reg)&^(0x800)|value<<11)
}
func (o *C_CAN_Type) GetCANIF1_MCTRL_TXIE() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_MCTRL.Reg) & 0x800) >> 11
}
func (o *C_CAN_Type) SetCANIF1_MCTRL_UMASK(value uint32) {
	volatile.StoreUint32(&o.CANIF1_MCTRL.Reg, volatile.LoadUint32(&o.CANIF1_MCTRL.Reg)&^(0x1000)|value<<12)
}
func (o *C_CAN_Type) GetCANIF1_MCTRL_UMASK() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_MCTRL.Reg) & 0x1000) >> 12
}
func (o *C_CAN_Type) SetCANIF1_MCTRL_INTPND(value uint32) {
	volatile.StoreUint32(&o.CANIF1_MCTRL.Reg, volatile.LoadUint32(&o.CANIF1_MCTRL.Reg)&^(0x2000)|value<<13)
}
func (o *C_CAN_Type) GetCANIF1_MCTRL_INTPND() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_MCTRL.Reg) & 0x2000) >> 13
}
func (o *C_CAN_Type) SetCANIF1_MCTRL_MSGLST(value uint32) {
	volatile.StoreUint32(&o.CANIF1_MCTRL.Reg, volatile.LoadUint32(&o.CANIF1_MCTRL.Reg)&^(0x4000)|value<<14)
}
func (o *C_CAN_Type) GetCANIF1_MCTRL_MSGLST() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_MCTRL.Reg) & 0x4000) >> 14
}
func (o *C_CAN_Type) SetCANIF1_MCTRL_NEWDAT(value uint32) {
	volatile.StoreUint32(&o.CANIF1_MCTRL.Reg, volatile.LoadUint32(&o.CANIF1_MCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *C_CAN_Type) GetCANIF1_MCTRL_NEWDAT() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_MCTRL.Reg) & 0x8000) >> 15
}
func (o *C_CAN_Type) SetCANIF1_MCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIF1_MCTRL.Reg, volatile.LoadUint32(&o.CANIF1_MCTRL.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANIF1_MCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_MCTRL.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANIF1_DA1: Message interface 1 data A1
func (o *C_CAN_Type) SetCANIF1_DA1_DATA0(value uint32) {
	volatile.StoreUint32(&o.CANIF1_DA1.Reg, volatile.LoadUint32(&o.CANIF1_DA1.Reg)&^(0xff)|value)
}
func (o *C_CAN_Type) GetCANIF1_DA1_DATA0() uint32 {
	return volatile.LoadUint32(&o.CANIF1_DA1.Reg) & 0xff
}
func (o *C_CAN_Type) SetCANIF1_DA1_DATA1(value uint32) {
	volatile.StoreUint32(&o.CANIF1_DA1.Reg, volatile.LoadUint32(&o.CANIF1_DA1.Reg)&^(0xff00)|value<<8)
}
func (o *C_CAN_Type) GetCANIF1_DA1_DATA1() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_DA1.Reg) & 0xff00) >> 8
}
func (o *C_CAN_Type) SetCANIF1_DA1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIF1_DA1.Reg, volatile.LoadUint32(&o.CANIF1_DA1.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANIF1_DA1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_DA1.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANIF1_DA2: Message interface 1 data A2
func (o *C_CAN_Type) SetCANIF1_DA2_DATA2(value uint32) {
	volatile.StoreUint32(&o.CANIF1_DA2.Reg, volatile.LoadUint32(&o.CANIF1_DA2.Reg)&^(0xff)|value)
}
func (o *C_CAN_Type) GetCANIF1_DA2_DATA2() uint32 {
	return volatile.LoadUint32(&o.CANIF1_DA2.Reg) & 0xff
}
func (o *C_CAN_Type) SetCANIF1_DA2_DATA3(value uint32) {
	volatile.StoreUint32(&o.CANIF1_DA2.Reg, volatile.LoadUint32(&o.CANIF1_DA2.Reg)&^(0xff00)|value<<8)
}
func (o *C_CAN_Type) GetCANIF1_DA2_DATA3() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_DA2.Reg) & 0xff00) >> 8
}
func (o *C_CAN_Type) SetCANIF1_DA2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIF1_DA2.Reg, volatile.LoadUint32(&o.CANIF1_DA2.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANIF1_DA2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_DA2.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANIF1_DB1: Message interface 1 data B1
func (o *C_CAN_Type) SetCANIF1_DB1_DATA4(value uint32) {
	volatile.StoreUint32(&o.CANIF1_DB1.Reg, volatile.LoadUint32(&o.CANIF1_DB1.Reg)&^(0xff)|value)
}
func (o *C_CAN_Type) GetCANIF1_DB1_DATA4() uint32 {
	return volatile.LoadUint32(&o.CANIF1_DB1.Reg) & 0xff
}
func (o *C_CAN_Type) SetCANIF1_DB1_DATA5(value uint32) {
	volatile.StoreUint32(&o.CANIF1_DB1.Reg, volatile.LoadUint32(&o.CANIF1_DB1.Reg)&^(0xff00)|value<<8)
}
func (o *C_CAN_Type) GetCANIF1_DB1_DATA5() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_DB1.Reg) & 0xff00) >> 8
}
func (o *C_CAN_Type) SetCANIF1_DB1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIF1_DB1.Reg, volatile.LoadUint32(&o.CANIF1_DB1.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANIF1_DB1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_DB1.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANIF1_DB2: Message interface 1 data B2
func (o *C_CAN_Type) SetCANIF1_DB2_DATA6(value uint32) {
	volatile.StoreUint32(&o.CANIF1_DB2.Reg, volatile.LoadUint32(&o.CANIF1_DB2.Reg)&^(0xff)|value)
}
func (o *C_CAN_Type) GetCANIF1_DB2_DATA6() uint32 {
	return volatile.LoadUint32(&o.CANIF1_DB2.Reg) & 0xff
}
func (o *C_CAN_Type) SetCANIF1_DB2_DATA7(value uint32) {
	volatile.StoreUint32(&o.CANIF1_DB2.Reg, volatile.LoadUint32(&o.CANIF1_DB2.Reg)&^(0xff00)|value<<8)
}
func (o *C_CAN_Type) GetCANIF1_DB2_DATA7() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_DB2.Reg) & 0xff00) >> 8
}
func (o *C_CAN_Type) SetCANIF1_DB2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIF1_DB2.Reg, volatile.LoadUint32(&o.CANIF1_DB2.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANIF1_DB2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIF1_DB2.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANIF2_CMDREQ: Message interface command request
func (o *C_CAN_Type) SetCANIF2_CMDREQ_MN(value uint32) {
	volatile.StoreUint32(&o.CANIF2_CMDREQ.Reg, volatile.LoadUint32(&o.CANIF2_CMDREQ.Reg)&^(0x3f)|value)
}
func (o *C_CAN_Type) GetCANIF2_CMDREQ_MN() uint32 {
	return volatile.LoadUint32(&o.CANIF2_CMDREQ.Reg) & 0x3f
}
func (o *C_CAN_Type) SetCANIF2_CMDREQ_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIF2_CMDREQ.Reg, volatile.LoadUint32(&o.CANIF2_CMDREQ.Reg)&^(0x7fc0)|value<<6)
}
func (o *C_CAN_Type) GetCANIF2_CMDREQ_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_CMDREQ.Reg) & 0x7fc0) >> 6
}
func (o *C_CAN_Type) SetCANIF2_CMDREQ_BUSY(value uint32) {
	volatile.StoreUint32(&o.CANIF2_CMDREQ.Reg, volatile.LoadUint32(&o.CANIF2_CMDREQ.Reg)&^(0x8000)|value<<15)
}
func (o *C_CAN_Type) GetCANIF2_CMDREQ_BUSY() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_CMDREQ.Reg) & 0x8000) >> 15
}
func (o *C_CAN_Type) SetCANIF2_CMDREQ_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIF2_CMDREQ.Reg, volatile.LoadUint32(&o.CANIF2_CMDREQ.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANIF2_CMDREQ_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_CMDREQ.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANIF2_CMDMSK_W: Message interface command mask - write direction
func (o *C_CAN_Type) SetCANIF2_CMDMSK_W_DATA_B(value uint32) {
	volatile.StoreUint32(&o.CANIF2_CMDMSK_W.Reg, volatile.LoadUint32(&o.CANIF2_CMDMSK_W.Reg)&^(0x1)|value)
}
func (o *C_CAN_Type) GetCANIF2_CMDMSK_W_DATA_B() uint32 {
	return volatile.LoadUint32(&o.CANIF2_CMDMSK_W.Reg) & 0x1
}
func (o *C_CAN_Type) SetCANIF2_CMDMSK_W_DATA_A(value uint32) {
	volatile.StoreUint32(&o.CANIF2_CMDMSK_W.Reg, volatile.LoadUint32(&o.CANIF2_CMDMSK_W.Reg)&^(0x2)|value<<1)
}
func (o *C_CAN_Type) GetCANIF2_CMDMSK_W_DATA_A() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_CMDMSK_W.Reg) & 0x2) >> 1
}
func (o *C_CAN_Type) SetCANIF2_CMDMSK_W_TXRQST(value uint32) {
	volatile.StoreUint32(&o.CANIF2_CMDMSK_W.Reg, volatile.LoadUint32(&o.CANIF2_CMDMSK_W.Reg)&^(0x4)|value<<2)
}
func (o *C_CAN_Type) GetCANIF2_CMDMSK_W_TXRQST() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_CMDMSK_W.Reg) & 0x4) >> 2
}
func (o *C_CAN_Type) SetCANIF2_CMDMSK_W_CLRINTPND(value uint32) {
	volatile.StoreUint32(&o.CANIF2_CMDMSK_W.Reg, volatile.LoadUint32(&o.CANIF2_CMDMSK_W.Reg)&^(0x8)|value<<3)
}
func (o *C_CAN_Type) GetCANIF2_CMDMSK_W_CLRINTPND() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_CMDMSK_W.Reg) & 0x8) >> 3
}
func (o *C_CAN_Type) SetCANIF2_CMDMSK_W_CTRL(value uint32) {
	volatile.StoreUint32(&o.CANIF2_CMDMSK_W.Reg, volatile.LoadUint32(&o.CANIF2_CMDMSK_W.Reg)&^(0x10)|value<<4)
}
func (o *C_CAN_Type) GetCANIF2_CMDMSK_W_CTRL() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_CMDMSK_W.Reg) & 0x10) >> 4
}
func (o *C_CAN_Type) SetCANIF2_CMDMSK_W_ARB(value uint32) {
	volatile.StoreUint32(&o.CANIF2_CMDMSK_W.Reg, volatile.LoadUint32(&o.CANIF2_CMDMSK_W.Reg)&^(0x20)|value<<5)
}
func (o *C_CAN_Type) GetCANIF2_CMDMSK_W_ARB() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_CMDMSK_W.Reg) & 0x20) >> 5
}
func (o *C_CAN_Type) SetCANIF2_CMDMSK_W_MASK(value uint32) {
	volatile.StoreUint32(&o.CANIF2_CMDMSK_W.Reg, volatile.LoadUint32(&o.CANIF2_CMDMSK_W.Reg)&^(0x40)|value<<6)
}
func (o *C_CAN_Type) GetCANIF2_CMDMSK_W_MASK() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_CMDMSK_W.Reg) & 0x40) >> 6
}
func (o *C_CAN_Type) SetCANIF2_CMDMSK_W_WR_RD(value uint32) {
	volatile.StoreUint32(&o.CANIF2_CMDMSK_W.Reg, volatile.LoadUint32(&o.CANIF2_CMDMSK_W.Reg)&^(0x80)|value<<7)
}
func (o *C_CAN_Type) GetCANIF2_CMDMSK_W_WR_RD() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_CMDMSK_W.Reg) & 0x80) >> 7
}
func (o *C_CAN_Type) SetCANIF2_CMDMSK_W_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIF2_CMDMSK_W.Reg, volatile.LoadUint32(&o.CANIF2_CMDMSK_W.Reg)&^(0xffffff00)|value<<8)
}
func (o *C_CAN_Type) GetCANIF2_CMDMSK_W_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_CMDMSK_W.Reg) & 0xffffff00) >> 8
}

// C_CAN.CANIF2_MSK1: Message interface 1 mask 1
func (o *C_CAN_Type) SetCANIF2_MSK1_MSK_15_0(value uint32) {
	volatile.StoreUint32(&o.CANIF2_MSK1.Reg, volatile.LoadUint32(&o.CANIF2_MSK1.Reg)&^(0xffff)|value)
}
func (o *C_CAN_Type) GetCANIF2_MSK1_MSK_15_0() uint32 {
	return volatile.LoadUint32(&o.CANIF2_MSK1.Reg) & 0xffff
}
func (o *C_CAN_Type) SetCANIF2_MSK1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIF2_MSK1.Reg, volatile.LoadUint32(&o.CANIF2_MSK1.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANIF2_MSK1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_MSK1.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANIF2_MSK2: Message interface 1 mask 2
func (o *C_CAN_Type) SetCANIF2_MSK2_MSK_28_16(value uint32) {
	volatile.StoreUint32(&o.CANIF2_MSK2.Reg, volatile.LoadUint32(&o.CANIF2_MSK2.Reg)&^(0x1fff)|value)
}
func (o *C_CAN_Type) GetCANIF2_MSK2_MSK_28_16() uint32 {
	return volatile.LoadUint32(&o.CANIF2_MSK2.Reg) & 0x1fff
}
func (o *C_CAN_Type) SetCANIF2_MSK2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIF2_MSK2.Reg, volatile.LoadUint32(&o.CANIF2_MSK2.Reg)&^(0x2000)|value<<13)
}
func (o *C_CAN_Type) GetCANIF2_MSK2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_MSK2.Reg) & 0x2000) >> 13
}
func (o *C_CAN_Type) SetCANIF2_MSK2_MDIR(value uint32) {
	volatile.StoreUint32(&o.CANIF2_MSK2.Reg, volatile.LoadUint32(&o.CANIF2_MSK2.Reg)&^(0x4000)|value<<14)
}
func (o *C_CAN_Type) GetCANIF2_MSK2_MDIR() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_MSK2.Reg) & 0x4000) >> 14
}
func (o *C_CAN_Type) SetCANIF2_MSK2_MXTD(value uint32) {
	volatile.StoreUint32(&o.CANIF2_MSK2.Reg, volatile.LoadUint32(&o.CANIF2_MSK2.Reg)&^(0x8000)|value<<15)
}
func (o *C_CAN_Type) GetCANIF2_MSK2_MXTD() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_MSK2.Reg) & 0x8000) >> 15
}
func (o *C_CAN_Type) SetCANIF2_MSK2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIF2_MSK2.Reg, volatile.LoadUint32(&o.CANIF2_MSK2.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANIF2_MSK2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_MSK2.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANIF2_ARB1: Message interface 1 arbitration 1
func (o *C_CAN_Type) SetCANIF2_ARB1_ID_15_0(value uint32) {
	volatile.StoreUint32(&o.CANIF2_ARB1.Reg, volatile.LoadUint32(&o.CANIF2_ARB1.Reg)&^(0xffff)|value)
}
func (o *C_CAN_Type) GetCANIF2_ARB1_ID_15_0() uint32 {
	return volatile.LoadUint32(&o.CANIF2_ARB1.Reg) & 0xffff
}
func (o *C_CAN_Type) SetCANIF2_ARB1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIF2_ARB1.Reg, volatile.LoadUint32(&o.CANIF2_ARB1.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANIF2_ARB1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_ARB1.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANIF2_ARB2: Message interface 1 arbitration 2
func (o *C_CAN_Type) SetCANIF2_ARB2_ID_28_16(value uint32) {
	volatile.StoreUint32(&o.CANIF2_ARB2.Reg, volatile.LoadUint32(&o.CANIF2_ARB2.Reg)&^(0x1fff)|value)
}
func (o *C_CAN_Type) GetCANIF2_ARB2_ID_28_16() uint32 {
	return volatile.LoadUint32(&o.CANIF2_ARB2.Reg) & 0x1fff
}
func (o *C_CAN_Type) SetCANIF2_ARB2_DIR(value uint32) {
	volatile.StoreUint32(&o.CANIF2_ARB2.Reg, volatile.LoadUint32(&o.CANIF2_ARB2.Reg)&^(0x2000)|value<<13)
}
func (o *C_CAN_Type) GetCANIF2_ARB2_DIR() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_ARB2.Reg) & 0x2000) >> 13
}
func (o *C_CAN_Type) SetCANIF2_ARB2_XTD(value uint32) {
	volatile.StoreUint32(&o.CANIF2_ARB2.Reg, volatile.LoadUint32(&o.CANIF2_ARB2.Reg)&^(0x4000)|value<<14)
}
func (o *C_CAN_Type) GetCANIF2_ARB2_XTD() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_ARB2.Reg) & 0x4000) >> 14
}
func (o *C_CAN_Type) SetCANIF2_ARB2_MSGVAL(value uint32) {
	volatile.StoreUint32(&o.CANIF2_ARB2.Reg, volatile.LoadUint32(&o.CANIF2_ARB2.Reg)&^(0x8000)|value<<15)
}
func (o *C_CAN_Type) GetCANIF2_ARB2_MSGVAL() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_ARB2.Reg) & 0x8000) >> 15
}
func (o *C_CAN_Type) SetCANIF2_ARB2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIF2_ARB2.Reg, volatile.LoadUint32(&o.CANIF2_ARB2.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANIF2_ARB2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_ARB2.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANIF2_MCTRL: Message interface 1 message control
func (o *C_CAN_Type) SetCANIF2_MCTRL_DLC_3_0(value uint32) {
	volatile.StoreUint32(&o.CANIF2_MCTRL.Reg, volatile.LoadUint32(&o.CANIF2_MCTRL.Reg)&^(0xf)|value)
}
func (o *C_CAN_Type) GetCANIF2_MCTRL_DLC_3_0() uint32 {
	return volatile.LoadUint32(&o.CANIF2_MCTRL.Reg) & 0xf
}
func (o *C_CAN_Type) SetCANIF2_MCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIF2_MCTRL.Reg, volatile.LoadUint32(&o.CANIF2_MCTRL.Reg)&^(0x70)|value<<4)
}
func (o *C_CAN_Type) GetCANIF2_MCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_MCTRL.Reg) & 0x70) >> 4
}
func (o *C_CAN_Type) SetCANIF2_MCTRL_EOB(value uint32) {
	volatile.StoreUint32(&o.CANIF2_MCTRL.Reg, volatile.LoadUint32(&o.CANIF2_MCTRL.Reg)&^(0x80)|value<<7)
}
func (o *C_CAN_Type) GetCANIF2_MCTRL_EOB() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_MCTRL.Reg) & 0x80) >> 7
}
func (o *C_CAN_Type) SetCANIF2_MCTRL_TXRQST(value uint32) {
	volatile.StoreUint32(&o.CANIF2_MCTRL.Reg, volatile.LoadUint32(&o.CANIF2_MCTRL.Reg)&^(0x100)|value<<8)
}
func (o *C_CAN_Type) GetCANIF2_MCTRL_TXRQST() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_MCTRL.Reg) & 0x100) >> 8
}
func (o *C_CAN_Type) SetCANIF2_MCTRL_RMTEN(value uint32) {
	volatile.StoreUint32(&o.CANIF2_MCTRL.Reg, volatile.LoadUint32(&o.CANIF2_MCTRL.Reg)&^(0x200)|value<<9)
}
func (o *C_CAN_Type) GetCANIF2_MCTRL_RMTEN() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_MCTRL.Reg) & 0x200) >> 9
}
func (o *C_CAN_Type) SetCANIF2_MCTRL_RXIE(value uint32) {
	volatile.StoreUint32(&o.CANIF2_MCTRL.Reg, volatile.LoadUint32(&o.CANIF2_MCTRL.Reg)&^(0x400)|value<<10)
}
func (o *C_CAN_Type) GetCANIF2_MCTRL_RXIE() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_MCTRL.Reg) & 0x400) >> 10
}
func (o *C_CAN_Type) SetCANIF2_MCTRL_TXIE(value uint32) {
	volatile.StoreUint32(&o.CANIF2_MCTRL.Reg, volatile.LoadUint32(&o.CANIF2_MCTRL.Reg)&^(0x800)|value<<11)
}
func (o *C_CAN_Type) GetCANIF2_MCTRL_TXIE() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_MCTRL.Reg) & 0x800) >> 11
}
func (o *C_CAN_Type) SetCANIF2_MCTRL_UMASK(value uint32) {
	volatile.StoreUint32(&o.CANIF2_MCTRL.Reg, volatile.LoadUint32(&o.CANIF2_MCTRL.Reg)&^(0x1000)|value<<12)
}
func (o *C_CAN_Type) GetCANIF2_MCTRL_UMASK() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_MCTRL.Reg) & 0x1000) >> 12
}
func (o *C_CAN_Type) SetCANIF2_MCTRL_INTPND(value uint32) {
	volatile.StoreUint32(&o.CANIF2_MCTRL.Reg, volatile.LoadUint32(&o.CANIF2_MCTRL.Reg)&^(0x2000)|value<<13)
}
func (o *C_CAN_Type) GetCANIF2_MCTRL_INTPND() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_MCTRL.Reg) & 0x2000) >> 13
}
func (o *C_CAN_Type) SetCANIF2_MCTRL_MSGLST(value uint32) {
	volatile.StoreUint32(&o.CANIF2_MCTRL.Reg, volatile.LoadUint32(&o.CANIF2_MCTRL.Reg)&^(0x4000)|value<<14)
}
func (o *C_CAN_Type) GetCANIF2_MCTRL_MSGLST() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_MCTRL.Reg) & 0x4000) >> 14
}
func (o *C_CAN_Type) SetCANIF2_MCTRL_NEWDAT(value uint32) {
	volatile.StoreUint32(&o.CANIF2_MCTRL.Reg, volatile.LoadUint32(&o.CANIF2_MCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *C_CAN_Type) GetCANIF2_MCTRL_NEWDAT() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_MCTRL.Reg) & 0x8000) >> 15
}
func (o *C_CAN_Type) SetCANIF2_MCTRL_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIF2_MCTRL.Reg, volatile.LoadUint32(&o.CANIF2_MCTRL.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANIF2_MCTRL_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_MCTRL.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANIF2_DA1: Message interface 1 data A1
func (o *C_CAN_Type) SetCANIF2_DA1_DATA0(value uint32) {
	volatile.StoreUint32(&o.CANIF2_DA1.Reg, volatile.LoadUint32(&o.CANIF2_DA1.Reg)&^(0xff)|value)
}
func (o *C_CAN_Type) GetCANIF2_DA1_DATA0() uint32 {
	return volatile.LoadUint32(&o.CANIF2_DA1.Reg) & 0xff
}
func (o *C_CAN_Type) SetCANIF2_DA1_DATA1(value uint32) {
	volatile.StoreUint32(&o.CANIF2_DA1.Reg, volatile.LoadUint32(&o.CANIF2_DA1.Reg)&^(0xff00)|value<<8)
}
func (o *C_CAN_Type) GetCANIF2_DA1_DATA1() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_DA1.Reg) & 0xff00) >> 8
}
func (o *C_CAN_Type) SetCANIF2_DA1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIF2_DA1.Reg, volatile.LoadUint32(&o.CANIF2_DA1.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANIF2_DA1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_DA1.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANIF2_DA2: Message interface 1 data A2
func (o *C_CAN_Type) SetCANIF2_DA2_DATA2(value uint32) {
	volatile.StoreUint32(&o.CANIF2_DA2.Reg, volatile.LoadUint32(&o.CANIF2_DA2.Reg)&^(0xff)|value)
}
func (o *C_CAN_Type) GetCANIF2_DA2_DATA2() uint32 {
	return volatile.LoadUint32(&o.CANIF2_DA2.Reg) & 0xff
}
func (o *C_CAN_Type) SetCANIF2_DA2_DATA3(value uint32) {
	volatile.StoreUint32(&o.CANIF2_DA2.Reg, volatile.LoadUint32(&o.CANIF2_DA2.Reg)&^(0xff00)|value<<8)
}
func (o *C_CAN_Type) GetCANIF2_DA2_DATA3() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_DA2.Reg) & 0xff00) >> 8
}
func (o *C_CAN_Type) SetCANIF2_DA2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIF2_DA2.Reg, volatile.LoadUint32(&o.CANIF2_DA2.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANIF2_DA2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_DA2.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANIF2_DB1: Message interface 1 data B1
func (o *C_CAN_Type) SetCANIF2_DB1_DATA4(value uint32) {
	volatile.StoreUint32(&o.CANIF2_DB1.Reg, volatile.LoadUint32(&o.CANIF2_DB1.Reg)&^(0xff)|value)
}
func (o *C_CAN_Type) GetCANIF2_DB1_DATA4() uint32 {
	return volatile.LoadUint32(&o.CANIF2_DB1.Reg) & 0xff
}
func (o *C_CAN_Type) SetCANIF2_DB1_DATA5(value uint32) {
	volatile.StoreUint32(&o.CANIF2_DB1.Reg, volatile.LoadUint32(&o.CANIF2_DB1.Reg)&^(0xff00)|value<<8)
}
func (o *C_CAN_Type) GetCANIF2_DB1_DATA5() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_DB1.Reg) & 0xff00) >> 8
}
func (o *C_CAN_Type) SetCANIF2_DB1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIF2_DB1.Reg, volatile.LoadUint32(&o.CANIF2_DB1.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANIF2_DB1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_DB1.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANIF2_DB2: Message interface 1 data B2
func (o *C_CAN_Type) SetCANIF2_DB2_DATA6(value uint32) {
	volatile.StoreUint32(&o.CANIF2_DB2.Reg, volatile.LoadUint32(&o.CANIF2_DB2.Reg)&^(0xff)|value)
}
func (o *C_CAN_Type) GetCANIF2_DB2_DATA6() uint32 {
	return volatile.LoadUint32(&o.CANIF2_DB2.Reg) & 0xff
}
func (o *C_CAN_Type) SetCANIF2_DB2_DATA7(value uint32) {
	volatile.StoreUint32(&o.CANIF2_DB2.Reg, volatile.LoadUint32(&o.CANIF2_DB2.Reg)&^(0xff00)|value<<8)
}
func (o *C_CAN_Type) GetCANIF2_DB2_DATA7() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_DB2.Reg) & 0xff00) >> 8
}
func (o *C_CAN_Type) SetCANIF2_DB2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIF2_DB2.Reg, volatile.LoadUint32(&o.CANIF2_DB2.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANIF2_DB2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIF2_DB2.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANTXREQ1: Transmission request 1
func (o *C_CAN_Type) SetCANTXREQ1_TXRQST_16_1(value uint32) {
	volatile.StoreUint32(&o.CANTXREQ1.Reg, volatile.LoadUint32(&o.CANTXREQ1.Reg)&^(0xffff)|value)
}
func (o *C_CAN_Type) GetCANTXREQ1_TXRQST_16_1() uint32 {
	return volatile.LoadUint32(&o.CANTXREQ1.Reg) & 0xffff
}
func (o *C_CAN_Type) SetCANTXREQ1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANTXREQ1.Reg, volatile.LoadUint32(&o.CANTXREQ1.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANTXREQ1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANTXREQ1.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANTXREQ2: Transmission request 2
func (o *C_CAN_Type) SetCANTXREQ2_TXRQST_32_17(value uint32) {
	volatile.StoreUint32(&o.CANTXREQ2.Reg, volatile.LoadUint32(&o.CANTXREQ2.Reg)&^(0xffff)|value)
}
func (o *C_CAN_Type) GetCANTXREQ2_TXRQST_32_17() uint32 {
	return volatile.LoadUint32(&o.CANTXREQ2.Reg) & 0xffff
}
func (o *C_CAN_Type) SetCANTXREQ2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANTXREQ2.Reg, volatile.LoadUint32(&o.CANTXREQ2.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANTXREQ2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANTXREQ2.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANND1: New data 1
func (o *C_CAN_Type) SetCANND1_NEWDAT_16_1(value uint32) {
	volatile.StoreUint32(&o.CANND1.Reg, volatile.LoadUint32(&o.CANND1.Reg)&^(0xffff)|value)
}
func (o *C_CAN_Type) GetCANND1_NEWDAT_16_1() uint32 {
	return volatile.LoadUint32(&o.CANND1.Reg) & 0xffff
}
func (o *C_CAN_Type) SetCANND1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANND1.Reg, volatile.LoadUint32(&o.CANND1.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANND1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANND1.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANND2: New data 2
func (o *C_CAN_Type) SetCANND2_NEWDAT_32_17(value uint32) {
	volatile.StoreUint32(&o.CANND2.Reg, volatile.LoadUint32(&o.CANND2.Reg)&^(0xffff)|value)
}
func (o *C_CAN_Type) GetCANND2_NEWDAT_32_17() uint32 {
	return volatile.LoadUint32(&o.CANND2.Reg) & 0xffff
}
func (o *C_CAN_Type) SetCANND2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANND2.Reg, volatile.LoadUint32(&o.CANND2.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANND2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANND2.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANIR1: Interrupt pending 1
func (o *C_CAN_Type) SetCANIR1_INTPND_16_1(value uint32) {
	volatile.StoreUint32(&o.CANIR1.Reg, volatile.LoadUint32(&o.CANIR1.Reg)&^(0xffff)|value)
}
func (o *C_CAN_Type) GetCANIR1_INTPND_16_1() uint32 {
	return volatile.LoadUint32(&o.CANIR1.Reg) & 0xffff
}
func (o *C_CAN_Type) SetCANIR1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIR1.Reg, volatile.LoadUint32(&o.CANIR1.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANIR1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIR1.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANIR2: Interrupt pending 2
func (o *C_CAN_Type) SetCANIR2_INTPND_32_17(value uint32) {
	volatile.StoreUint32(&o.CANIR2.Reg, volatile.LoadUint32(&o.CANIR2.Reg)&^(0xffff)|value)
}
func (o *C_CAN_Type) GetCANIR2_INTPND_32_17() uint32 {
	return volatile.LoadUint32(&o.CANIR2.Reg) & 0xffff
}
func (o *C_CAN_Type) SetCANIR2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANIR2.Reg, volatile.LoadUint32(&o.CANIR2.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANIR2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANIR2.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANMSGV1: Message valid 1
func (o *C_CAN_Type) SetCANMSGV1_MSGVAL_16_1(value uint32) {
	volatile.StoreUint32(&o.CANMSGV1.Reg, volatile.LoadUint32(&o.CANMSGV1.Reg)&^(0xffff)|value)
}
func (o *C_CAN_Type) GetCANMSGV1_MSGVAL_16_1() uint32 {
	return volatile.LoadUint32(&o.CANMSGV1.Reg) & 0xffff
}
func (o *C_CAN_Type) SetCANMSGV1_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANMSGV1.Reg, volatile.LoadUint32(&o.CANMSGV1.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANMSGV1_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANMSGV1.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANMSGV2: Message valid 2
func (o *C_CAN_Type) SetCANMSGV2_MSGVAL_32_17(value uint32) {
	volatile.StoreUint32(&o.CANMSGV2.Reg, volatile.LoadUint32(&o.CANMSGV2.Reg)&^(0xffff)|value)
}
func (o *C_CAN_Type) GetCANMSGV2_MSGVAL_32_17() uint32 {
	return volatile.LoadUint32(&o.CANMSGV2.Reg) & 0xffff
}
func (o *C_CAN_Type) SetCANMSGV2_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANMSGV2.Reg, volatile.LoadUint32(&o.CANMSGV2.Reg)&^(0xffff0000)|value<<16)
}
func (o *C_CAN_Type) GetCANMSGV2_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANMSGV2.Reg) & 0xffff0000) >> 16
}

// C_CAN.CANCLKDIV: Can clock divider register
func (o *C_CAN_Type) SetCANCLKDIV_CLKDIVVAL(value uint32) {
	volatile.StoreUint32(&o.CANCLKDIV.Reg, volatile.LoadUint32(&o.CANCLKDIV.Reg)&^(0xf)|value)
}
func (o *C_CAN_Type) GetCANCLKDIV_CLKDIVVAL() uint32 {
	return volatile.LoadUint32(&o.CANCLKDIV.Reg) & 0xf
}
func (o *C_CAN_Type) SetCANCLKDIV_RESERVED(value uint32) {
	volatile.StoreUint32(&o.CANCLKDIV.Reg, volatile.LoadUint32(&o.CANCLKDIV.Reg)&^(0xfffffff0)|value<<4)
}
func (o *C_CAN_Type) GetCANCLKDIV_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.CANCLKDIV.Reg) & 0xfffffff0) >> 4
}

// GPIO0
type GPIO_Type struct {
	_    [16380]byte
	DATA volatile.Register32 // 0x3FFC
	_    [16384]byte
	DIR  volatile.Register32 // 0x8000
	IS   volatile.Register32 // 0x8004
	IBE  volatile.Register32 // 0x8008
	IEV  volatile.Register32 // 0x800C
	IE   volatile.Register32 // 0x8010
	RIS  volatile.Register32 // 0x8014
	MIS  volatile.Register32 // 0x8018
	IC   volatile.Register32 // 0x801C
}

// GPIO.DATA: Port n data register for pins PIOn_0 to PIOn_11
func (o *GPIO_Type) SetDATA_DATA0(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetDATA_DATA0() uint32 {
	return volatile.LoadUint32(&o.DATA.Reg) & 0x1
}
func (o *GPIO_Type) SetDATA_DATA1(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetDATA_DATA1() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetDATA_DATA2(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetDATA_DATA2() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetDATA_DATA3(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetDATA_DATA3() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetDATA_DATA4(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetDATA_DATA4() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetDATA_DATA5(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetDATA_DATA5() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetDATA_DATA6(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetDATA_DATA6() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetDATA_DATA7(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetDATA_DATA7() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetDATA_DATA8(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetDATA_DATA8() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetDATA_DATA9(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetDATA_DATA9() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetDATA_DATA10(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetDATA_DATA10() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetDATA_DATA11(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetDATA_DATA11() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetDATA_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DATA.Reg, volatile.LoadUint32(&o.DATA.Reg)&^(0xfffff000)|value<<12)
}
func (o *GPIO_Type) GetDATA_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DATA.Reg) & 0xfffff000) >> 12
}

// GPIO.DIR: Data direction register for port n
func (o *GPIO_Type) SetDIR_IO0(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetDIR_IO0() uint32 {
	return volatile.LoadUint32(&o.DIR.Reg) & 0x1
}
func (o *GPIO_Type) SetDIR_IO1(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetDIR_IO1() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetDIR_IO2(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetDIR_IO2() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetDIR_IO3(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetDIR_IO3() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetDIR_IO4(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetDIR_IO4() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetDIR_IO5(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetDIR_IO5() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetDIR_IO6(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetDIR_IO6() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetDIR_IO7(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetDIR_IO7() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetDIR_IO8(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetDIR_IO8() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetDIR_IO9(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetDIR_IO9() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetDIR_IO10(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetDIR_IO10() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetDIR_IO11(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetDIR_IO11() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetDIR_RESERVED(value uint32) {
	volatile.StoreUint32(&o.DIR.Reg, volatile.LoadUint32(&o.DIR.Reg)&^(0xfffff000)|value<<12)
}
func (o *GPIO_Type) GetDIR_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.DIR.Reg) & 0xfffff000) >> 12
}

// GPIO.IS: Interrupt sense register for port n
func (o *GPIO_Type) SetIS_ISENSE0(value uint32) {
	volatile.StoreUint32(&o.IS.Reg, volatile.LoadUint32(&o.IS.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetIS_ISENSE0() uint32 {
	return volatile.LoadUint32(&o.IS.Reg) & 0x1
}
func (o *GPIO_Type) SetIS_ISENSE1(value uint32) {
	volatile.StoreUint32(&o.IS.Reg, volatile.LoadUint32(&o.IS.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetIS_ISENSE1() uint32 {
	return (volatile.LoadUint32(&o.IS.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetIS_ISENSE2(value uint32) {
	volatile.StoreUint32(&o.IS.Reg, volatile.LoadUint32(&o.IS.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetIS_ISENSE2() uint32 {
	return (volatile.LoadUint32(&o.IS.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetIS_ISENSE3(value uint32) {
	volatile.StoreUint32(&o.IS.Reg, volatile.LoadUint32(&o.IS.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetIS_ISENSE3() uint32 {
	return (volatile.LoadUint32(&o.IS.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetIS_ISENSE4(value uint32) {
	volatile.StoreUint32(&o.IS.Reg, volatile.LoadUint32(&o.IS.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetIS_ISENSE4() uint32 {
	return (volatile.LoadUint32(&o.IS.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetIS_ISENSE5(value uint32) {
	volatile.StoreUint32(&o.IS.Reg, volatile.LoadUint32(&o.IS.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetIS_ISENSE5() uint32 {
	return (volatile.LoadUint32(&o.IS.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetIS_ISENSE6(value uint32) {
	volatile.StoreUint32(&o.IS.Reg, volatile.LoadUint32(&o.IS.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetIS_ISENSE6() uint32 {
	return (volatile.LoadUint32(&o.IS.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetIS_ISENSE7(value uint32) {
	volatile.StoreUint32(&o.IS.Reg, volatile.LoadUint32(&o.IS.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetIS_ISENSE7() uint32 {
	return (volatile.LoadUint32(&o.IS.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetIS_ISENSE8(value uint32) {
	volatile.StoreUint32(&o.IS.Reg, volatile.LoadUint32(&o.IS.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetIS_ISENSE8() uint32 {
	return (volatile.LoadUint32(&o.IS.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetIS_ISENSE9(value uint32) {
	volatile.StoreUint32(&o.IS.Reg, volatile.LoadUint32(&o.IS.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetIS_ISENSE9() uint32 {
	return (volatile.LoadUint32(&o.IS.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetIS_ISENSE10(value uint32) {
	volatile.StoreUint32(&o.IS.Reg, volatile.LoadUint32(&o.IS.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetIS_ISENSE10() uint32 {
	return (volatile.LoadUint32(&o.IS.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetIS_ISENSE11(value uint32) {
	volatile.StoreUint32(&o.IS.Reg, volatile.LoadUint32(&o.IS.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetIS_ISENSE11() uint32 {
	return (volatile.LoadUint32(&o.IS.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetIS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IS.Reg, volatile.LoadUint32(&o.IS.Reg)&^(0xfffff000)|value<<12)
}
func (o *GPIO_Type) GetIS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IS.Reg) & 0xfffff000) >> 12
}

// GPIO.IBE: Interrupt both edges register for port n
func (o *GPIO_Type) SetIBE_IBE0(value uint32) {
	volatile.StoreUint32(&o.IBE.Reg, volatile.LoadUint32(&o.IBE.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetIBE_IBE0() uint32 {
	return volatile.LoadUint32(&o.IBE.Reg) & 0x1
}
func (o *GPIO_Type) SetIBE_IBE1(value uint32) {
	volatile.StoreUint32(&o.IBE.Reg, volatile.LoadUint32(&o.IBE.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetIBE_IBE1() uint32 {
	return (volatile.LoadUint32(&o.IBE.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetIBE_IBE2(value uint32) {
	volatile.StoreUint32(&o.IBE.Reg, volatile.LoadUint32(&o.IBE.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetIBE_IBE2() uint32 {
	return (volatile.LoadUint32(&o.IBE.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetIBE_IBE3(value uint32) {
	volatile.StoreUint32(&o.IBE.Reg, volatile.LoadUint32(&o.IBE.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetIBE_IBE3() uint32 {
	return (volatile.LoadUint32(&o.IBE.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetIBE_IBE4(value uint32) {
	volatile.StoreUint32(&o.IBE.Reg, volatile.LoadUint32(&o.IBE.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetIBE_IBE4() uint32 {
	return (volatile.LoadUint32(&o.IBE.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetIBE_IBE5(value uint32) {
	volatile.StoreUint32(&o.IBE.Reg, volatile.LoadUint32(&o.IBE.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetIBE_IBE5() uint32 {
	return (volatile.LoadUint32(&o.IBE.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetIBE_IBE6(value uint32) {
	volatile.StoreUint32(&o.IBE.Reg, volatile.LoadUint32(&o.IBE.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetIBE_IBE6() uint32 {
	return (volatile.LoadUint32(&o.IBE.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetIBE_IBE7(value uint32) {
	volatile.StoreUint32(&o.IBE.Reg, volatile.LoadUint32(&o.IBE.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetIBE_IBE7() uint32 {
	return (volatile.LoadUint32(&o.IBE.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetIBE_IBE8(value uint32) {
	volatile.StoreUint32(&o.IBE.Reg, volatile.LoadUint32(&o.IBE.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetIBE_IBE8() uint32 {
	return (volatile.LoadUint32(&o.IBE.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetIBE_IBE9(value uint32) {
	volatile.StoreUint32(&o.IBE.Reg, volatile.LoadUint32(&o.IBE.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetIBE_IBE9() uint32 {
	return (volatile.LoadUint32(&o.IBE.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetIBE_IBE10(value uint32) {
	volatile.StoreUint32(&o.IBE.Reg, volatile.LoadUint32(&o.IBE.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetIBE_IBE10() uint32 {
	return (volatile.LoadUint32(&o.IBE.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetIBE_IBE11(value uint32) {
	volatile.StoreUint32(&o.IBE.Reg, volatile.LoadUint32(&o.IBE.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetIBE_IBE11() uint32 {
	return (volatile.LoadUint32(&o.IBE.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetIBE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IBE.Reg, volatile.LoadUint32(&o.IBE.Reg)&^(0xfffff000)|value<<12)
}
func (o *GPIO_Type) GetIBE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IBE.Reg) & 0xfffff000) >> 12
}

// GPIO.IEV: Interrupt event register for port n
func (o *GPIO_Type) SetIEV_IEV0(value uint32) {
	volatile.StoreUint32(&o.IEV.Reg, volatile.LoadUint32(&o.IEV.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetIEV_IEV0() uint32 {
	return volatile.LoadUint32(&o.IEV.Reg) & 0x1
}
func (o *GPIO_Type) SetIEV_IEV1(value uint32) {
	volatile.StoreUint32(&o.IEV.Reg, volatile.LoadUint32(&o.IEV.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetIEV_IEV1() uint32 {
	return (volatile.LoadUint32(&o.IEV.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetIEV_IEV2(value uint32) {
	volatile.StoreUint32(&o.IEV.Reg, volatile.LoadUint32(&o.IEV.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetIEV_IEV2() uint32 {
	return (volatile.LoadUint32(&o.IEV.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetIEV_IEV3(value uint32) {
	volatile.StoreUint32(&o.IEV.Reg, volatile.LoadUint32(&o.IEV.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetIEV_IEV3() uint32 {
	return (volatile.LoadUint32(&o.IEV.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetIEV_IEV4(value uint32) {
	volatile.StoreUint32(&o.IEV.Reg, volatile.LoadUint32(&o.IEV.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetIEV_IEV4() uint32 {
	return (volatile.LoadUint32(&o.IEV.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetIEV_IEV5(value uint32) {
	volatile.StoreUint32(&o.IEV.Reg, volatile.LoadUint32(&o.IEV.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetIEV_IEV5() uint32 {
	return (volatile.LoadUint32(&o.IEV.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetIEV_IEV6(value uint32) {
	volatile.StoreUint32(&o.IEV.Reg, volatile.LoadUint32(&o.IEV.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetIEV_IEV6() uint32 {
	return (volatile.LoadUint32(&o.IEV.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetIEV_IEV7(value uint32) {
	volatile.StoreUint32(&o.IEV.Reg, volatile.LoadUint32(&o.IEV.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetIEV_IEV7() uint32 {
	return (volatile.LoadUint32(&o.IEV.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetIEV_IEV8(value uint32) {
	volatile.StoreUint32(&o.IEV.Reg, volatile.LoadUint32(&o.IEV.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetIEV_IEV8() uint32 {
	return (volatile.LoadUint32(&o.IEV.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetIEV_IEV9(value uint32) {
	volatile.StoreUint32(&o.IEV.Reg, volatile.LoadUint32(&o.IEV.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetIEV_IEV9() uint32 {
	return (volatile.LoadUint32(&o.IEV.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetIEV_IEV10(value uint32) {
	volatile.StoreUint32(&o.IEV.Reg, volatile.LoadUint32(&o.IEV.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetIEV_IEV10() uint32 {
	return (volatile.LoadUint32(&o.IEV.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetIEV_IEV11(value uint32) {
	volatile.StoreUint32(&o.IEV.Reg, volatile.LoadUint32(&o.IEV.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetIEV_IEV11() uint32 {
	return (volatile.LoadUint32(&o.IEV.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetIEV_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IEV.Reg, volatile.LoadUint32(&o.IEV.Reg)&^(0xfffff000)|value<<12)
}
func (o *GPIO_Type) GetIEV_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IEV.Reg) & 0xfffff000) >> 12
}

// GPIO.IE: Interrupt mask register for port n
func (o *GPIO_Type) SetIE_MASK0(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetIE_MASK0() uint32 {
	return volatile.LoadUint32(&o.IE.Reg) & 0x1
}
func (o *GPIO_Type) SetIE_MASK1(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetIE_MASK1() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetIE_MASK2(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetIE_MASK2() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetIE_MASK3(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetIE_MASK3() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetIE_MASK4(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetIE_MASK4() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetIE_MASK5(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetIE_MASK5() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetIE_MASK6(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetIE_MASK6() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetIE_MASK7(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetIE_MASK7() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetIE_MASK8(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetIE_MASK8() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetIE_MASK9(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetIE_MASK9() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetIE_MASK10(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetIE_MASK10() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetIE_MASK11(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetIE_MASK11() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetIE_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IE.Reg, volatile.LoadUint32(&o.IE.Reg)&^(0xfffff000)|value<<12)
}
func (o *GPIO_Type) GetIE_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IE.Reg) & 0xfffff000) >> 12
}

// GPIO.RIS: Raw interrupt status register for port n
func (o *GPIO_Type) SetRIS_RAWST0(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetRIS_RAWST0() uint32 {
	return volatile.LoadUint32(&o.RIS.Reg) & 0x1
}
func (o *GPIO_Type) SetRIS_RAWST1(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetRIS_RAWST1() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetRIS_RAWST2(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetRIS_RAWST2() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetRIS_RAWST3(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetRIS_RAWST3() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetRIS_RAWST4(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetRIS_RAWST4() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetRIS_RAWST5(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetRIS_RAWST5() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetRIS_RAWST6(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetRIS_RAWST6() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetRIS_RAWST7(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetRIS_RAWST7() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetRIS_RAWST8(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetRIS_RAWST8() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetRIS_RAWST9(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetRIS_RAWST9() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetRIS_RAWST10(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetRIS_RAWST10() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetRIS_RAWST11(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetRIS_RAWST11() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetRIS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.RIS.Reg, volatile.LoadUint32(&o.RIS.Reg)&^(0xfffff000)|value<<12)
}
func (o *GPIO_Type) GetRIS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.RIS.Reg) & 0xfffff000) >> 12
}

// GPIO.MIS: Masked interrupt status register for port n
func (o *GPIO_Type) SetMIS_MASK0(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetMIS_MASK0() uint32 {
	return volatile.LoadUint32(&o.MIS.Reg) & 0x1
}
func (o *GPIO_Type) SetMIS_MASK1(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetMIS_MASK1() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetMIS_MASK2(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetMIS_MASK2() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetMIS_MASK3(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetMIS_MASK3() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetMIS_MASK4(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetMIS_MASK4() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetMIS_MASK5(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetMIS_MASK5() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetMIS_MASK6(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetMIS_MASK6() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetMIS_MASK7(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetMIS_MASK7() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetMIS_MASK8(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetMIS_MASK8() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetMIS_MASK9(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetMIS_MASK9() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetMIS_MASK10(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetMIS_MASK10() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetMIS_MASK11(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetMIS_MASK11() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetMIS_RESERVED(value uint32) {
	volatile.StoreUint32(&o.MIS.Reg, volatile.LoadUint32(&o.MIS.Reg)&^(0xfffff000)|value<<12)
}
func (o *GPIO_Type) GetMIS_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.MIS.Reg) & 0xfffff000) >> 12
}

// GPIO.IC: Interrupt clear register for port n
func (o *GPIO_Type) SetIC_CLR0(value uint32) {
	volatile.StoreUint32(&o.IC.Reg, volatile.LoadUint32(&o.IC.Reg)&^(0x1)|value)
}
func (o *GPIO_Type) GetIC_CLR0() uint32 {
	return volatile.LoadUint32(&o.IC.Reg) & 0x1
}
func (o *GPIO_Type) SetIC_CLR1(value uint32) {
	volatile.StoreUint32(&o.IC.Reg, volatile.LoadUint32(&o.IC.Reg)&^(0x2)|value<<1)
}
func (o *GPIO_Type) GetIC_CLR1() uint32 {
	return (volatile.LoadUint32(&o.IC.Reg) & 0x2) >> 1
}
func (o *GPIO_Type) SetIC_CLR2(value uint32) {
	volatile.StoreUint32(&o.IC.Reg, volatile.LoadUint32(&o.IC.Reg)&^(0x4)|value<<2)
}
func (o *GPIO_Type) GetIC_CLR2() uint32 {
	return (volatile.LoadUint32(&o.IC.Reg) & 0x4) >> 2
}
func (o *GPIO_Type) SetIC_CLR3(value uint32) {
	volatile.StoreUint32(&o.IC.Reg, volatile.LoadUint32(&o.IC.Reg)&^(0x8)|value<<3)
}
func (o *GPIO_Type) GetIC_CLR3() uint32 {
	return (volatile.LoadUint32(&o.IC.Reg) & 0x8) >> 3
}
func (o *GPIO_Type) SetIC_CLR4(value uint32) {
	volatile.StoreUint32(&o.IC.Reg, volatile.LoadUint32(&o.IC.Reg)&^(0x10)|value<<4)
}
func (o *GPIO_Type) GetIC_CLR4() uint32 {
	return (volatile.LoadUint32(&o.IC.Reg) & 0x10) >> 4
}
func (o *GPIO_Type) SetIC_CLR5(value uint32) {
	volatile.StoreUint32(&o.IC.Reg, volatile.LoadUint32(&o.IC.Reg)&^(0x20)|value<<5)
}
func (o *GPIO_Type) GetIC_CLR5() uint32 {
	return (volatile.LoadUint32(&o.IC.Reg) & 0x20) >> 5
}
func (o *GPIO_Type) SetIC_CLR6(value uint32) {
	volatile.StoreUint32(&o.IC.Reg, volatile.LoadUint32(&o.IC.Reg)&^(0x40)|value<<6)
}
func (o *GPIO_Type) GetIC_CLR6() uint32 {
	return (volatile.LoadUint32(&o.IC.Reg) & 0x40) >> 6
}
func (o *GPIO_Type) SetIC_CLR7(value uint32) {
	volatile.StoreUint32(&o.IC.Reg, volatile.LoadUint32(&o.IC.Reg)&^(0x80)|value<<7)
}
func (o *GPIO_Type) GetIC_CLR7() uint32 {
	return (volatile.LoadUint32(&o.IC.Reg) & 0x80) >> 7
}
func (o *GPIO_Type) SetIC_CLR8(value uint32) {
	volatile.StoreUint32(&o.IC.Reg, volatile.LoadUint32(&o.IC.Reg)&^(0x100)|value<<8)
}
func (o *GPIO_Type) GetIC_CLR8() uint32 {
	return (volatile.LoadUint32(&o.IC.Reg) & 0x100) >> 8
}
func (o *GPIO_Type) SetIC_CLR9(value uint32) {
	volatile.StoreUint32(&o.IC.Reg, volatile.LoadUint32(&o.IC.Reg)&^(0x200)|value<<9)
}
func (o *GPIO_Type) GetIC_CLR9() uint32 {
	return (volatile.LoadUint32(&o.IC.Reg) & 0x200) >> 9
}
func (o *GPIO_Type) SetIC_CLR10(value uint32) {
	volatile.StoreUint32(&o.IC.Reg, volatile.LoadUint32(&o.IC.Reg)&^(0x400)|value<<10)
}
func (o *GPIO_Type) GetIC_CLR10() uint32 {
	return (volatile.LoadUint32(&o.IC.Reg) & 0x400) >> 10
}
func (o *GPIO_Type) SetIC_CLR11(value uint32) {
	volatile.StoreUint32(&o.IC.Reg, volatile.LoadUint32(&o.IC.Reg)&^(0x800)|value<<11)
}
func (o *GPIO_Type) GetIC_CLR11() uint32 {
	return (volatile.LoadUint32(&o.IC.Reg) & 0x800) >> 11
}
func (o *GPIO_Type) SetIC_RESERVED(value uint32) {
	volatile.StoreUint32(&o.IC.Reg, volatile.LoadUint32(&o.IC.Reg)&^(0xfffff000)|value<<12)
}
func (o *GPIO_Type) GetIC_RESERVED() uint32 {
	return (volatile.LoadUint32(&o.IC.Reg) & 0xfffff000) >> 12
}

// Constants for I2C: I2C
const (
	// CONSET: I2C Control Set Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is set. Writing a zero has no effect on the corresponding bit in the I2C control register.
	// Position of RESERVED field.
	I2C_CONSET_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	I2C_CONSET_RESERVED_Msk = 0x3
	// Position of AA field.
	I2C_CONSET_AA_Pos = 0x2
	// Bit mask of AA field.
	I2C_CONSET_AA_Msk = 0x4
	// Bit AA.
	I2C_CONSET_AA = 0x4
	// Position of SI field.
	I2C_CONSET_SI_Pos = 0x3
	// Bit mask of SI field.
	I2C_CONSET_SI_Msk = 0x8
	// Bit SI.
	I2C_CONSET_SI = 0x8
	// Position of STO field.
	I2C_CONSET_STO_Pos = 0x4
	// Bit mask of STO field.
	I2C_CONSET_STO_Msk = 0x10
	// Bit STO.
	I2C_CONSET_STO = 0x10
	// Position of STA field.
	I2C_CONSET_STA_Pos = 0x5
	// Bit mask of STA field.
	I2C_CONSET_STA_Msk = 0x20
	// Bit STA.
	I2C_CONSET_STA = 0x20
	// Position of I2EN field.
	I2C_CONSET_I2EN_Pos = 0x6
	// Bit mask of I2EN field.
	I2C_CONSET_I2EN_Msk = 0x40
	// Bit I2EN.
	I2C_CONSET_I2EN = 0x40
	// Position of RESERVED field.
	I2C_CONSET_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	I2C_CONSET_RESERVED_Msk = 0xffffff80

	// STAT: I2C Status Register. During I2C operation, this register provides detailed status codes that allow software to determine the next action needed.
	// Position of RESERVED field.
	I2C_STAT_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	I2C_STAT_RESERVED_Msk = 0x7
	// Position of Status field.
	I2C_STAT_Status_Pos = 0x3
	// Bit mask of Status field.
	I2C_STAT_Status_Msk = 0xf8
	// Position of RESERVED field.
	I2C_STAT_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	I2C_STAT_RESERVED_Msk = 0xffffff00

	// DAT: I2C Data Register. During master or slave transmit mode, data to be transmitted is written to this register. During master or slave receive mode, data that has been received may be read from this register.
	// Position of Data field.
	I2C_DAT_Data_Pos = 0x0
	// Bit mask of Data field.
	I2C_DAT_Data_Msk = 0xff
	// Position of RESERVED field.
	I2C_DAT_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	I2C_DAT_RESERVED_Msk = 0xffffff00

	// ADR0: I2C Slave Address Register 0. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
	// Position of GC field.
	I2C_ADR0_GC_Pos = 0x0
	// Bit mask of GC field.
	I2C_ADR0_GC_Msk = 0x1
	// Bit GC.
	I2C_ADR0_GC = 0x1
	// Position of Address field.
	I2C_ADR0_Address_Pos = 0x1
	// Bit mask of Address field.
	I2C_ADR0_Address_Msk = 0xfe
	// Position of RESERVED field.
	I2C_ADR0_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	I2C_ADR0_RESERVED_Msk = 0xffffff00

	// SCLH: SCH Duty Cycle Register High Half Word. Determines the high time of the I2C clock.
	// Position of SCLH field.
	I2C_SCLH_SCLH_Pos = 0x0
	// Bit mask of SCLH field.
	I2C_SCLH_SCLH_Msk = 0xffff
	// Position of RESERVED field.
	I2C_SCLH_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	I2C_SCLH_RESERVED_Msk = 0xffff0000

	// SCLL: SCL Duty Cycle Register Low Half Word. Determines the low time of the I2C clock. I2nSCLL and I2nSCLH together determine the clock frequency generated by an I2C master and certain times used in slave mode.
	// Position of SCLL field.
	I2C_SCLL_SCLL_Pos = 0x0
	// Bit mask of SCLL field.
	I2C_SCLL_SCLL_Msk = 0xffff
	// Position of RESERVED field.
	I2C_SCLL_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	I2C_SCLL_RESERVED_Msk = 0xffff0000

	// CONCLR: I2C Control Clear Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is cleared. Writing a zero has no effect on the corresponding bit in the I2C control register.
	// Position of RESERVED field.
	I2C_CONCLR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	I2C_CONCLR_RESERVED_Msk = 0x3
	// Position of AAC field.
	I2C_CONCLR_AAC_Pos = 0x2
	// Bit mask of AAC field.
	I2C_CONCLR_AAC_Msk = 0x4
	// Bit AAC.
	I2C_CONCLR_AAC = 0x4
	// Position of SIC field.
	I2C_CONCLR_SIC_Pos = 0x3
	// Bit mask of SIC field.
	I2C_CONCLR_SIC_Msk = 0x8
	// Bit SIC.
	I2C_CONCLR_SIC = 0x8
	// Position of RESERVED field.
	I2C_CONCLR_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	I2C_CONCLR_RESERVED_Msk = 0x10
	// Bit RESERVED.
	I2C_CONCLR_RESERVED = 0x10
	// Position of STAC field.
	I2C_CONCLR_STAC_Pos = 0x5
	// Bit mask of STAC field.
	I2C_CONCLR_STAC_Msk = 0x20
	// Bit STAC.
	I2C_CONCLR_STAC = 0x20
	// Position of I2ENC field.
	I2C_CONCLR_I2ENC_Pos = 0x6
	// Bit mask of I2ENC field.
	I2C_CONCLR_I2ENC_Msk = 0x40
	// Bit I2ENC.
	I2C_CONCLR_I2ENC = 0x40
	// Position of RESERVED field.
	I2C_CONCLR_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	I2C_CONCLR_RESERVED_Msk = 0x80
	// Bit RESERVED.
	I2C_CONCLR_RESERVED = 0x80
	// Position of RESERVED field.
	I2C_CONCLR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	I2C_CONCLR_RESERVED_Msk = 0xffffff00

	// MMCTRL: Monitor mode control register.
	// Position of MM_ENA field.
	I2C_MMCTRL_MM_ENA_Pos = 0x0
	// Bit mask of MM_ENA field.
	I2C_MMCTRL_MM_ENA_Msk = 0x1
	// Bit MM_ENA.
	I2C_MMCTRL_MM_ENA = 0x1
	// Monitor mode disabled.
	I2C_MMCTRL_MM_ENA_MONITOR_MODE_DISABLE = 0x0
	// The I2C module will enter monitor mode. In this mode the SDA output will be forced high. This will prevent the I2C module from outputting data of any kind (including ACK) onto the I 2C data bus. Depending on the state of the ENA_SCL bit, the output may be also forced high, preventing the module from having control over the I2C clock line.
	I2C_MMCTRL_MM_ENA_THE_I2C_MODULE_WILL_ = 0x1
	// Position of ENA_SCL field.
	I2C_MMCTRL_ENA_SCL_Pos = 0x1
	// Bit mask of ENA_SCL field.
	I2C_MMCTRL_ENA_SCL_Msk = 0x2
	// Bit ENA_SCL.
	I2C_MMCTRL_ENA_SCL = 0x2
	// When this bit is cleared to 0, the SCL output will be forced high when the module is in monitor mode. As described above, this will prevent the module from having any control over the I2C clock line.
	I2C_MMCTRL_ENA_SCL_HIGH = 0x0
	// When this bit is set, the I2C module may exercise the same control over the clock line that it would in normal operation. This means that, acting as a slave peripheral, the I2C module can stretch the clock line (hold it low) until it has had time to respond to an I2C interrupt.[1]
	I2C_MMCTRL_ENA_SCL_NORMAL = 0x1
	// Position of MATCH_ALL field.
	I2C_MMCTRL_MATCH_ALL_Pos = 0x2
	// Bit mask of MATCH_ALL field.
	I2C_MMCTRL_MATCH_ALL_Msk = 0x4
	// Bit MATCH_ALL.
	I2C_MMCTRL_MATCH_ALL = 0x4
	// When this bit is cleared, an interrupt will only be generated when a match occurs to one of the (up-to) four address registers described above. That is, the module will respond as a normal slave as far as address-recognition is concerned.
	I2C_MMCTRL_MATCH_ALL_MATCH = 0x0
	// When this bit is set to 1 and the I2C is in monitor mode, an interrupt will be generated on ANY address received. This will enable the part to monitor all traffic on the bus.
	I2C_MMCTRL_MATCH_ALL_ANYADDRESS = 0x1
	// Position of RESERVED field.
	I2C_MMCTRL_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	I2C_MMCTRL_RESERVED_Msk = 0xfffffff8

	// ADR1: I2C Slave Address Register 1. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
	// Position of GC field.
	I2C_ADR_GC_Pos = 0x0
	// Bit mask of GC field.
	I2C_ADR_GC_Msk = 0x1
	// Bit GC.
	I2C_ADR_GC = 0x1
	// Position of Address field.
	I2C_ADR_Address_Pos = 0x1
	// Bit mask of Address field.
	I2C_ADR_Address_Msk = 0xfe
	// Position of RESERVED field.
	I2C_ADR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	I2C_ADR_RESERVED_Msk = 0xffffff00

	// DATA_BUFFER: Data buffer register. The contents of the 8 MSBs of the I2DAT shift register will be transferred to the DATA_BUFFER automatically after every nine bits (8 bits of data plus ACK or NACK) has been received on the bus.
	// Position of Data field.
	I2C_DATA_BUFFER_Data_Pos = 0x0
	// Bit mask of Data field.
	I2C_DATA_BUFFER_Data_Msk = 0xff
	// Position of RESERVED field.
	I2C_DATA_BUFFER_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	I2C_DATA_BUFFER_RESERVED_Msk = 0xffffff00

	// MASK0: I2C Slave address mask register 0. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000).
	// Position of RESERVED field.
	I2C_MASK_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	I2C_MASK_RESERVED_Msk = 0x1
	// Bit RESERVED.
	I2C_MASK_RESERVED = 0x1
	// Position of MASK field.
	I2C_MASK_MASK_Pos = 0x1
	// Bit mask of MASK field.
	I2C_MASK_MASK_Msk = 0xfe
	// Position of RESERVED field.
	I2C_MASK_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	I2C_MASK_RESERVED_Msk = 0xffffff00
)

// Constants for WWDT: Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx Windowed WatchDog Timer (WDT) Modification date=9/19/2011 Major revision=6 Minor revision=not available
const (
	// WDMOD: Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer.
	// Position of WDEN field.
	WWDT_WDMOD_WDEN_Pos = 0x0
	// Bit mask of WDEN field.
	WWDT_WDMOD_WDEN_Msk = 0x1
	// Bit WDEN.
	WWDT_WDMOD_WDEN = 0x1
	// The watchdog timer is stopped.
	WWDT_WDMOD_WDEN_STOPPED = 0x0
	// The watchdog timer is running.
	WWDT_WDMOD_WDEN_RUN = 0x1
	// Position of WDRESET field.
	WWDT_WDMOD_WDRESET_Pos = 0x1
	// Bit mask of WDRESET field.
	WWDT_WDMOD_WDRESET_Msk = 0x2
	// Bit WDRESET.
	WWDT_WDMOD_WDRESET = 0x2
	// A watchdog timeout will not cause a chip reset.
	WWDT_WDMOD_WDRESET_NORESET = 0x0
	// A watchdog timeout will cause a chip reset.
	WWDT_WDMOD_WDRESET_RESET = 0x1
	// Position of WDTOF field.
	WWDT_WDMOD_WDTOF_Pos = 0x2
	// Bit mask of WDTOF field.
	WWDT_WDMOD_WDTOF_Msk = 0x4
	// Bit WDTOF.
	WWDT_WDMOD_WDTOF = 0x4
	// Position of WDINT field.
	WWDT_WDMOD_WDINT_Pos = 0x3
	// Bit mask of WDINT field.
	WWDT_WDMOD_WDINT_Msk = 0x8
	// Bit WDINT.
	WWDT_WDMOD_WDINT = 0x8
	// Position of WDPROTECT field.
	WWDT_WDMOD_WDPROTECT_Pos = 0x4
	// Bit mask of WDPROTECT field.
	WWDT_WDMOD_WDPROTECT_Msk = 0x10
	// Bit WDPROTECT.
	WWDT_WDMOD_WDPROTECT = 0x10
	// The watchdog reload value (WDTC) can be changed at any time.
	WWDT_WDMOD_WDPROTECT_ANYTIME = 0x0
	// The watchdog reload value (WDTC) can be changed only after the counter is below the value of WDWARNINT and WDWINDOW. Note: this mode is intended for use only when WDRESET =1.
	WWDT_WDMOD_WDPROTECT_LOWCOUNTER = 0x1
	// Position of RESERVED field.
	WWDT_WDMOD_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	WWDT_WDMOD_RESERVED_Msk = 0xffffffe0

	// WDTC: Watchdog timer constant register. This register determines the time-out value.
	// Position of Count field.
	WWDT_WDTC_Count_Pos = 0x0
	// Bit mask of Count field.
	WWDT_WDTC_Count_Msk = 0xffffff
	// Position of RESERVED field.
	WWDT_WDTC_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	WWDT_WDTC_RESERVED_Msk = 0xff000000

	// WDFEED: Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in WDTC.
	// Position of Feed field.
	WWDT_WDFEED_Feed_Pos = 0x0
	// Bit mask of Feed field.
	WWDT_WDFEED_Feed_Msk = 0xff
	// Position of RESERVED field.
	WWDT_WDFEED_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	WWDT_WDFEED_RESERVED_Msk = 0xffffff00

	// WDTV: Watchdog timer value register. This register reads out the current value of the Watchdog timer.
	// Position of Count field.
	WWDT_WDTV_Count_Pos = 0x0
	// Bit mask of Count field.
	WWDT_WDTV_Count_Msk = 0xffffff
	// Position of RESERVED field.
	WWDT_WDTV_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	WWDT_WDTV_RESERVED_Msk = 0xff000000

	// WDWARNINT: Watchdog Warning Interrupt compare value.
	// Position of WARNINT field.
	WWDT_WDWARNINT_WARNINT_Pos = 0x0
	// Bit mask of WARNINT field.
	WWDT_WDWARNINT_WARNINT_Msk = 0x3ff
	// Position of RESERVED field.
	WWDT_WDWARNINT_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	WWDT_WDWARNINT_RESERVED_Msk = 0xfffffc00

	// WDWINDOW: Watchdog Window compare value.
	// Position of WINDOW field.
	WWDT_WDWINDOW_WINDOW_Pos = 0x0
	// Bit mask of WINDOW field.
	WWDT_WDWINDOW_WINDOW_Msk = 0xffffff
	// Position of RESERVED field.
	WWDT_WDWINDOW_RESERVED_Pos = 0x18
	// Bit mask of RESERVED field.
	WWDT_WDWINDOW_RESERVED_Msk = 0xff000000
)

// Constants for UART: Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx UART Modification date=9/19/2011 Major revision=7 Minor revision=not available
const (
	// RBR: Receiver Buffer Register. Contains the next received character to be read. (DLAB=0)
	// Position of RBR field.
	UART_RBR_RBR_Pos = 0x0
	// Bit mask of RBR field.
	UART_RBR_RBR_Msk = 0xff
	// Position of RESERVED field.
	UART_RBR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART_RBR_RESERVED_Msk = 0xffffff00

	// THR: Transmit Holding Register. The next character to be transmitted is written here. (DLAB=0)
	// Position of THR field.
	UART_THR_THR_Pos = 0x0
	// Bit mask of THR field.
	UART_THR_THR_Msk = 0xff
	// Position of RESERVED field.
	UART_THR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART_THR_RESERVED_Msk = 0xffffff00

	// DLL: Divisor Latch LSB. Least significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider. (DLAB=1)
	// Position of DLLSB field.
	UART_DLL_DLLSB_Pos = 0x0
	// Bit mask of DLLSB field.
	UART_DLL_DLLSB_Msk = 0xff
	// Position of RESERVED field.
	UART_DLL_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART_DLL_RESERVED_Msk = 0xffffff00

	// DLM: Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider. (DLAB=1)
	// Position of DLMSB field.
	UART_DLM_DLMSB_Pos = 0x0
	// Bit mask of DLMSB field.
	UART_DLM_DLMSB_Msk = 0xff
	// Position of RESERVED field.
	UART_DLM_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART_DLM_RESERVED_Msk = 0xffffff00

	// IER: Interrupt Enable Register. Contains individual interrupt enable bits for the 7 potential UART interrupts. (DLAB=0)
	// Position of RBRIE field.
	UART_IER_RBRIE_Pos = 0x0
	// Bit mask of RBRIE field.
	UART_IER_RBRIE_Msk = 0x1
	// Bit RBRIE.
	UART_IER_RBRIE = 0x1
	// Disable the RDA interrupt.
	UART_IER_RBRIE_DISABLE_THE_RDA_INTE = 0x0
	// Enable the RDA interrupt.
	UART_IER_RBRIE_ENABLE_THE_RDA_INTER = 0x1
	// Position of THREIE field.
	UART_IER_THREIE_Pos = 0x1
	// Bit mask of THREIE field.
	UART_IER_THREIE_Msk = 0x2
	// Bit THREIE.
	UART_IER_THREIE = 0x2
	// Disable the THRE interrupt.
	UART_IER_THREIE_DISABLE_THE_THRE_INT = 0x0
	// Enable the THRE interrupt.
	UART_IER_THREIE_ENABLE_THE_THRE_INTE = 0x1
	// Position of RXLIE field.
	UART_IER_RXLIE_Pos = 0x2
	// Bit mask of RXLIE field.
	UART_IER_RXLIE_Msk = 0x4
	// Bit RXLIE.
	UART_IER_RXLIE = 0x4
	// Disable the RX line status interrupts.
	UART_IER_RXLIE_DISABLE_THE_RX_LINE_ = 0x0
	// Enable the RX line status interrupts.
	UART_IER_RXLIE_ENABLE_THE_RX_LINE_S = 0x1
	// Position of RESERVED field.
	UART_IER_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	UART_IER_RESERVED_Msk = 0x8
	// Bit RESERVED.
	UART_IER_RESERVED = 0x8
	// Position of RESERVED field.
	UART_IER_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	UART_IER_RESERVED_Msk = 0x70
	// Position of RESERVED field.
	UART_IER_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	UART_IER_RESERVED_Msk = 0x80
	// Bit RESERVED.
	UART_IER_RESERVED = 0x80
	// Position of ABEOINTEN field.
	UART_IER_ABEOINTEN_Pos = 0x8
	// Bit mask of ABEOINTEN field.
	UART_IER_ABEOINTEN_Msk = 0x100
	// Bit ABEOINTEN.
	UART_IER_ABEOINTEN = 0x100
	// Disable end of auto-baud Interrupt.
	UART_IER_ABEOINTEN_DISABLE_END_OF_AUTO_ = 0x0
	// Enable end of auto-baud Interrupt.
	UART_IER_ABEOINTEN_ENABLE_END_OF_AUTO_B = 0x1
	// Position of ABTOINTEN field.
	UART_IER_ABTOINTEN_Pos = 0x9
	// Bit mask of ABTOINTEN field.
	UART_IER_ABTOINTEN_Msk = 0x200
	// Bit ABTOINTEN.
	UART_IER_ABTOINTEN = 0x200
	// Disable auto-baud time-out Interrupt.
	UART_IER_ABTOINTEN_DISABLE_AUTO_BAUD_TI = 0x0
	// Enable auto-baud time-out Interrupt.
	UART_IER_ABTOINTEN_ENABLE_AUTO_BAUD_TIM = 0x1
	// Position of RESERVED field.
	UART_IER_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	UART_IER_RESERVED_Msk = 0xfffffc00

	// IIR: Interrupt ID Register. Identifies which interrupt(s) are pending.
	// Position of INTSTATUS field.
	UART_IIR_INTSTATUS_Pos = 0x0
	// Bit mask of INTSTATUS field.
	UART_IIR_INTSTATUS_Msk = 0x1
	// Bit INTSTATUS.
	UART_IIR_INTSTATUS = 0x1
	// At least one interrupt is pending.
	UART_IIR_INTSTATUS_PENDING = 0x0
	// No interrupt is pending.
	UART_IIR_INTSTATUS_NO_INTERRUPT_IS_PEND = 0x1
	// Position of INTID field.
	UART_IIR_INTID_Pos = 0x1
	// Bit mask of INTID field.
	UART_IIR_INTID_Msk = 0xe
	// 1 - Receive Line Status (RLS).
	UART_IIR_INTID_1_RECEIVE_LINE_S = 0x3
	// 2a - Receive Data Available (RDA).
	UART_IIR_INTID_2A__RECEIVE_DATA_AV = 0x2
	// 2b - Character Time-out Indicator (CTI).
	UART_IIR_INTID_2B__CHARACTER_TIME_ = 0x6
	// 3 - THRE Interrupt.
	UART_IIR_INTID_3_THRE_INTERRUPT = 0x1
	// 4 - Modem interrupt.
	UART_IIR_INTID_4_MODEM_INTERRUP = 0x0
	// Position of RESERVED field.
	UART_IIR_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	UART_IIR_RESERVED_Msk = 0x30
	// Position of FIFOENABLE field.
	UART_IIR_FIFOENABLE_Pos = 0x6
	// Bit mask of FIFOENABLE field.
	UART_IIR_FIFOENABLE_Msk = 0xc0
	// Position of ABEOINT field.
	UART_IIR_ABEOINT_Pos = 0x8
	// Bit mask of ABEOINT field.
	UART_IIR_ABEOINT_Msk = 0x100
	// Bit ABEOINT.
	UART_IIR_ABEOINT = 0x100
	// Position of ABTOINT field.
	UART_IIR_ABTOINT_Pos = 0x9
	// Bit mask of ABTOINT field.
	UART_IIR_ABTOINT_Msk = 0x200
	// Bit ABTOINT.
	UART_IIR_ABTOINT = 0x200
	// Position of RESERVED field.
	UART_IIR_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	UART_IIR_RESERVED_Msk = 0xfffffc00

	// FCR: FIFO Control Register. Controls UART FIFO usage and modes.
	// Position of FIFOEN field.
	UART_FCR_FIFOEN_Pos = 0x0
	// Bit mask of FIFOEN field.
	UART_FCR_FIFOEN_Msk = 0x1
	// Bit FIFOEN.
	UART_FCR_FIFOEN = 0x1
	// UART FIFOs are disabled. Must not be used in the application.
	UART_FCR_FIFOEN_DISABLED = 0x0
	// Active high enable for both UART Rx and TX FIFOs and FCR[7:1] access. This bit must be set for proper UART operation. Any transition on this bit will automatically clear the UART FIFOs.
	UART_FCR_FIFOEN_ENABLED = 0x1
	// Position of RXFIFORES field.
	UART_FCR_RXFIFORES_Pos = 0x1
	// Bit mask of RXFIFORES field.
	UART_FCR_RXFIFORES_Msk = 0x2
	// Bit RXFIFORES.
	UART_FCR_RXFIFORES = 0x2
	// No impact on either of UART FIFOs.
	UART_FCR_RXFIFORES_NO_IMPACT_ON_EITHER_ = 0x0
	// Writing a logic 1 to FCR[1] will clear all bytes in UART Rx FIFO, reset the pointer logic. This bit is self-clearing.
	UART_FCR_RXFIFORES_CLEAR = 0x1
	// Position of TXFIFORES field.
	UART_FCR_TXFIFORES_Pos = 0x2
	// Bit mask of TXFIFORES field.
	UART_FCR_TXFIFORES_Msk = 0x4
	// Bit TXFIFORES.
	UART_FCR_TXFIFORES = 0x4
	// No impact on either of UART FIFOs.
	UART_FCR_TXFIFORES_NO_IMPACT_ON_EITHER_ = 0x0
	// Writing a logic 1 to FCR[2] will clear all bytes in UART TX FIFO, reset the pointer logic. This bit is self-clearing.
	UART_FCR_TXFIFORES_CLEAR = 0x1
	// Position of RESERVED field.
	UART_FCR_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	UART_FCR_RESERVED_Msk = 0x8
	// Bit RESERVED.
	UART_FCR_RESERVED = 0x8
	// Position of RESERVED field.
	UART_FCR_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	UART_FCR_RESERVED_Msk = 0x30
	// Position of RXTL field.
	UART_FCR_RXTL_Pos = 0x6
	// Bit mask of RXTL field.
	UART_FCR_RXTL_Msk = 0xc0
	// Trigger level 0 (1 character or 0x01).
	UART_FCR_RXTL_TRIGGER_LEVEL_0_1_C = 0x0
	// Trigger level 1 (4 characters or 0x04).
	UART_FCR_RXTL_TRIGGER_LEVEL_1_4_C = 0x1
	// Trigger level 2 (8 characters or 0x08).
	UART_FCR_RXTL_TRIGGER_LEVEL_2_8_C = 0x2
	// Trigger level 3 (14 characters or 0x0E).
	UART_FCR_RXTL_TRIGGER_LEVEL_3_14_ = 0x3
	// Position of RESERVED field.
	UART_FCR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART_FCR_RESERVED_Msk = 0xffffff00

	// LCR: Line Control Register. Contains controls for frame formatting and break generation.
	// Position of WLS field.
	UART_LCR_WLS_Pos = 0x0
	// Bit mask of WLS field.
	UART_LCR_WLS_Msk = 0x3
	// 5-bit character length.
	UART_LCR_WLS_5_BIT_CHARACTER_LENG = 0x0
	// 6-bit character length.
	UART_LCR_WLS_6_BIT_CHARACTER_LENG = 0x1
	// 7-bit character length.
	UART_LCR_WLS_7_BIT_CHARACTER_LENG = 0x2
	// 8-bit character length.
	UART_LCR_WLS_8_BIT_CHARACTER_LENG = 0x3
	// Position of SBS field.
	UART_LCR_SBS_Pos = 0x2
	// Bit mask of SBS field.
	UART_LCR_SBS_Msk = 0x4
	// Bit SBS.
	UART_LCR_SBS = 0x4
	// 1 stop bit.
	UART_LCR_SBS_1_STOP_BIT_ = 0x0
	// 2 stop bits (1.5 if LCR[1:0]=00).
	UART_LCR_SBS_2_STOP_BITS = 0x1
	// Position of PE field.
	UART_LCR_PE_Pos = 0x3
	// Bit mask of PE field.
	UART_LCR_PE_Msk = 0x8
	// Bit PE.
	UART_LCR_PE = 0x8
	// Disable parity generation and checking.
	UART_LCR_PE_DISABLE_PARITY_GENER = 0x0
	// Enable parity generation and checking.
	UART_LCR_PE_ENABLE_PARITY_GENERA = 0x1
	// Position of PS field.
	UART_LCR_PS_Pos = 0x4
	// Bit mask of PS field.
	UART_LCR_PS_Msk = 0x30
	// Odd parity. Number of 1s in the transmitted character and the attached parity bit will be odd.
	UART_LCR_PS_ODD_PARITY_NUMBER_O = 0x0
	// Even Parity. Number of 1s in the transmitted character and the attached parity bit will be even.
	UART_LCR_PS_EVEN_PARITY_NUMBER_ = 0x1
	// Forced 1 stick parity.
	UART_LCR_PS_FORCED_1_STICK_PARIT = 0x2
	// Forced 0 stick parity.
	UART_LCR_PS_FORCED_0_STICK_PARIT = 0x3
	// Position of BC field.
	UART_LCR_BC_Pos = 0x6
	// Bit mask of BC field.
	UART_LCR_BC_Msk = 0x40
	// Bit BC.
	UART_LCR_BC = 0x40
	// Disable break transmission.
	UART_LCR_BC_DISABLE_BREAK_TRANSM = 0x0
	// Enable break transmission. Output pin UART TXD is forced to logic 0 when LCR[6] is active high.
	UART_LCR_BC_ENABLE_BREAK_TRANSMI = 0x1
	// Position of DLAB field.
	UART_LCR_DLAB_Pos = 0x7
	// Bit mask of DLAB field.
	UART_LCR_DLAB_Msk = 0x80
	// Bit DLAB.
	UART_LCR_DLAB = 0x80
	// Disable access to Divisor Latches.
	UART_LCR_DLAB_DISABLE_ACCESS_TO_DI = 0x0
	// Enable access to Divisor Latches.
	UART_LCR_DLAB_ENABLE_ACCESS_TO_DIV = 0x1
	// Position of RESERVED field.
	UART_LCR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART_LCR_RESERVED_Msk = 0xffffff00

	// MCR: Modem control register
	// Position of DTRC field.
	UART_MCR_DTRC_Pos = 0x0
	// Bit mask of DTRC field.
	UART_MCR_DTRC_Msk = 0x1
	// Bit DTRC.
	UART_MCR_DTRC = 0x1
	// Position of RTSC field.
	UART_MCR_RTSC_Pos = 0x1
	// Bit mask of RTSC field.
	UART_MCR_RTSC_Msk = 0x2
	// Bit RTSC.
	UART_MCR_RTSC = 0x2
	// Position of RESERVED field.
	UART_MCR_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	UART_MCR_RESERVED_Msk = 0xc
	// Position of LMS field.
	UART_MCR_LMS_Pos = 0x4
	// Bit mask of LMS field.
	UART_MCR_LMS_Msk = 0x10
	// Bit LMS.
	UART_MCR_LMS = 0x10
	// Position of RESERVED field.
	UART_MCR_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	UART_MCR_RESERVED_Msk = 0x20
	// Bit RESERVED.
	UART_MCR_RESERVED = 0x20
	// Position of RTSEN field.
	UART_MCR_RTSEN_Pos = 0x6
	// Bit mask of RTSEN field.
	UART_MCR_RTSEN_Msk = 0x40
	// Bit RTSEN.
	UART_MCR_RTSEN = 0x40
	// Disable auto-rts flow control.
	UART_MCR_RTSEN_DISABLE_AUTO_RTS_FLO = 0x0
	// Enable auto-rts flow control.
	UART_MCR_RTSEN_ENABLE_AUTO_RTS_FLOW = 0x1
	// Position of CTSEN field.
	UART_MCR_CTSEN_Pos = 0x7
	// Bit mask of CTSEN field.
	UART_MCR_CTSEN_Msk = 0x80
	// Bit CTSEN.
	UART_MCR_CTSEN = 0x80
	// Disable auto-cts flow control.
	UART_MCR_CTSEN_DISABLE_AUTO_CTS_FLO = 0x0
	// Enable auto-cts flow control.
	UART_MCR_CTSEN_ENABLE_AUTO_CTS_FLOW = 0x1
	// Position of RESERVED field.
	UART_MCR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART_MCR_RESERVED_Msk = 0xffffff00

	// LSR: Line Status Register. Contains flags for transmit and receive status, including line errors.
	// Position of RDR field.
	UART_LSR_RDR_Pos = 0x0
	// Bit mask of RDR field.
	UART_LSR_RDR_Msk = 0x1
	// Bit RDR.
	UART_LSR_RDR = 0x1
	// RBR is empty.
	UART_LSR_RDR_EMPTY_ = 0x0
	// RBR contains valid data.
	UART_LSR_RDR_VALID = 0x1
	// Position of OE field.
	UART_LSR_OE_Pos = 0x1
	// Bit mask of OE field.
	UART_LSR_OE_Msk = 0x2
	// Bit OE.
	UART_LSR_OE = 0x2
	// Overrun error status is inactive.
	UART_LSR_OE_INACTIVE = 0x0
	// Overrun error status is active.
	UART_LSR_OE_ACTIVE = 0x1
	// Position of PE field.
	UART_LSR_PE_Pos = 0x2
	// Bit mask of PE field.
	UART_LSR_PE_Msk = 0x4
	// Bit PE.
	UART_LSR_PE = 0x4
	// Parity error status is inactive.
	UART_LSR_PE_INACTIVE = 0x0
	// Parity error status is active.
	UART_LSR_PE_ACTIVE = 0x1
	// Position of FE field.
	UART_LSR_FE_Pos = 0x3
	// Bit mask of FE field.
	UART_LSR_FE_Msk = 0x8
	// Bit FE.
	UART_LSR_FE = 0x8
	// Framing error status is inactive.
	UART_LSR_FE_INACTIVE = 0x0
	// Framing error status is active.
	UART_LSR_FE_ACTIVE = 0x1
	// Position of BI field.
	UART_LSR_BI_Pos = 0x4
	// Bit mask of BI field.
	UART_LSR_BI_Msk = 0x10
	// Bit BI.
	UART_LSR_BI = 0x10
	// Break interrupt status is inactive.
	UART_LSR_BI_INACTIVE = 0x0
	// Break interrupt status is active.
	UART_LSR_BI_ACTIVE = 0x1
	// Position of THRE field.
	UART_LSR_THRE_Pos = 0x5
	// Bit mask of THRE field.
	UART_LSR_THRE_Msk = 0x20
	// Bit THRE.
	UART_LSR_THRE = 0x20
	// THR contains valid data.
	UART_LSR_THRE_VALID = 0x0
	// THR is empty.
	UART_LSR_THRE_EMPTY_ = 0x1
	// Position of TEMT field.
	UART_LSR_TEMT_Pos = 0x6
	// Bit mask of TEMT field.
	UART_LSR_TEMT_Msk = 0x40
	// Bit TEMT.
	UART_LSR_TEMT = 0x40
	// THR and/or the TSR contains valid data.
	UART_LSR_TEMT_VALID = 0x0
	// THR and the TSR are empty.
	UART_LSR_TEMT_EMPTY_ = 0x1
	// Position of RXFE field.
	UART_LSR_RXFE_Pos = 0x7
	// Bit mask of RXFE field.
	UART_LSR_RXFE_Msk = 0x80
	// Bit RXFE.
	UART_LSR_RXFE = 0x80
	// RBR contains no UART RX errors or FCR[0]=0.
	UART_LSR_RXFE_NOERROR = 0x0
	// UART RBR contains at least one UART RX error.
	UART_LSR_RXFE_ERROR = 0x1
	// Position of RESERVED field.
	UART_LSR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART_LSR_RESERVED_Msk = 0xffffff00

	// MSR: Modem status register
	// Position of DCTS field.
	UART_MSR_DCTS_Pos = 0x0
	// Bit mask of DCTS field.
	UART_MSR_DCTS_Msk = 0x1
	// Bit DCTS.
	UART_MSR_DCTS = 0x1
	// No change detected on modem input CTS.
	UART_MSR_DCTS_NO_CHANGE_DETECTED_O = 0x0
	// State change detected on modem input CTS.
	UART_MSR_DCTS_STATE_CHANGE_DETECTE = 0x1
	// Position of DDSR field.
	UART_MSR_DDSR_Pos = 0x1
	// Bit mask of DDSR field.
	UART_MSR_DDSR_Msk = 0x2
	// Bit DDSR.
	UART_MSR_DDSR = 0x2
	// No change detected on modem input DSR.
	UART_MSR_DDSR_NO_CHANGE_DETECTED_O = 0x0
	// State change detected on modem input DSR.
	UART_MSR_DDSR_STATE_CHANGE_DETECTE = 0x1
	// Position of TERI field.
	UART_MSR_TERI_Pos = 0x2
	// Bit mask of TERI field.
	UART_MSR_TERI_Msk = 0x4
	// Bit TERI.
	UART_MSR_TERI = 0x4
	// No change detected on modem input, RI.
	UART_MSR_TERI_NO_CHANGE_DETECTED_O = 0x0
	// Low-to-high transition detected on RI.
	UART_MSR_TERI_LOW_TO_HIGH_TRANSITI = 0x1
	// Position of DDCD field.
	UART_MSR_DDCD_Pos = 0x3
	// Bit mask of DDCD field.
	UART_MSR_DDCD_Msk = 0x8
	// Bit DDCD.
	UART_MSR_DDCD = 0x8
	// No change detected on modem input DCD.
	UART_MSR_DDCD_NO_CHANGE_DETECTED_O = 0x0
	// State change detected on modem input DCD.
	UART_MSR_DDCD_STATE_CHANGE_DETECTE = 0x1
	// Position of CTS field.
	UART_MSR_CTS_Pos = 0x4
	// Bit mask of CTS field.
	UART_MSR_CTS_Msk = 0x10
	// Bit CTS.
	UART_MSR_CTS = 0x10
	// Position of DSR field.
	UART_MSR_DSR_Pos = 0x5
	// Bit mask of DSR field.
	UART_MSR_DSR_Msk = 0x20
	// Bit DSR.
	UART_MSR_DSR = 0x20
	// Position of RI field.
	UART_MSR_RI_Pos = 0x6
	// Bit mask of RI field.
	UART_MSR_RI_Msk = 0x40
	// Bit RI.
	UART_MSR_RI = 0x40
	// Position of DCD field.
	UART_MSR_DCD_Pos = 0x7
	// Bit mask of DCD field.
	UART_MSR_DCD_Msk = 0x80
	// Bit DCD.
	UART_MSR_DCD = 0x80
	// Position of RESERVED field.
	UART_MSR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART_MSR_RESERVED_Msk = 0xffffff00

	// SCR: Scratch Pad Register. Eight-bit temporary storage for software.
	// Position of PAD field.
	UART_SCR_PAD_Pos = 0x0
	// Bit mask of PAD field.
	UART_SCR_PAD_Msk = 0xff
	// Position of RESERVED field.
	UART_SCR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART_SCR_RESERVED_Msk = 0xffffff00

	// ACR: Auto-baud Control Register. Contains controls for the auto-baud feature.
	// Position of START field.
	UART_ACR_START_Pos = 0x0
	// Bit mask of START field.
	UART_ACR_START_Msk = 0x1
	// Bit START.
	UART_ACR_START = 0x1
	// Auto-baud stop (auto-baud is not running).
	UART_ACR_START_STOP = 0x0
	// Auto-baud start (auto-baud is running). Auto-baud run bit. This bit is automatically cleared after auto-baud completion.
	UART_ACR_START_START = 0x1
	// Position of MODE field.
	UART_ACR_MODE_Pos = 0x1
	// Bit mask of MODE field.
	UART_ACR_MODE_Msk = 0x2
	// Bit MODE.
	UART_ACR_MODE = 0x2
	// Mode 0.
	UART_ACR_MODE_MODE_0_ = 0x0
	// Mode 1.
	UART_ACR_MODE_MODE_1_ = 0x1
	// Position of AUTORESTART field.
	UART_ACR_AUTORESTART_Pos = 0x2
	// Bit mask of AUTORESTART field.
	UART_ACR_AUTORESTART_Msk = 0x4
	// Bit AUTORESTART.
	UART_ACR_AUTORESTART = 0x4
	// No restart
	UART_ACR_AUTORESTART_NO_RESTART = 0x0
	// Restart in case of time-out (counter restarts at next UART Rx falling edge)
	UART_ACR_AUTORESTART_RESTART_IN_CASE_OF_T = 0x1
	// Position of RESERVED field.
	UART_ACR_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	UART_ACR_RESERVED_Msk = 0xf8
	// Position of ABEOINTCLR field.
	UART_ACR_ABEOINTCLR_Pos = 0x8
	// Bit mask of ABEOINTCLR field.
	UART_ACR_ABEOINTCLR_Msk = 0x100
	// Bit ABEOINTCLR.
	UART_ACR_ABEOINTCLR = 0x100
	// Writing a 0 has no impact.
	UART_ACR_ABEOINTCLR_NOIMPACT = 0x0
	// Writing a 1 will clear the corresponding interrupt in the IIR.
	UART_ACR_ABEOINTCLR_CLEAR = 0x1
	// Position of ABTOINTCLR field.
	UART_ACR_ABTOINTCLR_Pos = 0x9
	// Bit mask of ABTOINTCLR field.
	UART_ACR_ABTOINTCLR_Msk = 0x200
	// Bit ABTOINTCLR.
	UART_ACR_ABTOINTCLR = 0x200
	// Writing a 0 has no impact.
	UART_ACR_ABTOINTCLR_NOIMPACT = 0x0
	// Writing a 1 will clear the corresponding interrupt in the IIR.
	UART_ACR_ABTOINTCLR_CLEAR = 0x1
	// Position of RESERVED field.
	UART_ACR_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	UART_ACR_RESERVED_Msk = 0xfffffc00

	// FDR: Fractional Divider Register. Generates a clock input for the baud rate divider.
	// Position of DIVADDVAL field.
	UART_FDR_DIVADDVAL_Pos = 0x0
	// Bit mask of DIVADDVAL field.
	UART_FDR_DIVADDVAL_Msk = 0xf
	// Position of MULVAL field.
	UART_FDR_MULVAL_Pos = 0x4
	// Bit mask of MULVAL field.
	UART_FDR_MULVAL_Msk = 0xf0
	// Position of RESERVED field.
	UART_FDR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART_FDR_RESERVED_Msk = 0xffffff00

	// TER: Transmit Enable Register. Turns off UART transmitter for use with software flow control.
	// Position of RESERVED field.
	UART_TER_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	UART_TER_RESERVED_Msk = 0x7f
	// Position of TXEN field.
	UART_TER_TXEN_Pos = 0x7
	// Bit mask of TXEN field.
	UART_TER_TXEN_Msk = 0x80
	// Bit TXEN.
	UART_TER_TXEN = 0x80
	// Position of RESERVED field.
	UART_TER_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART_TER_RESERVED_Msk = 0xffffff00

	// RS485CTRL: RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes.
	// Position of NMMEN field.
	UART_RS485CTRL_NMMEN_Pos = 0x0
	// Bit mask of NMMEN field.
	UART_RS485CTRL_NMMEN_Msk = 0x1
	// Bit NMMEN.
	UART_RS485CTRL_NMMEN = 0x1
	// RS-485/EIA-485 Normal Multidrop Mode (NMM) is disabled.
	UART_RS485CTRL_NMMEN_DISABLED = 0x0
	// RS-485/EIA-485 Normal Multidrop Mode (NMM) is enabled. In this mode, an address is detected when a received byte causes the UART to set the parity error and generate an interrupt.
	UART_RS485CTRL_NMMEN_ENABLED = 0x1
	// Position of RXDIS field.
	UART_RS485CTRL_RXDIS_Pos = 0x1
	// Bit mask of RXDIS field.
	UART_RS485CTRL_RXDIS_Msk = 0x2
	// Bit RXDIS.
	UART_RS485CTRL_RXDIS = 0x2
	// The receiver is enabled.
	UART_RS485CTRL_RXDIS_ENABLED = 0x0
	// The receiver is disabled.
	UART_RS485CTRL_RXDIS_DISABLED = 0x1
	// Position of AADEN field.
	UART_RS485CTRL_AADEN_Pos = 0x2
	// Bit mask of AADEN field.
	UART_RS485CTRL_AADEN_Msk = 0x4
	// Bit AADEN.
	UART_RS485CTRL_AADEN = 0x4
	// Auto Address Detect (AAD) is disabled.
	UART_RS485CTRL_AADEN_DISABLED = 0x0
	// Auto Address Detect (AAD) is enabled.
	UART_RS485CTRL_AADEN_ENABLED = 0x1
	// Position of SEL field.
	UART_RS485CTRL_SEL_Pos = 0x3
	// Bit mask of SEL field.
	UART_RS485CTRL_SEL_Msk = 0x8
	// Bit SEL.
	UART_RS485CTRL_SEL = 0x8
	// If direction control is enabled (bit DCTRL = 1), pin RTS is used for direction control.
	UART_RS485CTRL_SEL_RTS = 0x0
	// If direction control is enabled (bit DCTRL = 1), pin DTR is used for direction control.
	UART_RS485CTRL_SEL_DTR = 0x1
	// Position of DCTRL field.
	UART_RS485CTRL_DCTRL_Pos = 0x4
	// Bit mask of DCTRL field.
	UART_RS485CTRL_DCTRL_Msk = 0x10
	// Bit DCTRL.
	UART_RS485CTRL_DCTRL = 0x10
	// Disable Auto Direction Control.
	UART_RS485CTRL_DCTRL_DISABLE_AUTO_DIRECTI = 0x0
	// Enable Auto Direction Control.
	UART_RS485CTRL_DCTRL_ENABLE_AUTO_DIRECTIO = 0x1
	// Position of OINV field.
	UART_RS485CTRL_OINV_Pos = 0x5
	// Bit mask of OINV field.
	UART_RS485CTRL_OINV_Msk = 0x20
	// Bit OINV.
	UART_RS485CTRL_OINV = 0x20
	// The direction control pin will be driven to logic 0 when the transmitter has data to be sent. It will be driven to logic 1 after the last bit of data has been transmitted.
	UART_RS485CTRL_OINV_LOW = 0x0
	// The direction control pin will be driven to logic 1 when the transmitter has data to be sent. It will be driven to logic 0 after the last bit of data has been transmitted.
	UART_RS485CTRL_OINV_HIGH = 0x1
	// Position of RESERVED field.
	UART_RS485CTRL_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	UART_RS485CTRL_RESERVED_Msk = 0xffffffc0

	// RS485ADRMATCH: RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode.
	// Position of ADRMATCH field.
	UART_RS485ADRMATCH_ADRMATCH_Pos = 0x0
	// Bit mask of ADRMATCH field.
	UART_RS485ADRMATCH_ADRMATCH_Msk = 0xff
	// Position of RESERVED field.
	UART_RS485ADRMATCH_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART_RS485ADRMATCH_RESERVED_Msk = 0xffffff00

	// RS485DLY: RS-485/EIA-485 direction control delay.
	// Position of DLY field.
	UART_RS485DLY_DLY_Pos = 0x0
	// Bit mask of DLY field.
	UART_RS485DLY_DLY_Msk = 0xff
	// Position of RESERVED field.
	UART_RS485DLY_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	UART_RS485DLY_RESERVED_Msk = 0xffffff00
)

// Constants for CT16B0: Product name title=UM10398 Chapter title=LPC1100XL series: 16-bit counter/timer CT16B0/1 Modification date=2/22/2012 Major revision=8 Minor revision=not available
const (
	// IR: Interrupt Register (IR). The IR can be written to clear interrupts. The IR can be read to identify which of five possible interrupt sources are pending.
	// Position of MR0INT field.
	CT16B0_IR_MR0INT_Pos = 0x0
	// Bit mask of MR0INT field.
	CT16B0_IR_MR0INT_Msk = 0x1
	// Bit MR0INT.
	CT16B0_IR_MR0INT = 0x1
	// Position of MR1INT field.
	CT16B0_IR_MR1INT_Pos = 0x1
	// Bit mask of MR1INT field.
	CT16B0_IR_MR1INT_Msk = 0x2
	// Bit MR1INT.
	CT16B0_IR_MR1INT = 0x2
	// Position of MR2INT field.
	CT16B0_IR_MR2INT_Pos = 0x2
	// Bit mask of MR2INT field.
	CT16B0_IR_MR2INT_Msk = 0x4
	// Bit MR2INT.
	CT16B0_IR_MR2INT = 0x4
	// Position of MR3INT field.
	CT16B0_IR_MR3INT_Pos = 0x3
	// Bit mask of MR3INT field.
	CT16B0_IR_MR3INT_Msk = 0x8
	// Bit MR3INT.
	CT16B0_IR_MR3INT = 0x8
	// Position of CR0INT field.
	CT16B0_IR_CR0INT_Pos = 0x4
	// Bit mask of CR0INT field.
	CT16B0_IR_CR0INT_Msk = 0x10
	// Bit CR0INT.
	CT16B0_IR_CR0INT = 0x10
	// Position of CR1INT field.
	CT16B0_IR_CR1INT_Pos = 0x5
	// Bit mask of CR1INT field.
	CT16B0_IR_CR1INT_Msk = 0x20
	// Bit CR1INT.
	CT16B0_IR_CR1INT = 0x20
	// Position of RESERVED field.
	CT16B0_IR_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	CT16B0_IR_RESERVED_Msk = 0xffffffc0

	// TCR: Timer Control Register (TCR). The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR.
	// Position of CEN field.
	CT16B0_TCR_CEN_Pos = 0x0
	// Bit mask of CEN field.
	CT16B0_TCR_CEN_Msk = 0x1
	// Bit CEN.
	CT16B0_TCR_CEN = 0x1
	// Position of CRST field.
	CT16B0_TCR_CRST_Pos = 0x1
	// Bit mask of CRST field.
	CT16B0_TCR_CRST_Msk = 0x2
	// Bit CRST.
	CT16B0_TCR_CRST = 0x2
	// Position of RESERVED field.
	CT16B0_TCR_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	CT16B0_TCR_RESERVED_Msk = 0xfffffffc

	// TC: Timer Counter (TC). The 16-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR.
	// Position of TC field.
	CT16B0_TC_TC_Pos = 0x0
	// Bit mask of TC field.
	CT16B0_TC_TC_Msk = 0xffff
	// Position of RESERVED field.
	CT16B0_TC_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	CT16B0_TC_RESERVED_Msk = 0xffff0000

	// PR: Prescale Register (PR). When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC.
	// Position of PR field.
	CT16B0_PR_PR_Pos = 0x0
	// Bit mask of PR field.
	CT16B0_PR_PR_Msk = 0xffff
	// Position of RESERVED field.
	CT16B0_PR_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	CT16B0_PR_RESERVED_Msk = 0xffff0000

	// PC: Prescale Counter (PC). The 16-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface.
	// Position of PC field.
	CT16B0_PC_PC_Pos = 0x0
	// Bit mask of PC field.
	CT16B0_PC_PC_Msk = 0xffff
	// Position of RESERVED field.
	CT16B0_PC_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	CT16B0_PC_RESERVED_Msk = 0xffff0000

	// MCR: Match Control Register (MCR). The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs.
	// Position of MR0I field.
	CT16B0_MCR_MR0I_Pos = 0x0
	// Bit mask of MR0I field.
	CT16B0_MCR_MR0I_Msk = 0x1
	// Bit MR0I.
	CT16B0_MCR_MR0I = 0x1
	// Enabled
	CT16B0_MCR_MR0I_ENABLED = 0x1
	// Disabled
	CT16B0_MCR_MR0I_DISABLED = 0x0
	// Position of MR0R field.
	CT16B0_MCR_MR0R_Pos = 0x1
	// Bit mask of MR0R field.
	CT16B0_MCR_MR0R_Msk = 0x2
	// Bit MR0R.
	CT16B0_MCR_MR0R = 0x2
	// Enabled
	CT16B0_MCR_MR0R_ENABLED = 0x1
	// Disabled
	CT16B0_MCR_MR0R_DISABLED = 0x0
	// Position of MR0S field.
	CT16B0_MCR_MR0S_Pos = 0x2
	// Bit mask of MR0S field.
	CT16B0_MCR_MR0S_Msk = 0x4
	// Bit MR0S.
	CT16B0_MCR_MR0S = 0x4
	// Enabled
	CT16B0_MCR_MR0S_ENABLED = 0x1
	// Disabled
	CT16B0_MCR_MR0S_DISABLED = 0x0
	// Position of MR1I field.
	CT16B0_MCR_MR1I_Pos = 0x3
	// Bit mask of MR1I field.
	CT16B0_MCR_MR1I_Msk = 0x8
	// Bit MR1I.
	CT16B0_MCR_MR1I = 0x8
	// Enabled
	CT16B0_MCR_MR1I_ENABLED = 0x1
	// Disabled
	CT16B0_MCR_MR1I_DISABLED = 0x0
	// Position of MR1R field.
	CT16B0_MCR_MR1R_Pos = 0x4
	// Bit mask of MR1R field.
	CT16B0_MCR_MR1R_Msk = 0x10
	// Bit MR1R.
	CT16B0_MCR_MR1R = 0x10
	// Enabled
	CT16B0_MCR_MR1R_ENABLED = 0x1
	// Disabled
	CT16B0_MCR_MR1R_DISABLED = 0x0
	// Position of MR1S field.
	CT16B0_MCR_MR1S_Pos = 0x5
	// Bit mask of MR1S field.
	CT16B0_MCR_MR1S_Msk = 0x20
	// Bit MR1S.
	CT16B0_MCR_MR1S = 0x20
	// Enabled
	CT16B0_MCR_MR1S_ENABLED = 0x1
	// Disabled
	CT16B0_MCR_MR1S_DISABLED = 0x0
	// Position of MR2I field.
	CT16B0_MCR_MR2I_Pos = 0x6
	// Bit mask of MR2I field.
	CT16B0_MCR_MR2I_Msk = 0x40
	// Bit MR2I.
	CT16B0_MCR_MR2I = 0x40
	// Enabled
	CT16B0_MCR_MR2I_ENABLED = 0x1
	// Disabled
	CT16B0_MCR_MR2I_DISABLED = 0x0
	// Position of MR2R field.
	CT16B0_MCR_MR2R_Pos = 0x7
	// Bit mask of MR2R field.
	CT16B0_MCR_MR2R_Msk = 0x80
	// Bit MR2R.
	CT16B0_MCR_MR2R = 0x80
	// Enabled
	CT16B0_MCR_MR2R_ENABLED = 0x1
	// Disabled
	CT16B0_MCR_MR2R_DISABLED = 0x0
	// Position of MR2S field.
	CT16B0_MCR_MR2S_Pos = 0x8
	// Bit mask of MR2S field.
	CT16B0_MCR_MR2S_Msk = 0x100
	// Bit MR2S.
	CT16B0_MCR_MR2S = 0x100
	// Enabled
	CT16B0_MCR_MR2S_ENABLED = 0x1
	// Disabled
	CT16B0_MCR_MR2S_DISABLED = 0x0
	// Position of MR3I field.
	CT16B0_MCR_MR3I_Pos = 0x9
	// Bit mask of MR3I field.
	CT16B0_MCR_MR3I_Msk = 0x200
	// Bit MR3I.
	CT16B0_MCR_MR3I = 0x200
	// Enabled
	CT16B0_MCR_MR3I_ENABLED = 0x1
	// Disabled
	CT16B0_MCR_MR3I_DISABLED = 0x0
	// Position of MR3R field.
	CT16B0_MCR_MR3R_Pos = 0xa
	// Bit mask of MR3R field.
	CT16B0_MCR_MR3R_Msk = 0x400
	// Bit MR3R.
	CT16B0_MCR_MR3R = 0x400
	// Enabled
	CT16B0_MCR_MR3R_ENABLED = 0x1
	// Disabled
	CT16B0_MCR_MR3R_DISABLED = 0x0
	// Position of MR3S field.
	CT16B0_MCR_MR3S_Pos = 0xb
	// Bit mask of MR3S field.
	CT16B0_MCR_MR3S_Msk = 0x800
	// Bit MR3S.
	CT16B0_MCR_MR3S = 0x800
	// Enabled
	CT16B0_MCR_MR3S_ENABLED = 0x1
	// Disabled
	CT16B0_MCR_MR3S_DISABLED = 0x0
	// Position of RESERVED field.
	CT16B0_MCR_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CT16B0_MCR_RESERVED_Msk = 0xfffff000

	// MR0: Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
	// Position of MATCH field.
	CT16B0_MR_MATCH_Pos = 0x0
	// Bit mask of MATCH field.
	CT16B0_MR_MATCH_Msk = 0xffff
	// Position of RESERVED field.
	CT16B0_MR_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	CT16B0_MR_RESERVED_Msk = 0xffff0000

	// CCR: Capture Control Register (CCR). The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place.
	// Position of CAP0RE field.
	CT16B0_CCR_CAP0RE_Pos = 0x0
	// Bit mask of CAP0RE field.
	CT16B0_CCR_CAP0RE_Msk = 0x1
	// Bit CAP0RE.
	CT16B0_CCR_CAP0RE = 0x1
	// Enabled
	CT16B0_CCR_CAP0RE_ENABLED = 0x1
	// Disabled
	CT16B0_CCR_CAP0RE_DISABLED = 0x0
	// Position of CAP0FE field.
	CT16B0_CCR_CAP0FE_Pos = 0x1
	// Bit mask of CAP0FE field.
	CT16B0_CCR_CAP0FE_Msk = 0x2
	// Bit CAP0FE.
	CT16B0_CCR_CAP0FE = 0x2
	// Enabled
	CT16B0_CCR_CAP0FE_ENABLED = 0x1
	// Disabled
	CT16B0_CCR_CAP0FE_DISABLED = 0x0
	// Position of CAP0I field.
	CT16B0_CCR_CAP0I_Pos = 0x2
	// Bit mask of CAP0I field.
	CT16B0_CCR_CAP0I_Msk = 0x4
	// Bit CAP0I.
	CT16B0_CCR_CAP0I = 0x4
	// Enabled
	CT16B0_CCR_CAP0I_ENABLED = 0x1
	// Disabled
	CT16B0_CCR_CAP0I_DISABLED = 0x0
	// Position of CAP1RE field.
	CT16B0_CCR_CAP1RE_Pos = 0x3
	// Bit mask of CAP1RE field.
	CT16B0_CCR_CAP1RE_Msk = 0x8
	// Bit CAP1RE.
	CT16B0_CCR_CAP1RE = 0x8
	// Enabled
	CT16B0_CCR_CAP1RE_ENABLED = 0x1
	// Disabled
	CT16B0_CCR_CAP1RE_DISABLED = 0x0
	// Position of CAP1FE field.
	CT16B0_CCR_CAP1FE_Pos = 0x4
	// Bit mask of CAP1FE field.
	CT16B0_CCR_CAP1FE_Msk = 0x10
	// Bit CAP1FE.
	CT16B0_CCR_CAP1FE = 0x10
	// Enabled
	CT16B0_CCR_CAP1FE_ENABLED = 0x1
	// Disabled
	CT16B0_CCR_CAP1FE_DISABLED = 0x0
	// Position of CAP1I field.
	CT16B0_CCR_CAP1I_Pos = 0x5
	// Bit mask of CAP1I field.
	CT16B0_CCR_CAP1I_Msk = 0x20
	// Bit CAP1I.
	CT16B0_CCR_CAP1I = 0x20
	// Enabled
	CT16B0_CCR_CAP1I_ENABLED = 0x1
	// Disabled
	CT16B0_CCR_CAP1I_DISABLED = 0x0
	// Position of RESERVED field.
	CT16B0_CCR_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	CT16B0_CCR_RESERVED_Msk = 0xffffffc0

	// CR0: Capture Register (CR). CR is loaded with the value of TC when there is an event on the CT16Bn_CAPm input.
	// Position of CAP field.
	CT16B0_CR_CAP_Pos = 0x0
	// Bit mask of CAP field.
	CT16B0_CR_CAP_Msk = 0xffff
	// Position of RESERVED field.
	CT16B0_CR_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	CT16B0_CR_RESERVED_Msk = 0xffff0000

	// EMR: External Match Register (EMR). The EMR controls the match function and the external match pins CT16B0_MAT[2:0].
	// Position of EM0 field.
	CT16B0_EMR_EM0_Pos = 0x0
	// Bit mask of EM0 field.
	CT16B0_EMR_EM0_Msk = 0x1
	// Bit EM0.
	CT16B0_EMR_EM0 = 0x1
	// Position of EM1 field.
	CT16B0_EMR_EM1_Pos = 0x1
	// Bit mask of EM1 field.
	CT16B0_EMR_EM1_Msk = 0x2
	// Bit EM1.
	CT16B0_EMR_EM1 = 0x2
	// Position of EM2 field.
	CT16B0_EMR_EM2_Pos = 0x2
	// Bit mask of EM2 field.
	CT16B0_EMR_EM2_Msk = 0x4
	// Bit EM2.
	CT16B0_EMR_EM2 = 0x4
	// Position of EM3 field.
	CT16B0_EMR_EM3_Pos = 0x3
	// Bit mask of EM3 field.
	CT16B0_EMR_EM3_Msk = 0x8
	// Bit EM3.
	CT16B0_EMR_EM3 = 0x8
	// Position of EMC0 field.
	CT16B0_EMR_EMC0_Pos = 0x4
	// Bit mask of EMC0 field.
	CT16B0_EMR_EMC0_Msk = 0x30
	// Do Nothing.
	CT16B0_EMR_EMC0_DO_NOTHING_ = 0x0
	// Clear the corresponding External Match bit/output to 0 (CT16Bn_MATm pin is LOW if pinned out).
	CT16B0_EMR_EMC0_CLEAR_THE_CORRESPOND = 0x1
	// Set the corresponding External Match bit/output to 1 (CT16Bn_MATm pin is HIGH if pinned out).
	CT16B0_EMR_EMC0_SET_THE_CORRESPONDIN = 0x2
	// Toggle the corresponding External Match bit/output.
	CT16B0_EMR_EMC0_TOGGLE_THE_CORRESPON = 0x3
	// Position of EMC1 field.
	CT16B0_EMR_EMC1_Pos = 0x6
	// Bit mask of EMC1 field.
	CT16B0_EMR_EMC1_Msk = 0xc0
	// Do Nothing.
	CT16B0_EMR_EMC1_DO_NOTHING_ = 0x0
	// Clear the corresponding External Match bit/output to 0 (CT16Bn_MATm pin is LOW if pinned out).
	CT16B0_EMR_EMC1_CLEAR_THE_CORRESPOND = 0x1
	// Set the corresponding External Match bit/output to 1 (CT16Bn_MATm pin is HIGH if pinned out).
	CT16B0_EMR_EMC1_SET_THE_CORRESPONDIN = 0x2
	// Toggle the corresponding External Match bit/output.
	CT16B0_EMR_EMC1_TOGGLE_THE_CORRESPON = 0x3
	// Position of EMC2 field.
	CT16B0_EMR_EMC2_Pos = 0x8
	// Bit mask of EMC2 field.
	CT16B0_EMR_EMC2_Msk = 0x300
	// Do Nothing.
	CT16B0_EMR_EMC2_DO_NOTHING_ = 0x0
	// Clear the corresponding External Match bit/output to 0 (CT16Bn_MATm pin is LOW if pinned out).
	CT16B0_EMR_EMC2_CLEAR_THE_CORRESPOND = 0x1
	// Set the corresponding External Match bit/output to 1 (CT16Bn_MATm pin is HIGH if pinned out).
	CT16B0_EMR_EMC2_SET_THE_CORRESPONDIN = 0x2
	// Toggle the corresponding External Match bit/output.
	CT16B0_EMR_EMC2_TOGGLE_THE_CORRESPON = 0x3
	// Position of EMC3 field.
	CT16B0_EMR_EMC3_Pos = 0xa
	// Bit mask of EMC3 field.
	CT16B0_EMR_EMC3_Msk = 0xc00
	// Do Nothing.
	CT16B0_EMR_EMC3_DO_NOTHING_ = 0x0
	// Clear the corresponding External Match bit/output to 0 (CT16Bn_MATm pin is LOW if pinned out).
	CT16B0_EMR_EMC3_CLEAR_THE_CORRESPOND = 0x1
	// Set the corresponding External Match bit/output to 1 (CT16Bn_MATm pin is HIGH if pinned out).
	CT16B0_EMR_EMC3_SET_THE_CORRESPONDIN = 0x2
	// Toggle the corresponding External Match bit/output.
	CT16B0_EMR_EMC3_TOGGLE_THE_CORRESPON = 0x3
	// Position of RESERVED field.
	CT16B0_EMR_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CT16B0_EMR_RESERVED_Msk = 0xfffff000

	// CTCR: Count Control Register (CTCR). The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.
	// Position of CTM field.
	CT16B0_CTCR_CTM_Pos = 0x0
	// Bit mask of CTM field.
	CT16B0_CTCR_CTM_Msk = 0x3
	// Timer Mode: every rising PCLK edge
	CT16B0_CTCR_CTM_TIMER_MODE_EVERY_RI = 0x0
	// Position of CIS field.
	CT16B0_CTCR_CIS_Pos = 0x2
	// Bit mask of CIS field.
	CT16B0_CTCR_CIS_Msk = 0xc
	// CT16Bn_CAP0
	CT16B0_CTCR_CIS_CT16BN_CAP0 = 0x0
	// CT16Bn_CAP1
	CT16B0_CTCR_CIS_CT16BN_CAP1 = 0x1
	// Position of ENCC field.
	CT16B0_CTCR_ENCC_Pos = 0x4
	// Bit mask of ENCC field.
	CT16B0_CTCR_ENCC_Msk = 0x10
	// Bit ENCC.
	CT16B0_CTCR_ENCC = 0x10
	// Position of SELCC field.
	CT16B0_CTCR_SELCC_Pos = 0x5
	// Bit mask of SELCC field.
	CT16B0_CTCR_SELCC_Msk = 0xe0
	// Rising Edge of CAP0 clears the timer (if bit 4 is set).
	CT16B0_CTCR_SELCC_RISING_EDGE_OF_CAP0_ = 0x0
	// Falling Edge of CAP0 clears the timer (if bit 4 is set).
	CT16B0_CTCR_SELCC_FALLING_EDGE_OF_CAP0 = 0x1
	// Rising Edge of CAP1 clears the timer (if bit 4 is set).
	CT16B0_CTCR_SELCC_RISING_EDGE_OF_CAP1_ = 0x2
	// Falling Edge of CAP1 clears the timer (if bit 4 is set).
	CT16B0_CTCR_SELCC_FALLING_EDGE_OF_CAP1 = 0x3
	// Position of RESERVED field.
	CT16B0_CTCR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	CT16B0_CTCR_RESERVED_Msk = 0xffffff00

	// PWMC: PWM Control Register (PWMCON). The PWMCON enables PWM mode for the external match pins CT16B0_MAT[2:0].
	// Position of PWMEN0 field.
	CT16B0_PWMC_PWMEN0_Pos = 0x0
	// Bit mask of PWMEN0 field.
	CT16B0_PWMC_PWMEN0_Msk = 0x1
	// Bit PWMEN0.
	CT16B0_PWMC_PWMEN0 = 0x1
	// CT16Bn_MAT0 is controlled by EM0.
	CT16B0_PWMC_PWMEN0_CT16BN_MAT0_IS_CONTR = 0x0
	// PWM mode is enabled for CT16Bn_MAT0.
	CT16B0_PWMC_PWMEN0_PWM_MODE_IS_ENABLED_ = 0x1
	// Position of PWMEN1 field.
	CT16B0_PWMC_PWMEN1_Pos = 0x1
	// Bit mask of PWMEN1 field.
	CT16B0_PWMC_PWMEN1_Msk = 0x2
	// Bit PWMEN1.
	CT16B0_PWMC_PWMEN1 = 0x2
	// CT16Bn_MAT1 is controlled by EM1.
	CT16B0_PWMC_PWMEN1_CT16BN_MAT1_IS_CONTR = 0x0
	// PWM mode is enabled for CT16Bn_MAT1.
	CT16B0_PWMC_PWMEN1_PWM_MODE_IS_ENABLED_ = 0x1
	// Position of PWMEN2 field.
	CT16B0_PWMC_PWMEN2_Pos = 0x2
	// Bit mask of PWMEN2 field.
	CT16B0_PWMC_PWMEN2_Msk = 0x4
	// Bit PWMEN2.
	CT16B0_PWMC_PWMEN2 = 0x4
	// Match channel 2 or pin CT16B0_MAT2 is controlled by EM2. Match channel 2 is not pinned out on timer 1.
	CT16B0_PWMC_PWMEN2_MATCH_CHANNEL_2_OR_P = 0x0
	// PWM mode is enabled for match channel 2 or pin CT16B0_MAT2.
	CT16B0_PWMC_PWMEN2_PWM_MODE_IS_ENABLED_ = 0x1
	// Position of PWMEN3 field.
	CT16B0_PWMC_PWMEN3_Pos = 0x3
	// Bit mask of PWMEN3 field.
	CT16B0_PWMC_PWMEN3_Msk = 0x8
	// Bit PWMEN3.
	CT16B0_PWMC_PWMEN3 = 0x8
	// Match channel 3 match channel 3 is controlled by EM3.
	CT16B0_PWMC_PWMEN3_MATCH_CHANNEL_3_MATC = 0x0
	// PWM mode is enabled for match channel 3match channel 3.
	CT16B0_PWMC_PWMEN3_PWM_MODE_IS_ENABLED_ = 0x1
	// Position of RESERVED field.
	CT16B0_PWMC_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	CT16B0_PWMC_RESERVED_Msk = 0xfffffff0
)

// Constants for CT32B0: Product name title=UM10398 Chapter title=LPC1100XL series: 32-bit counter/timer CT32B0/1 Modification date=2/22/2012 Major revision=8 Minor revision=not available
const (
	// IR: Interrupt Register (IR). The IR can be written to clear interrupts. The IR can be read to identify which of five possible interrupt sources are pending.
	// Position of MR0INT field.
	CT32B0_IR_MR0INT_Pos = 0x0
	// Bit mask of MR0INT field.
	CT32B0_IR_MR0INT_Msk = 0x1
	// Bit MR0INT.
	CT32B0_IR_MR0INT = 0x1
	// Position of MR1INT field.
	CT32B0_IR_MR1INT_Pos = 0x1
	// Bit mask of MR1INT field.
	CT32B0_IR_MR1INT_Msk = 0x2
	// Bit MR1INT.
	CT32B0_IR_MR1INT = 0x2
	// Position of MR2INT field.
	CT32B0_IR_MR2INT_Pos = 0x2
	// Bit mask of MR2INT field.
	CT32B0_IR_MR2INT_Msk = 0x4
	// Bit MR2INT.
	CT32B0_IR_MR2INT = 0x4
	// Position of MR3INT field.
	CT32B0_IR_MR3INT_Pos = 0x3
	// Bit mask of MR3INT field.
	CT32B0_IR_MR3INT_Msk = 0x8
	// Bit MR3INT.
	CT32B0_IR_MR3INT = 0x8
	// Position of CR0INT field.
	CT32B0_IR_CR0INT_Pos = 0x4
	// Bit mask of CR0INT field.
	CT32B0_IR_CR0INT_Msk = 0x10
	// Bit CR0INT.
	CT32B0_IR_CR0INT = 0x10
	// Position of CR1INT field.
	CT32B0_IR_CR1INT_Pos = 0x5
	// Bit mask of CR1INT field.
	CT32B0_IR_CR1INT_Msk = 0x20
	// Bit CR1INT.
	CT32B0_IR_CR1INT = 0x20
	// Position of RESERVED field.
	CT32B0_IR_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	CT32B0_IR_RESERVED_Msk = 0xffffffc0

	// TCR: Timer Control Register (TCR). The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR.
	// Position of CEN field.
	CT32B0_TCR_CEN_Pos = 0x0
	// Bit mask of CEN field.
	CT32B0_TCR_CEN_Msk = 0x1
	// Bit CEN.
	CT32B0_TCR_CEN = 0x1
	// Position of CRST field.
	CT32B0_TCR_CRST_Pos = 0x1
	// Bit mask of CRST field.
	CT32B0_TCR_CRST_Msk = 0x2
	// Bit CRST.
	CT32B0_TCR_CRST = 0x2
	// Position of RESERVED field.
	CT32B0_TCR_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	CT32B0_TCR_RESERVED_Msk = 0xfffffffc

	// TC: Timer Counter (TC). The 32-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR.
	// Position of TC field.
	CT32B0_TC_TC_Pos = 0x0
	// Bit mask of TC field.
	CT32B0_TC_TC_Msk = 0xffffffff

	// PR: Prescale Register (PR). When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC.
	// Position of PR field.
	CT32B0_PR_PR_Pos = 0x0
	// Bit mask of PR field.
	CT32B0_PR_PR_Msk = 0xffffffff

	// PC: Prescale Counter (PC). The 32-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface.
	// Position of PC field.
	CT32B0_PC_PC_Pos = 0x0
	// Bit mask of PC field.
	CT32B0_PC_PC_Msk = 0xffffffff

	// MCR: Match Control Register (MCR). The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs.
	// Position of MR0I field.
	CT32B0_MCR_MR0I_Pos = 0x0
	// Bit mask of MR0I field.
	CT32B0_MCR_MR0I_Msk = 0x1
	// Bit MR0I.
	CT32B0_MCR_MR0I = 0x1
	// Enabled
	CT32B0_MCR_MR0I_ENABLED = 0x1
	// Disabled
	CT32B0_MCR_MR0I_DISABLED = 0x0
	// Position of MR0R field.
	CT32B0_MCR_MR0R_Pos = 0x1
	// Bit mask of MR0R field.
	CT32B0_MCR_MR0R_Msk = 0x2
	// Bit MR0R.
	CT32B0_MCR_MR0R = 0x2
	// Enabled
	CT32B0_MCR_MR0R_ENABLED = 0x1
	// Disabled
	CT32B0_MCR_MR0R_DISABLED = 0x0
	// Position of MR0S field.
	CT32B0_MCR_MR0S_Pos = 0x2
	// Bit mask of MR0S field.
	CT32B0_MCR_MR0S_Msk = 0x4
	// Bit MR0S.
	CT32B0_MCR_MR0S = 0x4
	// Enabled
	CT32B0_MCR_MR0S_ENABLED = 0x1
	// Disabled
	CT32B0_MCR_MR0S_DISABLED = 0x0
	// Position of MR1I field.
	CT32B0_MCR_MR1I_Pos = 0x3
	// Bit mask of MR1I field.
	CT32B0_MCR_MR1I_Msk = 0x8
	// Bit MR1I.
	CT32B0_MCR_MR1I = 0x8
	// Enabled
	CT32B0_MCR_MR1I_ENABLED = 0x1
	// Disabled
	CT32B0_MCR_MR1I_DISABLED = 0x0
	// Position of MR1R field.
	CT32B0_MCR_MR1R_Pos = 0x4
	// Bit mask of MR1R field.
	CT32B0_MCR_MR1R_Msk = 0x10
	// Bit MR1R.
	CT32B0_MCR_MR1R = 0x10
	// Enabled
	CT32B0_MCR_MR1R_ENABLED = 0x1
	// Disabled
	CT32B0_MCR_MR1R_DISABLED = 0x0
	// Position of MR1S field.
	CT32B0_MCR_MR1S_Pos = 0x5
	// Bit mask of MR1S field.
	CT32B0_MCR_MR1S_Msk = 0x20
	// Bit MR1S.
	CT32B0_MCR_MR1S = 0x20
	// Enabled
	CT32B0_MCR_MR1S_ENABLED = 0x1
	// Disabled
	CT32B0_MCR_MR1S_DISABLED = 0x0
	// Position of MR2I field.
	CT32B0_MCR_MR2I_Pos = 0x6
	// Bit mask of MR2I field.
	CT32B0_MCR_MR2I_Msk = 0x40
	// Bit MR2I.
	CT32B0_MCR_MR2I = 0x40
	// Enabled
	CT32B0_MCR_MR2I_ENABLED = 0x1
	// Disabled
	CT32B0_MCR_MR2I_DISABLED = 0x0
	// Position of MR2R field.
	CT32B0_MCR_MR2R_Pos = 0x7
	// Bit mask of MR2R field.
	CT32B0_MCR_MR2R_Msk = 0x80
	// Bit MR2R.
	CT32B0_MCR_MR2R = 0x80
	// Enabled
	CT32B0_MCR_MR2R_ENABLED = 0x1
	// Disabled
	CT32B0_MCR_MR2R_DISABLED = 0x0
	// Position of MR2S field.
	CT32B0_MCR_MR2S_Pos = 0x8
	// Bit mask of MR2S field.
	CT32B0_MCR_MR2S_Msk = 0x100
	// Bit MR2S.
	CT32B0_MCR_MR2S = 0x100
	// Enabled
	CT32B0_MCR_MR2S_ENABLED = 0x1
	// Disabled
	CT32B0_MCR_MR2S_DISABLED = 0x0
	// Position of MR3I field.
	CT32B0_MCR_MR3I_Pos = 0x9
	// Bit mask of MR3I field.
	CT32B0_MCR_MR3I_Msk = 0x200
	// Bit MR3I.
	CT32B0_MCR_MR3I = 0x200
	// Enabled
	CT32B0_MCR_MR3I_ENABLED = 0x1
	// Disabled
	CT32B0_MCR_MR3I_DISABLED = 0x0
	// Position of MR3R field.
	CT32B0_MCR_MR3R_Pos = 0xa
	// Bit mask of MR3R field.
	CT32B0_MCR_MR3R_Msk = 0x400
	// Bit MR3R.
	CT32B0_MCR_MR3R = 0x400
	// Enabled
	CT32B0_MCR_MR3R_ENABLED = 0x1
	// Disabled
	CT32B0_MCR_MR3R_DISABLED = 0x0
	// Position of MR3S field.
	CT32B0_MCR_MR3S_Pos = 0xb
	// Bit mask of MR3S field.
	CT32B0_MCR_MR3S_Msk = 0x800
	// Bit MR3S.
	CT32B0_MCR_MR3S = 0x800
	// Enabled
	CT32B0_MCR_MR3S_ENABLED = 0x1
	// Disabled
	CT32B0_MCR_MR3S_DISABLED = 0x0
	// Position of RESERVED field.
	CT32B0_MCR_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CT32B0_MCR_RESERVED_Msk = 0xfffff000

	// MR0: Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
	// Position of MATCH field.
	CT32B0_MR_MATCH_Pos = 0x0
	// Bit mask of MATCH field.
	CT32B0_MR_MATCH_Msk = 0xffffffff

	// CCR: Capture Control Register (CCR). The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place.
	// Position of CAP0RE field.
	CT32B0_CCR_CAP0RE_Pos = 0x0
	// Bit mask of CAP0RE field.
	CT32B0_CCR_CAP0RE_Msk = 0x1
	// Bit CAP0RE.
	CT32B0_CCR_CAP0RE = 0x1
	// Enabled
	CT32B0_CCR_CAP0RE_ENABLED = 0x1
	// Disabled
	CT32B0_CCR_CAP0RE_DISABLED = 0x0
	// Position of CAP0FE field.
	CT32B0_CCR_CAP0FE_Pos = 0x1
	// Bit mask of CAP0FE field.
	CT32B0_CCR_CAP0FE_Msk = 0x2
	// Bit CAP0FE.
	CT32B0_CCR_CAP0FE = 0x2
	// Enabled
	CT32B0_CCR_CAP0FE_ENABLED = 0x1
	// Disabled
	CT32B0_CCR_CAP0FE_DISABLED = 0x0
	// Position of CAP0I field.
	CT32B0_CCR_CAP0I_Pos = 0x2
	// Bit mask of CAP0I field.
	CT32B0_CCR_CAP0I_Msk = 0x4
	// Bit CAP0I.
	CT32B0_CCR_CAP0I = 0x4
	// Enabled
	CT32B0_CCR_CAP0I_ENABLED = 0x1
	// Disabled
	CT32B0_CCR_CAP0I_DISABLED = 0x0
	// Position of CAP1RE field.
	CT32B0_CCR_CAP1RE_Pos = 0x3
	// Bit mask of CAP1RE field.
	CT32B0_CCR_CAP1RE_Msk = 0x8
	// Bit CAP1RE.
	CT32B0_CCR_CAP1RE = 0x8
	// Enabled
	CT32B0_CCR_CAP1RE_ENABLED = 0x1
	// Disabled
	CT32B0_CCR_CAP1RE_DISABLED = 0x0
	// Position of CAP1FE field.
	CT32B0_CCR_CAP1FE_Pos = 0x4
	// Bit mask of CAP1FE field.
	CT32B0_CCR_CAP1FE_Msk = 0x10
	// Bit CAP1FE.
	CT32B0_CCR_CAP1FE = 0x10
	// Enabled
	CT32B0_CCR_CAP1FE_ENABLED = 0x1
	// Disabled
	CT32B0_CCR_CAP1FE_DISABLED = 0x0
	// Position of CAP1I field.
	CT32B0_CCR_CAP1I_Pos = 0x5
	// Bit mask of CAP1I field.
	CT32B0_CCR_CAP1I_Msk = 0x20
	// Bit CAP1I.
	CT32B0_CCR_CAP1I = 0x20
	// Enabled
	CT32B0_CCR_CAP1I_ENABLED = 0x1
	// Disabled
	CT32B0_CCR_CAP1I_DISABLED = 0x0
	// Position of RESERVED field.
	CT32B0_CCR_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	CT32B0_CCR_RESERVED_Msk = 0xffffffc0

	// CR0: Capture Register (CR). CR is loaded with the value of TC when there is an event on the CT16Bn_CAPm input.
	// Position of CAP field.
	CT32B0_CR_CAP_Pos = 0x0
	// Bit mask of CAP field.
	CT32B0_CR_CAP_Msk = 0xffffffff

	// EMR: External Match Register (EMR). The EMR controls the match function and the external match pins CT32B0_MAT[3:0].
	// Position of EM0 field.
	CT32B0_EMR_EM0_Pos = 0x0
	// Bit mask of EM0 field.
	CT32B0_EMR_EM0_Msk = 0x1
	// Bit EM0.
	CT32B0_EMR_EM0 = 0x1
	// Position of EM1 field.
	CT32B0_EMR_EM1_Pos = 0x1
	// Bit mask of EM1 field.
	CT32B0_EMR_EM1_Msk = 0x2
	// Bit EM1.
	CT32B0_EMR_EM1 = 0x2
	// Position of EM2 field.
	CT32B0_EMR_EM2_Pos = 0x2
	// Bit mask of EM2 field.
	CT32B0_EMR_EM2_Msk = 0x4
	// Bit EM2.
	CT32B0_EMR_EM2 = 0x4
	// Position of EM3 field.
	CT32B0_EMR_EM3_Pos = 0x3
	// Bit mask of EM3 field.
	CT32B0_EMR_EM3_Msk = 0x8
	// Bit EM3.
	CT32B0_EMR_EM3 = 0x8
	// Position of EMC0 field.
	CT32B0_EMR_EMC0_Pos = 0x4
	// Bit mask of EMC0 field.
	CT32B0_EMR_EMC0_Msk = 0x30
	// Do Nothing.
	CT32B0_EMR_EMC0_DO_NOTHING_ = 0x0
	// Clear the corresponding External Match bit/output to 0 (CT32Bn_MATm pin is LOW if pinned out).
	CT32B0_EMR_EMC0_CLEAR_THE_CORRESPOND = 0x1
	// Set the corresponding External Match bit/output to 1 (CT32Bn_MATm pin is HIGH if pinned out).
	CT32B0_EMR_EMC0_SET_THE_CORRESPONDIN = 0x2
	// Toggle the corresponding External Match bit/output.
	CT32B0_EMR_EMC0_TOGGLE_THE_CORRESPON = 0x3
	// Position of EMC1 field.
	CT32B0_EMR_EMC1_Pos = 0x6
	// Bit mask of EMC1 field.
	CT32B0_EMR_EMC1_Msk = 0xc0
	// Do Nothing.
	CT32B0_EMR_EMC1_DO_NOTHING_ = 0x0
	// Clear the corresponding External Match bit/output to 0 (CT32Bn_MATm pin is LOW if pinned out).
	CT32B0_EMR_EMC1_CLEAR_THE_CORRESPOND = 0x1
	// Set the corresponding External Match bit/output to 1 (CT32Bn_MATm pin is HIGH if pinned out).
	CT32B0_EMR_EMC1_SET_THE_CORRESPONDIN = 0x2
	// Toggle the corresponding External Match bit/output.
	CT32B0_EMR_EMC1_TOGGLE_THE_CORRESPON = 0x3
	// Position of EMC2 field.
	CT32B0_EMR_EMC2_Pos = 0x8
	// Bit mask of EMC2 field.
	CT32B0_EMR_EMC2_Msk = 0x300
	// Do Nothing.
	CT32B0_EMR_EMC2_DO_NOTHING_ = 0x0
	// Clear the corresponding External Match bit/output to 0 (CT32Bn_MATm pin is LOW if pinned out).
	CT32B0_EMR_EMC2_CLEAR_THE_CORRESPOND = 0x1
	// Set the corresponding External Match bit/output to 1 (CT32Bn_MATm pin is HIGH if pinned out).
	CT32B0_EMR_EMC2_SET_THE_CORRESPONDIN = 0x2
	// Toggle the corresponding External Match bit/output.
	CT32B0_EMR_EMC2_TOGGLE_THE_CORRESPON = 0x3
	// Position of EMC3 field.
	CT32B0_EMR_EMC3_Pos = 0xa
	// Bit mask of EMC3 field.
	CT32B0_EMR_EMC3_Msk = 0xc00
	// Do Nothing.
	CT32B0_EMR_EMC3_DO_NOTHING_ = 0x0
	// Clear the corresponding External Match bit/output to 0 (CT32Bn_MATm pin is LOW if pinned out).
	CT32B0_EMR_EMC3_CLEAR_THE_CORRESPOND = 0x1
	// Set the corresponding External Match bit/output to 1 (CT32Bn_MATm pin is HIGH if pinned out).
	CT32B0_EMR_EMC3_SET_THE_CORRESPONDIN = 0x2
	// Toggle the corresponding External Match bit/output.
	CT32B0_EMR_EMC3_TOGGLE_THE_CORRESPON = 0x3
	// Position of RESERVED field.
	CT32B0_EMR_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	CT32B0_EMR_RESERVED_Msk = 0xfffff000

	// CTCR: Count Control Register (CTCR). The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.
	// Position of CTM field.
	CT32B0_CTCR_CTM_Pos = 0x0
	// Bit mask of CTM field.
	CT32B0_CTCR_CTM_Msk = 0x3
	// Timer Mode: every rising PCLK edge
	CT32B0_CTCR_CTM_TIMER_MODE_EVERY_RI = 0x0
	// Position of CIS field.
	CT32B0_CTCR_CIS_Pos = 0x2
	// Bit mask of CIS field.
	CT32B0_CTCR_CIS_Msk = 0xc
	// CT32Bn_CAP0
	CT32B0_CTCR_CIS_CT32BN_CAP0 = 0x0
	// CT32Bn_CAP1
	CT32B0_CTCR_CIS_CT32BN_CAP1 = 0x1
	// Reserved Note: If Counter mode is selected in the TnCTCR, the 3 bits for that input in the Capture Control Register (TnCCR) must be programmed as 000.
	CT32B0_CTCR_CIS_RESERVED_NOTE_IF_CO = 0x3
	// Position of ENCC field.
	CT32B0_CTCR_ENCC_Pos = 0x4
	// Bit mask of ENCC field.
	CT32B0_CTCR_ENCC_Msk = 0x10
	// Bit ENCC.
	CT32B0_CTCR_ENCC = 0x10
	// Position of SELCC field.
	CT32B0_CTCR_SELCC_Pos = 0x5
	// Bit mask of SELCC field.
	CT32B0_CTCR_SELCC_Msk = 0xe0
	// Rising Edge of CAP0 clears the timer (if bit 4 is set).
	CT32B0_CTCR_SELCC_RISING_EDGE_OF_CAP0_ = 0x0
	// Falling Edge of CAP0 clears the timer (if bit 4 is set).
	CT32B0_CTCR_SELCC_FALLING_EDGE_OF_CAP0 = 0x1
	// Rising Edge of CAP1 clears the timer (if bit 4 is set).
	CT32B0_CTCR_SELCC_RISING_EDGE_OF_CAP1_ = 0x2
	// Falling Edge of CAP1 clears the timer (if bit 4 is set).
	CT32B0_CTCR_SELCC_FALLING_EDGE_OF_CAP1 = 0x3
	// Position of RESERVED field.
	CT32B0_CTCR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	CT32B0_CTCR_RESERVED_Msk = 0xffffff00

	// PWMC: PWM Control Register (PWMCON). The PWMCON enables PWM mode for the external match pins CT32B0_MAT[3:0].
	// Position of PWMEN0 field.
	CT32B0_PWMC_PWMEN0_Pos = 0x0
	// Bit mask of PWMEN0 field.
	CT32B0_PWMC_PWMEN0_Msk = 0x1
	// Bit PWMEN0.
	CT32B0_PWMC_PWMEN0 = 0x1
	// CT32Bn_MAT0 is controlled by EM0.
	CT32B0_PWMC_PWMEN0_CT32BN_MAT0_IS_CONTR = 0x0
	// PWM mode is enabled for CT32Bn_MAT0.
	CT32B0_PWMC_PWMEN0_PWM_MODE_IS_ENABLED_ = 0x1
	// Position of PWMEN1 field.
	CT32B0_PWMC_PWMEN1_Pos = 0x1
	// Bit mask of PWMEN1 field.
	CT32B0_PWMC_PWMEN1_Msk = 0x2
	// Bit PWMEN1.
	CT32B0_PWMC_PWMEN1 = 0x2
	// CT32Bn_MAT1 is controlled by EM1.
	CT32B0_PWMC_PWMEN1_CT32BN_MAT1_IS_CONTR = 0x0
	// PWM mode is enabled for CT32Bn_MAT1.
	CT32B0_PWMC_PWMEN1_PWM_MODE_IS_ENABLED_ = 0x1
	// Position of PWMEN2 field.
	CT32B0_PWMC_PWMEN2_Pos = 0x2
	// Bit mask of PWMEN2 field.
	CT32B0_PWMC_PWMEN2_Msk = 0x4
	// Bit PWMEN2.
	CT32B0_PWMC_PWMEN2 = 0x4
	// CT32Bn_MAT2 is controlled by EM2.
	CT32B0_PWMC_PWMEN2_CT32BN_MAT2_IS_CONTR = 0x0
	// PWM mode is enabled for CT32Bn_MAT2.
	CT32B0_PWMC_PWMEN2_PWM_MODE_IS_ENABLED_ = 0x1
	// Position of PWMEN3 field.
	CT32B0_PWMC_PWMEN3_Pos = 0x3
	// Bit mask of PWMEN3 field.
	CT32B0_PWMC_PWMEN3_Msk = 0x8
	// Bit PWMEN3.
	CT32B0_PWMC_PWMEN3 = 0x8
	// CT32Bn_MAT3 is controlled by EM3.
	CT32B0_PWMC_PWMEN3_CT32BN_MAT3_IS_CONTR = 0x0
	// PWM mode is enabled for CT32Bn_MAT3.
	CT32B0_PWMC_PWMEN3_PWM_MODE_IS_ENABLED_ = 0x1
	// Position of RESERVED field.
	CT32B0_PWMC_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	CT32B0_PWMC_RESERVED_Msk = 0xfffffff0
)

// Constants for ADC: 10-bit ADC
const (
	// CR: A/D Control Register. The ADCR register must be written to select the operating mode before A/D conversion can occur.
	// Position of SEL field.
	ADC_CR_SEL_Pos = 0x0
	// Bit mask of SEL field.
	ADC_CR_SEL_Msk = 0xff
	// Position of CLKDIV field.
	ADC_CR_CLKDIV_Pos = 0x8
	// Bit mask of CLKDIV field.
	ADC_CR_CLKDIV_Msk = 0xff00
	// Position of BURST field.
	ADC_CR_BURST_Pos = 0x10
	// Bit mask of BURST field.
	ADC_CR_BURST_Msk = 0x10000
	// Bit BURST.
	ADC_CR_BURST = 0x10000
	// Software-controlled mode: Conversions are software-controlled and require 11 clocks.
	ADC_CR_BURST_SWMODE = 0x0
	// Hardware scan mode: The AD converter does repeated conversions at the rate selected by the CLKS field, scanning (if necessary) through the pins selected by 1s in the SEL field. The first conversion after the start corresponds to the least-significant bit set to 1 in the SEL field, then the next higher bits (pins) set to 1 are scanned if applicable. Repeated conversions can be terminated by clearing this bit, but the conversion in progress when this bit is cleared will be completed. Important: START bits must be 000 when BURST = 1 or conversions will not start.
	ADC_CR_BURST_HWMODE = 0x1
	// Position of CLKS field.
	ADC_CR_CLKS_Pos = 0x11
	// Bit mask of CLKS field.
	ADC_CR_CLKS_Msk = 0xe0000
	// 11 clocks / 10 bits
	ADC_CR_CLKS_10BIT = 0x0
	// 10 clocks / 9 bits
	ADC_CR_CLKS_9BIT = 0x1
	// 9 clocks / 8 bits
	ADC_CR_CLKS_8BIT = 0x2
	// 8 clocks / 7 bits
	ADC_CR_CLKS_7BIT = 0x3
	// 7 clocks / 6 bits
	ADC_CR_CLKS_6BIT = 0x4
	// 6 clocks / 5 bits
	ADC_CR_CLKS_5BIT = 0x5
	// 5 clocks / 4 bits
	ADC_CR_CLKS_4BIT = 0x6
	// 4 clocks / 3 bits
	ADC_CR_CLKS_3BIT = 0x7
	// Position of RESERVED field.
	ADC_CR_RESERVED_Pos = 0x14
	// Bit mask of RESERVED field.
	ADC_CR_RESERVED_Msk = 0xf00000
	// Position of START field.
	ADC_CR_START_Pos = 0x18
	// Bit mask of START field.
	ADC_CR_START_Msk = 0x7000000
	// No start (this value should be used when clearing PDN to 0).
	ADC_CR_START_STOP = 0x0
	// Start conversion now.
	ADC_CR_START_START = 0x1
	// Start conversion when the edge selected by bit 27 occurs on PIO0_2/SSEL/CT16B0_CAP0.
	ADC_CR_START_EDGEPIO0_2 = 0x2
	// Start conversion when the edge selected by bit 27 occurs on PIO1_5/DIR/CT32B0_CAP0.
	ADC_CR_START_EDGEPIO1_5 = 0x3
	// Start conversion when the edge selected by bit 27 occurs on CT32B0_MAT0[1].
	ADC_CR_START_EDGECT32B0_MAT0_1 = 0x4
	// Start conversion when the edge selected by bit 27 occurs on CT32B0_MAT1[1].
	ADC_CR_START_EDGECT32B0_MAT1_1 = 0x5
	// Start conversion when the edge selected by bit 27 occurs on CT16B0_MAT0[1].
	ADC_CR_START_EDGECT16B0_MAT0_1 = 0x6
	// Start conversion when the edge selected by bit 27 occurs on CT16B0_MAT1[1].
	ADC_CR_START_EDGECT16B0_MAT1_1 = 0x7
	// Position of EDGE field.
	ADC_CR_EDGE_Pos = 0x1b
	// Bit mask of EDGE field.
	ADC_CR_EDGE_Msk = 0x8000000
	// Bit EDGE.
	ADC_CR_EDGE = 0x8000000
	// Start conversion on a rising edge on the selected CAP/MAT signal.
	ADC_CR_EDGE_RISING = 0x0
	// Start conversion on a rising edge on the selected CAP/MAT signal.
	ADC_CR_EDGE_FALLING = 0x1
	// Position of RESERVED field.
	ADC_CR_RESERVED_Pos = 0x1c
	// Bit mask of RESERVED field.
	ADC_CR_RESERVED_Msk = 0xf0000000

	// GDR: A/D Global Data Register. Contains the result of the most recent A/D conversion.
	// Position of RESERVED field.
	ADC_GDR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	ADC_GDR_RESERVED_Msk = 0x3f
	// Position of V_VREF field.
	ADC_GDR_V_VREF_Pos = 0x6
	// Bit mask of V_VREF field.
	ADC_GDR_V_VREF_Msk = 0xffc0
	// Position of RESERVED field.
	ADC_GDR_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	ADC_GDR_RESERVED_Msk = 0xff0000
	// Position of CHN field.
	ADC_GDR_CHN_Pos = 0x18
	// Bit mask of CHN field.
	ADC_GDR_CHN_Msk = 0x7000000
	// Position of RESERVED field.
	ADC_GDR_RESERVED_Pos = 0x1b
	// Bit mask of RESERVED field.
	ADC_GDR_RESERVED_Msk = 0x38000000
	// Position of OVERRUN field.
	ADC_GDR_OVERRUN_Pos = 0x1e
	// Bit mask of OVERRUN field.
	ADC_GDR_OVERRUN_Msk = 0x40000000
	// Bit OVERRUN.
	ADC_GDR_OVERRUN = 0x40000000
	// Position of DONE field.
	ADC_GDR_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	ADC_GDR_DONE_Msk = 0x80000000
	// Bit DONE.
	ADC_GDR_DONE = 0x80000000

	// INTEN: A/D Interrupt Enable Register. This register contains enable bits that allow the DONE flag of each A/D channel to be included or excluded from contributing to the generation of an A/D interrupt.
	// Position of ADINTENn field.
	ADC_INTEN_ADINTENn_Pos = 0x0
	// Bit mask of ADINTENn field.
	ADC_INTEN_ADINTENn_Msk = 0xff
	// Position of ADGINTEN field.
	ADC_INTEN_ADGINTEN_Pos = 0x8
	// Bit mask of ADGINTEN field.
	ADC_INTEN_ADGINTEN_Msk = 0x100
	// Bit ADGINTEN.
	ADC_INTEN_ADGINTEN = 0x100
	// Position of RESERVED field.
	ADC_INTEN_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	ADC_INTEN_RESERVED_Msk = 0xfffffe00

	// DR0: A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
	// Position of RESERVED field.
	ADC_DR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	ADC_DR_RESERVED_Msk = 0x3f
	// Position of V_VREF field.
	ADC_DR_V_VREF_Pos = 0x6
	// Bit mask of V_VREF field.
	ADC_DR_V_VREF_Msk = 0xffc0
	// Position of RESERVED field.
	ADC_DR_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	ADC_DR_RESERVED_Msk = 0x3fff0000
	// Position of OVERRUN field.
	ADC_DR_OVERRUN_Pos = 0x1e
	// Bit mask of OVERRUN field.
	ADC_DR_OVERRUN_Msk = 0x40000000
	// Bit OVERRUN.
	ADC_DR_OVERRUN = 0x40000000
	// Position of DONE field.
	ADC_DR_DONE_Pos = 0x1f
	// Bit mask of DONE field.
	ADC_DR_DONE_Msk = 0x80000000
	// Bit DONE.
	ADC_DR_DONE = 0x80000000

	// STAT: A/D Status Register. This register contains DONE and OVERRUN flags for all of the A/D channels, as well as the A/D interrupt flag.
	// Position of DONE field.
	ADC_STAT_DONE_Pos = 0x0
	// Bit mask of DONE field.
	ADC_STAT_DONE_Msk = 0xff
	// Position of OVERRUN field.
	ADC_STAT_OVERRUN_Pos = 0x8
	// Bit mask of OVERRUN field.
	ADC_STAT_OVERRUN_Msk = 0xff00
	// Position of ADINT field.
	ADC_STAT_ADINT_Pos = 0x10
	// Bit mask of ADINT field.
	ADC_STAT_ADINT_Msk = 0x10000
	// Bit ADINT.
	ADC_STAT_ADINT = 0x10000
	// Position of RESERVED field.
	ADC_STAT_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	ADC_STAT_RESERVED_Msk = 0xfffe0000
)

// Constants for PMU: power management unit
const (
	// PCON: Power control register
	// Position of RESERVED field.
	PMU_PCON_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	PMU_PCON_RESERVED_Msk = 0x1
	// Bit RESERVED.
	PMU_PCON_RESERVED = 0x1
	// Position of DPDEN field.
	PMU_PCON_DPDEN_Pos = 0x1
	// Bit mask of DPDEN field.
	PMU_PCON_DPDEN_Msk = 0x2
	// Bit DPDEN.
	PMU_PCON_DPDEN = 0x2
	// ARM WFI will enter Sleep or Deep-sleep mode (clock to ARM Cortex-M0 core turned off).
	PMU_PCON_DPDEN_SLEEPMODE = 0x0
	// ARM WFI will enter Deep-power down mode (ARM Cortex-M0 core powered-down).
	PMU_PCON_DPDEN_DEEPPOWERDOWN = 0x1
	// Position of RESERVED field.
	PMU_PCON_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	PMU_PCON_RESERVED_Msk = 0xfc
	// Position of SLEEPFLAG field.
	PMU_PCON_SLEEPFLAG_Pos = 0x8
	// Bit mask of SLEEPFLAG field.
	PMU_PCON_SLEEPFLAG_Msk = 0x100
	// Bit SLEEPFLAG.
	PMU_PCON_SLEEPFLAG = 0x100
	// Read: No power-down mode entered. LPC111x/LPC11C1x is in Active mode. Write: No effect.
	PMU_PCON_SLEEPFLAG_NOPOWERDOWN = 0x0
	// Read: Sleep/Deep-sleep or Deep power-down mode entered. Write: Writing a 1 clears the SLEEPFLAG bit to 0.
	PMU_PCON_SLEEPFLAG_POWERDOWN = 0x1
	// Position of RESERVED field.
	PMU_PCON_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	PMU_PCON_RESERVED_Msk = 0x600
	// Position of DPDFLAG field.
	PMU_PCON_DPDFLAG_Pos = 0xb
	// Bit mask of DPDFLAG field.
	PMU_PCON_DPDFLAG_Msk = 0x800
	// Bit DPDFLAG.
	PMU_PCON_DPDFLAG = 0x800
	// Read: Deep power-down mode not entered. Write: No effect.
	PMU_PCON_DPDFLAG_NODEEPPOWERDOWN = 0x0
	// Read: Deep power-down mode entered. Write: Clear the Deep power-down flag.
	PMU_PCON_DPDFLAG_DEEPPOWERDOWN = 0x1
	// Position of RESERVED field.
	PMU_PCON_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	PMU_PCON_RESERVED_Msk = 0xfffff000

	// GPREG0: General purpose register
	// Position of GPDATA field.
	PMU_GPREG_GPDATA_Pos = 0x0
	// Bit mask of GPDATA field.
	PMU_GPREG_GPDATA_Msk = 0xffffffff

	// GPREG4: General purpose register 4
	// Position of RESERVED field.
	PMU_GPREG4_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	PMU_GPREG4_RESERVED_Msk = 0x3ff
	// Position of WAKEUPHYS field.
	PMU_GPREG4_WAKEUPHYS_Pos = 0xa
	// Bit mask of WAKEUPHYS field.
	PMU_GPREG4_WAKEUPHYS_Msk = 0x400
	// Bit WAKEUPHYS.
	PMU_GPREG4_WAKEUPHYS = 0x400
	// Hysteresis for WAKEUP pin enabled.
	PMU_GPREG4_WAKEUPHYS_ENABLED = 0x1
	// Hysteresis for WAKUP pin disabled.
	PMU_GPREG4_WAKEUPHYS_DISABLED = 0x0
	// Position of GPDATA field.
	PMU_GPREG4_GPDATA_Pos = 0xb
	// Bit mask of GPDATA field.
	PMU_GPREG4_GPDATA_Msk = 0xfffff800
)

// Constants for FLASHCTRL: Product name title=UM10462 Chapter title=LPC11U1x Flash programming firmware Modification date=3/17/2011 Major revision=0 Minor revision=3
const (
	// FLASHCFG: Flash memory access time configuration register
	// Position of FLASHTIM field.
	FLASHCTRL_FLASHCFG_FLASHTIM_Pos = 0x0
	// Bit mask of FLASHTIM field.
	FLASHCTRL_FLASHCFG_FLASHTIM_Msk = 0x3
	// 1 system clock flash access time (for system clock frequencies of up to 20 MHz).
	FLASHCTRL_FLASHCFG_FLASHTIM_1_SYSTEM_CLOCK_FLASH = 0x1
	// 2 system clocks flash access time (for system clock frequencies of up to 40 MHz).
	FLASHCTRL_FLASHCFG_FLASHTIM_2_SYSTEM_CLOCKS_FLAS = 0x2
	// 3 system clocks flash access time (for system clock frequencies of up to 50 MHz).
	FLASHCTRL_FLASHCFG_FLASHTIM_3_SYSTEM_CLOCKS_FLAS = 0x3
	// Position of RESERVED field.
	FLASHCTRL_FLASHCFG_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	FLASHCTRL_FLASHCFG_RESERVED_Msk = 0xfffffffc

	// FMSSTART: Signature start address register
	// Position of START field.
	FLASHCTRL_FMSSTART_START_Pos = 0x0
	// Bit mask of START field.
	FLASHCTRL_FMSSTART_START_Msk = 0x1ffff
	// Position of RESERVED field.
	FLASHCTRL_FMSSTART_RESERVED_Pos = 0x11
	// Bit mask of RESERVED field.
	FLASHCTRL_FMSSTART_RESERVED_Msk = 0xfffe0000

	// FMSSTOP: Signature stop-address register
	// Position of STOP field.
	FLASHCTRL_FMSSTOP_STOP_Pos = 0x0
	// Bit mask of STOP field.
	FLASHCTRL_FMSSTOP_STOP_Msk = 0x1ffff
	// Position of SIG_START field.
	FLASHCTRL_FMSSTOP_SIG_START_Pos = 0x11
	// Bit mask of SIG_START field.
	FLASHCTRL_FMSSTOP_SIG_START_Msk = 0x20000
	// Bit SIG_START.
	FLASHCTRL_FMSSTOP_SIG_START = 0x20000
	// Signature generation is stopped
	FLASHCTRL_FMSSTOP_SIG_START_SIGNATURE_GENERATION = 0x0
	// Initiate signature generation
	FLASHCTRL_FMSSTOP_SIG_START_INITIATE_SIGNATURE_G = 0x1
	// Position of RESERVED field.
	FLASHCTRL_FMSSTOP_RESERVED_Pos = 0x12
	// Bit mask of RESERVED field.
	FLASHCTRL_FMSSTOP_RESERVED_Msk = 0xfffc0000

	// FMSW0: Word 0 [31:0]
	// Position of SW0_31_0 field.
	FLASHCTRL_FMSW0_SW0_31_0_Pos = 0x0
	// Bit mask of SW0_31_0 field.
	FLASHCTRL_FMSW0_SW0_31_0_Msk = 0xffffffff

	// FMSW1: Word 1 [63:32]
	// Position of SW1_63_32 field.
	FLASHCTRL_FMSW1_SW1_63_32_Pos = 0x0
	// Bit mask of SW1_63_32 field.
	FLASHCTRL_FMSW1_SW1_63_32_Msk = 0xffffffff

	// FMSW2: Word 2 [95:64]
	// Position of SW2_95_64 field.
	FLASHCTRL_FMSW2_SW2_95_64_Pos = 0x0
	// Bit mask of SW2_95_64 field.
	FLASHCTRL_FMSW2_SW2_95_64_Msk = 0xffffffff

	// FMSW3: Word 3 [127:96]
	// Position of SW3_127_96 field.
	FLASHCTRL_FMSW3_SW3_127_96_Pos = 0x0
	// Bit mask of SW3_127_96 field.
	FLASHCTRL_FMSW3_SW3_127_96_Msk = 0xffffffff

	// FMSTAT: Signature generation status register
	// Position of RESERVED field.
	FLASHCTRL_FMSTAT_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	FLASHCTRL_FMSTAT_RESERVED_Msk = 0x3
	// Position of SIG_DONE field.
	FLASHCTRL_FMSTAT_SIG_DONE_Pos = 0x2
	// Bit mask of SIG_DONE field.
	FLASHCTRL_FMSTAT_SIG_DONE_Msk = 0x4
	// Bit SIG_DONE.
	FLASHCTRL_FMSTAT_SIG_DONE = 0x4
	// Position of RESERVED field.
	FLASHCTRL_FMSTAT_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	FLASHCTRL_FMSTAT_RESERVED_Msk = 0xfffffff8

	// FMSTATCLR: Signature generation status clear register
	// Position of RESERVED field.
	FLASHCTRL_FMSTATCLR_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	FLASHCTRL_FMSTATCLR_RESERVED_Msk = 0x3
	// Position of SIG_DONE_CLR field.
	FLASHCTRL_FMSTATCLR_SIG_DONE_CLR_Pos = 0x2
	// Bit mask of SIG_DONE_CLR field.
	FLASHCTRL_FMSTATCLR_SIG_DONE_CLR_Msk = 0x4
	// Bit SIG_DONE_CLR.
	FLASHCTRL_FMSTATCLR_SIG_DONE_CLR = 0x4
	// Position of RESERVED field.
	FLASHCTRL_FMSTATCLR_RESERVED_Pos = 0x3
	// Bit mask of RESERVED field.
	FLASHCTRL_FMSTATCLR_RESERVED_Msk = 0xfffffff8
)

// Constants for SPI0: SPI0
const (
	// CR0: Control Register 0. Selects the serial clock rate, bus type, and data size.
	// Position of DSS field.
	SPI_CR0_DSS_Pos = 0x0
	// Bit mask of DSS field.
	SPI_CR0_DSS_Msk = 0xf
	// 4-bit transfer
	SPI_CR0_DSS_4_BIT_TRANSFER = 0x3
	// 5-bit transfer
	SPI_CR0_DSS_5_BIT_TRANSFER = 0x4
	// 6-bit transfer
	SPI_CR0_DSS_6_BIT_TRANSFER = 0x5
	// 7-bit transfer
	SPI_CR0_DSS_7_BIT_TRANSFER = 0x6
	// 8-bit transfer
	SPI_CR0_DSS_8_BIT_TRANSFER = 0x7
	// 9-bit transfer
	SPI_CR0_DSS_9_BIT_TRANSFER = 0x8
	// 10-bit transfer
	SPI_CR0_DSS_10_BIT_TRANSFER = 0x9
	// 11-bit transfer
	SPI_CR0_DSS_11_BIT_TRANSFER = 0xa
	// 12-bit transfer
	SPI_CR0_DSS_12_BIT_TRANSFER = 0xb
	// 13-bit transfer
	SPI_CR0_DSS_13_BIT_TRANSFER = 0xc
	// 14-bit transfer
	SPI_CR0_DSS_14_BIT_TRANSFER = 0xd
	// 15-bit transfer
	SPI_CR0_DSS_15_BIT_TRANSFER = 0xe
	// 16-bit transfer
	SPI_CR0_DSS_16_BIT_TRANSFER = 0xf
	// Position of FRF field.
	SPI_CR0_FRF_Pos = 0x4
	// Bit mask of FRF field.
	SPI_CR0_FRF_Msk = 0x30
	// SPI
	SPI_CR0_FRF_SPI = 0x0
	// TI
	SPI_CR0_FRF_TI = 0x1
	// Microwire
	SPI_CR0_FRF_MICROWIRE = 0x2
	// Position of CPOL field.
	SPI_CR0_CPOL_Pos = 0x6
	// Bit mask of CPOL field.
	SPI_CR0_CPOL_Msk = 0x40
	// Bit CPOL.
	SPI_CR0_CPOL = 0x40
	// SPI controller maintains the bus clock low between frames.
	SPI_CR0_CPOL_LOW = 0x0
	// SPI controller maintains the bus clock high between frames.
	SPI_CR0_CPOL_HIGH = 0x1
	// Position of CPHA field.
	SPI_CR0_CPHA_Pos = 0x7
	// Bit mask of CPHA field.
	SPI_CR0_CPHA_Msk = 0x80
	// Bit CPHA.
	SPI_CR0_CPHA = 0x80
	// SPI controller captures serial data on the first clock transition of the frame, that is, the transition away from the inter-frame state of the clock line.
	SPI_CR0_CPHA_FIRSTCLOCK = 0x0
	// SPI controller captures serial data on the second clock transition of the frame, that is, the transition back to the inter-frame state of the clock line.
	SPI_CR0_CPHA_SECONDCLOCK = 0x1
	// Position of SCR field.
	SPI_CR0_SCR_Pos = 0x8
	// Bit mask of SCR field.
	SPI_CR0_SCR_Msk = 0xff00
	// Position of RESERVED field.
	SPI_CR0_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	SPI_CR0_RESERVED_Msk = 0xffff0000

	// CR1: Control Register 1. Selects master/slave and other modes.
	// Position of LBM field.
	SPI_CR1_LBM_Pos = 0x0
	// Bit mask of LBM field.
	SPI_CR1_LBM_Msk = 0x1
	// Bit LBM.
	SPI_CR1_LBM = 0x1
	// During normal operation.
	SPI_CR1_LBM_NORMAL = 0x0
	// Serial input is taken from the serial output (MOSI or MISO) rather than the serial input pin (MISO or MOSI respectively).
	SPI_CR1_LBM_LOOPBACK = 0x1
	// Position of SSE field.
	SPI_CR1_SSE_Pos = 0x1
	// Bit mask of SSE field.
	SPI_CR1_SSE_Msk = 0x2
	// Bit SSE.
	SPI_CR1_SSE = 0x2
	// The SPI controller is disabled.
	SPI_CR1_SSE_DISABLE = 0x0
	// The SPI controller will interact with other devices on the serial bus. Software should write the appropriate control information to the other SPI/SSP registers and interrupt controller registers, before setting this bit.
	SPI_CR1_SSE_ENABLE = 0x1
	// Position of MS field.
	SPI_CR1_MS_Pos = 0x2
	// Bit mask of MS field.
	SPI_CR1_MS_Msk = 0x4
	// Bit MS.
	SPI_CR1_MS = 0x4
	// The SPI controller acts as a master on the bus, driving the SCLK, MOSI, and SSEL lines and receiving the MISO line.
	SPI_CR1_MS_MASTER = 0x0
	// The SPI controller acts as a slave on the bus, driving MISO line and receiving SCLK, MOSI, and SSEL lines.
	SPI_CR1_MS_SLAVE = 0x1
	// Position of SOD field.
	SPI_CR1_SOD_Pos = 0x3
	// Bit mask of SOD field.
	SPI_CR1_SOD_Msk = 0x8
	// Bit SOD.
	SPI_CR1_SOD = 0x8
	// Position of RESERVED field.
	SPI_CR1_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	SPI_CR1_RESERVED_Msk = 0xfffffff0

	// DR: Data Register. Writes fill the transmit FIFO, and reads empty the receive FIFO.
	// Position of DATA field.
	SPI_DR_DATA_Pos = 0x0
	// Bit mask of DATA field.
	SPI_DR_DATA_Msk = 0xffff
	// Position of RESERVED field.
	SPI_DR_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	SPI_DR_RESERVED_Msk = 0xffff0000

	// SR: Status Register
	// Position of TFE field.
	SPI_SR_TFE_Pos = 0x0
	// Bit mask of TFE field.
	SPI_SR_TFE_Msk = 0x1
	// Bit TFE.
	SPI_SR_TFE = 0x1
	// Position of TNF field.
	SPI_SR_TNF_Pos = 0x1
	// Bit mask of TNF field.
	SPI_SR_TNF_Msk = 0x2
	// Bit TNF.
	SPI_SR_TNF = 0x2
	// Position of RNE field.
	SPI_SR_RNE_Pos = 0x2
	// Bit mask of RNE field.
	SPI_SR_RNE_Msk = 0x4
	// Bit RNE.
	SPI_SR_RNE = 0x4
	// Position of RFF field.
	SPI_SR_RFF_Pos = 0x3
	// Bit mask of RFF field.
	SPI_SR_RFF_Msk = 0x8
	// Bit RFF.
	SPI_SR_RFF = 0x8
	// Position of BSY field.
	SPI_SR_BSY_Pos = 0x4
	// Bit mask of BSY field.
	SPI_SR_BSY_Msk = 0x10
	// Bit BSY.
	SPI_SR_BSY = 0x10
	// Position of RESERVED field.
	SPI_SR_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	SPI_SR_RESERVED_Msk = 0xffffffe0

	// CPSR: Clock Prescale Register
	// Position of CPSDVSR field.
	SPI_CPSR_CPSDVSR_Pos = 0x0
	// Bit mask of CPSDVSR field.
	SPI_CPSR_CPSDVSR_Msk = 0xff
	// Position of RESERVED field.
	SPI_CPSR_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SPI_CPSR_RESERVED_Msk = 0xffffff00

	// IMSC: Interrupt Mask Set and Clear Register
	// Position of RORIM field.
	SPI_IMSC_RORIM_Pos = 0x0
	// Bit mask of RORIM field.
	SPI_IMSC_RORIM_Msk = 0x1
	// Bit RORIM.
	SPI_IMSC_RORIM = 0x1
	// Position of RTIM field.
	SPI_IMSC_RTIM_Pos = 0x1
	// Bit mask of RTIM field.
	SPI_IMSC_RTIM_Msk = 0x2
	// Bit RTIM.
	SPI_IMSC_RTIM = 0x2
	// Position of RXIM field.
	SPI_IMSC_RXIM_Pos = 0x2
	// Bit mask of RXIM field.
	SPI_IMSC_RXIM_Msk = 0x4
	// Bit RXIM.
	SPI_IMSC_RXIM = 0x4
	// Position of TXIM field.
	SPI_IMSC_TXIM_Pos = 0x3
	// Bit mask of TXIM field.
	SPI_IMSC_TXIM_Msk = 0x8
	// Bit TXIM.
	SPI_IMSC_TXIM = 0x8
	// Position of RESERVED field.
	SPI_IMSC_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	SPI_IMSC_RESERVED_Msk = 0xfffffff0

	// RIS: Raw Interrupt Status Register
	// Position of RORRIS field.
	SPI_RIS_RORRIS_Pos = 0x0
	// Bit mask of RORRIS field.
	SPI_RIS_RORRIS_Msk = 0x1
	// Bit RORRIS.
	SPI_RIS_RORRIS = 0x1
	// Position of RTRIS field.
	SPI_RIS_RTRIS_Pos = 0x1
	// Bit mask of RTRIS field.
	SPI_RIS_RTRIS_Msk = 0x2
	// Bit RTRIS.
	SPI_RIS_RTRIS = 0x2
	// Position of RXRIS field.
	SPI_RIS_RXRIS_Pos = 0x2
	// Bit mask of RXRIS field.
	SPI_RIS_RXRIS_Msk = 0x4
	// Bit RXRIS.
	SPI_RIS_RXRIS = 0x4
	// Position of TXRIS field.
	SPI_RIS_TXRIS_Pos = 0x3
	// Bit mask of TXRIS field.
	SPI_RIS_TXRIS_Msk = 0x8
	// Bit TXRIS.
	SPI_RIS_TXRIS = 0x8
	// Position of RESERVED field.
	SPI_RIS_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	SPI_RIS_RESERVED_Msk = 0xfffffff0

	// MIS: Masked Interrupt Status Register
	// Position of RORMIS field.
	SPI_MIS_RORMIS_Pos = 0x0
	// Bit mask of RORMIS field.
	SPI_MIS_RORMIS_Msk = 0x1
	// Bit RORMIS.
	SPI_MIS_RORMIS = 0x1
	// Position of RTMIS field.
	SPI_MIS_RTMIS_Pos = 0x1
	// Bit mask of RTMIS field.
	SPI_MIS_RTMIS_Msk = 0x2
	// Bit RTMIS.
	SPI_MIS_RTMIS = 0x2
	// Position of RXMIS field.
	SPI_MIS_RXMIS_Pos = 0x2
	// Bit mask of RXMIS field.
	SPI_MIS_RXMIS_Msk = 0x4
	// Bit RXMIS.
	SPI_MIS_RXMIS = 0x4
	// Position of TXMIS field.
	SPI_MIS_TXMIS_Pos = 0x3
	// Bit mask of TXMIS field.
	SPI_MIS_TXMIS_Msk = 0x8
	// Bit TXMIS.
	SPI_MIS_TXMIS = 0x8
	// Position of RESERVED field.
	SPI_MIS_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	SPI_MIS_RESERVED_Msk = 0xfffffff0

	// ICR: SSPICR Interrupt Clear Register
	// Position of RORIC field.
	SPI_ICR_RORIC_Pos = 0x0
	// Bit mask of RORIC field.
	SPI_ICR_RORIC_Msk = 0x1
	// Bit RORIC.
	SPI_ICR_RORIC = 0x1
	// Position of RTIC field.
	SPI_ICR_RTIC_Pos = 0x1
	// Bit mask of RTIC field.
	SPI_ICR_RTIC_Msk = 0x2
	// Bit RTIC.
	SPI_ICR_RTIC = 0x2
	// Position of RESERVED field.
	SPI_ICR_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	SPI_ICR_RESERVED_Msk = 0xfffffffc
)

// Constants for IOCON: Product name title=UM10398 Chapter title=LPC1100XL series: I/O configuration (IOCONFIG) Modification date=2/22/2012 Major revision=8 Minor revision=not available
const (
	// IOCON_PIO2_6: I/O configuration for pin PIO2_6/ CT32B0_MAT1
	// Position of FUNC field.
	IOCON_IOCON_PIO2_6_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO2_6_FUNC_Msk = 0x7
	// Selects function PIO2_6.
	IOCON_IOCON_PIO2_6_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Selects function CT32B0_MAT1.
	IOCON_IOCON_PIO2_6_FUNC_SELECTS_FUNCTION_CT3 = 0x1
	// Position of MODE field.
	IOCON_IOCON_PIO2_6_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO2_6_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO2_6_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO2_6_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO2_6_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO2_6_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO2_6_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO2_6_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO2_6_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO2_6_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO2_6_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO2_6_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO2_6_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO2_6_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO2_6_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO2_6_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO2_6_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO2_6_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO2_6_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO2_6_RESERVED_Msk = 0xfffff800

	// IOCON_PIO2_0: I/O configuration for pin PIO2_0/DTR/SSEL1
	// Position of FUNC field.
	IOCON_IOCON_PIO2_0_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO2_0_FUNC_Msk = 0x7
	// Selects function PIO2_0.
	IOCON_IOCON_PIO2_0_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Select function DTR.
	IOCON_IOCON_PIO2_0_FUNC_SELECT_FUNCTION_DTR_ = 0x1
	// Select function SSEL1.
	IOCON_IOCON_PIO2_0_FUNC_SELECT_FUNCTION_SSEL = 0x2
	// Position of MODE field.
	IOCON_IOCON_PIO2_0_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO2_0_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO2_0_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO2_0_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO2_0_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO2_0_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO2_0_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO2_0_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO2_0_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO2_0_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO2_0_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO2_0_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO2_0_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO2_0_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO2_0_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO2_0_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO2_0_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO2_0_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO2_0_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO2_0_RESERVED_Msk = 0xfffff800

	// IOCON_RESET_PIO0_0: I/O configuration for pin RESET/PIO0_0
	// Position of FUNC field.
	IOCON_IOCON_RESET_PIO0_0_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_RESET_PIO0_0_FUNC_Msk = 0x7
	// Selects function RESET.
	IOCON_IOCON_RESET_PIO0_0_FUNC_SELECTS_FUNCTION_RES = 0x0
	// Selects function PIO0_0.
	IOCON_IOCON_RESET_PIO0_0_FUNC_SELECTS_FUNCTION_PIO = 0x1
	// Position of MODE field.
	IOCON_IOCON_RESET_PIO0_0_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_RESET_PIO0_0_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_RESET_PIO0_0_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_RESET_PIO0_0_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_RESET_PIO0_0_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_RESET_PIO0_0_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_RESET_PIO0_0_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_RESET_PIO0_0_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_RESET_PIO0_0_HYS = 0x20
	// Disable.
	IOCON_IOCON_RESET_PIO0_0_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_RESET_PIO0_0_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_RESET_PIO0_0_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_RESET_PIO0_0_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_RESET_PIO0_0_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_RESET_PIO0_0_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_RESET_PIO0_0_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_RESET_PIO0_0_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_RESET_PIO0_0_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_RESET_PIO0_0_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_RESET_PIO0_0_RESERVED_Msk = 0xfffff800

	// IOCON_PIO0_1: I/O configuration for pin PIO0_1/CLKOUT/CT32B0_MAT2
	// Position of FUNC field.
	IOCON_IOCON_PIO0_1_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO0_1_FUNC_Msk = 0x7
	// Selects function PIO0_1.
	IOCON_IOCON_PIO0_1_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Selects function CLKOUT.
	IOCON_IOCON_PIO0_1_FUNC_SELECTS_FUNCTION_CLK = 0x1
	// Selects function CT32B0_MAT2.
	IOCON_IOCON_PIO0_1_FUNC_SELECTS_FUNCTION_CT3 = 0x2
	// Position of MODE field.
	IOCON_IOCON_PIO0_1_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO0_1_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO0_1_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO0_1_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO0_1_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO0_1_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO0_1_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO0_1_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO0_1_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO0_1_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO0_1_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO0_1_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO0_1_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO0_1_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO0_1_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO0_1_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO0_1_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO0_1_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO0_1_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO0_1_RESERVED_Msk = 0xfffff800

	// IOCON_PIO1_8: I/O configuration for pin PIO1_8/CT16B1_CAP0
	// Position of FUNC field.
	IOCON_IOCON_PIO1_8_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO1_8_FUNC_Msk = 0x7
	// Selects function PIO1_8.
	IOCON_IOCON_PIO1_8_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Selects function CT16B1_CAP0.
	IOCON_IOCON_PIO1_8_FUNC_SELECTS_FUNCTION_CT1 = 0x1
	// Position of MODE field.
	IOCON_IOCON_PIO1_8_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO1_8_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO1_8_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO1_8_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO1_8_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO1_8_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO1_8_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO1_8_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO1_8_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO1_8_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO1_8_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO1_8_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO1_8_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO1_8_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO1_8_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO1_8_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO1_8_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO1_8_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO1_8_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO1_8_RESERVED_Msk = 0xfffff800

	// IOCON_SSEL1_LOC: SSEL1 pin location select register
	// Position of SSEL1LOC field.
	IOCON_IOCON_SSEL1_LOC_SSEL1LOC_Pos = 0x0
	// Bit mask of SSEL1LOC field.
	IOCON_IOCON_SSEL1_LOC_SSEL1LOC_Msk = 0x3
	// Position of RESERVED field.
	IOCON_IOCON_SSEL1_LOC_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	IOCON_IOCON_SSEL1_LOC_RESERVED_Msk = 0xfffffffc

	// IOCON_PIO0_2: I/O configuration for pin PIO0_2/SSEL0/CT16B0_CAP0
	// Position of FUNC field.
	IOCON_IOCON_PIO0_2_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO0_2_FUNC_Msk = 0x7
	// Selects function PIO0_2.
	IOCON_IOCON_PIO0_2_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Selects function SSEL0.
	IOCON_IOCON_PIO0_2_FUNC_SELECTS_FUNCTION_SSE = 0x1
	// Selects function CT16B0_CAP0.
	IOCON_IOCON_PIO0_2_FUNC_SELECTS_FUNCTION_CT1 = 0x2
	// Position of MODE field.
	IOCON_IOCON_PIO0_2_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO0_2_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO0_2_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO0_2_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO0_2_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO0_2_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO0_2_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO0_2_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO0_2_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO0_2_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO0_2_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO0_2_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO0_2_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO0_2_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO0_2_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO0_2_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO0_2_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO0_2_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO0_2_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO0_2_RESERVED_Msk = 0xfffff800

	// IOCON_PIO2_7: I/O configuration for pin PIO2_7/ CT32B0_MAT2/RXD
	// Position of FUNC field.
	IOCON_IOCON_PIO2_7_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO2_7_FUNC_Msk = 0x7
	// Selects function PIO2_7.
	IOCON_IOCON_PIO2_7_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Selects function CT32B0_MAT2.
	IOCON_IOCON_PIO2_7_FUNC_SELECTS_FUNCTION_CT3 = 0x1
	// Selects function RXD.
	IOCON_IOCON_PIO2_7_FUNC_SELECTS_FUNCTION_RXD = 0x2
	// Position of MODE field.
	IOCON_IOCON_PIO2_7_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO2_7_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO2_7_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO2_7_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO2_7_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO2_7_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO2_7_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO2_7_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO2_7_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO2_7_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO2_7_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO2_7_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO2_7_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO2_7_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO2_7_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO2_7_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO2_7_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO2_7_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO2_7_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO2_7_RESERVED_Msk = 0xfffff800

	// IOCON_PIO2_8: I/O configuration for pin PIO2_8/ CT32B0_MAT3/TXD
	// Position of FUNC field.
	IOCON_IOCON_PIO2_8_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO2_8_FUNC_Msk = 0x7
	// Selects function PIO2_8.
	IOCON_IOCON_PIO2_8_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Selects function CT32B0_MAT3.
	IOCON_IOCON_PIO2_8_FUNC_SELECTS_FUNCTION_CT3 = 0x1
	// Selects function TXD.
	IOCON_IOCON_PIO2_8_FUNC_SELECTS_FUNCTION_TXD = 0x2
	// Position of MODE field.
	IOCON_IOCON_PIO2_8_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO2_8_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO2_8_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO2_8_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO2_8_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO2_8_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO2_8_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO2_8_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO2_8_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO2_8_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO2_8_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO2_8_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO2_8_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO2_8_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO2_8_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO2_8_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO2_8_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO2_8_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO2_8_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO2_8_RESERVED_Msk = 0xfffff800

	// IOCON_PIO2_1: I/O configuration for pin PIO2_1/DSR/SCK1
	// Position of FUNC field.
	IOCON_IOCON_PIO2_1_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO2_1_FUNC_Msk = 0x7
	// Selects function PIO2_1.
	IOCON_IOCON_PIO2_1_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Select function DSR.
	IOCON_IOCON_PIO2_1_FUNC_SELECT_FUNCTION_DSR_ = 0x1
	// Select function SCK1.
	IOCON_IOCON_PIO2_1_FUNC_SELECT_FUNCTION_SCK1 = 0x2
	// Position of MODE field.
	IOCON_IOCON_PIO2_1_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO2_1_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO2_1_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO2_1_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO2_1_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO2_1_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO2_1_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO2_1_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO2_1_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO2_1_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO2_1_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO2_1_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO2_1_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO2_1_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO2_1_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO2_1_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO2_1_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO2_1_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO2_1_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO2_1_RESERVED_Msk = 0xfffff800

	// IOCON_PIO0_3: I/O configuration for pin PIO0_3
	// Position of FUNC field.
	IOCON_IOCON_PIO0_3_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO0_3_FUNC_Msk = 0x7
	// Selects function PIO0_3.
	IOCON_IOCON_PIO0_3_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Position of MODE field.
	IOCON_IOCON_PIO0_3_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO0_3_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO0_3_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO0_3_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO0_3_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO0_3_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO0_3_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO0_3_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO0_3_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO0_3_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO0_3_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO0_3_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO0_3_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO0_3_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO0_3_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO0_3_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO0_3_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO0_3_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO0_3_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO0_3_RESERVED_Msk = 0xfffff800

	// IOCON_PIO0_4: I/O configuration for pin PIO0_4/SCL
	// Position of FUNC field.
	IOCON_IOCON_PIO0_4_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO0_4_FUNC_Msk = 0x7
	// Selects function PIO0_4 (open-drain pin).
	IOCON_IOCON_PIO0_4_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Selects I2C function SCL (open-drain pin).
	IOCON_IOCON_PIO0_4_FUNC_SELECTS_I2C_FUNCTION = 0x1
	// Position of I2CMODE field.
	IOCON_IOCON_PIO0_4_I2CMODE_Pos = 0x8
	// Bit mask of I2CMODE field.
	IOCON_IOCON_PIO0_4_I2CMODE_Msk = 0x300
	// Standard mode/ Fast-mode I2C.
	IOCON_IOCON_PIO0_4_I2CMODE_STANDARD_MODE_FAST = 0x0
	// Standard I/O functionality
	IOCON_IOCON_PIO0_4_I2CMODE_STANDARD_IO_FUNCTION = 0x1
	// Fast-mode Plus I2C
	IOCON_IOCON_PIO0_4_I2CMODE_FAST_MODE_PLUS_I2C = 0x2
	// Reserved.
	IOCON_IOCON_PIO0_4_I2CMODE_RESERVED_ = 0x3
	// Position of RESERVED field.
	IOCON_IOCON_PIO0_4_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO0_4_RESERVED_Msk = 0xfffffc00

	// IOCON_PIO0_5: I/O configuration for pin PIO0_5/SDA
	// Position of FUNC field.
	IOCON_IOCON_PIO0_5_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO0_5_FUNC_Msk = 0x7
	// Selects function PIO0_5 (open-drain pin).
	IOCON_IOCON_PIO0_5_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Selects I2C function SDA (open-drain pin).
	IOCON_IOCON_PIO0_5_FUNC_SELECTS_I2C_FUNCTION = 0x1
	// Position of I2CMODE field.
	IOCON_IOCON_PIO0_5_I2CMODE_Pos = 0x8
	// Bit mask of I2CMODE field.
	IOCON_IOCON_PIO0_5_I2CMODE_Msk = 0x300
	// Standard mode/ Fast-mode I2C.
	IOCON_IOCON_PIO0_5_I2CMODE_STANDARD_MODE_FAST = 0x0
	// Standard I/O functionality
	IOCON_IOCON_PIO0_5_I2CMODE_STANDARD_IO_FUNCTION = 0x1
	// Fast-mode Plus I2C
	IOCON_IOCON_PIO0_5_I2CMODE_FAST_MODE_PLUS_I2C = 0x2
	// Reserved.
	IOCON_IOCON_PIO0_5_I2CMODE_RESERVED_ = 0x3
	// Position of RESERVED field.
	IOCON_IOCON_PIO0_5_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO0_5_RESERVED_Msk = 0xfffffc00

	// IOCON_PIO1_9: I/O configuration for pin PIO1_9/CT16B1_MAT0/ MOSI1
	// Position of FUNC field.
	IOCON_IOCON_PIO1_9_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO1_9_FUNC_Msk = 0x7
	// Selects function PIO1_9.
	IOCON_IOCON_PIO1_9_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Selects function CT16B1_MAT0.
	IOCON_IOCON_PIO1_9_FUNC_SELECTS_FUNCTION_CT1 = 0x1
	// Selects function MOSI1.
	IOCON_IOCON_PIO1_9_FUNC_SELECTS_FUNCTION_MOS = 0x2
	// Position of MODE field.
	IOCON_IOCON_PIO1_9_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO1_9_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO1_9_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO1_9_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO1_9_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO1_9_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO1_9_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO1_9_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO1_9_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO1_9_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO1_9_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO1_9_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO1_9_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO1_9_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO1_9_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO1_9_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO1_9_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO1_9_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO1_9_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO1_9_RESERVED_Msk = 0xfffff800

	// IOCON_PIO3_4: I/O configuration for pin PIO3_4/ CT16B0_CAP1/RXD
	// Position of FUNC field.
	IOCON_IOCON_PIO3_4_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO3_4_FUNC_Msk = 0x7
	// Selects function PIO3_4.
	IOCON_IOCON_PIO3_4_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Selects function CT16B0_CAP1.
	IOCON_IOCON_PIO3_4_FUNC_SELECTS_FUNCTION_CT1 = 0x1
	// Selects function RXD.
	IOCON_IOCON_PIO3_4_FUNC_SELECTS_FUNCTION_RXD = 0x2
	// Position of MODE field.
	IOCON_IOCON_PIO3_4_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO3_4_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO3_4_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO3_4_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO3_4_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO3_4_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO3_4_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO3_4_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO3_4_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO3_4_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO3_4_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO3_4_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO3_4_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO3_4_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO3_4_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO3_4_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO3_4_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO3_4_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO3_4_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO3_4_RESERVED_Msk = 0xfffff800

	// IOCON_PIO2_4: I/O configuration for pin PIO2_4/ CT16B1_MAT1/ SSEL1
	// Position of FUNC field.
	IOCON_IOCON_PIO2_4_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO2_4_FUNC_Msk = 0x7
	// Selects function PIO2_4.
	IOCON_IOCON_PIO2_4_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Selects function CT16B1_MAT1.
	IOCON_IOCON_PIO2_4_FUNC_SELECTS_FUNCTION_CT1 = 0x1
	// Selects function SSEL1.
	IOCON_IOCON_PIO2_4_FUNC_SELECTS_FUNCTION_SSE = 0x2
	// Position of MODE field.
	IOCON_IOCON_PIO2_4_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO2_4_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO2_4_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO2_4_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO2_4_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO2_4_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO2_4_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO2_4_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO2_4_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO2_4_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO2_4_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO2_4_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO2_4_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO2_4_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO2_4_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO2_4_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO2_4_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO2_4_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO2_4_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO2_4_RESERVED_Msk = 0xfffff800

	// IOCON_PIO2_5: I/O configuration for pin PIO2_5/ CT32B0_MAT0
	// Position of FUNC field.
	IOCON_IOCON_PIO2_5_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO2_5_FUNC_Msk = 0x7
	// Selects function PIO2_5.
	IOCON_IOCON_PIO2_5_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Selects function CT32B0_MAT0.
	IOCON_IOCON_PIO2_5_FUNC_SELECTS_FUNCTION_CT3 = 0x1
	// Position of MODE field.
	IOCON_IOCON_PIO2_5_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO2_5_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO2_5_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO2_5_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO2_5_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO2_5_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO2_5_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO2_5_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO2_5_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO2_5_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO2_5_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO2_5_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO2_5_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO2_5_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO2_5_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO2_5_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO2_5_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO2_5_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO2_5_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO2_5_RESERVED_Msk = 0xfffff800

	// IOCON_PIO3_5: I/O configuration for pin PIO3_5/ CT16B1_CAP1/TXD
	// Position of FUNC field.
	IOCON_IOCON_PIO3_5_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO3_5_FUNC_Msk = 0x7
	// Selects function PIO3_5.
	IOCON_IOCON_PIO3_5_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Selects function CT16B1_CAP1.
	IOCON_IOCON_PIO3_5_FUNC_SELECTS_FUNCTION_CT1 = 0x1
	// Selects function TXD.
	IOCON_IOCON_PIO3_5_FUNC_SELECTS_FUNCTION_TXD = 0x2
	// Position of MODE field.
	IOCON_IOCON_PIO3_5_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO3_5_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO3_5_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO3_5_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO3_5_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO3_5_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO3_5_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO3_5_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO3_5_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO3_5_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO3_5_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO3_5_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO3_5_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO3_5_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO3_5_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO3_5_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO3_5_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO3_5_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO3_5_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO3_5_RESERVED_Msk = 0xfffff800

	// IOCON_PIO0_6: I/O configuration for pin PIO0_6/SCK0
	// Position of FUNC field.
	IOCON_IOCON_PIO0_6_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO0_6_FUNC_Msk = 0x7
	// Selects function PIO0_6.
	IOCON_IOCON_PIO0_6_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Reserved.
	IOCON_IOCON_PIO0_6_FUNC_RESERVED_ = 0x1
	// Selects function SCK0 (only if pin PIO0_6/SCK0 selected in Table 147).
	IOCON_IOCON_PIO0_6_FUNC_SELECTS_FUNCTION_SCK = 0x2
	// Position of MODE field.
	IOCON_IOCON_PIO0_6_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO0_6_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO0_6_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO0_6_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO0_6_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO0_6_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO0_6_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO0_6_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO0_6_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO0_6_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO0_6_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO0_6_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO0_6_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO0_6_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO0_6_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO0_6_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO0_6_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO0_6_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO0_6_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO0_6_RESERVED_Msk = 0xfffff800

	// IOCON_PIO0_7: I/O configuration for pin PIO0_7/CTS
	// Position of FUNC field.
	IOCON_IOCON_PIO0_7_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO0_7_FUNC_Msk = 0x7
	// Selects function PIO0_7.
	IOCON_IOCON_PIO0_7_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Select function CTS.
	IOCON_IOCON_PIO0_7_FUNC_SELECT_FUNCTION_CTS_ = 0x1
	// Position of MODE field.
	IOCON_IOCON_PIO0_7_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO0_7_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO0_7_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO0_7_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO0_7_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO0_7_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO0_7_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO0_7_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO0_7_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO0_7_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO0_7_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO0_7_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO0_7_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO0_7_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO0_7_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO0_7_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO0_7_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO0_7_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO0_7_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO0_7_RESERVED_Msk = 0xfffff800

	// IOCON_PIO2_9: I/O configuration for pin PIO2_9/ CT32B0_CAP0
	// Position of FUNC field.
	IOCON_IOCON_PIO2_9_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO2_9_FUNC_Msk = 0x7
	// Selects function PIO2_9.
	IOCON_IOCON_PIO2_9_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Selects function CT32B0_CAP0.
	IOCON_IOCON_PIO2_9_FUNC_SELECTS_FUNCTION_CT3 = 0x1
	// Position of MODE field.
	IOCON_IOCON_PIO2_9_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO2_9_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO2_9_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO2_9_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO2_9_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO2_9_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO2_9_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO2_9_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO2_9_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO2_9_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO2_9_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO2_9_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO2_9_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO2_9_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO2_9_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO2_9_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO2_9_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO2_9_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO2_9_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO2_9_RESERVED_Msk = 0xfffff800

	// IOCON_PIO2_10: I/O configuration for pin PIO2_10
	// Position of FUNC field.
	IOCON_IOCON_PIO2_10_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO2_10_FUNC_Msk = 0x7
	// Selects function PIO2_10.
	IOCON_IOCON_PIO2_10_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Position of MODE field.
	IOCON_IOCON_PIO2_10_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO2_10_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO2_10_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO2_10_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO2_10_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO2_10_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO2_10_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO2_10_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO2_10_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO2_10_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO2_10_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO2_10_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO2_10_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO2_10_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO2_10_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO2_10_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO2_10_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO2_10_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO2_10_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO2_10_RESERVED_Msk = 0xfffff800

	// IOCON_PIO2_2: I/O configuration for pin PIO2_2/DCD/MISO1
	// Position of FUNC field.
	IOCON_IOCON_PIO2_2_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO2_2_FUNC_Msk = 0x7
	// Selects function PIO2_2.
	IOCON_IOCON_PIO2_2_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Select function DCD.
	IOCON_IOCON_PIO2_2_FUNC_SELECT_FUNCTION_DCD_ = 0x1
	// Select function MISO1.
	IOCON_IOCON_PIO2_2_FUNC_SELECT_FUNCTION_MISO = 0x2
	// Position of MODE field.
	IOCON_IOCON_PIO2_2_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO2_2_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO2_2_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO2_2_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO2_2_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO2_2_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO2_2_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO2_2_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO2_2_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO2_2_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO2_2_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO2_2_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO2_2_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO2_2_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO2_2_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO2_2_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO2_2_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO2_2_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO2_2_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO2_2_RESERVED_Msk = 0xfffff800

	// IOCON_PIO0_8: I/O configuration for pin PIO0_8/MISO0/CT16B0_MAT0
	// Position of FUNC field.
	IOCON_IOCON_PIO0_8_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO0_8_FUNC_Msk = 0x7
	// Selects function PIO0_8.
	IOCON_IOCON_PIO0_8_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Selects function MISO0.
	IOCON_IOCON_PIO0_8_FUNC_SELECTS_FUNCTION_MIS = 0x1
	// Selects function CT16B0_MAT0.
	IOCON_IOCON_PIO0_8_FUNC_SELECTS_FUNCTION_CT1 = 0x2
	// Position of MODE field.
	IOCON_IOCON_PIO0_8_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO0_8_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO0_8_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO0_8_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO0_8_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO0_8_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO0_8_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO0_8_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO0_8_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO0_8_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO0_8_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO0_8_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO0_8_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO0_8_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO0_8_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO0_8_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO0_8_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO0_8_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO0_8_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO0_8_RESERVED_Msk = 0xfffff800

	// IOCON_PIO0_9: I/O configuration for pin PIO0_9/MOSI0/CT16B0_MAT1
	// Position of FUNC field.
	IOCON_IOCON_PIO0_9_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO0_9_FUNC_Msk = 0x7
	// Selects function PIO0_9.
	IOCON_IOCON_PIO0_9_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Selects function MOSI0.
	IOCON_IOCON_PIO0_9_FUNC_SELECTS_FUNCTION_MOS = 0x1
	// Selects function CT16B0_MAT1.
	IOCON_IOCON_PIO0_9_FUNC_SELECTS_FUNCTION_CT1 = 0x2
	// Position of MODE field.
	IOCON_IOCON_PIO0_9_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO0_9_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO0_9_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO0_9_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO0_9_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO0_9_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO0_9_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO0_9_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO0_9_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO0_9_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO0_9_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO0_9_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO0_9_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO0_9_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO0_9_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO0_9_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO0_9_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO0_9_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO0_9_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO0_9_RESERVED_Msk = 0xfffff800

	// IOCON_SWCLK_PIO0_10: I/O configuration for pin SWCLK/PIO0_10/ SCK0/CT16B0_MAT2
	// Position of FUNC field.
	IOCON_IOCON_SWCLK_PIO0_10_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_SWCLK_PIO0_10_FUNC_Msk = 0x7
	// Selects function SWCLK.
	IOCON_IOCON_SWCLK_PIO0_10_FUNC_SELECTS_FUNCTION_SWC = 0x0
	// Selects function PIO0_10.
	IOCON_IOCON_SWCLK_PIO0_10_FUNC_SELECTS_FUNCTION_PIO = 0x1
	// Selects function SCK0 (only if pin SWCLK/PIO0_10/SCK0/CT16B0_MAT2 selected in Table 147).
	IOCON_IOCON_SWCLK_PIO0_10_FUNC_SELECTS_FUNCTION_SCK = 0x2
	// Selects function CT16B0_MAT2.
	IOCON_IOCON_SWCLK_PIO0_10_FUNC_SELECTS_FUNCTION_CT1 = 0x3
	// Position of MODE field.
	IOCON_IOCON_SWCLK_PIO0_10_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_SWCLK_PIO0_10_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_SWCLK_PIO0_10_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_SWCLK_PIO0_10_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_SWCLK_PIO0_10_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_SWCLK_PIO0_10_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_SWCLK_PIO0_10_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_SWCLK_PIO0_10_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_SWCLK_PIO0_10_HYS = 0x20
	// Disable.
	IOCON_IOCON_SWCLK_PIO0_10_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_SWCLK_PIO0_10_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_SWCLK_PIO0_10_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_SWCLK_PIO0_10_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_SWCLK_PIO0_10_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_SWCLK_PIO0_10_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_SWCLK_PIO0_10_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_SWCLK_PIO0_10_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_SWCLK_PIO0_10_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_SWCLK_PIO0_10_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_SWCLK_PIO0_10_RESERVED_Msk = 0xfffff800

	// IOCON_PIO1_10: I/O configuration for pin PIO1_10/AD6/CT16B1_MAT1/ MISO1
	// Position of FUNC field.
	IOCON_IOCON_PIO1_10_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO1_10_FUNC_Msk = 0x7
	// Selects function PIO1_10.
	IOCON_IOCON_PIO1_10_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Selects function AD6.
	IOCON_IOCON_PIO1_10_FUNC_SELECTS_FUNCTION_AD6 = 0x1
	// Selects function CT16B1_MAT1.
	IOCON_IOCON_PIO1_10_FUNC_SELECTS_FUNCTION_CT1 = 0x2
	// Selects function MISO1.
	IOCON_IOCON_PIO1_10_FUNC_SELECTS_FUNCTION_MIS = 0x3
	// Position of MODE field.
	IOCON_IOCON_PIO1_10_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO1_10_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO1_10_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO1_10_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO1_10_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO1_10_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO1_10_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO1_10_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO1_10_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO1_10_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO1_10_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO1_10_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO1_10_RESERVED_Msk = 0x40
	// Bit RESERVED.
	IOCON_IOCON_PIO1_10_RESERVED = 0x40
	// Position of ADMODE field.
	IOCON_IOCON_PIO1_10_ADMODE_Pos = 0x7
	// Bit mask of ADMODE field.
	IOCON_IOCON_PIO1_10_ADMODE_Msk = 0x80
	// Bit ADMODE.
	IOCON_IOCON_PIO1_10_ADMODE = 0x80
	// Analog input mode
	IOCON_IOCON_PIO1_10_ADMODE_ANALOG_INPUT_MODE = 0x0
	// Digital functional mode
	IOCON_IOCON_PIO1_10_ADMODE_DIGITAL_FUNCTIONAL_M = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO1_10_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO1_10_RESERVED_Msk = 0x300
	// Position of OD field.
	IOCON_IOCON_PIO1_10_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO1_10_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO1_10_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO1_10_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO1_10_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO1_10_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO1_10_RESERVED_Msk = 0xfffff800

	// IOCON_PIO2_11: I/O configuration for pin PIO2_11/SCK0/ CT32B0_CAP1
	// Position of FUNC field.
	IOCON_IOCON_PIO2_11_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO2_11_FUNC_Msk = 0x7
	// Selects function PIO2_11.
	IOCON_IOCON_PIO2_11_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Select function SCK0 (only if pin PIO2_11/SCK0 selected in Table 147).
	IOCON_IOCON_PIO2_11_FUNC_SELECT_FUNCTION_SCK0 = 0x1
	// Select function CT32B0_CAP1.
	IOCON_IOCON_PIO2_11_FUNC_SELECT_FUNCTION_CT32 = 0x2
	// Position of MODE field.
	IOCON_IOCON_PIO2_11_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO2_11_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO2_11_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO2_11_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO2_11_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO2_11_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO2_11_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO2_11_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO2_11_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO2_11_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO2_11_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO2_11_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO2_11_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO2_11_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO2_11_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO2_11_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO2_11_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO2_11_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO2_11_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO2_11_RESERVED_Msk = 0xfffff800

	// IOCON_R_PIO0_11: I/O configuration for pin R/PIO0_11/AD0/CT32B0_MAT3
	// Position of FUNC field.
	IOCON_IOCON_R_PIO0_11_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_R_PIO0_11_FUNC_Msk = 0x7
	// Selects function R. This function is reserved. Select one of the alternate functions below.
	IOCON_IOCON_R_PIO0_11_FUNC_SELECTS_FUNCTION_R_ = 0x0
	// Selects function PIO0_11.
	IOCON_IOCON_R_PIO0_11_FUNC_SELECTS_FUNCTION_PIO = 0x1
	// Selects function AD0.
	IOCON_IOCON_R_PIO0_11_FUNC_SELECTS_FUNCTION_AD0 = 0x2
	// Selects function CT32B0_MAT3.
	IOCON_IOCON_R_PIO0_11_FUNC_SELECTS_FUNCTION_CT3 = 0x3
	// Position of MODE field.
	IOCON_IOCON_R_PIO0_11_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_R_PIO0_11_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_R_PIO0_11_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_R_PIO0_11_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_R_PIO0_11_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_R_PIO0_11_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_R_PIO0_11_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_R_PIO0_11_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_R_PIO0_11_HYS = 0x20
	// Disable.
	IOCON_IOCON_R_PIO0_11_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_R_PIO0_11_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_R_PIO0_11_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_R_PIO0_11_RESERVED_Msk = 0x40
	// Bit RESERVED.
	IOCON_IOCON_R_PIO0_11_RESERVED = 0x40
	// Position of ADMODE field.
	IOCON_IOCON_R_PIO0_11_ADMODE_Pos = 0x7
	// Bit mask of ADMODE field.
	IOCON_IOCON_R_PIO0_11_ADMODE_Msk = 0x80
	// Bit ADMODE.
	IOCON_IOCON_R_PIO0_11_ADMODE = 0x80
	// Analog input mode
	IOCON_IOCON_R_PIO0_11_ADMODE_ANALOG_INPUT_MODE = 0x0
	// Digital functional mode
	IOCON_IOCON_R_PIO0_11_ADMODE_DIGITAL_FUNCTIONAL_M = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_R_PIO0_11_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	IOCON_IOCON_R_PIO0_11_RESERVED_Msk = 0x300
	// Position of OD field.
	IOCON_IOCON_R_PIO0_11_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_R_PIO0_11_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_R_PIO0_11_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_R_PIO0_11_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_R_PIO0_11_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_R_PIO0_11_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_R_PIO0_11_RESERVED_Msk = 0xfffff800

	// IOCON_R_PIO1_0: I/O configuration for pin R/PIO1_0/AD1/CT32B1_CAP0
	// Position of FUNC field.
	IOCON_IOCON_R_PIO1_0_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_R_PIO1_0_FUNC_Msk = 0x7
	// Selects function R. This function is reserved. Select one of the alternate functions below.
	IOCON_IOCON_R_PIO1_0_FUNC_SELECTS_FUNCTION_R_ = 0x0
	// Selects function PIO1_0.
	IOCON_IOCON_R_PIO1_0_FUNC_SELECTS_FUNCTION_PIO = 0x1
	// Selects function AD1.
	IOCON_IOCON_R_PIO1_0_FUNC_SELECTS_FUNCTION_AD1 = 0x2
	// Selects function CT32B1_CAP0.
	IOCON_IOCON_R_PIO1_0_FUNC_SELECTS_FUNCTION_CT3 = 0x3
	// Position of MODE field.
	IOCON_IOCON_R_PIO1_0_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_R_PIO1_0_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_R_PIO1_0_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_R_PIO1_0_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_R_PIO1_0_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_R_PIO1_0_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_R_PIO1_0_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_R_PIO1_0_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_R_PIO1_0_HYS = 0x20
	// Disable.
	IOCON_IOCON_R_PIO1_0_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_R_PIO1_0_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_R_PIO1_0_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_R_PIO1_0_RESERVED_Msk = 0x40
	// Bit RESERVED.
	IOCON_IOCON_R_PIO1_0_RESERVED = 0x40
	// Position of ADMODE field.
	IOCON_IOCON_R_PIO1_0_ADMODE_Pos = 0x7
	// Bit mask of ADMODE field.
	IOCON_IOCON_R_PIO1_0_ADMODE_Msk = 0x80
	// Bit ADMODE.
	IOCON_IOCON_R_PIO1_0_ADMODE = 0x80
	// Analog input mode
	IOCON_IOCON_R_PIO1_0_ADMODE_ANALOG_INPUT_MODE = 0x0
	// Digital functional mode
	IOCON_IOCON_R_PIO1_0_ADMODE_DIGITAL_FUNCTIONAL_M = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_R_PIO1_0_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	IOCON_IOCON_R_PIO1_0_RESERVED_Msk = 0x300
	// Position of OD field.
	IOCON_IOCON_R_PIO1_0_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_R_PIO1_0_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_R_PIO1_0_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_R_PIO1_0_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_R_PIO1_0_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_R_PIO1_0_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_R_PIO1_0_RESERVED_Msk = 0xfffff800

	// IOCON_R_PIO1_1: I/O configuration for pin R/PIO1_1/AD2/CT32B1_MAT0
	// Position of FUNC field.
	IOCON_IOCON_R_PIO1_1_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_R_PIO1_1_FUNC_Msk = 0x7
	// Selects function R. This function is reserved. Select one of the alternate functions below.
	IOCON_IOCON_R_PIO1_1_FUNC_SELECTS_FUNCTION_R_ = 0x0
	// Selects function PIO1_1.
	IOCON_IOCON_R_PIO1_1_FUNC_SELECTS_FUNCTION_PIO = 0x1
	// Selects function AD2.
	IOCON_IOCON_R_PIO1_1_FUNC_SELECTS_FUNCTION_AD2 = 0x2
	// Selects function CT32B1_MAT0.
	IOCON_IOCON_R_PIO1_1_FUNC_SELECTS_FUNCTION_CT3 = 0x3
	// Position of MODE field.
	IOCON_IOCON_R_PIO1_1_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_R_PIO1_1_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_R_PIO1_1_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_R_PIO1_1_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_R_PIO1_1_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_R_PIO1_1_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_R_PIO1_1_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_R_PIO1_1_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_R_PIO1_1_HYS = 0x20
	// Disable.
	IOCON_IOCON_R_PIO1_1_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_R_PIO1_1_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_R_PIO1_1_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_R_PIO1_1_RESERVED_Msk = 0x40
	// Bit RESERVED.
	IOCON_IOCON_R_PIO1_1_RESERVED = 0x40
	// Position of ADMODE field.
	IOCON_IOCON_R_PIO1_1_ADMODE_Pos = 0x7
	// Bit mask of ADMODE field.
	IOCON_IOCON_R_PIO1_1_ADMODE_Msk = 0x80
	// Bit ADMODE.
	IOCON_IOCON_R_PIO1_1_ADMODE = 0x80
	// Analog input mode
	IOCON_IOCON_R_PIO1_1_ADMODE_ANALOG_INPUT_MODE = 0x0
	// Digital functional mode
	IOCON_IOCON_R_PIO1_1_ADMODE_DIGITAL_FUNCTIONAL_M = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_R_PIO1_1_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	IOCON_IOCON_R_PIO1_1_RESERVED_Msk = 0x300
	// Position of OD field.
	IOCON_IOCON_R_PIO1_1_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_R_PIO1_1_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_R_PIO1_1_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_R_PIO1_1_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_R_PIO1_1_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_R_PIO1_1_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_R_PIO1_1_RESERVED_Msk = 0xfffff800

	// IOCON_R_PIO1_2: I/O configuration for pin R/PIO1_2/AD3/CT32B1_MAT1
	// Position of FUNC field.
	IOCON_IOCON_R_PIO1_2_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_R_PIO1_2_FUNC_Msk = 0x7
	// Selects function R. This function is reserved. Select one of the alternate functions below.
	IOCON_IOCON_R_PIO1_2_FUNC_SELECTS_FUNCTION_R_ = 0x0
	// Selects function PIO1_2.
	IOCON_IOCON_R_PIO1_2_FUNC_SELECTS_FUNCTION_PIO = 0x1
	// Selects function AD3.
	IOCON_IOCON_R_PIO1_2_FUNC_SELECTS_FUNCTION_AD3 = 0x2
	// Selects function CT32B1_MAT1.
	IOCON_IOCON_R_PIO1_2_FUNC_SELECTS_FUNCTION_CT3 = 0x3
	// Position of MODE field.
	IOCON_IOCON_R_PIO1_2_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_R_PIO1_2_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_R_PIO1_2_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_R_PIO1_2_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_R_PIO1_2_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_R_PIO1_2_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_R_PIO1_2_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_R_PIO1_2_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_R_PIO1_2_HYS = 0x20
	// Disable.
	IOCON_IOCON_R_PIO1_2_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_R_PIO1_2_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_R_PIO1_2_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_R_PIO1_2_RESERVED_Msk = 0x40
	// Bit RESERVED.
	IOCON_IOCON_R_PIO1_2_RESERVED = 0x40
	// Position of ADMODE field.
	IOCON_IOCON_R_PIO1_2_ADMODE_Pos = 0x7
	// Bit mask of ADMODE field.
	IOCON_IOCON_R_PIO1_2_ADMODE_Msk = 0x80
	// Bit ADMODE.
	IOCON_IOCON_R_PIO1_2_ADMODE = 0x80
	// Analog input mode
	IOCON_IOCON_R_PIO1_2_ADMODE_ANALOG_INPUT_MODE = 0x0
	// Digital functional mode
	IOCON_IOCON_R_PIO1_2_ADMODE_DIGITAL_FUNCTIONAL_M = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_R_PIO1_2_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	IOCON_IOCON_R_PIO1_2_RESERVED_Msk = 0x300
	// Position of OD field.
	IOCON_IOCON_R_PIO1_2_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_R_PIO1_2_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_R_PIO1_2_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_R_PIO1_2_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_R_PIO1_2_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_R_PIO1_2_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_R_PIO1_2_RESERVED_Msk = 0xfffff800

	// IOCON_PIO3_0: I/O configuration for pin PIO3_0/DTR/CT16B0_MAT0/TXD
	// Position of FUNC field.
	IOCON_IOCON_PIO3_0_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO3_0_FUNC_Msk = 0x7
	// Selects function PIO3_0.
	IOCON_IOCON_PIO3_0_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Selects function DTR.
	IOCON_IOCON_PIO3_0_FUNC_SELECTS_FUNCTION_DTR = 0x1
	// Selects function CT16B0_MAT0.
	IOCON_IOCON_PIO3_0_FUNC_SELECTS_FUNCTION_CT1 = 0x2
	// Selects function TXD.
	IOCON_IOCON_PIO3_0_FUNC_SELECTS_FUNCTION_TXD = 0x3
	// Position of MODE field.
	IOCON_IOCON_PIO3_0_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO3_0_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO3_0_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO3_0_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO3_0_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO3_0_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO3_0_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO3_0_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO3_0_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO3_0_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO3_0_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO3_0_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO3_0_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO3_0_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO3_0_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO3_0_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO3_0_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO3_0_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO3_0_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO3_0_RESERVED_Msk = 0xfffff800

	// IOCON_PIO3_1: I/O configuration for pin PIO3_1/DSR/CT16B0_MAT1/RXD
	// Position of FUNC field.
	IOCON_IOCON_PIO3_1_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO3_1_FUNC_Msk = 0x7
	// Selects function PIO3_1.
	IOCON_IOCON_PIO3_1_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Selects function DSR.
	IOCON_IOCON_PIO3_1_FUNC_SELECTS_FUNCTION_DSR = 0x1
	// Selects function CT16B0_MAT1.
	IOCON_IOCON_PIO3_1_FUNC_SELECTS_FUNCTION_CT1 = 0x2
	// Selects function RXD.
	IOCON_IOCON_PIO3_1_FUNC_SELECTS_FUNCTION_RXD = 0x3
	// Position of MODE field.
	IOCON_IOCON_PIO3_1_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO3_1_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO3_1_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO3_1_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO3_1_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO3_1_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO3_1_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO3_1_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO3_1_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO3_1_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO3_1_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO3_1_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO3_1_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO3_1_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO3_1_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO3_1_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO3_1_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO3_1_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO3_1_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO3_1_RESERVED_Msk = 0xfffff800

	// IOCON_PIO2_3: I/O configuration for pin PIO2_3/RI/MOSI1
	// Position of FUNC field.
	IOCON_IOCON_PIO2_3_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO2_3_FUNC_Msk = 0x7
	// Selects function PIO2_3.
	IOCON_IOCON_PIO2_3_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Selects function RI.
	IOCON_IOCON_PIO2_3_FUNC_SELECTS_FUNCTION_RI_ = 0x1
	// Selects function MOSI1.
	IOCON_IOCON_PIO2_3_FUNC_SELECTS_FUNCTION_MOS = 0x2
	// Position of MODE field.
	IOCON_IOCON_PIO2_3_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO2_3_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO2_3_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO2_3_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO2_3_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO2_3_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO2_3_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO2_3_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO2_3_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO2_3_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO2_3_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO2_3_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO2_3_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO2_3_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO2_3_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO2_3_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO2_3_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO2_3_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO2_3_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO2_3_RESERVED_Msk = 0xfffff800

	// IOCON_SWDIO_PIO1_3: I/O configuration for pin SWDIO/PIO1_3/AD4/CT32B1_MAT2
	// Position of FUNC field.
	IOCON_IOCON_SWDIO_PIO1_3_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_SWDIO_PIO1_3_FUNC_Msk = 0x7
	// Selects function SWDIO.
	IOCON_IOCON_SWDIO_PIO1_3_FUNC_SELECTS_FUNCTION_SWD = 0x0
	// Selects function PIO1_3.
	IOCON_IOCON_SWDIO_PIO1_3_FUNC_SELECTS_FUNCTION_PIO = 0x1
	// Selects function AD4.
	IOCON_IOCON_SWDIO_PIO1_3_FUNC_SELECTS_FUNCTION_AD4 = 0x2
	// Selects function CT32B1_MAT2.
	IOCON_IOCON_SWDIO_PIO1_3_FUNC_SELECTS_FUNCTION_CT3 = 0x3
	// Position of MODE field.
	IOCON_IOCON_SWDIO_PIO1_3_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_SWDIO_PIO1_3_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_SWDIO_PIO1_3_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_SWDIO_PIO1_3_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_SWDIO_PIO1_3_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_SWDIO_PIO1_3_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_SWDIO_PIO1_3_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_SWDIO_PIO1_3_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_SWDIO_PIO1_3_HYS = 0x20
	// Disable.
	IOCON_IOCON_SWDIO_PIO1_3_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_SWDIO_PIO1_3_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_SWDIO_PIO1_3_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_SWDIO_PIO1_3_RESERVED_Msk = 0x40
	// Bit RESERVED.
	IOCON_IOCON_SWDIO_PIO1_3_RESERVED = 0x40
	// Position of ADMODE field.
	IOCON_IOCON_SWDIO_PIO1_3_ADMODE_Pos = 0x7
	// Bit mask of ADMODE field.
	IOCON_IOCON_SWDIO_PIO1_3_ADMODE_Msk = 0x80
	// Bit ADMODE.
	IOCON_IOCON_SWDIO_PIO1_3_ADMODE = 0x80
	// Analog input mode
	IOCON_IOCON_SWDIO_PIO1_3_ADMODE_ANALOG_INPUT_MODE = 0x0
	// Digital functional mode
	IOCON_IOCON_SWDIO_PIO1_3_ADMODE_DIGITAL_FUNCTIONAL_M = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_SWDIO_PIO1_3_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	IOCON_IOCON_SWDIO_PIO1_3_RESERVED_Msk = 0x300
	// Position of OD field.
	IOCON_IOCON_SWDIO_PIO1_3_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_SWDIO_PIO1_3_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_SWDIO_PIO1_3_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_SWDIO_PIO1_3_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_SWDIO_PIO1_3_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_SWDIO_PIO1_3_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_SWDIO_PIO1_3_RESERVED_Msk = 0xfffff800

	// IOCON_PIO1_4: I/O configuration for pin PIO1_4/AD5/CT32B1_MAT3
	// Position of FUNC field.
	IOCON_IOCON_PIO1_4_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO1_4_FUNC_Msk = 0x7
	// Selects function PIO1_4.
	IOCON_IOCON_PIO1_4_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Selects function AD5.
	IOCON_IOCON_PIO1_4_FUNC_SELECTS_FUNCTION_AD5 = 0x1
	// Selects function CT32B1_MAT3.
	IOCON_IOCON_PIO1_4_FUNC_SELECTS_FUNCTION_CT3 = 0x2
	// Position of MODE field.
	IOCON_IOCON_PIO1_4_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO1_4_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO1_4_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO1_4_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO1_4_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO1_4_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO1_4_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO1_4_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO1_4_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO1_4_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO1_4_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO1_4_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO1_4_RESERVED_Msk = 0x40
	// Bit RESERVED.
	IOCON_IOCON_PIO1_4_RESERVED = 0x40
	// Position of ADMODE field.
	IOCON_IOCON_PIO1_4_ADMODE_Pos = 0x7
	// Bit mask of ADMODE field.
	IOCON_IOCON_PIO1_4_ADMODE_Msk = 0x80
	// Bit ADMODE.
	IOCON_IOCON_PIO1_4_ADMODE = 0x80
	// Analog input mode
	IOCON_IOCON_PIO1_4_ADMODE_ANALOG_INPUT_MODE = 0x0
	// Digital functional mode
	IOCON_IOCON_PIO1_4_ADMODE_DIGITAL_FUNCTIONAL_M = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO1_4_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO1_4_RESERVED_Msk = 0x300
	// Position of OD field.
	IOCON_IOCON_PIO1_4_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO1_4_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO1_4_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO1_4_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO1_4_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO1_4_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO1_4_RESERVED_Msk = 0xfffff800

	// IOCON_PIO1_11: I/O configuration for pin PIO1_11/AD7/CT32B1_CAP1
	// Position of FUNC field.
	IOCON_IOCON_PIO1_11_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO1_11_FUNC_Msk = 0x7
	// Selects function PIO1_11.
	IOCON_IOCON_PIO1_11_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Selects function AD7.
	IOCON_IOCON_PIO1_11_FUNC_SELECTS_FUNCTION_AD7 = 0x1
	// Selects function CT32B1_CAP1.
	IOCON_IOCON_PIO1_11_FUNC_SELECTS_FUNCTION_CT3 = 0x2
	// Position of MODE field.
	IOCON_IOCON_PIO1_11_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO1_11_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO1_11_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO1_11_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO1_11_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO1_11_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO1_11_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO1_11_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO1_11_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO1_11_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO1_11_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO1_11_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO1_11_RESERVED_Msk = 0x40
	// Bit RESERVED.
	IOCON_IOCON_PIO1_11_RESERVED = 0x40
	// Position of ADMODE field.
	IOCON_IOCON_PIO1_11_ADMODE_Pos = 0x7
	// Bit mask of ADMODE field.
	IOCON_IOCON_PIO1_11_ADMODE_Msk = 0x80
	// Bit ADMODE.
	IOCON_IOCON_PIO1_11_ADMODE = 0x80
	// Analog input mode
	IOCON_IOCON_PIO1_11_ADMODE_ANALOG_INPUT_MODE = 0x0
	// Digital functional mode
	IOCON_IOCON_PIO1_11_ADMODE_DIGITAL_FUNCTIONAL_M = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO1_11_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO1_11_RESERVED_Msk = 0x300
	// Position of OD field.
	IOCON_IOCON_PIO1_11_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO1_11_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO1_11_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO1_11_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO1_11_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO1_11_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO1_11_RESERVED_Msk = 0xfffff800

	// IOCON_PIO3_2: I/O configuration for pin PIO3_2/DCD/ CT16B0_MAT2/SCK1
	// Position of FUNC field.
	IOCON_IOCON_PIO3_2_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO3_2_FUNC_Msk = 0x7
	// Selects function PIO3_2.
	IOCON_IOCON_PIO3_2_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Selects function DCD.
	IOCON_IOCON_PIO3_2_FUNC_SELECTS_FUNCTION_DCD = 0x1
	// Selects function CT16B0_MAT2.
	IOCON_IOCON_PIO3_2_FUNC_SELECTS_FUNCTION_CT1 = 0x2
	// Selects function SCK1.
	IOCON_IOCON_PIO3_2_FUNC_SELECTS_FUNCTION_SCK = 0x3
	// Position of MODE field.
	IOCON_IOCON_PIO3_2_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO3_2_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO3_2_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO3_2_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO3_2_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO3_2_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO3_2_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO3_2_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO3_2_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO3_2_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO3_2_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO3_2_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO3_2_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO3_2_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO3_2_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO3_2_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO3_2_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO3_2_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO3_2_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO3_2_RESERVED_Msk = 0xfffff800

	// IOCON_PIO1_5: I/O configuration for pin PIO1_5/RTS/CT32B0_CAP0
	// Position of FUNC field.
	IOCON_IOCON_PIO1_5_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO1_5_FUNC_Msk = 0x7
	// Selects function PIO1_5.
	IOCON_IOCON_PIO1_5_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Selects function RTS.
	IOCON_IOCON_PIO1_5_FUNC_SELECTS_FUNCTION_RTS = 0x1
	// Selects function CT32B0_CAP0.
	IOCON_IOCON_PIO1_5_FUNC_SELECTS_FUNCTION_CT3 = 0x2
	// Position of MODE field.
	IOCON_IOCON_PIO1_5_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO1_5_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO1_5_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO1_5_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO1_5_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO1_5_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO1_5_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO1_5_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO1_5_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO1_5_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO1_5_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO1_5_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO1_5_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO1_5_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO1_5_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO1_5_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO1_5_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO1_5_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO1_5_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO1_5_RESERVED_Msk = 0xfffff800

	// IOCON_PIO1_6: I/O configuration for pin PIO1_6/RXD/CT32B0_MAT0
	// Position of FUNC field.
	IOCON_IOCON_PIO1_6_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO1_6_FUNC_Msk = 0x7
	// Selects function PIO1_6.
	IOCON_IOCON_PIO1_6_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Selects function RXD.
	IOCON_IOCON_PIO1_6_FUNC_SELECTS_FUNCTION_RXD = 0x1
	// Selects function CT32B0_MAT0.
	IOCON_IOCON_PIO1_6_FUNC_SELECTS_FUNCTION_CT3 = 0x2
	// Position of MODE field.
	IOCON_IOCON_PIO1_6_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO1_6_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO1_6_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO1_6_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO1_6_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO1_6_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO1_6_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO1_6_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO1_6_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO1_6_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO1_6_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO1_6_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO1_6_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO1_6_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO1_6_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO1_6_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO1_6_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO1_6_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO1_6_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO1_6_RESERVED_Msk = 0xfffff800

	// IOCON_PIO1_7: I/O configuration for pin PIO1_7/TXD/CT32B0_MAT1
	// Position of FUNC field.
	IOCON_IOCON_PIO1_7_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO1_7_FUNC_Msk = 0x7
	// Selects function PIO1_7.
	IOCON_IOCON_PIO1_7_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Selects function TXD.
	IOCON_IOCON_PIO1_7_FUNC_SELECTS_FUNCTION_TXD = 0x1
	// Selects function CT32B0_MAT1.
	IOCON_IOCON_PIO1_7_FUNC_SELECTS_FUNCTION_CT3 = 0x2
	// Position of MODE field.
	IOCON_IOCON_PIO1_7_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO1_7_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO1_7_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO1_7_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO1_7_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO1_7_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO1_7_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO1_7_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO1_7_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO1_7_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO1_7_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO1_7_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO1_7_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO1_7_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO1_7_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO1_7_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO1_7_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO1_7_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO1_7_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO1_7_RESERVED_Msk = 0xfffff800

	// IOCON_PIO3_3: I/O configuration for pin PIO3_3/RI/ CT16B0_CAP0
	// Position of FUNC field.
	IOCON_IOCON_PIO3_3_FUNC_Pos = 0x0
	// Bit mask of FUNC field.
	IOCON_IOCON_PIO3_3_FUNC_Msk = 0x7
	// Selects function PIO3_3.
	IOCON_IOCON_PIO3_3_FUNC_SELECTS_FUNCTION_PIO = 0x0
	// Selects function RI.
	IOCON_IOCON_PIO3_3_FUNC_SELECTS_FUNCTION_RI_ = 0x1
	// Selects function CT16B0_CAP0.
	IOCON_IOCON_PIO3_3_FUNC_SELECTS_FUNCTION_CT1 = 0x2
	// Position of MODE field.
	IOCON_IOCON_PIO3_3_MODE_Pos = 0x3
	// Bit mask of MODE field.
	IOCON_IOCON_PIO3_3_MODE_Msk = 0x18
	// Inactive (no pull-down/pull-up resistor enabled).
	IOCON_IOCON_PIO3_3_MODE_INACTIVE_NO_PULL_DO = 0x0
	// Pull-down resistor enabled.
	IOCON_IOCON_PIO3_3_MODE_PULL_DOWN_RESISTOR_E = 0x1
	// Pull-up resistor enabled.
	IOCON_IOCON_PIO3_3_MODE_PULL_UP_RESISTOR_ENA = 0x2
	// Repeater mode.
	IOCON_IOCON_PIO3_3_MODE_REPEATER_MODE_ = 0x3
	// Position of HYS field.
	IOCON_IOCON_PIO3_3_HYS_Pos = 0x5
	// Bit mask of HYS field.
	IOCON_IOCON_PIO3_3_HYS_Msk = 0x20
	// Bit HYS.
	IOCON_IOCON_PIO3_3_HYS = 0x20
	// Disable.
	IOCON_IOCON_PIO3_3_HYS_DISABLE_ = 0x0
	// Enable.
	IOCON_IOCON_PIO3_3_HYS_ENABLE_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO3_3_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO3_3_RESERVED_Msk = 0x3c0
	// Position of OD field.
	IOCON_IOCON_PIO3_3_OD_Pos = 0xa
	// Bit mask of OD field.
	IOCON_IOCON_PIO3_3_OD_Msk = 0x400
	// Bit OD.
	IOCON_IOCON_PIO3_3_OD = 0x400
	// Standard GPIO output
	IOCON_IOCON_PIO3_3_OD_STANDARD_GPIO_OUTPUT = 0x0
	// Open-drain output
	IOCON_IOCON_PIO3_3_OD_OPEN_DRAIN_OUTPUT = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_PIO3_3_RESERVED_Pos = 0xb
	// Bit mask of RESERVED field.
	IOCON_IOCON_PIO3_3_RESERVED_Msk = 0xfffff800

	// IOCON_SCK0_LOC: SCK0 pin location select register
	// Position of SCKLOC field.
	IOCON_IOCON_SCK0_LOC_SCKLOC_Pos = 0x0
	// Bit mask of SCKLOC field.
	IOCON_IOCON_SCK0_LOC_SCKLOC_Msk = 0x3
	// Reserved.
	IOCON_IOCON_SCK0_LOC_SCKLOC_RESERVED_ = 0x3
	// Position of RESERVED field.
	IOCON_IOCON_SCK0_LOC_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	IOCON_IOCON_SCK0_LOC_RESERVED_Msk = 0xfffffffc

	// IOCON_DSR_LOC: DSR pin location select register
	// Position of DSRLOC field.
	IOCON_IOCON_DSR_LOC_DSRLOC_Pos = 0x0
	// Bit mask of DSRLOC field.
	IOCON_IOCON_DSR_LOC_DSRLOC_Msk = 0x3
	// Selects DSR function in pin location PIO2_1/DSR/SCK1 (see Table 113).
	IOCON_IOCON_DSR_LOC_DSRLOC_SELECTS_DSR_FUNCTIO = 0x0
	// Selects DSR function in pin location PIO3_1/DSR (see Table 137).
	IOCON_IOCON_DSR_LOC_DSRLOC_SELECTS_DSR_FUNCTION = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_DSR_LOC_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	IOCON_IOCON_DSR_LOC_RESERVED_Msk = 0xfffffffc

	// IOCON_DCD_LOC: DCD pin location select register
	// Position of DCDLOC field.
	IOCON_IOCON_DCD_LOC_DCDLOC_Pos = 0x0
	// Bit mask of DCDLOC field.
	IOCON_IOCON_DCD_LOC_DCDLOC_Msk = 0x3
	// Selects DCD function in pin location PIO2_2/DCD/MISO1 (see Table 126).
	IOCON_IOCON_DCD_LOC_DCDLOC_SELECTS_DCD_FUNCTIO = 0x0
	// Selects DCD function in pin location PIO3_2/DCD (see Table 142).
	IOCON_IOCON_DCD_LOC_DCDLOC_SELECTS_DCD_FUNCTION = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_DCD_LOC_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	IOCON_IOCON_DCD_LOC_RESERVED_Msk = 0xfffffffc

	// IOCON_RI_LOC: RI pin location select register
	// Position of RILOC field.
	IOCON_IOCON_RI_LOC_RILOC_Pos = 0x0
	// Bit mask of RILOC field.
	IOCON_IOCON_RI_LOC_RILOC_Msk = 0x3
	// Selects RI function in pin location PIO2_3/RI/MOSI1 (see Table 138).
	IOCON_IOCON_RI_LOC_RILOC_SELECTS_RI_FUNCTION = 0x0
	// Selects RI function in pin location PIO3_3/RI (see Table 146).
	IOCON_IOCON_RI_LOC_RILOC_SELECTS_RI_FUNCTION_ = 0x1
	// Position of RESERVED field.
	IOCON_IOCON_RI_LOC_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	IOCON_IOCON_RI_LOC_RESERVED_Msk = 0xfffffffc

	// IOCON_CT16B0_CAP0_LOC: CT16B0_CAP0 pin location select register
	// Position of CT16B0_CAP0LOC field.
	IOCON_IOCON_CT16B0_CAP0_LOC_CT16B0_CAP0LOC_Pos = 0x0
	// Bit mask of CT16B0_CAP0LOC field.
	IOCON_IOCON_CT16B0_CAP0_LOC_CT16B0_CAP0LOC_Msk = 0x3
	// Position of RESERVED field.
	IOCON_IOCON_CT16B0_CAP0_LOC_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	IOCON_IOCON_CT16B0_CAP0_LOC_RESERVED_Msk = 0xfffffffc

	// IOCON_SCK1_LOC: SCK1 pin location select register
	// Position of SCK1LOC field.
	IOCON_IOCON_SCK1_LOC_SCK1LOC_Pos = 0x0
	// Bit mask of SCK1LOC field.
	IOCON_IOCON_SCK1_LOC_SCK1LOC_Msk = 0x3
	// Position of RESERVED field.
	IOCON_IOCON_SCK1_LOC_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	IOCON_IOCON_SCK1_LOC_RESERVED_Msk = 0xfffffffc

	// IOCON_MISO1_LOC: MISO1 pin location select register
	// Position of MISO1LOC field.
	IOCON_IOCON_MISO1_LOC_MISO1LOC_Pos = 0x0
	// Bit mask of MISO1LOC field.
	IOCON_IOCON_MISO1_LOC_MISO1LOC_Msk = 0x3
	// Position of RESERVED field.
	IOCON_IOCON_MISO1_LOC_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	IOCON_IOCON_MISO1_LOC_RESERVED_Msk = 0xfffffffc

	// IOCON_MOSI1_LOC: MOSI1 pin location select register
	// Position of MOSI1LOC field.
	IOCON_IOCON_MOSI1_LOC_MOSI1LOC_Pos = 0x0
	// Bit mask of MOSI1LOC field.
	IOCON_IOCON_MOSI1_LOC_MOSI1LOC_Msk = 0x3
	// Position of RESERVED field.
	IOCON_IOCON_MOSI1_LOC_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	IOCON_IOCON_MOSI1_LOC_RESERVED_Msk = 0xfffffffc

	// IOCON_CT32B0_CAP0_LOC: CT32B0_CAP0 pin location select register
	// Position of CT32B0_CAP0LOC field.
	IOCON_IOCON_CT32B0_CAP0_LOC_CT32B0_CAP0LOC_Pos = 0x0
	// Bit mask of CT32B0_CAP0LOC field.
	IOCON_IOCON_CT32B0_CAP0_LOC_CT32B0_CAP0LOC_Msk = 0x3
	// Position of RESERVED field.
	IOCON_IOCON_CT32B0_CAP0_LOC_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	IOCON_IOCON_CT32B0_CAP0_LOC_RESERVED_Msk = 0xfffffffc

	// IOCON_RXD_LOC: RXD pin location select register
	// Position of RXDLOC field.
	IOCON_IOCON_RXD_LOC_RXDLOC_Pos = 0x0
	// Bit mask of RXDLOC field.
	IOCON_IOCON_RXD_LOC_RXDLOC_Msk = 0x3
	// Position of RESERVED field.
	IOCON_IOCON_RXD_LOC_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	IOCON_IOCON_RXD_LOC_RESERVED_Msk = 0xfffffffc
)

// Constants for SYSCON: Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx System configuration (SYSCON) Modification date=2/22/2012 Major revision=8 Minor revision=not available
const (
	// SYSMEMREMAP: System memory remap
	// Position of MAP field.
	SYSCON_SYSMEMREMAP_MAP_Pos = 0x0
	// Bit mask of MAP field.
	SYSCON_SYSMEMREMAP_MAP_Msk = 0x3
	// Boot Loader Mode. Interrupt vectors are re-mapped to Boot ROM.
	SYSCON_SYSMEMREMAP_MAP_BOOT_LOADER_MODE_IN = 0x0
	// User RAM Mode. Interrupt vectors are re-mapped to Static RAM.
	SYSCON_SYSMEMREMAP_MAP_USER_RAM_MODE_INTER = 0x1
	// User Flash Mode. Interrupt vectors are not re-mapped and reside in Flash.
	SYSCON_SYSMEMREMAP_MAP_USER_FLASH_MODE_INT = 0x2
	// Position of RESERVED field.
	SYSCON_SYSMEMREMAP_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	SYSCON_SYSMEMREMAP_RESERVED_Msk = 0xfffffffc

	// PRESETCTRL: Peripheral reset control
	// Position of SSP0_RST_N field.
	SYSCON_PRESETCTRL_SSP0_RST_N_Pos = 0x0
	// Bit mask of SSP0_RST_N field.
	SYSCON_PRESETCTRL_SSP0_RST_N_Msk = 0x1
	// Bit SSP0_RST_N.
	SYSCON_PRESETCTRL_SSP0_RST_N = 0x1
	// Resets the SPI0 peripheral.
	SYSCON_PRESETCTRL_SSP0_RST_N_SPIO0RESET = 0x0
	// SPI0 reset de-asserted.
	SYSCON_PRESETCTRL_SSP0_RST_N_SPIO0NORESET = 0x1
	// Position of I2C_RST_N field.
	SYSCON_PRESETCTRL_I2C_RST_N_Pos = 0x1
	// Bit mask of I2C_RST_N field.
	SYSCON_PRESETCTRL_I2C_RST_N_Msk = 0x2
	// Bit I2C_RST_N.
	SYSCON_PRESETCTRL_I2C_RST_N = 0x2
	// Resets the I2C peripheral.
	SYSCON_PRESETCTRL_I2C_RST_N_I2CRESET = 0x0
	// I2C reset de-asserted.
	SYSCON_PRESETCTRL_I2C_RST_N_I2CNORESET = 0x1
	// Position of SSP1_RST_N field.
	SYSCON_PRESETCTRL_SSP1_RST_N_Pos = 0x2
	// Bit mask of SSP1_RST_N field.
	SYSCON_PRESETCTRL_SSP1_RST_N_Msk = 0x4
	// Bit SSP1_RST_N.
	SYSCON_PRESETCTRL_SSP1_RST_N = 0x4
	// Resets the SPI1 peripheral.
	SYSCON_PRESETCTRL_SSP1_RST_N_SPI1RESET = 0x0
	// SPI1 reset de-asserted.
	SYSCON_PRESETCTRL_SSP1_RST_N_SPI2NORESET = 0x1
	// Position of CAN_RST_N field.
	SYSCON_PRESETCTRL_CAN_RST_N_Pos = 0x3
	// Bit mask of CAN_RST_N field.
	SYSCON_PRESETCTRL_CAN_RST_N_Msk = 0x8
	// Bit CAN_RST_N.
	SYSCON_PRESETCTRL_CAN_RST_N = 0x8
	// Resets the C_CAN peripheral.
	SYSCON_PRESETCTRL_CAN_RST_N_CANRESET = 0x0
	// C_CAN reset de-asserted.
	SYSCON_PRESETCTRL_CAN_RST_N_CANNORESET = 0x1
	// Position of RESERVED field.
	SYSCON_PRESETCTRL_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	SYSCON_PRESETCTRL_RESERVED_Msk = 0xfffffff0

	// SYSPLLCTRL: System PLL control
	// Position of MSEL field.
	SYSCON_SYSPLLCTRL_MSEL_Pos = 0x0
	// Bit mask of MSEL field.
	SYSCON_SYSPLLCTRL_MSEL_Msk = 0x1f
	// Position of PSEL field.
	SYSCON_SYSPLLCTRL_PSEL_Pos = 0x5
	// Bit mask of PSEL field.
	SYSCON_SYSPLLCTRL_PSEL_Msk = 0x60
	// P = 1
	SYSCON_SYSPLLCTRL_PSEL_P_EQ_1 = 0x0
	// P = 2
	SYSCON_SYSPLLCTRL_PSEL_P_EQ_2 = 0x1
	// P = 4
	SYSCON_SYSPLLCTRL_PSEL_P_EQ_4 = 0x2
	// P = 8
	SYSCON_SYSPLLCTRL_PSEL_P_EQ_8 = 0x3
	// Position of RESERVED field.
	SYSCON_SYSPLLCTRL_RESERVED_Pos = 0x7
	// Bit mask of RESERVED field.
	SYSCON_SYSPLLCTRL_RESERVED_Msk = 0xffffff80

	// SYSPLLSTAT: System PLL status
	// Position of LOCK field.
	SYSCON_SYSPLLSTAT_LOCK_Pos = 0x0
	// Bit mask of LOCK field.
	SYSCON_SYSPLLSTAT_LOCK_Msk = 0x1
	// Bit LOCK.
	SYSCON_SYSPLLSTAT_LOCK = 0x1
	// PLL not locked
	SYSCON_SYSPLLSTAT_LOCK_PLL_NOT_LOCKED = 0x0
	// PLL locked
	SYSCON_SYSPLLSTAT_LOCK_PLL_LOCKED = 0x1
	// Position of RESERVED field.
	SYSCON_SYSPLLSTAT_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	SYSCON_SYSPLLSTAT_RESERVED_Msk = 0xfffffffe

	// SYSOSCCTRL: System oscillator control
	// Position of BYPASS field.
	SYSCON_SYSOSCCTRL_BYPASS_Pos = 0x0
	// Bit mask of BYPASS field.
	SYSCON_SYSOSCCTRL_BYPASS_Msk = 0x1
	// Bit BYPASS.
	SYSCON_SYSOSCCTRL_BYPASS = 0x1
	// Oscillator is not bypassed.
	SYSCON_SYSOSCCTRL_BYPASS_NOBYPASS = 0x0
	// Bypass enabled. PLL input (sys_osc_clk) is fed directly from the XTALIN and XTALOUT pins.
	SYSCON_SYSOSCCTRL_BYPASS_BYPASS_ENABLED_PLL_ = 0x1
	// Position of FREQRANGE field.
	SYSCON_SYSOSCCTRL_FREQRANGE_Pos = 0x1
	// Bit mask of FREQRANGE field.
	SYSCON_SYSOSCCTRL_FREQRANGE_Msk = 0x2
	// Bit FREQRANGE.
	SYSCON_SYSOSCCTRL_FREQRANGE = 0x2
	// 1 - 20 MHz frequency range.
	SYSCON_SYSOSCCTRL_FREQRANGE_LOW = 0x0
	// 15 - 25 MHz frequency range
	SYSCON_SYSOSCCTRL_FREQRANGE_HIGH = 0x1
	// Position of RESERVED field.
	SYSCON_SYSOSCCTRL_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	SYSCON_SYSOSCCTRL_RESERVED_Msk = 0xfffffffc

	// WDTOSCCTRL: Watchdog oscillator control
	// Position of DIVSEL field.
	SYSCON_WDTOSCCTRL_DIVSEL_Pos = 0x0
	// Bit mask of DIVSEL field.
	SYSCON_WDTOSCCTRL_DIVSEL_Msk = 0x1f
	// Position of FREQSEL field.
	SYSCON_WDTOSCCTRL_FREQSEL_Pos = 0x5
	// Bit mask of FREQSEL field.
	SYSCON_WDTOSCCTRL_FREQSEL_Msk = 0x1e0
	// 0.5 MHz
	SYSCON_WDTOSCCTRL_FREQSEL_0_5_MHZ = 0x1
	// 0.8 MHz
	SYSCON_WDTOSCCTRL_FREQSEL_0_8_MHZ = 0x2
	// 1.1 MHz
	SYSCON_WDTOSCCTRL_FREQSEL_1_1_MHZ = 0x3
	// 1.4 MHz
	SYSCON_WDTOSCCTRL_FREQSEL_1_4_MHZ = 0x4
	// 1.6 MHz
	SYSCON_WDTOSCCTRL_FREQSEL_1_6_MHZ = 0x5
	// 1.8 MHz
	SYSCON_WDTOSCCTRL_FREQSEL_1_8_MHZ = 0x6
	// 2.0 MHz
	SYSCON_WDTOSCCTRL_FREQSEL_2_0_MHZ = 0x7
	// 2.2 MHz
	SYSCON_WDTOSCCTRL_FREQSEL_2_2_MHZ = 0x8
	// 2.4 MHz
	SYSCON_WDTOSCCTRL_FREQSEL_2_4_MHZ = 0x9
	// 2.6 MHz
	SYSCON_WDTOSCCTRL_FREQSEL_2_6_MHZ = 0xa
	// 2.7 MHz
	SYSCON_WDTOSCCTRL_FREQSEL_2_7_MHZ = 0xb
	// 2.9 MHz
	SYSCON_WDTOSCCTRL_FREQSEL_2_9_MHZ = 0xc
	// 3.1 MHz
	SYSCON_WDTOSCCTRL_FREQSEL_3_1_MHZ = 0xd
	// 3.2 MHz
	SYSCON_WDTOSCCTRL_FREQSEL_3_2_MHZ = 0xe
	// 3.4 MHz
	SYSCON_WDTOSCCTRL_FREQSEL_3_4_MHZ = 0xf
	// Position of RESERVED field.
	SYSCON_WDTOSCCTRL_RESERVED_Pos = 0x9
	// Bit mask of RESERVED field.
	SYSCON_WDTOSCCTRL_RESERVED_Msk = 0xfffffe00

	// IRCCTRL: IRC control
	// Position of TRIM field.
	SYSCON_IRCCTRL_TRIM_Pos = 0x0
	// Bit mask of TRIM field.
	SYSCON_IRCCTRL_TRIM_Msk = 0xff
	// Position of RESERVED field.
	SYSCON_IRCCTRL_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SYSCON_IRCCTRL_RESERVED_Msk = 0xffffff00

	// SYSRSTSTAT: System reset status register
	// Position of POR field.
	SYSCON_SYSRSTSTAT_POR_Pos = 0x0
	// Bit mask of POR field.
	SYSCON_SYSRSTSTAT_POR_Msk = 0x1
	// Bit POR.
	SYSCON_SYSRSTSTAT_POR = 0x1
	// No POR detected.
	SYSCON_SYSRSTSTAT_POR_NO_POR_DETECTED_ = 0x0
	// POR detected. Writing a one clears this reset.
	SYSCON_SYSRSTSTAT_POR_POR_DETECTED_WRITIN = 0x1
	// Position of EXTRST field.
	SYSCON_SYSRSTSTAT_EXTRST_Pos = 0x1
	// Bit mask of EXTRST field.
	SYSCON_SYSRSTSTAT_EXTRST_Msk = 0x2
	// Bit EXTRST.
	SYSCON_SYSRSTSTAT_EXTRST = 0x2
	// No RESET event detected.
	SYSCON_SYSRSTSTAT_EXTRST_NO_RESET_EVENT_DETEC = 0x0
	// RESET detected. Writing a one clears this reset.
	SYSCON_SYSRSTSTAT_EXTRST_RESET_DETECTED_WRIT = 0x1
	// Position of WDT field.
	SYSCON_SYSRSTSTAT_WDT_Pos = 0x2
	// Bit mask of WDT field.
	SYSCON_SYSRSTSTAT_WDT_Msk = 0x4
	// Bit WDT.
	SYSCON_SYSRSTSTAT_WDT = 0x4
	// No WDT reset detected.
	SYSCON_SYSRSTSTAT_WDT_NO_WDT_RESET_DETECTE = 0x0
	// WDT reset detected. Writing a one clears this reset.
	SYSCON_SYSRSTSTAT_WDT_WDT_RESET_DETECTED_ = 0x1
	// Position of BOD field.
	SYSCON_SYSRSTSTAT_BOD_Pos = 0x3
	// Bit mask of BOD field.
	SYSCON_SYSRSTSTAT_BOD_Msk = 0x8
	// Bit BOD.
	SYSCON_SYSRSTSTAT_BOD = 0x8
	// No BOD reset detected.
	SYSCON_SYSRSTSTAT_BOD_NO_BOD_RESET_DETECTE = 0x0
	// BOD reset detected. Writing a one clears this reset.
	SYSCON_SYSRSTSTAT_BOD_BOD_RESET_DETECTED_ = 0x1
	// Position of SYSRST field.
	SYSCON_SYSRSTSTAT_SYSRST_Pos = 0x4
	// Bit mask of SYSRST field.
	SYSCON_SYSRSTSTAT_SYSRST_Msk = 0x10
	// Bit SYSRST.
	SYSCON_SYSRSTSTAT_SYSRST = 0x10
	// No System reset detected.
	SYSCON_SYSRSTSTAT_SYSRST_NO_SYSTEM_RESET_DETE = 0x0
	// System reset detected. Writing a one clears this reset.
	SYSCON_SYSRSTSTAT_SYSRST_SYSTEM_RESET_DETECTE = 0x1
	// Position of RESERVED field.
	SYSCON_SYSRSTSTAT_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	SYSCON_SYSRSTSTAT_RESERVED_Msk = 0xffffffe0

	// SYSPLLCLKSEL: System PLL clock source select
	// Position of SEL field.
	SYSCON_SYSPLLCLKSEL_SEL_Pos = 0x0
	// Bit mask of SEL field.
	SYSCON_SYSPLLCLKSEL_SEL_Msk = 0x3
	// IRC oscillator
	SYSCON_SYSPLLCLKSEL_SEL_IRC_OSCILLATOR = 0x0
	// System oscillator
	SYSCON_SYSPLLCLKSEL_SEL_SYSTEM_OSCILLATOR = 0x1
	// Position of RESERVED field.
	SYSCON_SYSPLLCLKSEL_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	SYSCON_SYSPLLCLKSEL_RESERVED_Msk = 0xfffffffc

	// SYSPLLCLKUEN: System PLL clock source update enable
	// Position of ENA field.
	SYSCON_SYSPLLCLKUEN_ENA_Pos = 0x0
	// Bit mask of ENA field.
	SYSCON_SYSPLLCLKUEN_ENA_Msk = 0x1
	// Bit ENA.
	SYSCON_SYSPLLCLKUEN_ENA = 0x1
	// No change
	SYSCON_SYSPLLCLKUEN_ENA_NO_CHANGE = 0x0
	// Update clock source
	SYSCON_SYSPLLCLKUEN_ENA_UPDATE_CLOCK_SOURCE = 0x1
	// Position of RESERVED field.
	SYSCON_SYSPLLCLKUEN_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	SYSCON_SYSPLLCLKUEN_RESERVED_Msk = 0xfffffffe

	// MAINCLKSEL: Main clock source select
	// Position of SEL field.
	SYSCON_MAINCLKSEL_SEL_Pos = 0x0
	// Bit mask of SEL field.
	SYSCON_MAINCLKSEL_SEL_Msk = 0x3
	// IRC oscillator
	SYSCON_MAINCLKSEL_SEL_IRC_OSCILLATOR = 0x0
	// Input clock to system PLL
	SYSCON_MAINCLKSEL_SEL_INPUT_CLOCK_TO_SYSTE = 0x1
	// WDT oscillator
	SYSCON_MAINCLKSEL_SEL_WDT_OSCILLATOR = 0x2
	// System PLL clock out
	SYSCON_MAINCLKSEL_SEL_SYSTEM_PLL_CLOCK_OUT = 0x3
	// Position of RESERVED field.
	SYSCON_MAINCLKSEL_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	SYSCON_MAINCLKSEL_RESERVED_Msk = 0xfffffffc

	// MAINCLKUEN: Main clock source update enable
	// Position of ENA field.
	SYSCON_MAINCLKUEN_ENA_Pos = 0x0
	// Bit mask of ENA field.
	SYSCON_MAINCLKUEN_ENA_Msk = 0x1
	// Bit ENA.
	SYSCON_MAINCLKUEN_ENA = 0x1
	// No change
	SYSCON_MAINCLKUEN_ENA_NO_CHANGE = 0x0
	// Update clock source
	SYSCON_MAINCLKUEN_ENA_UPDATE_CLOCK_SOURCE = 0x1
	// Position of RESERVED field.
	SYSCON_MAINCLKUEN_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	SYSCON_MAINCLKUEN_RESERVED_Msk = 0xfffffffe

	// SYSAHBCLKDIV: System AHB clock divider
	// Position of DIV field.
	SYSCON_SYSAHBCLKDIV_DIV_Pos = 0x0
	// Bit mask of DIV field.
	SYSCON_SYSAHBCLKDIV_DIV_Msk = 0xff
	// Position of RESERVED field.
	SYSCON_SYSAHBCLKDIV_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SYSCON_SYSAHBCLKDIV_RESERVED_Msk = 0xffffff00

	// SYSAHBCLKCTRL: System AHB clock control
	// Position of SYS field.
	SYSCON_SYSAHBCLKCTRL_SYS_Pos = 0x0
	// Bit mask of SYS field.
	SYSCON_SYSAHBCLKCTRL_SYS_Msk = 0x1
	// Bit SYS.
	SYSCON_SYSAHBCLKCTRL_SYS = 0x1
	// Enable
	SYSCON_SYSAHBCLKCTRL_SYS_ENABLE = 0x1
	// Position of ROM field.
	SYSCON_SYSAHBCLKCTRL_ROM_Pos = 0x1
	// Bit mask of ROM field.
	SYSCON_SYSAHBCLKCTRL_ROM_Msk = 0x2
	// Bit ROM.
	SYSCON_SYSAHBCLKCTRL_ROM = 0x2
	// Disable
	SYSCON_SYSAHBCLKCTRL_ROM_DISABLE = 0x0
	// Enable
	SYSCON_SYSAHBCLKCTRL_ROM_ENABLE = 0x1
	// Position of RAM field.
	SYSCON_SYSAHBCLKCTRL_RAM_Pos = 0x2
	// Bit mask of RAM field.
	SYSCON_SYSAHBCLKCTRL_RAM_Msk = 0x4
	// Bit RAM.
	SYSCON_SYSAHBCLKCTRL_RAM = 0x4
	// Disable
	SYSCON_SYSAHBCLKCTRL_RAM_DISABLE = 0x0
	// Enable
	SYSCON_SYSAHBCLKCTRL_RAM_ENABLE = 0x1
	// Position of FLASHREG field.
	SYSCON_SYSAHBCLKCTRL_FLASHREG_Pos = 0x3
	// Bit mask of FLASHREG field.
	SYSCON_SYSAHBCLKCTRL_FLASHREG_Msk = 0x8
	// Bit FLASHREG.
	SYSCON_SYSAHBCLKCTRL_FLASHREG = 0x8
	// Disabled
	SYSCON_SYSAHBCLKCTRL_FLASHREG_DISABLED = 0x0
	// Enabled
	SYSCON_SYSAHBCLKCTRL_FLASHREG_ENABLED = 0x1
	// Position of FLASHARRAY field.
	SYSCON_SYSAHBCLKCTRL_FLASHARRAY_Pos = 0x4
	// Bit mask of FLASHARRAY field.
	SYSCON_SYSAHBCLKCTRL_FLASHARRAY_Msk = 0x10
	// Bit FLASHARRAY.
	SYSCON_SYSAHBCLKCTRL_FLASHARRAY = 0x10
	// Disabled
	SYSCON_SYSAHBCLKCTRL_FLASHARRAY_DISABLED = 0x0
	// Enabled
	SYSCON_SYSAHBCLKCTRL_FLASHARRAY_ENABLED = 0x1
	// Position of I2C field.
	SYSCON_SYSAHBCLKCTRL_I2C_Pos = 0x5
	// Bit mask of I2C field.
	SYSCON_SYSAHBCLKCTRL_I2C_Msk = 0x20
	// Bit I2C.
	SYSCON_SYSAHBCLKCTRL_I2C = 0x20
	// Disable
	SYSCON_SYSAHBCLKCTRL_I2C_DISABLE = 0x0
	// Enable
	SYSCON_SYSAHBCLKCTRL_I2C_ENABLE = 0x1
	// Position of GPIO field.
	SYSCON_SYSAHBCLKCTRL_GPIO_Pos = 0x6
	// Bit mask of GPIO field.
	SYSCON_SYSAHBCLKCTRL_GPIO_Msk = 0x40
	// Bit GPIO.
	SYSCON_SYSAHBCLKCTRL_GPIO = 0x40
	// Disable
	SYSCON_SYSAHBCLKCTRL_GPIO_DISABLE = 0x0
	// Enable
	SYSCON_SYSAHBCLKCTRL_GPIO_ENABLE = 0x1
	// Position of CT16B0 field.
	SYSCON_SYSAHBCLKCTRL_CT16B0_Pos = 0x7
	// Bit mask of CT16B0 field.
	SYSCON_SYSAHBCLKCTRL_CT16B0_Msk = 0x80
	// Bit CT16B0.
	SYSCON_SYSAHBCLKCTRL_CT16B0 = 0x80
	// Disable
	SYSCON_SYSAHBCLKCTRL_CT16B0_DISABLE = 0x0
	// Enable
	SYSCON_SYSAHBCLKCTRL_CT16B0_ENABLE = 0x1
	// Position of CT16B1 field.
	SYSCON_SYSAHBCLKCTRL_CT16B1_Pos = 0x8
	// Bit mask of CT16B1 field.
	SYSCON_SYSAHBCLKCTRL_CT16B1_Msk = 0x100
	// Bit CT16B1.
	SYSCON_SYSAHBCLKCTRL_CT16B1 = 0x100
	// Disable
	SYSCON_SYSAHBCLKCTRL_CT16B1_DISABLE = 0x0
	// Enable
	SYSCON_SYSAHBCLKCTRL_CT16B1_ENABLE = 0x1
	// Position of CT32B0 field.
	SYSCON_SYSAHBCLKCTRL_CT32B0_Pos = 0x9
	// Bit mask of CT32B0 field.
	SYSCON_SYSAHBCLKCTRL_CT32B0_Msk = 0x200
	// Bit CT32B0.
	SYSCON_SYSAHBCLKCTRL_CT32B0 = 0x200
	// Disable
	SYSCON_SYSAHBCLKCTRL_CT32B0_DISABLE = 0x0
	// Enable
	SYSCON_SYSAHBCLKCTRL_CT32B0_ENABLE = 0x1
	// Position of CT32B1 field.
	SYSCON_SYSAHBCLKCTRL_CT32B1_Pos = 0xa
	// Bit mask of CT32B1 field.
	SYSCON_SYSAHBCLKCTRL_CT32B1_Msk = 0x400
	// Bit CT32B1.
	SYSCON_SYSAHBCLKCTRL_CT32B1 = 0x400
	// Disable
	SYSCON_SYSAHBCLKCTRL_CT32B1_DISABLE = 0x0
	// Enable
	SYSCON_SYSAHBCLKCTRL_CT32B1_ENABLE = 0x1
	// Position of SSP0 field.
	SYSCON_SYSAHBCLKCTRL_SSP0_Pos = 0xb
	// Bit mask of SSP0 field.
	SYSCON_SYSAHBCLKCTRL_SSP0_Msk = 0x800
	// Bit SSP0.
	SYSCON_SYSAHBCLKCTRL_SSP0 = 0x800
	// Disable
	SYSCON_SYSAHBCLKCTRL_SSP0_DISABLE = 0x0
	// Enable
	SYSCON_SYSAHBCLKCTRL_SSP0_ENABLE = 0x1
	// Position of UART field.
	SYSCON_SYSAHBCLKCTRL_UART_Pos = 0xc
	// Bit mask of UART field.
	SYSCON_SYSAHBCLKCTRL_UART_Msk = 0x1000
	// Bit UART.
	SYSCON_SYSAHBCLKCTRL_UART = 0x1000
	// Disable
	SYSCON_SYSAHBCLKCTRL_UART_DISABLE = 0x0
	// Enable
	SYSCON_SYSAHBCLKCTRL_UART_ENABLE = 0x1
	// Position of ADC field.
	SYSCON_SYSAHBCLKCTRL_ADC_Pos = 0xd
	// Bit mask of ADC field.
	SYSCON_SYSAHBCLKCTRL_ADC_Msk = 0x2000
	// Bit ADC.
	SYSCON_SYSAHBCLKCTRL_ADC = 0x2000
	// Disable
	SYSCON_SYSAHBCLKCTRL_ADC_DISABLE = 0x0
	// Enable
	SYSCON_SYSAHBCLKCTRL_ADC_ENABLE = 0x1
	// Position of RESERVED field.
	SYSCON_SYSAHBCLKCTRL_RESERVED_Pos = 0xe
	// Bit mask of RESERVED field.
	SYSCON_SYSAHBCLKCTRL_RESERVED_Msk = 0x4000
	// Bit RESERVED.
	SYSCON_SYSAHBCLKCTRL_RESERVED = 0x4000
	// Position of WDT field.
	SYSCON_SYSAHBCLKCTRL_WDT_Pos = 0xf
	// Bit mask of WDT field.
	SYSCON_SYSAHBCLKCTRL_WDT_Msk = 0x8000
	// Bit WDT.
	SYSCON_SYSAHBCLKCTRL_WDT = 0x8000
	// Disable
	SYSCON_SYSAHBCLKCTRL_WDT_DISABLE = 0x0
	// Enable
	SYSCON_SYSAHBCLKCTRL_WDT_ENABLE = 0x1
	// Position of IOCON field.
	SYSCON_SYSAHBCLKCTRL_IOCON_Pos = 0x10
	// Bit mask of IOCON field.
	SYSCON_SYSAHBCLKCTRL_IOCON_Msk = 0x10000
	// Bit IOCON.
	SYSCON_SYSAHBCLKCTRL_IOCON = 0x10000
	// Disable
	SYSCON_SYSAHBCLKCTRL_IOCON_DISABLE = 0x0
	// Enable
	SYSCON_SYSAHBCLKCTRL_IOCON_ENABLE = 0x1
	// Position of CAN field.
	SYSCON_SYSAHBCLKCTRL_CAN_Pos = 0x11
	// Bit mask of CAN field.
	SYSCON_SYSAHBCLKCTRL_CAN_Msk = 0x20000
	// Bit CAN.
	SYSCON_SYSAHBCLKCTRL_CAN = 0x20000
	// Disable
	SYSCON_SYSAHBCLKCTRL_CAN_DISABLE = 0x0
	// Enable
	SYSCON_SYSAHBCLKCTRL_CAN_ENABLE = 0x1
	// Position of SSP1 field.
	SYSCON_SYSAHBCLKCTRL_SSP1_Pos = 0x12
	// Bit mask of SSP1 field.
	SYSCON_SYSAHBCLKCTRL_SSP1_Msk = 0x40000
	// Bit SSP1.
	SYSCON_SYSAHBCLKCTRL_SSP1 = 0x40000
	// Disable
	SYSCON_SYSAHBCLKCTRL_SSP1_DISABLE = 0x0
	// Enable
	SYSCON_SYSAHBCLKCTRL_SSP1_ENABLE = 0x1
	// Position of RESERVED field.
	SYSCON_SYSAHBCLKCTRL_RESERVED_Pos = 0x13
	// Bit mask of RESERVED field.
	SYSCON_SYSAHBCLKCTRL_RESERVED_Msk = 0xfff80000

	// SSP0CLKDIV: SPI0 clock divider
	// Position of DIV field.
	SYSCON_SSP0CLKDIV_DIV_Pos = 0x0
	// Bit mask of DIV field.
	SYSCON_SSP0CLKDIV_DIV_Msk = 0xff
	// Position of RESERVED field.
	SYSCON_SSP0CLKDIV_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SYSCON_SSP0CLKDIV_RESERVED_Msk = 0xffffff00

	// UARTCLKDIV: UART clock divder
	// Position of DIV field.
	SYSCON_UARTCLKDIV_DIV_Pos = 0x0
	// Bit mask of DIV field.
	SYSCON_UARTCLKDIV_DIV_Msk = 0xff
	// Position of RESERVED field.
	SYSCON_UARTCLKDIV_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SYSCON_UARTCLKDIV_RESERVED_Msk = 0xffffff00

	// SSP1CLKDIV: SPI1 clock divder
	// Position of DIV field.
	SYSCON_SSP1CLKDIV_DIV_Pos = 0x0
	// Bit mask of DIV field.
	SYSCON_SSP1CLKDIV_DIV_Msk = 0xff
	// Position of RESERVED field.
	SYSCON_SSP1CLKDIV_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SYSCON_SSP1CLKDIV_RESERVED_Msk = 0xffffff00

	// WDTCLKSEL: WDT clock source select
	// Position of SEL field.
	SYSCON_WDTCLKSEL_SEL_Pos = 0x0
	// Bit mask of SEL field.
	SYSCON_WDTCLKSEL_SEL_Msk = 0x3
	// IRC oscillator
	SYSCON_WDTCLKSEL_SEL_IRC_OSCILLATOR = 0x0
	// Main clock
	SYSCON_WDTCLKSEL_SEL_MAIN_CLOCK = 0x1
	// Watchdog oscillator
	SYSCON_WDTCLKSEL_SEL_WATCHDOG_OSCILLATOR = 0x2
	// Position of RESERVED field.
	SYSCON_WDTCLKSEL_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	SYSCON_WDTCLKSEL_RESERVED_Msk = 0xfffffffc

	// WDTCLKUEN: WDT clock source update enable
	// Position of ENA field.
	SYSCON_WDTCLKUEN_ENA_Pos = 0x0
	// Bit mask of ENA field.
	SYSCON_WDTCLKUEN_ENA_Msk = 0x1
	// Bit ENA.
	SYSCON_WDTCLKUEN_ENA = 0x1
	// No change
	SYSCON_WDTCLKUEN_ENA_NO_CHANGE = 0x0
	// Update clock source
	SYSCON_WDTCLKUEN_ENA_UPDATE_CLOCK_SOURCE = 0x1
	// Position of RESERVED field.
	SYSCON_WDTCLKUEN_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	SYSCON_WDTCLKUEN_RESERVED_Msk = 0xfffffffe

	// WDTCLKDIV: WDT clock divider
	// Position of DIV field.
	SYSCON_WDTCLKDIV_DIV_Pos = 0x0
	// Bit mask of DIV field.
	SYSCON_WDTCLKDIV_DIV_Msk = 0xff
	// Position of RESERVED field.
	SYSCON_WDTCLKDIV_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SYSCON_WDTCLKDIV_RESERVED_Msk = 0xffffff00

	// CLKOUTCLKSEL: CLKOUT clock source select
	// Position of SEL field.
	SYSCON_CLKOUTCLKSEL_SEL_Pos = 0x0
	// Bit mask of SEL field.
	SYSCON_CLKOUTCLKSEL_SEL_Msk = 0x3
	// IRC oscillator
	SYSCON_CLKOUTCLKSEL_SEL_IRC_OSCILLATOR = 0x0
	// System oscillator
	SYSCON_CLKOUTCLKSEL_SEL_SYSTEM_OSCILLATOR = 0x1
	// Watchdog oscillator
	SYSCON_CLKOUTCLKSEL_SEL_WATCHDOG_OSCILLATOR = 0x2
	// Main clock
	SYSCON_CLKOUTCLKSEL_SEL_MAIN_CLOCK = 0x3
	// Position of RESERVED field.
	SYSCON_CLKOUTCLKSEL_RESERVED_Pos = 0x2
	// Bit mask of RESERVED field.
	SYSCON_CLKOUTCLKSEL_RESERVED_Msk = 0xfffffffc

	// CLKOUTUEN: CLKOUT clock source update enable
	// Position of ENA field.
	SYSCON_CLKOUTUEN_ENA_Pos = 0x0
	// Bit mask of ENA field.
	SYSCON_CLKOUTUEN_ENA_Msk = 0x1
	// Bit ENA.
	SYSCON_CLKOUTUEN_ENA = 0x1
	// No change
	SYSCON_CLKOUTUEN_ENA_NO_CHANGE = 0x0
	// Update clock source
	SYSCON_CLKOUTUEN_ENA_UPDATE_CLOCK_SOURCE = 0x1
	// Position of RESERVED field.
	SYSCON_CLKOUTUEN_RESERVED_Pos = 0x1
	// Bit mask of RESERVED field.
	SYSCON_CLKOUTUEN_RESERVED_Msk = 0xfffffffe

	// CLKOUTCLKDIV: CLKOUT clock divider
	// Position of DIV field.
	SYSCON_CLKOUTCLKDIV_DIV_Pos = 0x0
	// Bit mask of DIV field.
	SYSCON_CLKOUTCLKDIV_DIV_Msk = 0xff
	// Position of RESERVED field.
	SYSCON_CLKOUTCLKDIV_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	SYSCON_CLKOUTCLKDIV_RESERVED_Msk = 0xffffff00

	// PIOPORCAP0: POR captured PIO status 0
	// Position of CAPPIO0_n field.
	SYSCON_PIOPORCAP0_CAPPIO0_n_Pos = 0x0
	// Bit mask of CAPPIO0_n field.
	SYSCON_PIOPORCAP0_CAPPIO0_n_Msk = 0xfff
	// Position of CAPPIO1_n field.
	SYSCON_PIOPORCAP0_CAPPIO1_n_Pos = 0xc
	// Bit mask of CAPPIO1_n field.
	SYSCON_PIOPORCAP0_CAPPIO1_n_Msk = 0xfff000
	// Position of CAPPIO2_n field.
	SYSCON_PIOPORCAP0_CAPPIO2_n_Pos = 0x18
	// Bit mask of CAPPIO2_n field.
	SYSCON_PIOPORCAP0_CAPPIO2_n_Msk = 0xff000000

	// PIOPORCAP1: POR captured PIO status 1
	// Position of CAPPIO2_8 field.
	SYSCON_PIOPORCAP1_CAPPIO2_8_Pos = 0x0
	// Bit mask of CAPPIO2_8 field.
	SYSCON_PIOPORCAP1_CAPPIO2_8_Msk = 0x1
	// Bit CAPPIO2_8.
	SYSCON_PIOPORCAP1_CAPPIO2_8 = 0x1
	// Position of CAPPIO2_9 field.
	SYSCON_PIOPORCAP1_CAPPIO2_9_Pos = 0x1
	// Bit mask of CAPPIO2_9 field.
	SYSCON_PIOPORCAP1_CAPPIO2_9_Msk = 0x2
	// Bit CAPPIO2_9.
	SYSCON_PIOPORCAP1_CAPPIO2_9 = 0x2
	// Position of CAPPIO2_10 field.
	SYSCON_PIOPORCAP1_CAPPIO2_10_Pos = 0x2
	// Bit mask of CAPPIO2_10 field.
	SYSCON_PIOPORCAP1_CAPPIO2_10_Msk = 0x4
	// Bit CAPPIO2_10.
	SYSCON_PIOPORCAP1_CAPPIO2_10 = 0x4
	// Position of CAPPIO2_11 field.
	SYSCON_PIOPORCAP1_CAPPIO2_11_Pos = 0x3
	// Bit mask of CAPPIO2_11 field.
	SYSCON_PIOPORCAP1_CAPPIO2_11_Msk = 0x8
	// Bit CAPPIO2_11.
	SYSCON_PIOPORCAP1_CAPPIO2_11 = 0x8
	// Position of CAPPIO3_0 field.
	SYSCON_PIOPORCAP1_CAPPIO3_0_Pos = 0x4
	// Bit mask of CAPPIO3_0 field.
	SYSCON_PIOPORCAP1_CAPPIO3_0_Msk = 0x10
	// Bit CAPPIO3_0.
	SYSCON_PIOPORCAP1_CAPPIO3_0 = 0x10
	// Position of CAPPIO3_1 field.
	SYSCON_PIOPORCAP1_CAPPIO3_1_Pos = 0x5
	// Bit mask of CAPPIO3_1 field.
	SYSCON_PIOPORCAP1_CAPPIO3_1_Msk = 0x20
	// Bit CAPPIO3_1.
	SYSCON_PIOPORCAP1_CAPPIO3_1 = 0x20
	// Position of CAPPIO3_2 field.
	SYSCON_PIOPORCAP1_CAPPIO3_2_Pos = 0x6
	// Bit mask of CAPPIO3_2 field.
	SYSCON_PIOPORCAP1_CAPPIO3_2_Msk = 0x40
	// Bit CAPPIO3_2.
	SYSCON_PIOPORCAP1_CAPPIO3_2 = 0x40
	// Position of CAPPIO3_3 field.
	SYSCON_PIOPORCAP1_CAPPIO3_3_Pos = 0x7
	// Bit mask of CAPPIO3_3 field.
	SYSCON_PIOPORCAP1_CAPPIO3_3_Msk = 0x80
	// Bit CAPPIO3_3.
	SYSCON_PIOPORCAP1_CAPPIO3_3 = 0x80
	// Position of CAPPIO3_4 field.
	SYSCON_PIOPORCAP1_CAPPIO3_4_Pos = 0x8
	// Bit mask of CAPPIO3_4 field.
	SYSCON_PIOPORCAP1_CAPPIO3_4_Msk = 0x100
	// Bit CAPPIO3_4.
	SYSCON_PIOPORCAP1_CAPPIO3_4 = 0x100
	// Position of CAPPIO3_5 field.
	SYSCON_PIOPORCAP1_CAPPIO3_5_Pos = 0x9
	// Bit mask of CAPPIO3_5 field.
	SYSCON_PIOPORCAP1_CAPPIO3_5_Msk = 0x200
	// Bit CAPPIO3_5.
	SYSCON_PIOPORCAP1_CAPPIO3_5 = 0x200
	// Position of RESERVED field.
	SYSCON_PIOPORCAP1_RESERVED_Pos = 0xa
	// Bit mask of RESERVED field.
	SYSCON_PIOPORCAP1_RESERVED_Msk = 0xfffffc00

	// BODCTRL: BOD control
	// Position of BODRSTLEV field.
	SYSCON_BODCTRL_BODRSTLEV_Pos = 0x0
	// Bit mask of BODRSTLEV field.
	SYSCON_BODCTRL_BODRSTLEV_Msk = 0x3
	// Level 0: The reset assertion threshold voltage is 1.46 V; the reset de-assertion threshold voltage is 1.63 V.
	SYSCON_BODCTRL_BODRSTLEV_LEVEL_0_THE_RESET_A = 0x0
	// Level 1: The reset assertion threshold voltage is 2.06 V; the reset de-assertion threshold voltage is 2.15 V.
	SYSCON_BODCTRL_BODRSTLEV_LEVEL_1_THE_RESET_A = 0x1
	// Level 2: The reset assertion threshold voltage is 2.35 V; the reset de-assertion threshold voltage is 2.43 V.
	SYSCON_BODCTRL_BODRSTLEV_LEVEL_2_THE_RESET_A = 0x2
	// Level 3: The reset assertion threshold voltage is 2.63 V; the reset de-assertion threshold voltage is 2.71 V.
	SYSCON_BODCTRL_BODRSTLEV_LEVEL_3_THE_RESET_A = 0x3
	// Position of BODINTVAL field.
	SYSCON_BODCTRL_BODINTVAL_Pos = 0x2
	// Bit mask of BODINTVAL field.
	SYSCON_BODCTRL_BODINTVAL_Msk = 0xc
	// Level 0: The interrupt assertion threshold voltage is 1.65 V; the interrupt de-assertion threshold voltage is 1.80 V.
	SYSCON_BODCTRL_BODINTVAL_LEVEL_0_THE_INTERRU = 0x0
	// Level 1:The interrupt assertion threshold voltage is 2.22 V; the interrupt de-assertion threshold voltage is 2.35 V.
	SYSCON_BODCTRL_BODINTVAL_LEVEL_1THE_INTERRUP = 0x1
	// Level 2: The interrupt assertion threshold voltage is 2.52 V; the interrupt de-assertion threshold voltage is 2.66 V.
	SYSCON_BODCTRL_BODINTVAL_LEVEL_2_THE_INTERRU = 0x2
	// Level 3: The interrupt assertion threshold voltage is 2.80 V; the interrupt de-assertion threshold voltage is 2.90 V.
	SYSCON_BODCTRL_BODINTVAL_LEVEL_3_THE_INTERRU = 0x3
	// Position of BODRSTENA field.
	SYSCON_BODCTRL_BODRSTENA_Pos = 0x4
	// Bit mask of BODRSTENA field.
	SYSCON_BODCTRL_BODRSTENA_Msk = 0x10
	// Bit BODRSTENA.
	SYSCON_BODCTRL_BODRSTENA = 0x10
	// Disable reset function.
	SYSCON_BODCTRL_BODRSTENA_DISABLE_RESET_FUNCTI = 0x0
	// Enable reset function.
	SYSCON_BODCTRL_BODRSTENA_ENABLE_RESET_FUNCTIO = 0x1
	// Position of RESERVED field.
	SYSCON_BODCTRL_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	SYSCON_BODCTRL_RESERVED_Msk = 0xffffffe0

	// SYSTCKCAL: System tick counter calibration
	// Position of CAL field.
	SYSCON_SYSTCKCAL_CAL_Pos = 0x0
	// Bit mask of CAL field.
	SYSCON_SYSTCKCAL_CAL_Msk = 0x3ffffff
	// Position of RESERVED field.
	SYSCON_SYSTCKCAL_RESERVED_Pos = 0x1a
	// Bit mask of RESERVED field.
	SYSCON_SYSTCKCAL_RESERVED_Msk = 0xfc000000

	// NMISRC: NMI source selection
	// Position of IRQNO field.
	SYSCON_NMISRC_IRQNO_Pos = 0x0
	// Bit mask of IRQNO field.
	SYSCON_NMISRC_IRQNO_Msk = 0x1f
	// Position of RESERVED field.
	SYSCON_NMISRC_RESERVED_Pos = 0x5
	// Bit mask of RESERVED field.
	SYSCON_NMISRC_RESERVED_Msk = 0x7fffffe0
	// Position of NMIEN field.
	SYSCON_NMISRC_NMIEN_Pos = 0x1f
	// Bit mask of NMIEN field.
	SYSCON_NMISRC_NMIEN_Msk = 0x80000000
	// Bit NMIEN.
	SYSCON_NMISRC_NMIEN = 0x80000000

	// STARTAPRP0: Start logic edge control register 0
	// Position of APRPIO0_0 field.
	SYSCON_STARTAPRP0_APRPIO0_0_Pos = 0x0
	// Bit mask of APRPIO0_0 field.
	SYSCON_STARTAPRP0_APRPIO0_0_Msk = 0x1
	// Bit APRPIO0_0.
	SYSCON_STARTAPRP0_APRPIO0_0 = 0x1
	// Position of APRPIO0_1 field.
	SYSCON_STARTAPRP0_APRPIO0_1_Pos = 0x1
	// Bit mask of APRPIO0_1 field.
	SYSCON_STARTAPRP0_APRPIO0_1_Msk = 0x2
	// Bit APRPIO0_1.
	SYSCON_STARTAPRP0_APRPIO0_1 = 0x2
	// Position of APRPIO0_2 field.
	SYSCON_STARTAPRP0_APRPIO0_2_Pos = 0x2
	// Bit mask of APRPIO0_2 field.
	SYSCON_STARTAPRP0_APRPIO0_2_Msk = 0x4
	// Bit APRPIO0_2.
	SYSCON_STARTAPRP0_APRPIO0_2 = 0x4
	// Position of APRPIO0_3 field.
	SYSCON_STARTAPRP0_APRPIO0_3_Pos = 0x3
	// Bit mask of APRPIO0_3 field.
	SYSCON_STARTAPRP0_APRPIO0_3_Msk = 0x8
	// Bit APRPIO0_3.
	SYSCON_STARTAPRP0_APRPIO0_3 = 0x8
	// Position of APRPIO0_4 field.
	SYSCON_STARTAPRP0_APRPIO0_4_Pos = 0x4
	// Bit mask of APRPIO0_4 field.
	SYSCON_STARTAPRP0_APRPIO0_4_Msk = 0x10
	// Bit APRPIO0_4.
	SYSCON_STARTAPRP0_APRPIO0_4 = 0x10
	// Position of APRPIO0_5 field.
	SYSCON_STARTAPRP0_APRPIO0_5_Pos = 0x5
	// Bit mask of APRPIO0_5 field.
	SYSCON_STARTAPRP0_APRPIO0_5_Msk = 0x20
	// Bit APRPIO0_5.
	SYSCON_STARTAPRP0_APRPIO0_5 = 0x20
	// Position of APRPIO0_6 field.
	SYSCON_STARTAPRP0_APRPIO0_6_Pos = 0x6
	// Bit mask of APRPIO0_6 field.
	SYSCON_STARTAPRP0_APRPIO0_6_Msk = 0x40
	// Bit APRPIO0_6.
	SYSCON_STARTAPRP0_APRPIO0_6 = 0x40
	// Position of APRPIO0_7 field.
	SYSCON_STARTAPRP0_APRPIO0_7_Pos = 0x7
	// Bit mask of APRPIO0_7 field.
	SYSCON_STARTAPRP0_APRPIO0_7_Msk = 0x80
	// Bit APRPIO0_7.
	SYSCON_STARTAPRP0_APRPIO0_7 = 0x80
	// Position of APRPIO0_8 field.
	SYSCON_STARTAPRP0_APRPIO0_8_Pos = 0x8
	// Bit mask of APRPIO0_8 field.
	SYSCON_STARTAPRP0_APRPIO0_8_Msk = 0x100
	// Bit APRPIO0_8.
	SYSCON_STARTAPRP0_APRPIO0_8 = 0x100
	// Position of APRPIO0_9 field.
	SYSCON_STARTAPRP0_APRPIO0_9_Pos = 0x9
	// Bit mask of APRPIO0_9 field.
	SYSCON_STARTAPRP0_APRPIO0_9_Msk = 0x200
	// Bit APRPIO0_9.
	SYSCON_STARTAPRP0_APRPIO0_9 = 0x200
	// Position of APRPIO0_10 field.
	SYSCON_STARTAPRP0_APRPIO0_10_Pos = 0xa
	// Bit mask of APRPIO0_10 field.
	SYSCON_STARTAPRP0_APRPIO0_10_Msk = 0x400
	// Bit APRPIO0_10.
	SYSCON_STARTAPRP0_APRPIO0_10 = 0x400
	// Position of APRPIO0_11 field.
	SYSCON_STARTAPRP0_APRPIO0_11_Pos = 0xb
	// Bit mask of APRPIO0_11 field.
	SYSCON_STARTAPRP0_APRPIO0_11_Msk = 0x800
	// Bit APRPIO0_11.
	SYSCON_STARTAPRP0_APRPIO0_11 = 0x800
	// Position of APRPIO1_0 field.
	SYSCON_STARTAPRP0_APRPIO1_0_Pos = 0xc
	// Bit mask of APRPIO1_0 field.
	SYSCON_STARTAPRP0_APRPIO1_0_Msk = 0x1000
	// Bit APRPIO1_0.
	SYSCON_STARTAPRP0_APRPIO1_0 = 0x1000
	// Position of RESERVED field.
	SYSCON_STARTAPRP0_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	SYSCON_STARTAPRP0_RESERVED_Msk = 0xffffe000

	// STARTERP0: Start logic signal enable register 0
	// Position of ERPIO0_0 field.
	SYSCON_STARTERP0_ERPIO0_0_Pos = 0x0
	// Bit mask of ERPIO0_0 field.
	SYSCON_STARTERP0_ERPIO0_0_Msk = 0x1
	// Bit ERPIO0_0.
	SYSCON_STARTERP0_ERPIO0_0 = 0x1
	// Position of ERPIO0_1 field.
	SYSCON_STARTERP0_ERPIO0_1_Pos = 0x1
	// Bit mask of ERPIO0_1 field.
	SYSCON_STARTERP0_ERPIO0_1_Msk = 0x2
	// Bit ERPIO0_1.
	SYSCON_STARTERP0_ERPIO0_1 = 0x2
	// Position of ERPIO0_2 field.
	SYSCON_STARTERP0_ERPIO0_2_Pos = 0x2
	// Bit mask of ERPIO0_2 field.
	SYSCON_STARTERP0_ERPIO0_2_Msk = 0x4
	// Bit ERPIO0_2.
	SYSCON_STARTERP0_ERPIO0_2 = 0x4
	// Position of ERPIO0_3 field.
	SYSCON_STARTERP0_ERPIO0_3_Pos = 0x3
	// Bit mask of ERPIO0_3 field.
	SYSCON_STARTERP0_ERPIO0_3_Msk = 0x8
	// Bit ERPIO0_3.
	SYSCON_STARTERP0_ERPIO0_3 = 0x8
	// Position of ERPIO0_4 field.
	SYSCON_STARTERP0_ERPIO0_4_Pos = 0x4
	// Bit mask of ERPIO0_4 field.
	SYSCON_STARTERP0_ERPIO0_4_Msk = 0x10
	// Bit ERPIO0_4.
	SYSCON_STARTERP0_ERPIO0_4 = 0x10
	// Position of ERPIO0_5 field.
	SYSCON_STARTERP0_ERPIO0_5_Pos = 0x5
	// Bit mask of ERPIO0_5 field.
	SYSCON_STARTERP0_ERPIO0_5_Msk = 0x20
	// Bit ERPIO0_5.
	SYSCON_STARTERP0_ERPIO0_5 = 0x20
	// Position of ERPIO0_6 field.
	SYSCON_STARTERP0_ERPIO0_6_Pos = 0x6
	// Bit mask of ERPIO0_6 field.
	SYSCON_STARTERP0_ERPIO0_6_Msk = 0x40
	// Bit ERPIO0_6.
	SYSCON_STARTERP0_ERPIO0_6 = 0x40
	// Position of ERPIO0_7 field.
	SYSCON_STARTERP0_ERPIO0_7_Pos = 0x7
	// Bit mask of ERPIO0_7 field.
	SYSCON_STARTERP0_ERPIO0_7_Msk = 0x80
	// Bit ERPIO0_7.
	SYSCON_STARTERP0_ERPIO0_7 = 0x80
	// Position of ERPIO0_8 field.
	SYSCON_STARTERP0_ERPIO0_8_Pos = 0x8
	// Bit mask of ERPIO0_8 field.
	SYSCON_STARTERP0_ERPIO0_8_Msk = 0x100
	// Bit ERPIO0_8.
	SYSCON_STARTERP0_ERPIO0_8 = 0x100
	// Position of ERPIO0_9 field.
	SYSCON_STARTERP0_ERPIO0_9_Pos = 0x9
	// Bit mask of ERPIO0_9 field.
	SYSCON_STARTERP0_ERPIO0_9_Msk = 0x200
	// Bit ERPIO0_9.
	SYSCON_STARTERP0_ERPIO0_9 = 0x200
	// Position of ERPIO0_10 field.
	SYSCON_STARTERP0_ERPIO0_10_Pos = 0xa
	// Bit mask of ERPIO0_10 field.
	SYSCON_STARTERP0_ERPIO0_10_Msk = 0x400
	// Bit ERPIO0_10.
	SYSCON_STARTERP0_ERPIO0_10 = 0x400
	// Position of ERPIO0_11 field.
	SYSCON_STARTERP0_ERPIO0_11_Pos = 0xb
	// Bit mask of ERPIO0_11 field.
	SYSCON_STARTERP0_ERPIO0_11_Msk = 0x800
	// Bit ERPIO0_11.
	SYSCON_STARTERP0_ERPIO0_11 = 0x800
	// Position of ERPIO1_0 field.
	SYSCON_STARTERP0_ERPIO1_0_Pos = 0xc
	// Bit mask of ERPIO1_0 field.
	SYSCON_STARTERP0_ERPIO1_0_Msk = 0x1000
	// Bit ERPIO1_0.
	SYSCON_STARTERP0_ERPIO1_0 = 0x1000
	// Position of RESERVED field.
	SYSCON_STARTERP0_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	SYSCON_STARTERP0_RESERVED_Msk = 0xffffe000

	// STARTRSRP0CLR: Start logic reset register 0
	// Position of RSRPIO0_0 field.
	SYSCON_STARTRSRP0CLR_RSRPIO0_0_Pos = 0x0
	// Bit mask of RSRPIO0_0 field.
	SYSCON_STARTRSRP0CLR_RSRPIO0_0_Msk = 0x1
	// Bit RSRPIO0_0.
	SYSCON_STARTRSRP0CLR_RSRPIO0_0 = 0x1
	// Position of RSRPIO0_1 field.
	SYSCON_STARTRSRP0CLR_RSRPIO0_1_Pos = 0x1
	// Bit mask of RSRPIO0_1 field.
	SYSCON_STARTRSRP0CLR_RSRPIO0_1_Msk = 0x2
	// Bit RSRPIO0_1.
	SYSCON_STARTRSRP0CLR_RSRPIO0_1 = 0x2
	// Position of RSRPIO0_2 field.
	SYSCON_STARTRSRP0CLR_RSRPIO0_2_Pos = 0x2
	// Bit mask of RSRPIO0_2 field.
	SYSCON_STARTRSRP0CLR_RSRPIO0_2_Msk = 0x4
	// Bit RSRPIO0_2.
	SYSCON_STARTRSRP0CLR_RSRPIO0_2 = 0x4
	// Position of RSRPIO0_3 field.
	SYSCON_STARTRSRP0CLR_RSRPIO0_3_Pos = 0x3
	// Bit mask of RSRPIO0_3 field.
	SYSCON_STARTRSRP0CLR_RSRPIO0_3_Msk = 0x8
	// Bit RSRPIO0_3.
	SYSCON_STARTRSRP0CLR_RSRPIO0_3 = 0x8
	// Position of RSRPIO0_4 field.
	SYSCON_STARTRSRP0CLR_RSRPIO0_4_Pos = 0x4
	// Bit mask of RSRPIO0_4 field.
	SYSCON_STARTRSRP0CLR_RSRPIO0_4_Msk = 0x10
	// Bit RSRPIO0_4.
	SYSCON_STARTRSRP0CLR_RSRPIO0_4 = 0x10
	// Position of RSRPIO0_5 field.
	SYSCON_STARTRSRP0CLR_RSRPIO0_5_Pos = 0x5
	// Bit mask of RSRPIO0_5 field.
	SYSCON_STARTRSRP0CLR_RSRPIO0_5_Msk = 0x20
	// Bit RSRPIO0_5.
	SYSCON_STARTRSRP0CLR_RSRPIO0_5 = 0x20
	// Position of RSRPIO0_6 field.
	SYSCON_STARTRSRP0CLR_RSRPIO0_6_Pos = 0x6
	// Bit mask of RSRPIO0_6 field.
	SYSCON_STARTRSRP0CLR_RSRPIO0_6_Msk = 0x40
	// Bit RSRPIO0_6.
	SYSCON_STARTRSRP0CLR_RSRPIO0_6 = 0x40
	// Position of RSRPIO0_7 field.
	SYSCON_STARTRSRP0CLR_RSRPIO0_7_Pos = 0x7
	// Bit mask of RSRPIO0_7 field.
	SYSCON_STARTRSRP0CLR_RSRPIO0_7_Msk = 0x80
	// Bit RSRPIO0_7.
	SYSCON_STARTRSRP0CLR_RSRPIO0_7 = 0x80
	// Position of RSRPIO0_8 field.
	SYSCON_STARTRSRP0CLR_RSRPIO0_8_Pos = 0x8
	// Bit mask of RSRPIO0_8 field.
	SYSCON_STARTRSRP0CLR_RSRPIO0_8_Msk = 0x100
	// Bit RSRPIO0_8.
	SYSCON_STARTRSRP0CLR_RSRPIO0_8 = 0x100
	// Position of RSRPIO0_9 field.
	SYSCON_STARTRSRP0CLR_RSRPIO0_9_Pos = 0x9
	// Bit mask of RSRPIO0_9 field.
	SYSCON_STARTRSRP0CLR_RSRPIO0_9_Msk = 0x200
	// Bit RSRPIO0_9.
	SYSCON_STARTRSRP0CLR_RSRPIO0_9 = 0x200
	// Position of RSRPIO0_10 field.
	SYSCON_STARTRSRP0CLR_RSRPIO0_10_Pos = 0xa
	// Bit mask of RSRPIO0_10 field.
	SYSCON_STARTRSRP0CLR_RSRPIO0_10_Msk = 0x400
	// Bit RSRPIO0_10.
	SYSCON_STARTRSRP0CLR_RSRPIO0_10 = 0x400
	// Position of RSRPIO0_11 field.
	SYSCON_STARTRSRP0CLR_RSRPIO0_11_Pos = 0xb
	// Bit mask of RSRPIO0_11 field.
	SYSCON_STARTRSRP0CLR_RSRPIO0_11_Msk = 0x800
	// Bit RSRPIO0_11.
	SYSCON_STARTRSRP0CLR_RSRPIO0_11 = 0x800
	// Position of RSRPIO1_0 field.
	SYSCON_STARTRSRP0CLR_RSRPIO1_0_Pos = 0xc
	// Bit mask of RSRPIO1_0 field.
	SYSCON_STARTRSRP0CLR_RSRPIO1_0_Msk = 0x1000
	// Bit RSRPIO1_0.
	SYSCON_STARTRSRP0CLR_RSRPIO1_0 = 0x1000
	// Position of RESERVED field.
	SYSCON_STARTRSRP0CLR_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	SYSCON_STARTRSRP0CLR_RESERVED_Msk = 0xffffe000

	// STARTSRP0: Start logic status register 0
	// Position of SRPIO0_0 field.
	SYSCON_STARTSRP0_SRPIO0_0_Pos = 0x0
	// Bit mask of SRPIO0_0 field.
	SYSCON_STARTSRP0_SRPIO0_0_Msk = 0x1
	// Bit SRPIO0_0.
	SYSCON_STARTSRP0_SRPIO0_0 = 0x1
	// Position of SRPIO0_1 field.
	SYSCON_STARTSRP0_SRPIO0_1_Pos = 0x1
	// Bit mask of SRPIO0_1 field.
	SYSCON_STARTSRP0_SRPIO0_1_Msk = 0x2
	// Bit SRPIO0_1.
	SYSCON_STARTSRP0_SRPIO0_1 = 0x2
	// Position of SRPIO0_2 field.
	SYSCON_STARTSRP0_SRPIO0_2_Pos = 0x2
	// Bit mask of SRPIO0_2 field.
	SYSCON_STARTSRP0_SRPIO0_2_Msk = 0x4
	// Bit SRPIO0_2.
	SYSCON_STARTSRP0_SRPIO0_2 = 0x4
	// Position of SRPIO0_3 field.
	SYSCON_STARTSRP0_SRPIO0_3_Pos = 0x3
	// Bit mask of SRPIO0_3 field.
	SYSCON_STARTSRP0_SRPIO0_3_Msk = 0x8
	// Bit SRPIO0_3.
	SYSCON_STARTSRP0_SRPIO0_3 = 0x8
	// Position of SRPIO0_4 field.
	SYSCON_STARTSRP0_SRPIO0_4_Pos = 0x4
	// Bit mask of SRPIO0_4 field.
	SYSCON_STARTSRP0_SRPIO0_4_Msk = 0x10
	// Bit SRPIO0_4.
	SYSCON_STARTSRP0_SRPIO0_4 = 0x10
	// Position of SRPIO0_5 field.
	SYSCON_STARTSRP0_SRPIO0_5_Pos = 0x5
	// Bit mask of SRPIO0_5 field.
	SYSCON_STARTSRP0_SRPIO0_5_Msk = 0x20
	// Bit SRPIO0_5.
	SYSCON_STARTSRP0_SRPIO0_5 = 0x20
	// Position of SRPIO0_6 field.
	SYSCON_STARTSRP0_SRPIO0_6_Pos = 0x6
	// Bit mask of SRPIO0_6 field.
	SYSCON_STARTSRP0_SRPIO0_6_Msk = 0x40
	// Bit SRPIO0_6.
	SYSCON_STARTSRP0_SRPIO0_6 = 0x40
	// Position of SRPIO0_7 field.
	SYSCON_STARTSRP0_SRPIO0_7_Pos = 0x7
	// Bit mask of SRPIO0_7 field.
	SYSCON_STARTSRP0_SRPIO0_7_Msk = 0x80
	// Bit SRPIO0_7.
	SYSCON_STARTSRP0_SRPIO0_7 = 0x80
	// Position of SRPIO0_8 field.
	SYSCON_STARTSRP0_SRPIO0_8_Pos = 0x8
	// Bit mask of SRPIO0_8 field.
	SYSCON_STARTSRP0_SRPIO0_8_Msk = 0x100
	// Bit SRPIO0_8.
	SYSCON_STARTSRP0_SRPIO0_8 = 0x100
	// Position of SRPIO0_9 field.
	SYSCON_STARTSRP0_SRPIO0_9_Pos = 0x9
	// Bit mask of SRPIO0_9 field.
	SYSCON_STARTSRP0_SRPIO0_9_Msk = 0x200
	// Bit SRPIO0_9.
	SYSCON_STARTSRP0_SRPIO0_9 = 0x200
	// Position of SRPIO0_10 field.
	SYSCON_STARTSRP0_SRPIO0_10_Pos = 0xa
	// Bit mask of SRPIO0_10 field.
	SYSCON_STARTSRP0_SRPIO0_10_Msk = 0x400
	// Bit SRPIO0_10.
	SYSCON_STARTSRP0_SRPIO0_10 = 0x400
	// Position of SRPIO0_11 field.
	SYSCON_STARTSRP0_SRPIO0_11_Pos = 0xb
	// Bit mask of SRPIO0_11 field.
	SYSCON_STARTSRP0_SRPIO0_11_Msk = 0x800
	// Bit SRPIO0_11.
	SYSCON_STARTSRP0_SRPIO0_11 = 0x800
	// Position of SRPIO1_0 field.
	SYSCON_STARTSRP0_SRPIO1_0_Pos = 0xc
	// Bit mask of SRPIO1_0 field.
	SYSCON_STARTSRP0_SRPIO1_0_Msk = 0x1000
	// Bit SRPIO1_0.
	SYSCON_STARTSRP0_SRPIO1_0 = 0x1000
	// Position of RESERVED field.
	SYSCON_STARTSRP0_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	SYSCON_STARTSRP0_RESERVED_Msk = 0xffffe000

	// PDSLEEPCFG: Power-down states in Deep-sleep mode
	// Position of NOTUSED0 field.
	SYSCON_PDSLEEPCFG_NOTUSED0_Pos = 0x0
	// Bit mask of NOTUSED0 field.
	SYSCON_PDSLEEPCFG_NOTUSED0_Msk = 0x7
	// Position of BOD_PD field.
	SYSCON_PDSLEEPCFG_BOD_PD_Pos = 0x3
	// Bit mask of BOD_PD field.
	SYSCON_PDSLEEPCFG_BOD_PD_Msk = 0x8
	// Bit BOD_PD.
	SYSCON_PDSLEEPCFG_BOD_PD = 0x8
	// Powered
	SYSCON_PDSLEEPCFG_BOD_PD_POWERED = 0x0
	// Powered down
	SYSCON_PDSLEEPCFG_BOD_PD_POWERED_DOWN = 0x1
	// Position of NOTUSED1 field.
	SYSCON_PDSLEEPCFG_NOTUSED1_Pos = 0x4
	// Bit mask of NOTUSED1 field.
	SYSCON_PDSLEEPCFG_NOTUSED1_Msk = 0x30
	// Position of WDTOSC_PD field.
	SYSCON_PDSLEEPCFG_WDTOSC_PD_Pos = 0x6
	// Bit mask of WDTOSC_PD field.
	SYSCON_PDSLEEPCFG_WDTOSC_PD_Msk = 0x40
	// Bit WDTOSC_PD.
	SYSCON_PDSLEEPCFG_WDTOSC_PD = 0x40
	// Powered
	SYSCON_PDSLEEPCFG_WDTOSC_PD_POWERED = 0x0
	// Powered down
	SYSCON_PDSLEEPCFG_WDTOSC_PD_POWERED_DOWN = 0x1
	// Position of NOTUSED2 field.
	SYSCON_PDSLEEPCFG_NOTUSED2_Pos = 0x7
	// Bit mask of NOTUSED2 field.
	SYSCON_PDSLEEPCFG_NOTUSED2_Msk = 0x80
	// Bit NOTUSED2.
	SYSCON_PDSLEEPCFG_NOTUSED2 = 0x80
	// Position of NOTUSED3 field.
	SYSCON_PDSLEEPCFG_NOTUSED3_Pos = 0x8
	// Bit mask of NOTUSED3 field.
	SYSCON_PDSLEEPCFG_NOTUSED3_Msk = 0x700
	// Position of NOTUSED4 field.
	SYSCON_PDSLEEPCFG_NOTUSED4_Pos = 0xb
	// Bit mask of NOTUSED4 field.
	SYSCON_PDSLEEPCFG_NOTUSED4_Msk = 0x1800
	// Position of RESERVED field.
	SYSCON_PDSLEEPCFG_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	SYSCON_PDSLEEPCFG_RESERVED_Msk = 0xffffe000

	// PDAWAKECFG: Power-down states after wake-up from Deep-sleep mode
	// Position of IRCOUT_PD field.
	SYSCON_PDAWAKECFG_IRCOUT_PD_Pos = 0x0
	// Bit mask of IRCOUT_PD field.
	SYSCON_PDAWAKECFG_IRCOUT_PD_Msk = 0x1
	// Bit IRCOUT_PD.
	SYSCON_PDAWAKECFG_IRCOUT_PD = 0x1
	// Powered
	SYSCON_PDAWAKECFG_IRCOUT_PD_POWERED = 0x0
	// Powered down
	SYSCON_PDAWAKECFG_IRCOUT_PD_POWERED_DOWN = 0x1
	// Position of IRC_PD field.
	SYSCON_PDAWAKECFG_IRC_PD_Pos = 0x1
	// Bit mask of IRC_PD field.
	SYSCON_PDAWAKECFG_IRC_PD_Msk = 0x2
	// Bit IRC_PD.
	SYSCON_PDAWAKECFG_IRC_PD = 0x2
	// Powered
	SYSCON_PDAWAKECFG_IRC_PD_POWERED = 0x0
	// Powered down
	SYSCON_PDAWAKECFG_IRC_PD_POWERED_DOWN = 0x1
	// Position of FLASH_PD field.
	SYSCON_PDAWAKECFG_FLASH_PD_Pos = 0x2
	// Bit mask of FLASH_PD field.
	SYSCON_PDAWAKECFG_FLASH_PD_Msk = 0x4
	// Bit FLASH_PD.
	SYSCON_PDAWAKECFG_FLASH_PD = 0x4
	// Powered
	SYSCON_PDAWAKECFG_FLASH_PD_POWERED = 0x0
	// Powered down
	SYSCON_PDAWAKECFG_FLASH_PD_POWERED_DOWN = 0x1
	// Position of BOD_PD field.
	SYSCON_PDAWAKECFG_BOD_PD_Pos = 0x3
	// Bit mask of BOD_PD field.
	SYSCON_PDAWAKECFG_BOD_PD_Msk = 0x8
	// Bit BOD_PD.
	SYSCON_PDAWAKECFG_BOD_PD = 0x8
	// Powered
	SYSCON_PDAWAKECFG_BOD_PD_POWERED = 0x0
	// Powered down
	SYSCON_PDAWAKECFG_BOD_PD_POWERED_DOWN = 0x1
	// Position of ADC_PD field.
	SYSCON_PDAWAKECFG_ADC_PD_Pos = 0x4
	// Bit mask of ADC_PD field.
	SYSCON_PDAWAKECFG_ADC_PD_Msk = 0x10
	// Bit ADC_PD.
	SYSCON_PDAWAKECFG_ADC_PD = 0x10
	// Powered
	SYSCON_PDAWAKECFG_ADC_PD_POWERED = 0x0
	// Powered down
	SYSCON_PDAWAKECFG_ADC_PD_POWERED_DOWN = 0x1
	// Position of SYSOSC_PD field.
	SYSCON_PDAWAKECFG_SYSOSC_PD_Pos = 0x5
	// Bit mask of SYSOSC_PD field.
	SYSCON_PDAWAKECFG_SYSOSC_PD_Msk = 0x20
	// Bit SYSOSC_PD.
	SYSCON_PDAWAKECFG_SYSOSC_PD = 0x20
	// Powered
	SYSCON_PDAWAKECFG_SYSOSC_PD_POWERED = 0x0
	// Powered down
	SYSCON_PDAWAKECFG_SYSOSC_PD_POWERED_DOWN = 0x1
	// Position of WDTOSC_PD field.
	SYSCON_PDAWAKECFG_WDTOSC_PD_Pos = 0x6
	// Bit mask of WDTOSC_PD field.
	SYSCON_PDAWAKECFG_WDTOSC_PD_Msk = 0x40
	// Bit WDTOSC_PD.
	SYSCON_PDAWAKECFG_WDTOSC_PD = 0x40
	// Powered
	SYSCON_PDAWAKECFG_WDTOSC_PD_POWERED = 0x0
	// Powered down
	SYSCON_PDAWAKECFG_WDTOSC_PD_POWERED_DOWN = 0x1
	// Position of SYSPLL_PD field.
	SYSCON_PDAWAKECFG_SYSPLL_PD_Pos = 0x7
	// Bit mask of SYSPLL_PD field.
	SYSCON_PDAWAKECFG_SYSPLL_PD_Msk = 0x80
	// Bit SYSPLL_PD.
	SYSCON_PDAWAKECFG_SYSPLL_PD = 0x80
	// Powered
	SYSCON_PDAWAKECFG_SYSPLL_PD_POWERED = 0x0
	// Powered down
	SYSCON_PDAWAKECFG_SYSPLL_PD_POWERED_DOWN = 0x1
	// Position of NOTUSED0 field.
	SYSCON_PDAWAKECFG_NOTUSED0_Pos = 0x8
	// Bit mask of NOTUSED0 field.
	SYSCON_PDAWAKECFG_NOTUSED0_Msk = 0x100
	// Bit NOTUSED0.
	SYSCON_PDAWAKECFG_NOTUSED0 = 0x100
	// Position of NOTUSED1 field.
	SYSCON_PDAWAKECFG_NOTUSED1_Pos = 0x9
	// Bit mask of NOTUSED1 field.
	SYSCON_PDAWAKECFG_NOTUSED1_Msk = 0x200
	// Bit NOTUSED1.
	SYSCON_PDAWAKECFG_NOTUSED1 = 0x200
	// Position of NOTUSED2 field.
	SYSCON_PDAWAKECFG_NOTUSED2_Pos = 0xa
	// Bit mask of NOTUSED2 field.
	SYSCON_PDAWAKECFG_NOTUSED2_Msk = 0x400
	// Bit NOTUSED2.
	SYSCON_PDAWAKECFG_NOTUSED2 = 0x400
	// Position of NOTUSED3 field.
	SYSCON_PDAWAKECFG_NOTUSED3_Pos = 0xb
	// Bit mask of NOTUSED3 field.
	SYSCON_PDAWAKECFG_NOTUSED3_Msk = 0x800
	// Bit NOTUSED3.
	SYSCON_PDAWAKECFG_NOTUSED3 = 0x800
	// Position of NOTUSED4 field.
	SYSCON_PDAWAKECFG_NOTUSED4_Pos = 0xc
	// Bit mask of NOTUSED4 field.
	SYSCON_PDAWAKECFG_NOTUSED4_Msk = 0x1000
	// Bit NOTUSED4.
	SYSCON_PDAWAKECFG_NOTUSED4 = 0x1000
	// Position of NOTUSED5 field.
	SYSCON_PDAWAKECFG_NOTUSED5_Pos = 0xd
	// Bit mask of NOTUSED5 field.
	SYSCON_PDAWAKECFG_NOTUSED5_Msk = 0xe000
	// Position of RESERVED field.
	SYSCON_PDAWAKECFG_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	SYSCON_PDAWAKECFG_RESERVED_Msk = 0xffff0000

	// PDRUNCFG: Power-down configuration register
	// Position of IRCOUT_PD field.
	SYSCON_PDRUNCFG_IRCOUT_PD_Pos = 0x0
	// Bit mask of IRCOUT_PD field.
	SYSCON_PDRUNCFG_IRCOUT_PD_Msk = 0x1
	// Bit IRCOUT_PD.
	SYSCON_PDRUNCFG_IRCOUT_PD = 0x1
	// Powered
	SYSCON_PDRUNCFG_IRCOUT_PD_POWERED = 0x0
	// Powered down
	SYSCON_PDRUNCFG_IRCOUT_PD_POWERED_DOWN = 0x1
	// Position of IRC_PD field.
	SYSCON_PDRUNCFG_IRC_PD_Pos = 0x1
	// Bit mask of IRC_PD field.
	SYSCON_PDRUNCFG_IRC_PD_Msk = 0x2
	// Bit IRC_PD.
	SYSCON_PDRUNCFG_IRC_PD = 0x2
	// Powered
	SYSCON_PDRUNCFG_IRC_PD_POWERED = 0x0
	// Powered down
	SYSCON_PDRUNCFG_IRC_PD_POWERED_DOWN = 0x1
	// Position of FLASH_PD field.
	SYSCON_PDRUNCFG_FLASH_PD_Pos = 0x2
	// Bit mask of FLASH_PD field.
	SYSCON_PDRUNCFG_FLASH_PD_Msk = 0x4
	// Bit FLASH_PD.
	SYSCON_PDRUNCFG_FLASH_PD = 0x4
	// Powered
	SYSCON_PDRUNCFG_FLASH_PD_POWERED = 0x0
	// Powered down
	SYSCON_PDRUNCFG_FLASH_PD_POWERED_DOWN = 0x1
	// Position of BOD_PD field.
	SYSCON_PDRUNCFG_BOD_PD_Pos = 0x3
	// Bit mask of BOD_PD field.
	SYSCON_PDRUNCFG_BOD_PD_Msk = 0x8
	// Bit BOD_PD.
	SYSCON_PDRUNCFG_BOD_PD = 0x8
	// Powered
	SYSCON_PDRUNCFG_BOD_PD_POWERED = 0x0
	// Powered down
	SYSCON_PDRUNCFG_BOD_PD_POWERED_DOWN = 0x1
	// Position of ADC_PD field.
	SYSCON_PDRUNCFG_ADC_PD_Pos = 0x4
	// Bit mask of ADC_PD field.
	SYSCON_PDRUNCFG_ADC_PD_Msk = 0x10
	// Bit ADC_PD.
	SYSCON_PDRUNCFG_ADC_PD = 0x10
	// Powered
	SYSCON_PDRUNCFG_ADC_PD_POWERED = 0x0
	// Powered down
	SYSCON_PDRUNCFG_ADC_PD_POWERED_DOWN = 0x1
	// Position of SYSOSC_PD field.
	SYSCON_PDRUNCFG_SYSOSC_PD_Pos = 0x5
	// Bit mask of SYSOSC_PD field.
	SYSCON_PDRUNCFG_SYSOSC_PD_Msk = 0x20
	// Bit SYSOSC_PD.
	SYSCON_PDRUNCFG_SYSOSC_PD = 0x20
	// Powered
	SYSCON_PDRUNCFG_SYSOSC_PD_POWERED = 0x0
	// Powered down
	SYSCON_PDRUNCFG_SYSOSC_PD_POWERED_DOWN = 0x1
	// Position of WDTOSC_PD field.
	SYSCON_PDRUNCFG_WDTOSC_PD_Pos = 0x6
	// Bit mask of WDTOSC_PD field.
	SYSCON_PDRUNCFG_WDTOSC_PD_Msk = 0x40
	// Bit WDTOSC_PD.
	SYSCON_PDRUNCFG_WDTOSC_PD = 0x40
	// Powered
	SYSCON_PDRUNCFG_WDTOSC_PD_POWERED = 0x0
	// Powered down
	SYSCON_PDRUNCFG_WDTOSC_PD_POWERED_DOWN = 0x1
	// Position of SYSPLL_PD field.
	SYSCON_PDRUNCFG_SYSPLL_PD_Pos = 0x7
	// Bit mask of SYSPLL_PD field.
	SYSCON_PDRUNCFG_SYSPLL_PD_Msk = 0x80
	// Bit SYSPLL_PD.
	SYSCON_PDRUNCFG_SYSPLL_PD = 0x80
	// Powered
	SYSCON_PDRUNCFG_SYSPLL_PD_POWERED = 0x0
	// Powered down
	SYSCON_PDRUNCFG_SYSPLL_PD_POWERED_DOWN = 0x1
	// Position of NOTUSED0 field.
	SYSCON_PDRUNCFG_NOTUSED0_Pos = 0x8
	// Bit mask of NOTUSED0 field.
	SYSCON_PDRUNCFG_NOTUSED0_Msk = 0x100
	// Bit NOTUSED0.
	SYSCON_PDRUNCFG_NOTUSED0 = 0x100
	// Position of NOTUSED1 field.
	SYSCON_PDRUNCFG_NOTUSED1_Pos = 0x9
	// Bit mask of NOTUSED1 field.
	SYSCON_PDRUNCFG_NOTUSED1_Msk = 0x200
	// Bit NOTUSED1.
	SYSCON_PDRUNCFG_NOTUSED1 = 0x200
	// Position of NOTUSED2 field.
	SYSCON_PDRUNCFG_NOTUSED2_Pos = 0xa
	// Bit mask of NOTUSED2 field.
	SYSCON_PDRUNCFG_NOTUSED2_Msk = 0x400
	// Bit NOTUSED2.
	SYSCON_PDRUNCFG_NOTUSED2 = 0x400
	// Position of NOTUSED3 field.
	SYSCON_PDRUNCFG_NOTUSED3_Pos = 0xb
	// Bit mask of NOTUSED3 field.
	SYSCON_PDRUNCFG_NOTUSED3_Msk = 0x800
	// Bit NOTUSED3.
	SYSCON_PDRUNCFG_NOTUSED3 = 0x800
	// Position of NOTUSED4 field.
	SYSCON_PDRUNCFG_NOTUSED4_Pos = 0xc
	// Bit mask of NOTUSED4 field.
	SYSCON_PDRUNCFG_NOTUSED4_Msk = 0x1000
	// Bit NOTUSED4.
	SYSCON_PDRUNCFG_NOTUSED4 = 0x1000
	// Position of NOTUSED5 field.
	SYSCON_PDRUNCFG_NOTUSED5_Pos = 0xd
	// Bit mask of NOTUSED5 field.
	SYSCON_PDRUNCFG_NOTUSED5_Msk = 0xe000
	// Position of RESERVED field.
	SYSCON_PDRUNCFG_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	SYSCON_PDRUNCFG_RESERVED_Msk = 0xffff0000

	// DEVICE_ID: Device ID register 0 for parts LPC1100, LPC1100C, LPC1100L.
	// Position of DEVICEID field.
	SYSCON_DEVICE_ID_DEVICEID_Pos = 0x0
	// Bit mask of DEVICEID field.
	SYSCON_DEVICE_ID_DEVICEID_Msk = 0xffffffff
)

// Constants for C_CAN: Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx C_CAN controller Modification date=9/19/2011 Major revision=7 Minor revision=not available
const (
	// CANCNTL: CAN control
	// Position of INIT field.
	C_CAN_CANCNTL_INIT_Pos = 0x0
	// Bit mask of INIT field.
	C_CAN_CANCNTL_INIT_Msk = 0x1
	// Bit INIT.
	C_CAN_CANCNTL_INIT = 0x1
	// Normal operation.
	C_CAN_CANCNTL_INIT_NORMAL_OPERATION_ = 0x0
	// Initialization is started. On reset, software needs to initialize the CAN controller.
	C_CAN_CANCNTL_INIT_INITIALIZATION = 0x1
	// Position of IE field.
	C_CAN_CANCNTL_IE_Pos = 0x1
	// Bit mask of IE field.
	C_CAN_CANCNTL_IE_Msk = 0x2
	// Bit IE.
	C_CAN_CANCNTL_IE = 0x2
	// Disable CAN interrupts. The interrupt line is always HIGH.
	C_CAN_CANCNTL_IE_DISABLE_CAN_INTERRUP = 0x0
	// Enable CAN interrupts. The interrupt line is set to LOW and remains LOW until all pending interrupts are cleared.
	C_CAN_CANCNTL_IE_ENABLE_CAN_INTERRUPT = 0x1
	// Position of SIE field.
	C_CAN_CANCNTL_SIE_Pos = 0x2
	// Bit mask of SIE field.
	C_CAN_CANCNTL_SIE_Msk = 0x4
	// Bit SIE.
	C_CAN_CANCNTL_SIE = 0x4
	// Disable status change interrupts. No status change interrupt will be generated.
	C_CAN_CANCNTL_SIE_DISABLE_STATUS_CHANG = 0x0
	// Enable status change interrupts. A status change interrupt will be generated when a message transfer is successfully completed or a CAN bus error is detected.
	C_CAN_CANCNTL_SIE_ENABLE_STATUS_CHANGE = 0x1
	// Position of EIE field.
	C_CAN_CANCNTL_EIE_Pos = 0x3
	// Bit mask of EIE field.
	C_CAN_CANCNTL_EIE_Msk = 0x8
	// Bit EIE.
	C_CAN_CANCNTL_EIE = 0x8
	// Disable error interrupt. No error status interrupt will be generated.
	C_CAN_CANCNTL_EIE_DISABLE_ERROR_INTERR = 0x0
	// Enable error interrupt. A change in the bits BOFF or EWARN in the CANSTAT registers will generate an interrupt.
	C_CAN_CANCNTL_EIE_ENABLE_ERROR_INTERRU = 0x1
	// Position of RESERVED field.
	C_CAN_CANCNTL_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	C_CAN_CANCNTL_RESERVED_Msk = 0x10
	// Bit RESERVED.
	C_CAN_CANCNTL_RESERVED = 0x10
	// Position of DAR field.
	C_CAN_CANCNTL_DAR_Pos = 0x5
	// Bit mask of DAR field.
	C_CAN_CANCNTL_DAR_Msk = 0x20
	// Bit DAR.
	C_CAN_CANCNTL_DAR = 0x20
	// Automatic retransmission of disturbed messages enabled.
	C_CAN_CANCNTL_DAR_ENABLED = 0x0
	// Automatic retransmission disabled.
	C_CAN_CANCNTL_DAR_DISABLED = 0x1
	// Position of CCE field.
	C_CAN_CANCNTL_CCE_Pos = 0x6
	// Bit mask of CCE field.
	C_CAN_CANCNTL_CCE_Msk = 0x40
	// Bit CCE.
	C_CAN_CANCNTL_CCE = 0x40
	// The CPU has no write access to the bit timing register.
	C_CAN_CANCNTL_CCE_NOACCESS = 0x0
	// The CPU has write access to the CANBT register while the INIT bit is one.
	C_CAN_CANCNTL_CCE_ACCESS = 0x1
	// Position of TEST field.
	C_CAN_CANCNTL_TEST_Pos = 0x7
	// Bit mask of TEST field.
	C_CAN_CANCNTL_TEST_Msk = 0x80
	// Bit TEST.
	C_CAN_CANCNTL_TEST = 0x80
	// Normal operation.
	C_CAN_CANCNTL_TEST_NORMAL_OPERATION_ = 0x0
	// Test mode.
	C_CAN_CANCNTL_TEST_TEST_MODE_ = 0x1
	// Position of RESERVED field.
	C_CAN_CANCNTL_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	C_CAN_CANCNTL_RESERVED_Msk = 0xffffff00

	// CANSTAT: Status register
	// Position of LEC field.
	C_CAN_CANSTAT_LEC_Pos = 0x0
	// Bit mask of LEC field.
	C_CAN_CANSTAT_LEC_Msk = 0x7
	// No error.
	C_CAN_CANSTAT_LEC_NO_ERROR_ = 0x0
	// Stuff error: More than 5 equal bits in a sequence have occurred in a part of a received message where this is not allowed.
	C_CAN_CANSTAT_LEC_STUFF_ERROR = 0x1
	// Form error: A fixed format part of a received frame has the wrong format.
	C_CAN_CANSTAT_LEC_FORM_ERROR = 0x2
	// AckError: The message this CAN core transmitted was not acknowledged.
	C_CAN_CANSTAT_LEC_ACKERROR = 0x3
	// Bit1Error: During the transmission of a message (with the exception of the arbitration field), the device wanted to send a HIGH/recessive level (bit of logical value 1), but the monitored bus value was LOW/dominant.
	C_CAN_CANSTAT_LEC_BIT1ERROR = 0x4
	// Bit0Error: During the transmission of a message (or acknowledge bit, or active error flag, or overload flag), the device wanted to send a LOW/dominant level (data or identifier bit logical value 0), but the monitored Bus value was HIGH/recessive. During busoff recovery this status is set each time a sequence of 11 HIGH/recessive bits has been monitored. This enables the CPU to monitor the proceeding of the busoff recovery sequence (indicating the bus is not stuck at LOW/dominant or continuously disturbed).
	C_CAN_CANSTAT_LEC_BIT0ERROR = 0x5
	// CRCError: The CRC checksum was incorrect in the message received.
	C_CAN_CANSTAT_LEC_CRCERROR = 0x6
	// Unused: No CAN bus event was detected (written by the CPU).
	C_CAN_CANSTAT_LEC_UNUSED = 0x7
	// Position of TXOK field.
	C_CAN_CANSTAT_TXOK_Pos = 0x3
	// Bit mask of TXOK field.
	C_CAN_CANSTAT_TXOK_Msk = 0x8
	// Bit TXOK.
	C_CAN_CANSTAT_TXOK = 0x8
	// Since this bit was reset by the CPU, no message has been successfully transmitted.
	C_CAN_CANSTAT_TXOK_NOTRANSMIT = 0x0
	// Since this bit was last reset by the CPU, a message has been successfully transmitted (error free and acknowledged by at least one other node).
	C_CAN_CANSTAT_TXOK_TRANSMIT = 0x1
	// Position of RXOK field.
	C_CAN_CANSTAT_RXOK_Pos = 0x4
	// Bit mask of RXOK field.
	C_CAN_CANSTAT_RXOK_Msk = 0x10
	// Bit RXOK.
	C_CAN_CANSTAT_RXOK = 0x10
	// Since this bit was last reset by the CPU, no message has been successfully transmitted.
	C_CAN_CANSTAT_RXOK_NOTRANSMIT = 0x0
	// Since this bit was last set to zero by the CPU, a message has been successfully received independent of the result of acceptance filtering.
	C_CAN_CANSTAT_RXOK_TRANSMIT = 0x1
	// Position of EPASS field.
	C_CAN_CANSTAT_EPASS_Pos = 0x5
	// Bit mask of EPASS field.
	C_CAN_CANSTAT_EPASS_Msk = 0x20
	// Bit EPASS.
	C_CAN_CANSTAT_EPASS = 0x20
	// The CAN controller is in the error active state.
	C_CAN_CANSTAT_EPASS_ACTIVE = 0x0
	// The CAN controller is in the error passive state as defined in the CAN 2.0 specification.
	C_CAN_CANSTAT_EPASS_PASSIVE = 0x1
	// Position of EWARN field.
	C_CAN_CANSTAT_EWARN_Pos = 0x6
	// Bit mask of EWARN field.
	C_CAN_CANSTAT_EWARN_Msk = 0x40
	// Bit EWARN.
	C_CAN_CANSTAT_EWARN = 0x40
	// Both error counters are below the error warning limit of 96.
	C_CAN_CANSTAT_EWARN_BELOWWARNINGLIM = 0x0
	// At least one of the error counters in the EML has reached the error warning limit of 96.
	C_CAN_CANSTAT_EWARN_WARNINGLIM = 0x1
	// Position of BOFF field.
	C_CAN_CANSTAT_BOFF_Pos = 0x7
	// Bit mask of BOFF field.
	C_CAN_CANSTAT_BOFF_Msk = 0x80
	// Bit BOFF.
	C_CAN_CANSTAT_BOFF = 0x80
	// The CAN module is not in busoff.
	C_CAN_CANSTAT_BOFF_NOTBUSOFF = 0x0
	// The CAN controller is in busoff state.
	C_CAN_CANSTAT_BOFF_BUSOFF = 0x1
	// Position of RESERVED field.
	C_CAN_CANSTAT_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	C_CAN_CANSTAT_RESERVED_Msk = 0xffffff00

	// CANEC: Error counter
	// Position of TEC_7_0 field.
	C_CAN_CANEC_TEC_7_0_Pos = 0x0
	// Bit mask of TEC_7_0 field.
	C_CAN_CANEC_TEC_7_0_Msk = 0xff
	// Position of REC_6_0 field.
	C_CAN_CANEC_REC_6_0_Pos = 0x8
	// Bit mask of REC_6_0 field.
	C_CAN_CANEC_REC_6_0_Msk = 0x7f00
	// Position of RP field.
	C_CAN_CANEC_RP_Pos = 0xf
	// Bit mask of RP field.
	C_CAN_CANEC_RP_Msk = 0x8000
	// Bit RP.
	C_CAN_CANEC_RP = 0x8000
	// The receive counter is below the error passive level.
	C_CAN_CANEC_RP_BELOWERRORPASSIVE = 0x0
	// The receive counter has reached the error passive level as defined in the CAN2.0 specification.
	C_CAN_CANEC_RP_ERRORPASSIVE = 0x1
	// Position of RESERVED field.
	C_CAN_CANEC_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN_CANEC_RESERVED_Msk = 0xffff0000

	// CANBT: Bit timing register
	// Position of BRP field.
	C_CAN_CANBT_BRP_Pos = 0x0
	// Bit mask of BRP field.
	C_CAN_CANBT_BRP_Msk = 0x3f
	// Position of SJW field.
	C_CAN_CANBT_SJW_Pos = 0x6
	// Bit mask of SJW field.
	C_CAN_CANBT_SJW_Msk = 0xc0
	// Position of TSEG1 field.
	C_CAN_CANBT_TSEG1_Pos = 0x8
	// Bit mask of TSEG1 field.
	C_CAN_CANBT_TSEG1_Msk = 0xf00
	// Position of TSEG2 field.
	C_CAN_CANBT_TSEG2_Pos = 0xc
	// Bit mask of TSEG2 field.
	C_CAN_CANBT_TSEG2_Msk = 0x7000
	// Position of RESERVED field.
	C_CAN_CANBT_RESERVED_Pos = 0xf
	// Bit mask of RESERVED field.
	C_CAN_CANBT_RESERVED_Msk = 0xffff8000

	// CANINT: Interrupt register
	// Position of INTID field.
	C_CAN_CANINT_INTID_Pos = 0x0
	// Bit mask of INTID field.
	C_CAN_CANINT_INTID_Msk = 0xffff
	// Position of RESERVED field.
	C_CAN_CANINT_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN_CANINT_RESERVED_Msk = 0xffff0000

	// CANTEST: Test register
	// Position of RESERVED field.
	C_CAN_CANTEST_RESERVED_Pos = 0x0
	// Bit mask of RESERVED field.
	C_CAN_CANTEST_RESERVED_Msk = 0x3
	// Position of BASIC field.
	C_CAN_CANTEST_BASIC_Pos = 0x2
	// Bit mask of BASIC field.
	C_CAN_CANTEST_BASIC_Msk = 0x4
	// Bit BASIC.
	C_CAN_CANTEST_BASIC = 0x4
	// Basic mode disabled.
	C_CAN_CANTEST_BASIC_BASIC_MODE_DISABLED_ = 0x0
	// IF1 registers used as TX buffer, IF2 registers used as RX buffer.
	C_CAN_CANTEST_BASIC_TXRX = 0x1
	// Position of SILENT field.
	C_CAN_CANTEST_SILENT_Pos = 0x3
	// Bit mask of SILENT field.
	C_CAN_CANTEST_SILENT_Msk = 0x8
	// Bit SILENT.
	C_CAN_CANTEST_SILENT = 0x8
	// Normal operation.
	C_CAN_CANTEST_SILENT_NORMAL_OPERATION_ = 0x0
	// The module is in silent mode.
	C_CAN_CANTEST_SILENT_SILENT = 0x1
	// Position of LBACK field.
	C_CAN_CANTEST_LBACK_Pos = 0x4
	// Bit mask of LBACK field.
	C_CAN_CANTEST_LBACK_Msk = 0x10
	// Bit LBACK.
	C_CAN_CANTEST_LBACK = 0x10
	// Loop back mode is disabled.
	C_CAN_CANTEST_LBACK_DISABLED = 0x0
	// Loop back mode is enabled.
	C_CAN_CANTEST_LBACK_ENABLED = 0x1
	// Position of TX field.
	C_CAN_CANTEST_TX_Pos = 0x5
	// Bit mask of TX field.
	C_CAN_CANTEST_TX_Msk = 0x60
	// Level at the CAN_TXD pin is controlled by the CAN controller. This is the value at reset.
	C_CAN_CANTEST_TX_LEVEL = 0x0
	// The sample point can be monitored at the CAN_TXD pin.
	C_CAN_CANTEST_TX_TXD = 0x1
	// CAN_TXD pin is driven LOW/dominant.
	C_CAN_CANTEST_TX_LOW = 0x2
	// CAN_TXD pin is driven HIGH/recessive.
	C_CAN_CANTEST_TX_HIGH = 0x3
	// Position of RX field.
	C_CAN_CANTEST_RX_Pos = 0x7
	// Bit mask of RX field.
	C_CAN_CANTEST_RX_Msk = 0x80
	// Bit RX.
	C_CAN_CANTEST_RX = 0x80
	// The CAN bus is recessive (CAN_RXD = 1).
	C_CAN_CANTEST_RX_RECESSIVE = 0x0
	// The CAN bus is dominant (CAN_RXD = 0).
	C_CAN_CANTEST_RX_DORMANT = 0x1
	// Position of RESERVED field.
	C_CAN_CANTEST_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	C_CAN_CANTEST_RESERVED_Msk = 0xffffff00

	// CANBRPE: Baud rate prescaler extension register
	// Position of BRPE field.
	C_CAN_CANBRPE_BRPE_Pos = 0x0
	// Bit mask of BRPE field.
	C_CAN_CANBRPE_BRPE_Msk = 0xf
	// Position of RESERVED field.
	C_CAN_CANBRPE_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	C_CAN_CANBRPE_RESERVED_Msk = 0xfffffff0

	// CANIF1_CMDREQ: Message interface command request
	// Position of MN field.
	C_CAN_CANIF_CMDREQ_MN_Pos = 0x0
	// Bit mask of MN field.
	C_CAN_CANIF_CMDREQ_MN_Msk = 0x3f
	// Position of RESERVED field.
	C_CAN_CANIF_CMDREQ_RESERVED_Pos = 0x6
	// Bit mask of RESERVED field.
	C_CAN_CANIF_CMDREQ_RESERVED_Msk = 0x7fc0
	// Position of BUSY field.
	C_CAN_CANIF_CMDREQ_BUSY_Pos = 0xf
	// Bit mask of BUSY field.
	C_CAN_CANIF_CMDREQ_BUSY_Msk = 0x8000
	// Bit BUSY.
	C_CAN_CANIF_CMDREQ_BUSY = 0x8000
	// Set to zero by hardware when read/write action to this Command request register has finished.
	C_CAN_CANIF_CMDREQ_BUSY_ZERO = 0x0
	// Set to one by hardware when writing to this Command request register.
	C_CAN_CANIF_CMDREQ_BUSY_ONE = 0x1
	// Position of RESERVED field.
	C_CAN_CANIF_CMDREQ_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN_CANIF_CMDREQ_RESERVED_Msk = 0xffff0000

	// CANIF1_CMDMSK_W: Message interface command mask - write direction
	// Position of DATA_B field.
	C_CAN_CANIF_CMDMSK_W_DATA_B_Pos = 0x0
	// Bit mask of DATA_B field.
	C_CAN_CANIF_CMDMSK_W_DATA_B_Msk = 0x1
	// Bit DATA_B.
	C_CAN_CANIF_CMDMSK_W_DATA_B = 0x1
	// Data bytes 4-7 unchanged.
	C_CAN_CANIF_CMDMSK_W_DATA_B_DATA_BYTES_4_7_UNCHA = 0x0
	// Transfer data bytes 4-7 to message object.
	C_CAN_CANIF_CMDMSK_W_DATA_B_TRANSFER_DATA_BYTES_ = 0x1
	// Position of DATA_A field.
	C_CAN_CANIF_CMDMSK_W_DATA_A_Pos = 0x1
	// Bit mask of DATA_A field.
	C_CAN_CANIF_CMDMSK_W_DATA_A_Msk = 0x2
	// Bit DATA_A.
	C_CAN_CANIF_CMDMSK_W_DATA_A = 0x2
	// Data bytes 0-3 unchanged.
	C_CAN_CANIF_CMDMSK_W_DATA_A_DATA_BYTES_0_3_UNCHA = 0x0
	// Transfer data bytes 0-3 to message object.
	C_CAN_CANIF_CMDMSK_W_DATA_A_TRANSFER_DATA_BYTES_ = 0x1
	// Position of TXRQST field.
	C_CAN_CANIF_CMDMSK_W_TXRQST_Pos = 0x2
	// Bit mask of TXRQST field.
	C_CAN_CANIF_CMDMSK_W_TXRQST_Msk = 0x4
	// Bit TXRQST.
	C_CAN_CANIF_CMDMSK_W_TXRQST = 0x4
	// No transmission request. TXRQSRT bit unchanged in IF1/2_MCTRL. If a transmission is requested by programming this bit, the TXRQST bit in the CANIFn_MCTRL register is ignored.
	C_CAN_CANIF_CMDMSK_W_TXRQST_NO_TRANSMISSION_REQU = 0x0
	// Request a transmission. Set the TXRQST bit IF1/2_MCTRL.
	C_CAN_CANIF_CMDMSK_W_TXRQST_REQUEST_A_TRANSMISSI = 0x1
	// Position of CLRINTPND field.
	C_CAN_CANIF_CMDMSK_W_CLRINTPND_Pos = 0x3
	// Bit mask of CLRINTPND field.
	C_CAN_CANIF_CMDMSK_W_CLRINTPND_Msk = 0x8
	// Bit CLRINTPND.
	C_CAN_CANIF_CMDMSK_W_CLRINTPND = 0x8
	// Position of CTRL field.
	C_CAN_CANIF_CMDMSK_W_CTRL_Pos = 0x4
	// Bit mask of CTRL field.
	C_CAN_CANIF_CMDMSK_W_CTRL_Msk = 0x10
	// Bit CTRL.
	C_CAN_CANIF_CMDMSK_W_CTRL = 0x10
	// Control bits unchanged.
	C_CAN_CANIF_CMDMSK_W_CTRL_UNCHANGED = 0x0
	// Transfer control bits to message object
	C_CAN_CANIF_CMDMSK_W_CTRL_TRANSFER_CONTROL_BIT = 0x1
	// Position of ARB field.
	C_CAN_CANIF_CMDMSK_W_ARB_Pos = 0x5
	// Bit mask of ARB field.
	C_CAN_CANIF_CMDMSK_W_ARB_Msk = 0x20
	// Bit ARB.
	C_CAN_CANIF_CMDMSK_W_ARB = 0x20
	// Arbitration bits unchanged.
	C_CAN_CANIF_CMDMSK_W_ARB_UNCHANGED = 0x0
	// Transfer Identifier, DIR, XTD, and MSGVAL bits to message object.
	C_CAN_CANIF_CMDMSK_W_ARB_TRANSFER_IDENTIFIER = 0x1
	// Position of MASK field.
	C_CAN_CANIF_CMDMSK_W_MASK_Pos = 0x6
	// Bit mask of MASK field.
	C_CAN_CANIF_CMDMSK_W_MASK_Msk = 0x40
	// Bit MASK.
	C_CAN_CANIF_CMDMSK_W_MASK = 0x40
	// Mask bits unchanged.
	C_CAN_CANIF_CMDMSK_W_MASK_UNCHANGED = 0x0
	// Transfer Identifier MASK + MDIR + MXTD to message object.
	C_CAN_CANIF_CMDMSK_W_MASK_TRANSFER_IDENTIFIER_ = 0x1
	// Position of WR_RD field.
	C_CAN_CANIF_CMDMSK_W_WR_RD_Pos = 0x7
	// Bit mask of WR_RD field.
	C_CAN_CANIF_CMDMSK_W_WR_RD_Msk = 0x80
	// Bit WR_RD.
	C_CAN_CANIF_CMDMSK_W_WR_RD = 0x80
	// Position of RESERVED field.
	C_CAN_CANIF_CMDMSK_W_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	C_CAN_CANIF_CMDMSK_W_RESERVED_Msk = 0xffffff00

	// CANIF1_CMDMSK_R: Message interface command mask - read direction
	// Position of DATA_B field.
	C_CAN_CANIF_CMDMSK_R_DATA_B_Pos = 0x0
	// Bit mask of DATA_B field.
	C_CAN_CANIF_CMDMSK_R_DATA_B_Msk = 0x1
	// Bit DATA_B.
	C_CAN_CANIF_CMDMSK_R_DATA_B = 0x1
	// Data bytes 4-7 unchanged.
	C_CAN_CANIF_CMDMSK_R_DATA_B_UNCHANGED = 0x0
	// Transfer data bytes 4-7 to IFx message buffer register.
	C_CAN_CANIF_CMDMSK_R_DATA_B_TRANSFER_DATA_BYTES_ = 0x1
	// Position of DATA_A field.
	C_CAN_CANIF_CMDMSK_R_DATA_A_Pos = 0x1
	// Bit mask of DATA_A field.
	C_CAN_CANIF_CMDMSK_R_DATA_A_Msk = 0x2
	// Bit DATA_A.
	C_CAN_CANIF_CMDMSK_R_DATA_A = 0x2
	// Data bytes 0-3 unchanged.
	C_CAN_CANIF_CMDMSK_R_DATA_A_UNCHANGED = 0x0
	// Transfer data bytes 0-3 to IFx message buffer.
	C_CAN_CANIF_CMDMSK_R_DATA_A_TRANSFER_DATA_BYTES_ = 0x1
	// Position of NEWDAT field.
	C_CAN_CANIF_CMDMSK_R_NEWDAT_Pos = 0x2
	// Bit mask of NEWDAT field.
	C_CAN_CANIF_CMDMSK_R_NEWDAT_Msk = 0x4
	// Bit NEWDAT.
	C_CAN_CANIF_CMDMSK_R_NEWDAT = 0x4
	// NEWDAT bit remains unchanged. A read access to a message object can be combined with the reset of the control bits INTPND and NEWDAT in IF1/2_MCTRL. The values of these bits transferred to the IFx Message Control Register always reflect the status before resetting these bits.
	C_CAN_CANIF_CMDMSK_R_NEWDAT_UNCHANGED = 0x0
	// Clear NEWDAT bit in the message object.
	C_CAN_CANIF_CMDMSK_R_NEWDAT_CLEAR_NEWDAT_BIT_IN_ = 0x1
	// Position of CLRINTPND field.
	C_CAN_CANIF_CMDMSK_R_CLRINTPND_Pos = 0x3
	// Bit mask of CLRINTPND field.
	C_CAN_CANIF_CMDMSK_R_CLRINTPND_Msk = 0x8
	// Bit CLRINTPND.
	C_CAN_CANIF_CMDMSK_R_CLRINTPND = 0x8
	// INTPND bit remains unchanged.
	C_CAN_CANIF_CMDMSK_R_CLRINTPND_UNCHANGED = 0x0
	// Clear INTPND bit in the message object.
	C_CAN_CANIF_CMDMSK_R_CLRINTPND_CLEAR_INTPND_BIT_IN_ = 0x1
	// Position of CTRL field.
	C_CAN_CANIF_CMDMSK_R_CTRL_Pos = 0x4
	// Bit mask of CTRL field.
	C_CAN_CANIF_CMDMSK_R_CTRL_Msk = 0x10
	// Bit CTRL.
	C_CAN_CANIF_CMDMSK_R_CTRL = 0x10
	// Control bits unchanged.
	C_CAN_CANIF_CMDMSK_R_CTRL_UNCHANGED = 0x0
	// Transfer control bits to IFx message buffer.
	C_CAN_CANIF_CMDMSK_R_CTRL_TRANSFER_CONTROL_BIT = 0x1
	// Position of ARB field.
	C_CAN_CANIF_CMDMSK_R_ARB_Pos = 0x5
	// Bit mask of ARB field.
	C_CAN_CANIF_CMDMSK_R_ARB_Msk = 0x20
	// Bit ARB.
	C_CAN_CANIF_CMDMSK_R_ARB = 0x20
	// Arbitration bits unchanged.
	C_CAN_CANIF_CMDMSK_R_ARB_UNCHANGED = 0x0
	// Transfer Identifier, DIR, XTD, and MSGVAL bits to IFx message buffer register.
	C_CAN_CANIF_CMDMSK_R_ARB_TRANSFER_IDENTIFIER = 0x1
	// Position of MASK field.
	C_CAN_CANIF_CMDMSK_R_MASK_Pos = 0x6
	// Bit mask of MASK field.
	C_CAN_CANIF_CMDMSK_R_MASK_Msk = 0x40
	// Bit MASK.
	C_CAN_CANIF_CMDMSK_R_MASK = 0x40
	// Mask bits unchanged.
	C_CAN_CANIF_CMDMSK_R_MASK_UNCHANGED = 0x0
	// Transfer Identifier MASK + MDIR + MXTD to IFx message buffer register.
	C_CAN_CANIF_CMDMSK_R_MASK_TRANSFER_IDENTIFIER_ = 0x1
	// Position of WR_RD field.
	C_CAN_CANIF_CMDMSK_R_WR_RD_Pos = 0x7
	// Bit mask of WR_RD field.
	C_CAN_CANIF_CMDMSK_R_WR_RD_Msk = 0x80
	// Bit WR_RD.
	C_CAN_CANIF_CMDMSK_R_WR_RD = 0x80
	// Position of RESERVED field.
	C_CAN_CANIF_CMDMSK_R_RESERVED_Pos = 0x8
	// Bit mask of RESERVED field.
	C_CAN_CANIF_CMDMSK_R_RESERVED_Msk = 0xffffff00

	// CANIF1_MSK1: Message interface 1 mask 1
	// Position of MSK_15_0 field.
	C_CAN_CANIF_MSK1_MSK_15_0_Pos = 0x0
	// Bit mask of MSK_15_0 field.
	C_CAN_CANIF_MSK1_MSK_15_0_Msk = 0xffff
	// The corresponding bit in the identifier of the message can not inhibit the match in the acceptance filtering.
	C_CAN_CANIF_MSK1_MSK_15_0_NOINHIBIT = 0x0
	// The corresponding identifier bit is used for acceptance filtering.
	C_CAN_CANIF_MSK1_MSK_15_0_ACCEPTANCEFILTERING = 0x1
	// Position of RESERVED field.
	C_CAN_CANIF_MSK1_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN_CANIF_MSK1_RESERVED_Msk = 0xffff0000

	// CANIF1_MSK2: Message interface 1 mask 2
	// Position of MSK_28_16 field.
	C_CAN_CANIF_MSK2_MSK_28_16_Pos = 0x0
	// Bit mask of MSK_28_16 field.
	C_CAN_CANIF_MSK2_MSK_28_16_Msk = 0x1fff
	// The corresponding bit in the identifier of the message can not inhibit the match in the acceptance filtering.
	C_CAN_CANIF_MSK2_MSK_28_16_NOINHIBIT = 0x0
	// The corresponding identifier bit is used for acceptance filtering.
	C_CAN_CANIF_MSK2_MSK_28_16_ACCEPTANCEFILTERING = 0x1
	// Position of RESERVED field.
	C_CAN_CANIF_MSK2_RESERVED_Pos = 0xd
	// Bit mask of RESERVED field.
	C_CAN_CANIF_MSK2_RESERVED_Msk = 0x2000
	// Bit RESERVED.
	C_CAN_CANIF_MSK2_RESERVED = 0x2000
	// Position of MDIR field.
	C_CAN_CANIF_MSK2_MDIR_Pos = 0xe
	// Bit mask of MDIR field.
	C_CAN_CANIF_MSK2_MDIR_Msk = 0x4000
	// Bit MDIR.
	C_CAN_CANIF_MSK2_MDIR = 0x4000
	// The message direction bit (DIR) has no effect on acceptance filtering.
	C_CAN_CANIF_MSK2_MDIR_NOEFFECT = 0x0
	// The message direction bit (DIR) is used for acceptance filtering.
	C_CAN_CANIF_MSK2_MDIR_ACCEPTANCEFILTERING = 0x1
	// Position of MXTD field.
	C_CAN_CANIF_MSK2_MXTD_Pos = 0xf
	// Bit mask of MXTD field.
	C_CAN_CANIF_MSK2_MXTD_Msk = 0x8000
	// Bit MXTD.
	C_CAN_CANIF_MSK2_MXTD = 0x8000
	// The extended identifier bit (XTD) has no effect on acceptance filtering.
	C_CAN_CANIF_MSK2_MXTD_NOEFFECT = 0x0
	// The extended identifier bit (XTD) is used for acceptance filtering.
	C_CAN_CANIF_MSK2_MXTD_ACCEPTANCEFILTERING = 0x1
	// Position of RESERVED field.
	C_CAN_CANIF_MSK2_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN_CANIF_MSK2_RESERVED_Msk = 0xffff0000

	// CANIF1_ARB1: Message interface 1 arbitration 1
	// Position of ID_15_0 field.
	C_CAN_CANIF_ARB1_ID_15_0_Pos = 0x0
	// Bit mask of ID_15_0 field.
	C_CAN_CANIF_ARB1_ID_15_0_Msk = 0xffff
	// Position of RESERVED field.
	C_CAN_CANIF_ARB1_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN_CANIF_ARB1_RESERVED_Msk = 0xffff0000

	// CANIF1_ARB2: Message interface 1 arbitration 2
	// Position of ID_28_16 field.
	C_CAN_CANIF_ARB2_ID_28_16_Pos = 0x0
	// Bit mask of ID_28_16 field.
	C_CAN_CANIF_ARB2_ID_28_16_Msk = 0x1fff
	// Position of DIR field.
	C_CAN_CANIF_ARB2_DIR_Pos = 0xd
	// Bit mask of DIR field.
	C_CAN_CANIF_ARB2_DIR_Msk = 0x2000
	// Bit DIR.
	C_CAN_CANIF_ARB2_DIR = 0x2000
	// Direction = receive. On TXRQST, a Remote Frame with the identifier of this Message Object is transmitted. On reception of a Data Frame with matching identifier, that message is stored in this Message Object.
	C_CAN_CANIF_ARB2_DIR_RECEIVE = 0x0
	// Direction = transmit. On TXRQST, the respective Message Object is transmitted as a Data Frame. On reception of a Remote Frame with matching identifier, the TXRQST bit of this Message Object is set (if RMTEN = one).
	C_CAN_CANIF_ARB2_DIR_TRANSMIT = 0x1
	// Position of XTD field.
	C_CAN_CANIF_ARB2_XTD_Pos = 0xe
	// Bit mask of XTD field.
	C_CAN_CANIF_ARB2_XTD_Msk = 0x4000
	// Bit XTD.
	C_CAN_CANIF_ARB2_XTD = 0x4000
	// The 11-bit standard identifier will be used for this message object.
	C_CAN_CANIF_ARB2_XTD_11_BIT_STANDARD_ = 0x0
	// The 29-bit extended identifier will be used for this message object.
	C_CAN_CANIF_ARB2_XTD_29_BIT_EXTENDED_ = 0x1
	// Position of MSGVAL field.
	C_CAN_CANIF_ARB2_MSGVAL_Pos = 0xf
	// Bit mask of MSGVAL field.
	C_CAN_CANIF_ARB2_MSGVAL_Msk = 0x8000
	// Bit MSGVAL.
	C_CAN_CANIF_ARB2_MSGVAL = 0x8000
	// The message object is ignored by the message handler.
	C_CAN_CANIF_ARB2_MSGVAL_IGNORE = 0x0
	// The message object is configured and should be considered by the message handler.
	C_CAN_CANIF_ARB2_MSGVAL_CONFIGURED = 0x1
	// Position of RESERVED field.
	C_CAN_CANIF_ARB2_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN_CANIF_ARB2_RESERVED_Msk = 0xffff0000

	// CANIF1_MCTRL: Message interface 1 message control
	// Position of DLC_3_0 field.
	C_CAN_CANIF_MCTRL_DLC_3_0_Pos = 0x0
	// Bit mask of DLC_3_0 field.
	C_CAN_CANIF_MCTRL_DLC_3_0_Msk = 0xf
	// Position of RESERVED field.
	C_CAN_CANIF_MCTRL_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	C_CAN_CANIF_MCTRL_RESERVED_Msk = 0x70
	// Position of EOB field.
	C_CAN_CANIF_MCTRL_EOB_Pos = 0x7
	// Bit mask of EOB field.
	C_CAN_CANIF_MCTRL_EOB_Msk = 0x80
	// Bit EOB.
	C_CAN_CANIF_MCTRL_EOB = 0x80
	// Message object belongs to a FIFO buffer and is not the last message object of that FIFO buffer.
	C_CAN_CANIF_MCTRL_EOB_FIFO = 0x0
	// Single message object or last message object of a FIFO buffer.
	C_CAN_CANIF_MCTRL_EOB_SINGELAST = 0x1
	// Position of TXRQST field.
	C_CAN_CANIF_MCTRL_TXRQST_Pos = 0x8
	// Bit mask of TXRQST field.
	C_CAN_CANIF_MCTRL_TXRQST_Msk = 0x100
	// Bit TXRQST.
	C_CAN_CANIF_MCTRL_TXRQST = 0x100
	// This message object is not waiting for transmission.
	C_CAN_CANIF_MCTRL_TXRQST_NOWAIT = 0x0
	// The transmission of this message object is requested and is not yet done
	C_CAN_CANIF_MCTRL_TXRQST_WAIT = 0x1
	// Position of RMTEN field.
	C_CAN_CANIF_MCTRL_RMTEN_Pos = 0x9
	// Bit mask of RMTEN field.
	C_CAN_CANIF_MCTRL_RMTEN_Msk = 0x200
	// Bit RMTEN.
	C_CAN_CANIF_MCTRL_RMTEN = 0x200
	// At the reception of a remote frame, TXRQST is left unchanged.
	C_CAN_CANIF_MCTRL_RMTEN_NOCHANGE = 0x0
	// At the reception of a remote frame, TXRQST is set.
	C_CAN_CANIF_MCTRL_RMTEN_SET = 0x1
	// Position of RXIE field.
	C_CAN_CANIF_MCTRL_RXIE_Pos = 0xa
	// Bit mask of RXIE field.
	C_CAN_CANIF_MCTRL_RXIE_Msk = 0x400
	// Bit RXIE.
	C_CAN_CANIF_MCTRL_RXIE = 0x400
	// INTPND will be left unchanged after successful reception of a frame.
	C_CAN_CANIF_MCTRL_RXIE_NOCHANGE = 0x0
	// INTPND will be set after successful reception of a frame.
	C_CAN_CANIF_MCTRL_RXIE_SET = 0x1
	// Position of TXIE field.
	C_CAN_CANIF_MCTRL_TXIE_Pos = 0xb
	// Bit mask of TXIE field.
	C_CAN_CANIF_MCTRL_TXIE_Msk = 0x800
	// Bit TXIE.
	C_CAN_CANIF_MCTRL_TXIE = 0x800
	// The INTPND bit will be left unchanged after a successful transmission of a frame.
	C_CAN_CANIF_MCTRL_TXIE_NOCHANGE = 0x0
	// INTPND will be set after a successful transmission of a frame.
	C_CAN_CANIF_MCTRL_TXIE_SET = 0x1
	// Position of UMASK field.
	C_CAN_CANIF_MCTRL_UMASK_Pos = 0xc
	// Bit mask of UMASK field.
	C_CAN_CANIF_MCTRL_UMASK_Msk = 0x1000
	// Bit UMASK.
	C_CAN_CANIF_MCTRL_UMASK = 0x1000
	// Mask ignored.
	C_CAN_CANIF_MCTRL_UMASK_IGNORE = 0x0
	// Use mask (MSK[28:0], MXTD, and MDIR) for acceptance filtering.
	C_CAN_CANIF_MCTRL_UMASK_USEMASK = 0x1
	// Position of INTPND field.
	C_CAN_CANIF_MCTRL_INTPND_Pos = 0xd
	// Bit mask of INTPND field.
	C_CAN_CANIF_MCTRL_INTPND_Msk = 0x2000
	// Bit INTPND.
	C_CAN_CANIF_MCTRL_INTPND = 0x2000
	// This message object is not the source of an interrupt.
	C_CAN_CANIF_MCTRL_INTPND_NOINTSOURCE = 0x0
	// This message object is the source of an interrupt. The Interrupt Identifier in the Interrupt Register will point to this message object if there is no other interrupt source with higher priority.
	C_CAN_CANIF_MCTRL_INTPND_INTSOURCE = 0x1
	// Position of MSGLST field.
	C_CAN_CANIF_MCTRL_MSGLST_Pos = 0xe
	// Bit mask of MSGLST field.
	C_CAN_CANIF_MCTRL_MSGLST_Msk = 0x4000
	// Bit MSGLST.
	C_CAN_CANIF_MCTRL_MSGLST = 0x4000
	// No message lost since this bit was reset last by the CPU.
	C_CAN_CANIF_MCTRL_MSGLST_NOLOST = 0x0
	// The Message Handler stored a new message into this object when NEWDAT was still set, the CPU has lost a message.
	C_CAN_CANIF_MCTRL_MSGLST_NEWMESSAGE = 0x1
	// Position of NEWDAT field.
	C_CAN_CANIF_MCTRL_NEWDAT_Pos = 0xf
	// Bit mask of NEWDAT field.
	C_CAN_CANIF_MCTRL_NEWDAT_Msk = 0x8000
	// Bit NEWDAT.
	C_CAN_CANIF_MCTRL_NEWDAT = 0x8000
	// No new data has been written into the data portion of this message object by the message handler since this flag was cleared last by the CPU.
	C_CAN_CANIF_MCTRL_NEWDAT_NONEWDATA = 0x0
	// The message handler or the CPU has written new data into the data portion of this message object.
	C_CAN_CANIF_MCTRL_NEWDAT_NEWDATA = 0x1
	// Position of RESERVED field.
	C_CAN_CANIF_MCTRL_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN_CANIF_MCTRL_RESERVED_Msk = 0xffff0000

	// CANIF1_DA1: Message interface 1 data A1
	// Position of DATA0 field.
	C_CAN_CANIF_DA1_DATA0_Pos = 0x0
	// Bit mask of DATA0 field.
	C_CAN_CANIF_DA1_DATA0_Msk = 0xff
	// Position of DATA1 field.
	C_CAN_CANIF_DA1_DATA1_Pos = 0x8
	// Bit mask of DATA1 field.
	C_CAN_CANIF_DA1_DATA1_Msk = 0xff00
	// Position of RESERVED field.
	C_CAN_CANIF_DA1_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN_CANIF_DA1_RESERVED_Msk = 0xffff0000

	// CANIF1_DA2: Message interface 1 data A2
	// Position of DATA2 field.
	C_CAN_CANIF_DA2_DATA2_Pos = 0x0
	// Bit mask of DATA2 field.
	C_CAN_CANIF_DA2_DATA2_Msk = 0xff
	// Position of DATA3 field.
	C_CAN_CANIF_DA2_DATA3_Pos = 0x8
	// Bit mask of DATA3 field.
	C_CAN_CANIF_DA2_DATA3_Msk = 0xff00
	// Position of RESERVED field.
	C_CAN_CANIF_DA2_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN_CANIF_DA2_RESERVED_Msk = 0xffff0000

	// CANIF1_DB1: Message interface 1 data B1
	// Position of DATA4 field.
	C_CAN_CANIF_DB1_DATA4_Pos = 0x0
	// Bit mask of DATA4 field.
	C_CAN_CANIF_DB1_DATA4_Msk = 0xff
	// Position of DATA5 field.
	C_CAN_CANIF_DB1_DATA5_Pos = 0x8
	// Bit mask of DATA5 field.
	C_CAN_CANIF_DB1_DATA5_Msk = 0xff00
	// Position of RESERVED field.
	C_CAN_CANIF_DB1_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN_CANIF_DB1_RESERVED_Msk = 0xffff0000

	// CANIF1_DB2: Message interface 1 data B2
	// Position of DATA6 field.
	C_CAN_CANIF_DB2_DATA6_Pos = 0x0
	// Bit mask of DATA6 field.
	C_CAN_CANIF_DB2_DATA6_Msk = 0xff
	// Position of DATA7 field.
	C_CAN_CANIF_DB2_DATA7_Pos = 0x8
	// Bit mask of DATA7 field.
	C_CAN_CANIF_DB2_DATA7_Msk = 0xff00
	// Position of RESERVED field.
	C_CAN_CANIF_DB2_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN_CANIF_DB2_RESERVED_Msk = 0xffff0000

	// CANTXREQ1: Transmission request 1
	// Position of TXRQST_16_1 field.
	C_CAN_CANTXREQ1_TXRQST_16_1_Pos = 0x0
	// Bit mask of TXRQST_16_1 field.
	C_CAN_CANTXREQ1_TXRQST_16_1_Msk = 0xffff
	// Position of RESERVED field.
	C_CAN_CANTXREQ1_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN_CANTXREQ1_RESERVED_Msk = 0xffff0000

	// CANTXREQ2: Transmission request 2
	// Position of TXRQST_32_17 field.
	C_CAN_CANTXREQ2_TXRQST_32_17_Pos = 0x0
	// Bit mask of TXRQST_32_17 field.
	C_CAN_CANTXREQ2_TXRQST_32_17_Msk = 0xffff
	// Position of RESERVED field.
	C_CAN_CANTXREQ2_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN_CANTXREQ2_RESERVED_Msk = 0xffff0000

	// CANND1: New data 1
	// Position of NEWDAT_16_1 field.
	C_CAN_CANND1_NEWDAT_16_1_Pos = 0x0
	// Bit mask of NEWDAT_16_1 field.
	C_CAN_CANND1_NEWDAT_16_1_Msk = 0xffff
	// Position of RESERVED field.
	C_CAN_CANND1_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN_CANND1_RESERVED_Msk = 0xffff0000

	// CANND2: New data 2
	// Position of NEWDAT_32_17 field.
	C_CAN_CANND2_NEWDAT_32_17_Pos = 0x0
	// Bit mask of NEWDAT_32_17 field.
	C_CAN_CANND2_NEWDAT_32_17_Msk = 0xffff
	// Position of RESERVED field.
	C_CAN_CANND2_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN_CANND2_RESERVED_Msk = 0xffff0000

	// CANIR1: Interrupt pending 1
	// Position of INTPND_16_1 field.
	C_CAN_CANIR1_INTPND_16_1_Pos = 0x0
	// Bit mask of INTPND_16_1 field.
	C_CAN_CANIR1_INTPND_16_1_Msk = 0xffff
	// Position of RESERVED field.
	C_CAN_CANIR1_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN_CANIR1_RESERVED_Msk = 0xffff0000

	// CANIR2: Interrupt pending 2
	// Position of INTPND_32_17 field.
	C_CAN_CANIR2_INTPND_32_17_Pos = 0x0
	// Bit mask of INTPND_32_17 field.
	C_CAN_CANIR2_INTPND_32_17_Msk = 0xffff
	// Position of RESERVED field.
	C_CAN_CANIR2_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN_CANIR2_RESERVED_Msk = 0xffff0000

	// CANMSGV1: Message valid 1
	// Position of MSGVAL_16_1 field.
	C_CAN_CANMSGV1_MSGVAL_16_1_Pos = 0x0
	// Bit mask of MSGVAL_16_1 field.
	C_CAN_CANMSGV1_MSGVAL_16_1_Msk = 0xffff
	// Position of RESERVED field.
	C_CAN_CANMSGV1_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN_CANMSGV1_RESERVED_Msk = 0xffff0000

	// CANMSGV2: Message valid 2
	// Position of MSGVAL_32_17 field.
	C_CAN_CANMSGV2_MSGVAL_32_17_Pos = 0x0
	// Bit mask of MSGVAL_32_17 field.
	C_CAN_CANMSGV2_MSGVAL_32_17_Msk = 0xffff
	// Position of RESERVED field.
	C_CAN_CANMSGV2_RESERVED_Pos = 0x10
	// Bit mask of RESERVED field.
	C_CAN_CANMSGV2_RESERVED_Msk = 0xffff0000

	// CANCLKDIV: Can clock divider register
	// Position of CLKDIVVAL field.
	C_CAN_CANCLKDIV_CLKDIVVAL_Pos = 0x0
	// Bit mask of CLKDIVVAL field.
	C_CAN_CANCLKDIV_CLKDIVVAL_Msk = 0xf
	// Position of RESERVED field.
	C_CAN_CANCLKDIV_RESERVED_Pos = 0x4
	// Bit mask of RESERVED field.
	C_CAN_CANCLKDIV_RESERVED_Msk = 0xfffffff0
)

// Constants for GPIO0: GPIO0
const (
	// DATA: Port n data register for pins PIOn_0 to PIOn_11
	// Position of DATA0 field.
	GPIO_DATA_DATA0_Pos = 0x0
	// Bit mask of DATA0 field.
	GPIO_DATA_DATA0_Msk = 0x1
	// Bit DATA0.
	GPIO_DATA_DATA0 = 0x1
	// Position of DATA1 field.
	GPIO_DATA_DATA1_Pos = 0x1
	// Bit mask of DATA1 field.
	GPIO_DATA_DATA1_Msk = 0x2
	// Bit DATA1.
	GPIO_DATA_DATA1 = 0x2
	// Position of DATA2 field.
	GPIO_DATA_DATA2_Pos = 0x2
	// Bit mask of DATA2 field.
	GPIO_DATA_DATA2_Msk = 0x4
	// Bit DATA2.
	GPIO_DATA_DATA2 = 0x4
	// Position of DATA3 field.
	GPIO_DATA_DATA3_Pos = 0x3
	// Bit mask of DATA3 field.
	GPIO_DATA_DATA3_Msk = 0x8
	// Bit DATA3.
	GPIO_DATA_DATA3 = 0x8
	// Position of DATA4 field.
	GPIO_DATA_DATA4_Pos = 0x4
	// Bit mask of DATA4 field.
	GPIO_DATA_DATA4_Msk = 0x10
	// Bit DATA4.
	GPIO_DATA_DATA4 = 0x10
	// Position of DATA5 field.
	GPIO_DATA_DATA5_Pos = 0x5
	// Bit mask of DATA5 field.
	GPIO_DATA_DATA5_Msk = 0x20
	// Bit DATA5.
	GPIO_DATA_DATA5 = 0x20
	// Position of DATA6 field.
	GPIO_DATA_DATA6_Pos = 0x6
	// Bit mask of DATA6 field.
	GPIO_DATA_DATA6_Msk = 0x40
	// Bit DATA6.
	GPIO_DATA_DATA6 = 0x40
	// Position of DATA7 field.
	GPIO_DATA_DATA7_Pos = 0x7
	// Bit mask of DATA7 field.
	GPIO_DATA_DATA7_Msk = 0x80
	// Bit DATA7.
	GPIO_DATA_DATA7 = 0x80
	// Position of DATA8 field.
	GPIO_DATA_DATA8_Pos = 0x8
	// Bit mask of DATA8 field.
	GPIO_DATA_DATA8_Msk = 0x100
	// Bit DATA8.
	GPIO_DATA_DATA8 = 0x100
	// Position of DATA9 field.
	GPIO_DATA_DATA9_Pos = 0x9
	// Bit mask of DATA9 field.
	GPIO_DATA_DATA9_Msk = 0x200
	// Bit DATA9.
	GPIO_DATA_DATA9 = 0x200
	// Position of DATA10 field.
	GPIO_DATA_DATA10_Pos = 0xa
	// Bit mask of DATA10 field.
	GPIO_DATA_DATA10_Msk = 0x400
	// Bit DATA10.
	GPIO_DATA_DATA10 = 0x400
	// Position of DATA11 field.
	GPIO_DATA_DATA11_Pos = 0xb
	// Bit mask of DATA11 field.
	GPIO_DATA_DATA11_Msk = 0x800
	// Bit DATA11.
	GPIO_DATA_DATA11 = 0x800
	// Position of RESERVED field.
	GPIO_DATA_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	GPIO_DATA_RESERVED_Msk = 0xfffff000

	// DIR: Data direction register for port n
	// Position of IO0 field.
	GPIO_DIR_IO0_Pos = 0x0
	// Bit mask of IO0 field.
	GPIO_DIR_IO0_Msk = 0x1
	// Bit IO0.
	GPIO_DIR_IO0 = 0x1
	// Position of IO1 field.
	GPIO_DIR_IO1_Pos = 0x1
	// Bit mask of IO1 field.
	GPIO_DIR_IO1_Msk = 0x2
	// Bit IO1.
	GPIO_DIR_IO1 = 0x2
	// Position of IO2 field.
	GPIO_DIR_IO2_Pos = 0x2
	// Bit mask of IO2 field.
	GPIO_DIR_IO2_Msk = 0x4
	// Bit IO2.
	GPIO_DIR_IO2 = 0x4
	// Position of IO3 field.
	GPIO_DIR_IO3_Pos = 0x3
	// Bit mask of IO3 field.
	GPIO_DIR_IO3_Msk = 0x8
	// Bit IO3.
	GPIO_DIR_IO3 = 0x8
	// Position of IO4 field.
	GPIO_DIR_IO4_Pos = 0x4
	// Bit mask of IO4 field.
	GPIO_DIR_IO4_Msk = 0x10
	// Bit IO4.
	GPIO_DIR_IO4 = 0x10
	// Position of IO5 field.
	GPIO_DIR_IO5_Pos = 0x5
	// Bit mask of IO5 field.
	GPIO_DIR_IO5_Msk = 0x20
	// Bit IO5.
	GPIO_DIR_IO5 = 0x20
	// Position of IO6 field.
	GPIO_DIR_IO6_Pos = 0x6
	// Bit mask of IO6 field.
	GPIO_DIR_IO6_Msk = 0x40
	// Bit IO6.
	GPIO_DIR_IO6 = 0x40
	// Position of IO7 field.
	GPIO_DIR_IO7_Pos = 0x7
	// Bit mask of IO7 field.
	GPIO_DIR_IO7_Msk = 0x80
	// Bit IO7.
	GPIO_DIR_IO7 = 0x80
	// Position of IO8 field.
	GPIO_DIR_IO8_Pos = 0x8
	// Bit mask of IO8 field.
	GPIO_DIR_IO8_Msk = 0x100
	// Bit IO8.
	GPIO_DIR_IO8 = 0x100
	// Position of IO9 field.
	GPIO_DIR_IO9_Pos = 0x9
	// Bit mask of IO9 field.
	GPIO_DIR_IO9_Msk = 0x200
	// Bit IO9.
	GPIO_DIR_IO9 = 0x200
	// Position of IO10 field.
	GPIO_DIR_IO10_Pos = 0xa
	// Bit mask of IO10 field.
	GPIO_DIR_IO10_Msk = 0x400
	// Bit IO10.
	GPIO_DIR_IO10 = 0x400
	// Position of IO11 field.
	GPIO_DIR_IO11_Pos = 0xb
	// Bit mask of IO11 field.
	GPIO_DIR_IO11_Msk = 0x800
	// Bit IO11.
	GPIO_DIR_IO11 = 0x800
	// Position of RESERVED field.
	GPIO_DIR_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	GPIO_DIR_RESERVED_Msk = 0xfffff000

	// IS: Interrupt sense register for port n
	// Position of ISENSE0 field.
	GPIO_IS_ISENSE0_Pos = 0x0
	// Bit mask of ISENSE0 field.
	GPIO_IS_ISENSE0_Msk = 0x1
	// Bit ISENSE0.
	GPIO_IS_ISENSE0 = 0x1
	// Position of ISENSE1 field.
	GPIO_IS_ISENSE1_Pos = 0x1
	// Bit mask of ISENSE1 field.
	GPIO_IS_ISENSE1_Msk = 0x2
	// Bit ISENSE1.
	GPIO_IS_ISENSE1 = 0x2
	// Position of ISENSE2 field.
	GPIO_IS_ISENSE2_Pos = 0x2
	// Bit mask of ISENSE2 field.
	GPIO_IS_ISENSE2_Msk = 0x4
	// Bit ISENSE2.
	GPIO_IS_ISENSE2 = 0x4
	// Position of ISENSE3 field.
	GPIO_IS_ISENSE3_Pos = 0x3
	// Bit mask of ISENSE3 field.
	GPIO_IS_ISENSE3_Msk = 0x8
	// Bit ISENSE3.
	GPIO_IS_ISENSE3 = 0x8
	// Position of ISENSE4 field.
	GPIO_IS_ISENSE4_Pos = 0x4
	// Bit mask of ISENSE4 field.
	GPIO_IS_ISENSE4_Msk = 0x10
	// Bit ISENSE4.
	GPIO_IS_ISENSE4 = 0x10
	// Position of ISENSE5 field.
	GPIO_IS_ISENSE5_Pos = 0x5
	// Bit mask of ISENSE5 field.
	GPIO_IS_ISENSE5_Msk = 0x20
	// Bit ISENSE5.
	GPIO_IS_ISENSE5 = 0x20
	// Position of ISENSE6 field.
	GPIO_IS_ISENSE6_Pos = 0x6
	// Bit mask of ISENSE6 field.
	GPIO_IS_ISENSE6_Msk = 0x40
	// Bit ISENSE6.
	GPIO_IS_ISENSE6 = 0x40
	// Position of ISENSE7 field.
	GPIO_IS_ISENSE7_Pos = 0x7
	// Bit mask of ISENSE7 field.
	GPIO_IS_ISENSE7_Msk = 0x80
	// Bit ISENSE7.
	GPIO_IS_ISENSE7 = 0x80
	// Position of ISENSE8 field.
	GPIO_IS_ISENSE8_Pos = 0x8
	// Bit mask of ISENSE8 field.
	GPIO_IS_ISENSE8_Msk = 0x100
	// Bit ISENSE8.
	GPIO_IS_ISENSE8 = 0x100
	// Position of ISENSE9 field.
	GPIO_IS_ISENSE9_Pos = 0x9
	// Bit mask of ISENSE9 field.
	GPIO_IS_ISENSE9_Msk = 0x200
	// Bit ISENSE9.
	GPIO_IS_ISENSE9 = 0x200
	// Position of ISENSE10 field.
	GPIO_IS_ISENSE10_Pos = 0xa
	// Bit mask of ISENSE10 field.
	GPIO_IS_ISENSE10_Msk = 0x400
	// Bit ISENSE10.
	GPIO_IS_ISENSE10 = 0x400
	// Position of ISENSE11 field.
	GPIO_IS_ISENSE11_Pos = 0xb
	// Bit mask of ISENSE11 field.
	GPIO_IS_ISENSE11_Msk = 0x800
	// Bit ISENSE11.
	GPIO_IS_ISENSE11 = 0x800
	// Position of RESERVED field.
	GPIO_IS_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	GPIO_IS_RESERVED_Msk = 0xfffff000

	// IBE: Interrupt both edges register for port n
	// Position of IBE0 field.
	GPIO_IBE_IBE0_Pos = 0x0
	// Bit mask of IBE0 field.
	GPIO_IBE_IBE0_Msk = 0x1
	// Bit IBE0.
	GPIO_IBE_IBE0 = 0x1
	// Position of IBE1 field.
	GPIO_IBE_IBE1_Pos = 0x1
	// Bit mask of IBE1 field.
	GPIO_IBE_IBE1_Msk = 0x2
	// Bit IBE1.
	GPIO_IBE_IBE1 = 0x2
	// Position of IBE2 field.
	GPIO_IBE_IBE2_Pos = 0x2
	// Bit mask of IBE2 field.
	GPIO_IBE_IBE2_Msk = 0x4
	// Bit IBE2.
	GPIO_IBE_IBE2 = 0x4
	// Position of IBE3 field.
	GPIO_IBE_IBE3_Pos = 0x3
	// Bit mask of IBE3 field.
	GPIO_IBE_IBE3_Msk = 0x8
	// Bit IBE3.
	GPIO_IBE_IBE3 = 0x8
	// Position of IBE4 field.
	GPIO_IBE_IBE4_Pos = 0x4
	// Bit mask of IBE4 field.
	GPIO_IBE_IBE4_Msk = 0x10
	// Bit IBE4.
	GPIO_IBE_IBE4 = 0x10
	// Position of IBE5 field.
	GPIO_IBE_IBE5_Pos = 0x5
	// Bit mask of IBE5 field.
	GPIO_IBE_IBE5_Msk = 0x20
	// Bit IBE5.
	GPIO_IBE_IBE5 = 0x20
	// Position of IBE6 field.
	GPIO_IBE_IBE6_Pos = 0x6
	// Bit mask of IBE6 field.
	GPIO_IBE_IBE6_Msk = 0x40
	// Bit IBE6.
	GPIO_IBE_IBE6 = 0x40
	// Position of IBE7 field.
	GPIO_IBE_IBE7_Pos = 0x7
	// Bit mask of IBE7 field.
	GPIO_IBE_IBE7_Msk = 0x80
	// Bit IBE7.
	GPIO_IBE_IBE7 = 0x80
	// Position of IBE8 field.
	GPIO_IBE_IBE8_Pos = 0x8
	// Bit mask of IBE8 field.
	GPIO_IBE_IBE8_Msk = 0x100
	// Bit IBE8.
	GPIO_IBE_IBE8 = 0x100
	// Position of IBE9 field.
	GPIO_IBE_IBE9_Pos = 0x9
	// Bit mask of IBE9 field.
	GPIO_IBE_IBE9_Msk = 0x200
	// Bit IBE9.
	GPIO_IBE_IBE9 = 0x200
	// Position of IBE10 field.
	GPIO_IBE_IBE10_Pos = 0xa
	// Bit mask of IBE10 field.
	GPIO_IBE_IBE10_Msk = 0x400
	// Bit IBE10.
	GPIO_IBE_IBE10 = 0x400
	// Position of IBE11 field.
	GPIO_IBE_IBE11_Pos = 0xb
	// Bit mask of IBE11 field.
	GPIO_IBE_IBE11_Msk = 0x800
	// Bit IBE11.
	GPIO_IBE_IBE11 = 0x800
	// Position of RESERVED field.
	GPIO_IBE_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	GPIO_IBE_RESERVED_Msk = 0xfffff000

	// IEV: Interrupt event register for port n
	// Position of IEV0 field.
	GPIO_IEV_IEV0_Pos = 0x0
	// Bit mask of IEV0 field.
	GPIO_IEV_IEV0_Msk = 0x1
	// Bit IEV0.
	GPIO_IEV_IEV0 = 0x1
	// Position of IEV1 field.
	GPIO_IEV_IEV1_Pos = 0x1
	// Bit mask of IEV1 field.
	GPIO_IEV_IEV1_Msk = 0x2
	// Bit IEV1.
	GPIO_IEV_IEV1 = 0x2
	// Position of IEV2 field.
	GPIO_IEV_IEV2_Pos = 0x2
	// Bit mask of IEV2 field.
	GPIO_IEV_IEV2_Msk = 0x4
	// Bit IEV2.
	GPIO_IEV_IEV2 = 0x4
	// Position of IEV3 field.
	GPIO_IEV_IEV3_Pos = 0x3
	// Bit mask of IEV3 field.
	GPIO_IEV_IEV3_Msk = 0x8
	// Bit IEV3.
	GPIO_IEV_IEV3 = 0x8
	// Position of IEV4 field.
	GPIO_IEV_IEV4_Pos = 0x4
	// Bit mask of IEV4 field.
	GPIO_IEV_IEV4_Msk = 0x10
	// Bit IEV4.
	GPIO_IEV_IEV4 = 0x10
	// Position of IEV5 field.
	GPIO_IEV_IEV5_Pos = 0x5
	// Bit mask of IEV5 field.
	GPIO_IEV_IEV5_Msk = 0x20
	// Bit IEV5.
	GPIO_IEV_IEV5 = 0x20
	// Position of IEV6 field.
	GPIO_IEV_IEV6_Pos = 0x6
	// Bit mask of IEV6 field.
	GPIO_IEV_IEV6_Msk = 0x40
	// Bit IEV6.
	GPIO_IEV_IEV6 = 0x40
	// Position of IEV7 field.
	GPIO_IEV_IEV7_Pos = 0x7
	// Bit mask of IEV7 field.
	GPIO_IEV_IEV7_Msk = 0x80
	// Bit IEV7.
	GPIO_IEV_IEV7 = 0x80
	// Position of IEV8 field.
	GPIO_IEV_IEV8_Pos = 0x8
	// Bit mask of IEV8 field.
	GPIO_IEV_IEV8_Msk = 0x100
	// Bit IEV8.
	GPIO_IEV_IEV8 = 0x100
	// Position of IEV9 field.
	GPIO_IEV_IEV9_Pos = 0x9
	// Bit mask of IEV9 field.
	GPIO_IEV_IEV9_Msk = 0x200
	// Bit IEV9.
	GPIO_IEV_IEV9 = 0x200
	// Position of IEV10 field.
	GPIO_IEV_IEV10_Pos = 0xa
	// Bit mask of IEV10 field.
	GPIO_IEV_IEV10_Msk = 0x400
	// Bit IEV10.
	GPIO_IEV_IEV10 = 0x400
	// Position of IEV11 field.
	GPIO_IEV_IEV11_Pos = 0xb
	// Bit mask of IEV11 field.
	GPIO_IEV_IEV11_Msk = 0x800
	// Bit IEV11.
	GPIO_IEV_IEV11 = 0x800
	// Position of RESERVED field.
	GPIO_IEV_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	GPIO_IEV_RESERVED_Msk = 0xfffff000

	// IE: Interrupt mask register for port n
	// Position of MASK0 field.
	GPIO_IE_MASK0_Pos = 0x0
	// Bit mask of MASK0 field.
	GPIO_IE_MASK0_Msk = 0x1
	// Bit MASK0.
	GPIO_IE_MASK0 = 0x1
	// Position of MASK1 field.
	GPIO_IE_MASK1_Pos = 0x1
	// Bit mask of MASK1 field.
	GPIO_IE_MASK1_Msk = 0x2
	// Bit MASK1.
	GPIO_IE_MASK1 = 0x2
	// Position of MASK2 field.
	GPIO_IE_MASK2_Pos = 0x2
	// Bit mask of MASK2 field.
	GPIO_IE_MASK2_Msk = 0x4
	// Bit MASK2.
	GPIO_IE_MASK2 = 0x4
	// Position of MASK3 field.
	GPIO_IE_MASK3_Pos = 0x3
	// Bit mask of MASK3 field.
	GPIO_IE_MASK3_Msk = 0x8
	// Bit MASK3.
	GPIO_IE_MASK3 = 0x8
	// Position of MASK4 field.
	GPIO_IE_MASK4_Pos = 0x4
	// Bit mask of MASK4 field.
	GPIO_IE_MASK4_Msk = 0x10
	// Bit MASK4.
	GPIO_IE_MASK4 = 0x10
	// Position of MASK5 field.
	GPIO_IE_MASK5_Pos = 0x5
	// Bit mask of MASK5 field.
	GPIO_IE_MASK5_Msk = 0x20
	// Bit MASK5.
	GPIO_IE_MASK5 = 0x20
	// Position of MASK6 field.
	GPIO_IE_MASK6_Pos = 0x6
	// Bit mask of MASK6 field.
	GPIO_IE_MASK6_Msk = 0x40
	// Bit MASK6.
	GPIO_IE_MASK6 = 0x40
	// Position of MASK7 field.
	GPIO_IE_MASK7_Pos = 0x7
	// Bit mask of MASK7 field.
	GPIO_IE_MASK7_Msk = 0x80
	// Bit MASK7.
	GPIO_IE_MASK7 = 0x80
	// Position of MASK8 field.
	GPIO_IE_MASK8_Pos = 0x8
	// Bit mask of MASK8 field.
	GPIO_IE_MASK8_Msk = 0x100
	// Bit MASK8.
	GPIO_IE_MASK8 = 0x100
	// Position of MASK9 field.
	GPIO_IE_MASK9_Pos = 0x9
	// Bit mask of MASK9 field.
	GPIO_IE_MASK9_Msk = 0x200
	// Bit MASK9.
	GPIO_IE_MASK9 = 0x200
	// Position of MASK10 field.
	GPIO_IE_MASK10_Pos = 0xa
	// Bit mask of MASK10 field.
	GPIO_IE_MASK10_Msk = 0x400
	// Bit MASK10.
	GPIO_IE_MASK10 = 0x400
	// Position of MASK11 field.
	GPIO_IE_MASK11_Pos = 0xb
	// Bit mask of MASK11 field.
	GPIO_IE_MASK11_Msk = 0x800
	// Bit MASK11.
	GPIO_IE_MASK11 = 0x800
	// Position of RESERVED field.
	GPIO_IE_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	GPIO_IE_RESERVED_Msk = 0xfffff000

	// RIS: Raw interrupt status register for port n
	// Position of RAWST0 field.
	GPIO_RIS_RAWST0_Pos = 0x0
	// Bit mask of RAWST0 field.
	GPIO_RIS_RAWST0_Msk = 0x1
	// Bit RAWST0.
	GPIO_RIS_RAWST0 = 0x1
	// Position of RAWST1 field.
	GPIO_RIS_RAWST1_Pos = 0x1
	// Bit mask of RAWST1 field.
	GPIO_RIS_RAWST1_Msk = 0x2
	// Bit RAWST1.
	GPIO_RIS_RAWST1 = 0x2
	// Position of RAWST2 field.
	GPIO_RIS_RAWST2_Pos = 0x2
	// Bit mask of RAWST2 field.
	GPIO_RIS_RAWST2_Msk = 0x4
	// Bit RAWST2.
	GPIO_RIS_RAWST2 = 0x4
	// Position of RAWST3 field.
	GPIO_RIS_RAWST3_Pos = 0x3
	// Bit mask of RAWST3 field.
	GPIO_RIS_RAWST3_Msk = 0x8
	// Bit RAWST3.
	GPIO_RIS_RAWST3 = 0x8
	// Position of RAWST4 field.
	GPIO_RIS_RAWST4_Pos = 0x4
	// Bit mask of RAWST4 field.
	GPIO_RIS_RAWST4_Msk = 0x10
	// Bit RAWST4.
	GPIO_RIS_RAWST4 = 0x10
	// Position of RAWST5 field.
	GPIO_RIS_RAWST5_Pos = 0x5
	// Bit mask of RAWST5 field.
	GPIO_RIS_RAWST5_Msk = 0x20
	// Bit RAWST5.
	GPIO_RIS_RAWST5 = 0x20
	// Position of RAWST6 field.
	GPIO_RIS_RAWST6_Pos = 0x6
	// Bit mask of RAWST6 field.
	GPIO_RIS_RAWST6_Msk = 0x40
	// Bit RAWST6.
	GPIO_RIS_RAWST6 = 0x40
	// Position of RAWST7 field.
	GPIO_RIS_RAWST7_Pos = 0x7
	// Bit mask of RAWST7 field.
	GPIO_RIS_RAWST7_Msk = 0x80
	// Bit RAWST7.
	GPIO_RIS_RAWST7 = 0x80
	// Position of RAWST8 field.
	GPIO_RIS_RAWST8_Pos = 0x8
	// Bit mask of RAWST8 field.
	GPIO_RIS_RAWST8_Msk = 0x100
	// Bit RAWST8.
	GPIO_RIS_RAWST8 = 0x100
	// Position of RAWST9 field.
	GPIO_RIS_RAWST9_Pos = 0x9
	// Bit mask of RAWST9 field.
	GPIO_RIS_RAWST9_Msk = 0x200
	// Bit RAWST9.
	GPIO_RIS_RAWST9 = 0x200
	// Position of RAWST10 field.
	GPIO_RIS_RAWST10_Pos = 0xa
	// Bit mask of RAWST10 field.
	GPIO_RIS_RAWST10_Msk = 0x400
	// Bit RAWST10.
	GPIO_RIS_RAWST10 = 0x400
	// Position of RAWST11 field.
	GPIO_RIS_RAWST11_Pos = 0xb
	// Bit mask of RAWST11 field.
	GPIO_RIS_RAWST11_Msk = 0x800
	// Bit RAWST11.
	GPIO_RIS_RAWST11 = 0x800
	// Position of RESERVED field.
	GPIO_RIS_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	GPIO_RIS_RESERVED_Msk = 0xfffff000

	// MIS: Masked interrupt status register for port n
	// Position of MASK0 field.
	GPIO_MIS_MASK0_Pos = 0x0
	// Bit mask of MASK0 field.
	GPIO_MIS_MASK0_Msk = 0x1
	// Bit MASK0.
	GPIO_MIS_MASK0 = 0x1
	// Position of MASK1 field.
	GPIO_MIS_MASK1_Pos = 0x1
	// Bit mask of MASK1 field.
	GPIO_MIS_MASK1_Msk = 0x2
	// Bit MASK1.
	GPIO_MIS_MASK1 = 0x2
	// Position of MASK2 field.
	GPIO_MIS_MASK2_Pos = 0x2
	// Bit mask of MASK2 field.
	GPIO_MIS_MASK2_Msk = 0x4
	// Bit MASK2.
	GPIO_MIS_MASK2 = 0x4
	// Position of MASK3 field.
	GPIO_MIS_MASK3_Pos = 0x3
	// Bit mask of MASK3 field.
	GPIO_MIS_MASK3_Msk = 0x8
	// Bit MASK3.
	GPIO_MIS_MASK3 = 0x8
	// Position of MASK4 field.
	GPIO_MIS_MASK4_Pos = 0x4
	// Bit mask of MASK4 field.
	GPIO_MIS_MASK4_Msk = 0x10
	// Bit MASK4.
	GPIO_MIS_MASK4 = 0x10
	// Position of MASK5 field.
	GPIO_MIS_MASK5_Pos = 0x5
	// Bit mask of MASK5 field.
	GPIO_MIS_MASK5_Msk = 0x20
	// Bit MASK5.
	GPIO_MIS_MASK5 = 0x20
	// Position of MASK6 field.
	GPIO_MIS_MASK6_Pos = 0x6
	// Bit mask of MASK6 field.
	GPIO_MIS_MASK6_Msk = 0x40
	// Bit MASK6.
	GPIO_MIS_MASK6 = 0x40
	// Position of MASK7 field.
	GPIO_MIS_MASK7_Pos = 0x7
	// Bit mask of MASK7 field.
	GPIO_MIS_MASK7_Msk = 0x80
	// Bit MASK7.
	GPIO_MIS_MASK7 = 0x80
	// Position of MASK8 field.
	GPIO_MIS_MASK8_Pos = 0x8
	// Bit mask of MASK8 field.
	GPIO_MIS_MASK8_Msk = 0x100
	// Bit MASK8.
	GPIO_MIS_MASK8 = 0x100
	// Position of MASK9 field.
	GPIO_MIS_MASK9_Pos = 0x9
	// Bit mask of MASK9 field.
	GPIO_MIS_MASK9_Msk = 0x200
	// Bit MASK9.
	GPIO_MIS_MASK9 = 0x200
	// Position of MASK10 field.
	GPIO_MIS_MASK10_Pos = 0xa
	// Bit mask of MASK10 field.
	GPIO_MIS_MASK10_Msk = 0x400
	// Bit MASK10.
	GPIO_MIS_MASK10 = 0x400
	// Position of MASK11 field.
	GPIO_MIS_MASK11_Pos = 0xb
	// Bit mask of MASK11 field.
	GPIO_MIS_MASK11_Msk = 0x800
	// Bit MASK11.
	GPIO_MIS_MASK11 = 0x800
	// Position of RESERVED field.
	GPIO_MIS_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	GPIO_MIS_RESERVED_Msk = 0xfffff000

	// IC: Interrupt clear register for port n
	// Position of CLR0 field.
	GPIO_IC_CLR0_Pos = 0x0
	// Bit mask of CLR0 field.
	GPIO_IC_CLR0_Msk = 0x1
	// Bit CLR0.
	GPIO_IC_CLR0 = 0x1
	// Position of CLR1 field.
	GPIO_IC_CLR1_Pos = 0x1
	// Bit mask of CLR1 field.
	GPIO_IC_CLR1_Msk = 0x2
	// Bit CLR1.
	GPIO_IC_CLR1 = 0x2
	// Position of CLR2 field.
	GPIO_IC_CLR2_Pos = 0x2
	// Bit mask of CLR2 field.
	GPIO_IC_CLR2_Msk = 0x4
	// Bit CLR2.
	GPIO_IC_CLR2 = 0x4
	// Position of CLR3 field.
	GPIO_IC_CLR3_Pos = 0x3
	// Bit mask of CLR3 field.
	GPIO_IC_CLR3_Msk = 0x8
	// Bit CLR3.
	GPIO_IC_CLR3 = 0x8
	// Position of CLR4 field.
	GPIO_IC_CLR4_Pos = 0x4
	// Bit mask of CLR4 field.
	GPIO_IC_CLR4_Msk = 0x10
	// Bit CLR4.
	GPIO_IC_CLR4 = 0x10
	// Position of CLR5 field.
	GPIO_IC_CLR5_Pos = 0x5
	// Bit mask of CLR5 field.
	GPIO_IC_CLR5_Msk = 0x20
	// Bit CLR5.
	GPIO_IC_CLR5 = 0x20
	// Position of CLR6 field.
	GPIO_IC_CLR6_Pos = 0x6
	// Bit mask of CLR6 field.
	GPIO_IC_CLR6_Msk = 0x40
	// Bit CLR6.
	GPIO_IC_CLR6 = 0x40
	// Position of CLR7 field.
	GPIO_IC_CLR7_Pos = 0x7
	// Bit mask of CLR7 field.
	GPIO_IC_CLR7_Msk = 0x80
	// Bit CLR7.
	GPIO_IC_CLR7 = 0x80
	// Position of CLR8 field.
	GPIO_IC_CLR8_Pos = 0x8
	// Bit mask of CLR8 field.
	GPIO_IC_CLR8_Msk = 0x100
	// Bit CLR8.
	GPIO_IC_CLR8 = 0x100
	// Position of CLR9 field.
	GPIO_IC_CLR9_Pos = 0x9
	// Bit mask of CLR9 field.
	GPIO_IC_CLR9_Msk = 0x200
	// Bit CLR9.
	GPIO_IC_CLR9 = 0x200
	// Position of CLR10 field.
	GPIO_IC_CLR10_Pos = 0xa
	// Bit mask of CLR10 field.
	GPIO_IC_CLR10_Msk = 0x400
	// Bit CLR10.
	GPIO_IC_CLR10 = 0x400
	// Position of CLR11 field.
	GPIO_IC_CLR11_Pos = 0xb
	// Bit mask of CLR11 field.
	GPIO_IC_CLR11_Msk = 0x800
	// Bit CLR11.
	GPIO_IC_CLR11 = 0x800
	// Position of RESERVED field.
	GPIO_IC_RESERVED_Pos = 0xc
	// Bit mask of RESERVED field.
	GPIO_IC_RESERVED_Msk = 0xfffff000
)
